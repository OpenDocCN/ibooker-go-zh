- en: 'Chapter 10\. keep it to yourself: Encapsulation and Embedding'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。保持低调：封装和嵌入
- en: '![image](assets/f0289-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0289-01.png)'
- en: '**Mistakes happen.** Sometimes, your program will receive invalid data from
    user input, a file you’re reading in, or elsewhere. In this chapter, you’ll learn
    about **encapsulation**: a way to protect your struct type’s fields from that
    invalid data. That way, you’ll know your field data is safe to work with!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误是难免的。** 有时，您的程序将从用户输入、正在读取的文件或其他地方接收到无效数据。在本章中，您将学习**封装**：一种保护结构类型字段免受无效数据影响的方法。这样，您就知道您的字段数据是安全的！'
- en: We’ll also show you how to **embed** other types within your struct type. If
    your struct type needs methods that already exist on another type, you don’t have
    to copy and paste the method code. You can embed the other type within your struct
    type, and then use the embedded type’s methods just as if they were defined on
    your own type!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向您展示如何在您的结构类型中**嵌入**其他类型。如果您的结构类型需要另一类型上已存在的方法，您无需复制和粘贴方法代码。您可以将其他类型嵌入到您的结构类型中，然后像在自己的类型上定义一样使用嵌入类型的方法！
- en: Creating a Date struct type
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个`Date`结构类型
- en: A local startup called Remind Me is developing a calendar application to help
    users remember birthdays, anniversaries, and more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为Remind Me的本地初创公司正在开发一个日历应用，帮助用户记住生日、周年纪念日等。
- en: '![image](assets/f0290-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0290-01.png)'
- en: The year, month, and day sound like they all need to be grouped together; none
    of those values would be useful by itself. A struct type would probably be useful
    for keeping those separate values together in a single bundle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 年、月和日听起来都需要被组合在一起；这些值单独来看可能不是很有用。结构类型可能对于在一个单一的捆绑中保持这些单独的值是有用的。
- en: As we’ve seen, defined types can use any other type as their underlying type,
    including structs. In fact, struct types served as our introduction to defined
    types, back in [Chapter 8](ch08.html#building_storagecolon_structs).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，定义的类型可以使用任何其他类型作为它们的基础类型，包括结构体。事实上，结构体类型作为我们在[第8章](ch08.html#building_storagecolon_structs)中对定义类型的介绍。
- en: Let’s create a `Date` struct type to hold our year, month, and day values. We’ll
    add `Year`, `Month`, and `Day` fields to the struct, each with a type of `int`.
    In our `main` function, we’ll run a quick test of the new type, using a struct
    literal to create a `Date` value with all its fields populated. We’ll just use
    `Println` to print the `Date` out for now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Date`结构类型来保存我们的年、月和日值。我们将在结构中添加`Year`、`Month`和`Day`字段，每个字段的类型都是`int`。在我们的`main`函数中，我们将使用结构字面量快速测试新类型，使用`Println`暂时打印`Date`。
- en: '![image](assets/f0290-02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0290-02.png)'
- en: If we run the finished program, we’ll see the `Year`, `Month`, and `Day` fields
    of our `Date` struct. It looks like everything’s working!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行完成的程序，我们将看到我们的`Date`结构的`Year`、`Month`和`Day`字段。看起来一切正常！
- en: People are setting the Date struct field to invalid values!
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人们将`Date`结构字段设置为无效值！
- en: '![image](assets/f0291-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0291-01.png)'
- en: Ah, we can see how that might happen. Only year numbers `1` or greater are valid,
    but we don’t have anything preventing users from accidentally setting the `Year`
    field to `0` or `-999`. Only month numbers from `1` through `12` are valid, but
    nothing prevents users from setting the `Month` field to `0` or `13`. Only the
    numbers `1` through `31` are valid for the `Day` field, but users can enter days
    like `-2` or `50`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，我们可以看到可能发生的情况。只有大于等于`1`的年份是有效的，但我们没有任何东西阻止用户意外将`Year`字段设置为`0`或`-999`。只有从`1`到`12`的月份号码是有效的，但没有任何东西阻止用户将`Month`字段设置为`0`或`13`。`Day`字段只有从`1`到`31`的数字是有效的，但用户可以输入像`-2`或`50`这样的天数。
- en: '![image](assets/f0291-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0291-02.png)'
- en: What we need is a way for our programs to ensure the user data is valid before
    accepting it. In computer science, this is known as *data validation*. We need
    to test that the `Year` is being set to a value of `1` or greater, the `Month`
    is being set between `1` and `12`, and the `Day` is being set between `1` and
    `31`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来确保用户数据在接受之前是有效的。在计算机科学中，这称为*数据验证*。我们需要测试`Year`是否被设置为大于等于`1`的值，`Month`是否在`1`到`12`之间，以及`Day`是否在`1`到`31`之间。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: (Yes, some months have fewer than 31 days, but to keep our code samples a reasonable
    length, we’ll just check that it’s between 1 and 31.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，有些月份少于31天，但为了保持我们的代码示例长度合理，我们将仅检查它是否介于1和31之间。）
- en: Setter methods
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置方法
- en: A struct type is just another defined type, and that means you can define methods
    on it just like any other. We should be able to create `SetYear`, `SetMonth`,
    and `SetDay` methods on the `Date` type that take a value, check whether it’s
    valid, and if so, set the appropriate struct field.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型只是另一种定义的类型，这意味着你可以像任何其他类型一样在其上定义方法。我们应该能够在`Date`类型上创建`SetYear`、`SetMonth`和`SetDay`方法，它们接受一个值，检查其有效性，如果有效则设置相应的结构字段。
- en: This kind of method is often called a **setter method**. By convention, Go setter
    methods are usually named in the form `Set*X*`, where `*X*` is the thing that
    you’re setting.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常称为**设置方法**。按照惯例，Go的设置方法通常以`Set*X*`的形式命名，其中`*X*`是你要设置的内容。
- en: '**Setter methods are methods used to set fields or other values within a defined
    type’s underlying value.**'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**设置方法是用于设置定义类型底层值中字段或其他值的方法。**'
- en: Here’s our first attempt at a `SetYear` method. The receiver parameter is the
    `Date` struct you’re calling the method on. `SetYear` accepts the year you want
    to set as a parameter, and sets the `Year` field on the receiver `Date` struct.
    It doesn’t validate the value at all currently, but we’ll add validation in a
    little bit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次尝试的`SetYear`方法。接收器参数是你调用方法的`Date`结构体。`SetYear`作为参数接受你想要设置的年份，并在接收器`Date`结构体上设置`Year`字段。当前它不验证值的有效性，但稍后我们会添加验证。
- en: In our `main` method, we create a `Date` and call `SetYear` on it. Then we print
    the struct’s `Year` field.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`方法中，我们创建一个`Date`并调用其`SetYear`方法。然后我们打印结构体的`Year`字段。
- en: '![image](assets/f0292-01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0292-01.png)'
- en: When we run the program, though, we’ll see that it didn’t work quite right.
    Even though we create a `Date` and call `SetYear` with a new value, the `Year`
    field is still set to its zero value!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们运行程序，但会发现它并没有完全正确地工作。即使我们创建了一个`Date`并用新值调用了`SetYear`，`Year`字段仍然设置为其零值！
- en: Setter methods need pointer receivers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置方法需要指针接收器。
- en: Remember the `Double` method on the `Number` type we showed you earlier? Originally,
    we wrote it with a plain value receiver type, `Number`. But we learned that, like
    any other parameter, receiver parameters receive a *copy* of the original value.
    The `Double` method was updating the copy, which was lost when the function exited.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前展示过的`Number`类型上的`Double`方法吗？最初，我们使用普通值接收器类型`Number`编写它。但我们了解到，像任何其他参数一样，接收器参数接收到原始值的*副本*。`Double`方法在更新副本时会丢失。
- en: '![image](assets/f0293-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0293-01.png)'
- en: We needed to update `Double` to take a pointer receiver type, `*Number`. When
    we updated the value at the pointer, the changes were preserved after `Double`
    exited.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`Double`方法，使其接受指针接收器类型`*Number`。当我们在指针上更新值时，在`Double`退出后，更改仍然被保留。
- en: The same holds true for `SetYear`. The `Date` receiver gets a *copy* of the
    original struct. Any updates to the fields of the copy are lost when `SetYear`
    exits!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SetYear`也是如此。`Date`接收器得到原始结构的*副本*。当`SetYear`退出时，对副本字段的任何更新都将丢失！
- en: '![image](assets/f0293-02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0293-02.png)'
- en: 'We can fix `SetYear` by updating it to take a pointer receiver: `(d *Date)`.
    That’s the only change that’s necessary. We don’t have to update the `SetYear`
    method block, because `d.Year` automatically gets the value at the pointer for
    us (as if we’d typed `(*d).Year`). The call to `date.SetYear` in `main` doesn’t
    need to be changed either, because the `Date` value is automatically converted
    to a `*Date` when it’s passed to the method.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新为指针接收器`(d *Date)`来修复`SetYear`。这是唯一必要的更改。我们不必更新`SetYear`方法块，因为`d.Year`会自动为我们获取指针的值（就像我们输入`(*d).Year`一样）。在`main`中调用`date.SetYear`时也无需更改，因为在传递给方法时，`Date`值会自动转换为`*Date`。
- en: '![image](assets/f0293-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0293-03.png)'
- en: Now that `SetYear` takes a pointer receiver, if we rerun the code, we’ll see
    that the `Year` field has been updated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`SetYear`采用指针接收器，如果我们重新运行代码，我们将看到`Year`字段已经更新。
- en: Adding the remaining setter methods
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加其余的设置方法。
- en: Now it should be easy to follow the same pattern to define `SetMonth` and `SetDay`
    methods on the `Date` type. We just need to be sure to use a pointer receiver
    in the method definition. Go will convert the receiver to a pointer when we call
    each method, and convert the pointer back to a struct value when updating its
    fields.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很容易按照相同的模式定义`Date`类型上的`SetMonth`和`SetDay`方法。我们只需要确保在方法定义中使用指针接收器。当我们调用每个方法时，Go将接收器转换为指针，并在更新其字段时将指针转换回结构值。
- en: '![image](assets/f0294-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0294-01.png)'
- en: In `main`, we can create a `Date` struct value; set its `Year`, `Month`, and
    `Day` fields via our new methods; and print the whole struct out to see the results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们可以创建一个`Date`结构值；通过我们的新方法设置其`Year`、`Month`和`Day`字段；然后打印整个结构以查看结果。
- en: Now we have setter methods for each of our `Date` type’s fields. But even if
    they use the methods, users can still accidentally set the fields to invalid values.
    We’ll look at preventing that next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`Date`类型的每个字段都有了设置方法。但即使使用这些方法，用户仍然可能意外地将字段设置为无效值。我们接下来将看看如何防止这种情况。
- en: '![image](assets/f0294-02.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0294-02.png)'
- en: Adding validation to the setter methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向设置方法添加验证
- en: Adding validation to our setter methods will take a bit of work, but we learned
    everything we need to do it in [Chapter 3](ch03.html#call_mecolon_functions).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 向我们的设置方法添加验证将需要一些工作，但我们在[第三章](ch03.html#call_mecolon_functions)中学到了一切我们需要做的事情。
- en: In each setter method, we’ll test whether the value is in a valid range. If
    it’s invalid, we’ll return an `error` value. If it’s valid, we’ll set the `Date`
    struct field as normal and return `nil` for the error value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个设置方法中，我们将测试值是否在有效范围内。如果无效，我们将返回一个`error`值。如果有效，则将`Date`结构字段设置为正常状态，并为错误值返回`nil`。
- en: Let’s add validation to the `SetYear` method first. We add a declaration that
    the method will return a value, of type `error`. At the start of the method block,
    we test whether the `year` parameter provided by the caller is any number less
    than `1`. If it is, we return an `error` with a message of `"invalid year"`. If
    not, we set the struct’s `Year` field and return `nil`, indicating there was no
    error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在`SetYear`方法中添加验证。我们添加一个声明，该方法将返回一个`error`类型的值。在方法块的开头，我们测试调用者提供的`year`参数是否为小于`1`的任何数字。如果是，则返回一个带有消息`"invalid
    year"`的`error`。如果不是，则设置结构的`Year`字段并返回`nil`，表示没有错误。
- en: In `main`, we call `SetYear` and store its return value in a variable named
    `err`. If `err` is not `nil`, it means the assigned value was invalid, so we log
    the error and exit. Otherwise, we proceed to print the `Date` struct’s `Year`
    field.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们调用`SetYear`并将其返回值存储在名为`err`的变量中。如果`err`不为`nil`，这意味着分配的值无效，因此我们记录错误并退出。否则，我们继续打印`Date`结构的`Year`字段。
- en: '![image](assets/f0296-01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0296-01.png)'
- en: Passing an invalid value to `SetYear` causes the program to report the error
    and exit. But if we pass a valid value, the program will proceed to print it out.
    Looks like our `SetYear` method is working!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 向`SetYear`传递无效值会导致程序报告错误并退出。但如果我们传递一个有效值，程序将继续打印它。看起来我们的`SetYear`方法正常工作！
- en: Validation code in the `SetMonth` and `SetDay` methods will be similar to the
    code in `SetYear`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMonth`和`SetDay`方法中的验证代码将类似于`SetYear`中的代码。'
- en: In `SetMonth`, we test whether the provided month number is less than `1` or
    greater than `12`, and return an error if so. Otherwise, we set the field and
    return `nil`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetMonth`中，我们测试提供的月份号码是否小于`1`或大于`12`，如果是则返回错误。否则，我们设置字段并返回`nil`。
- en: And in `SetDay`, we test whether the provided day of the month is less than
    `1` or greater than `31`. Invalid values result in a returned error, but valid
    values cause the field to be set and `nil` to be returned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetDay`中，我们测试提供的日期是否小于`1`或大于`31`。无效值导致返回错误，但有效值导致字段被设置并返回`nil`。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can test the setter methods by inserting the code snippets below into the
    block for `main`...
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将下面的代码片段插入到`main`块中来测试设置方法...
- en: 'Passing `14` to `SetMonth` results in an error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将`14`传递给`SetMonth`会导致错误：
- en: '![image](assets/f0297-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0297-02.png)'
- en: 'But passing `5` to `SetMonth` works:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但将`5`传递给`SetMonth`可以工作：
- en: '![image](assets/f0297-03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0297-03.png)'
- en: 'Passing `50` to `SetDay` results in an error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将`50`传递给`SetDay`会导致错误：
- en: '![image](assets/f0297-04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0297-04.png)'
- en: 'But passing `27` to `SetDay` works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但将`27`传递给`SetDay`可以工作：
- en: '![image](assets/f0297-05.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0297-05.png)'
- en: The fields can still be set to invalid values!
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段仍然可以设置为无效值！
- en: '![image](assets/f0298-01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0298-01.png)'
- en: It’s true; there’s nothing preventing anyone from setting the `Date` struct
    fields directly. And if they do so, it bypasses the validation code in the setter
    methods. They can set any value they want!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，没有任何阻止任何人直接设置`Date`结构字段的东西。如果他们这样做，它将绕过设置方法中的验证代码。他们可以设置任何他们想要的值！
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need a way to protect these fields, so that users of our `Date` type can
    only update the fields using the setter methods.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来保护这些字段，以便我们的`Date`类型的用户只能使用设置方法更新字段。
- en: 'Go provides a way of doing this: we can move the `Date` type to another package
    and make its date fields unexported.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一种方法来解决这个问题：我们可以将 `Date` 类型移动到另一个包中，并将其日期字段设为未导出。
- en: So far, unexported variables, functions, and the like have mostly gotten in
    our way. The most recent example of this was in [Chapter 8](ch08.html#building_storagecolon_structs),
    when we discovered that even though our `Subscriber` struct type was exported
    from the `magazine` package, its fields were *unexported*, making them inaccessible
    outside the `magazine` package.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，未导出的变量、函数等大多数时候都会阻碍我们。最近的例子是在[第 8 章](ch08.html#building_storagecolon_structs)中，当我们发现尽管我们的
    `Subscriber` 结构类型从 `magazine` 包中导出，但其字段是*未导出*的，因此在 `magazine` 包外部无法访问。
- en: '![image](assets/f0298-02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0298-02.png)'
- en: But in this case, we don’t *want* the fields to be accessible. Unexported struct
    fields are exactly what we need!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，我们**不希望**字段可以访问。未导出的结构字段正是我们需要的！
- en: Let’s try moving our `Date` type to another package and making its fields unexported,
    and see if that fixes our problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着将 `Date` 类型移到另一个包中，并将其字段设为未导出，看看是否可以解决我们的问题。
- en: Moving the Date type to another package
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `Date` 类型移动到另一个包中
- en: In the *headfirstgo* directory within your Go workspace, create a new directory
    to hold a package named `calendar`. Within *calendar*, create a file named *date.go*.
    (Remember, you can name the files within a package directory anything you want;
    they’ll all become part of the same package.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Go 工作区内的 *headfirstgo* 目录中，创建一个新目录以容纳名为 `calendar` 的包。在 *calendar* 内部，创建一个名为
    *date.go* 的文件。（记住，您可以将包目录中的文件命名为任何您喜欢的名称；它们将成为同一个包的一部分。）
- en: '![image](assets/f0299-01.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0299-01.png)'
- en: Within *date.go*, add a `package calendar` declaration and import the `"errors"`
    package. (That’s the only package that the code in this file will be using.) Then,
    copy all your old code for the `Date` type and paste it into this file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *date.go* 中，添加一个 `package calendar` 声明，并导入 `"errors"` 包。（这是此文件中的代码将要使用的唯一包。）然后，将
    `Date` 类型的所有旧代码复制并粘贴到这个文件中。
- en: '![image](assets/f0299-02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0299-02.png)'
- en: Next, let’s create a program to try out the `calendar` package. Since this is
    just for experimenting, we’ll do as we did in [Chapter 8](ch08.html#building_storagecolon_structs)
    and save a file *outside* the Go workspace, so it doesn’t interfere with any other
    packages. (We’ll just use the `go run` command to run it.) Name the file *main.go*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个程序来试试 `calendar` 包。由于这只是为了实验，我们将像在[第 8 章](ch08.html#building_storagecolon_structs)中那样，在
    Go 工作区之外保存一个文件，以避免与任何其他包发生干扰。（我们将只使用 `go run` 命令来运行它。）将文件命名为 *main.go*。
- en: '![image](assets/f0300-01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0300-01.png)'
- en: At this point, code we add in *main.go* will still be able to create an invalid
    `Date`, either by setting its fields directly or by using a struct literal.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们添加在 *main.go* 中的代码仍然可以创建一个无效的 `Date`，无论是通过直接设置其字段还是使用结构字面量。
- en: '![image](assets/f0300-02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0300-02.png)'
- en: If we run *main.go* from the terminal, we’ll see that both ways of setting the
    fields worked, and two invalid dates are printed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从终端运行 *main.go*，我们会看到设置字段的两种方式都起作用，并打印出两个无效的日期。
- en: '![image](assets/f0300-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0300-03.png)'
- en: Making Date fields unexported
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 `Date` 字段变为未导出
- en: Now let’s try updating the `Date` struct so that its fields are unexported.
    Simply change the field names to begin with lowercase letters in the type definition
    and everywhere else they occur.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试更新 `Date` 结构，使其字段变为未导出。只需在类型定义中将字段名更改为小写字母开头，并在其他任何地方也都如此。
- en: The `Date` type itself needs to remain exported, as do all of the setter methods,
    because we *will* need to access these from outside the `calendar` package.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 类型本身需要保持导出，以及所有的设置方法，因为我们*确实*需要从 `calendar` 包外部访问这些方法。'
- en: '![image](assets/f0301-01.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0301-01.png)'
- en: To test our changes, update the field names in *main.go* to match the field
    names in *date.go*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的更改，在 *main.go* 中更新字段名称，以匹配 *date.go* 中的字段名称。
- en: '![image](assets/f0301-02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0301-02.png)'
- en: Accessing unexported fields through exported methods
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过导出的方法访问未导出的字段
- en: As you might expect, now that we’ve converted the fields of `Date` to unexported,
    trying to access them from the `main` package results in compile errors. This
    is true both when we’re trying to set the field values directly, and when using
    them in a struct literal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所料，现在我们已经将 `Date` 的字段转换为未导出后，试图从 `main` 包中访问它们会导致编译错误。这在直接设置字段值时以及在结构字面量中使用它们时都是如此。
- en: '![image](assets/f0302-01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0302-01.png)'
- en: But we can still access the fields indirectly. *Unexported* variables, struct
    fields, functions, methods, and the like can still be accessed by *exported* functions
    and methods in the same package. So when code in the `main` package calls the
    exported `SetYear` method on a `Date` value, `SetYear` can update the `Date`’s
    `year` struct field, even though it’s unexported. The exported `SetMonth` method
    can update the unexported `month` field. And so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们仍然可以间接访问这些字段。*未导出*的变量、结构字段、函数、方法等仍然可以被同一包内导出的函数和方法访问。因此，当 `main` 包中的代码调用
    `Date` 值上的导出 `SetYear` 方法时，即使 `year` 字段是未导出的，`SetYear` 也可以更新 `Date` 的 `year` 结构字段。导出的
    `SetMonth` 方法可以更新未导出的 `month` 字段，依此类推。
- en: 'If we modify *main.go* to use the setter methods, we’ll be able to update a
    `Date` value’s fields:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改 *main.go* 以使用设置器方法，我们将能够更新 `Date` 值的字段：
- en: '![image](assets/f0302-02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0302-02.png)'
- en: '**Unexported variables, struct fields, functions, and methods can still be
    accessed by exported functions and methods in the same package.**'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**未导出的变量、结构字段、函数和方法仍然可以被同一包内导出的函数和方法访问。**'
- en: 'If we update *main.go* to call `SetYear` with an invalid value, we’ll get an
    error when we run it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新 *main.go* 以使用无效值调用 `SetYear`，则在运行时会出现错误：
- en: '![image](assets/f0303-01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0303-01.png)'
- en: Now that a `Date` value’s fields can only be updated via its setter methods,
    programs are protected against accidentally entering invalid data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Date` 值的字段只能通过其设置器方法更新，程序可以避免意外输入无效数据。
- en: '![image](assets/f0303-02.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0303-02.png)'
- en: Ah, that’s right. We provided setter methods that let us set `Date` fields,
    even though those fields are unexported from the `calendar` package. But we haven’t
    provided any methods to *get* the field values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 噢，没错。我们提供了设置器方法，允许我们设置 `Date` 字段，尽管这些字段在 `calendar` 包中是未导出的。但是，我们并未提供任何获取字段值的方法。
- en: We can print an entire `Date` struct. But if we try to update *main.go* to print
    an individual `Date` field, we won’t be able to access it!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印整个 `Date` 结构。但是，如果尝试更新 *main.go* 以打印单个 `Date` 字段，则无法访问它！
- en: '![image](assets/f0303-03.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0303-03.png)'
- en: Getter methods
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器方法
- en: As we’ve seen, methods whose main purpose is to *set* the value of a struct
    field or variable are called *setter methods*. And, as you might expect, methods
    whose main purpose is to *get* the value of a struct field or variable are called
    **getter methods**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，其主要目的是设置结构字段或变量值的方法称为*设置器方法*。而其主要目的是获取结构字段或变量值的方法称为**获取器方法**。
- en: Compared to the setter methods, adding getter methods to the `Date` type will
    be easy. They don’t need to do anything except return the field value when they’re
    called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与设置器方法相比，为 `Date` 类型添加获取器方法将很容易。它们在被调用时不需要执行任何操作，只需返回字段值即可。
- en: '![image](assets/f0304-01.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0304-01.png)'
- en: By convention, a getter method’s name should be the same as the name of the
    field or variable it accesses. (Of course, if you want the method to be exported,
    its name will need to start with a capital letter.) So `Date` will need a `Year`
    method to access the `year` field, a `Month` method for the `month` field, and
    a `Day` method for the `day` field.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，获取器方法的名称应与其访问的字段或变量名称相同。（当然，如果要导出该方法，其名称需要以大写字母开头。）因此，`Date` 将需要一个 `Year`
    方法来访问 `year` 字段，一个 `Month` 方法来访问 `month` 字段，以及一个 `Day` 方法来访问 `day` 字段。
- en: Getter methods don’t need to modify the receiver at all, so we *could* use a
    direct `Date` value as a receiver. But if any method on a type takes a pointer
    receiver, convention says that they *all* should, for consistency’s sake. Since
    we have to use a pointer receiver for our setter methods, we use a pointer for
    the getter methods as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器方法根本不需要修改接收器，因此我们*可以*使用直接的 `Date` 值作为接收器。但是，如果某个类型的任何方法都使用指针接收器，按照惯例，为了保持一致性，它们*全部*都应该使用指针接收器。因此，由于我们必须为我们的设置器方法使用指针接收器，我们也为获取器方法使用指针。
- en: With the changes to *date.go* complete, we can update *main.go* to set all the
    `Date` fields, then use the getter methods to print them all out.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 *date.go* 的更改后，我们可以更新 *main.go* 以设置所有 `Date` 字段，然后使用获取器方法打印它们。
- en: '![image](assets/f0304-02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0304-02.png)'
- en: Encapsulation
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: The practice of hiding data in one part of a program from code in another part
    is known as **encapsulation**, and it’s not unique to Go. Encapsulation is valuable
    because it can be used to protect against invalid data (as we’ve seen). Also,
    you can change an encapsulated portion of a program without worrying about breaking
    other code that accesses it, because direct access isn’t allowed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序的一部分中的数据隐藏在另一部分代码中被称为**封装**，这不仅限于Go。封装是有价值的，因为它可以用来保护免受无效数据的影响（正如我们所见）。此外，您可以更改程序的封装部分而不必担心破坏访问它的其他代码，因为不允许直接访问。
- en: Many other programming languages encapsulate data within classes. (Classes are
    a concept similar, but not identical, to a Go type.) In Go, data is encapsulated
    within packages, using unexported variables, struct fields, functions, or methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他编程语言将数据封装在类中。（类是与Go类型类似但不完全相同的概念。）在Go中，数据通过未导出的变量、结构字段、函数或方法封装在包内。
- en: Encapsulation is used far more frequently in other languages than it is in Go.
    In some languages it’s conventional to define getters and setters for every field,
    even when accessing those fields directly would work just as well. Go developers
    generally only rely on encapsulation when it’s necessary, such as when field data
    needs to be validated by setter methods. In Go, if you don’t see a need to encapsulate
    a field, it’s generally okay to export it and allow direct access to it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 封装在其他语言中比在Go中更频繁地使用。在某些语言中，通常为每个字段定义getter和setter，即使直接访问这些字段也可以很好地工作。在Go中，开发者通常只在必要时依赖封装，例如当字段数据需要通过setter方法进行验证时。在Go中，如果没有看到需要封装字段的必要性，通常可以直接导出它并允许直接访问。
- en: there are no Dumb Questions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: Many other languages don’t allow access to encapsulated values outside
    of the class where they’re defined. Is it safe for Go to allow other code in the
    same package to access unexported fields?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：许多其他语言不允许在类外部访问封装值。在Go中，允许同一包中的其他代码访问未导出字段安全吗？**'
- en: '**A:** Generally, all the code in a package is the work of a single developer
    (or group of developers). All the code in a package generally has a similar purpose,
    as well. The authors of code within the same package are most likely to need access
    to unexported data, and they’re also likely to only use that data in valid ways.
    So, yes, sharing unexported data with the rest of the package is generally safe.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** 通常，一个包中的所有代码都是单个开发者（或一组开发者）的工作。一个包中的所有代码通常都有相似的目的。同一个包中的代码作者很可能需要访问未公开的数据，并且他们也很可能只在有效的方式下使用这些数据。因此，是的，与包中的其他代码共享未公开数据通常是安全的。'
- en: Code *outside* the package is likely to be written by *other* developers, but
    that’s okay because the unexported fields are hidden from them, so they can’t
    accidentally change their values to something invalid.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码*在*包之外很可能是由*其他*开发者编写的，但这没关系，因为未导出字段对他们是隐藏的，所以他们无法意外地将其值更改为无效值。
- en: '**Q: I’ve seen other languages where the name of every getter method started
    with “`Get”`, as in `GetName`, `GetCity`, and so on. Can I do that in Go?**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**问：我看过其他语言中每个获取器方法的名称都以“`Get`”开头，比如`GetName`、`GetCity`等等。在Go语言中我可以这样做吗？**'
- en: '**A:** The Go language will allow you to do that, but you shouldn’t. The Go
    community has decided on a convention of leaving the `Get` prefix off of getter
    method names. Including it would only lead to confusion for your fellow developers!'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**答：** Go语言允许你这样做，但你不应该这样做。Go社区已经决定不在getter方法名称中包含`Get`前缀的约定。包含此前缀只会导致其他开发者感到困惑！'
- en: Go still uses a `Set` prefix for setter methods, just like many other languages,
    because it’s needed to distinguish setter method names from getter method names
    for the same field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多其他语言一样，Go仍然为setter方法使用`Set`前缀，因为这是为了区分相同字段的getter方法名和setter方法名所必需的。
- en: Embedding the Date type in an Event type
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入`Event`类型中的`Date`类型
- en: '![image](assets/f0308-01.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0308-01.png)'
- en: That shouldn’t take much work. Remember how we embedded an `Address` struct
    type within two other struct types back in [Chapter 8](ch08.html#building_storagecolon_structs)?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那不应该花费太多工作。还记得我们在[第8章](ch08.html#building_storagecolon_structs)中是如何将`Address`结构类型嵌入另外两个结构类型中的吗？
- en: '![image](assets/f0308-02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0308-02.png)'
- en: The `Address` type was considered “embedded” because we used an anonymous field
    (a field with no name, just a type) in the outer struct to store it. This caused
    the fields of `Address` to be promoted to the outer struct, allowing us to access
    fields of the inner struct as if they belonged to the outer struct.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类型被视为“嵌入”，因为我们在外部结构体中使用了一个匿名字段（只有类型没有名称），这导致`Address`的字段被提升到外部结构体，从而允许我们像访问外部结构体字段一样访问内部结构体的字段。'
- en: '![image](assets/f0308-03.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0308-03.png)'
- en: Since that strategy worked so well before, let’s define an `Event` type that
    embeds a `Date` with an anonymous field.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这种策略之前如此成功，让我们定义一个`Event`类型，其中包含一个匿名字段`Date`。
- en: 'Create another file within the `calendar` package folder, named *event.go*.
    (We could put it within the existing *date.go* field, but this organizes things
    a bit more neatly.) Within that file, define an `Event` type with two fields:
    a `Title` field with a type of `string`, and an anonymous `Date` field.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calendar`包文件夹中创建另一个文件，命名为*event.go*。（我们可以将其放在现有的*date.go*文件中，但这样可以更加整洁地组织。）在该文件中，定义一个`Event`类型，它有两个字段：一个类型为`string`的`Title`字段，和一个匿名的`Date`字段。
- en: Unexported fields don’t get promoted
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未导出的字段不会被提升
- en: Embedding a `Date` in the `Event` type will *not* cause the `Date` fields to
    be promoted to the `Event`, though. The `Date` fields are unexported, and Go doesn’t
    promote unexported fields to the enclosing type. That makes sense; we made sure
    the fields were encapsulated so they can only be accessed through setter and getter
    methods, and we don’t want that encapsulation to be circumvented through field
    promotion.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在`Event`类型中嵌入`Date`不会导致将`Date`字段提升到`Event`，`Date`字段是未导出的，Go语言不会将未导出字段提升到封闭类型。这是有道理的；我们确保字段被封装，因此只能通过设置器和获取器方法访问它们，并且不希望通过字段提升来规避封装。
- en: '![image](assets/f0309-01.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0309-01.png)'
- en: 'In our `main` package, if we try to set the `month` field of a `Date` through
    its enclosing `Event`, we’ll get an error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`包中，如果我们尝试通过其封闭的`Event`设置`Date`的`month`字段，我们会遇到错误：
- en: '![image](assets/f0309-02.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0309-02.png)'
- en: And, of course, using dot operator chaining to retrieve the `Date` field and
    then access fields on it directly won’t work, either. You can’t access a `Date`
    value’s unexported fields when it’s by itself, and you can’t access its unexported
    fields when it’s part of an `Event`, either.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用点操作符链式检索`Date`字段然后直接访问它的字段也不起作用。当`Date`独立存在时，无法访问其未导出字段；当其作为`Event`的一部分存在时也不行。
- en: '![image](assets/f0309-03.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0309-03.png)'
- en: So does that mean we won’t be able to access the fields of the `Date` type,
    if it’s embedded within the `Event` type? Don’t worry; there’s another way!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这是否意味着我们无法访问`Event`类型中嵌入的`Date`类型的字段？别担心；还有另一种方法！
- en: Exported methods get promoted just like fields
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出的方法会像字段一样被提升
- en: If you embed a type with exported methods within a struct type, its methods
    will be promoted to the outer type, meaning you can call the methods as if they
    were defined on the outer type. (Remember how embedding one struct type within
    another causes the inner struct’s fields to be promoted to the outer struct? This
    is the same idea, but with methods instead of fields.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在结构类型中嵌入具有导出方法的类型，其方法将被提升到外部类型，这意味着您可以像在外部类型上定义的方法一样调用这些方法。（还记得如何在一个结构体类型中嵌入另一个导致内部结构体的字段被提升到外部结构体吗？这与字段相同，但是用方法替代了。）
- en: Here’s a package that defines two types. `MyType` is a struct type and it embeds
    a second type, `EmbeddedType`, as an anonymous field.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义了两种类型的包。`MyType`是一个结构类型，它作为匿名字段嵌入了第二个类型`EmbeddedType`。
- en: '![image](assets/f0310-01.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0310-01.png)'
- en: Because `EmbeddedType` defines an exported method (named `ExportedMethod`),
    that method is promoted to `MyType`, and can be called on `MyType` values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`EmbeddedType`定义了一个导出方法（名为`ExportedMethod`），该方法会被提升到`MyType`，并且可以在`MyType`值上调用。
- en: '![image](assets/f0310-02.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0310-02.png)'
- en: As with unexported fields, unexported methods are *not* promoted. You’ll get
    an error if you try to call one.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与未导出字段一样，未导出方法也不会被提升。如果尝试调用未导出方法，则会出现错误。
- en: '![image](assets/f0310-03.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0310-03.png)'
- en: Our `Date` fields weren’t promoted to the `Event` type, because they’re unexported.
    But the getter and setter methods on `Date` *are* exported, and they *do* get
    promoted to the `Event` type!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Date`字段没有被提升到`Event`类型，因为它们是未导出的。但是`Date`上的获取器和设置器方法是导出的，并且会被提升到`Event`类型！
- en: That means we can create an `Event` value, and then call the getter and setter
    methods for the `Date` directly on the `Event`. That’s just what we do in the
    updated *main.go* code below. As always, the exported methods are able to access
    the unexported `Date` fields for us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以创建一个`Event`值，然后直接在`Event`上调用`Date`的getter和setter方法。这正是我们在下面更新的*main.go*代码中所做的。如常，公开的方法可以为我们访问未导出的`Date`字段。
- en: '![image](assets/f0311-01.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0311-01.png)'
- en: 'And if you prefer to use dot operator chaining to call methods on the `Date`
    value directly, you can do that too:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢在`Date`值上直接使用点操作符链式调用方法，您也可以这样做：
- en: '![image](assets/f0311-02.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0311-02.png)'
- en: Encapsulating the Event Title field
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装事件标题字段
- en: 'Because the `Event` struct’s `Title` field is exported, we can still access
    it directly:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Event`结构体的`Title`字段是公开的，我们仍然可以直接访问它：
- en: '![image](assets/f0312-01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0312-01.png)'
- en: 'This exposes us to the same sort of issues that we had with the `Date` fields,
    though. For example, there’s no limit on the length of the `Title` string:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们暴露于与`Date`字段相同的问题，比如，`Title`字符串没有长度限制：
- en: '![image](assets/f0312-02.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0312-02.png)'
- en: It seems like a good idea to encapsulate the title field as well, so we can
    validate new values. Here’s an update to the `Event` type that does so. We change
    the field’s name to `title` so it’s unexported, then add getter and setter methods.
    The `RuneCountInString` function from the `unicode/utf8` package is used to ensure
    there aren’t too many runes (characters) in the string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来将标题字段封装起来也是个好主意，这样我们就可以验证新的值。下面是更新后的`Event`类型，做了这样的操作。我们将字段的名称更改为`title`，使其未导出，然后添加了getter和setter方法。使用`unicode/utf8`包中的`RuneCountInString`函数来确保字符串中没有太多的符文（字符）。
- en: '![image](assets/f0312-03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0312-03.png)'
- en: Promoted methods live alongside the outer type’s methods
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升的方法与外部类型的方法并存
- en: 'Now that we’ve added setter and getter methods for the `title` field, our programs
    can report an error if a title longer than 30 characters is used. An attempt to
    set a 39-character title causes an error to be returned:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为`title`字段添加了setter和getter方法，如果使用超过30个字符的标题，我们的程序可以报错。尝试设置一个39个字符的标题将导致错误返回：
- en: '![image](assets/f0313-01.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0313-01.png)'
- en: The `Event` type’s `Title` and `SetTitle` methods live alongside the methods
    promoted from the embedded `Date` type. Importers of the `calendar` package can
    treat all the methods as if they belong to the `Event` type, without worrying
    about which type they’re actually defined on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类型的`Title`和`SetTitle`方法与从嵌入的`Date`类型提升的方法并存。导入`calendar`包的用户可以将所有方法视为属于`Event`类型，而不用担心它们实际上是在哪种类型上定义的。'
- en: '![image](assets/f0313-02.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0313-02.png)'
- en: Our calendar package is complete!
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的日历包已经完善了！
- en: '![image](assets/f0314-01.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0314-01.png)'
- en: Method promotion allows you to easily use one type’s methods as if they belonged
    to another. You can use this to compose types that combine the methods of several
    other types. This can help you keep your code clean, without sacrificing convenience!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 方法提升允许您轻松地将一种类型的方法用作另一种类型的方法。您可以使用这个功能来组合多种其他类型的方法。这有助于保持代码的清晰性，而不会牺牲便利性！
- en: Your Go Toolbox
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Go工具箱
- en: '![image](assets/f0316-01.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0316-01.png)'
- en: '**That’s it for [Chapter 10](#keep_it_to_yourselfcolon_encapsulation_a)! You’ve
    added encapsulation and embedding to your toolbox.**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**到此为止，[第10章](#keep_it_to_yourselfcolon_encapsulation_a)就结束了！您已经将封装和嵌入添加到了您的工具箱中。**'
- en: '![image](assets/f0316-02.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0316-02.png)'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Embedding
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入
- en: A type that is stored within a struct type using an anonymous field is said
    to be embedded within the struct.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 被存储在结构体类型内部的类型，使用匿名字段被称为被嵌入在结构体中。
- en: Methods of an embedded type get promoted to the outer type. They can be called
    as if they were defined on the outer type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入类型的方法被提升到外部类型。它们可以被调用，就好像它们是在外部类型上定义的一样。
