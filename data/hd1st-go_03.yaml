- en: 'Chapter 2\. which code runs next?: Conditionals and Loops'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。哪些代码将会接下来运行？：条件语句和循环
- en: '![image](assets/f0031-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0031-01.png)'
- en: '**Every program has parts that apply only in certain situations**. “This code
    should run *if* there’s an error. Otherwise, that other code should run.” Almost
    every program contains code that should be run only when a certain *condition*
    is true. So almost every programming language provides **conditional statements**
    that let you determine whether to run segments of code. Go is no exception.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个程序都有仅在特定情况下适用的部分**。“如果出现错误，则应运行此代码。否则，应运行其他代码。” 几乎每个程序包含应仅在某个*条件*为真时运行的代码。因此，几乎每种编程语言都提供了**条件语句**，让您可以确定是否运行代码段。Go
    也不例外。'
- en: You may also need some parts of your code to run *repeatedly*. Like most languages,
    Go provides **loops** that run sections of code more than once. We’ll learn to
    use both conditionals and loops in this chapter!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要使您的一些代码运行*重复*。像大多数语言一样，Go 提供了可以多次运行代码段的**循环**。我们将在本章学习如何同时使用条件语句和循环！
- en: Calling methods
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'In Go, it’s possible to define **methods**: functions that are associated with
    values of a given type. Go methods are kind of like the methods that you may have
    seen attached to “objects” in other languages, but they’re a bit simpler.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，可以定义**方法**：与给定类型的值相关联的函数。Go 方法有点像您可能在其他语言中附加到“对象”的方法，但它们稍微简单一些。
- en: We’ll be taking a detailed look at how methods work in [Chapter 9](ch09.html#yoursquore_my_typecolon_defined_types).
    But we need to use a couple methods to make our examples for this chapter work,
    so let’s look at some brief examples of calling methods now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论方法如何在[第9章](ch09.html#yoursquore_my_typecolon_defined_types)中工作。但我们需要使用一些方法来使本章的示例工作，所以让我们现在看一些调用方法的简短示例。
- en: 'The `time` package has a `Time` type that represents a date (year, month, and
    day) and time (hour, minute, second, etc.). Each `time.Time` value has a `Year`
    method that returns the year. The code below uses this method to print the current
    year:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 包有一个 `Time` 类型，表示日期（年、月和日）和时间（时、分、秒等）。每个 `time.Time` 值都有一个 `Year` 方法，返回年份。下面的代码使用此方法打印当前年份：'
- en: '![image](assets/f0032-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0032-01.png)'
- en: 'The `time.Now` function returns a new `Time` value for the current date and
    time, which we store in the `now` variable. Then, we call the `Year` method on
    the value that `now` refers to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Now` 函数返回当前日期和时间的新 `Time` 值，我们将其存储在 `now` 变量中。然后，我们在 `now` 引用的值上调用 `Year`
    方法：'
- en: '![image](assets/f0032-02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0032-02.png)'
- en: The `Year` method returns an integer with the year, which we then print.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Year` 方法返回一个整数年份，然后我们将其打印出来。'
- en: '**Methods are functions that are associated with values of a particular type.**'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**方法是与特定类型的值相关联的函数**。'
- en: 'The `strings` package has a `Replacer` type that can search through a string
    for a substring, and replace each occurrence of that substring with another string.
    The code below replaces every `#` symbol in a string with the letter `o`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings` 包中有一个 `Replacer` 类型，它可以搜索字符串中的子字符串，并将每个出现的子字符串替换为另一个字符串。下面的代码用字母
    `o` 替换了字符串中的每个 `#` 符号：'
- en: '![image](assets/f0033-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0033-01.png)'
- en: The `strings.NewReplacer` function takes arguments with a string to replace
    (`"#"`), and a string to replace it with (`"o"`), and returns a `strings.Replacer`.
    When we pass a string to the `Replacer` value’s `Replace` method, it returns a
    string with those replacements made.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.NewReplacer` 函数接受两个参数，第一个是要替换的字符串（`"#"`），第二个是要替换为的字符串（`"o"`），并返回一个
    `strings.Replacer`。当我们将字符串传递给 `Replacer` 值的 `Replace` 方法时，它将返回一个已进行替换的字符串。'
- en: '![image](assets/f0033-02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0033-02.png)'
- en: '**The dot indicates that the thing on its right belongs to the thing on its
    left**.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**点号指示点右侧的东西属于左侧的东西**。'
- en: Whereas the functions we saw earlier belonged to a *package*, the methods belong
    to an individual *value*. That value is what appears to the left of the dot.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们早些时候看到的函数属于*包*不同，方法属于一个单独的*值*。这个值是出现在点号左侧的内容。
- en: '![image](assets/f0033-03.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0033-03.png)'
- en: Making the grade
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取得好成绩
- en: In this chapter, we’re going to look at features of Go that let you decide whether
    to run some code or not, based on a condition. Let’s look at a situation where
    we might need that ability...
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Go 的一些特性，这些特性让您可以根据条件决定是否运行一些代码。让我们看一个可能需要这种能力的情况...
- en: 'We need to write a program that allows a student to type in their percentage
    grade and tells them whether they passed or not. Passing or failing follows a
    simple formula: a grade of 60% or more is passing, and less than 60% is failing.
    So our program will need to give one response if the percentage users enter is
    60 or greater, and a different response otherwise.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个程序，允许学生输入他们的百分比成绩，并告诉他们是否通过了。通过或失败遵循一个简单的规则：60%或更高的成绩为通过，低于60%为失败。因此，如果用户输入的百分比是60或更高，我们的程序将需要给出一种响应；否则给出另一种响应。
- en: Comments
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Let’s create a new file, *pass_fail.go*, to hold our program. We’re going to
    take care of a detail we omitted in our previous programs, and add a description
    of what the program does at the top.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，*pass_fail.go*，来保存我们的程序。我们将处理之前程序中遗漏的一个细节，并在顶部添加一个描述程序功能的描述。
- en: '![image](assets/f0034-01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0034-01.png)'
- en: Most Go programs include descriptions in their source code of what they do,
    intended for people maintaining the program to read. These **comments** are ignored
    by the compiler.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Go 程序在其源代码中包含了描述程序功能的注释，这些注释供维护程序的人阅读。编译器会忽略这些**注释**。
- en: The most common form of comment is marked with two slash characters (`//`).
    Everything from the slashes to the end of the line is treated as part of the comment.
    A `//` comment can appear on a line by itself, or following a line of code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的注释形式是用两个斜杠字符（`//`）标记的。从斜杠开始到行末的所有内容都视为注释的一部分。`//` 注释可以单独出现在一行上，也可以跟随在代码行后面。
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The less frequently used form of comments, **block comments**, spans multiple
    lines. Block comments start with `/*` and end with `*/`, and everything between
    those markers (including newlines) is part of the comment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不太常用的注释形式是**块注释**，跨越多行。块注释以`/*`开头，以`*/`结束，两者之间的所有内容（包括换行）都是注释的一部分。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Getting a grade from the user
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户的成绩
- en: 'Now let’s add some actual code to our *pass_fail.go* program. The first thing
    it needs to do is allow the user to input a percentage grade. We want them to
    type a number and press Enter, and we’ll store the number they typed in a variable.
    Let’s add code to handle this. *(Note: this code will not actually compile as
    shown; we’ll talk about the reason in a moment!)*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向我们的 *pass_fail.go* 程序添加一些实际的代码。它首先需要做的是允许用户输入一个百分比成绩。我们希望他们输入一个数字并按回车，我们将把他们输入的数字存储在一个变量中。让我们添加处理此操作的代码。（*注意：此代码将不能按照显示的方式编译，我们稍后会讨论原因！*）
- en: '![image](assets/f0035-01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0035-01.png)'
- en: First, we need to let the user know to enter something, so we use the `fmt.Print`
    function to display a prompt. (Unlike the `Println` function, `Print` doesn’t
    skip to a new terminal line after printing a message, which lets us keep the prompt
    and the user’s entry on the same line.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要让用户知道输入内容，因此我们使用`fmt.Print`函数显示一个提示。 （与`Println`函数不同，`Print`在打印消息后不会跳到新的终端行，这使我们可以保持提示和用户输入在同一行上。）
- en: Next, we need a way to read (receive and store) input from the program’s *standard
    input*, which all keyboard input goes to. The line `reader := bufio.NewReader(os.Stdin)`
    stores a `bufio.Reader` in the `reader` variable that can do that for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法从程序的*标准输入*中读取（接收和存储）输入，所有键盘输入都将进入这里。行`reader := bufio.NewReader(os.Stdin)`在变量`reader`中存储了一个能够执行此操作的`bufio.Reader`。
- en: '![image](assets/f0035-02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0035-02.png)'
- en: To actually get the user’s input, we call the `ReadString` method on the `Reader`.
    The `ReadString` method requires an argument with a rune (character) that marks
    the end of the input. We want to read everything the user types up until they
    press Enter, so we give `ReadString` a newline rune.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际获取用户的输入，我们在`Reader`上调用`ReadString`方法。`ReadString`方法需要一个标志输入结束的符文（字符），我们希望读取用户按下回车键之前的所有内容，因此我们给`ReadString`传递一个换行符符文。
- en: Once we have the user input, we simply print it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了用户的输入，我们就简单地将其打印出来。
- en: 'That’s the plan, anyway. But if we try to compile or run this program, we’ll
    get an error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是计划，但是如果我们试图编译或运行这个程序，我们将会得到一个错误：
- en: '![image](assets/f0035-03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0035-03.png)'
- en: Multiple return values from a function or method
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数或方法的多返回值
- en: 'We’re trying to read the user’s keyboard input, but we’re getting an error.
    The compiler is reporting a problem in this line of code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图读取用户的键盘输入，但是出现了错误。编译器在这行代码中报告了一个问题：
- en: '![image](assets/f0036-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0036-01.png)'
- en: The problem is that the `ReadString` method is trying to return *two* values,
    and we’ve only provided *one* variable to assign a value to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `ReadString` 方法试图返回*两个*值，但我们只提供了*一个*变量来接收值。
- en: 'In most programming languages, functions and methods can only have a single
    return value, but in Go, they can return any number of values. The most common
    use of multiple return values in Go is to return an additional error value that
    can be consulted to find out if anything went wrong while the function or method
    was running. A few examples:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，函数和方法只能有一个返回值，但在Go语言中，它们可以返回任意数量的值。在Go语言中多返回值的最常见用法是返回额外的错误值，可以通过它来查找函数或方法执行过程中是否出现了问题。以下是一些例子：
- en: '![image](assets/f0036-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0036-02.png)'
- en: '**Go doesn’t allow us to declare a variable unless we use it**.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go语言不允许我们声明变量而不使用它**。'
- en: Go requires that every variable that gets *declared* must also get *used* somewhere
    in your program. If we add an `err` variable and then don’t check it, our code
    won’t compile. Unused variables often indicate a bug, so this is an example of
    Go helping you detect and fix bugs!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言要求每个被*声明*的变量在程序中必须被*使用*。如果我们添加了一个 `err` 变量但没有检查它，我们的代码就无法编译通过。未使用的变量通常表示程序中可能存在的错误，这是Go语言帮助你检测和修复错误的一个例子！
- en: '![image](assets/f0036-03.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0036-03.png)'
- en: 'Option 1: Ignore the error return value with the blank identifier'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项1：使用空白标识符忽略错误返回值
- en: The `ReadString` method returns a second value along with the user’s input,
    and we need to do something with that second value. We’ve tried just adding a
    second variable and ignoring it, but our code still won’t compile.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadString` 方法除了返回用户输入的值外，还返回一个第二个值，我们需要对这第二个值做些处理。我们尝试添加第二个变量并忽略它，但我们的代码仍然无法编译通过。'
- en: '![image](assets/f0037-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0037-01.png)'
- en: When we have a value that would normally be assigned to a variable, but that
    we don’t intend to use, we can use Go’s **blank identifier**. Assigning a value
    to the blank identifier essentially discards it (while making it obvious to others
    reading your code that you are doing so). To use the blank identifier, simply
    type a single underscore ( `_` ) character in an assignment statement where you
    would normally type a variable name.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个通常会被赋值给变量但我们不打算使用的值时，可以使用Go语言的**空白标识符**。将值赋给空白标识符实际上是将其丢弃（同时也向读者明确表明你正在这样做）。要使用空白标识符，在赋值语句中简单地输入一个下划线（
    `_` ）字符，替代你通常会输入的变量名。
- en: 'Let’s try using the blank identifier in place of our old `err` variable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着用空白标识符替代我们以前的 `err` 变量：
- en: '![image](assets/f0037-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0037-02.png)'
- en: 'Now we’ll try the change out. In your terminal, change to the directory where
    you saved *pass_fail.go*, and run the program with:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来尝试这个变化。在你的终端中，切换到保存了 *pass_fail.go* 文件的目录，并使用以下命令运行程序：
- en: '![image](assets/f0037-03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0037-03.png)'
- en: When you type a grade (or any other string) at the prompt and press Enter, your
    entry will be echoed back to you. Our program is working!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在提示符处输入一个成绩（或任何其他字符串）并按Enter键时，你输入的内容将被回显给你。我们的程序正在工作！
- en: 'Option 2: Handle the error'
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项2：处理错误
- en: '![image](assets/f0038-01.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0038-01.png)'
- en: '**That’s true. If an error actually occurred, this program wouldn’t tell us!**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是真的。如果真的发生错误，这个程序就不会告诉我们！**'
- en: If we got an error back from the `ReadString` method, the blank identifier would
    just cause the error to be ignored, and our program would proceed anyway, possibly
    with invalid data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 `ReadString` 方法得到一个错误，空白标识符将会忽略这个错误，并且我们的程序会继续运行，可能会带来无效的数据。
- en: '![image](assets/f0038-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0038-02.png)'
- en: In this case, it would be more appropriate to alert the user and stop the program
    if there was an error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果出现错误，最好通知用户并停止程序。
- en: 'The `log` package has a `Fatal` function that can do both of these operations
    for us at once: log a message to the terminal *and* stop the program. (“Fatal”
    in this context means reporting an error that “kills” your program.)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 包中有一个 `Fatal` 函数可以同时执行这两个操作：向终端记录消息并停止程序运行。在这里，“Fatal”表示报告一个“致命”的错误，即会“杀死”你的程序。'
- en: Let’s get rid of the blank identifier and replace it with an `err` variable
    so that we’re recording the error again. Then, we’ll use the `Fatal` function
    to log the error and halt the program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去掉空白标识符，将其替换为 `err` 变量，这样我们再次记录错误。然后，我们将使用 `Fatal` 函数记录错误并停止程序。
- en: '![image](assets/f0038-03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0038-03.png)'
- en: But if we try running this updated program, we’ll see there’s a new problem...
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们尝试运行这个更新后的程序，我们会发现有一个新问题...
- en: Conditionals
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: If our program encounters a problem reading input from the keyboard, we’ve set
    it up to report the error and stop running. But now, it stops running even when
    everything’s working correctly!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的程序在从键盘读取输入时遇到问题，我们已设置程序报告错误并停止运行。但现在，即使一切正常，它也停止运行！
- en: '![image](assets/f0039-01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0039-01.png)'
- en: Functions and methods like `ReadString` return an error value of **nil**, which
    basically means “there’s nothing there.” In other words, if `err` is `nil`, it
    means there was no error. But our program is set up to simply report the `nil`
    error! What we *should* do is exit the program only *if* the `err` variable has
    a value other than `nil`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像`ReadString`这样的函数和方法返回一个值为**nil**的错误，这基本上意味着“没有任何内容”。换句话说，如果`err`是`nil`，那么没有错误。但是我们的程序设置为简单地报告`nil`错误！我们*应该*的是只有在`err`变量的值不是`nil`时才退出程序。
- en: 'We can do this using **conditionals**: statements that cause a block of code
    (one or more statements surrounded by `{}` curly braces) to be executed only if
    a condition is met.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过**条件语句**来实现这一点：这些语句会导致仅在满足条件时执行一个代码块（一个或多个被`{}`大括号包围的语句）。
- en: '![image](assets/f0039-02.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0039-02.png)'
- en: An expression is evaluated, and if its result is `true`, the code in the conditional
    block body is executed. If it’s `false`, the conditional block is skipped.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式被评估，如果结果为`true`，则执行条件块中的代码。如果结果为`false`，则跳过条件块。
- en: '![image](assets/f0039-03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0039-03.png)'
- en: As with most other languages, Go supports multiple branches in the conditional.
    These statements take the form `if`...`else if`...`else`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言一样，Go支持条件中的多个分支。这些语句采用`if`...`else if`...`else`的形式。
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Conditionals rely on a Boolean expression (one that evaluates to `true` or `false`)
    to decide whether the code they contain should be executed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句依赖于布尔表达式（一个评估为`true`或`false`的表达式），以决定它们包含的代码是否应该被执行。
- en: '![image](assets/f0040-01.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0040-01.png)'
- en: When you need to execute code only if a condition is *false*, you can use `!`,
    the Boolean negation operator, which lets you take a `true` value and make it
    `false`, or a `false` value and make it `true`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要仅在条件*false*时执行代码时，可以使用`!`，布尔取反运算符，它可以将`true`变为`false`，或者将`false`变为`true`。
- en: '![image](assets/f0040-02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0040-02.png)'
- en: If you want to run some code only if two conditions are *both* true, you can
    use the `&&` (“and”) operator. If you want it to run if *either* of two conditions
    is true, you can use the `||` (“or”) operator.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想只在两个条件*都*为真时运行一些代码，你可以使用`&&`（“和”）运算符。如果你希望在两个条件*之一*为真时运行，你可以使用`||`（“或”）运算符。
- en: '![image](assets/f0040-03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0040-03.png)'
- en: there are no Dumb Questions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: My other programming language requires that an `**if**` statement’s condition
    be surrounded with parentheses. Doesn’t Go?**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 我的另一种编程语言要求`**if**`语句的条件必须用括号括起来。Go也是这样吗？**'
- en: '**A:** No, and in fact the `go fmt` tool will remove any parentheses you add,
    unless you’re using them to set order of operations.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 不是，并且事实上，`go fmt`工具会删除您添加的任何括号，除非您用它们来设置操作顺序。'
- en: Logging a fatal error, conditionally
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件地记录致命错误
- en: Our grading program is reporting an error and exiting, even if it reads input
    from the keyboard successfully.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的成绩评估程序成功从键盘读取输入，也会报告错误并退出。
- en: '![image](assets/f0042-01.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0042-01.png)'
- en: We know that if the value in our `err` variable is `nil`, it means reading from
    the keyboard was successful. Now that we know about `if` statements, let’s try
    updating our code to log an error and exit only if `err` is *not* `nil`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如果`err`变量的值为`nil`，那么从键盘读取是成功的。既然我们知道了`if`语句，让我们尝试更新我们的代码，只有当`err`不是`nil`时才记录错误并退出。
- en: '![image](assets/f0042-02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0042-02.png)'
- en: If we rerun our program, we’ll see that it’s working again. And now, if there
    are any errors when reading user input, we’ll see those as well!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行我们的程序，我们会看到它又开始工作了。现在，如果在读取用户输入时有任何错误，我们也会看到这些错误！
- en: '![image](assets/f0042-03.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0042-03.png)'
- en: Code Magnets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/f0018-01.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0018-01.png)'
- en: A Go program that prints the size of a file is on the fridge. It calls the `os.Stat`
    function, which returns an `os.FileInfo` value, and possibly an error value. Then
    it calls the `Size` method on the `FileInfo` value to get the file size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 冰箱上有一个打印文件大小的Go程序。它调用`os.Stat`函数，该函数返回一个`os.FileInfo`值，可能还有一个错误值。然后它调用`FileInfo`值上的`Size`方法以获取文件大小。
- en: But the original program uses the `_` blank identifier to ignore the error value
    from `os.Stat`. If an error occurs (which could happen if the file doesn’t exist),
    this will cause the program to fail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但原始程序使用`_`空白标识符来忽略从`os.Stat`返回的错误值。如果发生错误（例如文件不存在），这将导致程序失败。
- en: Reconstruct the extra code snippets to make a program that works just like the
    original one, but also checks for an error from `os.Stat`. If the error from `os.Stat`
    is not `nil`, the error should be reported, and the program should exit. Discard
    the magnet with the `_` blank identifier; it won’t be used in the finished program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重构额外的代码片段，使其功能与原始程序完全相同，但还要检查来自`os.Stat`的错误。如果`os.Stat`返回的错误不是`nil`，则应报告错误并退出程序。丢弃带有`_`空白标识符的磁铁；它在最终程序中不会被使用。
- en: '![image](assets/f0043-02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0043-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_2).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](assets/arrow.png) 答案在[“代码磁铁解决方案”](#code_magnets_solution_2)中。'
- en: Avoid shadowing names
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免名称遮蔽
- en: '![image](assets/f0044-01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0044-01.png)'
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Naming a variable `**error**` would be a bad idea, because it would shadow
    the name of a type called `**error**`**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名一个变量为`**error**`是一个坏主意，因为它会遮蔽名为`**error**`的类型的名称**。'
- en: When you declare a variable, you should make sure it doesn’t have the same name
    as any existing functions, packages, types, or other variables. If something by
    the same name exists in the enclosing scope (we’ll talk about scopes shortly),
    your variable will **shadow** it—that is, take precedence over it. And all too
    often, that’s a bad thing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明一个变量时，应确保它与任何现有的函数、包、类型或其他变量名称不同。如果在封闭作用域中存在同名内容（我们稍后会讨论作用域），则您的变量将**遮蔽**它——即优先使用它。而这往往是件坏事。
- en: Here, we declare a variable named `int` that shadows a type name, a variable
    named `append` that shadows a built-in function name (we’ll see the `append` function
    in [Chapter 6](ch06.html#appending_issuecolon_slices)), and a variable named `fmt`
    that shadows an imported package name. Those names are awkward, but they don’t
    cause any errors by themselves...
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`int`的变量，它遮蔽了一个类型名称，一个名为`append`的变量，它遮蔽了一个内置函数名称（我们将在[第6章](ch06.html#appending_issuecolon_slices)中看到`append`函数），以及一个名为`fmt`的变量，它遮蔽了一个导入的包名称。这些名称可能会让人感到尴尬，但它们本身并不会引发任何错误...
- en: '![image](assets/f0044-02.png)![image](assets/f0044-03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0044-02.png)![图像](assets/f0044-03.png)'
- en: '...But if we try to access the type, function, or package the variables are
    shadowing, we’ll get the value in the variable instead. In this case, it results
    in compile errors:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '...但是，如果我们尝试访问变量遮蔽的类型、函数或包，将会获取变量中的值而不是预期的类型。在这种情况下，会导致编译错误：'
- en: '![image](assets/f0045-01.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0045-01.png)'
- en: 'To avoid confusion for yourself and your fellow developers, you should avoid
    shadowing names wherever possible. In this case, fixing the issue is as simple
    as choosing nonconflicting names for the variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免自己和其他开发者的混淆，您应尽可能避免名称遮蔽。在这种情况下，修复问题就像选择与变量名不冲突的名称一样简单：
- en: '![image](assets/f0045-02.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0045-02.png)'
- en: As we’ll see in [Chapter 3](ch03.html#call_mecolon_functions), Go has a built-in
    type named `error`. So that’s why, when declaring variables meant to hold errors,
    we’ve been naming them `err` instead of `error`—we want to avoid shadowing the
    name of the `error` type with our variable name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第3章](ch03.html#call_mecolon_functions)中看到的那样，Go语言有一个名为`error`的内置类型。因此，当声明用于保存错误的变量时，我们使用`err`而不是`error`的名称——我们希望避免用变量名遮蔽`error`类型的名称。
- en: '![image](assets/f0045-03.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/f0045-03.png)'
- en: If you *do* name your variables `error`, your code will *probably* still work.
    That is, *until* you forget that the `error` type name is shadowed, you try to
    use the type, and you get the variable instead. Don’t take that chance; use the
    name `err` for your error variables!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将变量命名为`error`，您的代码可能仍然能够工作。也就是说，直到您忘记`error`类型名被遮蔽，并尝试使用该类型时，实际获取的是变量。不要冒这个风险；为您的错误变量使用名称`err`！
- en: Converting strings to numbers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: Conditional statements will also let us evaluate the entered grade. Let’s add
    an `if`/`else` statement to determine whether the grade is passing or failing.
    If the entered percentage grade is 60 or greater, we’ll set the status to `"passing"`.
    Otherwise, we’ll set it to `"failing"`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句还允许我们评估输入的成绩。让我们添加一个 `if`/`else` 语句来确定成绩是及格还是不及格。如果输入的百分比成绩为 60 或更高，我们将将状态设置为
    `"passing"`。否则，设置为 `"failing"`。
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In its current form, though, this gets us a compilation error.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，按其当前形式，这会导致编译错误。
- en: '![image](assets/f0046-01.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0046-01.png)'
- en: 'Here’s the problem: input from the keyboard is read in as a string. Go can
    only compare numbers to other numbers; we can’t compare a number with a string.
    And there’s no direct type conversion from `string` to a number:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于：键盘输入的 `input` 被读取为字符串。Go 只能将数字与其他数字进行比较；我们无法将数字与字符串进行比较。而且，从 `string` 直接转换为数字没有直接的类型转换：
- en: '![image](assets/f0046-02.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0046-02.png)'
- en: 'We have a pair of issues to address here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决一对问题：
- en: The `input` string still has a newline character on the end, from when the user
    pressed the Enter key while entering it. We need to strip that off.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input` 字符串仍然在末尾具有换行符，因为用户输入时按 Enter 键。我们需要将其去除。'
- en: The remainder of the string needs to be converted to a floating-point number.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的剩余部分需要转换为浮点数。
- en: Removing the newline character from the end of the `input` string will be easy.
    The `strings` package has a `TrimSpace` function that will remove all whitespace
    characters (newlines, tabs, and regular spaces) from the start and end of a string.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `input` 字符串末尾去除换行符将很容易。`strings` 包有一个 `TrimSpace` 函数，将从字符串开头和末尾去除所有空白字符（换行符、制表符和普通空格）。
- en: '![image](assets/f0047-01a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0047-01a.png)'
- en: So, we can get rid of the newline on `input` by passing it to `TrimSpace`, and
    assigning the return value back to the `input` variable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过将其传递给 `TrimSpace` 来去除 `input` 上的换行符，并将返回值分配回 `input` 变量。
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All that should remain in the `input` string now is the number the user entered.
    We can use the `strconv` package’s `ParseFloat` function to convert it to a `float64`
    value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `input` 字符串中应该只剩下用户输入的数字。我们可以使用 `strconv` 包的 `ParseFloat` 函数将其转换为 `float64`
    值。
- en: '![image](assets/f0047-01.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0047-01.png)'
- en: You pass `ParseFloat` a string that you want to convert to a number, as well
    as the number of bits of precision the result should have. Since we’re converting
    to a `float64` value, we pass the number `64`. (In addition to `float64`, Go offers
    a less precise `float32` type, but you shouldn’t use that unless you have a good
    reason.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您将 `ParseFloat` 传递给要转换为数字的字符串，以及结果应具有的精度位数。因为我们要转换为 `float64` 值，所以传递数字 `64`。（除了
    `float64`，Go 还提供了不那么精确的 `float32` 类型，但除非有充分的理由，否则不应使用。）
- en: '`ParseFloat` converts the string to a number, and returns it as a `float64`
    value. Like `ReadString`, it also has a second return value, an error, which will
    be `nil` unless there was some problem converting the string. (For example, a
    string that *can’t* be converted to a number. We don’t know of a numeric equivalent
    to `"hello"`...)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseFloat` 将字符串转换为数字，并作为 `float64` 值返回。像 `ReadString` 一样，它还有一个第二个返回值，即错误，除非有某些问题转换字符串（例如，无法转换为数字的字符串。我们不知道
    `"hello"` 的数字等价物...）'
- en: 'Let’s update *pass_fail.go* with calls to `TrimSpace` and `ParseFloat`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 *pass_fail.go*，调用 `TrimSpace` 和 `ParseFloat`：
- en: '![image](assets/f0048-01.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0048-01.png)'
- en: First, we add the appropriate packages to the `import` section. We add code
    to remove the newline character from the `input` string. Then we pass `input`
    to `ParseFloat`, and store the resulting `float64` value in a new variable, `grade`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向 `import` 部分添加适当的包。我们添加代码以从 `input` 字符串中删除换行符。然后将 `input` 传递给 `ParseFloat`，并将生成的
    `float64` 值存储在新变量 `grade` 中。
- en: Just as we did with `ReadString`, we test whether `ParseFloat` returns an error
    value. If it does, we report it and stop the program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 `ReadString` 中所做的那样，我们测试 `ParseFloat` 是否返回错误值。如果返回错误，我们报告错误并停止程序。
- en: Finally, we update the conditional statement to test the number in `grade`,
    rather than the string in `input`. That should fix the error stemming from comparing
    a string to a number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新条件语句，以测试 `grade` 中的数字，而不是 `input` 中的字符串。这应该修复由于比较字符串与数字而导致的错误。
- en: If we try to run the updated program, we no longer get the `mismatched types
    string and int` error. So it looks like we’ve fixed that issue. But we’ve got
    a couple more errors to address. We’ll look at those next.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行更新后的程序，就不再会出现`类型不匹配的字符串和整数`错误。看起来我们已经解决了那个问题。但是还有几个错误需要解决。接下来我们会看看这些。
- en: '![image](assets/f0048-02.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0048-02.png)'
- en: Blocks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块
- en: 'We’ve converted the user’s grade input to a `float64` value, and added it to
    a conditional to determine if it’s passing or failing. But we’re getting a couple
    more compile errors:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将用户的成绩输入转换为`float64`值，并将其添加到条件语句中以确定是否通过或失败。但我们又遇到了几个编译错误：
- en: '![image](assets/f0049-01.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0049-01.png)'
- en: As we’ve seen previously, declaring a variable like `status` without using it
    afterward is an error in Go. It seems a little strange that we’re getting the
    error twice, but let’s disregard that for now. We’ll add a call to `Println` to
    print the percentage grade we were given, and the value of `status`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，像`status`这样声明一个变量，而后不使用它是Go语言中的一个错误。我们得到错误两次似乎有些奇怪，但现在先不管它。我们将在`Println`中添加一个调用，打印给定的百分比成绩和`status`的值。
- en: '![image](assets/f0049-02.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0049-02.png)'
- en: But now we get a *new* error, saying that the `status` variable is undefined
    when we attempt to use it in our `Println` statement! What’s going on?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们又得到了一个*新*的错误，说在我们的`Println`语句中尝试使用`status`变量时未定义！出了什么问题？
- en: Go code can be divided up into **blocks**, segments of code. Blocks are usually
    surrounded by curly braces (`{}`), although there are also blocks at the source
    code file and package levels. Blocks can be nested inside one another.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码可以被划分为**块**，代码段。块通常用花括号(`{}`)括起来，虽然在源代码文件和包级别也有块。块可以嵌套在彼此内部。
- en: '![image](assets/f0049-03.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0049-03.png)'
- en: The bodies of functions and conditionals are both blocks as well. Understanding
    this will be key to solving our problem with the `status` variable...
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体和条件语句的主体也都是块。理解这一点将对解决我们在`status`变量上的问题至关重要…
- en: Blocks and variable scope
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块和变量作用域
- en: 'Each variable you declare has a **scope**: a portion of your code that it’s
    “visible” within. A declared variable can be accessed anywhere within its scope,
    but if you try to access it outside that scope, you’ll get an error.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个你声明的变量都有一个**作用域**：它在代码中“可见”的一部分。声明的变量可以在其作用域内的任何地方访问，但如果你尝试在该作用域之外访问它，就会收到一个错误。
- en: A variable’s scope consists of the block it’s declared in and any blocks nested
    within that block.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域包括它声明的块及其嵌套在其中的任何块。
- en: '![image](assets/f0050-01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0050-01.png)'
- en: 'Here are the scopes of the variables in the code above:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是代码中变量的作用域：
- en: The scope of `packageVar` is the entire `main` package. You can access `packageVar`
    anywhere within any function you define in the package.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packageVar`的作用域是整个`main`包。你可以在包中定义的任何函数内部的任何地方访问`packageVar`。'
- en: The scope of `functionVar` is the entire function it’s declared in, including
    the `if` block nested within that function.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functionVar`的作用域是它所声明的整个函数，包括该函数内部嵌套的`if`块。'
- en: The scope of `conditionalVar` is limited to the `if` block. When we try to access
    `conditionalVar` *after* the closing `}` brace of the `if` block, we’ll get an
    error saying that `conditionalVar` is undefined!
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conditionalVar`的作用域仅限于`if`块。当我们在`if`块的闭合`}`后尝试访问`conditionalVar`时，将会收到一个错误，提示`conditionalVar`未定义！'
- en: Now that we understand variable scope, we can explain why our `status` variable
    was undefined in the grading program. We declared `status` in our conditional
    blocks. (In fact, we declared it twice, since there are two separate blocks. That’s
    why we got two `status declared and not used` errors.) But then we tried to access
    `status` *outside* those blocks, where it was no longer in scope.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了变量作用域，我们可以解释为什么我们的`status`变量在评分程序中未定义了。我们在条件块中声明了`status`。（事实上，我们声明了两次，因为有两个单独的块。这就是为什么我们会得到两个`status
    declared and not used`错误。）但是后来我们试图在那些块的*外部*访问`status`，此时它已经不在作用域内了。
- en: '![image](assets/f0051-01.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0051-01.png)'
- en: The solution is to move the declaration of the `status` variable out of the
    conditional blocks, and up to the function block. Once we do that, the `status`
    variable will be in scope both within the nested conditional blocks *and* at the
    end of the function block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将`status`变量的声明移出条件块，并移到函数块顶部。这样一来，`status`变量将在嵌套的条件块内部和函数块的末尾都可以访问。
- en: '![image](assets/f0051-02.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0051-02.png)'
- en: We’ve finished the grading program!
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们已完成评分程序！
- en: 'That was it! Our *pass_fail.go* program is ready for action! Let’s take one
    more look at the complete code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的*pass_fail.go*程序已经准备就绪！让我们再看一下完整的代码：
- en: '![image](assets/f0052-01.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0052-01.png)'
- en: You can try running the finished program as many times as you like. Enter a
    percentage grade under 60, and it will report a failing status. Enter a grade
    over 60, and it will report that it’s passing. Looks like everything’s working!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意运行完成的程序多次。输入低于 60 的百分比成绩，它将报告不及格状态。输入超过 60 的成绩，它将报告及格状态。看起来一切正常运行！
- en: '![image](assets/f0052-02.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0052-02.png)'
- en: Only one variable in a short variable declaration has to be new
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短变量声明中只有一个变量必须是新的
- en: '![image](assets/f0054-01.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0054-01.png)'
- en: 'It’s true that when the same variable name is declared twice in the same scope,
    we get a compile error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，当在同一作用域内声明同名变量两次时，我们会得到一个编译错误：
- en: '![image](assets/f0054-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0054-02.png)'
- en: But as long as at least one variable name in a short variable declaration is
    new, it’s allowed. The new variable names are treated as a declaration, and the
    existing names are treated as an assignment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但只要短变量声明中至少有一个变量名是新的，就是允许的。新变量名被视为声明，现有变量名被视为赋值。
- en: '![image](assets/f0054-03.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0054-03.png)'
- en: 'There’s a reason for this special handling: a lot of Go functions return multiple
    values. It would be a pain if you had to declare all the variables separately
    just because you want to reuse one of them.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊处理的原因：很多 Go 函数返回多个值。如果你因为想重用其中一个变量而不得不单独声明所有变量会很麻烦。
- en: '![image](assets/f0054-04.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0054-04.png)'
- en: Instead, Go lets you use a short variable declaration for everything, even if
    for *one* of the variables, it’s actually an assignment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Go 允许你为所有东西使用短变量声明，即使对于*一个*变量，它实际上是一个赋值操作。
- en: '![image](assets/f0054-05.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0054-05.png)'
- en: Let’s build a game
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来制作一个游戏
- en: We’re going to wrap up this chapter by building a simple game. If that sounds
    daunting, don’t worry; you’ve already learned most of the skills you’re going
    to need! Along the way, we’ll learn about *loops*, which will allow the player
    to take multiple turns.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过制作一个简单的游戏来结束本章。如果听起来有些艰巨，不用担心；你已经学会了大部分你将需要的技能！在此过程中，我们将学习关于*循环*的知识，这将允许玩家进行多次回合。
- en: 'Let’s look at everything we’ll need to do:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要做的所有事情：
- en: '![image](assets/f0055-01.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0055-01.png)'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This example debuted in Head First Ruby. (Another fine book that you should
    also buy!) It worked so well that we’re using it again here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首次出现在《Head First Ruby》中。（另一本你也应该买的好书！）它非常成功，所以我们在这里再次使用它。
- en: '![image](assets/f0055-02.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0055-02.png)'
- en: Figure 2-1\. Gary Richardott Game Designer
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 加里·理查德特 游戏设计师
- en: Let’s create a new source file, named *guess.go*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为*guess.go*的新源文件。
- en: It looks like our first requirement is to generate a random number. Let’s get
    started!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的第一个要求是生成一个随机数。让我们开始吧！
- en: Package names vs. import paths
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包名与导入路径
- en: The `math/rand` package has a `Intn` function that can generate a random number
    for us, so we’ll need to import `math/rand`. Then we’ll call `rand.Intn` to generate
    the random number.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`math/rand`包有一个`Intn`函数可以为我们生成一个随机数，所以我们需要导入`math/rand`。然后我们将调用`rand.Intn`来生成随机数。'
- en: '![image](assets/f0056-01.png)![image](assets/f0056-02.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0056-01.png)![image](assets/f0056-02.png)'
- en: '**One is the package’s import path, and the other is the package’s name**.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个是包的导入路径，另一个是包的名称**。'
- en: When we say `math/rand` we’re referring to the package’s *import path*, not
    its *name*. An **import path** is just a unique string that identifies a package
    and that you use in an `import` statement. Once you’ve imported the package, you
    can refer to it by its package name.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`math/rand`时，我们指的是包的*导入路径*，而不是*名称*。**导入路径**只是一个唯一的字符串，用于标识一个包，并在`import`语句中使用。导入了包之后，可以用其包名引用它。
- en: 'For every package we’ve used so far, the import path has been identical to
    the package name. Here are a few examples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的每个包的导入路径都与包名相同。以下是一些示例：
- en: '| Import path | Package name |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 导入路径 | 包名 |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"fmt"` | `fmt` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `"fmt"` | `fmt` |'
- en: '| `"log"` | `log` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `"log"` | `log` |'
- en: '| `"strings"` | `strings` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `"strings"` | `strings` |'
- en: But the import path and package name don’t have to be identical. Many Go packages
    fall into similar categories, like compression or complex math. So they’re grouped
    together under similar import path prefixes, such as `"archive/"` or `"math/"`.
    (Think of them as being similar to the paths of directories on your hard drive.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但导入路径和包名不一定相同。许多 Go 包属于类似的类别，如压缩或复杂数学。因此，它们被分组到类似的导入路径前缀下，如 `"archive/"` 或 `"math/"`。（可以把它们想象成硬盘驱动器上目录的路径。）
- en: '| Import path | Package name |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 导入路径 | 包名 |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"archive"` | `archive` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `"archive"` | `archive` |'
- en: '| `"archive/tar"` | `tar` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `"archive/tar"` | `tar` |'
- en: '| `"archive/zip"` | `zip` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `"archive/zip"` | `zip` |'
- en: '| `"math"` | `math` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `"math"` | `math` |'
- en: '| `"math/cmplx"` | `cmplx` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `"math/cmplx"` | `cmplx` |'
- en: '| `"math/rand"` | `rand` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `"math/rand"` | `rand` |'
- en: The Go language doesn’t require that a package name have anything to do with
    its import path. But by convention, the last (or only) segment of the import path
    is also used as the package name. So if the import path is `"archive"`, the package
    name will be `archive`, and if the import path is `"archive/zip"`, the package
    name will be `zip`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 语言不要求包名与其导入路径有任何关系，但按照惯例，导入路径的最后（或唯一）段也用作包名。因此，如果导入路径是 `"archive"`，包名将是
    `archive`，如果导入路径是 `"archive/zip"`，包名将是 `zip`。
- en: '| Import path | Package name |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 导入路径 | 包名 |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"archive"` | archive |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `"archive"` | archive |'
- en: '| `"archive/tar"` | tar |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `"archive/tar"` | `tar` |'
- en: '| `"archive/zip"` | zip |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `"archive/zip"` | `zip` |'
- en: '| `"math"` | math |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `"math"` | `math` |'
- en: '| `"math/cmplx"` | cmplx |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `"math/cmplx"` | cmplx |'
- en: '| `"math/rand"` | rand |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `"math/rand"` | rand |'
- en: 'So, that’s why our `import` statement uses a path of `"math/rand"`, but our
    `main` function just uses the package name: `rand`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是为什么我们的 `import` 语句使用路径 `"math/rand"`，但我们的 `main` 函数只使用包名 `rand`。
- en: '![image](assets/f0057-02.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0057-02.png)'
- en: Generating a random number
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成一个随机数
- en: Pass a number to `rand.Intn`, and it will return a random integer between `0`
    and the number you provided. In other words, if we pass an argument of `100`,
    we’ll get a random number in the range 0–99\. Since we need a number in the range
    1–100, we’ll just add `1` to whatever random value we get. We’ll store the result
    in a variable, `target`. We’ll do more with `target` later, but for now we’ll
    just print it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数字传递给 `rand.Intn`，它将返回一个介于 `0` 和你提供的数字之间的随机整数。换句话说，如果我们传递一个参数 `100`，我们将得到一个在
    0 到 99 范围内的随机数。由于我们需要的是 1 到 100 范围内的数，我们将随机值加 `1`。我们将结果存储在变量 `target` 中。稍后我们会进一步处理
    `target`，但现在我们只需打印它。
- en: '![image](assets/f0057-03.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0057-03.png)'
- en: If we try running our program right now, we’ll get a random number. But we just
    get the *same* random number over and over! The problem is, random numbers generated
    by computers aren’t really that random. But there’s a way to increase that randomness...
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试运行程序，我们将得到一个随机数。但我们每次都只得到*相同*的随机数！问题在于，计算机生成的随机数并不是真正随机的。但有一种方法可以增加这种随机性……
- en: '![image](assets/f0057-04.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0057-04.png)'
- en: To get different random numbers, we need to pass a value to the `rand.Seed`
    function. That will “seed” the random number generator—that is, give it a value
    that it will use to generate other random values. But if we keep giving it the
    same seed value, it will keep giving us the same random values, and we’ll be back
    where we started.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得不同的随机数，我们需要向 `rand.Seed` 函数传递一个值。这将“种子”随机数生成器，即给它一个值，它将用来生成其他随机值。但如果我们继续给它相同的种子值，它将一直给我们相同的随机值，我们将回到原点。
- en: We saw earlier that the `time.Now` function will give us a `Time` value representing
    the current date and time. We can use that to get a different seed value every
    time we run our program.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到 `time.Now` 函数会给我们一个代表当前日期和时间的 `Time` 值。我们可以用它来获得每次运行程序时都不同的种子值。
- en: '![image](assets/f0058-01.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0058-01.png)'
- en: The `rand.Seed` function expects an integer, so we can’t pass it a `Time` value
    directly. Instead, we call the `Unix` method on the `Time`, which will convert
    it to an integer. (Specifically, it will convert it to Unix time format, which
    is an integer with the number of seconds since January 1, 1970\. But you don’t
    really need to remember that.) We pass that integer to `rand.Seed`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `rand.Seed` 需要一个整数作为参数，所以我们不能直接传递一个 `Time` 值。相反，我们在 `Time` 上调用 `Unix` 方法，它会将其转换为一个整数（具体来说，它会转换为
    Unix 时间格式，这是一个自 1970 年 1 月 1 日以来的秒数整数。但你不必真正记住这些。）我们将这个整数传递给 `rand.Seed`。
- en: We also add a couple `Println` calls to let the user know we’ve chosen a random
    number. But aside from that, we can leave the rest of our code, including the
    call to `rand.Intn`, as is. Seeding the generator should be the only change we
    need to make.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了几个`Println`调用，让用户知道我们选择了一个随机数。但除此之外，我们可以保留其余代码，包括对`rand.Intn`的调用。播种生成器应该是我们需要做的唯一更改。
- en: Now, each time we run our program, we’ll see our message, along with a random
    number. It looks like our changes are successful!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次运行我们的程序，我们都会看到我们的消息，以及一个随机数。看起来我们的更改是成功的！
- en: '![image](assets/f0058-02.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0058-02.png)'
- en: Getting an integer from the keyboard
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从键盘获取一个整数
- en: Our first requirement is complete! Next we need to get the user’s guess via
    the keyboard.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个要求已完成！接下来我们需要通过键盘获取用户的猜测。
- en: That should work in much the same way as when we read in a percentage grade
    from the keyboard for our grading program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与我们为分级程序从键盘读取百分比成绩时的方式基本相同。
- en: '![image](assets/f0059-01.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0059-01.png)'
- en: 'There will be only one difference: instead of converting the input to a `float64`,
    we need to convert it to an `int` (since our guessing game uses only whole numbers).
    So we’ll pass the string read from the keyboard to the `strconv` package’s `Atoi`
    (string to integer) function instead of its `ParseFloat` function. `Atoi` will
    give us an integer as its return value. (Just like `ParseFloat`, `Atoi` might
    also give us an error if it can’t convert the string. If that happens, we again
    report the error and exit.)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个区别：我们需要将输入转换为`int`（因为我们的猜数字游戏只使用整数）。因此，我们将从键盘读取的字符串传递给`strconv`包的`Atoi`（字符串转整数）函数，而不是它的`ParseFloat`函数。`Atoi`将返回一个整数作为其返回值。（就像`ParseFloat`一样，如果无法转换字符串，`Atoi`也可能会给我们一个错误。如果发生这种情况，我们再次报告错误并退出。）
- en: '![image](assets/f0059-02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0059-02.png)'
- en: Comparing the guess to the target
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将猜测与目标进行比较
- en: Another requirement finished. And this next one will be easy... We just need
    to compare the user’s guess to the randomly generated number, and tell them whether
    it was higher or lower.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要求完成了。接下来将很容易...我们只需要将用户的猜测与随机生成的数字进行比较，并告诉他们猜测是高还是低。
- en: '![image](assets/f0060-01.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0060-01.png)'
- en: If `guess` is less than `target`, we need to print a message saying the guess
    was low. *Otherwise, if* `guess` is greater than `target`, we should print a message
    saying the guess was high. Sounds like we need an `if`...`else if` statement.
    We’ll add it below the other code in our `main` function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`guess`小于`target`，我们需要打印一条消息说猜测偏低。*否则，如果*`guess`大于`target`，我们应该打印一条消息说猜测偏高。听起来我们需要一个`if`...`else
    if`语句。我们将在`main`函数中的其他代码下面添加它。
- en: '![image](assets/f0060-02.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0060-02.png)'
- en: Now try running our updated program from the terminal. It’s still set up to
    print `target` each time it runs, which will be useful for debugging. Just enter
    a number lower than `target`, and you should be told your guess was low. If you
    rerun the program, you’ll get a new `target` value. Enter a number higher than
    that, and you’ll be told your guess was high.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试从终端运行我们更新后的程序。它仍然设置为每次运行时打印`target`，这对于调试很有用。只需输入一个低于`target`的数字，你应该会被告知你的猜测偏低。如果重新运行程序，你将得到一个新的`target`值。输入一个高于该值的数字，你将被告知你的猜测偏高。
- en: '![image](assets/f0060-03.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0060-03.png)'
- en: Loops
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Another requirement down! Let’s look at the next one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 又一个要求完成了！让我们看看下一个。
- en: '![image](assets/f0061-01.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0061-01.png)'
- en: Currently, the player only gets to guess once, but we need to allow them to
    guess up to 10 times.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家只能猜一次，但我们需要允许他们最多猜`10`次。
- en: The code to prompt for a guess is already in place. We just need to run it *more
    than once*. We can use a **loop** to execute a block of code repeatedly. If you’ve
    used other programming languages, you’ve probably encountered loops. When you
    need one or more statements executed over and over, you place them inside a loop.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 提示玩家猜测的代码已经就位。我们只需要*多次*运行它。我们可以使用**循环**来重复执行一段代码。如果你使用过其他编程语言，你可能遇到过循环。当你需要一条或多条语句重复执行时，你将它们放在循环内部。
- en: '![image](assets/f0061-02.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0061-02.png)'
- en: 'Loops always begin with the `for` keyword. In one common kind of loop, `for`
    is followed by three segments of code that control the loop:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 循环总是以`for`关键字开头。在一种常见的循环中，`for`后面跟着三个控制循环的代码段：
- en: An initialization (or init) statement that is usually used to initialize a variable
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化语句，通常用于初始化一个变量
- en: A condition expression that determines when to break out of the loop
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条件表达式，确定何时退出循环
- en: A post statement that runs after each iteration of the loop
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后置语句在每次循环迭代后运行
- en: Often, the initialization statement is used to initialize a variable, the condition
    expression keeps the loop running until that variable reaches a certain value,
    and the post statement is used to update the value of that variable. For example,
    in this snippet, the `t` variable is initialized to `3`, the condition keeps the
    loop going while `t > 0`, and the post statement subtracts `1` from `t` each time
    the loop runs. Eventually, `t` reaches `0` and the loop ends.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，初始化语句用于初始化变量，条件表达式使循环在变量达到特定值之前继续运行，后置语句用于更新该变量的值。例如，在此片段中，`t` 变量初始化为 `3`，条件为
    `t > 0` 时循环继续运行，并且后置语句每次循环时从 `t` 减去 `1`。最终，`t` 达到 `0` 时循环结束。
- en: '![image](assets/f0061-03.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0061-03.png)'
- en: The `++` and `--` statements are frequently used in loop post statements. Each
    time they’re evaluated, `++` adds `1` to a variable’s value, and `--` subtracts
    `1`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 和 `--` 语句经常用作循环后置语句。每次评估它们时，`++` 将 `1` 添加到变量的值，而 `--` 将 `1` 减去。'
- en: '![image](assets/f0062-01.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0062-01.png)'
- en: Used in a loop, `++` and `--` are convenient for counting up or down.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 和 `--` 在循环中使用时，便于计数向上或向下。'
- en: '![image](assets/f0062-02.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0062-02.png)'
- en: Go also includes the assignment operators `+=` and `-=`. They take the value
    in a variable, add or subtract another value, and then assign the result back
    to the variable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还包括赋值运算符 `+=` 和 `-=`。它们获取变量中的值，添加或减去另一个值，然后将结果重新赋给变量。
- en: '![image](assets/f0062-03.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0062-03.png)'
- en: '`+=` and `-=` can be used in a loop to count in increments other than `1`.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`+=` 和 `-=` 可以在循环中使用，以便按照除 `1` 外的增量计数。'
- en: '![image](assets/f0062-04.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0062-04.png)'
- en: 'When the loop finishes, execution will resume with whatever statement follows
    the loop block. But the loop will keep going as long as the condition expression
    evaluates to `true`. It’s possible to abuse this; here are examples of a loop
    that will run forever, and a loop that will never run at all:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，执行将恢复到循环块后面的语句。但只要条件表达式评估为`true`，循环将继续进行。这可能被滥用；以下是永远运行的循环示例和根本不会运行的循环示例：
- en: '![image](assets/f0062-05.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0062-05.png)'
- en: Init and post statements are optional
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化语句和后置语句是可选的
- en: If you want, you can leave out the init and post statements from a `for` loop,
    leaving only the condition expression (although you still need to make sure the
    condition eventually evaluates to `false`, or you could have an infinite loop
    on your hands).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，您可以从 `for` 循环中省略初始化和后置语句，仅留下条件表达式（尽管您仍然需要确保条件最终评估为 `false`，否则您可能会遇到无限循环的问题）。
- en: '![image](assets/f0063-01.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0063-01.png)'
- en: Loops and scope
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环和作用域
- en: Just like with conditionals, the scope of any variables declared within a loop’s
    block is limited to that block (although the init statement, condition expression,
    and post statement can be considered part of that scope as well).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 就像条件语句一样，循环块内声明的任何变量的作用域仅限于该块（尽管初始化语句、条件表达式和后置语句也可视为该作用域的一部分）。
- en: '![image](assets/f0063-02.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0063-02.png)'
- en: Also as with conditionals, any variable declared *before* the loop will still
    be in scope within the loop’s control statements and block, *and* will still be
    in scope after the loop exits.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就像条件语句一样，在循环的控制语句和块之前声明的任何变量*仍然*在循环内的作用域内，并且在循环退出后*仍然*在作用域内。
- en: '![image](assets/f0063-03.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0063-03.png)'
- en: Breaking Stuff is Educational!
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏东西是教育性的！
- en: '![image](assets/f0006-01.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0006-01.png)'
- en: Here’s a program that uses a loop to count to 3\. Try making one of the changes
    below and run it. Then undo your change and try the next one. See what happens!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用循环计数到 `3` 的程序。尝试进行以下更改并运行它。然后撤消您的更改并尝试下一个。看看会发生什么！
- en: '![image](assets/f0064-02.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0064-02.png)'
- en: '| If you do this... | ...it will break because... |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 如果你这样做... | ...它会中断，因为... |'
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Add parentheses after the `for` keyword `for (x := 1; x <= 3; x++)` | Some
    other languages *require* parentheses around a `for` loop’s control statements,
    but not only does Go not require them, it doesn’t *allow* them. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 在 `for` 关键字后加上括号 `for (x := 1; x <= 3; x++)` | 某些其他语言要求在 `for` 循环的控制语句周围加上括号，但是
    Go 不仅不需要它们，而且*禁止*使用它们。 |'
- en: '| Delete the `:` from the init statement `x = 1` | Unless you’re assigning
    to a variable that’s already been declared in the enclosing scope (which you usually
    won’t be), the init statement needs to be a *declaration*, not an *assignment.*
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 从初始化语句`x = 1`中删除`:` | 除非你正在给封闭作用域中已声明的变量赋值（通常情况下不会这样），初始化语句必须是一个*声明*，而不是一个*赋值*。
    |'
- en: '| Remove the `=` from the condition expression `x < 3` | The expression `x
    < 3` becomes `false` when `x` reaches `3` (whereas `x <= 3` would still be `true`).
    So the loop would only count to `2`. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 从条件表达式`x < 3`中移除`=` | 当`x`达到`3`时，表达式`x < 3`变为`false`（而`x <= 3`仍然为`true`）。因此，循环只会计数到`2`。
    |'
- en: '| Reverse the comparison in the condition expression `x >= 3` | Because the
    condition is already `false` when the loop begins (`x` is initialized to `1`,
    which is *less* than `3`), the loop will never run. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 反转条件表达式`x >= 3`中的比较 | 因为条件在循环开始时已经是`false`（`x`被初始化为`1`，比`3`*小*），所以循环永远不会运行。
    |'
- en: '| Change the post statement from `x++` to `x--` `x--` | The `x` variable will
    start counting *down* from `1` (`1`, `0`, `-1`, `-2`, etc.), and since it will
    never be greater than `3`, the loop will never end. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 将后置语句从`x++`改为`x--` `x--` | `x`变量将从`1`开始递减（`1`、`0`、`-1`、`-2`等），并且由于它永远不会大于`3`，因此循环永远不会结束。
    |'
- en: '| Move the `fmt.Println(x)` statement outside the loop’s block | Variables
    declared in the init statement or within the loop block are only in scope within
    the loop block. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 将`fmt.Println(x)`语句移到循环块之外 | 在初始化语句或循环块内声明的变量只在循环块内有效。 |'
- en: Using a loop in our guessing game
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的猜测游戏中使用循环
- en: Our game still only prompts the user for a guess once. Let’s add a loop around
    the code that prompts the user for a guess and tells them if it was low or high,
    so that the user can guess 10 times.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏仍然只提示用户一次猜测。让我们在提示用户猜测并告知他们是否太低或太高的代码周围添加一个循环，以便用户可以猜测10次。
- en: We’ll use an `int` variable named `guesses` to track the number of guesses the
    player has made. In our loop’s init statement, we’ll initialize `guesses` to `0`.
    We’ll add `1` to `guesses` with each iteration of the loop, and we’ll stop the
    loop when `guesses` reaches `10`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`guesses`的`int`变量来跟踪玩家已经猜测的次数。在循环的初始化语句中，我们将`guesses`初始化为`0`。每次循环迭代时，我们将`guesses`加`1`，当`guesses`达到`10`时，我们将停止循环。
- en: We’ll also add a `Println` statement at the top of the loop’s block to tell
    the user how many guesses they have left.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在循环块的顶部添加一个`Println`语句，告诉用户剩余的猜测次数。
- en: '![image](assets/f0066-01.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0066-01.png)'
- en: Now that our loop is in place, if we run our game again, we’ll get asked 10
    times what our guess is!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的循环已经就位，如果再次运行游戏，我们将被询问10次猜测的内容！
- en: '![image](assets/f0067-01.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0067-01.png)'
- en: Since the code to prompt for a guess and state whether it was high or low is
    inside the loop, it gets run repeatedly. After 10 guesses, the loop (and the game)
    will end.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于提示猜测并声明是否过高或过低的代码位于循环内部，因此它会被重复运行。经过10次猜测后，循环（和游戏）将结束。
- en: But the loop always runs 10 times, even if the player guesses correctly! Fixing
    that will be our next requirement.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但是即使玩家猜对了，循环也总是运行10次！修复这个问题将是我们的下一个要求。
- en: Skipping parts of a loop with “continue” and “break”
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“continue”和“break”跳过循环的部分
- en: The hard part is done! We only have a couple requirements left to go.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 辛苦部分已经完成！我们只剩下几个要求需要完成。
- en: Right now, the loop that prompts the user for a guess always runs 10 times.
    Even if the player guesses correctly, we don’t tell them so, and we don’t stop
    the loop. Our next task is to fix that.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，提示用户猜测的循环总是运行10次。即使玩家猜对了，我们也不告诉他们，并且我们不停止循环。我们的下一个任务是修复这个问题。
- en: '![image](assets/f0068-01.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0068-01.png)'
- en: Go provides two keywords that control the flow of a loop. The first, `continue`,
    immediately skips to the next iteration of a loop, without running any further
    code in the loop block.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言提供了两个控制循环流程的关键字。第一个是`continue`，立即跳到循环的下一次迭代，而不执行循环块中的任何其他代码。
- en: '![image](assets/f0068-02.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0068-02.png)'
- en: In the above example, the string `"after continue"` never gets printed, because
    the `continue` keyword always skips back to the top of the loop before the second
    call to `Println` can be run.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，字符串`"after continue"`永远不会被打印，因为`continue`关键字总是在第二次调用`Println`之前跳回循环顶部。
- en: The second keyword, `break`, immediately breaks out of a loop. No further code
    within the loop block is executed, and no further iterations are run. Execution
    moves to the first statement following the loop.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键字，`break`，立即中断循环。循环块内部的代码不再执行，也不再进行进一步的迭代。执行转移到循环后的第一个语句。
- en: '![image](assets/f0068-03.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0068-03.png)'
- en: Here, in the first iteration of the loop, the string `"before break"` gets printed,
    but then the `break` statement immediately breaks out of the loop, without printing
    the `"after break"` string, and without running the loop again (even though it
    normally would have run two more times). Execution instead moves to the statement
    following the loop.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第一次迭代中，字符串 `"before break"` 被打印出来，但是 `break` 语句立即中断了循环，没有打印 `"after break"`
    字符串，并且不再运行循环（尽管通常还会再运行两次）。执行转而移到循环后的语句。
- en: 'The `break` keyword seems like it would be applicable to our current problem:
    we need to break out of our loop when the player guesses correctly. Let’s try
    using it in our game...'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 关键字似乎适用于我们当前的问题：当玩家猜测正确时，我们需要中断循环。让我们在游戏中尝试使用它...'
- en: Breaking out of our guessing loop
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出我们的猜测循环
- en: We’re using an `if`...`else if` conditional to tell the player the status of
    their guess. If the player guesses a number too high or too low, we currently
    print a message telling them so.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `if`...`else if` 条件语句来告诉玩家他们猜测的状态。如果玩家猜测的数字太高或太低，我们目前会打印一条消息告诉他们。
- en: It stands to reason that if the guess is neither too high *nor* too low, it
    must be correct. So let’s add an `else` branch onto the conditional, that will
    run in the event of a correct guess. Inside the block for the `else` branch, we’ll
    tell the player they were right, and then use the `break` statement to stop the
    guessing loop.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猜测既不太高*也*不太低，那么它必须是正确的。因此，让我们在条件语句上添加一个 `else` 分支，在猜测正确的情况下运行。在 `else` 分支的块内部，我们会告诉玩家他们猜对了，并使用
    `break` 语句来停止猜测循环。
- en: '![image](assets/f0069-01.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0069-01.png)'
- en: Now, when the player guesses correctly, they’ll see a congratulatory message,
    and the loop will exit without repeating the full 10 times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家猜测正确时，他们将看到一条祝贺的消息，并且循环将在不再完全重复10次的情况下退出。
- en: '![image](assets/f0069-02.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0069-02.png)'
- en: That’s another requirement complete!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 又完成了另一个要求！
- en: Revealing the target
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示目标
- en: '![image](assets/f0070-01.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0070-01.png)'
- en: We’re *so* close! Just one more requirement left!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离成功*如此*近！只剩下一个要求了！
- en: If the player makes 10 guesses without finding the target number, the loop will
    exit. In that event, we need to print a message saying they lost, and tell them
    what the target was.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家猜测了10次仍未找到目标数字，则循环将退出。在这种情况下，我们需要打印一条消息告诉他们输了，并告诉他们目标是什么。
- en: But we *also* exit the loop if the player guesses correctly. We don’t want to
    say the player has lost when they’ve already won!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果玩家猜对了，我们*也*会退出循环。我们不希望在玩家已经赢得胜利时说他们输了！
- en: So, before our guessing loop, we’ll declare a `success` variable that holds
    a `bool`. (We need to declare it *before* the loop so that it’s still in scope
    after the loop ends.) We’ll initialize `success` to a default value of `false`.
    Then, if the player guesses correctly, we’ll set `success` to `true`, indicating
    we don’t need to print the failure message.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的猜测循环之前，我们将声明一个 `success` 变量，它保存一个布尔值。（我们需要在循环之前声明它，以便在循环结束后仍然在范围内。）我们将
    `success` 初始化为默认值 `false`。然后，如果玩家猜对了，我们将 `success` 设置为 `true`，表示我们不需要打印失败消息。
- en: '![image](assets/f0070-02.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0070-02.png)'
- en: After the loop, we add an `if` block that prints the failure message. But an
    `if` block only runs if its condition evaluates to `true`, and we only want to
    print the failure message if `success` is `false`. So we add the Boolean negation
    operator (`!`). As we saw earlier, `!` turns `true` values `false` and `false`
    values `true`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之后，我们添加了一个 `if` 块来打印失败消息。但是 `if` 块只有在条件为 `true` 时才会执行，我们只想在 `success` 为 `false`
    时打印失败消息。因此，我们添加了布尔取反运算符（`!`）。正如我们之前看到的，`!` 将 `true` 变为 `false`，将 `false` 变为 `true`。
- en: The result is that the failure message will be printed if `success` is `false`,
    but *won’t* be printed if `success` is `true`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，如果 `success` 是 `false`，则会打印失败消息，但如果 `success` 是 `true`，则不会打印。
- en: The finishing touches
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的润色
- en: '![image](assets/f0071-01.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0071-01.png)'
- en: Congratulations, that’s the last requirement!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这是最后一个要求！
- en: Let’s take care of a couple final issues with our code, and then try out our
    game!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一些代码的最后问题，然后试试我们的游戏！
- en: First, as we mentioned, it’s typical to add a comment at the top of each Go
    program describing what it does. Let’s add one now.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如我们提到的，每个 Go 程序顶部通常添加一条注释来描述其功能。现在让我们添加一条。
- en: '![image](assets/f0071-02.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0071-02.png)'
- en: Our program is also encouraging cheaters by printing the target number at the
    start of every game. Let’s remove the `Println` call that does that.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序还通过在每次游戏开始时打印目标数字来鼓励作弊者。让我们删除执行此操作的 `Println` 调用。
- en: '![image](assets/f0071-03.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0071-03.png)'
- en: We’re finally ready to try running our complete code!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好尝试运行我们的完整代码了！
- en: First, we’ll run out of guesses on purpose to ensure the target number gets
    displayed...
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们故意用尽猜测次数以确保目标数字被显示...
- en: '![image](assets/f0071-04.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0071-04.png)'
- en: Then we’ll try guessing successfully.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将尝试成功猜测。
- en: Our game is working great!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏运行得很顺利！
- en: '![image](assets/f0071-05.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0071-05.png)'
- en: Congratulations, your game is complete!
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恭喜，您的游戏已完成！
- en: '![image](assets/f0072-01.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0072-01.png)'
- en: Using conditionals and loops, you’ve written a complete game in Go! Pour yourself
    a cold drink—you’ve earned it!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件和循环，您已在 Go 中编写了一个完整的游戏！请为自己倒一杯冷饮——您赢得了它！
- en: '**Here’s our complete guess.go source code!**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**这是我们完整的 guess.go 源代码！**'
- en: '![image](assets/f0073-01.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0073-01.png)'
- en: Your Go Toolbox
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的 Go 工具箱
- en: '![image](assets/f0074-01.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0074-01.png)'
- en: '**That’s it for [Chapter 2](#which_code_runs_nextquestcolon_condition)! You’ve
    added conditionals and loops to your toolbox**.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是[第2章](#which_code_runs_nextquestcolon_condition)的全部内容！您已将条件和循环添加到您的工具箱中**。'
- en: '![image](assets/f0074-02.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0074-02.png)'
- en: Note
  id: totrans-344
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Loops**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**'
- en: Loops cause a block of code to execute repeatedly.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 循环使一段代码重复执行。
- en: One common kind of loop starts with the keyword “for”, followed by an init statement
    that initializes a variable, a condition expression that determines when to break
    out of the loop, and a post statement that runs after each iteration of the loop.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的循环以关键字“for”开头，后跟初始化语句以初始化变量，条件表达式以确定何时退出循环，并且后置语句在每次循环迭代之后运行。
- en: Code Magnets Solution
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁解决方案
- en: '![image](assets/bag.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/bag.png)'
- en: A Go program that prints the size of a file is on the fridge. It calls the `os.Stat`
    function, which returns an `os.FileInfo` value, and possibly an error. Then it
    calls the `Size` method on the `FileInfo` value to get the file size.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一个打印文件大小的 Go 程序挂在冰箱上。它调用 `os.Stat` 函数，该函数返回一个 `os.FileInfo` 值和可能的错误。然后它调用 `FileInfo`
    值上的 `Size` 方法来获取文件大小。
- en: The original program used the `_` blank identifier to ignore the error value
    from `os.Stat`. If an error occurred (which could happen if the file doesn’t exist),
    this would cause the program to fail.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的程序使用 `_` 空标识符来忽略 `os.Stat` 中的错误值。如果发生错误（例如文件不存在），这会导致程序失败。
- en: Your job was to reconstruct the extra code snippets to make a program that works
    just like the original one, but also checks for an error from `os.Stat`. If the
    error from `os.Stat` is not `nil`, the error should be reported, and the program
    should exit.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是重建额外的代码片段，使得程序像原始程序一样运行，但还要检查 `os.Stat` 的错误。如果 `os.Stat` 的错误不为 `nil`，则应报告错误并退出程序。
- en: '![image](assets/f0076-02.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0076-02.png)'
