- en: Chapter 2\. Getting Started with gRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章\. gRPC入门
- en: Enough with the theory on gRPC; let’s apply what you learned in [Chapter 1](ch01.html#grpc_ch_01)
    to build a real-world gRPC application from the ground up. In this chapter, you
    will use both Go and Java to build a simple gRPC service and a client application
    that invokes the service you developed. In the process you’ll learn about specifying
    a gRPC service definition using protocol buffers, generating a server skeleton
    and client stub, implementing a service’s business logic, running a gRPC server
    with the service you implemented, and invoking the service through the gRPC client
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关于gRPC的理论就到此为止；让我们应用您在[第1章](ch01.html#grpc_ch_01)学到的知识来从头开始构建一个真实的gRPC应用程序。在本章中，您将使用Go和Java构建一个简单的gRPC服务和一个调用您开发的服务的客户端应用程序。在此过程中，您将学习如何使用协议缓冲区指定gRPC服务定义，生成服务器框架和客户端存根，实现服务的业务逻辑，运行具有您实现的服务的gRPC服务器，并通过gRPC客户端应用程序调用服务。
- en: Let’s use the same online retail system from [Chapter 1](ch01.html#grpc_ch_01),
    where we need to build a service that is responsible for managing the products
    of a retail store. The service can be remotely accessed and the consumers of that
    service can add new products to the system and also retrieve product details from
    the system by providing the product ID. We’ll model this service and consumer
    using gRPC. You may pick the programming language of your choice to implement
    this, but in this chapter, we will use both the Go and Java languages to implement
    this sample.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用与[第1章](ch01.html#grpc_ch_01)相同的在线零售系统，我们需要构建一个负责管理零售店产品的服务。该服务可以远程访问，服务的消费者可以通过提供产品ID来向系统中添加新产品，并从系统中检索产品详细信息。我们将使用gRPC对这个服务和消费者进行建模。您可以选择任意编程语言来实现这一点，但在本章中，我们将使用Go和Java语言来实现这个示例。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can try out both the Go and Java implementations of the sample in the source
    code repository for this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的源代码存储库中尝试这个示例的Go和Java实现。
- en: 'In [Figure 2-1](#client_server_interaction_of_product_info_service), we illustrate
    the client–server communication patterns of the `ProductInfo` service for each
    method invocation. The server hosts a gRPC service that offers two remote methods:
    `addProduct(product)` and `getProduct(productId)`. The client can invoke either
    of those remote methods.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-1](#client_server_interaction_of_product_info_service)中，我们说明了`ProductInfo`服务的客户端-服务器通信模式，每个方法调用的方式。服务器托管一个gRPC服务，提供两个远程方法：`addProduct(product)`和`getProduct(productId)`。客户端可以调用这两个远程方法之一。
- en: '![client-server interaction of Product Info service](assets/grpc_0201.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![产品信息服务的客户端-服务器交互](assets/grpc_0201.png)'
- en: Figure 2-1\. Client–server interaction of ProductInfo service
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 产品信息服务的客户端-服务器交互
- en: Let’s start building this sample by creating the service definition of the `ProductInfo`
    gRPC service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`ProductInfo` gRPC服务的服务定义开始构建这个示例。
- en: Creating the Service Definition
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务定义
- en: As you learned in [Chapter 1](ch01.html#grpc_ch_01), when you develop a gRPC
    application, the first thing you do is define the service interface, which contains
    the methods that allow consumers to call remotely, the method parameters and message
    formats to use when invoking those methods, and so on. All these service definitions
    are recorded as a [protocol buffer’s definition](https://oreil.ly/1X5Ws), which
    is the interface definition language (IDL) used in gRPC.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](ch01.html#grpc_ch_01)中学到的，当您开发gRPC应用程序时，首先要做的是定义服务接口。该接口包含允许消费者远程调用的方法，调用这些方法时要使用的方法参数和消息格式等。所有这些服务定义都记录在[协议缓冲区的定义](https://oreil.ly/1X5Ws)中，这是gRPC中使用的接口定义语言（IDL）。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We will further dive into service definition techniques for different messaging
    patterns in [Chapter 3](ch03.html#ch_03). We will also cover the details of protocol
    buffers and gRPC implementation details in [Chapter 4](ch04.html#ch_04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html#ch_03)中进一步探讨不同消息模式的服务定义技术。我们还将在[第4章](ch04.html#ch_04)中详细介绍协议缓冲区和gRPC实现细节。
- en: Once you identify the business capabilities of the service, you can define the
    service interface to fulfill the business need. In our sample, we can identify
    two remote methods (`addProduct(product)` and `getProduct(productId)`) in the
    `ProductInfo` service and two message types (`Product` and `ProductID`) that both
    methods accept and return.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了服务的业务能力，就可以定义服务接口以满足业务需求。在我们的示例中，我们可以识别出`ProductInfo`服务中的两个远程方法（`addProduct(product)`和`getProduct(productId)`）以及两个消息类型（`Product`和`ProductID`），这两个方法都接受和返回。
- en: The next step is to specify these service definitions as a protocol buffer definition.
    With protocol buffers, we can define services and message types. A service consists
    of its methods and each method is defined by its type, input, and output parameters.
    The message consists of its fields and each field is defined by its type and a
    unique index value. Let’s dive into the details of defining message structures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这些服务定义指定为协议缓冲定义。使用协议缓冲，我们可以定义服务和消息类型。服务由其方法组成，每个方法由其类型、输入和输出参数定义。消息由其字段组成，每个字段由其类型和唯一索引值定义。让我们深入了解定义消息结构的详细信息。
- en: Defining Messages
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义消息
- en: 'The *message* is the data structure that is exchanged between client and service.
    As you can see in [Figure 2-1](#client_server_interaction_of_product_info_service),
    our `ProductInfo` use case has two message types. One is the product information
    (`Product`), which is required when adding a new product to the system and is
    returned when retrieving a particular product. The other is a unique identification
    (`ProductID`) of the product, which is required when retrieving a particular product
    from the system and is returned when adding a new product:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息*是在客户端和服务之间交换的数据结构。正如您在 [图 2-1](#client_server_interaction_of_product_info_service)
    中看到的那样，我们的`ProductInfo`用例有两种消息类型。一种是产品信息（`Product`），在向系统中添加新产品时需要，并在检索特定产品时返回。另一种是产品的唯一标识（`ProductID`），在从系统中检索特定产品时需要，并在添加新产品时返回：'
- en: '`ProductID`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductID`'
- en: '`ProductID` is a unique identifier of the product that can be a string value.
    We can either define our own message type that contains a string field or use
    the well-known message type `google.protobuf.StringValue`, provided by the protocol
    buffer library. In this example, we are going to define our own message type that
    contains a string field. The `ProductID` message type definition is shown in [Example 2-1](#EX2-1a).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductID`是产品的唯一标识符，可以是字符串值。我们可以定义自己的消息类型，其中包含一个字符串字段，或者使用由 Protocol Buffer
    库提供的`google.protobuf.StringValue`这种已知消息类型。在这个示例中，我们将定义自己的消息类型，其中包含一个字符串字段。`ProductID`消息类型的定义如
    [示例 2-1](#EX2-1a) 所示。'
- en: Example 2-1\. Protocol Buffer definition of ProductID message type.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. `ProductID`消息类型的 Protocol Buffer 定义。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Product`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`'
- en: '`Product` is a custom message type that represents the data that should exist
    in a product in our online retail application. It can have a set of fields that
    represent the data associated with each product. Suppose the `Product` message
    type has the following fields:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product`是我们在线零售应用中表示产品应该存在的数据的自定义消息类型。它可以包含一组字段，每个字段表示与每个产品相关联的数据。假设`Product`消息类型具有以下字段：'
- en: '`ID`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID`'
- en: Unique identifier of the product
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 产品的唯一标识符
- en: '`Name`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`名称`'
- en: Product name
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 产品名称
- en: '`Description`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`描述`'
- en: Product description
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 产品描述
- en: '`Price`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`价格`'
- en: Product price
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 产品价格
- en: Then we can define our custom message type using a protocol buffer as shown
    in [Example 2-2](#EX2-1).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用协议缓冲定义我们的自定义消息类型，如 [示例 2-2](#EX2-1) 所示。
- en: Example 2-2\. Protocol buffer definition of Product message type
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. `Product`消息类型的 Protocol Buffer 定义
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the number assigned to each message field is used to uniquely identify
    the field in the message. So, we can’t use the same number in two different fields
    in the same message definition. We will further dive into the details of the message
    definition techniques of protocol buffers and explain why we need to provide a
    unique number for each field in [Chapter 4](ch04.html#ch_04). For now, you can
    think of it as a rule when defining a protocol buffer message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里分配给每个消息字段的数字用于唯一标识消息中的字段。因此，在同一消息定义中，我们不能使用相同的数字来标识两个不同的字段。当我们定义协议缓冲消息时，我们将进一步深入探讨消息定义技术的细节，并解释为什么需要为每个字段提供一个唯一的数字，在
    [第四章](ch04.html#ch_04) 中说明这一点。目前，您可以将其视为定义协议缓冲消息时的一个规则。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The protobuf library provides a set of protobuf message types for well-known
    types. So we can reuse them instead of defining such types again in our service
    definition. You can get more details about these well-known types in the [protocol
    buffers documentation](https://oreil.ly/D8Ysn).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: protobuf 库为一组已知类型提供了协议缓冲区消息类型。因此，我们可以重用它们，而不是在服务定义中再次定义这些类型。您可以在 [协议缓冲区文档](https://oreil.ly/D8Ysn)
    中获取有关这些已知类型的更多详细信息。
- en: Since we have completed defining message types for the `ProductInfo` service,
    we can move on to the service interface definition.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了 `ProductInfo` 服务的消息类型定义，现在可以继续进行服务接口的定义。
- en: Defining Services
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义服务
- en: 'A *service* is a collection of remote methods that are exposed to a client.
    In our sample, the `ProductInfo` service has two remote methods: `addProduct(product)`
    and `getProduct(productId)`. According to the protocol buffer rule, we can only
    have one input parameter in a remote method and it can return only one value.
    If we need to pass multiple values to the method like in the `addProduct` method,
    we need to define a message type and group all the values as we have done in the
    `Product` message type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务* 是向客户端暴露的一组远程方法。在我们的示例中，`ProductInfo` 服务有两个远程方法：`addProduct(product)` 和
    `getProduct(productId)`。根据协议缓冲区规则，远程方法中只能有一个输入参数，并且只能返回一个值。如果需要像 `addProduct`
    方法中那样传递多个值给方法，我们需要定义一个消息类型，并像我们在 `Product` 消息类型中所做的那样将所有值分组：'
- en: '`addProduct`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`addProduct`'
- en: Creates a new `Product` in the system. It requires the details of the product
    as input and returns the product identification number of the newly added product,
    if the action completed successfully. [Example 2-3](#EX2-2) shows the definition
    of the `addProduct` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中创建一个新的 `Product`。它需要产品的详细信息作为输入，并且如果操作成功完成，则返回新添加产品的产品标识号。[Example 2-3](#EX2-2)
    展示了 `addProduct` 方法的定义。
- en: Example 2-3\. Protocol buffer definition of *addProduct* method
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. *addProduct* 方法的协议缓冲区定义
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`getProduct`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProduct`'
- en: Retrieves product information. It requires the `ProductID` as input and returns
    `Product` details if a particular product exists in the system. [Example 2-4](#EX2-3)
    shows the definition of the `getProduct` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 检索产品信息。它需要 `ProductID` 作为输入，并且如果系统中存在特定产品，则返回 `Product` 的详细信息。[Example 2-4](#EX2-3)
    展示了 `getProduct` 方法的定义。
- en: Example 2-4\. Protocol buffer definition of *getProduct* method
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. *getProduct* 方法的协议缓冲区定义
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Combining all messages and services, we now have a complete protocol buffer
    definition for our `ProductInfo` use case, as shown in [Example 2-5](#EX2-4).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结合所有消息和服务，我们现在有了一个完整的协议缓冲区定义，用于我们的 `ProductInfo` 使用案例，如 [Example 2-5](#EX2-4)
    所示。
- en: Example 2-5\. gRPC service definition of ProductInfo service using protocol
    buffers
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 使用协议缓冲区的 ProductInfo 服务的 gRPC 服务定义
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO1-1)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO1-1)'
- en: The service definition begins with specifying the protocol buffer version (proto3)
    that we use.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义始于指定的协议缓冲区版本（proto3）的说明。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO1-2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO1-2)'
- en: Package names are used to prevent name clashes between protocol message types
    and also will be used to generate code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 包名用于避免协议消息类型之间的名称冲突，并且将用于生成代码。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO1-3)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO1-3)'
- en: Definition of the service interface of the service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 服务接口的定义。
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO1-4)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO1-4)'
- en: Remote method to add a product that returns the product ID as the response.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 远程方法添加产品，返回产品ID作为响应。
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO1-5)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO1-5)'
- en: Remote method to get a product based on the product ID.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基于产品ID获取产品的远程方法。
- en: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO1-6)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO1-6)'
- en: Definition of the message format/type of `Product`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 的消息格式/类型定义。'
- en: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO1-7)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO1-7)'
- en: Field (name-value pair) that holds the product ID with unique field numbers
    that are used to identify your fields in the message binary format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 包含产品ID的字段（名称-值对），其唯一字段编号用于在消息二进制格式中标识您的字段。
- en: '[![8](assets/8.png)](#co_getting_started_with_grpc_CO1-8)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_getting_started_with_grpc_CO1-8)'
- en: Definition of the message format/type of ProductID.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ProductID 的消息格式/类型定义。
- en: In the protocol buffer definition, we can specify a package name (e.g., `ecommerce`),
    which helps to prevent naming conflicts between different projects. When we generate
    code for our services or clients using this service definition with a package,
    the same packages (unless we explicitly specify a different package for code generation)
    are created in the respective programming language (of course only if the language
    supports the notion of a *package*) with which our code is generated. We can also
    define package names with version numbers like `ecommerce.v1` and `ecommerce.v2`.
    So future major changes to the API can coexist in the same codebase.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲定义中，我们可以指定一个包名（例如 `ecommerce`），这有助于防止不同项目之间的命名冲突。当我们使用带有包的服务定义生成我们的服务或客户端的代码时（除非我们显式指定不同的包用于代码生成），相同的包（当然，只有在语言支持
    *包* 的概念时）将在相应的编程语言中创建。我们还可以使用带有版本号的包名，如 `ecommerce.v1` 和 `ecommerce.v2`。因此，API
    的未来主要更改可以共存于同一代码库中。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Commonly used IDEs (integrated development environments) such as IntelliJ IDEA,
    Eclipse, VSCode, etc., now have plug-ins to support protocol buffers. You can
    install the plug-in to your IDE and easily create a protocol buffer definition
    for your service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 像 IntelliJ IDEA、Eclipse、VSCode 等常用的集成开发环境现在都有支持协议缓冲的插件。您可以将插件安装到您的 IDE 中，并轻松为您的服务创建协议缓冲定义。
- en: 'One other process that should be mentioned here is importing from another proto
    file. If we need to use the message types defined in other proto files, we can
    import them and our protocol buffer definition. For example, if we want to use
    the `StringValue` type (`google.protobuf.StringValue`) defined in the *wrappers.proto*
    file, we can import the *google/protobuf/wrappers.proto* file in our definition
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还应提及另一个过程，即从另一个 proto 文件导入。如果我们需要使用其他 proto 文件中定义的消息类型，我们可以将它们导入到我们的协议缓冲定义中。例如，如果我们想要使用在
    *wrappers.proto* 文件中定义的 `StringValue` 类型（`google.protobuf.StringValue`），我们可以在我们的定义中导入
    *google/protobuf/wrappers.proto* 文件如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you complete the specification of the service definition, you can proceed
    to the implementation of the gRPC service and the client.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完成服务定义的规范后，您可以继续实现 gRPC 服务和客户端。
- en: Implementation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Let’s implement a gRPC service with the set of remote methods that we specified
    in the service definition. These remote methods are exposed by the server and
    the gRPC client connects to the server and invokes those remote methods.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个 gRPC 服务，该服务包含我们在服务定义中指定的一组远程方法。这些远程方法由服务器公开，gRPC 客户端连接到服务器并调用这些远程方法。
- en: As illustrated in [Figure 2-2](#a_microservice_and_a_consumer_based_on_service_definition),
    we first need to compile the `ProductInfo` service definition and generate source
    code for the chosen language. Out of the box, gRPC is supported by all the popular
    languages like Java, Go, Python, Ruby, C, C++, Node, etc. You can choose which
    language to use when implementing the service or client. gRPC also works across
    multiple languages and platforms, which means you can have your server written
    in one language and your client written in another language in your application.
    In our sample, we will develop our client and server in both the Go and Java languages,
    so you can follow whichever implementation you prefer to use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [Figure 2-2](#a_microservice_and_a_consumer_based_on_service_definition)
    所示，我们首先需要编译 `ProductInfo` 服务定义并为所选语言生成源代码。gRPC 默认支持所有流行语言如 Java、Go、Python、Ruby、C、C++、Node
    等。您可以选择在实现服务或客户端时使用哪种语言。gRPC 还跨越多种语言和平台工作，这意味着您可以在应用程序中将服务器编写为一种语言，将客户端编写为另一种语言。在我们的示例中，我们将使用
    Go 和 Java 两种语言开发我们的客户端和服务器，因此您可以选择使用您偏好的实现。
- en: In order to generate source code from the service definition, we can either
    manually compile the proto file using the [protocol buffer compiler](https://oreil.ly/CYEbY)
    or we can use build automation tools like Bazel, Maven, or Gradle. Those automation
    tools already have a set of rules defined to generate the code when building the
    project. Often it is easier to integrate with an existing build tool to generate
    the source code of the gRPC service and client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从服务定义中生成源代码，我们可以手动编译 proto 文件使用 [协议缓冲编译器](https://oreil.ly/CYEbY)，或者我们可以使用像
    Bazel、Maven 或 Gradle 这样的构建自动化工具。这些自动化工具已经定义了一组规则，在构建项目时生成代码。通常，集成现有的构建工具来生成 gRPC
    服务和客户端的源代码更加容易。
- en: '![client-server interaction of Product Info service](assets/grpc_0202.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![产品信息服务的客户端-服务器交互](assets/grpc_0202.png)'
- en: Figure 2-2\. A microservice and a consumer based on a service definition
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 基于服务定义的微服务和消费者
- en: In this sample, we’ll use Gradle to build the Java application and use the Gradle
    protocol buffer plug-in to generate the service and client code. For the Go application,
    we’ll use the protocol buffer compiler and generate the code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用 Gradle 构建 Java 应用程序，并使用 Gradle 协议缓冲插件生成服务和客户端代码。对于 Go 应用程序，我们将使用协议缓冲编译器生成代码。
- en: Let’s walk through implementing a gRPC server and client in Go and Java. Before
    we do this, make sure you have installed Java 7 or higher and Go 1.11 or higher
    on your local machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现 Go 和 Java 中的 gRPC 服务器和客户端。在此之前，请确保您的本地机器上已安装了 Java 7 或更高版本以及 Go 1.11
    或更高版本。
- en: Developing a Service
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发一个服务
- en: When you generate the service skeleton code, you will get the low-level code
    required to establish the gRPC communication, relevant message types, and interfaces.
    The task of service implementation is all about implementing the interfaces that
    are generated with the code generation step. Let’s start with implementing the
    Go service and then we will look at how to implement the same service in the Java
    language.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当您生成服务骨架代码时，您将获得建立 gRPC 通信所需的低级代码，相关的消息类型和接口。服务实现的任务就是实现与代码生成步骤一起生成的接口。让我们从实现
    Go 服务开始，然后我们将看看如何在 Java 语言中实现相同的服务。
- en: Implementing a gRPC service with Go
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 实现 gRPC 服务
- en: 'Implementing the Go service has three steps. First, we need to generate the
    stubs for the service definition, then we implement the business logic of all
    the remote methods of the service, and finally, we create a server listening on
    a specified port and register the service to accept client requests. Let’s start
    by creating a new Go module. Here we are going to create one module and a subdirectory
    inside the module; the module `productinfo/service` is used to keep the service
    code and the subdirectory (`ecommerce`) is used to keep the autogenerated stub
    file. Create a directory inside the *productinfo* directory and call it *service*.
    Navigate inside to the *service* directory and execute the following command to
    create the module `productinfo/service`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Go 服务有三个步骤。首先，我们需要为服务定义生成存根，然后实现服务所有远程方法的业务逻辑，最后创建一个在指定端口监听并注册服务以接受客户端请求的服务器。让我们从创建一个新的
    Go 模块开始。在这里，我们将创建一个模块和模块内的一个子目录；模块 `productinfo/service` 用于保持服务代码，而子目录 (`ecommerce`)
    用于保存自动生成的存根文件。在 *productinfo* 目录中创建一个名为 *service* 的目录。进入 *service* 目录并执行以下命令以创建模块
    `productinfo/service`：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you create the module and create a subdirectory inside the module, you
    will get a module structure as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建模块并在模块内部创建一个子目录，您将获得以下模块结构：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to update the *go.mod* file with the dependencies with the specific
    version as shown in the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用 *go.mod* 文件更新特定版本的依赖项，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'From Go 1.11 onwards, a new concept called *modules* has been introduced that
    allows developers to create and build Go projects outside GOPATH. To create a
    Go module, we need to create a new directory anywhere outside `$GOPATH/src` and
    inside the directory, we need to execute the command to initialize the module
    with a module name like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Go 1.11 开始，引入了一个称为 *模块* 的新概念，允许开发人员在 GOPATH 之外的任何位置创建和构建 Go 项目。要创建一个 Go 模块，我们需要在
    `$GOPATH/src` 之外的任何位置创建一个新目录，并在该目录内执行以下命令，以模块名称初始化模块：
- en: '`go mod init <module_name>`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`go mod init <module_name>`'
- en: Once you initialize the module, a *go.mod* file will be created inside the root
    of the module. And then we can create our Go source file inside the module and
    build it. Go resolves imports by using the specific dependency module versions
    listed in *go.mod*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化模块，将在模块根目录内创建一个 *go.mod* 文件。然后我们可以在模块内部创建我们的 Go 源文件并构建它。Go 通过使用 *go.mod*
    中列出的特定依赖模块版本解析导入。
- en: Generating client/server stubs
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成客户端/服务器存根
- en: 'Now we’ll generate client/server stubs manually, using the protocol buffer
    compiler. To do that, we need to fulfill a set of prerequisites as listed here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将手动生成客户端/服务器存根，使用协议缓冲编译器。为此，我们需要满足以下一系列先决条件：
- en: Download and install the latest protocol buffer version 3 compiler from the
    [GitHub release page](https://oreil.ly/Ez8qu).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[GitHub 发行页面](https://oreil.ly/Ez8qu)下载并安装最新的协议缓冲器版本 3 编译器。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When downloading the compiler, you need to choose the compiler that suits your
    platform. For example, if you are using a 64-bit Linux machine and you need to
    get a protocol buffer compiler version x.x.x, you need to download the *protoc-x.x.x-linux-x86_64.zip*
    file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载编译器时，需要选择适合您平台的编译器。例如，如果您使用的是 64 位 Linux 机器，并且需要获取协议缓冲区编译器版本 x.x.x，您需要下载
    *protoc-x.x.x-linux-x86_64.zip* 文件。
- en: 'Install the gRPC library using the following command:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 gRPC 库：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Install the protoc plug-in for Go using the following command:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 Go 的 protoc 插件：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we fulfill all the prerequisites, we can generate the code for the service
    definition by executing the protoc command as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们满足所有先决条件后，可以按照以下示例执行 protoc 命令来生成服务定义的代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO2-1)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO2-1)'
- en: Specifies the directory path where the source proto file and dependent proto
    files exist (specified with the `--proto_path` or `-I` command-line flag). If
    you do not specify a value, the current directory is used as the source directory.
    Inside the directory, we need to arrange the dependent proto files in accordance
    with the package name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 指定源 proto 文件和依赖 proto 文件所在的目录路径（使用 `--proto_path` 或 `-I` 命令行标志指定）。如果不指定值，则使用当前目录作为源目录。在目录内，我们需要按照包名排列依赖的
    proto 文件。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO2-2)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO2-2)'
- en: Specifies the proto file path you want to compile. The compiler will read the
    file and generate the output Go file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要编译的 proto 文件路径。编译器将读取文件并生成输出的 Go 文件。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO2-3)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO2-3)'
- en: Specifies the destination directory where you want the generated code to go.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您希望生成的代码去的目标目录。
- en: When we execute the command, a stub file (*product_info.pb.go*) will be generated
    inside the given subdirectory (*ecommerce*) in the module. Now that we have generated
    the stubs, we need to implement our business logic using the generated code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行命令时，会在模块中给定的子目录（*ecommerce*）内生成一个存根文件（*product_info.pb.go*）。现在我们已生成了存根，需要使用生成的代码实现我们的业务逻辑。
- en: Implementing business logic
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现业务逻辑
- en: First, let’s create a new Go file named *productinfo_service.go* inside the
    Go module (`productinfo/service`) and implement the remote methods as shown in
    [Example 2-6](#EX2-5).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 Go 模块（*productinfo/service*）内创建一个名为 *productinfo_service.go* 的新 Go 文件，并按
    [示例 2-6](#EX2-5) 中显示的方式实现远程方法。
- en: Example 2-6\. gRPC service implementation of *ProductInfo* service in Go
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 在 Go 中实现 *ProductInfo* 服务的 gRPC 服务实现
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO3-1)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO3-1)'
- en: Import the package that contains the generated code we just created from the
    protobuf compiler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包含从 protobuf 编译器生成的代码的包。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO3-2)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO3-2)'
- en: The `server` struct is an abstraction of the server. It allows attaching service
    methods to the server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` 结构体是服务器的抽象。它允许将服务方法附加到服务器上。'
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO3-3)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO3-3)'
- en: The `AddProduct` method takes `Product` as a parameter and returns a `ProductID`.
    `Product` and `ProductID` structs are defined in the *product_info.pb.go* file,
    which is autogenerated from the *product_info.proto* definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddProduct` 方法以 `Product` 作为参数，并返回一个 `ProductID`。`Product` 和 `ProductID` 结构在
    *product_info.pb.go* 文件中定义，该文件是从 *product_info.proto* 定义自动生成的。'
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO3-6)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO3-6)'
- en: The `GetProduct` method takes `ProductID` as a parameter and returns a `Product`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetProduct` 方法以 `ProductID` 作为参数，并返回一个 `Product`。'
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO3-4)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO3-4)'
- en: Both methods also have a `Context` parameter. A `Context` object contains metadata
    such as the identity of the end user authorization tokens and the request’s deadline,
    and it will exist during the lifetime of the request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都有一个 `Context` 参数。`Context` 对象包含元数据，例如最终用户身份验证令牌的标识和请求的截止时间，并且在请求的生命周期内存在。
- en: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO3-5)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO3-5)'
- en: Both methods return an error in addition to the return value of the remote method
    (methods have multiple return types). These errors are propagated to the consumers
    and can be used for error handling at the consumer side.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法除了远程方法的返回值之外，还返回一个错误（方法有多种返回类型）。这些错误会传播到消费者，并可用于在消费者端进行错误处理。
- en: That’s all you have to do to implement the business logic of the `ProductInfo`
    service. Then we can create a simple server that hosts the service and accepts
    requests from the client.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您必须为 `ProductInfo` 服务实现业务逻辑的所有内容。然后，我们可以创建一个简单的服务器来托管服务并接受来自客户端的请求。
- en: Creating a Go server
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个 Go 服务器
- en: To create the server in Go, let’s create a new Go file named *main.go* inside
    the same Go package (`productinfo/service`) and implement the `main` method as
    shown in [Example 2-7](#EX2-6).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中创建服务器，让我们在同一个 Go 包（`productinfo/service`）中创建一个名为 *main.go* 的新 Go 文件，并按照[示例
    2-7](#EX2-6)中显示的方式实现 `main` 方法。
- en: Example 2-7\. gRPC server implementation to host ProductInfo service in Go
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 在 Go 中实现 gRPC 服务器以托管 ProductInfo 服务
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO4-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO4-1)'
- en: Import the package that contains the generated code we just created from the
    protobuf compiler.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包含从 protobuf 编译器刚刚创建的生成代码的包。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO4-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO4-2)'
- en: TCP listener that we want the gRPC server to bind to is created on the port
    (50051).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 gRPC 服务器绑定到的 TCP 监听器创建在端口（50051）上。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO4-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO4-3)'
- en: New gRPC server instance is created by calling gRPC Go APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 gRPC Go API 创建新的 gRPC 服务器实例。
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO4-4)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO4-4)'
- en: The service implemented earlier is registered to the newly created gRPC server
    by calling generated APIs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 先前实现的服务通过调用生成的 API 注册到新创建的 gRPC 服务器上。
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO4-5)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO4-5)'
- en: Start listening to the incoming messages on the port (50051).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 开始监听端口（50051）传入的消息。
- en: Now we have completed building a gRPC service for our business use case in the
    Go language. And also we created a simple server that will expose service methods
    and accept messages from gRPC clients.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了在 Go 语言中为我们的业务用例构建 gRPC 服务。同时，我们还创建了一个简单的服务器，用于公开服务方法并接受来自 gRPC 客户端的消息。
- en: If you prefer using Java for building a service, we can implement the same service
    using Java. The implementation procedure is quite similar to Go. So, let’s create
    the same service using the Java language. However, if you are interested in building
    a client application in Go instead, go directly to [“Developing a gRPC Client”](#dev_grpc_client).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢使用 Java 构建服务，我们可以使用 Java 实现相同的服务。实现过程与 Go 非常相似。因此，让我们使用 Java 语言创建相同的服务。但是，如果您有兴趣在
    Go 中构建客户端应用程序，请直接转到[“开发 gRPC 客户端”](#dev_grpc_client)。
- en: Implementing a gRPC Service with Java
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Java 实现 gRPC 服务
- en: When creating a Java gRPC project, the best approach is to use an existing build
    tool like Gradle, Maven, or Bazel because it manages all dependencies and code
    generation, etc. In our sample, we will use Gradle to manage the project and we’ll
    discuss how to create a Java project using Gradle and how to implement the business
    logic of all remote methods of the service. Finally, we’ll create a server and
    register the service to accept client requests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Java gRPC 项目时，最佳方法是使用像 Gradle、Maven 或 Bazel 这样的现有构建工具，因为它管理所有依赖项和代码生成等。在我们的示例中，我们将使用
    Gradle 管理项目，并讨论如何使用 Gradle 创建 Java 项目以及如何实现服务的所有远程方法的业务逻辑。最后，我们将创建一个服务器并注册服务以接受客户端请求。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Gradle is a build automation tool that supports multiple languages, including
    Java, Scala, Android, C/C++, and Groovy, and is closely integrated with development
    tools like Eclipse and IntelliJ IDEA. You can install Gradle on your machine by
    following the steps given on the [official page](https://gradle.org/install).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个支持多种语言（包括 Java、Scala、Android、C/C++ 和 Groovy）的构建自动化工具，并与 Eclipse 和
    IntelliJ IDEA 等开发工具紧密集成。您可以按照[官方页面](https://gradle.org/install)上给出的步骤在您的机器上安装
    Gradle。
- en: Setting up a Java project
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置一个 Java 项目
- en: 'Let’s first create a Gradle Java project (`product-info-service`). Once you
    have then created the project, you will get a project structure like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 Gradle Java 项目（`product-info-service`）。创建项目后，您将获得以下项目结构：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Under the *src/main* directory, create a *proto* directory and add our `ProductInfo`
    service definition file (*.proto* file) inside the *proto* directory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*src/main*目录下创建一个*proto*目录，并将我们的`ProductInfo`服务定义文件（*.proto*文件）添加到*proto*目录中。
- en: Next, you need to update the *build.gradle* file and add dependencies and the
    protobuf plug-in for Gradle. Update the *build.gradle* file as shown in [Example 2-8](#EX2-8).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要更新*build.gradle*文件并添加依赖项和Gradle的protobuf插件。根据[Example 2-8](#EX2-8)更新*build.gradle*文件。
- en: Example 2-8\. Gradle configuration for gRPC Java project
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-8\. gRPC Java项目的Gradle配置
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO5-1)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO5-1)'
- en: gRPC Java library version used in the Gradle project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle项目中使用的gRPC Java库版本。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO5-2)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO5-2)'
- en: External dependencies we need to use in this project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此项目中需要使用的外部依赖项。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO5-3)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO5-3)'
- en: Gradle protobuf plug-in version we are using in the project. Use plug-in version
    0.7.5 if your Gradle version is lower than 2.12.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目中使用的Gradle protobuf插件版本。如果您的Gradle版本低于2.12，请使用插件版本0.7.5。
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO5-4)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO5-4)'
- en: In the protobuf plug-in, we need to specify the protobuf compiler version and
    protobuf Java executable version.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在protobuf插件中，我们需要指定protobuf编译器版本和protobuf Java可执行版本。
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO5-5)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO5-5)'
- en: This is to inform IDEs like IntelliJ IDEA, Eclipse, or NetBeans about the generated
    code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此内容用于通知像IntelliJ IDEA、Eclipse或NetBeans等IDE有关生成代码的信息。
- en: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO5-6)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO5-6)'
- en: Configure the main class to use when running the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 配置在运行应用程序时使用的主类。
- en: 'Then run the following command to build the library and generate stub code
    from the protobuf build plug-in:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令来构建库并从protobuf构建插件生成存根代码：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we have the Java project ready with autogenerated code. Let’s implement
    the service interface and add business logic to the remote methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了带有自动生成代码的Java项目。让我们实现服务接口，并向远程方法添加业务逻辑。
- en: Implementing business logic
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现业务逻辑
- en: To start with, let’s create the Java package (`ecommerce`) inside the *src/main/java*
    source directory and create a Java class (*ProductInfoImpl.java*) inside the package.
    Then we’ll implement the remote methods as shown in [Example 2-9](#EX2-9).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在*src/main/java*源目录下创建Java包(`ecommerce`)，并在包内创建一个Java类(*ProductInfoImpl.java*)。然后，根据[Example 2-9](#EX2-9)实现远程方法。
- en: Example 2-9\. gRPC service implementation of *ProductInfo* service in Java
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-9\. Java中*ProductInfo*服务的gRPC服务实现
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO6-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO6-1)'
- en: Extend the abstract class (`ProductInfoGrpc.ProductInfoImplBase`) that is generated
    from the plug-in. This will allow adding business logic to `AddProduct` and `GetProduct`
    methods defined in the service definition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展自插件生成的抽象类(`ProductInfoGrpc.ProductInfoImplBase`)。这将允许在服务定义中定义的`AddProduct`和`GetProduct`方法中添加业务逻辑。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO6-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO6-2)'
- en: The `AddProduct` method takes `Product(ProductInfoOuterClass.Product)` as a
    parameter. The `Product` class is defined in the `ProductInfoOuterClass` class,
    which is generated from the service definition.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddProduct`方法以`Product(ProductInfoOuterClass.Product)`作为参数。`Product`类定义在`ProductInfoOuterClass`类中，该类是从服务定义生成的。'
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO6-6)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO6-6)'
- en: The `GetProduct` method takes `ProductID(ProductInfoOuterClass.ProductID)` as
    a parameter. The `ProductID` class is defined in the `ProductInfoOuterClass` class,
    which is generated from the service definition.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetProduct`方法以`ProductID(ProductInfoOuterClass.ProductID)`作为参数。`ProductID`类定义在`ProductInfoOuterClass`类中，该类是从服务定义生成的。'
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO6-3)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO6-3)'
- en: The `responseObserver` object is used to send the response back to the client
    and close the stream.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`responseObserver`对象用于将响应发送回客户端并关闭流。'
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO6-4)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO6-4)'
- en: Send a response back to the client.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应发送回客户端。
- en: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO6-5)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO6-5)'
- en: End the client call by closing the stream.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭流来结束客户端调用。
- en: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO6-10)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO6-10)'
- en: Send an error back to the client.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 向客户端发送一个错误。
- en: That’s all you need to do to implement the business logic of the `ProductInfo`
    service in Java. Then we can create a simple server that hosts the service and
    accepts requests from the client.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要在 Java 中实现 `ProductInfo` 服务的业务逻辑的全部内容。然后，我们可以创建一个简单的服务器来托管服务并接受来自客户端的请求。
- en: Creating a Java server
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个 Java 服务器
- en: In order to expose our service to the outside, we need to create a gRPC server
    instance and register our `ProductInfo` service to the server. The server will
    listen on the specified port and dispatch all requests to the relevant service.
    Let’s create a main class (*ProductInfoServer.java*) inside the package as shown
    in [Example 2-10](#EX2-10).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的服务暴露给外部，我们需要创建一个 gRPC 服务器实例，并将我们的 `ProductInfo` 服务注册到服务器中。服务器将在指定的端口上监听，并将所有请求分派到相关的服务上。让我们在包内创建一个主类（*ProductInfoServer.java*），如
    [Example 2-10](#EX2-10) 中所示。
- en: Example 2-10\. gRPC server implementation to host ProductInfo service in Java
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-10\. 在 Java 中托管 ProductInfo 服务的 gRPC 服务器实现
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO7-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO7-1)'
- en: Server instance is created on port 50051\. This is the port we want the server
    to bind to and where it will listen to incoming messages. Our `ProductInfo` service
    implementation is added to the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器实例创建在端口 50051 上。这是我们希望服务器绑定并监听传入消息的端口。我们的 `ProductInfo` 服务实现添加到了服务器中。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO7-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO7-2)'
- en: A runtime shutdown hook is added to shut down the gRPC server when JVM shuts
    down.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JVM 关闭时，添加运行时关闭钩子以关闭 gRPC 服务器。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO7-3)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO7-3)'
- en: At the end of the method, the server thread is held until the server gets terminated.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法结束时，保持服务器线程直到服务器终止。
- en: Now we are done with the implementation of the gRPC service in both languages.
    We can then proceed to the implementation of the gRPC client.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了两种语言中的 gRPC 服务的实现。接下来，我们可以进行 gRPC 客户端的实现。
- en: Developing a gRPC Client
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发 gRPC 客户端
- en: As we did with the gRPC service implementation, we can now discuss how to create
    an application to talk with the server. Let’s start off with the generation of
    the client-side stubs from the service definition. On top of the generated client
    stub, we can create a simple gRPC client to connect with our gRPC server and invoke
    the remote methods that it offers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们实现 gRPC 服务一样，现在我们可以讨论如何创建一个应用程序来与服务器通信。让我们从服务定义中生成客户端存根开始。在生成的客户端存根之上，我们可以创建一个简单的
    gRPC 客户端来连接我们的 gRPC 服务器，并调用其提供的远程方法。
- en: In this sample, we are going to write client applications in both the Java and
    Go languages. But you don’t need to create your server and client in the same
    language, or run them on the same platform. Since gRPC works across languages
    and platforms, you can create them in any supported language. Let’s discuss the
    Go implementation first. If you are interested in the Java implementation, you
    may skip the next section and go directly into the Java client.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 Java 和 Go 两种语言编写客户端应用程序。但是您不需要在同一种语言或平台上创建您的服务器和客户端。由于 gRPC 跨语言和跨平台工作，您可以在任何支持的语言中创建它们。让我们先讨论
    Go 的实现。如果您对 Java 实现感兴趣，可以跳过下一节，直接进入 Java 客户端。
- en: Implementing a gRPC Go client
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 gRPC Go 客户端
- en: Let’s start by creating a new Go module (`productinfo/client`) and subdirectory
    (*ecommerce*) inside the module. In order to implement the Go client application,
    we also need to generate the stub as we have done when implementing the Go service.
    Since we need to create the same file (*product_info.pb.go*) and need to follow
    the same steps to generate the stubs, we are not going to mention it here. Please
    refer to [“Generating client/server stubs”](#gen_client_server_stubs) to generate
    stub files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的 Go 模块 (`productinfo/client`)，并在模块内部创建一个子目录 (*ecommerce*)。为了实现 Go
    客户端应用程序，我们还需要生成存根，就像我们在实现 Go 服务时所做的那样。由于我们需要创建相同的文件 (*product_info.pb.go*) 并需要遵循生成存根的相同步骤，我们不会在此处详述。请参考
    [“生成客户端/服务器存根”](#gen_client_server_stubs) 以生成存根文件。
- en: Let’s create a new Go file named *productinfo_client.go* inside the Go module
    (`productinfo/client`) and implement the main method to invoke remote methods
    as shown in [Example 2-11](#EX2-11).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Go 模块 (`productinfo/client`) 中创建一个名为 *productinfo_client.go* 的新文件，并实现主方法来调用远程方法，如
    [Example 2-11](#EX2-11) 中所示。
- en: Example 2-11\. gRPC client application in Go
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. Go 中的 gRPC 客户端应用程序
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO8-1)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO8-1)'
- en: Import the package that contains the generated code we created from the protobuf
    compiler.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包含我们从 protobuf 编译器生成的代码的包。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO8-2)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO8-2)'
- en: Set up a connection with the server from the provided address (“localhost:50051”).
    Here we create an unsecured connection between client and server.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的地址（“localhost:50051”）建立与服务器的连接。在这里，我们创建了客户端和服务器之间的非安全连接。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO8-4)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO8-4)'
- en: Pass the connection and create a stub. This stub instance contains all the remote
    methods to invoke the server.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 传递连接并创建存根。此存根实例包含调用服务器的所有远程方法。
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO8-5)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO8-5)'
- en: Create a `Context` to pass with the remote call. Here the `Context` object contains
    metadata such as the identity of the end user, authorization tokens, and the request’s
    deadline and it will exist during the lifetime of the request.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Context` 对象以传递远程调用。这里的 `Context` 对象包含元数据，如最终用户的身份、授权令牌和请求的截止日期，并且在请求的生命周期内都存在。
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO8-6)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO8-6)'
- en: Call `addProduct` method with product details. This returns a product ID if
    the action completed successfully. Otherwise it returns an error.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品详细信息调用 `addProduct` 方法。如果操作成功完成，则返回产品 ID。否则返回错误。
- en: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO8-7)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_getting_started_with_grpc_CO8-7)'
- en: Call `getProduct` with the product ID. This returns product details if the action
    completed successfully. Otherwise it returns an error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品 ID 调用 `getProduct` 方法。如果操作成功完成，则返回产品详情。否则返回错误。
- en: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO8-3)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_getting_started_with_grpc_CO8-3)'
- en: Close the connection when everything is done.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有操作完成后关闭连接。
- en: Now we have completed building the gRPC client in the Go language. Let’s next
    create a client using the Java language. This is not a mandatory step to follow.
    If you are also interested in building a gRPC client in Java, you can continue;
    otherwise, you can skip the next section and go directly to [“Building and Running”](#build_run).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了使用 Go 语言构建 gRPC 客户端的过程。接下来让我们使用 Java 语言创建一个客户端。这不是强制性的步骤。如果您也有兴趣在 Java
    中构建 gRPC 客户端，可以继续；否则，您可以跳过下一部分，直接去 [“构建和运行”](#build_run)。
- en: Implementing a Java client
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Java 客户端
- en: In order to create a Java client application, we also need to set up a Gradle
    project (`product-info-client`) and generate classes using the Gradle plug-in
    as we did when implementing the Java service. Please follow the steps in [“Setting
    up a Java project”](#set_up_java) to set up a Java client project.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Java 客户端应用程序，我们还需要设置一个 Gradle 项目（`product-info-client`）并使用 Gradle 插件生成类，就像我们在实现
    Java 服务时所做的那样。请按照 [“设置 Java 项目”](#set_up_java) 中的步骤设置 Java 客户端项目。
- en: Once you generate the client stub code for your project via the Gradle build
    tool, let’s create a new class called `ProductInfoClient` inside the `ecommerce`
    package and add the content in [Example 2-12](#EX2-12).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过 Gradle 构建工具为您的项目生成了客户端存根代码，让我们在 `ecommerce` 包内创建一个名为 `ProductInfoClient`
    的新类，并添加 [示例 2-12](#EX2-12) 中的内容。
- en: Example 2-12\. gRPC client application in Java
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. Java 中的 gRPC 客户端应用程序
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO9-1)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_getting_started_with_grpc_CO9-1)'
- en: Create a gRPC channel specifying the server address and port we want to connect
    to. Here we are trying to connect to a server running on the same machine and
    listening on port 50051\. We also enable plaintext, which means we are setting
    up an unsecured connection between client and server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 gRPC 通道，指定我们要连接到的服务器地址和端口。在这里，我们尝试连接运行在同一台机器上并监听端口 50051 的服务器。我们还启用了明文传输，这意味着我们正在设置客户端和服务器之间的非安全连接。
- en: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO9-2)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_getting_started_with_grpc_CO9-2)'
- en: Create the client stub using the newly created channel. We can create two types
    of stubs. One is the `BlockingStub`, which waits until it receives a server response.
    The other one is the `NonBlockingStub`, which doesn’t wait for server response,
    but instead registers an observer to receive the response. In this example, we
    use a `BlockingStub` to make the client simple.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新创建的通道创建客户端存根。我们可以创建两种类型的存根。一种是 `BlockingStub`，它会等待接收服务器响应。另一种是 `NonBlockingStub`，它不会等待服务器响应，而是注册一个观察者来接收响应。在本例中，我们使用
    `BlockingStub` 来简化客户端。
- en: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO9-3)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_getting_started_with_grpc_CO9-3)'
- en: Call `addProduct` method using the product details. This returns a product ID
    if the action completed successfully.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品详细信息调用 `addProduct` 方法。如果操作成功完成，将返回产品 ID。
- en: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO9-4)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_getting_started_with_grpc_CO9-4)'
- en: Call `getProduct` with the product ID. Returns the product details if the action
    completed successfully.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用产品 ID 调用 `getProduct`。如果操作成功完成，将返回产品详细信息。
- en: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO9-5)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_getting_started_with_grpc_CO9-5)'
- en: Close the connection when everything is done so that the network resources that
    we used in our application are safely returned back after we are finished.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都完成后关闭连接，以确保我们应用程序中使用的网络资源在我们完成后安全地返回。
- en: Now we have finished developing the gRPC client. Let’s make the client and server
    talk to each other.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了开发 gRPC 客户端的工作。让我们让客户端和服务器相互通信。
- en: Building and Running
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行
- en: It’s time to build and run the gRPC server and client applications that we have
    created. You can deploy and run a gRPC application on your local machine, on a
    virtual machine, on Docker, or on Kubernetes. In this section, we will discuss
    how to build and run the gRPC server and client applications on a local machine.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建和运行我们创建的 gRPC 服务器和客户端应用程序了。您可以在本地机器、虚拟机、Docker 或 Kubernetes 上部署和运行 gRPC
    应用程序。在本节中，我们将讨论如何在本地机器上构建和运行 gRPC 服务器和客户端应用程序。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We will cover how to deploy and run gRPC applications on Docker and Kubernetes
    environments in [Chapter 7](ch07.html#ch_07).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第7章](ch07.html#ch_07) 中介绍如何在 Docker 和 Kubernetes 环境中部署和运行 gRPC 应用程序。
- en: Let’s run the gRPC server and client applications that we have just developed
    in your local machine. Since our server and client applications are written in
    two languages, we are going to build the server application separately.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地运行我们刚刚开发的 gRPC 服务器和客户端应用程序。由于我们的服务器和客户端应用程序使用两种语言编写，我们将分别构建服务器应用程序。
- en: Building a Go Server
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Go 服务器
- en: 'When we implement a Go service, the final package structure in the workspace
    looks like the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现 Go 服务时，工作空间中的最终包结构如下所示：
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can build our service to generate a service binary (*bin/server*). In order
    to build, first go to the Go module root directory location (*productinfo/service*)
    and execute the following shell command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建我们的服务以生成一个服务二进制文件（*bin/server*）。为了构建，首先进入 Go 模块根目录位置（*productinfo/service*），然后执行以下
    shell 命令：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once the build is successful, an executable file (*bin/server*) is created under
    the *bin* directory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，在 *bin* 目录下创建一个可执行文件（*bin/server*）。
- en: Next, let’s set up the Go client!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置 Go 客户端！
- en: Building a Go Client
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Go 客户端
- en: 'When we implement a Go client, the package structure in the workspace looks
    like:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现 Go 客户端时，工作空间中的包结构如下所示：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can build the client code the same way we built the Go service using the
    following shell command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 shell 命令像构建 Go 服务一样构建客户端代码：
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the build is successful, an executable file (*bin/client*) is created under
    the *bin* directory. The next step is to run the files!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，在 *bin* 目录下创建一个可执行文件（*bin/client*）。下一步是运行这些文件！
- en: Running a Go Server and Client
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Go 服务器和客户端
- en: 'We’ve just built a client and a server. Let’s run them on separate terminals
    and make them talk to each other:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个客户端和一个服务器。让我们在不同的终端上运行它们并让它们相互通信：
- en: '[PRE25]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next we’ll build a Java server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将构建一个 Java 服务器。
- en: Building a Java Server
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Java 服务器
- en: 'Since we implement the Java service as a Gradle project, we can easily build
    the project using the following command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 Java 服务实现为 Gradle 项目，我们可以使用以下命令轻松构建项目：
- en: '[PRE26]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the build is successful, the executable JAR (*server.jar*) file is created
    under the *build/libs* directory.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功后，可执行的 JAR 文件（*server.jar*）将创建在 *build/libs* 目录下。
- en: Building a Java Client
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Java 客户端
- en: 'Just as with a service, we can easily build the project using the following
    command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务一样，我们可以轻松地使用以下命令构建项目：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once the build is successful, the executable JAR (*client.jar*) file is created
    under the *build/libs* directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建成功，可执行的 JAR 文件（*client.jar*）将创建在 *build/libs* 目录下。
- en: Running a Java Server and Client
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Java 服务器和客户端
- en: 'We’ve now built both a client and server in the Java language. Let’s run them:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经用 Java 语言分别构建了客户端和服务器。让我们来运行它们：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we have built and run our sample successfully on local machines. Once we
    successfully run the client and server, the client application first invokes the
    `addProduct` method with product details and receives the product identifier of
    the newly added product as the response. Then it retrieves the newly added product
    details by calling the `getProduct` method with the product identifier. As we
    mentioned earlier in this chapter, we don’t need to write the client in the same
    language to talk with the server. We can run a gRPC Java server and Go client
    and it will work without any issue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地机器上成功构建并运行了示例。一旦成功运行客户端和服务器，客户端应用程序首先使用`addProduct`方法调用产品详细信息，并接收新添加产品的产品标识符作为响应。然后，通过使用产品标识符调用`getProduct`方法来检索新添加的产品详细信息。正如本章前面提到的，我们不需要用相同的语言编写客户端与服务器通信。我们可以运行一个
    gRPC Java 服务器和 Go 客户端，它将毫无问题地工作。
- en: That brings us to the end of the chapter!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的结束！
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When you develop a gRPC application, you first define a service interface definition
    using protocol buffers, a language-agnostic, platform-neutral, extensible mechanism
    for serializing structured data. Next, you generate server-side and client-side
    code for the programming language of your choice, which simplifies the server-
    and client-side logic by providing the low-level communication abstractions. From
    the server side, you implement the logic of the method that you expose remotely
    and run a gRPC server that binds the service. On the client side, you connect
    to the remote gRPC server and invoke the remote method using the generated client-side
    code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发 gRPC 应用程序时，首先使用协议缓冲区定义服务接口。协议缓冲区是一种语言无关、平台中立、可扩展的机制，用于序列化结构化数据。接下来，为您选择的编程语言生成服务器端和客户端代码，这简化了服务器端和客户端逻辑，提供了低级通信抽象。在服务器端，您实现远程公开的方法的逻辑，并运行绑定服务的
    gRPC 服务器。在客户端，您连接到远程 gRPC 服务器，并使用生成的客户端代码调用远程方法。
- en: This chapter is mainly about getting hands-on experience with developing and
    running gRPC server and client applications. The experience you gain by following
    the session is quite useful when building a real-world gRPC application because
    irrespective of which language you are using, you need similar steps to build
    a gRPC application. So, in the next chapter, we will further extend the concepts
    and technologies you learned to build real-world use cases.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要介绍如何动手开发和运行 gRPC 服务器和客户端应用程序的经验。按照本节的步骤获得的经验在构建真实的 gRPC 应用程序时非常有用，因为无论使用哪种语言，构建
    gRPC 应用程序都需要类似的步骤。因此，在下一章中，我们将进一步扩展您学到的概念和技术，以构建实际的使用案例。
