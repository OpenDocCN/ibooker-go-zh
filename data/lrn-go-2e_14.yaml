- en: Chapter 14\. The Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。上下文
- en: 'Servers need a way to handle metadata on individual requests. This metadata
    falls into two general categories: metadata that is required to correctly process
    the request, and metadata on when to stop processing the request. For example,
    an HTTP server might want to use a tracking ID to identify a chain of requests
    through a set of microservices. It also might want to set a timer that ends requests
    to other microservices if they take too long.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要一种处理个别请求元数据的方式。这些元数据可以大致分为两类：一是正确处理请求所需的元数据，二是控制何时停止处理请求的元数据。例如，一个HTTP服务器可能希望使用跟踪ID标识一系列通过一组微服务的请求。它还可能希望设置一个计时器，以便在其他微服务请求时间过长时结束请求。
- en: Many languages use *threadlocal* variables to store this kind of information,
    associating data to a specific operating system thread of execution. This doesn’t
    work in Go because goroutines don’t have unique identities that can be used to
    look up values. More importantly, threadlocals feel like magic; values go in one
    place and pop up somewhere else.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言使用*线程本地*变量来存储这类信息，将数据关联到特定的操作系统线程执行上。这在Go语言中行不通，因为goroutine没有可以用来查找值的唯一标识。更重要的是，线程本地变量感觉像是魔术；值放在一个地方，却在其他地方出现。
- en: Go solves the request metadata problem with a construct called the *context*.
    Let’s see how to use it correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言通过一种称为*context*的构造解决请求元数据问题。让我们看看如何正确使用它。
- en: What Is the Context?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是上下文？
- en: Rather than add a new feature to the language, a context is simply an instance
    that meets the `Context` interface defined in the `context` package. As you know,
    idiomatic Go encourages explicit data passing via function parameters. The same
    is true for the context. It is just another parameter to your function.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不是为语言添加新功能，上下文仅仅是符合`context`包中定义的`Context`接口的实例。正如你所知，Go语言鼓励通过函数参数显式传递数据。对于上下文而言也是如此，它只是作为你的函数的另一个参数。
- en: 'Just as Go has a convention that the last return value from a function is an
    `error`, Go has another convention that the context is explicitly passed through
    your program as the first parameter of a function. The usual name for the context
    parameter is `ctx`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Go语言约定的最后一个返回值是`error`一样，Go还约定上下文作为函数的第一个参数显式传递到你的程序中。上下文参数的通常名称是`ctx`：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to defining the `Context` interface, the `context` package contains
    several factory functions for creating and wrapping contexts. When you don’t have
    an existing context, such as at the entry point to a command-line program, create
    an empty initial context with the function `context.Background`. This returns
    a variable of type `context.Context`. (Yes, this is an exception to the usual
    pattern of returning a concrete type from a function call.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义`Context`接口外，`context`包还包含几个工厂函数，用于创建和包装上下文。当你没有现成的上下文，比如在命令行程序的入口点时，可以使用函数`context.Background`创建一个空的初始上下文。这将返回一个`context.Context`类型的变量。（是的，这与通常从函数调用中返回具体类型的模式不同。）
- en: An empty context is a starting point; each time you add metadata to the context,
    you do so by *wrapping* the existing context by using one of the factory functions
    in the `context` package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 空上下文是一个起点；每次向上下文添加元数据时，都可以通过`context`包中的工厂函数*包装*现有的上下文。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another function, `context.TODO`, also creates an empty `context.Context`. It
    is intended for temporary use during development. If you aren’t sure where the
    context is going to come from or how it’s going to be used, use `context.TODO`
    to put a placeholder in your code. Production code shouldn’t include `context.TODO`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数`context.TODO`也创建一个空的`context.Context`。它用于开发过程中的临时使用。如果你不确定上下文将来自何处或将如何使用它，请使用`context.TODO`在代码中放置一个占位符。生产代码不应包含`context.TODO`。
- en: When writing an HTTP server, you use a slightly different pattern for acquiring
    and passing the context through layers of middleware to the top-level `http.Handler`.
    Unfortunately, context was added to the Go APIs long after the `net/http` package
    was created. Because of the compatibility promise, there was no way to change
    the `http.Handler` interface to add a `context.Context` parameter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写HTTP服务器时，你使用稍微不同的模式来通过中间件层传递并获取上下文，最终传递给顶级的`http.Handler`。不幸的是，上下文是在`net/http`包创建之后很长时间才添加到Go
    API中的。由于兼容性承诺，无法修改`http.Handler`接口以添加`context.Context`参数。
- en: 'The compatibility promise does allow new methods to be added to existing types,
    and that’s what the Go team did. Two context-related methods are on `http.Request`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 兼容性承诺确实允许在现有类型中添加新方法，这也是 Go 团队所做的。`http.Request` 上有两个与上下文相关的方法：
- en: '`Context` returns the `context.Context` associated with the request.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context` 返回与请求关联的 `context.Context`。'
- en: '`WithContext` takes in a `context.Context` and returns a new `http.Request`
    with the old request’s state combined with the supplied `context.Context`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithContext` 接收一个 `context.Context` 并返回一个新的 `http.Request`，其中包含旧请求的状态和提供的
    `context.Context` 的组合。'
- en: 'Here’s the general pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一般的模式：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing you do in your middleware is extract the existing context from
    the request by using the `Context` method. (If you want to skip ahead, you can
    see how to put values into the context in [“Values”](#context_values).) After
    you put values into the context, you create a new request based on the old request
    and the now-populated context by using the `WithContext` method. Finally, you
    call the `handler` and pass it your new request and the existing `http.ResponseWriter`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的中间件中，第一件事情是通过使用 `Context` 方法从请求中提取现有的上下文。（如果你想要跳过，可以看看如何将值放入上下文中的[“值”](#context_values)部分。）在将值放入上下文后，你可以使用
    `WithContext` 方法基于旧请求和现在填充的上下文创建一个新请求。最后，调用 `handler` 并传递你的新请求和现有的 `http.ResponseWriter`。
- en: 'When you implement the handler, extract the context from the request by using
    the `Context` method and call your business logic with the context as the first
    parameter, just as you saw previously:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现处理程序时，使用 `Context` 方法从请求中提取上下文，并将上下文作为第一个参数调用你的业务逻辑，就像之前看到的那样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When making an HTTP call from your application to another HTTP service, use
    the `NewRequestWithContext` function in the `net/http` package to construct a
    request that includes existing context information:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序从另一个 HTTP 服务进行 HTTP 调用时，请使用 `net/http` 包中的 `NewRequestWithContext` 函数来构造一个请求，其中包含现有的上下文信息：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can find these code samples in the *sample_code/context_patterns* directory
    in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第14章的仓库](https://oreil.ly/iT-az)中的 *sample_code/context_patterns* 目录中找到这些代码示例。
- en: Now that you know how to acquire and pass a context, let’s start making them
    useful. You’ll begin with passing values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何获取和传递上下文了，让我们开始让它们有用起来。你将从传递值开始。
- en: Values
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值
- en: By default, you should prefer to pass data through explicit parameters. As has
    been mentioned before, idiomatic Go favors the explicit over the implicit, and
    this includes explicit data passing. If a function depends on some data, it should
    be clear what data it needs and where that data came from.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你应该优先通过显式参数传递数据。正如之前提到的，习惯上 Go 更偏向于显式而非隐式，包括显式数据传递。如果一个函数依赖于某些数据，它应该清楚地指出它需要什么数据以及数据来自何处。
- en: However, in some cases you cannot pass data explicitly. The most common situation
    is an HTTP request handler and its associated middleware. As you have seen, all
    HTTP request handlers have two parameters, one for the request and one for the
    response. If you want to make a value available to your handler in middleware,
    you need to store it in the context. Possible situations include extracting a
    user from a JWT (JSON Web Token) or creating a per-request GUID that is passed
    through multiple layers of middleware and into your handler and business logic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你不能显式地传递数据。最常见的情况是 HTTP 请求处理程序及其关联的中间件。正如你所见，所有的 HTTP 请求处理程序都有两个参数，一个用于请求，一个用于响应。如果你想要在中间件中使一个值对处理程序可用，你需要将它存储在上下文中。可能的情况包括从
    JWT（JSON Web Token）中提取用户或创建一个通过多层中间件传递到处理程序和业务逻辑的每个请求的 GUID。
- en: 'There is a factory method for putting values into the context, `context.WithValue`.
    It takes in three values: a context, a key to look up the value, and the value
    itself. The key and the value parameters are declared to be of type `any`. The
    `context.WithValue` function returns a context, but it is not the same context
    that was passed into the function. Instead, it is a *child* context that contains
    the key-value pair and *wraps* the passed-in *parent* `context.Context`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用于将值放入上下文的工厂方法，`context.WithValue`。它接收三个值：一个上下文，一个键来查找值以及值本身。键和值参数声明为 `any`
    类型。`context.WithValue` 函数返回一个上下文，但它不是传入函数的同一个上下文。相反，它是一个包含键-值对并包裹传入的父 `context.Context`
    的*子*上下文。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see this wrapping pattern several times. A context is treated as an immutable
    instance. Whenever you add information to a context, you do so by wrapping an
    existing parent context with a child context. This allows you to use contexts
    to pass information into deeper layers of the code. The context is never used
    to pass information out of deeper layers to higher layers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会多次看到这种包装模式。上下文被视为一个不可变实例。每当向上下文添加信息时，都是通过将现有的父上下文包装为子上下文来实现的。这使你能够使用上下文将信息传递到代码的更深层。上下文永远不用于将信息从更深的层传递到更高的层。
- en: 'The `Value` method on `context.Context` checks whether a value is in a context
    or any of its parent contexts. This method takes in a key and returns the value
    associated with the key. Again, both the key parameter and the value result are
    declared to be of type `any`. If no value is found for the supplied key, `nil`
    is returned. Use the comma ok idiom to type-assert the returned value to the correct
    type:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Context`上的`Value`方法检查一个值是否在上下文或其任何父上下文中。此方法接受一个键，并返回与该键关联的值。同样，键参数和值结果都声明为`any`类型。如果未找到提供的键的值，则返回`nil`。使用逗号-ok惯用法将返回的值断言为正确的类型：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are familiar with data structures, you might recognize that searching
    for values stored in the context chain is a *linear* search. This has no serious
    performance implications when there are only a few values, but it would perform
    poorly if you stored dozens of values in the context during a request. That said,
    if your program is creating a context chain with dozens of values, your program
    probably needs some refactoring.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉数据结构，您可能会意识到在上下文链中搜索存储的值是*线性*搜索。当只有少量值时，这不会对性能造成严重影响，但如果在请求期间将几十个值存储在上下文中，性能会表现不佳。也就是说，如果您的程序正在创建具有几十个值的上下文链，那么您的程序可能需要进行一些重构。
- en: The value stored in the context can be of any type, but picking the correct
    key is important. Like the key for a `map`, the key for a context value must be
    comparable. Don’t just use a `string` like `"id"`. If you use `string` or another
    predefined or exported type for the type of the key, different packages could
    create identical keys, resulting in collisions. This causes problems that are
    hard to debug, such as one package writing data to the context that masks the
    data written by another package, or reading data from the context that was written
    by another package.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文中存储的值可以是任何类型，但选择正确的键很重要。就像`map`的键一样，上下文值的键必须是可比较的。不要仅仅使用像`"id"`这样的`string`。如果你使用`string`或者另一个预定义或导出的类型作为键的类型，不同的包可能会创建相同的键，导致冲突。这会引起难以调试的问题，例如一个包向上下文写入数据，掩盖了另一个包写入的数据，或者从上下文读取由另一个包写入的数据。
- en: 'Two patterns are used to guarantee that a key is unique and comparable. The
    first creates a new, unexported type for the key, based on an `int`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种模式用于保证键是唯一且可比较的。第一种是基于`int`创建一个新的、未导出的键类型：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After declaring your unexported key type, you then declare an unexported constant
    of that type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明您的未导出键类型后，然后声明该类型的未导出常量：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With both the type and the typed constant of the key being unexported, no code
    from outside your package can put data into the context that would cause a collision.
    If your package needs to put multiple values into the context, define a different
    key of the same type for each value, using the `iota` pattern you looked at in
    [“iota Is for Enumerations—Sometimes”](ch07.html#iota_section). Since you care
    about the constant’s value only as a way to differentiate multiple keys, this
    is a perfect use for `iota`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型和键的类型常量都是未导出的，因此来自包外部的代码无法将数据放入上下文以引起冲突。如果您的包需要将多个值放入上下文，请为每个值定义相同类型的不同键，使用您在[“iota
    用于枚举——有时”](ch07.html#iota_section)中查看过的`iota`模式。由于您只关心常量的值作为区分多个键的一种方式，这是`iota`的一个完美用例。
- en: 'Next, build an API to place a value into the context and to read the value
    from the context. Make these functions public only if code outside your package
    should be able to read and write your context values. The name of the function
    that creates a context with the value should start with `ContextWith`. The function
    that returns the value from the context should have a name that ends with `FromContext`.
    Here are the implementations of functions to set and read the user from the context:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建一个API来将值放入上下文并从上下文中读取该值。仅在包外的代码应该能够读取和写入您的上下文值时，使这些函数公开。创建具有该值的上下文的函数的名称应以`ContextWith`开头。从上下文返回值的函数的名称应以`FromContext`结尾。以下是设置和从上下文中读取用户的函数实现：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another option is to define the unexported key type by using an empty struct:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是通过使用空结构体定义未导出的键类型：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The functions for managing access to the context value are then changed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改用于管理上下文值访问的函数：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How do you know which key style to use? If you have a set of related keys for
    storing different values in the context, use the `int` and `iota` technique. If
    you have only a single key, either is fine. The important thing is that you want
    to make it impossible for context keys to collide.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道使用哪种键样式？如果您有一组用于在上下文中存储不同值的相关键，则使用`int`和`iota`技术。如果只有一个单一的键，则任何一种都可以。重要的是，您希望使上下文键不可能发生冲突。
- en: 'Now that you’ve written your user-management code, let’s see how to use it.
    You’re going to write middleware that extracts a user ID from a cookie:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已编写了用户管理代码，让我们看看如何使用它。您将编写中间件，从cookie中提取用户ID：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the middleware, you first get your user value. Next, you extract the context
    from the request with the `Context` method and create a new context that contains
    the user with your `ContextWithUser` function. It is idiomatic to reuse the `ctx`
    variable name when you wrap a context. You then make a new request from the old
    request and the new context by using the `WithContext` method. Finally, you call
    the next function in your handler chain with our new request and the supplied
    `http.ResponseWriter`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间件中，您首先获取用户值。接下来，使用`Context`方法从请求中提取上下文，并使用`ContextWithUser`函数创建一个包含用户的新上下文。当您包装上下文时，重用`ctx`变量名是惯用的。然后，您通过使用`WithContext`方法从旧请求和新上下文创建一个新请求。最后，您使用我们提供的`http.ResponseWriter`调用处理程序链中的下一个函数。
- en: 'In most cases, you want to extract the value from the context in your request
    handler and pass it in to your business logic explicitly. Go functions have explicit
    parameters, and you shouldn’t use the context as a way to sneak values past the
    API:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您希望在请求处理程序中从上下文中提取值，并将其显式传递给业务逻辑。Go函数具有显式参数，不应将上下文用作通过API绕过的方式：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your handler gets the context by using the `Context` method on the request,
    extracts the user from the context by using the `UserFromContext` function, and
    then calls the business logic. This code shows the value of separation of concerns;
    how the user is loaded is unknown to the `Controller`. A real user-management
    system could be implemented in middleware and swapped in without changing any
    of the controller’s code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在请求上使用`Context`方法获取上下文，使用`UserFromContext`函数从上下文中提取用户，然后调用业务逻辑，您的处理程序会得到上下文。这段代码展示了关注点分离的价值；如何加载用户对`Controller`来说是未知的。一个真实的用户管理系统可以在中间件中实现，并且可以在不更改任何控制器代码的情况下进行交换。
- en: The complete code for this example is in the *sample_code/context_user* directory
    in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码位于[第14章代码库](https://oreil.ly/iT-az)的*sample_code/context_user*目录中。
- en: In some situations, it’s better to keep a value in the context. The tracking
    GUID that was mentioned earlier is one. This information is meant for management
    of your application; it is not part of your business state. Passing it explicitly
    through your code adds additional parameters and prevents integration with third-party
    libraries that do not know about your metainformation. By leaving a tracking GUID
    in the context, it passes invisibly through business logic that doesn’t need to
    know about tracking and is available when your program writes a log message or
    connects to another server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，最好将值保留在上下文中。前面提到的跟踪GUID就是一个例子。此信息用于管理您的应用程序；它不是业务状态的一部分。通过将跟踪GUID明确地通过您的代码传递，可以添加额外的参数，并防止与不知道您元信息的第三方库集成。通过在上下文中留下跟踪GUID，它将在不需要了解跟踪的业务逻辑中隐式传递，并在您的程序写日志消息或连接到另一个服务器时可用。
- en: 'Here is a simple context-aware GUID implementation that tracks from service
    to service and creates logs with the GUID included:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的上下文感知的 GUID 实现，用于跟踪服务之间的流动，并在日志中包含 GUID：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Middleware` function either extracts the GUID from the incoming request
    or generates a new GUID. In both cases, it places the GUID into the context, creates
    a new request with the updated context, and continues the call chain.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Middleware` 函数从传入的请求中提取或生成一个新的 GUID。在这两种情况下，它都将 GUID 放入上下文中，创建一个带有更新后的上下文的新请求，并继续调用链。'
- en: Next you see how this GUID is used. The `Logger` struct provides a generic logging
    method that takes in a context and a string. If there’s a GUID in the context,
    it appends it to the beginning of the log message and outputs it. The `Request`
    function is used when this service makes a call to another service. It takes in
    an `*http.Request`, adds a header with the GUID if it exists in the context, and
    returns the `*http.Request`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来您可以看到如何使用这个 GUID。`Logger` 结构提供了一个通用的日志记录方法，接受上下文和字符串作为参数。如果上下文中有 GUID，则将其附加到日志消息的开头并输出。当此服务调用另一个服务时，会使用
    `Request` 函数。它接受一个 `*http.Request`，如果上下文中存在 GUID，则添加一个带有 GUID 的头部，并返回更新后的 `*http.Request`。
- en: 'Once you have this package, you can use the dependency injection techniques
    that I discussed in [“Implicit Interfaces Make Dependency Injection Easier”](ch07.html#dependency_injection)
    to create business logic that is completely unaware of any tracking information.
    First, you declare an interface to represent your logger, a function type to represent
    a request decorator, and a business logic struct that depends on them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了这个包，您可以使用我在 [“隐式接口使依赖注入更容易”](ch07.html#dependency_injection) 中讨论的依赖注入技术来创建完全不知道任何跟踪信息的业务逻辑。首先，声明一个接口来表示您的日志记录器，一个函数类型来表示请求装饰器，以及一个依赖于它们的业务逻辑结构：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, you implement your business logic:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现您的业务逻辑：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The GUID is passed through to the logger and the request decorator without
    the business logic being aware of it, separating the data needed for program logic
    from the data needed for program management. The only place that’s aware of the
    association is the code in `main` that wires up your dependencies:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GUID 通过日志记录器和请求装饰器传递，而业务逻辑不知道它，从而将程序逻辑所需的数据与程序管理所需的数据分离。唯一知道关联的地方是在 `main` 中将您的依赖项连接起来的代码。
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can find the complete code for the GUID tracker in the *sample_code/context_guid*
    directory in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [第 14 章存储库](https://oreil.ly/iT-az) 的 *sample_code/context_guid* 目录中找到
    GUID 追踪器的完整代码。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the context to pass values through standard APIs. Copy values from the context
    into explicit parameters when they are needed for processing business logic. System
    maintenance information can be accessed directly from the context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文通过标准 API 传递值。在处理业务逻辑时，将上下文中的值复制到显式参数中。系统维护信息可以直接从上下文中访问。
- en: Cancellation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消
- en: While context values are useful for passing metadata and working around the
    limitations of Go’s HTTP API, the context has a second use. The context also allows
    you to control the responsiveness of your application and coordinate concurrent
    goroutines. Let’s see how.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上下文值对于传递元数据并解决 Go 的 HTTP API 限制非常有用，但上下文还有第二个用途。上下文还允许您控制应用程序的响应性并协调并发的 goroutine。让我们看看如何实现。
- en: I discussed this briefly in [“Use the Context to Terminate Goroutines”](ch12.html#done_channel).
    Imagine that you have a request that launches several goroutines, each one calling
    a different HTTP service. If one service returns an error that prevents you from
    returning a valid result, there is no point in continuing to process the other
    goroutines. In Go, this is called *cancellation*, and the context provides the
    mechanism for its implementation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [“使用上下文终止 Goroutines”](ch12.html#done_channel) 中简要讨论了这个问题。想象一下，您有一个请求启动了几个
    goroutine，每个 goroutine 调用不同的 HTTP 服务。如果一个服务返回错误，导致您无法返回有效结果，则继续处理其他 goroutine
    没有意义。在 Go 中，这被称为 *取消*，上下文提供了其实现的机制。
- en: To create a cancellable context, use the `context.WithCancel` function. It takes
    in a `context.Context` as a parameter and returns a `context.Context` and a `context.CancelFunc`.
    Just like `context.WithValue`, the returned `context.Context` is a child context
    of the context that was passed into the function. A `context.CancelFunc` is a
    function that takes no parameters and *cancels* the context, telling all the code
    that’s listening for potential cancellation that it’s time to stop processing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可取消的上下文，使用`context.WithCancel`函数。它以`context.Context`作为参数，并返回一个`context.Context`和一个`context.CancelFunc`。就像`context.WithValue`一样，返回的`context.Context`是传入函数的上下文的子上下文。`context.CancelFunc`是一个不带参数的函数，用于*取消*上下文，告诉所有监听潜在取消事件的代码停止处理。
- en: Anytime you create a context that has an associated cancel function, you *must*
    call that cancel function when you are done processing, whether or not your processing
    ends in an error. If you do not, your program will leak resources (memory and
    goroutines) and eventually slow down or crash. No error occurs if you call the
    cancel function more than once; any invocation after the first does nothing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个带有关联取消函数的上下文时，无论处理是否以错误结束，*必须*调用该取消函数。如果不这样做，你的程序将泄露资源（内存和goroutine），最终会变慢或崩溃。多次调用取消函数不会引发错误；第一次之后的每次调用都不会产生任何效果。
- en: 'The easiest way to make sure you call the cancel function is to use `defer`
    to invoke it right after the cancel function is returned:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确保调用取消函数的最简单方法是使用`defer`在取消函数返回后立即调用它：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This leads to the question, how do you detect cancellation? The `context.Context`
    interface has a method called `Done`. It returns a channel of type `struct{}`.
    (The reason this is the chosen return type is that an empty struct uses no memory.)
    This channel is closed when the `cancel` function is invoked. Remember, a closed
    channel always immediately returns its zero value when you attempt to read it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来一个问题，你如何检测取消？`context.Context`接口有一个叫做`Done`的方法。它返回一个类型为`struct{}`的通道。（选择这种返回类型的原因是空结构体不使用内存。）当调用`cancel`函数时，这个通道会关闭。记住，关闭的通道在尝试读取时会立即返回其零值。
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you call `Done` on a context that isn’t cancellable, it returns `nil`. As
    was covered in [“Turn Off a case in a select”](ch12.html#nil_channel), a read
    from a `nil` channel never returns. If this is not done inside a `case` in a `select`
    statement, your program will hang.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个不可取消的上下文中调用`Done`，它将返回`nil`。正如在[“在`select`语句中关闭一个`case`”](ch12.html#nil_channel)中所述，从`nil`通道读取永远不会返回。如果这不是在`select`语句的一个`case`内完成，你的程序将挂起。
- en: Let’s take a look at how this works. Let’s say you have a program that’s gathering
    data from a number of HTTP endpoints. If any one of them fails, you want to end
    processing across all of them. Context cancellation allows you to do that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。假设你有一个程序从多个HTTP端点收集数据。如果其中任何一个失败，你希望结束所有的处理。上下文取消允许你这样做。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this example, you are going to take advantage of a great service called
    [httpbin.org](http://httpbin.org). You send it HTTP or HTTPS requests to test
    how your application responds to a variety of situations. You’ll use two of its
    endpoints: one that delays response for a specified number of seconds, and one
    that will return one of the status codes that you send it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将利用一个名为[httpbin.org](http://httpbin.org)的优秀服务。你可以向它发送HTTP或HTTPS请求，以测试你的应用程序对各种情况的响应方式。你将使用它的两个端点：一个是延迟指定秒数后返回响应的端点，另一个会返回你发送的状态码之一。
- en: 'First, create your cancellable context, a channel to get back data from your
    goroutines, and a `sync.WaitGroup` to allow you to wait until all goroutines have
    completed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建你的可取消上下文、一个用于从goroutine获取数据的通道，以及一个`sync.WaitGroup`以允许等待直到所有goroutine完成：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, you launch two goroutines, one that calls a URL that randomly returns
    a bad status, and the other that sends a canned JSON response after a delay. First
    the random status goroutine:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动两个goroutine，一个调用URL，随机返回一个错误的状态，另一个在延迟后发送一个预设的JSON响应。首先是随机状态的goroutine：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `makeRequest` function is a helper to make an HTTP request using the supplied
    context and URL. If you get back an OK status, you write a message to the channel
    and sleep for a second. When an error occurs or you get back a bad status code,
    you call `cancelFunc` and exit the goroutine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRequest`函数是一个辅助函数，用于使用提供的上下文和URL进行HTTP请求。如果返回OK状态，你将向通道写入一条消息并休眠一秒钟。当出现错误或者返回了一个错误的状态码时，你调用`cancelFunc`并退出goroutine。'
- en: 'The delay goroutine is similar:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟goroutine类似：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, you use the for/select pattern to read data from the channel written
    to by the goroutines and wait for cancellation to happen:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用for/select模式从goroutine写入的通道中读取数据，并等待取消的发生：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In your `select` statement, you have two cases. One reads from the message channel,
    and the other waits for the done channel to be closed. When it closes, you exit
    the loop and wait for the goroutines to exit. You can find this program in the
    *sample_code/cancel_http* directory in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`select`语句中，有两种情况。一种从消息通道读取，另一种等待完成通道关闭。当它关闭时，你退出循环并等待goroutine退出。你可以在[第14章仓库](https://oreil.ly/iT-az)的*sample_code/cancel_http*目录中找到此程序。
- en: 'Here’s what happens when you run the code (the results are random, so go ahead
    and run it a few times to see different results):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您运行代码时发生的情况（结果是随机的，所以请继续运行几次以查看不同的结果）：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are some interesting things to note. First, you are calling `cancelFunc`
    multiple times. As mentioned earlier, this is perfectly fine and causes no problems.
    Next, notice that you got an error from the delay goroutine after cancellation
    was triggered. This is because the built-in HTTP client in the Go standard library
    respects cancellation. You created the request using the cancellable context,
    and when it was cancelled, the request ended. This triggers the error path in
    the goroutine and makes sure that it does not leak.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的事情需要注意。首先，您多次调用`cancelFunc`。正如前面提到的，这是完全可以的，不会引起问题。接下来，请注意，在触发取消后，您从延迟goroutine获取了一个错误。这是因为Go标准库中内置的HTTP客户端尊重取消。您使用可取消的上下文创建了请求，当取消时，请求结束。这会触发goroutine中的错误路径，并确保它不会泄漏。
- en: You might wonder about the error that caused the cancellation and how you can
    report it. An alternate version of `WithCancel`, called `WithCancelCause`, returns
    a cancellation function that takes in an error as a parameter. The `Cause` function
    in the `context` package returns the error that was passed into the first invocation
    of the cancellation function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道导致取消的错误以及如何报告它。名为`WithCancelCause`的`WithCancel`的替代版本返回一个接受错误作为参数的取消函数。`context`包中的`Cause`函数返回传递给取消函数首次调用的错误。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Cause` is a function in the `context` package instead of a method on `context.Context`
    because the ability to return errors via cancellation was added to the `context`
    package in Go 1.20, long after the context was initially introduced. If a new
    method was added to the `context.Context` interface, this would have broken any
    third-party code that implemented it. Another option would be to define a new
    interface that included this method, but existing code already passes `context.Context`
    everywhere, and converting to a new interface with a `Cause` method would require
    type assertions or type switches. Adding a function is the simplest approach.
    There are several ways to evolve your APIs over time. You should pick the one
    that has the least impact on your users.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cause`是`context`包中的一个函数，而不是`context.Context`上的方法，因为在Go 1.20中将通过取消返回错误的功能添加到了`context`包中，这是在最初引入`context`之后很久的事情。如果在`context.Context`接口上添加了一个新方法，这将破坏任何实现它的第三方代码。另一个选项是定义一个包含此方法的新接口，但现有代码已经到处传递`context.Context`，并将其转换为具有`Cause`方法的新接口将需要类型断言或类型切换。添加一个函数是最简单的方法。随着时间的推移，有几种方式可以演化你的API。你应该选择对用户影响最小的方式。'
- en: 'Let’s rewrite the program to capture the error. First, you change your context
    creation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写程序以捕获错误。首先，您更改了上下文的创建：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, you are going to make slight modifications to your two goroutines. The
    body of the `for` loop in the status goroutine now looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将对两个goroutine进行轻微修改。状态goroutine中`for`循环的主体现在如下所示：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You’ve removed the `fmt.Println` statements and pass errors to `cancelFunc`.
    The body of the `for` loop in the delay goroutine now looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您已删除`fmt.Println`语句，并将错误传递给`cancelFunc`。延迟goroutine中`for`循环的主体现在如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `fmt.Println` is still there so you can show that the error is still generated
    and passed to `cancelFunc`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Println`仍然存在，因此您可以显示仍然生成并传递给`cancelFunc`的错误。'
- en: 'Finally, you use `context.Cause` to print out the error both on initial cancellation
    and after you finish waiting for your goroutines to complete:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您使用`context.Cause`在初始取消和等待goroutine完成后打印错误：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can find this code in the *sample_code/cancel_error_http* directory in the
    [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第14章存储库](https://oreil.ly/iT-az)的*sample_code/cancel_error_http*目录中找到此代码。
- en: 'Running your new program produces this output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新程序会生成以下输出：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You see that the error from the status goroutine is printed out both when cancellation
    is initially detected in the `switch` statement and after you finish waiting for
    the delay goroutine to complete. Notice that the delay goroutine called `cancelFunc`
    with an error, but that error doesn’t overwrite the initial cancellation error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当最初在`switch`语句中检测到取消时，你会看到来自状态goroutine的错误输出，以及在等待延迟goroutine完成后。请注意，延迟goroutine使用错误调用了`cancelFunc`，但该错误并未覆盖最初的取消错误。
- en: Manual cancellation is very useful when your code reaches a logical state that
    ends processing. Sometimes you want to cancel because a task is taking too long.
    In that case, you use a timer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码达到结束处理的逻辑状态时，手动取消非常有用。有时候你想取消是因为任务花费的时间太长。在这种情况下，你可以使用定时器。
- en: Contexts with Deadlines
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有截止时间的上下文。
- en: One of the most important jobs for a server is managing requests. A novice programmer
    often thinks that a server should take as many requests as it possibly can and
    work on them for as long as it can until it returns a result for each client.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的最重要工作之一是管理请求。初学者程序员通常认为服务器应该尽可能多地接受请求，并在可能的情况下处理它们，直到为每个客户端返回结果。
- en: The problem is that this approach does not scale. A server is a shared resource.
    Like all shared resources, each user wants to get as much as they can out of it
    and isn’t terribly concerned with the needs of other users. It’s the responsibility
    of the shared resource to manage itself so that it provides a fair amount of time
    to all its users.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这种方法不具备可扩展性。服务器是共享资源。像所有共享资源一样，每个用户都希望从中获取尽可能多的资源，并且并不十分关心其他用户的需求。共享资源的责任是自我管理，以便为所有用户提供公平的时间。
- en: 'Generally, a server can do four things to manage its load:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务器可以执行四项操作来管理其负载：
- en: Limit simultaneous requests
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制同时请求。
- en: Limit the number of queued requests waiting to run
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制等待运行的排队请求数量。
- en: Limit the amount of time a request can run
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制请求可以运行的时间量。
- en: Limit the resources a request can use (such as memory or disk space)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制请求可以使用的资源（如内存或磁盘空间）。
- en: Go provides tools to handle the first three. You saw how to handle the first
    two when learning about concurrency in [Chapter 12](ch12.html#unique_chapter_id_12).
    By limiting the number of goroutines, a server manages simultaneous load. The
    size of the waiting queue is handled via buffered channels.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了处理前三个问题的工具。在学习并发性时，你了解到如何处理前两个问题（参见[第12章](ch12.html#unique_chapter_id_12)）。通过限制goroutine的数量，服务器可以管理同时负载。通过缓冲通道处理等待队列的大小。
- en: 'The context provides a way to control how long a request runs. When building
    an application, you should have an idea of your performance envelope: how long
    you have for your request to complete before the user has an unsatisfactory experience.
    If you know the maximum amount of time that a request can run, you can enforce
    it using the context.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文提供了一种控制请求运行时间的方法。在构建应用程序时，你应该有一个性能范围的概念：在用户体验不佳之前，请求完成的最长时间。如果你知道请求可以运行的最长时间，可以使用上下文进行强制执行。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While `GOMEMLIMIT` provides a soft way to limit the amount of memory a Go program
    uses, if you want to enforce constraints on memory or disk space that a single
    request uses, you’ll have to write the code to manage that yourself. Discussion
    of this topic is beyond the scope of this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`GOMEMLIMIT`提供了限制Go程序使用的内存量的软性方法，但如果你想强制约束单个请求使用的内存或磁盘空间，你必须编写管理此类限制的代码。本书讨论此主题超出了范围。
- en: 'You can use one of two functions to create a time-limited context. The first
    is `context.WithTimeout`. It takes two parameters: an existing context and `time.Duration`
    that specifies the duration until the context automatically cancels. It returns
    a context that automatically triggers a cancellation after the specified duration
    as well as a cancellation function that is invoked to cancel the context immediately.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两个函数之一创建有时间限制的上下文。第一个是`context.WithTimeout`。它接受两个参数：一个现有的上下文和指定持续时间的`time.Duration`，在此持续时间后上下文将自动取消。它返回一个上下文，在指定持续时间后自动触发取消，并返回一个可立即调用以取消上下文的取消函数。
- en: The second function is `context.WithDeadline`. This function takes in an existing
    context and a `time.Time` that specifies the time when the context is automatically
    canceled. Like `context.WithTimeout`, it returns a context that automatically
    triggers a cancellation after the specified time has elapsed as well as a cancellation
    function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数是`context.WithDeadline`。此函数接收一个现有的上下文和一个指定上下文何时自动取消的`time.Time`。像`context.WithTimeout`一样，它返回一个上下文，在指定时间后自动触发取消以及一个取消函数。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you pass a time in the past to `context.WithDeadline`, the context is created
    already canceled.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将过去的时间传递给`context.WithDeadline`，上下文已经被创建取消。
- en: Just as with the cancellation function returned from `context.WithCancel` and
    `context.WithCancelCause`, you must make sure that that the cancellation function
    returned by `context.WithTimeout` and `context.WithDeadline` is invoked at least
    once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从`context.WithCancel`和`context.WithCancelCause`返回的取消函数一样，你必须确保`context.WithTimeout`和`context.WithDeadline`返回的取消函数至少被调用一次。
- en: If you want to find out when a context will automatically cancel, use the `Deadline`
    method on `context.Context`. It returns a `time.Time` that indicates the time
    and a `bool` that indicates if a timeout was set. This mirrors the comma ok idiom
    you use when reading from maps or channels.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道上下文何时会自动取消，请使用`context.Context`的`Deadline`方法。它返回一个`time.Time`，指示时间和一个`bool`，指示是否设置了超时。这与读取映射或通道时使用的comma
    ok习语类似。
- en: When you set a time limit for the overall duration of the request, you might
    want to subdivide that time. And if you call another service from your service,
    you might want to limit how long you allow the network call to run, reserving
    some time for the rest of your processing or for other network calls. You control
    how long an individual call takes by creating a child context that wraps a parent
    context by using `context.WithTimeout` or `context.WithDeadline`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为请求的总持续时间设置时间限制时，你可能希望将这段时间细分。如果你从你的服务调用另一个服务，你可能希望限制允许网络调用运行的时间，为其余处理或其他网络调用预留一些时间。通过使用`context.WithTimeout`或`context.WithDeadline`创建包装父上下文的子上下文，你可以控制每个单独调用所花费的时间。
- en: Any timeout that you set on the child context is bounded by the timeout set
    on the parent context; if a parent context times out in 2 seconds, you can declare
    that a child context times out in 3 seconds, but when the parent context times
    out after 2 seconds, so will the child.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你在子上下文设置的任何超时都受父上下文设置的超时的限制；如果父上下文在2秒钟后超时，你可以声明子上下文在3秒钟后超时，但当父上下文在2秒钟后超时时，子上下文也将超时。
- en: 'You can see this with a simple program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个简单的程序看到这一点：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this sample, you specify a 2-second timeout on the parent context and a 3-second
    timeout on the child context. You then wait for the child context to complete
    by waiting on the channel returned from the `Done` method on the child `context.Context`.
    I’ll talk more about the `Done` method in the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你在父上下文上指定了2秒钟的超时，在子上下文上指定了3秒钟的超时。然后，你通过等待从子`context.Context`的`Done`方法返回的通道来等待子上下文完成。我将在下一节更多地讨论`Done`方法。
- en: 'You can find this code in the *sample_code/nested_timers* directory in the
    [Chapter 14 repository](https://oreil.ly/iT-az) or run this code on [The Go Playground](https://oreil.ly/FS8h2).
    You’ll see the following result:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第14章存储库](https://oreil.ly/iT-az)的*sample_code/nested_timers*目录中找到此代码，或在[Go
    Playground](https://oreil.ly/FS8h2)上运行此代码。你将看到以下结果：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since contexts with timers can cancel because of a timeout or an explicit call
    to the cancellation function, the context API provides a way to tell what caused
    cancellation. The `Err` method returns `nil` if the context is still active, or
    it returns one of two sentinel errors if the context has been canceled: `context.Canceled`
    or `context.DeadlineExceeded`. The first is returned after explicit cancellation,
    and the second is returned when a timeout triggered cancellation.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于带有计时器的上下文可以因超时或显式调用取消函数而取消，上下文API提供了一种告知取消原因的方法。`Err`方法返回`nil`，如果上下文仍处于活动状态，或者如果上下文已被取消，则返回两种哨兵错误之一：`context.Canceled`或`context.DeadlineExceeded`。当显式取消时返回第一个错误，当超时触发取消时返回第二个错误。
- en: 'Let’s see them in use. You’re going to make one more change to your httpbin
    program. This time, you’re adding a timeout to the context that’s used to control
    how long the goroutines run:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们的用法。你将对你的httpbin程序进行一次修改。这一次，你要为控制goroutine运行时间的上下文添加一个超时：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want the option of returning the error for the cancellation cause, you
    need to wrap a context created by `WithTimeout` or `WithDeadline` in a context
    created by `WithCancelCause`. You must `defer` both cancellation functions to
    keep resources from being leaked. If you want to return a custom sentinel error
    when a context times out, use the `context.WithTimeoutCause` or `context.WithDeadlineCause`
    functions instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望返回取消原因的错误选项，则需要将由`WithTimeout`或`WithDeadline`创建的上下文包装在由`WithCancelCause`创建的上下文中。您必须推迟两个取消函数，以防止资源泄漏。如果希望在上下文超时时返回自定义哨兵错误，请改用`context.WithTimeoutCause`或`context.WithDeadlineCause`函数。
- en: 'Now your program will exit if a 500 status code is returned or if you don’t
    get a 500 status code within 3 seconds. The only other change you are making to
    the program is to print out the value returned by `Err` when cancellation happens:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果返回500状态代码或者在3秒内未获取500状态代码，您的程序将退出。您对程序的唯一其他更改是在取消发生时打印`Err`返回的值：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can find the code in the *sample_code/timeout_error_http* directory in the
    [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第14章存储库](https://oreil.ly/iT-az)的*sample_code/timeout_error_http*目录中找到该代码。
- en: 'The results are random, so run the program multiple times to see different
    results. If you run the program and hit the timeout, you’ll get output like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是随机的，因此运行程序多次以查看不同的结果。如果运行程序并达到超时，您将获得如下输出：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that the error returned by `context.Cause` is the same error that’s
    returned by the `Err` method: `context.DeadlineExceeded`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`context.Cause`返回的错误与`Err`方法返回的错误相同：`context.DeadlineExceeded`。
- en: 'If the status error happens within 3 seconds, you’ll get output like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态错误发生在3秒内，您将获得如下输出：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the error returned by `context.Cause` is `bad status`, but `Err` returns
    a `context.Canceled` error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`context.Cause`返回的错误是`bad status`，但`Err`返回`context.Canceled`错误。
- en: Context Cancellation in Your Own Code
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您自己代码中的上下文取消
- en: Most of the time, you don’t need to worry about timeouts or cancellation within
    your own code; it simply doesn’t run for long enough. Whenever you call another
    HTTP service or the database, you should pass along the context; those libraries
    properly handle cancellation via the context.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您无需担心自己的代码超时或取消；它根本不会运行足够长时间。每当调用另一个HTTP服务或数据库时，应传递上下文；这些库通过上下文正确处理取消。
- en: You should think about handling cancellation for two situations. The first is
    when you have a function that reads or writes channels by using a `select` statement.
    As shown in [“Cancellation”](#cancelation), include a `case` that checks the channel
    returned by the `Done` method on the context. This allows your function to exit
    upon context cancellation, even if the goroutines do not handle cancellation properly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您应考虑处理两种情况的取消。第一种情况是当您的函数使用`select`语句读取或写入通道时。如[“取消”](#cancelation)中所示，包括检查上下文上的`Done`方法返回的通道的`case`。这允许您的函数在上下文取消时退出，即使goroutine未正确处理取消。
- en: The second situation is when you write code that runs long enough that it should
    be interrupted by a context cancellation. In that case, check the status of the
    context periodically using `context.Cause`. The `context.Cause` function returns
    an error if the context has been cancelled.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是当您编写的代码运行时间足够长，应该被上下文取消中断时。在这种情况下，定期使用`context.Cause`检查上下文的状态。`context.Cause`函数如果上下文已被取消，则返回错误。
- en: 'Here’s the pattern for supporting context cancellation in your code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是支持您代码中上下文取消的模式：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here’s an example loop from a function that calculates π by using the inefficient
    Leibniz algorithm. Using context cancellation allows you to control how long it
    can run:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例循环，通过使用低效的Leibniz算法计算π的函数。使用上下文取消允许您控制其运行时间：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can see the complete sample program that demonstrates this pattern in the
    *sample_code/own_cancellation* directory in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看完整的示例程序，演示了*sample_code/own_cancellation*目录中的这种模式，在[第14章存储库](https://oreil.ly/iT-az)中找到。
- en: Exercises
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you’ve seen how to use the context, try to implement these exercises.
    All the answers are found in the [Chapter 14 repository](https://oreil.ly/iT-az).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到如何使用上下文，请尝试实现这些练习。所有答案都可以在[第14章存储库](https://oreil.ly/iT-az)中找到。
- en: Create a middleware-generating function that creates a context with a timeout.
    The function should have one parameter, which is the number of milliseconds that
    a request is allowed to run. It should return a `func(http.Handler) http.Handler`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成中间件的函数，它创建一个带有超时的上下文。该函数应该有一个参数，即请求允许运行的毫秒数。它应返回一个`func(http.Handler)
    http.Handler`。
- en: 'Write a program that adds randomly generated numbers between 0 (inclusive)
    and 100,000,000 (exclusive) together until one of two things happen: the number
    1234 is generated or 2 seconds has passed. Print out the sum, the number of iterations,
    and the reason for ending (timeout or number reached).'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，将在生成的随机数介于0（含）和100,000,000（不含）之间的范围内随机生成，直到两件事中的一件发生为止：生成数字1234或经过2秒。打印出总和、迭代次数以及结束原因（超时或达到数字）。
- en: 'Assume you have a simple logging function that looks like this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个简单的日志记录函数，看起来像这样：
- en: '[PRE35]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Define a type called `Level` whose underlying type is `string`. Define two constants
    of this type, `Debug` and `Info`, and set them to `"debug"` and `"info"`, respectively.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个名为`Level`的类型，其底层类型为`string`。定义该类型的两个常量，`Debug`和`Info`，分别设置为`"debug"`和`"info"`。
- en: Create functions to store the log level in the context and to extract it.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上下文中创建函数来存储日志级别并提取它。
- en: Create a middleware function to get the logging level from a query parameter
    called `log_level`. The valid values for `log_level` are `debug` and `info`.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个中间件函数，从名为`log_level`的查询参数中获取日志级别。`log_level` 的有效值为 `debug` 和 `info`。
- en: Finally, fill in the `TODO` in `Log` to properly extract the log level from
    the context. If the log level is not assigned or is not a valid value, nothing
    should be printed.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在`Log`中填写`TODO`，从上下文中正确提取日志级别。如果未分配日志级别或不是有效值，则不应打印任何内容。
- en: Wrapping Up
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to manage request metadata by using the context.
    You can now set timeouts, perform explicit cancellation, pass values through the
    context, and know when you should do each of these things. In the next chapter,
    you’re going to see Go’s built-in testing framework and learn how to use it to
    find bugs and diagnose performance problems in your programs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用上下文管理请求元数据。现在，您可以设置超时时间，执行显式取消操作，通过上下文传递值，并知道应该在何时执行这些操作。在下一章中，您将了解Go的内置测试框架，并学习如何使用它来查找程序中的错误并诊断性能问题。
