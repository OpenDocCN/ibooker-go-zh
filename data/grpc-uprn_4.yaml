- en: 'Chapter 4\. gRPC: Under the Hood'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '第四章\. gRPC: 深入解析'
- en: As you have learned in previous chapters, gRPC applications communicate using
    RPC over the network. As a gRPC application developer, you don’t need to worry
    about the underlying details of how RPC is implemented, what message-encoding
    techniques are used, and how RPC works over the network. You use the service definition
    to generate either server- or client-side code for the language of your choice.
    All the low-level communication details are implemented in the generated code
    and you get some high-level abstractions to work with. However, when building
    complex gRPC-based systems and running them in production, it’s vital to know
    how gRPC works under the hood.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的章节中所学到的，gRPC 应用程序使用 RPC 在网络上进行通信。作为 gRPC 应用程序开发者，您不需要担心 RPC 的具体实现细节，消息编码技术的使用方式，以及
    RPC 在网络上的工作原理。您可以使用服务定义为所选择的语言生成服务器端或客户端代码。所有的低级通信细节都在生成的代码中实现，并且您会获得一些高级抽象来进行操作。然而，在构建复杂的基于
    gRPC 的系统并将其投入生产时，了解 gRPC 在底层是如何工作的是非常重要的。
- en: In this chapter, we’ll explore how the gRPC communication flow is implemented,
    what encoding techniques are used, how gRPC uses the underlying network communication
    techniques, and so on. We’ll walk you through the message flow where the client
    invokes a given RPC, then discuss how it gets marshaled to a gRPC call that goes
    over the network, how the network communication protocol is used, how it is unmarshaled
    at the server, how the corresponding service and remote function is invoked, and
    so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 gRPC 通信流程的实现方式，使用的编码技术，gRPC 如何利用底层网络通信技术等。我们将为您讲解消息流程，客户端如何调用特定 RPC，然后讨论它如何编组为一个
    gRPC 调用并在网络上传输，以及服务器如何进行反编组，并调用相应的服务和远程函数等等。
- en: We’ll also look at how we use protocol buffers as the encoding technique and
    HTTP/2 as the communication protocol for gRPC. Finally, we’ll dive into the implementation
    architecture of gRPC and the language support stack built around it. Although
    the low-level details that we are going to discuss here may not be of much use
    in most gRPC applications, having a good understanding of the low-level communication
    details is quite helpful if you are designing a complex gRPC application or trying
    to debug existing applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看看如何使用协议缓冲作为编码技术和 HTTP/2 作为 gRPC 的通信协议。最后，我们将深入探讨 gRPC 的实现架构以及围绕其构建的语言支持堆栈。尽管我们将在此讨论的低级细节在大多数
    gRPC 应用程序中可能用处不大，但如果您正在设计复杂的 gRPC 应用程序或尝试调试现有应用程序，了解低级通信细节是非常有帮助的。
- en: RPC Flow
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC 流程
- en: In an RPC system, the server implements a set of functions that can be invoked
    remotely. The client application can generate a stub that provides abstractions
    for the same functions offered from the server so that the client application
    can directly call stub functions that invoke the remote functions of the server
    application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RPC 系统中，服务器实现一组可远程调用的函数。客户端应用程序可以生成一个提供这些函数抽象的存根，以便客户端应用程序可以直接调用存根函数，从而调用服务器应用程序的远程函数。
- en: Let’s look at the `ProductInfo` service that we discussed in [Chapter 2](ch02.html#ch_02)
    to understand how a remote procedure call works over the network. One of the functions
    that we implemented as part of our `ProductInfo` service is `getProduct`, where
    the client can retrieve product details by providing the product ID. [Figure 4-1](#how_remote_procedure_call_works_over_the_network)
    illustrates the actions involved when the client calls a remote function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在 [第二章](ch02.html#ch_02) 中讨论的 `ProductInfo` 服务，以了解远程过程调用在网络上的工作原理。作为
    `ProductInfo` 服务的一部分，我们实现的其中一个函数是 `getProduct`，客户端可以通过提供产品 ID 来检索产品详细信息。[图 4-1](#how_remote_procedure_call_works_over_the_network)
    描绘了客户端调用远程函数时涉及的操作。
- en: '![How remote procedure call works over the network](assets/grpc_0401.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![远程过程调用在网络上的工作原理](assets/grpc_0401.png)'
- en: Figure 4-1\. How a remote procedure call works over the network
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 远程过程调用在网络上的工作原理
- en: 'As shown in [Figure 4-1](#how_remote_procedure_call_works_over_the_network),
    we can identify the following key steps when the client calls the `getProduct`
    function in the generated stub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4-1](#how_remote_procedure_call_works_over_the_network) 所示，当客户端调用生成的存根中的
    `getProduct` 函数时，我们可以识别以下关键步骤：
- en: '![1](assets/1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![1](assets/1.png)'
- en: The client process calls the `getProduct` function in the generated stub.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端进程调用生成的存根中的 `getProduct` 函数。
- en: '![2](assets/2.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![2](assets/2.png)'
- en: The client stub creates an HTTP POST request with the encoded message. In gRPC,
    all requests are HTTP POST requests with content-type prefixed with `application/grpc`.
    The remote function (`/ProductInfo/getProduct`) that it invokes is sent as a separate
    HTTP header.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端存根创建一个带有编码消息的 HTTP POST 请求。在 gRPC 中，所有请求都是带有以 `application/grpc` 为前缀的内容类型的
    HTTP POST 请求。它调用的远程函数（`/ProductInfo/getProduct`）作为单独的 HTTP 头发送。
- en: '![3](assets/3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![3](assets/3.png)'
- en: The HTTP request message is sent across the network to the server machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求消息被发送到服务器机器上的网络。
- en: '![4](assets/4.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![4](assets/4.png)'
- en: When the message is received at the server, the server examines the message
    headers to see which service function needs to be called and hands over the message
    to the service stub.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息在服务器端接收时，服务器检查消息头以查看需要调用哪个服务函数，并将消息交给服务存根。
- en: '![5](assets/5.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![5](assets/5.png)'
- en: The service stub parses the message bytes into language-specific data structures.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 服务存根将消息字节解析为特定语言的数据结构。
- en: '![6](assets/6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![6](assets/6.png)'
- en: Then, using the parsed message, the service makes a local call to the `getProduct`
    function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用解析后的消息，服务调用本地的 `getProduct` 函数。
- en: '![7](assets/7.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![7](assets/7.png)'
- en: The response from the service function is encoded and sent back to the client.
    The response message follows the same procedure that we observed on the client
    side (response→encode→HTTP response on the wire); the message is unpacked and
    its value returned to the waiting client process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务函数的响应被编码并发送回客户端。响应消息遵循我们在客户端端观察到的相同过程（响应→编码→通过HTTP发送的响应）；消息被解包并其值返回给等待的客户端进程。
- en: These steps are quite similar to most RPC systems like CORBA, Java RMI, etc.
    The main difference between gRPC here is the way that it encodes the message,
    which we saw in [Figure 4-1](#how_remote_procedure_call_works_over_the_network).
    For encoding messages, gRPC uses protocol buffers. [Protocol buffers](https://oreil.ly/u9YJI)
    are a language-agnostic, platform-neutral, extensible mechanism for serializing
    structured data. You define how you want your data to be structured once, then
    you can use the specially generated source code to easily write and read your
    structured data to and from a variety of data streams.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤与大多数 RPC 系统（如 CORBA、Java RMI 等）非常相似。gRPC 在这里的主要区别是它编码消息的方式，正如我们在 [Figure 4-1](#how_remote_procedure_call_works_over_the_network)
    中看到的。对于消息的编码，gRPC 使用协议缓冲区。[协议缓冲区](https://oreil.ly/u9YJI) 是一种语言无关、平台中立、可扩展的机制，用于序列化结构化数据。您定义数据结构的方式一次，然后可以使用专门生成的源代码轻松地将结构化数据写入和从各种数据流中读取。
- en: Let’s dive into how gRPC uses protocol buffers to encode messages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 gRPC 如何使用协议缓冲区对消息进行编码。
- en: Message Encoding Using Protocol Buffers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议缓冲区对消息进行编码
- en: As we discussed in previous chapters, gRPC uses protocol buffers to write the
    service definition for gRPC services. Defining the service using protocol buffers
    includes defining remote methods in the service and defining messages we want
    to send across the network. For example, let’s take the `getProduct` method in
    the `ProductInfo` service. The `getProduct` method accepts a `ProductID` message
    as an input parameter and returns a `Product` message. We can define those input
    and output message structures using protocol buffers as shown in [Example 4-1](#EX4-1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的那样，gRPC 使用协议缓冲区为 gRPC 服务编写服务定义。使用协议缓冲区定义服务包括在服务中定义远程方法和定义我们想要通过网络发送的消息。例如，让我们看一下
    `ProductInfo` 服务中的 `getProduct` 方法。`getProduct` 方法接受 `ProductID` 消息作为输入参数，并返回
    `Product` 消息。我们可以像 [Example 4-1](#EX4-1) 中所示使用协议缓冲区定义这些输入和输出消息结构。
- en: Example 4-1\. Service definition of ProductInfo service with getProduct function
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-1\. 使用 `getProduct` 函数定义 `ProductInfo` 服务的服务定义
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As per [Example 4-1](#EX4-1), the `ProductID` message carries a unique product
    ID. So it has only one field with a string type. The `Product` message has the
    structure required to represent the product. It is important to have a message
    defined correctly, because how you define the message determines how the messages
    get encoded. We will discuss how message definitions are used when encoding messages
    later in this section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [Example 4-1](#EX4-1)，`ProductID` 消息携带唯一的产品 ID。因此它只有一个字符串类型的字段。`Product`
    消息具有表示产品所需的结构。正确定义消息非常重要，因为消息的定义方式决定了消息如何被编码。我们将在本节稍后讨论消息定义在编码消息时的使用方式。
- en: Now that we have the message definition, let’s look at how to encode the message
    and generate the equivalent byte content. Normally this is handled by the generated
    source code for the message definition. All the supported languages have their
    own compilers to generate source code. As an application developer, you need to
    pass the message definition and generate source code to read and write the message.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了消息定义，让我们看看如何对消息进行编码并生成等效的字节内容。通常这是由消息定义的生成源代码处理的。所有支持的语言都有自己的编译器来生成源代码。作为应用开发者，您需要传递消息定义并生成源代码以读取和写入消息。
- en: 'Let’s say we need to get product details for product ID `15`; we create a message
    object with value equal to 15 and pass it to the `getProduct` function. The following
    code snippet shows how to create a `ProductID` message with value equal to `15`
    and pass it to the `getProduct` function to retrieve product details:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要获取产品ID为`15`的产品详细信息；我们创建一个值为15的消息对象，并将其传递给`getProduct`函数。以下代码片段展示了如何创建一个`ProductID`消息，其值为`15`，并将其传递给`getProduct`函数以检索产品详细信息：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code snippet is written in Go. Here, the `ProductID` message definition
    is in the generated source code. We create an instance of `ProductID` and set
    the value as `15`. Similarly in the Java language, we use generated methods to
    create a `ProductID` instance as shown in the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段是用Go语言编写的。在这里，`ProductID`消息定义在生成的源代码中。我们创建一个`ProductID`实例，并将值设置为`15`。在Java语言中，我们使用生成的方法创建`ProductID`实例，如下所示的代码片段：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `ProductID` message structure that follows, there is one field called
    `value` with the field index 1\. When we create a message instance with `value`
    equal to `15`, the equivalent byte content consists of a field identifier for
    the `value` field followed by its encoded value. This field identifier is also
    known as a *tag*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的`ProductID`消息结构中，有一个名为`value`的字段，其字段索引为1。当我们创建一个带有`value`等于`15`的消息实例时，等效的字节内容包含了`value`字段的字段标识符，后跟其编码值。此字段标识符也称为*标签*：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This byte content structure looks like [Figure 4-2](#protocol_buffer_encoded_byte_stream),
    where each message field consists of a field identifier followed by its encoded
    value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字节内容结构类似于[图 4-2](#protocol_buffer_encoded_byte_stream)，其中每个消息字段都包含字段标识符和其编码值。
- en: '![Protocol buffer encoded byte stream](assets/grpc_0402.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![协议缓冲编码字节流](assets/grpc_0402.png)'
- en: Figure 4-2\. Protocol buffer encoded byte stream
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 协议缓冲编码字节流
- en: 'This tag builds up two values: the field index and the wire type. The field
    index is the unique number we assigned to each message field when defining the
    message in the proto file. The wire type is based on the field type, which is
    the type of data that can enter the field. This wire type provides information
    to find the length of the value. [Table 4-1](#available_wire_types_and_corresponding_field_types)
    shows how wire types are mapped to field types. This is the predefined mapping
    of wire types and field types. You can refer to the [official protocol buffers
    encoding document](https://oreil.ly/xeLBr) to get more insight into the mapping.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记构建了两个值：字段索引和线路类型。字段索引是我们在proto文件中定义消息时分配给每个消息字段的唯一编号。线路类型基于字段类型，即可以输入字段的数据类型。此线路类型提供信息以查找值的长度。[表 4-1](#available_wire_types_and_corresponding_field_types)展示了线路类型如何映射到字段类型。这是线路类型和字段类型的预定义映射。您可以参考[官方协议缓冲编码文档](https://oreil.ly/xeLBr)以获取更多关于映射的洞察。
- en: Table 4-1\. Available wire types and corresponding field types
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 可用的线路类型及其对应的字段类型
- en: '| Wire type | Category | Field types |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 线路类型 | 类别 | 字段类型 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | Varint | int32, int64, uint32, uint64, sint32, sint64, bool, enum |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 变长整数 | int32、int64、uint32、uint64、sint32、sint64、bool、enum |'
- en: '| 1 | 64-bit | fixed64, sfixed64, double |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | fixed64、sfixed64、double |'
- en: '| 2 | Length-delimited | string, bytes, embedded messages, packed repeated
    fields |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 长度限定 | string、bytes、嵌入式消息、打包的重复字段 |'
- en: '| 3 | Start group | groups (deprecated) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 开始组 | 组（已弃用） |'
- en: '| 4 | End group | groups (deprecated) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 结束组 | 组（已弃用） |'
- en: '| 5 | 32-bit | fixed32, sfixed32, float |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32位 | fixed32、sfixed32、float |'
- en: 'Once we know the field index and wire type of a certain field, we can determine
    the tag value of the field using the following equation. Here we left shift the
    binary representation of the field index by three digits and perform a bitwise
    union with the binary representation of the wire type value:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道某个字段的字段索引和线类型，我们就可以使用以下方程式确定字段的标签值。在此处，我们将字段索引的二进制表示左移三位，并与线类型值的二进制表示进行按位或运算：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 4-3](#structure_of_the_tag_value) shows how field index and wire type
    are arranged in a tag value.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#structure_of_the_tag_value) 展示了字段索引和线类型在标签值中的排列方式。'
- en: '![Structure of the tag value](assets/grpc_0403.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![标签值的结构](assets/grpc_0403.png)'
- en: Figure 4-3\. Structure of the tag value
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 标签值的结构
- en: 'Let’s try to understand this terminology using the example that we used earlier.
    The `ProductID` message has one string field with field index equal to 1 and the
    wire type of string is 2\. When we convert them to binary representation, the
    field index looks like 00000001 and the wire type looks like 00000010\. When we
    put those values into the preceding equation, the tag value 10 is derived as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用先前使用的示例来理解这些术语。`ProductID` 消息具有一个字符串字段，字段索引为 1，字符串的线类型为 2\. 当我们将它们转换为二进制表示时，字段索引看起来像
    00000001，线类型看起来像 00000010\. 当我们将这些值放入前面的方程式中时，标签值 10 派生如下：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next step is to encode the value of the message field. Different encoding
    techniques are used by protocol buffers to encode the different types of data.
    For example, if it is a string value, the protocol buffer uses UTF-8 to encode
    the value and if it is an integer value with the int32 field type, it uses an
    encoding technique called varints. We will discuss different encoding techniques
    and when those techniques are applied in the next section in detail. For now,
    we will discuss how to encode a string value to complete the example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对消息字段的值进行编码。协议缓冲使用不同的编码技术来编码不同类型的数据。例如，如果它是字符串值，则协议缓冲使用 UTF-8 对该值进行编码；如果它是具有
    int32 字段类型的整数值，则使用一种称为 varints 的编码技术。我们将在下一节详细讨论不同的编码技术以及何时应用这些技术。现在，我们将讨论如何编码字符串值以完成示例。
- en: In protocol buffers encoding, string values are encoded using UTF-8 encoding
    technique. UTF (Unicode Transformation Format) uses 8-bit blocks to represent
    a character. It is a variable-length character encoding technique that is also
    a preferred encoding technique in web pages and emails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲编码中，字符串值使用 UTF-8 编码技术进行编码。UTF-8（Unicode 转换格式）使用 8 位块来表示一个字符。它是一种变长字符编码技术，也是网页和电子邮件中首选的编码技术。
- en: 'In our example, the value of the `value` field in the `ProductID` message is
    15 and the UTF-8 encoded value of `15` is `\x31 \x35`. In UTF-8 encoding, the
    encoded value length is not fixed. In other words, the number of 8-bit blocks
    required to represent the encoded value is not fixed. It varies based upon the
    value of the message field. In our example, it is two blocks. So we need to pass
    the encoded value length (number of blocks the encoded value spans) before the
    encoded value. The hexadecimal representation of the encoded value of `15` will
    look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`ProductID` 消息中 `value` 字段的值为 15，并且 `15` 的 UTF-8 编码值是 `\x31 \x35`。在
    UTF-8 编码中，编码值的长度是不固定的。换句话说，表示编码值所需的 8 位块数是不固定的。它取决于消息字段的值。在我们的示例中，它是两个块。因此，在编码值之前，我们需要传递编码值的长度（编码值跨越的块数）。`15`
    的十六进制表示如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The two righthand bytes here are the UTF-8 encoded value of `15`. Value 0x02
    represents the length of the encoded string value in 8-bit blocks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个右手字节是 `15` 的 UTF-8 编码值。值 `0x02` 表示编码的字符串值的长度，以 8 位块为单位。
- en: When a message is encoded, its tags and values are concatenated into a byte
    stream. [Figure 4-2](#protocol_buffer_encoded_byte_stream) illustrates how field
    values are arranged into a byte stream when a message has multiple fields. The
    end of the stream is marked by sending a tag valued 0.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息被编码时，它的标签和值被连接成字节流。[图 4-2](#protocol_buffer_encoded_byte_stream) 说明了当消息具有多个字段时，如何将字段值排列成字节流。流的结尾通过发送标签值为
    0 来标记。
- en: We have now completed encoding a simple message with a string field using protocol
    buffers. The protocol buffers support various field types and some field types
    have different encoding mechanisms. Let’s quickly go through the encoding techniques
    used by protocol buffers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用协议缓冲完成了对带有字符串字段的简单消息的编码。协议缓冲支持各种字段类型，并且一些字段类型具有不同的编码机制。让我们快速浏览一下协议缓冲使用的编码技术。
- en: Encoding Techniques
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码技术
- en: There are many encoding techniques supported by protocol buffers. Different
    encoding techniques are applied based on the type of data. For example, string
    values are encoded using UTF-8 character encoding, whereas int32 values are encoded
    using a technique called varints. Having knowledge about how data is encoded in
    each data type is important when designing the message definition because it allows
    us to set the most appropriate data type for each message field so that the messages
    are efficiently encoded at runtime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲支持许多编码技术。不同的编码技术根据数据类型应用不同的方法。例如，字符串值使用UTF-8字符编码进行编码，而int32值使用称为Varints的技术进行编码。了解每种数据类型在编码时如何处理数据是设计消息定义时非常重要的，因为这样可以为每个消息字段设置最合适的数据类型，从而在运行时高效地编码消息。
- en: In protocol buffers, supported field types are categorized into different groups
    and each group uses a different technique to encode the value. Listed in the next
    section are a few commonly used encoding techniques in protocol buffers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲中，支持的字段类型被分类为不同的组，并且每个组使用不同的技术来编码值。在下一节中列出了协议缓冲中一些常用的编码技术。
- en: Varints
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变长整数
- en: Varints (variable length integers) are a method of serializing integers using
    one or more bytes. They’re based on the idea that most numbers are not uniformly
    distributed. So the number of bytes allocated for each value is not fixed. It
    depends on the value. As per [Table 4-1](#available_wire_types_and_corresponding_field_types),
    field types like int32, int64, uint32, uint64, sint32, sint64, bool, and enum
    are grouped into varints and encoded as varints. [Table 4-2](#fieldtypes_varints)
    shows what field types are categorized under varints, and what each type is used
    for.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变长整数（Varints）是一种使用一个或多个字节序列化整数的方法。它们基于大多数数字不是均匀分布的观念。因此，为每个值分配的字节数并不固定，而是取决于值本身。根据[表 4-1](#available_wire_types_and_corresponding_field_types)，如int32、int64、uint32、uint64、sint32、sint64、bool和enum等字段类型被分组为Varints并编码为Varints。[表 4-2](#fieldtypes_varints)显示了哪些字段类型被归类为Varints，并说明了每种类型的用途。
- en: Table 4-2\. Field type definitions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2. 字段类型定义
- en: '| Field type | Definition |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 字段类型 | 定义 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int32` | A value type that represents signed integers with values that range
    from negative 2,147,483,648 to positive 2,147,483,647\. Note this type is inefficient
    for encoding negative numbers. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 一个表示带有值范围从负2,147,483,648到正2,147,483,647的有符号整数的值类型。注意，这种类型不适合编码负数。
    |'
- en: '| `int64` | A value type that represents signed integers with values that range
    from negative 9,223,372,036,854,775,808 to positive 9,223,372,036,854,775,807\.
    Note this type is inefficient for encoding negative numbers. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 一个表示带有值范围从负9,223,372,036,854,775,808到正9,223,372,036,854,775,807的有符号整数的值类型。注意，这种类型不适合编码负数。
    |'
- en: '| `uint32` | A value type that represents unsigned integers with values that
    range from 0 to 4,294,967,295. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 一个表示无符号整数的值类型，其取值范围从0到4,294,967,295。 |'
- en: '| `uint64` | A value type that represents unsigned integers with values that
    range from 0 to 18,446,744,073,709,551,615. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 一个表示无符号整数的值类型，其取值范围从0到18,446,744,073,709,551,615。 |'
- en: '| `sint32` | A value type that represents signed integers with values that
    range from negative 2,147,483,648 to positive 2,147,483,647\. This more efficiently
    encodes negative numbers than regular int32s. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `sint32` | 一个表示带有值范围从负2,147,483,648到正2,147,483,647的有符号整数的值类型。相比普通的int32，这种类型更有效地编码负数。
    |'
- en: '| `sint64` | A value type that represents signed integers with values that
    range from negative 9,223,372,036,854,775,808 to positive 9,223,372,036,854,775,807\.
    This more efficiently encodes negative numbers than regular int64s. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `sint64` | 一个表示带有值范围从负9,223,372,036,854,775,808到正9,223,372,036,854,775,807的有符号整数的值类型。相比普通的int64，这种类型更有效地编码负数。
    |'
- en: '| `bool` | A value type that represents two possible values, normally denoted
    as true or false. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 一个表示两种可能值的值类型，通常表示为true或false。 |'
- en: '| `enum` | A value type that represents a set of named values. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | 一个表示一组命名值的值类型。 |'
- en: In varints, each byte except the last byte has the most significant bit (MSB)
    set to indicate that there are further bytes to come. The lower 7 bits of each
    byte are used to store the two’s complement representation of the number. Also,
    the least significant group comes first, which means that we should add a continuation
    bit to the low-order group.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在变长整数中，除了最后一个字节外，每个字节的最高位（MSB）都被设置为指示后续字节的存在。每个字节的低7位用于存储该数字的二进制补码表示。此外，最不重要的组先出现，这意味着我们应在低阶组中添加一个继续位。
- en: Signed integers
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有符号整数
- en: Signed integers are types that represent both positive and negative integer
    values. Field types like sint32 and sint64 are considered signed integers. For
    signed types, zigzag encoding is used to convert signed integers to unsigned ones.
    Then unsigned integers are encoded using varints encoding as mentioned previously.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 签名整数是表示正负整数值的类型。像sint32和sint64这样的字段类型被视为有符号整数。对于有符号类型，使用锯齿编码将有符号整数转换为无符号整数。然后使用先前提到的变长整数编码无符号整数。
- en: In zigzag encoding, signed integers are mapped to unsigned integers in a zigzag
    way through negative and positive integers. [Table 4-3](#the_zig_zag_encoding_used_in_signed_integers)
    shows how mapping works in zigzag encoding.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在锯齿编码中，有符号整数通过负整数和正整数以锯齿方式映射为无符号整数。[表 4-3](#the_zig_zag_encoding_used_in_signed_integers)显示了锯齿编码中映射工作的方式。
- en: Table 4-3\. The zigzag encoding used in signed integers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3。用于有符号整数的锯齿编码
- en: '| Original value | Mapped value |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 原始值 | 映射值 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| -1 | 1 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 1 |'
- en: '| 1 | 2 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 |'
- en: '| -2 | 3 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| -2 | 3 |'
- en: '| 2 | 4 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 |'
- en: As shown in [Table 4-3](#the_zig_zag_encoding_used_in_signed_integers), value
    zero is mapped to the original value of zero and other values are mapped to positive
    numbers in a zigzag way. The negative original values are mapped to odd positive
    numbers and positive original values are mapped to even positive numbers. After
    zigzag encoding, we get a positive number irrespective of the sign of the original
    value. Once we have a positive number, we perform varints to encode the value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表 4-3](#the_zig_zag_encoding_used_in_signed_integers)所示，零值映射到原始零值，其他值以锯齿方式映射为正数。负的原始值映射为奇数正数，正的原始值映射为偶数正数。经过锯齿编码后，我们获得一个与原始值的符号无关的正数。一旦我们有了一个正数，我们执行变长整数编码来编码该值。
- en: For negative integer values, it is recommended to use signed integer types like
    sint32 and sint64 because if we use a regular type such as int32 or int64, negative
    values are converted to binary using varints encoding. Varints encoding for a
    negative integer value needs more bytes to represent an equivalent binary value
    than a positive integer value. So the efficient way of encoding negative value
    is to convert the negative value to a positive number and then encode the positive
    value. In signed integer types like sint32, the negative values are first converted
    to positive values using zigzag encoding and then encoded using varints.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负整数值，建议使用有符号整数类型，如sint32和sint64，因为如果使用普通类型如int32或int64，负值将使用变长整数编码转换为二进制值。变长整数编码负整数值需要更多字节来表示等效的二进制值，比正整数值更多。因此，编码负值的有效方式是将负值转换为正数，然后编码正数。在像sint32这样的有符号整数类型中，负值首先使用锯齿编码转换为正值，然后使用变长整数编码。
- en: Nonvarint numbers
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非变长整数
- en: Nonvarint types are just the opposite of the varint type. They allocate a fixed
    number of bytes irrespective of the actual value. Protocol buffers use two wire
    types that categorize as nonvarint numbers. One is for the 64-bit data types like
    fixed64, sfixed64, and double. The other is for 32-bit data types like fixed32,
    sfixed32, and float.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 非变长整数类型正好与变长整数类型相反。它们分配固定数量的字节，不考虑实际值。协议缓冲区使用两种线路类型来分类为非变长整数。一种是用于64位数据类型，如fixed64、sfixed64和double。另一种是用于32位数据类型，如fixed32、sfixed32和float。
- en: String type
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串类型
- en: In protocol buffers, the string type belongs to the length-delimited wire type,
    which means that the value is a varint-encoded length followed by the specified
    number of bytes of data. String values are encoded using UTF-8 character encoding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲区中，字符串类型属于长度限定的线路类型，这意味着值是变长整数编码的长度，后跟指定数量的数据字节。字符串值使用UTF-8字符编码进行编码。
- en: We just summarized the techniques used to encode commonly used data types. You
    can find a detailed explanation about protocol buffer encoding on [the official
    page](https://oreil.ly/hH_gL).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚总结了编码常用数据类型的技术。你可以在 [官方页面](https://oreil.ly/hH_gL) 上找到有关协议缓冲区编码的详细说明。
- en: Now that we have encoded the message using protocol buffers, the next step is
    to frame the message before sending it to the server over the network.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用协议缓冲区对消息进行了编码，下一步是在将其发送到服务器之前对消息进行帧化。
- en: Length-Prefixed Message Framing
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长度前缀消息帧
- en: In common terms, the message-framing approach constructs information and communication
    so that the intended audience can easily extract the information. The same thing
    applies to gRPC communication as well. Once we have the encoded data to send to
    the other party, we need to package the data in a way that other parties can easily
    extract the information. In order to package the message to send over the network,
    gRPC uses a message-framing technique called length-prefix framing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常术语中，消息帧方法构建信息和通信，以便预期的受众可以轻松提取信息。gRPC 通信也适用相同原理。一旦我们有编码后的数据要发送给对方，我们需要以其他方便提取信息的方式打包数据。为了将消息打包以便在网络上传输，gRPC
    使用一种称为长度前缀帧的消息帧技术。
- en: Length-prefix is a message-framing approach that writes the size of each message
    before writing the message itself. As you can see in [Figure 4-4](#how_grpc_message_framed_using_length_prefix_framing),
    before the encoded binary message there are 4 bytes allocated to specify the size
    of the message. In gRPC communication, 4 additional bytes are allocated for each
    message to set its size. The size of the message is a finite number, and allocating
    4 bytes to represent the message size means gRPC communication can handle all
    messages up to 4 GB in size.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀是一种消息帧方法，它在写入消息本身之前写入每个消息的大小。正如你可以在 [图 4-4](#how_grpc_message_framed_using_length_prefix_framing)
    中看到的那样，在编码的二进制消息之前，有4个字节用于指定消息的大小。在 gRPC 通信中，每个消息额外分配了4个字节来设置其大小。消息的大小是一个有限的数字，分配4个字节来表示消息大小意味着
    gRPC 通信可以处理大小达到4 GB的所有消息。
- en: '![How a gRPC message is encoded and framed](assets/grpc_0404.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![gRPC 消息编码和帧](assets/grpc_0404.png)'
- en: Figure 4-4\. How a gRPC message frame uses length-prefix framing
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. gRPC 消息帧使用长度前缀帧的示意图
- en: As illustrated in [Figure 4-4](#how_grpc_message_framed_using_length_prefix_framing),
    when the message is encoded using protocol buffers, we get the message in binary
    format. Then we calculate the size of the binary content and add it before the
    binary content in big-endian format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4-4](#how_grpc_message_framed_using_length_prefix_framing) 所示，当使用协议缓冲区对消息进行编码时，我们得到二进制格式的消息。然后，我们计算二进制内容的大小，并以大端格式将其添加到二进制内容之前。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Big-endian is a way of ordering binary data in the system or message. In big-endian
    format, the most significant value (the largest powers of two) in the sequence
    is stored at the lowest storage address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大端法是一种在系统或消息中对二进制数据排序的方式。在大端格式中，序列中最重要的值（最大的二的幂）存储在最低的存储地址。
- en: In addition to the message size, the frame also has a 1-byte unsigned integer
    to indicate whether the data is compressed or not. A Compressed-Flag value of
    1 indicates that the binary data is compressed using the mechanism declared in
    the Message-Encoding header, which is one of the headers declared in HTTP transport.
    The value 0 indicates that no encoding of message bytes has occurred. We will
    discuss HTTP headers supported in gRPC communication in detail in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了消息大小之外，帧还有一个1字节的无符号整数，用于指示数据是否已压缩。压缩标志值为1表示使用消息编码头中声明的机制对二进制数据进行了压缩，该头是在 HTTP
    传输中声明的头之一。值0表示未对消息字节进行编码。我们将在下一节详细讨论 gRPC 通信中支持的 HTTP 头。
- en: So now the message is framed and it’s ready to be sent over the network to the
    recipient. For a client request message, the recipient is the server. For a response
    message, the recipient is the client. On the recipient side, once a message is
    received, it first needs to read the first byte to check whether the message is
    compressed or not. Then the recipient reads the next four bytes to get the size
    of the encoded binary message. Once the size is known, the exact length of bytes
    can be read from the stream. For unary/simple messages, we will have only one
    length-prefixed message, and for streaming messages, we will have multiple length-prefixed
    messages to process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在消息已经被分帧并准备好通过网络发送给接收者。对于客户端请求消息，接收者是服务器。对于响应消息，接收者是客户端。在接收方，一旦接收到消息，首先需要读取第一个字节来检查消息是否已压缩。然后，接收者读取接下来的四个字节以获取编码二进制消息的大小。一旦知道大小，就可以从流中读取确切长度的字节。对于一元/简单消息，我们只有一个长度前缀的消息，而对于流式消息，我们将有多个长度前缀的消息需要处理。
- en: 'Now you have a good understanding of how messages are prepared to deliver to
    the recipient over the network. In the next section, we are going to discuss how
    gRPC sends those length-prefixed messages over the network. Currently, the gRPC
    core supports three transport implementations: HTTP/2, [Cronet](https://oreil.ly/D0laq),
    and [in-process](https://oreil.ly/lRgXF). Among them, the most common transport
    for sending messages is HTTP/2\. Let’s discuss how gRPC utilizes the HTTP/2 network
    to send messages efficiently.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经很好地理解了如何准备消息并通过网络发送到接收者。在下一节中，我们将讨论 gRPC 如何通过网络发送这些长度前缀的消息。目前，gRPC 核心支持三种传输实现方式：HTTP/2、[Cronet](https://oreil.ly/D0laq)
    和 [in-process](https://oreil.ly/lRgXF)。其中，用于发送消息的最常见的传输方式是 HTTP/2。让我们讨论 gRPC 如何利用
    HTTP/2 网络高效地发送消息。
- en: gRPC over HTTP/2
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 在 HTTP/2 上
- en: HTTP/2 is the second major version of the internet protocol HTTP. It was introduced
    to overcome some of the issues encountered with security, speed, etc. in the previous
    version (HTTP/1.1). HTTP/2 supports all of the core features of HTTP/1.1 but in
    a more efficient way. So applications written in HTTP/2 are faster, simpler, and
    more robust.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 是互联网协议 HTTP 的第二个主要版本。它被引入以解决之前版本（HTTP/1.1）中遇到的一些安全性、速度等问题。HTTP/2 支持 HTTP/1.1
    的所有核心功能，但以更高效的方式实现。因此，使用 HTTP/2 编写的应用程序更快、更简单、更健壮。
- en: gRPC uses HTTP/2 as its transport protocol to send messages over the network.
    This is one of the reasons why gRPC is a high-performance RPC framework. Let’s
    explore the relationship between gRPC and HTTP/2.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 HTTP/2 作为其传输协议，在网络上发送消息。这是 gRPC 成为高性能 RPC 框架的原因之一。让我们探讨 gRPC 和 HTTP/2
    之间的关系。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In HTTP/2, all communication between a client and server is performed over
    a single TCP connection that can carry any number of bidirectional flows of bytes.
    To understand the HTTP/2 process, you should be familiar with the following important
    terminology:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP/2 中，客户端和服务器之间的所有通信都通过单个 TCP 连接进行，该连接可以承载任意数量的双向字节流。要理解 HTTP/2 的过程，您应该熟悉以下重要术语：
- en: '*Stream:* A bidirectional flow of bytes within an established connection. A
    stream may carry one or more messages.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流（Stream）：* 在已建立的连接中的双向字节流。一个流可以承载一个或多个消息。'
- en: '*Frame:* The smallest unit of communication in HTTP/2\. Each frame contains
    a frame header, which at a minimum identifies the stream to which the frame belongs.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*帧（Frame）：* HTTP/2 中通信的最小单位。每个帧包含一个帧头，至少标识帧所属的流。'
- en: '*Message:* A complete sequence of frames that map to a logical HTTP message
    that consists of one or more frames. This allows the messages to be multiplexed,
    by allowing the client and server to break down the message into independent frames,
    interleave them, and then reassemble them on the other side.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息（Message）：* 映射到逻辑 HTTP 消息的完整帧序列，由一个或多个帧组成。这使得消息可以进行多路复用，客户端和服务器可以将消息分解为独立的帧、交错它们，然后在另一端重新组装它们。'
- en: As you can see in [Figure 4-5](#how_grpc_semantics_relates_to_http2), the gRPC
    channel represents a connection to an endpoint, which is an HTTP/2 connection.
    When the client application creates a gRPC channel, behind the scenes it creates
    an HTTP/2 connection with the server. Once the channel is created we can reuse
    it to send multiple remote calls to the server. These remote calls are mapped
    to streams in HTTP/2\. Messages that are sent in the remote call are sent as HTTP/2
    frames. A frame may carry one gRPC length-prefixed message, or if a gRPC message
    is quite large it might span multiple data frames.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 [Figure 4-5](#how_grpc_semantics_relates_to_http2) 中所见，gRPC 通道代表与端点的连接，这是一个
    HTTP/2 连接。当客户端应用程序创建 gRPC 通道时，它在后台与服务器创建了一个 HTTP/2 连接。一旦通道创建完成，我们可以重用它来向服务器发送多个远程调用。这些远程调用在
    HTTP/2 中被映射为流。发送到远程调用的消息作为 HTTP/2 帧发送。一个帧可以携带一个 gRPC 长度前缀消息，或者如果 gRPC 消息非常大，它可能跨越多个数据帧。
- en: '![How gRPC semantics relate to HTTP/2](assets/grpc_0405.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![gRPC 语义与 HTTP/2 的关系](assets/grpc_0405.png)'
- en: Figure 4-5\. How gRPC semantics relate to HTTP/2
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. gRPC 语义与 HTTP/2 的关系
- en: In the previous section, we discussed how to frame our message to a length-prefixed
    message. When we send them over the network as a request or response message,
    we need to send additional headers along with the message. Let’s discuss how to
    structure request/response messages and which headers need to pass for each message
    in the next sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了如何将消息框架化为长度前缀消息。当我们将它们作为请求或响应消息通过网络发送时，我们需要发送附加的头部以及消息。让我们在接下来的部分讨论如何构造请求/响应消息以及每个消息需要传递哪些头部。
- en: Request Message
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求消息
- en: 'The request message is the one that initiates the remote call. In gRPC, the
    request message is always triggered by the client application and it consists
    of three main components: request headers, the length-prefixed message, and the
    end of stream flag as shown in [Figure 4-6](#sequence_of_message_elements_in_request_message1).
    The remote call is initiated once the client sends request headers. Then, length-prefixed
    messages are sent in the call. Finally, the EOS (end of stream) flag is sent to
    notify the recipient that we finished sending the request message.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请求消息是发起远程调用的消息。在 gRPC 中，请求消息始终由客户端应用程序触发，它由三个主要组件组成：请求头，长度前缀消息以及流结束标志，如图 [Figure 4-6](#sequence_of_message_elements_in_request_message1)
    所示。一旦客户端发送请求头，远程调用就被初始化。然后，在调用中发送长度前缀消息。最后，发送 EOS（流结束）标志通知接收方，我们完成了请求消息的发送。
- en: '![Sequence of message elements in request message](assets/grpc_0406.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![请求消息中消息元素的顺序](assets/grpc_0406.png)'
- en: Figure 4-6\. Sequence of message elements in request message
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 请求消息中消息元素的顺序
- en: 'Let’s use the same `getProduct` function in the `ProductInfo` service to explain
    how the request message is sent in HTTP/2 frames. When we call the `getProduct`
    function, the client initiates a call by sending request headers as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `ProductInfo` 服务中相同的 `getProduct` 函数来解释如何在 HTTP/2 帧中发送请求消息。当我们调用 `getProduct`
    函数时，客户端通过发送如下的请求头来发起调用：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO1-1)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO1-1)'
- en: Defines the HTTP method. For gRPC, the `:method` header is always `POST`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 HTTP 方法。对于 gRPC，`:method` 头部始终为 `POST`。
- en: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO1-2)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO1-2)'
- en: Defines the HTTP scheme. If TLS (Transport Level Security) is enabled, the scheme
    is set to “https,” otherwise it is “http.”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 HTTP 方案。如果启用了传输层安全（TLS），则方案设置为 “https”，否则为 “http”。
- en: '[![3](assets/3.png)](#co_grpc__under_the_hood_CO1-3)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_grpc__under_the_hood_CO1-3)'
- en: Defines the endpoint path. For gRPC, this value is constructed as “/” {service
    name} “/” {method name}.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 定义端点路径。对于 gRPC，该值构造为 “/” {服务名称} “/” {方法名称}。
- en: '[![4](assets/4.png)](#co_grpc__under_the_hood_CO1-4)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_grpc__under_the_hood_CO1-4)'
- en: Defines the virtual hostname of the target URI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定义目标 URI 的虚拟主机名。
- en: '[![5](assets/5.png)](#co_grpc__under_the_hood_CO1-5)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_grpc__under_the_hood_CO1-5)'
- en: Defines detection of incompatible proxies. For gRPC, the value must be “trailers.”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不兼容代理的检测。对于 gRPC，该值必须为 “trailers”。
- en: '[![6](assets/6.png)](#co_grpc__under_the_hood_CO1-6)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_grpc__under_the_hood_CO1-6)'
- en: Defines call timeout. If not specified, the server should assume an infinite
    timeout.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 定义调用超时时间。如果未指定，服务器应假定超时时间为无限。
- en: '[![7](assets/7.png)](#co_grpc__under_the_hood_CO1-7)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_grpc__under_the_hood_CO1-7)'
- en: Defines the content-type. For gRPC, the content-type should begin with `application/grpc`.
    If not, gRPC servers will respond with an HTTP status of 415 (Unsupported Media
    Type).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义内容类型。对于 gRPC，内容类型应以`application/grpc`开头。否则，gRPC 服务器将以 HTTP 415（不支持的媒体类型）状态响应。
- en: '[![8](assets/8.png)](#co_grpc__under_the_hood_CO1-8)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_grpc__under_the_hood_CO1-8)'
- en: Defines the message compression type. Possible values are `identity`, `gzip`,
    `deflate`, `snappy`, and `{custom}`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定义消息压缩类型。可能的值为`identity`、`gzip`、`deflate`、`snappy`和`{custom}`。
- en: '[![9](assets/9.png)](#co_grpc__under_the_hood_CO1-9)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_grpc__under_the_hood_CO1-9)'
- en: This is optional metadata. `authorization` metadata is used to access the secure
    endpoint.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可选的元数据。`authorization`元数据用于访问安全端点。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some other notes on this example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此示例的一些其他注意事项：
- en: Header names starting with “:” are called reserved headers and HTTP/2 requires
    reserved headers to appear before other headers.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以“:”开头的标头称为保留标头，HTTP/2 要求保留标头出现在其他标头之前。
- en: 'Headers passed in gRPC communication are categorized into two types: call-definition
    headers and custom metadata.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 通信中传递的标头分为两种类型：调用定义标头和自定义元数据。
- en: Call-definition headers are predefined headers supported by HTTP/2\. Those headers
    should be sent before custom metadata.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用定义标头是 HTTP/2 支持的预定义标头。这些标头应在自定义元数据之前发送。
- en: Custom metadata is an arbitrary set of key-value pairs defined by the application
    layer. When you are defining custom metadata, you need to make sure not to use
    a header name starting with `grpc-`. This is listed as a reserved name in the
    gRPC core.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元数据是应用层定义的一组任意键值对。在定义自定义元数据时，请确保不使用以`grpc-`开头的标头名称，因为这在 gRPC 核心中列为保留名称。
- en: 'Once the client initiates the call with the server, the client sends length-prefixed
    messages as HTTP/2 data frames. If the length-prefixed message doesn’t fit one
    data frame, it can span to multiple data frames. The end of the request message
    is indicated by adding an `END_STREAM` flag on the last `DATA` frame. When no
    data remains to be sent but we need to close the request stream, the implementation
    must send an empty data frame with the `END_STREAM` flag:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端与服务器发起调用，客户端将作为 HTTP/2 数据帧发送长度前缀消息。如果长度前缀消息不适合一个数据帧，则可以跨多个数据帧。请求消息的结束通过在最后一个`DATA`帧上添加`END_STREAM`标志来指示。当没有剩余数据需要发送但需要关闭请求流时，实现必须发送带有`END_STREAM`标志的空数据帧：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just an overview of the structure of the gRPC request message. You can
    find more details in [the official gRPC GitHub repository](https://oreil.ly/VIhYs).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 gRPC 请求消息结构的概述。您可以在[官方 gRPC GitHub 存储库](https://oreil.ly/VIhYs)找到更多细节。
- en: Similar to the request message, the response message also has its own structure.
    Let’s look at the structure of response messages and the related headers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求消息类似，响应消息也有其自己的结构。让我们看看响应消息及其相关标头的结构。
- en: Response Message
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应消息
- en: 'The response message is generated by the server in response to the client’s
    request. Similar to the request message, in most cases the response message also
    consists of three main components: response headers, length-prefixed messages,
    and trailers. When there is no length-prefixed message to send as a response to
    the client, the response message consists only of headers and trailers as shown
    in [Figure 4-7](#sequence_of_message_elements_in_request_message).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应消息是响应客户端请求生成的。与请求消息类似，在大多数情况下，响应消息也由三个主要组件组成：响应标头、长度前缀消息和尾部。当没有长度前缀消息作为响应发送给客户端时，响应消息仅由标头和尾部组成，如[图
    4-7](#sequence_of_message_elements_in_request_message)所示。
- en: '![Sequence of message elements in a response message](assets/grpc_0407.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![响应消息中消息元素的顺序](assets/grpc_0407.png)'
- en: Figure 4-7\. Sequence of message elements in a response message
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 响应消息中消息元素的顺序
- en: 'Let’s look at the same example to explain the HTTP/2 framing sequence of the
    response message. When the server sends a response to the client, it first sends
    response headers as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以同样的示例来解释响应消息的 HTTP/2 帧序列。当服务器向客户端发送响应时，首先发送响应标头，如下所示：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO2-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO2-1)'
- en: Indicates the status of the HTTP request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指示 HTTP 请求的状态。
- en: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO2-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO2-2)'
- en: Defines the message compression type. Possible values include `identity`, `gzip`,
    `deflate`, `snappy`, and `{custom}`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 定义消息压缩类型。可能的值包括`identity`、`gzip`、`deflate`、`snappy`和`{custom}`。
- en: '[![3](assets/3.png)](#co_grpc__under_the_hood_CO2-3)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_grpc__under_the_hood_CO2-3)'
- en: Defines the `content-type`. For gRPC, the `content-type` should begin with `application/grpc`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `content-type`。对于 gRPC，`content-type` 应以 `application/grpc` 开头。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to the request headers, custom metadata that contains an arbitrary set
    of key-value pairs defined by the application layer can be set in the response
    headers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与请求头类似，响应头中可以设置包含应用层定义的任意键值对的自定义元数据。
- en: 'Once the server sends response headers, length-prefixed messages are sent as
    HTTP/2 data frames in the call. Similar to the request message, if the length-prefixed
    message doesn’t fit one data frame, it can span to multiple data frames. As shown
    in the following, the `END_STREAM` flag isn’t sent with data frames. It is sent
    as a separate header called a trailer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器发送了响应头，长度前缀消息将作为 HTTP/2 数据帧发送。与请求消息类似，如果长度前缀消息不适合一个数据帧，它可以跨越多个数据帧。如下所示，`END_STREAM`
    标志不会与数据帧一起发送，而是作为称为尾部的单独头部发送：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the end, trailers are sent to notify the client that we finished sending
    the response message. Trailers also carry the status code and status message of
    the request:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尾部被发送以通知客户端我们已完成发送响应消息。尾部还携带请求的状态码和状态消息：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO3-1)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_grpc__under_the_hood_CO3-1)'
- en: Defines the gRPC status code. gRPC uses a set of well-defined status codes.
    You can find the definition of status codes in the [official gRPC documentation](https://oreil.ly/3MH72).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 gRPC 的状态码。gRPC 使用一组明确定义的状态码。你可以在 [官方 gRPC 文档](https://oreil.ly/3MH72) 中找到状态码的定义。
- en: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO3-2)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_grpc__under_the_hood_CO3-2)'
- en: Defines the description of the error. This is optional. This is only set when
    there is an error in processing the request.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了错误的描述。这是可选的。只有在处理请求时出现错误时才设置。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Trailers are also delivered as HTTP/2 header frames but at the end of the response
    message. The end of the response stream is indicated by setting the `END_STREAM`
    flag in trailer headers. Additionally, it contains the `grpc-status` and `grpc-message`
    headers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部也作为 HTTP/2 头部帧传递，但位于响应消息的末尾。通过在尾部头部设置 `END_STREAM` 标志来指示响应流的结束。此外，它包含 `grpc-status`
    和 `grpc-message` 头部。
- en: 'In certain scenarios, there can be an immediate failure in the request call.
    In those cases, the server needs to send a response back without the data frames.
    So the server sends only trailers as a response. Those trailers are also delivered
    as an HTTP/2 header frame and also contain the `END_STREAM` flag. Additionally,
    the following headers are included in trailers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，请求调用可能会立即失败。在这些情况下，服务器需要发送仅包含尾部的响应。这些尾部也作为 HTTP/2 头部帧传递，并包含 `END_STREAM`
    标志。此外，尾部还包含以下头部：
- en: HTTP-Status → `:status`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 状态 → `:status`
- en: Content-Type → `content-type`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型 → `content-type`
- en: Status → `grpc-status`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态 → `grpc-status`
- en: Status-Message → `grpc-message`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态消息 → `grpc-message`
- en: Now that we know how a gRPC message flows over an HTTP/2 connection, let’s try
    to understand the message flow of different communication patterns in gRPC.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 gRPC 消息如何在 HTTP/2 连接上传输，让我们尝试理解 gRPC 中不同通信模式的消息流动。
- en: Understanding the Message Flow in gRPC Communication Patterns
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在理解 gRPC 通信模式的消息流程时
- en: In the previous chapter, we discussed four communication patterns supported
    by gRPC. They are simple RPC, server-streaming RPC, client-streaming RPC, and
    bidirectional-streaming RPC. We also discussed how those communication patterns
    work using real-world use cases. In this section, we are going to look at those
    patterns again from a different angle. Let’s discuss how each pattern works at
    the transport level with the knowledge we collected in this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了 gRPC 支持的四种通信模式。它们是简单 RPC、服务器流式 RPC、客户端流式 RPC 和双向流式 RPC。我们还讨论了如何使用真实用例来解释这些通信模式的工作原理。在本节中，我们将从不同角度再次审视这些模式，讨论如何在传输层级别上使用我们在本章中收集的知识来解释每种模式的工作方式。
- en: Simple RPC
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单 RPC
- en: In simple RPC you always have a single request and a single response in the
    communication between the gRPC server and gRPC client. As shown in [Figure 4-8](#simple_rpc_message_flow),
    the request message contains headers followed by a length-prefixed message, which
    can span one or more data frames. An end of stream (EOS) flag is added at the
    end of the message to half-close the connection at the client side and mark the
    end of the request message. Here “half-close the connection” means the client
    closes the connection on its side so the client is no longer able to send messages
    to the server but still can listen to the incoming messages from the server. The
    server creates the response message only after receiving the complete message
    on the server side. The response message contains a header frame followed by a
    length-prefixed message. Communication ends once the server sends the trailing
    header with status details.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单 RPC 中，通信中 gRPC 服务器和 gRPC 客户端始终有一个单一请求和单一响应。如 [图 4-8](#simple_rpc_message_flow)
    所示，请求消息包含头部，后跟一个长度前缀消息，该消息可以跨越一个或多个数据帧。在消息末尾添加了流结束 (EOS) 标志，以半关闭客户端侧的连接并标记请求消息的结束。这里的“半关闭连接”意味着客户端关闭了其侧的连接，因此客户端无法再向服务器发送消息，但仍然可以接收服务器传入的消息。服务器只有在收到完整的请求消息后才创建响应消息。响应消息包含一个头部帧，后跟一个长度前缀消息。一旦服务器发送带有状态详细信息的尾部头，通信即告结束。
- en: '![Simple RPC: message flow](assets/grpc_0408.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![简单 RPC：消息流](assets/grpc_0408.png)'
- en: 'Figure 4-8\. Simple RPC: message flow'
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. 简单 RPC：消息流
- en: This is the simplest communication pattern. Let’s move on to a bit more complex
    server-streaming RPC scenario.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的通信模式。让我们继续看一个稍微复杂一点的服务器端流式 RPC 场景。
- en: Server-streaming RPC
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端流式 RPC
- en: From the client perspective, both simple RPC and server-streaming RPC have the
    same request message flow. In both cases, we send one request message. The main
    difference is on the server side. Rather than sending one response message to
    the client, the server sends multiple messages. The server waits until it receives
    the completed request message and sends the response headers and multiple length-prefixed
    messages as shown in [Figure 4-9](#server_streaming_rpc_message_flow). Communication
    ends once the server sends the trailing header with status details.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度看，简单 RPC 和服务器端流式 RPC 的请求消息流是相同的。在两种情况下，我们发送一个请求消息。主要区别在于服务器端。服务器不会只向客户端发送一个响应消息，而是发送多个消息。服务器等待接收完整的请求消息后，发送响应头和多个长度前缀消息，如
    [图 4-9](#server_streaming_rpc_message_flow) 所示。一旦服务器发送带有状态详细信息的尾部头，通信即告结束。
- en: '![Server-streaming RPC: message flow](assets/grpc_0409.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![服务器端流式 RPC：消息流](assets/grpc_0409.png)'
- en: 'Figure 4-9\. Server-streaming RPC: message flow'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-9\. 服务器端流式 RPC：消息流
- en: Now let’s look at client-streaming RPC, which is pretty much the opposite of
    server-streaming RPC.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看客户端流式 RPC，这与服务器端流式 RPC 几乎完全相反。
- en: Client-streaming RPC
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端流式 RPC
- en: In client-streaming RPC, the client sends multiple messages to the server and
    the server sends one response message in reply. The client first sets up the connection
    with the server by sending the header frames. Once the connection is set up, the
    client sends multiple length-prefixed messages as data frames to the server as
    shown in [Figure 4-10](#client_streaming_rpc_message_flow). In the end, the client
    half-closes the connection by sending an EOS flag in the last data frame. In the
    meantime, the server reads the messages received from the client. Once it receives
    all messages, the server sends a response message along with the trailing header
    and closes the connection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端流式 RPC 中，客户端向服务器发送多个消息，服务器则以一个响应消息回复。客户端首先通过发送头帧与服务器建立连接。一旦建立连接，客户端将多个长度前缀消息作为数据帧发送到服务器，如
    [图 4-10](#client_streaming_rpc_message_flow) 所示。最后，客户端通过在最后一个数据帧中发送 EOS 标志来半关闭连接。与此同时，服务器读取从客户端接收到的消息。一旦接收到所有消息，服务器将发送一个响应消息以及尾部头，并关闭连接。
- en: '![Client-streaming RPC: message flow](assets/grpc_0410.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![客户端流式 RPC：消息流](assets/grpc_0410.png)'
- en: 'Figure 4-10\. Client-streaming RPC: message flow'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-10\. 客户端流式 RPC：消息流
- en: Now let’s move onto the last communication pattern, bidirectional RPC, in which
    the client and server are both sending multiple messages to each other until they
    close the connection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向最后一种通信模式，双向 RPC，在这种模式下，客户端和服务器都会彼此发送多个消息，直到关闭连接。
- en: Bidirectional-streaming RPC
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双向流式 RPC
- en: In this pattern, the client sets up the connection by sending header frames.
    Once the connection is set up, the client and server both send length-prefixed
    messages without waiting for the other to finish. As shown in [Figure 4-11](#bidirectional_streaming_rpc_message_flow),
    both client and server send messages simultaneously. Both can end the connection
    at their side, meaning they can’t send any more messages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，客户端通过发送头帧建立连接。一旦连接建立，客户端和服务器都可以发送长度前缀的消息，而无需等待对方完成。如图 [4-11](#bidirectional_streaming_rpc_message_flow)
    所示，客户端和服务器同时发送消息。两者都可以在各自的一侧结束连接，这意味着它们不能再发送任何消息。
- en: '![Bidirectional-streaming RPC: message flow](assets/grpc_0411.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![双向流式 RPC：消息流](assets/grpc_0411.png)'
- en: 'Figure 4-11\. Bidirectional-streaming RPC: message flow'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-11\. 双向流式 RPC：消息流
- en: With that, we have come to the end of our in-depth tour of gRPC communication.
    Network and transport-related operations in communication are normally handled
    at the gRPC core layer and you don’t need to be aware of the details as a gRPC
    application developer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经结束了关于 gRPC 通信的深入介绍。通信中的网络和传输相关操作通常在 gRPC 核心层处理，作为 gRPC 应用程序开发人员，您不需要了解这些细节。
- en: Before wrapping up this chapter, let’s look at the gRPC implementation architecture
    and the language stack.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们来看看 gRPC 实现架构和语言堆栈。
- en: gRPC Implementation Architecture
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 实现架构
- en: As shown in [Figure 4-12](#grpc_native_implementation_architecture), gRPC implementation
    can be divided into multiple layers. The base layer is the gRPC core layer. It
    is a thin layer and it abstracts all the network operations from the upper layers
    so that application developers can easily make RPC calls over the network. The
    core layer also provides extensions to the core functionality. Some of the extension
    points are authentication filters to handle call security and a deadline filter
    to implement call deadlines, etc.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 [4-12](#grpc_native_implementation_architecture) 所示，gRPC 实现可以分为多个层次。基础层是
    gRPC 核心层。这是一个薄层，并且将所有网络操作从上层抽象出来，以便应用开发人员可以轻松地通过网络进行 RPC 调用。核心层还提供了对核心功能的扩展。一些扩展点是用于处理调用安全性的身份验证过滤器和用于实现调用截止时间的截止时间过滤器等。
- en: gRPC is natively supported by the C/C++, Go, and Java languages. gRPC also provides
    language bindings in many popular languages such as Python, Ruby, PHP, etc. These
    language bindings are wrappers over the low-level C API.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 受到 C/C++、Go 和 Java 语言的原生支持。gRPC 还提供了许多流行语言的语言绑定，如 Python、Ruby、PHP 等。这些语言绑定是低级
    C API 的封装器。
- en: Finally, the application code goes on top of language bindings. This application
    layer handles the application logic and data encoding logic. Normally developers
    generate source code for data encoding logic using compilers provided by different
    languages. For example, if we use protocol buffers for encoding data, the protocol
    buffer compiler can be used to generate source code. So developers can write their
    application logic by invoking the methods of generated source code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序代码位于语言绑定的顶部。此应用层处理应用逻辑和数据编码逻辑。通常开发人员使用不同语言提供的编译器生成数据编码逻辑的源代码。例如，如果我们使用协议缓冲区来编码数据，可以使用协议缓冲区编译器生成源代码。因此，开发人员可以通过调用生成的源代码的方法来编写其应用程序逻辑。
- en: '![gRPC native implementation architecture](assets/grpc_0412.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![gRPC 原生实现架构](assets/grpc_0412.png)'
- en: Figure 4-12\. gRPC native implementation architecture
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-12\. gRPC 原生实现架构
- en: With that, we have covered most of the low-level implementation and execution
    details of gRPC-based applications. As an application developer, it is always
    better to have an understanding of the low-level details about the techniques
    you’re going to use in the application. It not only helps to design robust applications,
    but also helps in troubleshooting application issues easily.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经涵盖了基于 gRPC 的应用程序的大部分低级实现和执行细节。作为应用程序开发人员，了解即将在应用程序中使用的技术的低级细节总是更好的。这不仅有助于设计健壮的应用程序，还有助于轻松解决应用程序问题。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: gRPC builds on top of two fast and efficient protocols called protocol buffers
    and HTTP/2\. Protocol buffers are a data serialization protocol that is a language-agnostic,
    platform-neutral, and extensible mechanism for serializing structured data. Once
    serialized, this protocol produces a binary payload that is smaller in size than
    a normal JSON payload and is strongly typed. This serialized binary payload then
    travels over the binary transport protocol called HTTP/2.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 建立在两个快速高效的协议之上，称为协议缓冲区和 HTTP/2。协议缓冲区是一种数据序列化协议，它是一种与语言无关、平台中立且可扩展的机制，用于序列化结构化数据。一旦序列化，该协议生成的二进制载荷比普通
    JSON 载荷更小，并且是强类型的。这个序列化的二进制载荷然后通过称为 HTTP/2 的二进制传输协议进行传输。
- en: HTTP/2 is the next major version of the internet protocol HTTP. HTTP/2 is fully
    multiplexed, which means that HTTP/2 can send multiple requests for data in parallel
    over a single TCP connection. This makes applications written in HTTP/2 faster,
    simpler, and more robust than others.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 是互联网协议 HTTP 的下一个主要版本。HTTP/2 是完全多路复用的，这意味着 HTTP/2 可以在单个 TCP 连接上并行发送多个数据请求。这使得使用
    HTTP/2 编写的应用程序比其他应用程序更快、更简单和更可靠。
- en: All these factors make gRPC a high-performance RPC framework.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些因素使得 gRPC 成为一个高性能的 RPC 框架。
- en: In this chapter we covered low-level details about gRPC communication. These
    details may be not essential to develop a gRPC application, because they are already
    handled by the library, but understanding low-level gRPC message flow is absolutely
    essential when it comes to troubleshooting gRPC communication-related issues when
    you use gRPC in production. In the next chapter, we’ll discuss some advanced capabilities
    provided by gRPC to cater to real-world requirements.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了关于 gRPC 通信的低级细节。这些细节对于开发 gRPC 应用可能并非必不可少，因为它们已经被库处理了，但是在使用 gRPC 进行生产时，理解低级
    gRPC 消息流对于解决与 gRPC 通信相关的问题是绝对必要的。在下一章中，我们将讨论 gRPC 提供的一些高级能力，以满足实际需求。
