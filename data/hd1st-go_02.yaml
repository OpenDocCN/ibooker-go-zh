- en: 'Chapter 1\. let’s get going: Syntax Basics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 让我们开始吧：语法基础
- en: '![image](assets/f0001-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0001-01.png)'
- en: '**Are you ready to turbo-charge your software?** Do you want a **simple** programming
    language that **compiles fast**? That **runs fast**? That makes it **easy to distribute**
    your work to users? Then **you’re ready for Go**!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**你准备好加速你的软件了吗？** 你想要一个**简单**的编程语言，**编译快**？**运行快**？让你**轻松分发**你的工作给用户？那么**你准备好使用Go了**！'
- en: Go is a programming language that focuses on **simplicity** and **speed**. It’s
    simpler than other languages, so it’s quicker to learn. And it lets you harness
    the power of today’s multicore computer processors, so your programs run faster.
    This chapter will show you all the Go features that will make **your life as a
    developer easier**, and make your **users happier**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种专注于**简单**和**速度**的编程语言。它比其他语言更简单，因此学习起来更快。它让你利用当今多核计算机处理器的强大能力，使得你的程序运行更快。本章将向你展示所有能让**作为开发者的生活更轻松**，让**用户更快乐**的Go特性。
- en: Ready, set, Go!
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了，开始吧！
- en: Back in 2007, the search engine Google had a problem. They had to maintain programs
    with millions of lines of code. Before they could test new changes, they had to
    compile the code into a runnable form, a process which at the time took the better
    part of an hour. Needless to say, this was bad for developer productivity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2007年，搜索引擎Google遇到了一个问题。他们必须维护数百万行代码的程序。在他们测试新更改之前，他们必须将代码编译成可运行的形式，这个过程当时需要大部分时间。不用说，这对开发者的生产力是不利的。
- en: 'So Google engineers Robert Griesemer, Rob Pike, and Ken Thompson sketched out
    some goals for a new language:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Google的工程师Robert Griesemer、Rob Pike和Ken Thompson为一种新语言设定了一些目标：
- en: Fast compilation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速编译
- en: Less cumbersome code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少繁琐的代码
- en: Unused memory freed automatically (garbage collection)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的内存会自动释放（垃圾回收）
- en: Easy-to-write software that does several operations simultaneously (concurrency)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够同时执行多个操作的易于编写的软件（并发）
- en: Good support for processors with multiple cores
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对多核处理器的良好支持
- en: 'After a couple years of work, Google had created Go: a language that was fast
    to write code for and produced programs that were fast to compile and run. The
    project switched to an open source license in 2009\. It’s now free for anyone
    to use. And you should use it! Go is rapidly gaining popularity thanks to its
    simplicity and power.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几年的努力，Google创建了Go：一种编写代码快速且产生的程序编译和运行速度快的语言。该项目于2009年转向开源许可证。现在任何人都可以免费使用。而且你应该使用它！由于其简单性和强大性，Go正迅速赢得人们的青睐。
- en: If you’re writing a command-line tool, Go can produce executable files for Windows,
    macOS, and Linux, all from the same source code. If you’re writing a web server,
    it can help you handle many users connecting at once. And no matter *what* you’re
    writing, it will help you ensure that your code is easier to maintain and add
    to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个命令行工具，Go可以从同一源代码生成Windows、macOS和Linux的可执行文件。如果你正在编写一个Web服务器，它可以帮助你处理许多用户同时连接。无论你在写什么，它都将帮助你确保你的代码更易于维护和添加。
- en: Ready to learn more? Let’s Go!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好学习更多了吗？让我们开始吧！
- en: '![image](assets/f0002-01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0002-01.png)'
- en: The Go Playground
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go Playground
- en: The easiest way to try Go is to visit *[https://play.golang.org](https://play.golang.org)*
    in your web browser. There, the Go team has set up a simple editor where you can
    enter Go code and run it on their servers. The result is displayed right there
    in your browser.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试Go的最简单方法是在你的Web浏览器中访问*[https://play.golang.org](https://play.golang.org)*。在那里，Go团队设置了一个简单的编辑器，你可以在其中输入Go代码并在他们的服务器上运行。结果会直接显示在你的浏览器中。
- en: '![image](assets/f0003-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0003-01.png)'
- en: (Of course, this only works if you have a stable internet connection. If you
    don’t, see [“Installing Go on your computer”](#installing_go_on_your_computer)
    to learn how to download and run the Go compiler directly on your computer. Then
    run the following examples using the compiler instead.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，这仅在你有稳定的互联网连接时才有效。如果没有，请参阅[“在你的计算机上安装Go”](#installing_go_on_your_computer)了解如何直接在你的计算机上下载和运行Go编译器。然后使用编译器运行以下示例。）
- en: Let’s try it out now!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试一试吧！
- en: '![image](assets/f0003-02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0003-02.png)'
- en: Open *[https://play.golang.org](https://play.golang.org)* in your browser. (Don’t
    worry if what you see doesn’t quite match the screenshot; it just means they’ve
    improved the site since this book was printed!)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开*[https://play.golang.org](https://play.golang.org)*。（如果你看到的与截图不太一样，不用担心；这只是说明他们自从印刷本书以来改进了网站！）
- en: 'Delete any code that’s in the editing area, and type this instead:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除编辑区域中的任何代码，并键入以下内容：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry, we’ll explain what all this means on the next page!
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 别担心，我们将在下一页解释所有这些内容的含义！
- en: Click the Format button, which will automatically reformat your code according
    to Go conventions.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击格式化按钮，这将根据 Go 约定自动重新格式化你的代码。
- en: Click the Run button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行按钮。
- en: You should see “Hello, Go!” displayed at the bottom of the screen. Congratulations,
    you’ve just run your first Go program!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在屏幕底部看到“Hello, Go!”显示。恭喜，你刚刚运行了你的第一个 Go 程序！
- en: Turn the page, and we’ll explain what we just did...
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 翻页，我们将解释刚刚做了什么...
- en: '![image](assets/f0003-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0003-03.png)'
- en: What does it all mean?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这一切都意味着什么？
- en: You’ve just run your first Go program! Now let’s look at the code and figure
    out what it actually means...
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚运行了你的第一个 Go 程序！现在让我们来看看这段代码，并弄清楚它实际上意味着什么...
- en: Every Go file starts with a `package` clause. A **package** is a collection
    of code that all does similar things, like formatting strings or drawing images.
    The `package` clause gives the name of the package that this file’s code will
    become a part of. In this case, we use the special package `main`, which is required
    if this code is going to be run directly (usually from the terminal).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Go 文件都以`package`子句开头。一个**包**是一组执行类似操作的代码，如格式化字符串或绘制图像。`package`子句指定了此文件代码将成为其一部分的包的名称。在这种情况下，我们使用特殊的`main`包，如果要直接运行此代码（通常来自终端），则需要此包。
- en: Next, Go files almost always have one or more `import` statements. Each file
    needs to **import** other packages before its code can use the code those other
    packages contain. Loading all the Go code on your computer at once would result
    in a big, slow program, so instead you specify only the packages you need by importing
    them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，几乎每个 Go 文件都有一个或多个`import`语句。每个文件在其代码可以使用其他包中的代码之前都需要**import**这些包。一次性加载计算机上所有
    Go 代码会导致一个庞大而缓慢的程序，因此你只需指定需要的包来导入它们。
- en: '![image](assets/f0004-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0004-01.png)'
- en: The last part of every Go file is the actual code, which is often split up into
    one or more functions. A **function** is a group of one or more lines of code
    that you can **call** (run) from other places in your program. When a Go program
    is run, it looks for a function named `main` and runs that first, which is why
    we named this function `main`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Go 文件的最后部分实际上是实际的代码，通常分割成一个或多个函数。一个**函数**是一组一个或多个代码行，你可以从程序的其他地方**调用**（运行）。当运行
    Go 程序时，它会查找名为`main`的函数并首先运行它，这就是为什么我们将这个函数命名为`main`的原因。
- en: The typical Go file layout
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的 Go 文件布局
- en: 'You’ll quickly get used to seeing these three sections, in this order, in almost
    every Go file you work with:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快会习惯看到这三个部分，按照这个顺序，在你所使用的几乎每个 Go 文件中：
- en: The package clause
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包子句
- en: Any `import` statements
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何`import`语句
- en: The actual code
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的代码
- en: '![image](assets/f0004-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0004-02.png)'
- en: 'The saying goes, “a place for everything, and everything in its place.” Go
    is a very *consistent* language. This is a good thing: you’ll often find you just
    *know* where to look in your project for a given piece of code, without having
    to think about it!'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说：“万物有其位，万物有其处。” Go 是一门非常*一致*的语言。这是一件好事：你经常会发现在项目中找到特定代码的位置，而无需思考！
- en: there are no Dumb Questions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: My other programming language requires that each statement end with a
    semicolon. Doesn’t Go?**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 我的另一种编程语言要求每个语句以分号结束。Go 不需要吗？**'
- en: '**A:** You *can* use semicolons to separate statements in Go, but it’s not
    required (in fact, it’s generally frowned upon).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 在 Go 中，你*可以*使用分号来分隔语句，但这并非必需（事实上，这通常是不被赞同的）。'
- en: '**Q: What’s this Format button? Why did we click that before running our code?**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 这个格式化按钮是什么？为什么在运行代码之前我们要点击它？**'
- en: '**A:** The Go compiler comes with a standard formatting tool, called `go fmt`.
    The Format button is the web version of `go fmt`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** Go 编译器配备了一个名为`go fmt`的标准格式化工具。格式化按钮是`go fmt`的 Web 版本。'
- en: Whenever you share your code, other Go developers will expect it to be in the
    standard Go format. That means that things like indentation and spacing will be
    formatted in a standard way, making it easier for everyone to read. Where other
    languages achieve this by relying on people manually reformatting their code to
    conform to a style guide, with Go all you have to do is run `go fmt`, and it will
    automatically fix everything for you.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你分享你的代码时，其他的 Go 开发者都期望它遵循标准的 Go 格式。这意味着缩进和间距等将以标准的方式格式化，使每个人阅读更加轻松。在其他语言中，这通常通过依赖人们手动根据样式指南重新格式化其代码来实现，但是在
    Go 中，你只需运行 `go fmt`，它就会自动为你修复一切。
- en: We ran the formatter on every example we created for this book, and you should
    run it on all your code, too!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对为本书创建的每个示例运行了格式化程序，你也应该对你的所有代码运行它！
- en: What if something goes wrong?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果发生了什么错误？
- en: Go programs have to follow certain rules to avoid confusing the compiler. If
    we break one of these rules, we’ll get an error message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序必须遵循某些规则，以避免使编译器混淆。如果我们违反其中一个规则，将会收到错误消息。
- en: Suppose we forgot to add parentheses on our call to the `Println` function on
    line 6.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们忘记在第 6 行对 `Println` 函数的调用中添加括号。
- en: 'If we try to run this version of the program, we get an error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行程序的这个版本，会得到一个错误：
- en: '![image](assets/f0005-01.png)![image](assets/f0005-02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0005-01.png)![image](assets/f0005-02.png)'
- en: Go tells us which source code file and line number we need to go to so we can
    fix the problem. (The Go Playground saves your code to a temporary file before
    running it, which is where the *prog.go* filename comes from.) Then it gives a
    description of the error. In this case, because we deleted the parentheses, Go
    can’t tell we’re trying to call the `Println` function, so it can’t understand
    why we’re putting `"Hello, Go"` at the end of line 6.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go 告诉我们我们需要转到哪个源代码文件和行号以便我们可以修复问题。（Go Playground 在运行之前会将你的代码保存到一个临时文件中，这就是 *prog.go*
    文件名的来源。）然后它会给出错误的描述。在这种情况下，因为我们删除了括号，Go 无法知道我们正在尝试调用 `Println` 函数，因此它无法理解为什么我们要在第
    6 行的末尾放置 `"Hello, Go"`。
- en: Breaking Stuff is Educational!
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破东西是教育性的！
- en: '![image](assets/f0006-01.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0006-01.png)'
- en: We can get a feel for the rules Go programs have to follow by intentionally
    breaking our program in various ways. Take this code sample, try making one of
    the changes below, and run it. Then undo your change and try the next one. See
    what happens!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过故意在不同的方式中断我们的程序来了解 Go 程序必须遵循的规则。拿这段代码示例来说，试着做一个以下的改变，并运行它。然后撤销你的改变，再试下一个。看看会发生什么！
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Try breaking our code sample and see what happens!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试故意破坏我们的代码示例，并查看发生了什么！
- en: '| If you do this... | ...it will fail because... |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 如果你这样做... | ...它会因为...而失败 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Delete the package clause...   ~~`package main`~~ | Every Go file has to
    begin with a package clause. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 删除包声明...   ~~`package main`~~ | 每个 Go 文件必须以包声明开头。'
- en: '| Delete the import statement...   ~~`import "fmt"`~~ | Every Go file has to
    import every package it references. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 删除导入语句...   ~~`import "fmt"`~~ | 每个 Go 文件必须导入其引用的每个包。'
- en: '| Import a second (unused) package...   ~~`import "fmt" import "strings"`~~
    | Go files must import *only* the packages they reference. (This helps keep your
    code compiling fast!) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 导入第二个（未使用的）包...   ~~`import "fmt" import "strings"`~~ | Go 文件必须仅导入其引用的包。（这有助于保持代码的快速编译！）'
- en: '| Rename the `main` function...   `func ~~main~~hello` | Go looks for a function
    named `main` to run first. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 重命名 `main` 函数...   `func ~~main~~hello` | Go 首先查找名为 `main` 的函数来运行。'
- en: '| Change the Println call to lowercase...   `fmt.~~P~~println("Hello, Go!")`
    | Everything in Go is case-sensitive, so although `fmt.Println` is valid, there’s
    no such thing as `fmt.println`. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 将 Println 调用更改为小写...   `fmt.~~P~~println("Hello, Go!")` | Go 中一切都是大小写敏感的，所以虽然
    `fmt.Println` 是有效的，但 `fmt.println` 是不存在的。'
- en: '| Delete the package name before Println...   `~~fmt~~.Println("Hello, Go!")`
    | The `Println` function isn’t part of the `main` package, so Go needs the package
    name before the function call. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 删除 Println 前的包名...   `~~fmt~~.Println("Hello, Go!")` | `Println` 函数不是 `main`
    包的一部分，因此在函数调用前需要包名。'
- en: Let’s try the first one as an example...
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以第一个作为例子...
- en: '![image](assets/f0006-03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0006-03.png)'
- en: Calling functions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: Our example includes a call to the `fmt` package’s `Println` function. To call
    a function, type the function name (`Println` in this case), and a pair of parentheses.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例包含对 `fmt` 包的 `Println` 函数的调用。要调用一个函数，输入函数名（本例中为 `Println`），然后加上一对括号。
- en: '![image](assets/f0007-01.png)![image](assets/f0007-02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0007-01.png)![image](assets/f0007-02.png)'
- en: 'Like many functions, `Println` can take one or more **arguments**: values you
    want the function to work with. The arguments appear in parentheses after the
    function name.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多函数一样，`Println`可以接受一个或多个**参数**：你希望函数处理的值。参数出现在函数名称后的括号中。
- en: '![image](assets/f0007-03.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0007-03.png)'
- en: '`Println` can be called with no arguments, or you can provide several arguments.
    When we look at other functions later, however, you’ll find that most require
    a specific number of arguments. If you provide too few or too many, you’ll get
    an error message saying how many arguments were expected, and you’ll need to fix
    your code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Println`可以不带参数调用，也可以提供多个参数。稍后我们会看到，大多数函数需要特定数量的参数。如果提供的参数太少或太多，会出现错误消息，说明期望的参数数量，需要修正代码。'
- en: The Println function
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Println`函数'
- en: Use the `Println` function when you need to see what your program is doing.
    Any arguments you pass to it will be printed (displayed) in your terminal, with
    each argument separated by a space.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要查看程序正在执行的操作时，请使用`Println`函数。传递给它的任何参数将在您的终端中打印（显示），每个参数由空格分隔。
- en: After printing all its arguments, `Println` will skip to a new terminal line.
    (That’s why “ln” is at the end of its name.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打印所有参数后，`Println`将跳到新的终端行。（这就是其名称末尾有“ln”的原因。）
- en: '![image](assets/f0007-04.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0007-04.png)'
- en: Using functions from other packages
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他包中的函数
- en: The code in our first program is all part of the `main` package, but the `Println`
    function is in the `fmt` package. (The `fmt` stands for “format.”) To be able
    to call `Println`, we first have to import the package containing it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个程序中的代码都属于`main`包，但`Println`函数位于`fmt`包中。（`fmt`代表“格式”）为了能够调用`Println`，我们必须首先导入包含它的包。
- en: '![image](assets/f0008-01.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0008-01.png)'
- en: Once we’ve imported the package, we can access any functions it offers by typing
    the package name, a dot, and the name of the function we want.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包后，我们可以通过输入包名、一个点和我们想要的函数名称访问它提供的任何函数。
- en: '![image](assets/f0008-02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0008-02.png)'
- en: Here’s a code sample that calls functions from a couple other packages. Because
    we need to import multiple packages, we switch to an alternate format for the
    `import` statement that lets you list multiple packages within parentheses, one
    package name per line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个调用其他包中函数的代码示例。因为我们需要导入多个包，我们切换到一种允许在`import`语句中列出多个包的备用格式，每行一个包名。
- en: '![image](assets/f0008-03.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0008-03.png)'
- en: Once we’ve imported the `math` and `strings` packages, we can access the `math`
    package’s `Floor` function with `math.Floor`, and the `strings` package’s `Title`
    function with `strings.Title`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 导入了`math`和`strings`包之后，我们可以使用`math.Floor`访问`math`包的`Floor`函数，使用`strings.Title`访问`strings`包的`Title`函数。
- en: You may have noticed that in spite of including those two function calls in
    our code, the above sample doesn’t display any output. We’ll look at how to fix
    that next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，尽管在我们的代码中包含了这两个函数调用，上面的示例却没有显示任何输出。接下来我们将看看如何修复这个问题。
- en: Function return values
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数返回值
- en: 'In our previous code sample, we tried calling the `math.Floor` and `strings.Title`
    functions, but they didn’t produce any output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码示例中，我们尝试调用`math.Floor`和`strings.Title`函数，但它们没有产生任何输出：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This program produces no output!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序不产生任何输出！
- en: 'When we call the `fmt.Println` function, we don’t need to communicate with
    it any further after that. We pass one or more values for `Println` to print,
    and we trust that it printed them. But sometimes a program needs to be able to
    call a function and get data back from it. For this reason, functions in most
    programming languages can have **return values**: a value that the function computes
    and returns to its caller.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`fmt.Println`函数时，在此之后我们不需要再与其通信。我们传递一个或多个值给`Println`打印，相信它会打印出它们。但有时程序需要能够调用函数并从中获取数据返回。因此，大多数编程语言中的函数可以有**返回值**：函数计算并返回给其调用者的值。
- en: The `math.Floor` and `strings.Title` functions are both examples of functions
    that use return values. The `math.Floor` function takes a floating-point number,
    rounds it down to the nearest whole number, and returns that whole number. And
    the `strings.Title` function takes a string, capitalizes the first letter of each
    word it contains (converting it to “title case”), and returns the capitalized
    string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.Floor`和`strings.Title`函数都是使用返回值的示例函数。`math.Floor`函数接受一个浮点数，将其向下舍入到最接近的整数，并返回该整数。而`strings.Title`函数接受一个字符串，将其中每个单词的第一个字母大写（将其转换为“标题格式”），并返回大写的字符串。'
- en: 'To actually see the results of these function calls, we need to take their
    return values and pass those to `fmt.Println`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些函数调用的结果，我们需要获取它们的返回值，并将这些返回值传递给`fmt.Println`：
- en: '![image](assets/f0009-01.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0009-01.png)'
- en: Once this change is made, the return values get printed, and we can see the
    results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个更改完成，返回值将被打印出来，我们可以看到结果。
- en: Pool Puzzle
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](assets/chair.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/chair.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in the code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make code that will run
    and produce the output shown.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您的**任务**是从池中获取代码片段，并将它们放入空行中。**不要**多次使用相同的片段，也不需要使用所有片段。您的**目标**是编写能够运行并生成所示输出的代码。
- en: '![image](assets/f0010-02.png)![image](assets/f0010-03.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0010-02.png)![image](assets/f0010-03.png)'
- en: '**Note: each snippet from the pool can only be used once!**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个池中的片段只能使用一次！**'
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_1).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在[“池谜题解答”](#pool_puzzle_solution_1)中。'
- en: A Go program template
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个Go程序模板
- en: 'For the code snippets that follow, just imagine inserting them into this full
    Go program:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的代码片段，想象将它们插入到这个完整的Go程序中：
- en: Better yet, try typing this program into the Go Playground, and then insert
    the snippets one at a time to see for yourself what they do!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是，尝试在Go Playground中键入这个程序，然后逐个插入片段，亲自看看它们的作用！
- en: '![image](assets/f0011-01.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0011-01.png)'
- en: Strings
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'We’ve been passing **strings** as arguments to `Println`. A string is a series
    of bytes that usually represent text characters. You can define strings directly
    within your code using **string literals**: text between double quotation marks
    that Go will treat as a string.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直将**字符串**作为`Println`的参数传递。字符串是一系列字节，通常表示文本字符。您可以在代码中直接定义字符串，使用**字符串字面量**：双引号之间的文本，Go将其视为字符串。
- en: '![image](assets/f0011-02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0011-02.png)'
- en: 'Within strings, characters like newlines, tabs, and other characters that would
    be hard to include in program code can be represented with **escape sequences**:
    a backslash followed by characters that represent another character.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中，像换行符、制表符和其他难以包含在程序代码中的字符可以用**转义序列**来表示：反斜杠后跟表示另一个字符的字符。
- en: '![image](assets/f0011-03.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0011-03.png)'
- en: '| Escape sequence | Value |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 值 |'
- en: '| --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\n` | A newline character. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符。 |'
- en: '| `\t` | A tab character. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符。 |'
- en: '| `\"` | Double quotation marks. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号。 |'
- en: '| `\\` | A backslash. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠。 |'
- en: Runes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符文
- en: Whereas strings are usually used to represent a whole series of text characters,
    Go’s **runes** are used to represent single characters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串通常用于表示一系列文本字符，但Go的**符文**用于表示单个字符。
- en: '![image](assets/f0012-01.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0012-01.png)'
- en: String literals are written surrounded by double quotation marks (`"`), but
    **rune literals** are written with single quotation marks (`'`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量用双引号(`"`)括起来，但**符文字面量**则用单引号(`'`)括起来。
- en: Go programs can use almost any character from almost any language on earth,
    because Go uses the Unicode standard for storing runes. Runes are kept as numeric
    codes, not the characters themselves, and if you pass a rune to `fmt.Println`,
    you’ll see that numeric code in the output, not the original character.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序可以使用几乎来自地球上任何语言的任何字符，因为Go使用Unicode标准来存储符文。符文保存为数值代码，而不是字符本身，如果将符文传递给`fmt.Println`，您将在输出中看到该数值代码，而不是原始字符。
- en: '![image](assets/f0012-02.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0012-02.png)'
- en: 'Just as with string literals, escape sequences can be used in a rune literal
    to represent characters that would be hard to include in program code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串字面量一样，符文字面量中也可以使用转义序列来表示在程序代码中难以包含的字符：
- en: '![image](assets/f0012-03.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0012-03.png)'
- en: Booleans
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: '**Boolean** values can be one of only two values: `true` or `false`. They’re
    especially useful with conditional statements, which cause sections of code to
    run only if a condition is true or false. (We’ll look at conditionals in the next
    chapter.)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔**值只能是`true`或`false`两个值中的一个。它们在条件语句中特别有用，条件语句只在条件为真或假时运行代码的某些部分。（我们将在下一章节中讨论条件语句。）'
- en: '![image](assets/f0012-04.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0012-04.png)'
- en: Numbers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'You can also define numbers directly within your code, and it’s even simpler
    than string literals: just type the number.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在代码中直接定义数字，这比字符串字面量更简单：只需键入数字。
- en: '![image](assets/f0013-01.png)![image](assets/f0013-02.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0013-01.png)![image](assets/f0013-02.png)'
- en: As we’ll see shortly, Go treats integer and floating-point numbers as different
    types, so remember that a decimal point can be used to distinguish an integer
    from a floating-point number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的那样，Go将整数和浮点数视为不同的类型，因此请记住，小数点可以用来区分整数和浮点数。
- en: Math operations and comparisons
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学运算和比较
- en: Go’s basic math operators work just like they do in most other languages. The
    `+` symbol is for addition, `-` for subtraction, `*` for multiplication, and `/`
    for division.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Go的基本数学运算符工作方式与大多数其他语言相同。`+`符号用于加法，`-`用于减法，`*`用于乘法，`/`用于除法。
- en: '![image](assets/f0013-03.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0013-03.png)'
- en: You can use `<` and `>` to compare two values and see if one is less than or
    greater than another. You can use `==` (that’s *two* equals signs) to see if two
    values are equal, and `!=` (that’s an exclamation point and an equals sign, read
    aloud as “not equal”) to see if two values are not equal. `<=` tests whether the
    second value is less than *or* equal to the first, and `>=` tests whether the
    second value is greater than or equal to the first.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`<`和`>`来比较两个值，看一个是否小于或大于另一个。你可以使用`==`（这是*两个*等号）来判断两个值是否相等，使用`!=`（这是一个感叹号和一个等号，读作“不等于”）来判断两个值是否不相等。`<=`测试第二个值是否小于或等于第一个值，`>=`测试第二个值是否大于或等于第一个值。
- en: The result of a comparison is a Boolean value, either `true` or `false`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的结果是一个布尔值，要么是`true`，要么是`false`。
- en: '![image](assets/f0013-04.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0013-04.png)'
- en: Types
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: In a previous code sample, we saw the `math.Floor` function, which rounds a
    floating-point number down to the nearest whole number, and the `strings.Title`
    function, which converts a string to title case. It makes sense that you would
    pass a number as an argument to the `Floor` function, and a string as an argument
    to the `Title` function. But what would happen if you passed a string to `Floor`
    and a number to `Title`?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们看到了`math.Floor`函数，它将浮点数向下舍入到最接近的整数，并且`strings.Title`函数，它将字符串转换为标题格式。你传递一个数字作为`Floor`函数的参数是有道理的，而将一个字符串作为`Title`函数的参数也是如此。但如果你将一个字符串传递给`Floor`，并将一个数字传递给`Title`会发生什么呢？
- en: '![image](assets/f0014-01.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0014-01.png)'
- en: Go prints two error messages, one for each function call, and the program doesn’t
    even run!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Go会打印两条错误消息，每个函数调用一条，甚至程序都不会运行！
- en: Things in the world around you can often be classified into different types
    based on what they can be used for. You don’t eat a car or truck for breakfast
    (because they’re vehicles), and you don’t drive an omelet or bowl of cereal to
    work (because they’re breakfast foods).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 周围的世界中的事物通常可以根据它们的用途分类为不同的类型。你不会吃汽车或卡车作为早餐（因为它们是车辆），你也不会开着煎蛋卷或碗状谷物去上班（因为它们是早餐食品）。
- en: Likewise, values in Go are all classified into different **types**, which specify
    what the values can be used for. Integers can be used in math operations, but
    strings can’t. Strings can be capitalized, but numbers can’t. And so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，Go中的值都被分类为不同的**类型**，这些类型指定了值可以用于什么。整数可以用于数学运算，但字符串不能。字符串可以大写，但数字不能。依此类推。
- en: 'Go is **statically typed**, which means that it knows what the types of your
    values are even before your program runs. Functions expect their arguments to
    be of particular types, and their return values have types as well (which may
    or may not be the same as the argument types). If you accidentally use the wrong
    type of value in the wrong place, Go will give you an error message. This is a
    good thing: it lets you find out there’s a problem before your users do!'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Go是**静态类型**的，这意味着它在程序运行之前就知道你的值的类型。函数期望它们的参数具有特定的类型，它们的返回值也有类型（可能与参数类型相同，也可能不同）。如果你在错误的地方意外使用了错误类型的值，Go会给出错误消息。这是件好事：它能让你在用户之前发现问题！
- en: '**Go is statically typed. If you use the wrong type of value in the wrong place,
    Go will let you know.**'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Go 是静态类型的。如果在错误的地方使用了错误类型的值，Go 会提醒您。**'
- en: 'You can view the type of any value by passing it to the `reflect` package’s
    `TypeOf` function. Let’s find out what the types are for some of the values we’ve
    already seen:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其传递给`reflect`包的`TypeOf`函数来查看任何值的类型。让我们看看我们已经见过的一些值的类型：
- en: '![image](assets/f0015-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0015-01.png)'
- en: 'Here’s what those types are used for:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型是用于什么的：
- en: '| Type | Description |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int` | An integer. Holds whole numbers. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 整数。保存整数值。 |'
- en: '| `float64` | A floating-point number. Holds numbers with a fractional part.
    (The `64` in the type name is because 64 bits of data are used to hold the number.
    This means that `float64` values can be fairly, but not infinitely, precise before
    being rounded off.) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | 浮点数。保存具有小数部分的数字。（类型名称中的`64`表示使用了64位数据来保存数字。这意味着`float64`值在被四舍五入之前可以相当精确，但不是无限精确。）
    |'
- en: '| `bool` | A Boolean value. Can only be `true` or `false`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值。只能是`true`或`false`。 |'
- en: '| `string` | A string. A series of data that usually represents text characters.
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 字符串。通常表示文本字符的数据系列。 |'
- en: '![image](assets/arrow.png) Answers in [“![image](assets/common.png) Exercise
    Solutions”](#exercise_solutions_1).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在[“![image](assets/common.png) 练习解答”](#exercise_solutions_1)中。'
- en: Declaring variables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量
- en: In Go, a **variable** is a piece of storage containing a value. You can give
    a variable a name by using a **variable declaration**. Just use the `var` keyword
    followed by the desired name and the type of values the variable will hold.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，**变量**是包含值的存储空间。您可以使用**变量声明**为变量命名。只需使用`var`关键字，后面跟上所需的名称和变量将保存的值的类型。
- en: '![image](assets/f0016-01.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0016-01.png)'
- en: 'Once you declare a variable, you can assign any value of that type to it with
    `=` (that’s a *single* equals sign):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了变量，您可以使用`=`将该类型的任何值赋给它（这是*单个*等号）：
- en: '[PRE3]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can assign values to multiple variables in the same statement. Just place
    multiple variable names on the left side of the `=`, and the same number of values
    on the right side, separated with commas.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在同一语句中为多个变量分配值。只需在`=`的左侧放置多个变量名，并在右侧用逗号分隔相同数量的值即可。
- en: '![image](assets/f0016-02.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0016-02.png)'
- en: 'Once you’ve assigned values to variables, you can use them in any context where
    you would use the original values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为变量赋值，您可以在任何需要使用原始值的上下文中使用它们：
- en: '![image](assets/f0016-03.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0016-03.png)'
- en: 'If you know beforehand what a variable’s value will be, you can declare variables
    and assign them values on the same line:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您事先知道变量的值，可以在同一行声明变量并为其赋值：
- en: '![image](assets/f0017-01.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0017-01.png)'
- en: You can assign new values to existing variables, but they need to be values
    of the same type. Go’s static typing ensures you don’t accidentally assign the
    wrong kind of value to a variable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为现有变量分配新值，但它们需要是相同类型的值。Go 的静态类型确保您不会意外地将错误类型的值分配给变量。
- en: '![image](assets/f0017-02.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0017-02.png)'
- en: If you assign a value to a variable at the same time as you declare it, you
    can usually omit the variable type from the declaration. The type of the value
    assigned to the variable will be used as the type of that variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在声明变量的同时为其赋值，通常可以省略声明中的变量类型。将赋给变量的值的类型将用作该变量的类型。
- en: '![image](assets/f0017-03.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0017-03.png)'
- en: Zero values
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零值
- en: 'If you declare a variable without assigning it a value, that variable will
    contain the **zero value** for its type. For numeric types, the zero value is
    actually `0`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明一个变量而没有为其赋值，那么该变量将包含其类型的**零值**。对于数值类型，零值实际上是`0`：
- en: '![image](assets/f0017-04.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0017-04.png)'
- en: But for other types, a value of `0` would be invalid, so the zero value for
    that type may be something else. The zero value for `string` variables is an empty
    string, for example, and the zero value for `bool` variables is `false`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于其他类型，值`0`可能是无效的，因此该类型的零值可能是其他值。例如，`string` 类型变量的零值是空字符串，`bool` 类型变量的零值是`false`。
- en: '![image](assets/f0017-05.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0017-05.png)'
- en: Code Magnets
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/f0018-01.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0018-01.png)'
- en: A Go program is all scrambled up on the fridge. Can you reconstruct the code
    snippets to make a working program that will produce the given output?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Go 程序在冰箱上乱七八糟地摆放着。你能否重构代码片段，使其成为一个能产生指定输出的工作程序？
- en: '![image](assets/f0018-02.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0018-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_1).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在 [“Code Magnets Solution”](#code_magnets_solution_1)。'
- en: Short variable declarations
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短变量声明
- en: 'We mentioned that you can declare variables and assign them values on the same
    line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到你可以在同一行声明变量并给它们赋值：
- en: '![image](assets/f0019-01.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0019-01.png)'
- en: But if you know what the initial value of a variable is going to be as soon
    as you declare it, it’s more typical to use a **short variable declaration**.
    Instead of explicitly declaring the type of the variable and later assigning to
    it with `=`, you do both at once using `:=`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在声明变量的同时知道变量的初始值，使用**短变量声明**更为典型。而不是显式声明变量类型，然后用 `=` 赋值，你可以一次完成两者，使用 `:=`。
- en: 'Let’s update the previous example to use short variable declarations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新之前的示例以使用短变量声明：
- en: '![image](assets/f0019-02.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0019-02.png)'
- en: There’s no need to explicitly declare the variable’s type; the type of the value
    assigned to the variable becomes the type of that variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要显式声明变量的类型；分配给变量的值的类型成为该变量的类型。
- en: Because short variable declarations are so convenient and concise, they’re used
    more often than regular declarations. You’ll still see both forms occasionally,
    though, so it’s important to be familiar with both.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为短变量声明如此方便和简洁，它们比常规声明更常用。尽管如此，你仍会偶尔看到两种形式，所以熟悉这两种形式是很重要的。
- en: Breaking Stuff is Educational!
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Breaking Stuff is Educational!
- en: '![image](assets/f0020-01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0020-01.png)'
- en: Take our program that uses variables, try making one of the changes below, and
    run it. Then undo your change and try the next one. See what happens!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 拿我们使用变量的程序，尝试进行以下修改，并运行它。然后撤消你的更改并尝试下一个。看看会发生什么！
- en: '![image](assets/f0020-01a.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0020-01a.png)'
- en: '| If you do this... | ...it will fail because... |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 如果你这样做... | ...它会失败，因为... |'
- en: '| --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Add a second declaration for the same variable   `quantity := 4 quantity
    := 4` | You can only declare a variable once. (Although you can assign new values
    to it as often as you want. You can also declare other variables with the same
    name, as long as they’re in a different scope. We’ll learn about scopes in the
    next chapter.) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 为相同变量添加第二个声明   `quantity := 4 quantity := 4` | 你只能声明一个变量。（尽管你可以随意给它赋新值。你也可以声明同名的其他变量，只要它们在不同的作用域内。我们将在下一章学习作用域。）
    |'
- en: '| Delete the : from a short variable declaration   `quantity = 4` | If you
    forget the :, it’s treated as an assignment, not a declaration, and you can’t
    assign to a variable that hasn’t been declared. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 删除短变量声明中的冒号   `quantity = 4` | 如果忘记了冒号，它将被视为赋值而不是声明，而且你不能给一个未声明的变量赋值。 |'
- en: '| Assign a `string` to an int variable   `quantity := 4 quantity = "a"` | Variables
    can only be assigned values of the same type. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 给 int 变量赋一个 `string`   `quantity := 4 quantity = "a"` | 变量只能被赋予相同类型的值。 |'
- en: '| Mismatch number of variables and values `length, width := 1.2` | You’re required
    to provide a value for every variable you’re assigning, and a variable for every
    value. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 变量和值数量不匹配 `length, width := 1.2` | 每个要赋值的变量都必须提供一个值，并且每个值都必须有一个对应的变量。 |'
- en: '| Remove code that uses a variable   ~~`fmt.Println(customerName)`~~ | All
    declared variables must be used in your program. If you remove the code that uses
    a variable, you must also remove the declaration. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 移除使用变量的代码   ~~`fmt.Println(customerName)`~~ | 所有声明的变量必须在你的程序中使用。如果移除了使用变量的代码，也必须移除该声明。
    |'
- en: Naming rules
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名规则
- en: 'Go has one simple set of rules that apply to the names of variables, functions,
    and types:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有一套简单的规则适用于变量、函数和类型的名称：
- en: A name must begin with a letter, and can have any number of additional letters
    and numbers.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须以字母开头，并且可以有任意数量的额外字母和数字。
- en: 'If the name of a variable, function, or type begins with a capital letter,
    it is considered **exported** and can be accessed from packages outside the current
    one. (This is why the `P` in `fmt.Println` is capitalized: so it can be used from
    the `main` package or any other.) If a variable/function/type name begins with
    a lowercase letter, it is considered **unexported** and can only be accessed within
    the current package.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果变量、函数或类型的名称以大写字母开头，它被视为**导出的**，可以从当前包之外的包访问。（这就是为什么 `fmt.Println` 中的 `P` 要大写：这样它可以从
    `main` 包或任何其他包使用。）如果变量/函数/类型名称以小写字母开头，它被视为**未导出的**，只能在当前包内访问。
- en: '![image](assets/f0021-01.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0021-01.png)'
- en: 'Those are the only rules enforced by the language. But the Go community follows
    some additional conventions as well:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是语言强制执行的唯一规则。但 Go 社区也遵循一些额外的约定：
- en: 'If a name consists of multiple words, each word after the first should be capitalized,
    and they should be attached together without spaces between them, like this: `topPrice`,
    `RetryConnection`, and so on. (The first letter of the name should only be capitalized
    if you want to export it from the package.) This style is often called *camel
    case* because the capitalized letters look like the humps on a camel.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果名称由多个单词组成，则从第一个单词开始，每个单词后面的单词应大写，并且它们应该以不加空格连接在一起，如 `topPrice`、`RetryConnection`
    等。（如果要将名称导出到包外，则仅应将名称的第一个字母大写。）这种风格通常称为*驼峰式*，因为大写字母看起来像骆驼的驼峰。
- en: 'When the meaning of a name is obvious from the context, the Go community’s
    convention is to abbreviate it: to use `i` instead of `index`, `max` instead of
    `maximum`, and so on. (However, we at Head First believe that nothing is obvious
    when you’re learning a new language, so we will *not* be following that convention
    in this book.)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当名称的含义在上下文中是显而易见的时，Go 社区的惯例是缩写它：使用 `i` 替代 `index`，`max` 替代 `maximum` 等。（然而，在
    Head First 我们认为，在学习新语言时，没有什么是显而易见的，所以在本书中我们*不会*遵循这种惯例。）
- en: '![image](assets/f0021-02.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0021-02.png)'
- en: '**Only variables, functions, or types whose names begin with a capital letter
    are considered exported: accessible from packages outside the current package.**'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**只有以大写字母开头的变量、函数或类型的名称才被视为导出的：可以从当前包之外的包访问。**'
- en: Conversions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: Math and comparison operations in Go require that the included values be of
    the same type. If they’re not, you’ll get an error when trying to run your code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，数学和比较操作要求包含的值是相同类型的。如果它们不是，则在尝试运行代码时会出错。
- en: '![image](assets/f0022-01.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0022-01.png)'
- en: The same is true of assigning new values to variables. If the type of value
    being assigned doesn’t match the declared type of the variable, you’ll get an
    error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 给变量赋新值也是如此。如果被赋值的值的类型与变量声明的类型不匹配，你将会得到一个错误。
- en: '![image](assets/f0022-02.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0022-02.png)'
- en: The solution is to use **conversions**, which let you convert a value from one
    type to another type. You just provide the type you want to convert a value to,
    immediately followed by the value you want to convert in parentheses.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是使用**类型转换**，它允许您将一个值从一种类型转换为另一种类型。您只需在要转换的值的括号中立即提供要转换为的类型。
- en: '![image](assets/f0022-03.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0022-03.png)'
- en: 'The result is a new value of the desired type. Here’s what we get when we call
    `TypeOf` on the value in an integer variable, and again on that same value after
    conversion to a `float64`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是所需类型的新值。当我们在整数变量中的值上调用 `TypeOf`，然后在将其转换为 `float64` 后再次调用时，我们得到的就是这个：
- en: '![image](assets/f0022-04.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0022-04.png)'
- en: Let’s update our failing code example to convert the `int` value to a `float64`
    before using it in any math operations or comparisons with other `float64` values.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们失败的代码示例，在任何数学运算或与其他 `float64` 值比较之前将 `int` 值转换为 `float64`：
- en: '![image](assets/f0023-01.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0023-01.png)'
- en: The math operation and comparison both work correctly now!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数学运算和比较都能正常工作了！
- en: 'Now let’s try converting an `int` to a `float64` before assigning it to a `float64`
    variable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在将其分配给 `float64` 变量之前将 `int` 转换为 `float64`：
- en: '![image](assets/f0023-02.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0023-02.png)'
- en: Again, with the conversion in place, the assignment is successful.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次确认转换完成后，分配就成功了。
- en: When making conversions, be aware of how they might change the resulting values.
    For example, `float64` variables can store fractional values, but `int` variables
    can’t. When you convert a `float64` to an `int`, the fractional portion is simply
    dropped! This can throw off any operations you do with the resulting value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行转换时，请注意它们可能如何改变结果值。例如，`float64`变量可以存储分数值，但`int`变量则不能。当您将`float64`转换为`int`时，小数部分将被简单地丢弃！这可能会影响您对结果值进行的任何操作。
- en: '![image](assets/f0023-03.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0023-03.png)'
- en: As long as you’re cautious, though, you’ll find conversions essential to working
    with Go. They allow otherwise-incompatible types to work together.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你小心，转换对于使用Go是至关重要的。它们允许原本不兼容的类型一起工作。
- en: Installing Go on your computer
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的计算机上安装Go
- en: The Go Playground is a great way to try out the language. But its practical
    uses are limited. You can’t use it to work with files, for example. And it doesn’t
    have a way to take user input from the terminal, which we’re going to need for
    an upcoming program.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Go Playground是尝试该语言的好方法。但它的实际用途有限。例如，您无法使用它来处理文件。它也没有办法从终端获取用户输入，而这对我们即将开发的程序非常重要。
- en: So, to wrap up this chapter, let’s download and install Go on your computer.
    Don’t worry, the Go team has made it really easy! On most operating systems, you
    just have to run an installer program, and you’ll be done.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在结束本章之前，让我们在您的计算机上下载并安装Go。别担心，Go团队已经非常简化了这个过程！在大多数操作系统上，您只需运行一个安装程序，就可以完成安装。
- en: '![image](assets/f0025-01.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0025-01.png)'
- en: Visit *[https://golang.org](https://golang.org)* in your web browser.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Web浏览器中访问*[https://golang.org](https://golang.org)*。
- en: Click the download link.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载链接。
- en: Select the installation package for your operating system (OS). The download
    should begin automatically.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合您操作系统（OS）的安装包。下载应会自动开始。
- en: Visit the installation instructions page for your OS (you may be taken there
    automatically after the download starts), and follow the directions there.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您操作系统的安装说明页面（下载开始后可能会自动跳转），按照页面上的指导进行操作。
- en: Open a new terminal or command prompt window.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端或命令提示符窗口。
- en: Confirm Go was installed by typing `**go version**` at the prompt and hitting
    the Return or Enter key. You should see a message with the version of Go that’s
    installed.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符处键入`**go version**`并按下回车键或Enter键确认Go是否已安装。您应该会看到安装的Go版本信息。
- en: Compiling Go code
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译Go代码
- en: Our interaction with the Go Playground has consisted of typing in code and having
    it mysteriously run. Now that we’ve actually installed Go on your computer, it’s
    time to take a closer look at how this works.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与Go Playground的互动主要是键入代码并神秘地运行它。现在我们实际上在您的计算机上安装了Go，是时候更仔细地了解它的工作原理了。
- en: 'Computers actually aren’t capable of running Go code directly. Before that
    can happen, we need to take the source code file and **compile** it: convert it
    to a binary format that a CPU can execute.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机实际上不能直接运行Go代码。在此之前，我们需要获取源代码文件并**编译**它：将其转换为CPU可以执行的二进制格式。
- en: '![image](assets/f0026-01.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0026-01.png)'
- en: Let’s try using our new Go installation to compile and run our “Hello, Go!”
    example from earlier.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们新的Go安装程序编译和运行之前的“Hello, Go!”示例。
- en: '![image](assets/f0026-03.png)![image](assets/f0026-02.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0026-03.png)![image](assets/f0026-02.png)'
- en: Using your favorite text editor, save our “Hello, Go!” code from earlier in
    a plain-text file named *hello.go*.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器，将我们之前的“Hello, Go!”代码保存在一个名为*hello.go*的纯文本文件中。
- en: Open a new terminal or command prompt window.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端或命令提示符窗口。
- en: In the terminal, change to the directory where you saved *hello.go*.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，切换到保存*hello.go*的目录。
- en: Run `**go fmt hello.go**` to clean up the code formatting. (This step isn’t
    required, but it’s a good idea anyway.)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`**go fmt hello.go**`来清理代码格式。（这一步骤不是必需的，但无论如何都是一个好主意。）
- en: Run `**go build hello.go**` to compile the source code. This will add an executable
    file to the current directory. On macOS or Linux, the executable will be named
    just *hello*. On Windows, the executable will be named *hello.exe*.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`**go build hello.go**`来编译源代码。这将在当前目录中添加一个可执行文件。在macOS或Linux上，可执行文件将命名为*hello*。在Windows上，可执行文件将命名为*hello.exe*。
- en: Run the executable file. On macOS or Linux, do this by typing `**./hello**`
    (which means “run a program named `hello` in the current directory”). On Windows,
    just type `**hello.exe**`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行可执行文件。在macOS或Linux上，输入`**./hello**`（意思是“在当前目录中运行名为`hello`的程序”）。在Windows上，只需输入`**hello.exe**`。
- en: '![image](assets/f0026-04.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0026-04.png)'
- en: Go tools
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go工具
- en: 'When you install Go, it adds an executable named *go* to your command prompt.
    The *go* executable gives you access to various commands, including:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Go后，会在命令提示符中添加一个名为*go*的可执行文件。*go*可执行文件为您提供访问各种命令的权限，包括：
- en: '| Command | Description |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `go build` | Compiles source code files into binary files. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `go build` | 将源代码文件编译成二进制文件。 |'
- en: '| `go run` | Compiles and runs a program, without saving an executable file.
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `go run` | 编译并运行程序，而不保存可执行文件。 |'
- en: '| `go fmt` | Reformats source files using Go standard formatting. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `go fmt` | 使用Go标准格式重新格式化源文件。 |'
- en: '| `go version` | Displays the current Go version. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `go version` | 显示当前Go版本。 |'
- en: We just tried the `go fmt` command, which reformats your code in the standard
    Go format. It’s equivalent to the Format button on the Go Playground site. We
    recommend running `go fmt` on every source file you create.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚尝试了`go fmt`命令，该命令会按照标准Go格式重新格式化您的代码。它相当于Go Playground网站上的格式化按钮。我们建议在创建每个源文件后运行`go
    fmt`。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most editors can be set up to automatically run go fmt every time you save a
    file! See [https://blog.golang.org/go-fmt-your-code](https://blog.golang.org/go-fmt-your-code).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编辑器可以设置为在每次保存文件时自动运行go fmt！请参阅[https://blog.golang.org/go-fmt-your-code](https://blog.golang.org/go-fmt-your-code)。
- en: We also used the `go build` command to compile code into an executable file.
    Executable files like this can be distributed to users, and they’ll be able to
    run them even if they don’t have Go installed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`go build`命令将代码编译成可执行文件。像这样的可执行文件可以分发给用户，即使他们没有安装Go，他们也能运行它们。
- en: But we haven’t tried the `go run` command yet. Let’s do that now.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有尝试过`go run`命令。现在让我们来试试吧。
- en: Try out code quickly with “go run”
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“go run”快速试验代码
- en: The `go run` command compiles and runs a source file, without saving an executable
    file to the current directory. It’s great for quickly trying out simple programs.
    Let’s use it to run our *hello.go* sample.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run`命令编译并运行源文件，而不会将可执行文件保存到当前目录。这对于快速尝试简单程序非常有用。让我们用它来运行我们的*hello.go*示例。'
- en: '![image](assets/f0027-02.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0027-02.png)'
- en: Open a new terminal or command prompt window.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的终端或命令提示窗口。
- en: In the terminal, change to the directory where you saved *hello.go*.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，切换到保存*hello.go*的目录。
- en: Type `**go run hello.go**` and hit Enter/Return. (The command is the same on
    all operating systems.)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`**go run hello.go**`并按Enter/Return键。 （该命令在所有操作系统上都相同。）
- en: '![image](assets/f0027-01.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0027-01.png)'
- en: You’ll immediately see the program output. If you make changes to the source
    code, you don’t have to do a separate compilation step; just run your code with
    `go run` and you’ll be able to see the results right away. When you’re working
    on small programs, `go run` is a handy tool to have!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您将立即看到程序输出。如果对源代码进行更改，您不必进行单独的编译步骤；只需使用`go run`运行代码，即可立即查看结果。在编写小型程序时，`go run`是一个很方便的工具！
- en: Your Go Toolbox
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Go工具箱
- en: '![image](assets/f0028-01.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0028-01.png)'
- en: '**That’s it for [Chapter 1](#letapsos_get_going_syntax_basics)! You’ve added
    function calls and types to your toolbox.**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**至此为止，[第一章](#letapsos_get_going_syntax_basics)就讲完了！您已经把函数调用和类型添加到了您的工具箱中。**'
- en: Note
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Function calls**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数调用**'
- en: A function is a chunk of code that you can call from other places in your program.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是程序中可以从其他位置调用的代码块。
- en: When calling a function, you can use arguments to provide the function with
    data.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，可以使用参数为函数提供数据。
- en: Note
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Types**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**'
- en: Values in Go are classified into different types, which specify what the values
    can be used for.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的值被分类为不同的类型，这些类型指定了值可以用于什么。
- en: Math operations and comparisons between different types are not allowed, but
    you can convert a value to a new type if needed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 数学操作和不同类型之间的比较不允许，但如果需要，可以将值转换为新类型。
- en: Go variables can only store values of their declared type.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Go变量只能存储其声明类型的值。
- en: Pool Puzzle Solution
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解决方案
- en: '![image](assets/f0029-01.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0029-01.png)'
- en: Code Magnets Solution
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁解决方案
- en: '![image](assets/f0030-01.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0030-01.png)'
