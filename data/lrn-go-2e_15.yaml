- en: Chapter 15\. Writing Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 写测试
- en: Since the 2000s, the widespread adoption of automated testing has probably done
    more to improve code quality than any other software engineering technique. As
    a language and ecosystem focused on improving software quality, it’s not surprising
    that Go includes testing support as part of its standard library. Go makes it
    so easy to test your code, there’s no excuse to not do it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自2000年以来，自动化测试的广泛采用可能比任何其他软件工程技术更多地提高了代码质量。作为一个专注于提高软件质量的语言和生态系统，Go 将测试支持作为其标准库的一部分包含其中并不令人意外。Go
    使得测试代码变得如此简单，没有理由不去做。
- en: In this chapter, you’ll see how to test Go code, group tests into unit and integration
    tests, examine code coverage, write benchmarks, and learn how to check code for
    concurrency issues by using the Go data race detector. Along the way, I’ll discuss
    how to write code that is testable and why this improves our code quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到如何测试 Go 代码，将测试分组为单元测试和集成测试，检查代码覆盖率，编写基准测试，并学习如何通过使用 Go 数据竞争检测器检查代码并发问题。在此过程中，我将讨论如何编写可测试的代码以及为什么这样可以提高我们的代码质量。
- en: Understanding the Basics of Testing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试的基础知识
- en: 'Go’s testing support has two parts: libraries and tooling. The `testing` package
    in the standard library provides the types and functions to write tests, while
    the `go test` tool that’s bundled with Go runs your tests and generates reports.
    Unlike many other languages, Go places its tests in the same directory and the
    same package as the production code. Since tests are located in the same package,
    they are able to access and test unexported functions and variables. You’ll see
    in a bit how to write tests that ensure that you are testing only a public API.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言不同，Go 将其测试放在与生产代码相同的目录和包中。由于测试位于同一包中，因此它们能够访问和测试未公开的函数和变量。稍后您将看到如何编写测试来确保仅测试公共
    API。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Complete code samples for this chapter are found in the [Chapter 15 repository](https://oreil.ly/PNRJx).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码示例可在 [第15章存储库](https://oreil.ly/PNRJx) 中找到。
- en: 'Let’s write a simple function and then a test to make sure the function works.
    In the *sample_code/adder* directory, in the file *adder.go*, you have the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的函数，然后编写一个测试来确保该函数正常工作。在 *sample_code/adder* 目录中的 *adder.go* 文件中，您有以下内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding test is in *adder_test.go*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的测试位于 *adder_test.go* 中：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Every test is written in a file whose name ends with *_test.go*. If you are
    writing tests against *foo.go*, place your tests in a file named *foo_test.go*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都写在以 *_test.go* 结尾的文件中。如果您正在对 *foo.go* 进行测试，请将测试放在名为 *foo_test.go* 的文件中。
- en: Test functions start with the word `Test` and take in a single parameter of
    type `*testing.T`. By convention, this parameter is named `t`. Test functions
    do not return any values. The name of the test (apart from starting with the word
    “Test”) is meant to document what you are testing, so pick something that explains
    what you are testing. When writing unit tests for individual functions, the convention
    is to name the unit test `Test` followed by the name of the function. When testing
    unexported functions, some people use an underscore between the word `Test` and
    the name of the function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数以单参数 `*testing.T` 开头。按照惯例，这个参数被命名为 `t`。测试函数不返回任何值。测试的名称（除了以单词“Test”开头之外）旨在说明您正在测试什么，请选择一个能够解释您正在测试内容的名称。当为单个函数编写单元测试时，惯例是将单元测试命名为
    `Test` 后跟函数名。在测试未导出的函数时，有些人在单词“Test”和函数名之间使用下划线。
- en: Also note that you use standard Go code to call the code being tested and to
    validate that the responses are as expected. When there’s an incorrect result,
    you report the error with the `t.Error` method, which works like the `fmt.Print`
    function. You’ll see other error-reporting methods in a bit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，您使用标准的 Go 代码调用正在测试的代码，并验证响应是否符合预期。当结果不正确时，使用 `t.Error` 方法报告错误，其工作方式类似于
    `fmt.Print` 函数。稍后您将看到其他报告错误的方法。
- en: 'You’ve just seen the library portion of Go’s test support. Now let’s take a
    look at the tooling. Just as `go build` builds a binary and `go run` runs a program,
    the command `go test` runs the test functions in the current directory:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的测试支持分为两部分：库和工具。标准库中的 `testing` 包提供了编写测试所需的类型和函数，而随 Go 捆绑的 `go test` 工具则运行您的测试并生成报告。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It looks like you found a bug in your code. Taking a second look at `addNumbers`,
    you see that you are adding `x` to `x`, not `x` to `y`. Let’s change the code
    and rerun the test to verify that the bug is fixed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来你在代码中发现了一个bug。仔细查看`addNumbers`，你会发现你正在将`x`加到`x`，而不是加到`y`。让我们更改代码并重新运行测试以验证bug是否已修复：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `go test` command allows you to specify which packages to test. Using `./...`
    for the package name specifies that you want to run tests in the current directory
    and all subdirectories of the current directory. Include a `-v` flag to get verbose
    testing output.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`go test`命令允许你指定要测试的包。使用`./...`作为包名指定你想在当前目录及其所有子目录中运行测试。包含`-v`标志以获取详细的测试输出。'
- en: Reporting Test Failures
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告测试失败
- en: There are several methods on `*testing.T` for reporting test failures. You’ve
    already seen `Error`, which builds a failure description string out of a comma-separated
    list of values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.T`上有几种报告测试失败的方法。你已经看到了`Error`，它通过逗号分隔的值构建一个失败描述字符串。'
- en: 'If you’d rather use a `Printf`-style formatting string to generate your message,
    use the `Errorf` method instead:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用`Printf`风格的格式化字符串来生成你的消息，请改用`Errorf`方法：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While `Error` and `Errorf` mark a test as failed, the test function continues
    running. If you think a test function should stop processing as soon as a failure
    is found, use the `Fatal` and `Fatalf` methods. The `Fatal` method works like
    `Error`, and the `Fatalf` method works like `Errorf`. The difference is that the
    test function exits immediately after the test failure message is generated. Note
    that this doesn’t exit *all* tests; any remaining test functions will execute
    after the current test function exits.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Error`和`Errorf`标记一个测试为失败，但测试函数会继续运行。如果你认为一个测试函数应该在发现失败后立即停止处理，可以使用`Fatal`和`Fatalf`方法。`Fatal`方法的工作方式类似于`Error`，而`Fatalf`方法的工作方式类似于`Errorf`。不同之处在于，在生成测试失败消息后，测试函数立即退出。请注意，这并不会退出*所有*测试；当前测试函数退出后，任何剩余的测试函数将继续执行。
- en: When should you use `Fatal`/`Fatalf` and when should you use `Error`/`Errorf`?
    If the failure of a check in a test means that further checks in the same test
    function will always fail or cause the test to panic, use `Fatal` or `Fatalf`.
    If you are testing several independent items (such as validating fields in a struct),
    then use `Error` or `Errorf` so you can report many problems at once. This makes
    it easier to fix multiple problems without rerunning your tests over and over.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该使用`Fatal`/`Fatalf`，何时应该使用`Error`/`Errorf`？如果测试中的某个检查失败意味着后续检查总会失败或导致测试崩溃，请使用`Fatal`或`Fatalf`。如果你正在测试几个独立的项目（例如验证结构体中的字段），则使用`Error`或`Errorf`，这样你可以一次报告多个问题。这样可以更轻松地修复多个问题，而无需反复运行测试。
- en: Setting Up and Tearing Down
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和拆除
- en: 'Sometimes you have some common state that you want to set up before any tests
    run and remove when testing is complete. Use a `TestMain` function to manage this
    state and run your tests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你有一些通用状态需要在所有测试运行之前设置并在测试完成后移除。使用`TestMain`函数来管理这些状态并运行你的测试：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both `TestFirst` and `TestSecond` refer to the package-level variable `testTime`.
    Assume that it needs to be initialized in order for the tests to run properly.
    You declare a function called `TestMain` with a parameter of type `*testing.M`.
    If there’s a function named `TestMain` in a package, `go test` calls it instead
    of the test functions. It is the responsibility of the `TestMain` function to
    set up any state that’s necessary to make the tests in the package run correctly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestFirst`和`TestSecond`都引用了包级别变量`testTime`。假设需要初始化它以便测试正确运行。你声明一个名为`TestMain`的函数，参数类型为`*testing.M`。如果包中有一个名为`TestMain`的函数，`go
    test`将调用它而不是测试函数。`TestMain`函数的责任是设置任何必要的状态，以确保包中的测试正确运行。'
- en: Once the state is configured, the `TestMain` function calls the `Run` method
    on `*testing.M`. This runs the test functions in the package. The `Run` method
    returns the exit code; `0` indicates that all tests passed. Finally, the `TestMain`
    function must call `os.Exit` with the exit code returned from `Run`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦状态配置完成，`TestMain`函数调用`*testing.M`上的`Run`方法。这将在包中运行测试函数。`Run`方法返回退出码；`0`表示所有测试通过。最后，`TestMain`函数必须使用从`Run`返回的退出码调用`os.Exit`。
- en: 'Running `go test` on this produces the output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`go test`会产生如下输出：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that `TestMain` is invoked once, not before and after each individual
    test. Also be aware that you can have only one `TestMain` per package.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`TestMain`仅在测试前后各调用一次。还要注意，每个包只能有一个`TestMain`。
- en: '`TestMain` is useful in two common situations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestMain`在两种常见情况下很有用：'
- en: When you need to set up data in an external repository, such as a database
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要在外部存储库（如数据库）中设置数据时
- en: When the code being tested depends on package-level variables that need to be
    initialized
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被测试的代码依赖于需要初始化的包级变量时
- en: As mentioned before (and will be again!), you should avoid package-level variables
    in your programs. They make it hard to understand how data flows through your
    program. If you are using `TestMain` for this reason, consider refactoring your
    code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述（并将再次提及！），你应该避免在程序中使用包级变量。这会使得理解数据如何在你的程序中流动变得困难。如果你因此而使用`TestMain`，请考虑重构你的代码。
- en: The `Cleanup` method on `*testing.T` is used to clean up temporary resources
    created for a single test. This method has a single parameter, a function with
    no input parameters or return values. The function runs when the test completes.
    For simple tests, you can achieve the same result by using a `defer` statement,
    but `Cleanup` is useful when tests rely on helper functions to set up sample data,
    as you see in [Example 15-1](#EX15_1). It’s fine to call `Cleanup` multiple times.
    Just like `defer`, the functions are invoked in last-added, first-called order.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.T`上的`Cleanup`方法用于清理为单个测试创建的临时资源。此方法有一个参数，即没有输入参数或返回值的函数。该函数在测试完成时运行。对于简单的测试，你可以通过使用`defer`语句达到相同的结果，但在测试依赖于设置示例数据的辅助函数时，`Cleanup`非常有用，就像你在[Example 15-1](#EX15_1)中看到的那样。可以多次调用`Cleanup`是可以的。与`defer`一样，函数按照后添加的先调用的顺序执行。'
- en: Example 15-1\. Using `t.Cleanup`
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-1\. 使用`t.Cleanup`
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If your test uses temporary files, you can avoid writing cleanup code by taking
    advantage of the `TempDir` method on `*testing.T`. This method creates a new temporary
    directory every time it is invoked and returns the full path of the directory.
    It also registers a handler with `Cleanup` to delete the directory and its contents
    when the test has completed. You can use it to rewrite the previous example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试使用临时文件，你可以通过利用`*testing.T`上的`TempDir`方法而避免编写清理代码。每次调用时，该方法都会创建一个新的临时目录，并返回目录的完整路径。它还会在`Cleanup`上注册一个处理程序，以便在测试完成时删除目录及其内容。你可以用它来重新编写前面的示例：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Testing with Environment Variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量进行测试
- en: 'It’s a common (and very good) practice to configure applications with environment
    variables. To help you test your environment-variable–parsing code, Go provides
    a helper method on `testing.T`. Call `t.Setenv()` to register a value for an environment
    variable for your test. Behind the scenes, it calls `Cleanup` to revert the environment
    variable to its previous state when the test exits:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序使用环境变量是一种常见（并且非常好的）做法。为了帮助你测试环境变量解析代码，Go提供了`testing.T`上的一个辅助方法。调用`t.Setenv()`来为你的测试注册一个环境变量的值。在幕后，它调用`Cleanup`在测试结束时将环境变量恢复到先前的状态：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While it is good to use environment variables to configure your application,
    it is also good to make sure that most of your code is entirely unaware of them.
    Be sure to copy the values of environment variables into configuration structs
    before your program starts its work, in your `main` function or soon afterward.
    Doing so makes it easier to reuse and test code, since *how* the code is configured
    has been abstracted away from *what* the code is doing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用环境变量来配置你的应用程序是好的，但确保大部分代码完全不知道它们也是很重要的。确保在程序开始工作时，在你的`main`函数或之后尽快将环境变量的值复制到配置结构体中。这样做可以使代码更易于重用和测试，因为代码的配置方式已经从代码执行的内容中抽象出来。
- en: Rather than writing this code yourself, you should strongly consider using a
    third-party configuration library, like [Viper](https://oreil.ly/-RUA-) or [envconfig](https://oreil.ly/rhGYk).
    Also, look at [GoDotEnv](https://oreil.ly/sN2Sp) as a way to store environment
    variables in *.env* files for development or continuous integration machines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与其自己编写此代码，你应该强烈考虑使用第三方配置库，比如[Viper](https://oreil.ly/-RUA-)或[envconfig](https://oreil.ly/rhGYk)。此外，查看[GoDotEnv](https://oreil.ly/sN2Sp)，它可以将环境变量存储在*.env*文件中，供开发或持续集成机器使用。
- en: Storing Sample Test Data
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储样本测试数据
- en: As `go test` walks your source code tree, it uses the current package directory
    as the current working directory. If you want to use sample data to test functions
    in a package, create a subdirectory named *testdata* to hold your files. Go reserves
    this directory name as a place to hold test files. When reading from *testdata*,
    always use a relative file reference. Since `go test` changes the current working
    directory to the current package, each package accesses its own *testdata* via
    a relative file path.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`go test`遍历你的源代码树时，它将当前包目录作为当前工作目录。如果你想在一个包中使用样本数据来测试函数，请创建一个名为*testdata*的子目录来保存你的文件。Go
    将此目录名称保留为一个用于保存测试文件的地方。在从*testdata*读取时，始终使用相对文件引用。由于`go test`将当前工作目录更改为当前包，因此每个包通过相对文件路径访问其自己的*testdata*。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The [`text` package](https://oreil.ly/lV_KJ) in the *sample_code* directory
    of the Chapter 15 repository demonstrates how to use *testdata*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 15 章的代码库](https://oreil.ly/lV_KJ)的*sample_code*目录中，`text` 包演示了如何使用*testdata*。
- en: Caching Test Results
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存测试结果
- en: Just as you learned in [Chapter 10](ch10.html#unique_chapter_id_10) that Go
    caches compiled packages if they haven’t changed, Go also caches test results
    when running tests across multiple packages if they have passed and their code
    hasn’t changed. The tests are recompiled and rerun if you change any file in the
    package or in the *testdata* directory. You can also force tests to always run
    if you pass the flag `-count=1` to `go test`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 10 章](ch10.html#unique_chapter_id_10)中学到的，如果 Go 编译的包没有改变，它会缓存这些编译后的包，同样地，当跨多个包运行测试并且它们通过且代码没有改变时，Go
    也会缓存测试结果。如果你改变了包中的任何文件或*testdata*目录中的文件，则会重新编译并重新运行测试。如果你希望测试始终运行，请向`go test`传递`-count=1`标志。
- en: Testing Your Public API
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的公共 API
- en: The tests that you’ve written are in the same package as the production code.
    This allows you to test both exported and unexported functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的测试与生产代码位于同一个包中。这允许你测试导出和未导出的函数。
- en: If you want to test just the public API of your package, Go has a convention
    for specifying this. You still keep your test source code in the same directory
    as the production source code, but you use `packagename_test` for the package
    name. Let’s redo the initial test case, using an exported function instead. You
    can find the code in the *sample_code/pubadder* directory in the [Chapter 15 repository](https://oreil.ly/PNRJx).
    If you have the following function in the `pubadder` package
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想测试包的公共 API，Go 有一种约定可以指定这样做。你仍然将测试源代码放在与生产源代码相同的目录中，但是包名使用`packagename_test`。让我们重新做初始测试用例，使用一个导出的函数来代替。你可以在[第
    15 章的代码库](https://oreil.ly/PNRJx)的*sample_code/pubadder*目录中找到这段代码。如果你的`pubadder`包中有如下函数：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'then you can test it as public API by using the following code in a file in
    the `pubadder` package named *adder_public_test.go*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`pubadder`包的名为*adder_public_test.go*的文件中使用以下代码测试它：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the package name for the test file is `pubadder_test`. You have
    to import `github.com/learning-go-book-2e/ch15/sample_code/pubadder` even though
    the files are in the same directory. To follow the convention for naming tests,
    the test function name matches the name of the `AddNumbers` function. Also note
    that you use `pubadder.AddNumbers`, since you are calling an exported function
    in a different package.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试文件的包名为`pubadder_test`。即使文件位于同一个目录中，你也必须导入`github.com/learning-go-book-2e/ch15/sample_code/pubadder`。为了遵循测试命名的约定，测试函数名与`AddNumbers`函数的名称匹配。还要注意，你要使用`pubadder.AddNumbers`，因为你在不同包中调用一个导出函数。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are typing this code in by hand, you’ll need to create a module with
    a *go.mod* file that has the module declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是手动输入这段代码，你需要创建一个带有模块声明的*go.mod*文件：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: and that puts the source code in the *sample_code/pubadder* directory within
    the module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将源代码放在模块内的*sample_code/pubadder*目录中。
- en: Just as you can call exported functions from within a package, you can test
    your public API from a test that is in the same package as your source code. The
    advantage of using the `_test` suffix in the package name is that it lets you
    treat your tested package as a “black box.” You are forced to interact with it
    only via its exported functions, methods, types, constants, and variables. Also
    be aware that you can have test source files with both package names intermixed
    in the same source directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您可以从包内调用导出函数一样，您可以从与源代码相同包中的测试中测试您的公共 API。在包名称中使用 `_test` 后缀的优势在于，它让您将测试的包视为“黑盒”。您只能通过其导出的函数、方法、类型、常量和变量与其交互。还要注意，您可以在同一源目录中混合使用包名称交错的测试源文件。
- en: Using go-cmp to Compare Test Results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 go-cmp 进行比较测试结果
- en: 'Writing a thorough comparison of a compound type’s two instances can be verbose.
    While you can use `reflect.DeepEqual` to compare structs, maps, and slices, there’s
    a better way. Google released a third-party module called [`go-cmp`](https://oreil.ly/9bWJf)
    that does the comparison for you and returns a detailed description of what does
    not match. Let’s see how it works by defining a simple `struct` and a factory
    function that populates it. You can find this code in the *sample_code/cmp* directory
    in the [Chapter 15 repository](https://oreil.ly/PNRJx):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编写复合类型两个实例的彻底比较可能会很啰嗦。虽然您可以使用 `reflect.DeepEqual` 比较结构体、映射和切片，但有更好的方法。Google
    发布了一个名为 [`go-cmp`](https://oreil.ly/9bWJf) 的第三方模块，它可以为您进行比较，并返回不匹配之处的详细描述。让我们看看它是如何工作的，通过定义一个简单的
    `struct` 和一个填充它的工厂函数。您可以在 [第 15 章仓库](https://oreil.ly/PNRJx) 的 *sample_code/cmp*
    目录中找到这段代码：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In your test file, you need to import `github.com/google/go-cmp/cmp`, and your
    test function looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的测试文件中，您需要导入 `github.com/google/go-cmp/cmp`，并且您的测试函数看起来像这样：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `cmp.Diff` function takes in the expected output and the output that was
    returned by the function that you’re testing. It returns a string that describes
    any mismatches between the two inputs. If the inputs match, it returns an empty
    string. You assign the output of the `cmp.Diff` function to a variable called
    `diff` and then check whether `diff` is an empty string. If it is not, an error
    occurred.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp.Diff` 函数接受预期输出和由您测试的函数返回的输出。它返回一个描述两个输入之间任何不匹配的字符串。如果输入匹配，则返回空字符串。您将 `cmp.Diff`
    函数的输出分配给名为 `diff` 的变量，然后检查 `diff` 是否为空字符串。如果不是，则发生了错误。'
- en: 'When you build and run the test, you’ll see the output that `go-cmp` generates
    when two struct instances don’t match:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建并运行测试时，您将看到 `go-cmp` 在两个结构实例不匹配时生成的输出：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The lines with a `-` and `+` indicate the fields whose values differ. The test
    failed because the dates didn’t match. This is a problem because you can’t control
    what date is assigned by the `CreatePerson` function. You have to ignore the `DateAdded`
    field. You do that by specifying a comparator function. Declare the function as
    a local variable in your test:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 和 `+` 开头的行指示其值不同的字段。测试失败是因为日期不匹配。这是一个问题，因为您无法控制 `CreatePerson` 函数分配的日期。您需要忽略
    `DateAdded` 字段。通过指定一个比较函数来实现。在测试中将该函数声明为局部变量：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pass a function to the `cmp.Comparer` function to create a customer comparator.
    The function that’s passed in must have two parameters of the same type and return
    a `bool`. It also must be symmetric (the order of the parameters doesn’t matter),
    deterministic (it always returns the same value for the same inputs), and pure
    (it must not modify its parameters). In your implementation, you are comparing
    the `Name` and `Age` fields and ignoring the `DateAdded` field.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数传递给 `cmp.Comparer` 函数以创建一个自定义比较器。传入的函数必须有两个相同类型的参数，并返回一个 `bool` 值。它还必须是对称的（参数的顺序不重要）、确定性的（对于相同的输入始终返回相同的值）和纯粹的（不修改其参数）。在您的实现中，您正在比较
    `Name` 和 `Age` 字段，并忽略 `DateAdded` 字段。
- en: 'Then change your call to `cmp.Diff` to include `comparer`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将您的调用更改为 `cmp.Diff`，包括 `comparer`：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is only a quick preview of the most useful features in `go-cmp`. Check
    its [documentation](https://oreil.ly/rmiWO) to learn more about how to control
    what is compared and the output format.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `go-cmp` 中最有用的功能的快速预览。查看其 [文档](https://oreil.ly/rmiWO) 了解更多关于如何控制比较和输出格式的信息。
- en: Running Table Tests
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行表测试
- en: Most of the time, it takes more than a single test case to validate that a function
    is working correctly. You could write multiple test functions to validate your
    function or multiple tests within the same function, but you’ll find that a great
    deal of the testing logic is repetitive. You set up supporting data and functions,
    specify inputs, check the outputs, and compare to see if they match your expectations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，验证函数正确工作需要多个测试案例。你可以编写多个测试函数来验证函数，或者在同一个函数中编写多个测试，但你会发现大部分测试逻辑是重复的。你设置支持数据和函数，指定输入，检查输出，并比较它们是否符合你的预期。
- en: 'Rather than writing this over and over, you can take advantage of a pattern
    called *table tests*. Let’s take a look at a sample. You can find this code in
    the *sample_code/table* directory in the [Chapter 15 repository](https://oreil.ly/PNRJx).
    Assume you have the following function in the `table` package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一遍又一遍地写这个，你可以利用称为*表测试*的模式。让我们看一个样例。你可以在[第15章存储库](https://oreil.ly/PNRJx)的*sample_code/table*目录中找到这段代码。假设你在`table`包中有以下函数：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To test this function, you need to check the different branches, trying out
    inputs that return valid results, as well as inputs that trigger errors. You could
    write code like this, but it’s very repetitive:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个函数，你需要检查不同的分支，尝试返回有效结果的输入，以及触发错误的输入。你可以编写这样的代码，但这样做非常重复：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s replace this repetition with a table test. First, you declare a slice
    of anonymous structs. The struct contains fields for the name of the test, the
    input parameters, and the return values. Each entry in the slice represents another
    test:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用表测试替换这种重复。首先，你声明一个匿名结构体切片。结构体包含测试的名称、输入参数和返回值字段。切片中的每个条目代表另一个测试：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, loop over each test case in `data`, invoking the `Run` method each time.
    This is the line that does the magic. You pass two parameters to `Run`, a name
    for the subtest and a function with a single parameter of type `*testing.T`. Inside
    the function, you call `DoMath` by using the fields of the current entry in `data`,
    using the same logic over and over. When you run these tests, you’ll see that
    not only do they pass, but when you use the `-v` flag, each subtest also now has
    a name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，循环处理`data`中的每个测试案例，每次调用`Run`方法。这是实现魔法的地方。你向`Run`传递两个参数，子测试的名称和一个参数类型为`*testing.T`的函数。在函数内部，你使用`data`当前条目的字段调用`DoMath`，一遍又一遍地使用相同的逻辑。运行这些测试时，你会发现它们不仅通过了测试，而且当你使用`-v`标志时，每个子测试现在也有了名称：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Comparing error messages can be fragile, because there may not be any compatibility
    guarantees on the message text. The function that you are testing uses `errors.New`
    and `fmt.Errorf` to make errors, so the only option is to compare the messages.
    If an error has a custom type or a named sentinel error, use `errors.Is` or `errors.As`
    to check that the correct error is returned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 比较错误消息可能不够稳定，因为消息文本可能没有兼容性保证。你正在测试的函数使用`errors.New`和`fmt.Errorf`生成错误，因此唯一的选择是比较消息。如果错误具有自定义类型或命名的哨兵错误，请使用`errors.Is`或`errors.As`来检查返回的正确错误。
- en: Running Tests Concurrently
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行测试
- en: 'By default, unit tests are run sequentially. Since each unit test is supposed
    to be independent from every other unit test, they make ideal candidates for concurrency.
    To make a unit test run concurrently with other tests, call the `Parallel` method
    on `*testing.T` as the first line in your test:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，单元测试是顺序运行的。由于每个单元测试应该独立于其他单元测试，它们是并发的理想候选者。要使单元测试与其他测试同时运行，请在测试的第一行调用`*testing.T`的`Parallel`方法：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Parallel tests run concurrently with other tests marked as parallel.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并行测试与其他标记为并行的测试同时运行。
- en: The advantage of parallel tests is that it can speed up long-running test suites.
    There are some disadvantages, though. If you have multiple tests that rely on
    the same shared mutable state, do not mark them as parallel, because you will
    get inconsistent results. (But after all of my warnings, you don’t have any shared
    mutable state in your application, right?) Also be aware that your test will panic
    if you mark it as parallel and use the `Setenv` method in your test function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 并行测试的优势在于可以加快长时间运行的测试套件。但也有一些缺点。如果有多个测试依赖于相同的共享可变状态，请不要标记它们为并行，因为你会得到不一致的结果。（但在所有这些警告之后，你的应用程序中没有共享可变状态，对吧？）还要注意，如果你标记为并行并在测试函数中使用`Setenv`方法，你的测试将会panic。
- en: 'Be careful when running table tests in parallel. When table tests run in parallel,
    it’s just as you saw in [“Goroutines, for Loops, and Varying Variables”](ch12.html#shared_var_goroutine),
    where you launched multiple goroutines within a `for` loop. If you run this example
    using Go 1.21 or earlier (or on Go 1.22 or later with the Go version set to 1.21
    or earlier in the `go` directive in the *go.mod* file), a reference to the variable
    `d` is shared by all the parallel tests, so they all see the same value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行运行表格测试时要小心。当表格测试并行运行时，情况就像你在 [“Goroutines, for Loops, and Varying Variables”](ch12.html#shared_var_goroutine)
    中看到的一样，你在 `for` 循环内启动了多个 goroutine。如果你在 Go 1.21 或更早版本中运行此示例（或在 Go 1.22 或更高版本中，但在
    *go.mod* 文件的 `go` 指令中设置了 Go 版本为 1.21 或更早版本），则所有并行测试共享变量 `d` 的引用，因此它们都看到相同的值：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can run this code on [The Go Playground](https://oreil.ly/b0S4n) or in
    the *sample_code/parallel* directory in the [Chapter 15 repository](https://oreil.ly/PNRJx).
    Take a look at the output and you’ll see that you test the last value in the table
    test three times:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [The Go Playground](https://oreil.ly/b0S4n) 上或者在 [第 15 章的代码库](https://oreil.ly/PNRJx)
    的 *sample_code/parallel* 目录中运行这段代码。看一下输出结果，你会发现测试表中的最后一个值被测试了三次：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This problem is common enough that Go 1.20 added a `go vet` check for this problem.
    When you run `go vet` on this code, you get the message `loop variable d captured
    by func literal` on each line where `d` is captured.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很常见，以至于 Go 1.20 版本中添加了 `go vet` 检查此问题的功能。当你在这段代码上运行 `go vet` 时，会得到消息 `loop
    variable d captured by func literal`，其中每一行都捕获了变量 `d`。
- en: 'The `for` loop changes in Go 1.22 or later resolve this issue. If you cannot
    use Go 1.22, you can avoid this bug by shadowing `d` within the `for` loop before
    invoking `t.Run`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 1.22 或更高版本中，`for` 循环的变化解决了这个问题。如果你不能使用 Go 1.22，你可以通过在调用 `t.Run` 之前在 `for`
    循环内部屏蔽 `d` 来避免这个 bug：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that you have a way to run lots of tests, you’ll learn about code coverage
    to find out what your tests are testing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了运行大量测试的方法，你将了解代码覆盖率以查找你的测试是否完整。
- en: Checking Your Code Coverage
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查你的代码覆盖率
- en: Code coverage is a very useful tool for knowing whether you’ve missed any obvious
    cases. However, reaching 100% code coverage doesn’t guarantee that there aren’t
    bugs in your code for some inputs. First you’ll see how `go test` displays code
    coverage and then you’ll look at the limitations of relying on code coverage alone.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个非常有用的工具，可以帮助你了解是否遗漏了任何明显的情况。但是，达到 100% 的代码覆盖率并不保证你的代码对于某些输入没有 bug。首先，你会看到
    `go test` 如何显示代码覆盖率，然后再看看仅依赖代码覆盖率的局限性。
- en: 'Adding the `-cover` flag to the `go test` command calculates coverage information
    and includes a summary in the test output. If you include a second flag `-coverprofile`,
    you can save the coverage information to a file. Let’s go back to the *sample_code/table*
    directory in the [Chapter 15 repository](https://oreil.ly/PNRJx) and gather code
    coverage information:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `go test` 命令中添加 `-cover` 标志可以计算覆盖率信息，并在测试输出中包含摘要。如果你包含第二个标志 `-coverprofile`，你可以将覆盖率信息保存到一个文件中。让我们回到
    [第 15 章代码库](https://oreil.ly/PNRJx) 的 *sample_code/table* 目录中，收集代码覆盖率信息：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run your table test with code coverage, the test output now includes
    a line that indicates the amount of test code coverage, 87.5%. That’s good to
    know, but it’d be more useful if you could see what you missed. The `cover` tool
    included with Go generates an HTML representation of your source code with that
    information:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用代码覆盖来运行你的表格测试，测试输出现在会包括一行指示测试代码覆盖率的信息，例如 87.5%。这是个好消息，但更有用的是你可以看到你漏掉了什么。Go
    自带的 `cover` 工具会生成一个包含这些信息的源代码的 HTML 表示：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you run it, your web browser should open and show you a page that looks
    like [Figure 15-1](#initial_code_coverage).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，你的网页浏览器应该会打开，并显示一个看起来像是 [Figure 15-1](#initial_code_coverage) 的页面。
- en: 'Every file that’s tested appears in the combo box in the upper left. The source
    code is in one of three colors. Gray is used for lines of code that aren’t testable,
    green is used for code that’s been covered by a test, and red is used for code
    that hasn’t been tested. (The reliance on color is unfortunate for readers of
    the print edition and those who have red-green color blindness. If you are unable
    to see the colors, the lighter gray is the covered lines.) From looking at this,
    you can see that you didn’t write a test to cover the default case, when a bad
    operator is passed to your function. Add that case to your slice of test cases:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个被测试的文件都显示在左上角的组合框中。源代码有三种颜色。灰色用于不可测试的代码行，绿色用于已被测试覆盖的代码，红色用于未被测试的代码。（依赖颜色对于打印版的读者和红绿色盲是不幸的。如果你无法看到颜色，浅灰色表示被覆盖的行。）通过查看这些内容，你会发现你没有编写测试来覆盖默认情况，即当函数传递给它一个错误的操作符时。在你的测试案例中添加这种情况：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you rerun `go test -v -cover -coverprofile=c.out` and `go tool cover` `-html=c.out`,
    you see in [Figure 15-2](#final_code_coverage) that the final line is covered
    and you have 100% test code coverage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新运行 `go test -v -cover -coverprofile=c.out` 和 `go tool cover -html=c.out`
    时，你会在 [图 15-2](#final_code_coverage) 中看到最后一行被覆盖，并且你拥有100%的测试代码覆盖率。
- en: '![Initial Code Coverage](assets/lgo2_1501.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![初始代码覆盖率](assets/lgo2_1501.png)'
- en: Figure 15-1\. Initial code coverage
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1\. 初始代码覆盖率
- en: '![Final Code Coverage](assets/lgo2_1502.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![最终代码覆盖率](assets/lgo2_1502.png)'
- en: Figure 15-2\. Final code coverage
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-2\. 最终代码覆盖率
- en: 'Code coverage is a great thing, but it’s not enough. There’s actually a bug
    in your code, even though you have 100% coverage. Have you noticed it? If not,
    add another test case and rerun your tests:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一件好事，但这并不足够。实际上，你的代码中有一个bug，即使你已经达到了100%的覆盖率。你注意到了吗？如果没有，添加另一个测试案例并重新运行你的测试：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the error:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到错误：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your case for multiplication has a typo. It adds the numbers together instead
    of multiplying them. (Beware the dangers of copy-and-paste coding!) Fix the code,
    rerun `go test -v -cover -coverprofile=c.out` and `go tool cover -html=c.out`,
    and you’ll see that the tests pass again.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的乘法案例有一个拼写错误。它将数字相加而不是相乘。（小心复制粘贴编码的危险！）修复代码，重新运行 `go test -v -cover -coverprofile=c.out`
    和 `go tool cover -html=c.out`，你会看到测试再次通过。
- en: Warning
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Code coverage is necessary but not sufficient. You can have 100% code coverage
    and still have bugs in your code!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是必要的，但并不充分。你可以拥有100%的代码覆盖率，但代码中仍然可能存在bug！
- en: Fuzzing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试
- en: One of the most important lessons that every developer eventually learns is
    that all data is suspect. No matter how well specified a data format is, you will
    eventually have to process input that doesn’t match what you expect. This doesn’t
    happen for only malicious reasons. Data can be corrupted in transit, in storage,
    and even in memory. Programs that process data might have bugs, and specifications
    for data formats always have corner cases that can be interpreted differently
    by different developers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者最终都会学到的最重要的一课是所有数据都是可疑的。无论数据格式有多么精确，你最终都将不得不处理不符合预期的输入。这并不仅仅是因为恶意原因。数据可能在传输、存储甚至内存中损坏。处理数据的程序可能存在bug，而数据格式的规范总是会有一些边缘情况，不同的开发者可能会以不同的方式解释。
- en: Even when developers do the work of writing good unit tests, it’s impossible
    to think of everything. As you’ve seen, even 100% unit test code coverage is no
    guarantee that your code is bug free. You need to supplement unit tests with generated
    data that could break your program in ways you didn’t anticipate. That’s where
    fuzzing helps.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使开发者编写了良好的单元测试，也不可能考虑到所有情况。正如你所见，即使单元测试代码达到100%的覆盖率，也不能保证代码没有错误。你需要用可能会导致程序以意想不到的方式崩溃的生成数据来补充单元测试。这就是模糊测试的作用。
- en: '*Fuzzing* is a technique for generating random data and submitting it to code
    to see whether it properly handles unexpected input. The developer can provide
    a *seed corpus* or set of known good data, and the fuzzer uses that as a basis
    for generating bad input. Let’s see how to use the fuzzing support in Go’s testing
    tools to discover additional test cases.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fuzzing* 是一种生成随机数据并将其提交给代码以查看其是否正确处理意外输入的技术。开发者可以提供一个*种子语料库*或一组已知的良好数据，模糊器将以此为基础生成有问题的输入。让我们看看如何利用Go的测试工具中的模糊支持来发现额外的测试用例。'
- en: 'Assume that you are writing a program to processes data files. You can find
    the code for this example [on GitHub](https://oreil.ly/7dx6i). You are sending
    a list of strings but want to efficiently allocate memory, so the number of strings
    in a file is sent as the first line, while the remaining lines are the lines of
    text. Here’s the sample function for processing this data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个处理数据文件的程序。您可以在[Github上找到此示例的代码](https://oreil.ly/7dx6i)。您正在发送一个字符串列表，但希望有效地分配内存，因此文件中的字符串数量作为第一行发送，而剩余的行是文本行。以下是处理此数据的示例函数：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You use a `bufio.Scanner` to read line-by-line from an `io.Reader`. If there’s
    no data to be read, an error is returned. You then read the first line and attempt
    to convert it to an int named `count`. If you can’t, an error is returned. Next,
    you allocate the memory for your slice of strings, and read `count` number of
    lines from the scanner. If there aren’t enough lines, an error is returned. If
    all goes well, you return the lines you read.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bufio.Scanner`从`io.Reader`逐行读取数据。如果没有数据可读，则返回错误。然后读取第一行，并尝试将其转换为名为`count`的整数。如果无法转换，则返回错误。接下来，为字符串切片分配内存，并从扫描器中读取`count`行。如果行数不足，则返回错误。如果一切顺利，返回读取的行数。
- en: 'A unit test has already been written to validate the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 已编写单元测试以验证代码：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The unit test has 100% line coverage for `ParseData`, handling all its error
    cases. You might think the code is ready for production, but let’s see if fuzzing
    can help you discover errors that you hadn’t considered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试已为`ParseData`实现了100%的代码行覆盖率，处理了所有错误情况。您可能认为代码已准备好投入生产，但让我们看看模糊测试是否可以帮助您发现未考虑的错误。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware that fuzzing uses a lot of resources. A fuzz test can allocate (or
    attempt to allocate) many gigabytes of memory and might write several gigabytes
    of data to your local disk. If you are running something else on the same machine
    at the same time as a fuzz test, don’t be surprised if it slows down.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模糊测试会消耗大量资源。模糊测试可以分配（或尝试分配）许多吉比字节的内存，并且可能向本地磁盘写入数吉比字节的数据。如果在进行模糊测试的同时在同一台机器上运行其他程序，如果速度变慢也不要感到惊讶。
- en: 'You start by writing a fuzz test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编写一个模糊测试：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A fuzz test looks similar to a standard unit test. The function name starts
    with `Fuzz`, the only parameter is of type `*testing.F`, and it has no return
    values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试看起来与标准单元测试类似。函数名称以`Fuzz`开头，唯一参数类型为`*testing.F`，并且没有返回值。
- en: 'Next, you set up a seed corpus, which is composed of one or more sets of sample
    data. The data can run successfully, error out, or even panic. The important things
    are that you know how your program behaves when this data is provided and that
    this behavior is accounted for by your fuzz test. These samples are mutated by
    the fuzzer to generate bad inputs. This example uses only a single field of data
    for each entry (a slice of bytes), but you can have as many fields as needed.
    The fields in a corpus entry are currently limited to only certain types:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，设置种子语料库，它由一个或多个样本数据集组成。数据可以成功运行、出错，甚至崩溃。重要的是，您知道在提供这些数据时程序的行为方式，并且您的模糊测试已经考虑到了这种行为。这些样本由模糊器变异以生成错误输入。本示例每个条目仅使用单个数据字段（字节切片），但可以根据需要有多个字段。目前，语料库条目的字段仅限于某些类型：
- en: Any integer type (including unsigned types, `rune`, and `byte`)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何整数类型（包括无符号类型，`rune`和`byte`）
- en: Any floating-point type
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何浮点类型
- en: '`bool`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`'
- en: '`string`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`'
- en: '`[]byte`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]byte`'
- en: 'Each entry in the corpus is passed to the `Add` method on the `*testing.F`
    instance. In the example, you have a slice of bytes for each entry:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语料库条目都会传递给`*testing.F`实例的`Add`方法。在示例中，每个条目都有一个字节切片：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the function being fuzzed needed an `int` and a `string`, the call to `Add`
    would look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被模糊化的函数需要一个`int`和一个`string`，则调用`Add`看起来像这样：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s a runtime error to pass a value of an invalid type to `Add`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将无效类型的值传递给`Add`是运行时错误。
- en: Next you call the `Fuzz` method on your `*testing.F` instance. This looks a
    bit like a call to `Run` when writing a table test in a standard unit test. `Fuzz`
    takes in a single parameter, a function whose first parameter is of type `*testing.T`
    and whose remaining parameters exactly match the types, order, and count of the
    values that were passed in to `Add`. This also specifies the type of data generated
    by the fuzzing engine during fuzzing. There’s no way for the Go compiler to enforce
    this constraint, so it’s a runtime error if the convention is not followed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你在你的`*testing.F`实例上调用`Fuzz`方法。在编写标准单元测试中的表测试时，这看起来有点像对`Run`的调用。`Fuzz`接受一个参数，一个函数，其第一个参数类型为`*testing.T`，其余参数的类型、顺序和数量与传递给`Add`的值完全匹配。这还指定了在模糊测试期间由模糊引擎生成的数据类型。Go编译器无法强制执行此约束，因此如果不遵循约定，这将是运行时错误。
- en: 'Finally, let’s look at the body of the fuzz target. Remember, fuzzing is used
    to find cases where bad input is not handled correctly. Since the input is randomly
    generated, you can’t write tests that have knowledge of what the output should
    be. Instead, you have to use test conditions that will be true for all inputs.
    In the case of `ParseData`, you can check for two things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看模糊目标的内容。记住，模糊测试用于找到未正确处理坏输入的情况。由于输入是随机生成的，您不能编写对输出内容有了解的测试。相反，您必须使用对所有输入都为真的测试条件。对于`ParseData`，您可以检查两件事：
- en: Does the code return an error for bad input, or does it panic?
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当错误输入时，代码是否返回错误或会发生恐慌？
- en: If you convert the slice of strings back to a slice of bytes and re-parse it,
    do you get the same result?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将字符串切片转换回字节切片并重新解析，您会得到相同的结果吗？
- en: 'Let’s see what happens when you run the fuzz test:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行模糊测试时会发生什么：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you don’t specify the `-fuzz` flag, your fuzz tests will be treated like
    unit tests and will be run against the seed corpus. Only a single fuzz test can
    be fuzzed at a time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定`-fuzz`标志，您的模糊测试将被视为单元测试，并将针对种子语料库运行。每次只能对一个模糊测试进行模糊处理。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to get the full experience, delete the contents of the *testdata/fuzz/FuzzParseData*
    directory. This will cause the fuzzer to generate new seed corpus entries. Since
    the fuzzer generates random input, your samples might be different from the ones
    shown. The different entries will likely produce similar errors, though maybe
    not in the same order.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获得完整体验，请删除 *testdata/fuzz/FuzzParseData* 目录的内容。这将导致模糊器生成新的种子语料库条目。由于模糊器生成随机输入，您的样本可能与显示的不同。不过，不同的条目可能会产生类似的错误，尽管可能不是按相同顺序。
- en: The fuzz test runs for several seconds and then fails. In this case, the `go`
    command reports that it has crashed. You don’t want programs that crash, so let’s
    look at the input that was generated. Every time a test case fails, the fuzzer
    writes it to the *testdata/fuzz/TESTNAME* subdirectory in the same package as
    the failed test, adding a new entry to the seed corpus. The new seed corpus entry
    in the file now becomes a new unit test, one that was automatically generated
    by the fuzzer. It is run anytime `go test` runs the `FuzzParseData` function,
    and acts as a regression test once you fix your bug.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试运行几秒钟后失败。在这种情况下，`go`命令报告说它已崩溃。您不希望程序崩溃，所以让我们看看生成的输入。每次测试用例失败时，模糊器都会将其写入
    *testdata/fuzz/TESTNAME* 子目录，该子目录与失败的测试位于同一软件包中，添加一个新条目到种子语料库。现在文件中的新种子语料库条目成为新的单元测试，这是由模糊器自动生成的。每当运行`go
    test`运行`FuzzParseData`函数时，它作为回归测试，一旦修复错误，就会执行。
- en: 'Here are the contents of the file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件的内容：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first line is a header to indicate that this is test data for a fuzz test.
    The subsequent lines have the data that caused the failure.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个标题，指示这是模糊测试的测试数据。随后的行包含导致失败的数据。
- en: 'The failure message tells you how to isolate this failing case when you rerun
    the test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 失败消息告诉您在重新运行测试时如何隔离此失败案例：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The problem is that you are trying to allocate a slice with the capacity to
    hold 300,000,000,000 strings. That requires quite a bit more RAM than my computer
    (and probably yours) has. You need to limit the number of expected text elements
    to a reasonable number. Set the maximum number of rows to 1,000 by adding the
    following code to `ParseData` after you parse the number of expected rows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于您试图分配一个能够容纳300,000,000,000个字符串的切片。这比我的计算机（可能也比您的）的RAM要多得多。您需要限制预期文本元素的数量。通过在解析预期行数后向`ParseData`添加以下代码，将最大行数设置为1,000：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the fuzzer again to see whether it finds any more errors:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行模糊器，查看是否发现更多错误：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This time you get a fuzz result that produces a panic. Looking at the file
    generated by `go fuzz`, you see this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这次您得到一个产生恐慌的模糊结果。查看由 `go fuzz` 生成的文件，您会看到这个：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The line that’s generating the panic is shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显示产生恐慌的行在这里：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You are trying to create a slice with negative capacity, which panics. Add
    another condition to your code to look for negative numbers:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在尝试创建一个具有负容量的切片，这会导致恐慌。向您的代码添加另一个条件以查找负数：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run your fuzzer again, and it generates another error:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的模糊器，它生成了另一个错误：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Looking at the file it created, you are generating blank lines with only `\r`
    (return) characters. Blank lines are not what you expect in your input, so add
    some code to the loop that reads lines of text from the `Scanner`. You’ll check
    whether a line consists only of whitespace characters. If it does, return an error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查看它创建的文件，您正在生成仅包含 `\r`（回车）字符的空白行。空白行不是您在输入中期望的内容，因此向从 `Scanner` 中读取文本行的循环中添加一些代码。您将检查一行是否只包含空白字符。如果是，则返回错误：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run your fuzzer yet again:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行您的模糊器：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After a few minutes, no more errors are found, so hit Ctrl-C to end fuzzing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，没有发现更多错误，因此按下 Ctrl-C 结束模糊测试。
- en: Just because the fuzzer didn’t find additional issues doesn’t mean that the
    code is now bug free. However, fuzzing allowed you to automatically find some
    significant oversights in the original code. Writing fuzz tests takes practice,
    as they require a slightly different mindset than writing unit tests. Once you
    get the hang of them, they become an essential tool for validating how your code
    handles unexpected user input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为模糊器没有找到其他问题并不意味着代码现在没有错误。但是，模糊测试使您能够自动发现原始代码中的一些重大疏忽。编写模糊测试需要练习，因为它们需要比编写单元测试稍微不同的思维方式。一旦掌握它们，它们将成为验证代码如何处理意外用户输入的重要工具。
- en: Using Benchmarks
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基准测试
- en: 'Determining how fast (or slow) code runs is surprisingly difficult. Rather
    than trying to figure it out yourself, you should use the benchmarking support
    that’s built into Go’s testing framework. Let’s explore it with a function in
    the *sample_code/bench* directory in the [Chapter 15 repository](https://oreil.ly/PNRJx):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确定代码运行速度快慢是非常困难的。与其自己试图弄清楚，不如使用内置在Go测试框架中的基准测试支持。让我们通过[第 15 章的代码库](https://oreil.ly/PNRJx)中
    *sample_code/bench* 目录中的一个函数来探讨它：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function counts the number of characters in a file. It takes in two parameters,
    the name of the file and the size of the buffer that you are using to read the
    file (you’ll see the reason for the second parameter in a moment).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算文件中的字符数。它接受两个参数，文件名和用于读取文件的缓冲区大小（稍后您将看到第二个参数的原因）。
- en: 'Before seeing how fast it is, you should test your library to make sure that
    it works (it does). Here’s a simple test:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看其速度有多快之前，您应该测试您的库以确保它工作正常（确实如此）。这里是一个简单的测试：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now you can see how long it takes your file-length function to run. Your goal
    is to find out what size buffer you should use to read from the file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到运行文件长度函数需要多长时间。您的目标是找出应该用来从文件中读取的缓冲区大小。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before you spend time going down an optimization rabbit hole, be sure that you
    need to optimize. If your program is already fast enough to meet your responsiveness
    requirements and is using an acceptable amount of memory, your time is better
    spent on adding features and fixing bugs. Your business requirements determine
    what “fast enough” and “acceptable amount of memory” mean.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在您花时间深入优化之前，请确保您需要优化。如果您的程序已经足够快以满足响应要求并且使用的内存量是可接受的，则更好的选择是添加功能和修复错误。您的业务需求决定了“足够快”和“可接受的内存量”是什么意思。
- en: 'In Go, *benchmarks* are functions in your test files that start with the word
    `Benchmark` and take in a single parameter of type `*testing.B`. This type includes
    all the functionality of a `*testing.T` as well as additional support for benchmarking.
    Let’s start by looking at a benchmark that uses a buffer size of 1 byte:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，*基准测试* 是您的测试文件中以 `Benchmark` 开头并接受 `*testing.B` 类型的单个参数的函数。此类型包含 `*testing.T`
    的所有功能，以及用于基准测试的额外支持。让我们先看一个使用 1 字节缓冲区的基准测试：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `blackhole` package-level variable is interesting. You write the results
    from `FileLen` to this package-level variable to make sure that the compiler doesn’t
    get too clever and decide to optimize away the call to `FileLen`, ruining your
    benchmark.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`blackhole` 包级变量很有趣。你将 `FileLen` 的结果写入这个包级变量，以确保编译器不会太过聪明而决定优化掉对 `FileLen`
    的调用，从而破坏你的基准测试。'
- en: Every Go benchmark must have a loop that iterates from 0 to `b.*N*`. The testing
    framework calls your benchmark functions over and over with larger and larger
    values for `*N*` until it is sure that the timing results are accurate. You’ll
    see this in the output in a moment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Go 基准测试必须有一个循环，从 0 迭代到 `b.*N*`。测试框架会反复调用你的基准函数，并增加 `*N*` 的值，直到确保时间结果准确为止。稍后的输出中你会看到这一点。
- en: You run a benchmark by passing the `-bench` flag to `go test`. This flag expects
    a regular expression to describe the name of the benchmarks to run. Use `-bench=.`
    to run all benchmarks. A second flag, `-benchmem`, includes memory allocation
    information in the benchmark output. All tests are run before the benchmarks,
    so you can benchmark code only when tests pass.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `-bench` 标志传递给 `go test` 来运行基准测试。此标志期望一个正则表达式来描述要运行的基准测试的名称。使用 `-bench=.`
    来运行所有基准测试。第二个标志 `-benchmem` 在基准测试输出中包括内存分配信息。在运行基准测试之前会运行所有的测试，因此只有在测试通过时才能对代码进行基准测试。
- en: 'Here’s the output for the benchmark on my computer:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在我的计算机上进行基准测试的输出：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running a benchmark with memory allocation information produces output with
    five columns. Here’s what each one means:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有内存分配信息的基准测试会生成包含五列的输出。以下是每一列的含义：
- en: BenchmarkFileLen1-12
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkFileLen1-12
- en: The name of the benchmark, a hyphen, and the value of `GOMAXPROCS` for the benchmark.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的名称，一个连字符，以及基准测试的 `GOMAXPROCS` 值。
- en: '25'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: The number of times that the test ran to produce a stable result.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 测试稳定结果所需运行的次数
- en: 47201025 ns/op
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 47201025 纳秒/操作
- en: The amount of time it took to run a single pass of this benchmark, in nanoseconds
    (there are 1,000,000,000 nanoseconds in a second).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试运行一次的时间，以纳秒为单位（每秒有 1,000,000,000 纳秒）。
- en: 65342 B/op
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 65342 B/操作
- en: The number of bytes allocated during a single pass of the benchmark.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次基准测试中分配的字节数。
- en: 65208 allocs/op
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 65208 分配/操作
- en: The number of times bytes had to be allocated from the heap during a single
    pass of the benchmark. This will always be less than or equal to the number of
    bytes allocated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次基准测试中，从堆中分配字节的次数。这将始终小于或等于分配的字节的数量。
- en: 'Now that you have results for a buffer of 1 byte, let’s see what the results
    look like when you use buffers of different sizes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了 1 字节缓冲区的结果，让我们看看当你使用不同大小的缓冲区时的结果：
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Just as you launched table tests using `t.Run`, you’re using `b.Run` to launch
    benchmarks that vary based only on input. Here are the results of this benchmark
    on my computer:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你使用 `t.Run` 启动表格测试一样，你使用 `b.Run` 来启动基准测试，这些测试仅基于输入而变化。以下是在我的计算机上进行此基准测试的结果：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These results aren’t surprising; as you increase the size of the buffer, you
    make fewer allocations and your code runs faster, until the buffer is bigger than
    the file. When the buffer is bigger than the size of the file, extra allocations
    slow the output. If you expect files of roughly this size, a buffer of 10,000
    bytes would work best.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果并不令人意外；随着缓冲区大小的增加，分配的次数减少，代码运行速度更快，直到缓冲区大于文件大小。当缓冲区大于文件大小时，额外的分配会减慢输出速度。如果你预期的文件大小大致相同，那么
    10,000 字节的缓冲区效果最好。
- en: 'But you can make a change that improves the numbers more. You are reallocating
    the buffer every time you get the next set of bytes from the file. That’s unnecessary.
    If you move the byte slice allocation before the loop and rerun your benchmark,
    you see an improvement:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以进行改进以进一步提高这些数字。你每次从文件获取下一组字节时重新分配缓冲区是不必要的。如果你在循环之前分配字节片段并重新运行基准测试，你会看到改善：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The number of allocations are now consistent and small, just four allocations
    for every buffer size. What is interesting is that you now can make trade-offs.
    If you are tight on memory, you can use a smaller buffer size and save memory
    at the expense of performance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在分配的数量是一致且较小的，每个缓冲区大小只有四次分配。有趣的是，你现在可以做出权衡。如果内存紧张，你可以使用较小的缓冲区大小，并在性能上牺牲内存。
- en: Using Stubs in Go
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中使用存根
- en: 'So far, you’ve written tests for functions that didn’t depend on other code.
    This is not typical, as most code is filled with dependencies. As you saw in [Chapter 7](ch07.html#unique_chapter_id_07),
    Go allows you to abstract function calls in two ways: defining a function type
    and defining an interface. These abstractions help you write not only modular
    production code but also unit tests.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经为不依赖于其他代码的函数编写了测试。这并不典型，因为大多数代码都充满了依赖项。正如您在[第7章](ch07.html#unique_chapter_id_07)中看到的那样，Go允许您以两种方式抽象函数调用：定义函数类型和定义接口。这些抽象帮助您不仅编写模块化的生产代码，还能编写单元测试。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When your code depends on abstractions, it’s easier to write unit tests!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码依赖于抽象时，编写单元测试会更容易！
- en: 'Let’s take a look at an example in the *sample_code/solver* directory in the
    [Chapter 15 repository](https://oreil.ly/PNRJx). You define a type called `Processor`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，在 *sample_code/solver* 目录中的 [第15章存储库](https://oreil.ly/PNRJx) 中定义了一个名为`Processor`的类型：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It has a field of type `MathSolver`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个类型为`MathSolver`的字段：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You’ll implement and test `MathSolver` in a bit.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您将稍后实现和测试`MathSolver`。
- en: '`Processor` also has a method that reads an expression from an `io.Reader`
    and returns the calculated value:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Processor`还有一个从`io.Reader`读取表达式并返回计算值的方法：'
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s write the code to test `ProcessExpression`. First, you need a simple
    implementation of the `Resolve` method to write your test:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来测试`ProcessExpression`。首先，您需要一个简单的`Resolve`方法的实现来编写您的测试：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, you write a unit test that uses this stub (production code should test
    the error messages too, but for the sake of brevity, you’ll leave those out):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你编写一个单元测试，使用这个存根（生产代码应该测试错误消息，但为了简洁起见，你会省略这些）：
- en: '[PRE58]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can then run your test and see that everything works.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以运行你的测试，看看一切是否正常工作。
- en: 'While most Go interfaces specify only one or two methods, this isn’t always
    the case. You sometimes find yourself with an interface that has many methods.
    Let’s take a look at the code in the *sample_code/stub* directory in the [Chapter
    15 repository](https://oreil.ly/PNRJx). Assume you have an interface that looks
    like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数Go接口仅指定一个或两个方法，但并非总是如此。有时您会发现自己有一个具有许多方法的接口。让我们看一下 *sample_code/stub* 目录中的
    [第15章存储库](https://oreil.ly/PNRJx) 中的代码。假设您有一个看起来像这样的接口：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are two patterns for testing code that depends on large interfaces. The
    first is to embed the interface in a struct. Embedding an interface in a struct
    automatically defines all the interface’s methods on the struct. It doesn’t provide
    any implementations of those methods, so you need to implement the methods that
    you care about for the current test. Let’s assume that `Logic` is a struct that
    has a field of type `Entities`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种模式可以测试依赖于大型接口的代码。第一种是将接口嵌入到结构体中。在结构体中嵌入接口会自动在结构体上定义接口的所有方法。它不提供这些方法的任何实现，因此您需要为当前测试关心的方法实现这些方法。假设`Logic`是一个具有`Entities`类型字段的结构体：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Assume you want to test this method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想测试这种方法：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This method uses only one of the methods declared on `Entities`: `GetPets`.
    Rather than creating a stub that implements every single method on `Entities`
    just to test `GetPets`, you can write a stub struct that implements only the method
    you need to test this method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仅使用了`Entities`上声明的一个方法：`GetPets`。而不是创建一个实现`Entities`上的每一个方法来测试`GetPets`，你可以编写一个仅实现你需要测试这个方法的存根结构体：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You then write your unit test, with your stub injected into `Logic`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您编写单元测试，将您的存根注入到`Logic`中：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: (By the way, the `GetPetNames` method has a bug. Did you see it? Even simple
    methods can sometimes have bugs.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，`GetPetNames`方法有一个bug。你看到了吗？即使是简单的方法有时也会有bug。）
- en: Warning
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you embed an interface in a stub struct, make sure you provide an implementation
    for every method that’s called during your test! If you call an unimplemented
    method, your tests will panic.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在存根结构体中嵌入一个接口，请确保为每个在测试期间调用的方法提供实现！如果调用未实现的方法，您的测试将会崩溃。
- en: 'If you need to implement only one or two methods in an interface for a single
    test, this technique works well. The drawback comes when you need to call the
    same method in different tests with different inputs and outputs. When that happens,
    you need to either include every possible result for every test within the same
    implementation or reimplement the struct for each test. This quickly becomes difficult
    to understand and maintain. A better solution is to create a stub struct that
    proxies method calls to function fields. For each method defined on `Entities`,
    you define a function field with a matching signature on your stub struct:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要为接口中的一个或两个方法实现一个测试，这种技术就很有效。当需要在不同的测试中使用不同的输入和输出调用相同的方法时，这种方法就有缺陷。在这种情况下，您需要在同一实现中包括每个测试的每个可能结果，或者为每个测试重新实现结构。这很快就变得难以理解和维护。更好的解决方案是创建一个存根结构体，将方法调用代理到函数字段上。对于`Entities`定义的每个方法，您在存根结构体上定义一个具有匹配签名的函数字段：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You then make `EntitiesStub` meet the `Entities` interface by defining the
    methods. In each method, you invoke the associated function field. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过定义方法使`EntitiesStub`满足`Entities`接口。在每个方法中，您调用相关的函数字段。例如：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Once you create this stub, you can supply different implementations of different
    methods in different test cases via the fields in the data struct for a table
    test:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这个存根，您可以通过数据结构中的字段为表测试的不同测试案例提供不同的方法实现：
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You add a field of function type to `data`’s anonymous struct. In each test
    case, you specify a function that returns the data that `GetPets` would return.
    When you write your test stubs this way, it’s clear what the stubs should return
    for each test case. As each test runs, you instantiate a new `EntitiesStub` and
    assign the `getPets` function field in your test data to the `getPets` function
    field in `EntitiesStub`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`的匿名结构体中添加一个函数类型的字段。在每个测试案例中，您指定一个返回`GetPets`应返回的数据的函数。当以这种方式编写您的测试存根时，很明显每个测试案例应该返回什么。随着每个测试的运行，您会实例化一个新的`EntitiesStub`，并将测试数据中的`getPets`函数字段分配给`EntitiesStub`中的`getPets`函数字段。
- en: Using httptest
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用httptest
- en: 'It can be difficult to write tests for a function that calls an HTTP service.
    Traditionally, this became an integration test, requiring you to stand up a test
    instance of the service that the function calls. The Go standard library includes
    the [`net/http/httptest`](https://oreil.ly/0c_MX) package to make it easier to
    stub HTTP services. Let’s go back to the *sample_code/solver* directory in the
    [Chapter 15 repository](https://oreil.ly/PNRJx) and provide an implementation
    of `MathSolver` that calls an HTTP service to evaluate expressions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要为调用HTTP服务的函数编写测试可能会很困难。传统上，这变成了一个集成测试，需要您启动一个测试实例来调用函数的服务。Go标准库包含[`net/http/httptest`](https://oreil.ly/0c_MX)包，以便更容易地存根HTTP服务。让我们回到[第15章代码库](https://oreil.ly/PNRJx)中的*sample_code/solver*目录，并提供一个调用HTTP服务来评估表达式的`MathSolver`的实现：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now let’s see how to use the `httptest` library to test this code without standing
    up a server. The code is in the `TestRemoteSolver_Resolve` function in *sample_code/solver/remote_solver_test.go*
    in the [Chapter 15 repository](https://oreil.ly/PNRJx), but here are the highlights.
    First, you want to make sure that the data that’s passed into the function arrives
    on the server. So in your test function, you define a type called `info` to hold
    your input and output and a variable called `io` that is assigned the current
    input and output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用`httptest`库来测试这段代码，而无需启动服务器。代码位于[第15章代码库](https://oreil.ly/PNRJx)中*sample_code/solver/remote_solver_test.go*的`TestRemoteSolver_Resolve`函数中，但这里是重点。首先，您希望确保传递到函数的数据到达服务器。因此，在您的测试函数中，您定义了一个名为`info`的类型来保存输入和输出，以及一个名为`io`的变量，它被分配了当前的输入和输出：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, you set up your fake remote server and use it to configure an instance
    of `RemoteSolver`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您设置假的远程服务器并使用它来配置`RemoteSolver`的实例：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `httptest.NewServer` function creates and starts an HTTP server on a random
    unused port. You need to provide an `http.Handler` implementation to process the
    request. Since this is a server, you must close it when the test completes. The
    `server` instance has its URL specified in the `URL` field of the `server` instance
    and a preconfigured `http.Client` for communicating with the test server. You
    pass these into `RemoteSolver`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptest.NewServer`函数会在一个随机未使用的端口上创建并启动一个HTTP服务器。你需要提供一个`http.Handler`实现来处理请求。由于这是一个服务器，当测试完成时必须将其关闭。`server`实例的URL已经在`server`实例的`URL`字段中指定，并且为与测试服务器通信而预先配置了`http.Client`。你需要将这些传递给`RemoteSolver`。'
- en: 'The rest of the function works like every other table test that you’ve seen:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分和你见过的其他表格测试一样：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The interesting thing to note is that the variable `io` has been captured by
    two closures: the one for the stub server and the one for running each test. You
    write to it in one closure and read it in the other. This is a bad idea in production
    code, but it works well in test code within a single function.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是变量`io`被两个闭包捕获：一个用于存根服务器，另一个用于运行每个测试。你在一个闭包中向其写入，而在另一个闭包中读取。在生产代码中这样做是不好的，但在单个函数中的测试代码中却很有效。
- en: Using Integration Tests and Build Tags
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集成测试和构建标签
- en: Even though `httptest` provides a way to avoid testing against external services,
    you should still write *integration tests*, automated tests that connect to other
    services. These validate that your understanding of the service’s API is correct.
    The challenge is figuring out how to group your automated tests; you want to run
    integration tests only when the support environment is present. Also, integration
    tests tend to be slower than unit tests, so they are usually run less frequently.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`httptest`提供了一种避免针对外部服务进行测试的方法，你仍然应该编写*集成测试*，即连接到其他服务的自动化测试，以验证你对服务API的理解是否正确。挑战在于如何分组自动化测试；你希望只在支持环境存在时运行集成测试。此外，集成测试通常比单元测试慢，因此通常运行频率较低。
- en: In [“Using Build Tags”](ch11.html#build_tags), I covered build tags, which are
    used by the Go compiler to control when a file is compiled. While they are primarily
    intended to allow developers to write code that’s intended only for a specific
    operating system, CPU, or Go version, you can take advantage of the ability to
    specify custom build tags to control when integration tests are compiled and run.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“使用构建标签”](ch11.html#build_tags)中，我介绍了构建标签，这些标签由Go编译器用于控制何时编译文件。虽然它们主要用于允许开发人员编写仅适用于特定操作系统、CPU或Go版本的代码，但你也可以利用指定自定义构建标签的能力来控制何时编译和运行集成测试。
- en: Let’s try this out with the math-solving project. Use [Docker](https://oreil.ly/5FWcb)
    to download a server implementation with `docker pull jonbodner/math-server` and
    then run the server locally on port 8080 with `docker run -p 8080:8080` `jonbodner/math-server`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试数学求解项目。使用[Docker](https://oreil.ly/5FWcb)下载服务器实现：`docker pull jonbodner/math-server`，然后在本地端口8080上运行服务器：`docker
    run -p 8080:8080 jonbodner/math-server`。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t have Docker installed or if you want to build the code for yourself,
    you can find it on [GitHub](https://oreil.ly/yjMzc).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装Docker或者想要自己构建代码，你可以在[GitHub](https://oreil.ly/yjMzc)上找到它。
- en: 'You need to write an integration test to make sure that your `Resolve` method
    properly communicates with the math server. The *sample_code/solver/remote_solver_integration_test.go*
    file in the [Chapter 15 repository](https://oreil.ly/PNRJx) has a complete test
    in the `TestRemoteSolver_ResolveIntegration` function. The test looks like every
    other table test that you’ve written. The interesting thing is the first line
    of the file, separated from the package declaration by a newline:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 需要编写一个集成测试来确保你的`Resolve`方法能够与数学服务器正常通信。在[第15章代码库](https://oreil.ly/PNRJx)的*sample_code/solver/remote_solver_integration_test.go*文件中，`TestRemoteSolver_ResolveIntegration`函数已经包含了一个完整的测试。这个测试看起来和你写过的其他表格测试一样。有趣的是文件的第一行，通过一个空行与包声明分隔开来：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To run your integration test alongside the other tests you’ve written, use
    this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要将集成测试与你编写的其他测试一起运行，请使用以下命令：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You should be aware that some people in the Go community prefer to use environment
    variables rather than build tags to create groups of integration tests. Peter
    Bourgon describes the concept in a blog post with the unsubtle title [“Don’t Use
    Build Tags for Integration Tests”](https://oreil.ly/BXSnu). His argument is that
    it’s hard to find out what build tags to set in order to run integration tests.
    An explicit check for an environment variable in each integration test, combined
    with a detailed message in a `t.Skip` method call, makes it clear that tests aren’t
    being run and how to run them. In the end, it’s a trade-off between verbosity
    and discoverability. Feel free to use either technique.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，Go社区中有些人更喜欢使用环境变量而不是构建标签来创建集成测试组。 Peter Bourgon在博客文章中详细描述了这个概念，标题不含糊地为[“不要使用构建标签进行集成测试”](https://oreil.ly/BXSnu)。
    他认为，很难找出设置哪些构建标签来运行集成测试。 在每个集成测试中显式检查环境变量，并在`t.Skip`方法调用中添加详细消息，清楚地表明测试未运行以及如何运行它们，这是语法冗长和可发现性之间的权衡。
    请随意使用任一技术。
- en: Finding Concurrency Problems with the Data Race Detector
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据竞争检测器查找并发问题
- en: Even with Go’s built-in support for concurrency, bugs still happen. It’s easy
    to accidentally reference a variable from two different goroutines without acquiring
    a lock. The computer science term for this is a *data race*. To help find these
    sorts of bugs, Go includes a *race checker*. It isn’t guaranteed to find every
    single data race in your code, but if it finds one, you should put proper locks
    around what it finds.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Go内置支持并发，错误仍会发生。 容易无意中从两个不同的goroutine引用变量而不获取锁。 计算机科学术语称为*数据竞争*。 为了帮助找到这些类型的错误，Go包括一个*竞争检查器*。
    它不能保证在您的代码中找到每一个数据竞争，但如果找到一个，您应该在找到的内容周围放置适当的锁。
- en: 'Look at a simple example in the file *sample_code/race/race.go* in the [Chapter
    15 repository](https://oreil.ly/PNRJx):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章存储库](https://oreil.ly/PNRJx)的文件*sample_code/race/race.go*中查看一个简单的示例：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This code launches five goroutines, has each of them update a shared `counter`
    variable 1,000 times, and then returns the result. You’d expect it to be 5,000,
    so let’s verify this with a unit test in *sample_code/race/race_test.go*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码启动五个goroutine，每个goroutine更新共享的`counter`变量1000次，然后返回结果。 您希望它为5000，因此让我们在*sample_code/race/race_test.go*中使用单元测试来验证：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you run `go test` a few times, you’ll see that sometimes it passes, but
    most of the time it fails with an error message like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次运行`go test`，您会看到有时它会通过，但大多数情况下会出现类似以下错误消息：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The problem is that there’s a data race in the code. In a program this simple,
    the cause is obvious: multiple goroutines are trying to update `counter` simultaneously,
    and some of their updates are lost. In more complicated programs, these sorts
    of races are harder to see. Let’s see what the data race detector does. Use the
    flag `-race` with `go test` to enable it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于代码中存在数据竞争。 在这么简单的程序中，原因是显而易见的：多个goroutine同时尝试更新`counter`，其中一些更新会丢失。 在更复杂的程序中，这些类型的竞争更难以看到。
    让我们看看数据竞争检测器的作用。 使用`go test`的`-race`标志来启用它：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The traces make it clear that the line `counter++` is the source of your problems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚迹象表明`counter++`是你问题的根源。
- en: Warning
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some people try to fix race conditions by inserting “sleeps” into their code,
    trying to space out access to the variable that’s being accessed by multiple goroutines.
    *This is a bad idea*. Doing so might eliminate the problem in some cases, but
    the code is still wrong and will fail in some situations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人尝试通过向其代码插入“睡眠”来修复竞态条件，试图间隔访问由多个goroutine访问的变量。 *这是一个坏主意*。 这样做可能会在某些情况下消除问题，但代码仍然是错误的，并且在某些情况下将失败。
- en: You can also use the `-race` flag when you build your programs. This creates
    a binary that includes the data race detector and that reports any races it finds
    to the console. This allows you to find data races in code that doesn’t have tests.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建程序时，还可以使用`-race`标志。 这将创建一个包含数据竞争检测器的二进制文件，并将其报告给控制台上发现的任何竞争。 这使您可以在没有测试的代码中找到数据竞争。
- en: If the data race detector is so useful, why isn’t it enabled all the time for
    testing and production? A binary with `-race` enabled runs approximately 10 times
    slower than a normal binary. That isn’t a problem for test suites that take a
    second to run, but for large test suites that take several minutes, a 10× slowdown
    reduces productivity.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据竞争检测器如此有用，为什么不总是在测试和生产中启用它？启用 `-race` 的二进制运行速度大约比正常二进制慢 10 倍。对于运行一秒钟的测试套件来说，这不是问题，但对于运行几分钟的大型测试套件来说，10
    倍的减速会降低生产力。
- en: For more information on the data race detector, check out its [official documentation](https://oreil.ly/0uLcW).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于数据竞争检测器的更多信息，请查阅其[官方文档](https://oreil.ly/0uLcW)。
- en: Exercises
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you’ve learned about writing tests and using the code-quality tools
    included with Go, complete these exercises to apply that knowledge to a sample
    application.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何编写测试并使用 Go 自带的代码质量工具，完成以下练习，将这些知识应用到一个示例应用程序中。
- en: '[Download the Simple Web App program](https://oreil.ly/5b_xI). Write unit tests
    for the program and get as close to 100% code coverage as you can. If you find
    any bugs, fix them.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[下载 Simple Web App 程序](https://oreil.ly/5b_xI)。为该程序编写单元测试，并尽可能接近 100% 的代码覆盖率。如果发现任何错误，请修复它们。'
- en: Use the race detector to find a concurrency problem in the program and fix it.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用竞争检测器来找出程序中的并发问题并修复它。
- en: Write a fuzz test against the `parser` function and fix any problems that you
    find.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `parser` 函数编写一个模糊测试，并修复你找到的任何问题。
- en: Wrapping Up
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you’ve learned how to write tests and improve code quality
    by using Go’s built-in support for testing, code coverage, benchmarking, fuzzing,
    and data race checking. In the next chapter, you’re going to explore some Go features
    that allow you to break the rules: the `unsafe` package, reflection, and `cgo`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用 Go 内置的测试支持、代码覆盖率、基准测试、模糊测试和数据竞争检查来编写测试并提高代码质量。在下一章中，你将探索一些允许你打破规则的
    Go 特性：`unsafe` 包、反射和 `cgo`。
