- en: Chapter 1\. Software Efficiency Matters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 软件效率至关重要
- en: The primary task of software engineers is the cost-effective development of
    maintainable and useful software.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件工程师的主要任务是成本效益高、易维护且有用的软件开发。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jon Louis Bentley, *Writing Efficient Programs* (Prentice Hall, 1982)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jon Louis Bentley，《编写高效程序》（Prentice Hall，1982）
- en: Even after 40 years, Jon’s definition of development is fairly accurate. The
    ultimate goal for any engineer is to create a useful product that can sustain
    user needs for the product lifetime. Unfortunately, nowadays not every developer
    realizes the significance of the software cost. The truth can be brutal; stating
    that the development process can be expensive might be an underestimation. For
    instance, it took 5 years and 250 engineers for Rockstar to develop the popular
    Grand Theft Auto 5 video game, which [was estimated to cost $137.5 million](https://oreil.ly/0CRW2).
    On the other hand, to create a usable, commercialized operating system, Apple
    had to spend way over [$500 million before the first release of macOS](https://oreil.ly/hQhiv)
    in 2001.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 即使经过40年，Jon对开发的定义仍然非常准确。任何工程师的最终目标都是创建一个有用的产品，能够在产品生命周期内满足用户需求。不幸的是，如今并不是每个开发者都意识到软件成本的重要性。事实可能很残酷；声明开发过程可能昂贵可能是低估了。例如，Rockstar花了5年时间和250名工程师开发了流行的《侠盗猎车手5》视频游戏，[估计成本达1.375亿美元](https://oreil.ly/0CRW2)。另一方面，为了创建一个可用的、商业化的操作系统，苹果在2001年macOS首次发布前已经花费了超过[5亿美元](https://oreil.ly/hQhiv)。
- en: Because of the high cost of producing software, it’s crucial to focus our efforts
    on things that matter the most. Ideally, we don’t want to waste engineering time
    and energy on unnecessary actions, for example, spending weeks on code refactoring
    that doesn’t objectively reduce code complexity, or deep micro-optimizations of
    a function that rarely runs. Therefore, the industry continually invents new patterns
    to pursue an efficient development process. Agile Kanban methods that allow us
    to adapt to ever-changing requirements, specialized programming languages for
    mobile platforms like Kotlin, or frameworks for building websites like React are
    only some examples. Engineers innovate in these fields because every inefficiency
    increases the cost.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件生产成本高昂，我们需要把精力集中在最重要的事情上。理想情况下，我们不希望在不必要的行动上浪费工程时间和精力，例如花费数周进行并未客观减少代码复杂性的代码重构，或者深度微优化一个很少运行的函数。因此，该行业不断创新出新的模式来追求高效的开发过程。敏捷看板方法允许我们适应不断变化的需求，专门为移动平台开发的编程语言如Kotlin，以及用于构建网站的框架如React，仅仅是一些例子。工程师在这些领域进行创新，因为每一种低效都会增加成本。
- en: What makes it even more difficult is that when developing software now, we should
    also be aware of the future costs. Some sources even estimate that running and
    maintenance costs [can be higher than the initial development costs](https://oreil.ly/59Zqe).
    Code changes to stay competitive, bug fixing, incidents, installations, and finally,
    compute cost (including electricity consumed) are only a few examples of the [total
    software cost of ownership (TCO)](https://oreil.ly/ZzUCx) we have to take into
    account. Agile methodologies help reveal this cost early by releasing software
    often and getting feedback sooner.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更加困难的是，当下开发软件时，我们还应该考虑到未来的成本。一些来源甚至估计，运行和维护成本[可能高于初始开发成本](https://oreil.ly/59Zqe)。为了保持竞争力，代码更改、故障修复、事故处理、安装以及最终的计算成本（包括消耗的电力）只是[总软件拥有成本（TCO）](https://oreil.ly/ZzUCx)的几个例子，我们必须考虑进去。敏捷方法有助于早期揭示这些成本，通过频繁发布软件并尽早获取反馈。
- en: However, is that TCO higher if we descope efficiency and speed optimizations
    from our software development process? In many cases, waiting a few more seconds
    for our application execution should not be a problem. On top of that, the hardware
    is getting cheaper and faster every month. In 2022, buying a smartphone with a
    dozen GBs of RAM was not difficult. Finger-sized, [2 TB SSD disks capable of 7
    GBps](https://oreil.ly/eVcPQ) read and write throughput are available. Even home
    PC workstations are hitting never-before-seen performance scores. With [8 CPUs
    or more that can perform billions of cycles per second each, and with 2 TB of
    RAM](https://oreil.ly/eUzNh), we can compute things fast. Plus, we can always
    add optimizations later, right?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们从软件开发过程中剥离效率和速度优化，TCO是否会更高呢？在许多情况下，等待应用程序执行多几秒钟应该不成问题。此外，硬件每个月变得更便宜更快。在2022年，购买一部具有数十GB
    RAM的智能手机并不困难。指尖大小的[2 TB SSD硬盘，可达每秒7 GBps的读写吞吐量](https://oreil.ly/eVcPQ)已经可以购买到。即使是家庭PC工作站也达到了前所未见的性能分数。配备[8个或更多CPU，每秒可以执行数十亿周期，以及2
    TB的RAM](https://oreil.ly/eUzNh)，我们可以快速计算事物。而且，我们总是可以稍后添加优化，对吧？
- en: Machines have become increasingly cheap compared to people; any discussion of
    computer efficiency that fails to take this into account is short-sighted. “Efficiency”
    involves the reduction of overall cost—not just machine time over the life of
    the program, but also time spent by the programmer and by the users of the program.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与人们相比，机器变得越来越便宜；任何未能考虑到这一点的计算机效率讨论都是短视的。“效率”包括整体成本的降低——不仅是程序生命周期内的机器时间，还包括程序员和程序使用者的时间。
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian W. Kernighan and P. J. Plauger, *The Elements of Programming Style* (McGraw-Hill,
    1978)
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brian W. Kernighan 和 P. J. Plauger，《程序设计风格的要素》（McGraw-Hill, 1978）
- en: After all, improving the runtime or space complexity of the software is a complicated
    topic. Especially when you are new, it’s common to lose time optimizing without
    significant program speedups. And even if we start caring about the latency introduced
    by our code, things like Java Virtual Machine or Go compiler will apply their
    optimizations anyway. Spending more time on something tricky, like efficiency
    on modern hardware that can also sacrifice our code’s reliability and maintainability,
    may sound like a bad idea. These are only a few reasons why engineers typically
    put performance optimizations at the lowest position of the development priority
    list.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，改进软件的运行时间或空间复杂性是一个复杂的话题。特别是当你是新手时，花费时间优化而没有显著的程序加速是很常见的。即使我们开始关注代码引入的延迟，像Java虚拟机或Go编译器也会应用它们的优化。在现代硬件上花费更多时间处理复杂的事情，比如效率，这可能会牺牲我们代码的可靠性和可维护性，听起来可能不是一个好主意。这些只是工程师通常将性能优化放在开发优先级列表的最低位置的几个原因。
- en: Unfortunately, as with every extreme simplification, there is some risk in such
    performance de-prioritization. Don’t be worried, though! In this book, I will
    not try to convince you that you should now measure the number of nanoseconds
    each code line introduces or every bit it allocates in memory before adding it
    to your software. You should not. I am far from trying to motivate you to put
    performance at the top of your development priority list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，就像每一种极端简化一样，这种性能降低也存在一定的风险。不过，别担心！在本书中，我不会试图说服你，现在应该测量每行代码引入的纳秒数量，或者在将其添加到你的软件之前分配的每个比特。你不应该这样做。我远非试图激励你将性能置于开发优先级列表的首位。
- en: However, there is a difference between consciously postponing optimizations
    and making silly mistakes, causing inefficiencies and slowdowns. As the common
    saying goes, [“Perfect is the enemy of good”](https://oreil.ly/OogZF), but we
    have to find that balanced good first. So I want to propose a subtle but essential
    change to how we, as software engineers, should think about application performance.
    It will allow you to bring small but effective habits to your programming and
    development management cycle. Based on data and as early as possible in the development
    cycle, you will learn how to tell when you can safely ignore or postpone program
    inefficiencies. Finally, when you can’t afford to skip performance optimizations,
    where and how to apply them effectively, and when to stop.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有意推迟优化与犯傻错误、导致低效和减速是有区别的。正如俗话说的那样，[“完美是好的敌人”](https://oreil.ly/OogZF)，但我们必须首先找到那个平衡的好。因此，我想提出一个细微但至关重要的变化，来改变我们作为软件工程师应该如何思考应用程序性能的方式。它将允许你将小而有效的习惯带入你的编程和开发管理周期中。基于数据，并且在开发周期的尽早阶段，你将学会如何判断何时可以安全地忽略或推迟程序的低效性。最后，当你无法跳过性能优化时，如何在哪里以及如何有效地应用它们，以及何时停止。
- en: In [“Behind Performance”](#ch-eff-s-performance), we will unpack the word *performance*
    and learn how it is related to *efficiency* in this book’s title. Then in [“Common
    Efficiency Misconceptions”](#ch-eff-s-misconceptions), we will challenge five
    serious misconceptions around efficiency and performance, often descoping such
    work from developer minds. You will learn that thinking about efficiency is not
    reserved only for “high-performance” software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“性能背后”](#ch-eff-s-performance)，我们将解析*性能*这个词，并学习它与本书标题中的*效率*的关系。然后在[“常见效率误解”](#ch-eff-s-misconceptions)，我们将挑战关于效率和性能的五个严重误解，这些误解常常使开发者们不再关注此类工作。你将学会，思考效率并不仅仅适用于“高性能”软件。
- en: Some of the chapters, like this one, [Chapter 3](ch03.html#ch-efficiency), and
    parts of other chapters, are fully language agnostic, so they should be practical
    for non-Go developers too!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些章节，比如这一章，[第3章](ch03.html#ch-efficiency)，以及其他章节的部分，都是完全与语言无关的，因此对非Go开发者也应该是实用的！
- en: Finally, in [“The Key to Pragmatic Code Performance”](#ch-eff-s-efficiency),
    I will teach you why focusing on efficiency will allow us to think about performance
    optimizations effectively without sacrificing time and other software qualities.
    This chapter might feel theoretical, but trust me, the insights will train your
    essential programming judgment on how and if to adopt particular efficiency optimizations,
    algorithms, and code improvements presented in other parts of this book. Perhaps
    it will also help you motivate your product manager or stakeholder to see that
    more efficient awareness of your project can be beneficial.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[“实用代码性能的关键”](#ch-eff-s-efficiency)，我将教你为什么专注于效率将使我们能够有效地思考性能优化，而不会牺牲时间和其他软件质量。这一章可能感觉理论性很强，但请相信我，这些见解将训练你在其他部分中介绍的特定效率优化、算法和代码改进的关键编程判断能力。也许它还会帮助你说服你的产品经理或利益相关者，更高效地意识到你的项目可能会有益。
- en: Let’s start by unpacking the definition of efficiency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解析效率的定义开始。
- en: Behind Performance
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能背后
- en: Before discussing why software efficiency or optimizations matter, we must first
    demystify the overused word *performance*. In engineering, this word is used in
    many contexts and can mean different things, so let’s unpack it to avoid confusion.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论为什么软件效率或优化很重要之前，我们必须首先揭开被滥用的*性能*这个词的真相。在工程上，这个词在许多上下文中被使用，并且可以有不同的含义，因此让我们对其进行解析，以避免混淆。
- en: When people say, “This application is performing poorly,” they usually mean
    that this particular program is executing slowly.^([1](ch01.html#idm45606840459904))
    However, if the same people say, “Bartek is not performing well at work,” they
    probably don’t mean that Bartek is walking too slowly from the computer to the
    meeting room. In my experience, a significant number of people in software development
    consider the word *performance* a synonym of *speed*. For others, it means the
    overall quality of execution, which is the original definition of this word.^([2](ch01.html#idm45606840401472))
    This phenomenon is sometimes called a [“semantic diffusion”](https://oreil.ly/Qx9Ft),
    which occurs when a word starts to be used by larger groups with a different meaning
    than it originally had.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们说“This application is performing poorly”时，他们通常意味着这个特定程序正在执行得很慢。^([1](ch01.html#idm45606840459904))
    然而，如果同样的人说“Bartek is not performing well at work”，他们可能并不意味着Bartek从电脑到会议室的步伐太慢。根据我的经验，许多软件开发人员认为*performance*这个词是*speed*的同义词。对于其他人来说，它意味着执行质量的总体，这是这个词的最初定义。^([2](ch01.html#idm45606840401472))
    这种现象有时被称为“语义扩散”，即当一个词开始被更大的群体使用时，它的含义可能与其最初的含义不同。
- en: The word performance in computer performance means the same thing that performance
    means in other contexts, that is, it means “How well is the computer doing the
    work it is supposed to do?”
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机性能中，性能这个词意味着与其他情境中性能相同的东西，也就是说，“计算机在执行其预期工作时表现如何？”
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arnold O. Allen, *Introduction to Computer Performance Analysis with Mathematica*
    (Morgan Kaufmann, 1994)
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Arnold O. Allen，《用Mathematica进行计算机性能分析导论》（Morgan Kaufmann，1994）
- en: I think Arnold’s definition describes the word *performance* as accurately as
    possible, so it might be the first actionable item you can take from this book.
    Be specific.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为Arnold的定义尽可能准确地描述了*performance*这个词，因此这可能是你从本书中可以采取的第一个可操作步骤。要具体。
- en: Clarify When Someone Uses the Word “Performance”
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当有人使用“性能”这个词时澄清
- en: When reading the documentation, code, bug trackers, or attending conference
    talks, be careful when you hear that word, *performance*. Ask follow-up questions
    and ensure what the author means.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读文档、代码、bug跟踪器或参加会议时，当你听到*performance*这个词时要小心。提出跟进问题，确保了解作者的意思。
- en: In practice, performance, as the quality of overall execution, might contain
    much more than we typically think. It might feel picky, but if we want to improve
    software development’s cost-effectiveness, we must communicate clearly, efficiently,
    and effectively!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，性能作为整体执行的质量可能包含比我们通常认为的更多。这可能看起来有点挑剔，但如果我们想提高软件开发的成本效益，我们必须清晰、高效和有效地沟通！
- en: I suggest avoiding the *performance* word unless we can specify its meaning.
    Imagine you are reporting a bug in a bug tracker like GitHub Issues. Especially
    there, don’t just mention “bad performance,” but specify exactly the unexpected
    behavior of the application you described. Similarly, when describing improvements
    for a software release in the changelog,^([3](ch01.html#idm45606849124608)) don’t
    just mention that a change “improved performance.” Describe what, exactly, was
    enhanced. Maybe part of the system is now less prone to user input errors, uses
    less RAM (if yes, how much less, in what circumstances?), or executes something
    faster (how many seconds faster, for what kinds of workloads?). Being explicit
    will save time for you and your users.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议避免使用*performance*这个词，除非我们能明确其含义。想象一下你在类似GitHub Issues这样的bug跟踪器中报告bug。特别是在那里，不要只是提到“bad
    performance”，而是具体描述应用程序中出现的预期外行为。同样，在变更日志中描述软件发布的改进时，^([3](ch01.html#idm45606849124608))
    不要只是说某个变更“改进了性能”。描述具体改进了什么。也许系统的某部分现在更不容易出现用户输入错误，使用的内存更少（如果是的话，在什么情况下？），或者执行某些工作负载更快（比以前快多少秒？）。具体描述将为您和您的用户节省时间。
- en: I will be explicit in my book about this word. So whenever you see the word
    *performance* describing the software, remind yourself about this visualization
    in [Figure 1-1](#img-perf-definition).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的书中明确解释这个词。所以每当你看到描述软件的词语*performance*，请通过[图 1-1](#img-perf-definition)来想象这种可视化。
- en: '![efgo 0101](assets/efgo_0101.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0101](assets/efgo_0101.png)'
- en: Figure 1-1\. Performance definition
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 性能定义
- en: 'In principle, software performance means “how well software runs” and consists
    of three core execution elements you can improve (or sacrifice):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，软件性能意味着“软件运行得有多好”，并由你可以改进（或牺牲）的三个核心执行要素组成：
- en: Accuracy
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 精确性
- en: The number of errors you make while doing the work to accomplish the task. This
    can be measured for software by the number of wrong results your application produces.
    For example, how many requests finished with non-200 HTTP status codes in a web
    system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成任务所需的工作中所犯的错误数量。对于软件来说，可以通过应用程序产生的错误结果的数量来衡量。例如，在Web系统中，有多少请求以非200 HTTP状态代码完成。
- en: Speed
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Speed
- en: How fast you do the work needed to accomplish the task—the timeliness of execution.
    This can be observed by operation latency or throughput. For example, we can estimate
    that typical compression of 1 GB of data in memory typically takes around 10 s
    (latency), allowing approximately [100 MBps throughput](https://oreil.ly/eOJdK).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成任务所需的工作速度——执行的及时性。这可以通过操作延迟或吞吐量来观察。例如，我们可以估计内存中1GB数据的典型压缩通常需要大约10秒（延迟），从而实现大约[100
    MBps的吞吐量](https://oreil.ly/eOJdK)。
- en: Efficiency
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Efficiency
- en: The ratio of the useful energy delivered by a dynamic system to the energy supplied
    to it. More simply, this is the indicator of how many extra resources, energy,
    or work were used to accomplish the task. In other words, how much effort we wasted.
    For instance, if our operation of fetching 64 bytes of valuable data from disk
    allocates 420 bytes on RAM, our memory efficiency would equal 15.23%.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 动态系统提供的有效能量与供给它的能量之比。更简单地说，这是衡量完成任务所需的额外资源、能量或工作量的指标。换句话说，我们浪费了多少努力。例如，如果我们从磁盘中获取64字节的宝贵数据的操作在RAM上分配了420字节，我们的内存效率将达到15.23%。
- en: This does not mean our operation is 15.23% efficient in absolute measure. We
    did not calculate energy, CPU time, heat, and other efficiencies. For practical
    purposes, we tend to specify what efficiency we have in mind. In our example,
    that was memory space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们的操作在绝对度量上效率为15.23%。我们没有计算能量、CPU时间、热量和其他效率指标。出于实际目的，我们倾向于指定我们考虑的效率是什么。在我们的例子中，这是内存空间。
- en: 'To sum up, performance is a combination of at least those three elements:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，性能至少由这三个元素组成：
- en: <math><mrow><mtext>performance</mtext> <mo>=</mo> <mo>(</mo> <mtext>accuracy</mtext>
    <mo>*</mo> <mtext>efficiency</mtext> <mo>*</mo> <mtext>speed</mtext> <mo>)</mo></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mtext>性能</mtext> <mo>=</mo> <mo>(</mo> <mtext>精度</mtext> <mo>*</mo>
    <mtext>效率</mtext> <mo>*</mo> <mtext>速度</mtext> <mo>)</mo></mrow></math>
- en: Improving any of those enhances the performance of the running application or
    system. It can help with reliability, availability, resiliency, overall latency,
    and more. Similarly, ignoring any of those can make our software less useful.^([4](ch01.html#idm45606840462688))
    The question is, at what point should we say “stop” and claim it is good enough?
    Those three elements might also feel disjointed, but in fact, they are connected.
    For instance, notice that we can still achieve better reliability and availability
    without changing accuracy (not reducing the number of bugs). For example, with
    efficiency, reducing memory consumption decreases the chances of running out of
    memory and crashing the application or host operating system. This book focuses
    on knowledge, techniques, and methods, allowing you to increase the efficiency
    and speed of your running code without degrading accuracy.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 改进其中任何一个都可以提高正在运行的应用程序或系统的性能。它可以帮助提高可靠性、可用性、弹性、总延迟等。同样，忽视其中任何一个可能会使我们的软件变得不那么有用。^([4](ch01.html#idm45606840462688))问题是，我们应该在什么时候停下来，并宣称它足够好？这三个元素可能看起来毫不相关，但实际上它们是相互关联的。例如，请注意，即使不减少错误的数量，我们仍然可以提高可靠性和可用性。例如，通过提高效率，减少内存消耗可以降低内存不足并导致应用程序或主机操作系统崩溃的风险。本书专注于知识、技术和方法，帮助您在不降低精度的情况下提高正在运行的代码的效率和速度。
- en: It’s No Mistake That the Title of My Book Is “Efficient Go”
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的书名为“高效的Go”并非偶然。
- en: My goal is to teach you pragmatic skills, allowing you to produce high-quality,
    accurate, efficient, and fast code with minimum effort. For this purpose, when
    I mention the overall efficiency of the code (without saying a particular resource),
    I mean both speed and efficiency, as shown in [Figure 1-1](#img-perf-definition).
    Trust me, this will help us to get through the subject effectively. You will learn
    more about why in [“The Key to Pragmatic Code Performance”](#ch-eff-s-efficiency).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是教会您实用的技能，使您能够以最小的努力产生高质量、准确、高效和快速的代码。为此，当我提到代码的整体效率时（而不是特定的资源），我指的是速度和效率，如图[1-1](#img-perf-definition)所示。相信我，这将有助于我们有效地理解这个主题。您将在[“实用代码性能的关键”](#ch-eff-s-efficiency)中了解更多原因。
- en: Misleading use of the *performance* word might be the tip of the misconceptions
    iceberg in the efficiency subject. We will now walk through many more serious
    stereotypes and tendencies that are causing the development of our software to
    worsen. Best case, it results in more expensive to run or less valuable programs.
    Worse case, it causes severe social and financial organizational problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能* 这个词的误导性使用可能只是效率主题中误解冰山的一角。我们现在将详细讨论更多导致软件开发恶化的严重刻板印象和趋势。最好的情况下，它导致运行成本更高或价值不高的程序。最坏的情况下，它会引起严重的社会和财务组织问题。'
- en: Common Efficiency Misconceptions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的效率误解
- en: The number of times when I was asked, in code reviews or sprint plannings, to
    ignore the efficiency of the software “for now” is staggering. And you have probably
    heard that too! I also rejected someone else’s change set for the same reasons
    numerous times. Perhaps our changes were dismissed at that time for good reasons,
    especially if they were micro-optimizations that added unnecessary complexity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码审查或迭代计划中被要求“暂时忽略”软件效率的次数令人震惊。你可能也听说过这种情况！我也因同样的理由多次拒绝了别人的变更集。也许当时对我们的变更不予采纳是有充分理由的，特别是如果它们是不必要的微优化，增加了不必要的复杂性。
- en: On the other hand, there were also cases where the reasons for rejection were
    based on common, factual misconceptions. Let’s try to unpack some of the most
    damaging misunderstandings. Be cautious when you hear some of these generalized
    statements. Demystifying them might help you save enormous development costs long-term.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也有一些情况是因为普遍的事实误解而被拒绝的。让我们试着揭示一些最具破坏性的误解。当你听到这些概括性的陈述时要谨慎。揭示它们可能有助于长期节省巨额开发成本。
- en: Optimized Code Is Not Readable
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化后的代码并不一定可读
- en: Undoubtedly, one of the most critical qualities of software code is its readability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，软件代码最关键的品质之一是其可读性。
- en: It is more important to make the purpose of the code unmistakable than to display
    virtuosity.... The problem with obscure code is that debugging and modification
    become much more difficult, and these are already the hardest aspects of computer
    programming. Besides, there is the added danger that a too clever program may
    not say what you thought it said.
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使代码目的不会被误解比展示技术高超更为重要... 模糊代码的问题在于调试和修改变得更加困难，而这已经是计算机编程中最难的方面。此外，太过聪明的程序可能会让你意想不到。
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian W. Kernighan and P. J. Plauger, *The Elements of Programming Style* (McGraw-Hill,
    1978)
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brian W. Kernighan 和 P. J. Plauger，《编程风格的要素》（McGraw-Hill，1978）
- en: When we think about ultrafast code, the first thing that sometimes comes to
    mind is those clever, low-level implementations with a bunch of byte shifts, magic
    byte paddings, and unrolled loops. Or worse, pure assembly code linked to your
    application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑超快速的代码时，有时候会想到那些巧妙的、低级别的实现，带有一堆字节移位、魔术字节填充和展开的循环。或者更糟糕的是，链接到您应用程序的纯汇编代码。
- en: Yes, low-level optimizations like that can make our code significantly less
    readable, but as you will learn in this book, such extreme changes are rare in
    practice. Code optimizations might produce extra complexity, increase cognitive
    load, and make our code harder to maintain. The problem is that engineers tend
    to associate optimization with complexity to the extreme and avoid efficiency
    optimization like fire. In their minds, it translates to an immediate negative
    readability impact. The point of this section is to show you that there are ways
    to make efficiency-optimized code clear. Efficiency and readability can coexist.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，像这样的低级别优化确实会使我们的代码显著变得不可读，但正如您将在本书中了解到的那样，这样的极端变化在实践中是罕见的。代码优化可能会带来额外的复杂性，增加认知负荷，并使我们的代码更难以维护。问题在于工程师们倾向于将优化与极端复杂性联系起来，并避免像火一样的效率优化。在他们的心目中，这意味着即时的负面可读性影响。本节的重点是向您展示，有方法可以使效率优化的代码清晰可见。效率和可读性可以共存。
- en: Similarly, the same risk exists if we add any other functionality or change
    the code for different reasons. For example, refusing to write more efficient
    code because of a fear of decreasing readability is like refusing to add vital
    functionality to avoid complexity. So, again, this is a fair question, and we
    can consider descoping the feature, but we should evaluate the consequences first.
    The same should be applied to efficiency changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果我们添加其他任何功能或出于其他原因更改代码，也存在同样的风险。例如，因为害怕降低可读性而拒绝编写更高效的代码就像拒绝添加重要功能以避免复杂性一样。因此，再次，这是一个公正的问题，我们可以考虑放弃功能，但我们应该先评估后果。同样适用于效率更改。
- en: For example, when you want to add extra validation to the input, you can naively
    paste a complex 50-line code waterfall of `if` statements directly into the handling
    function. This might make the next reader of your code cry (or yourself when you
    revisit this code months later). Alternatively, you can encapsulate everything
    to a single `func validate(input string) error` function, adding only slight complexity.
    Furthermore, to avoid modifying the handling block of code, you can design the
    code to validate it on the caller side or in the middleware. We can also rethink
    our system design and move validation complexity to another system or component,
    thus not implementing this feature. There are many ways to compose a particular
    feature without sacrificing our goals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您想为输入添加额外验证时，可以直接将复杂的50行代码`if`语句瀑布式地粘贴到处理函数中。这可能会让您的代码下一位读者哭泣（或者是您自己，当您几个月后重新查看这段代码时）。或者，您可以将所有内容封装到一个`func
    validate(input string) error`函数中，只添加轻微的复杂性。此外，为了避免修改处理代码块，您可以设计代码在调用者侧或中间件中验证它。我们还可以重新考虑系统设计，将验证复杂性转移到另一个系统或组件中，因此不实施此功能。组合特定功能时有很多方法，不会牺牲我们的目标。
- en: How are performance improvements in our code different from extra features?
    I would argue they are not. You can design efficiency optimizations with readability
    in mind as you do with features. Both can be entirely transparent to the readers
    if hidden under abstractions.^([5](ch01.html#idm45606857311024))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码性能改进与额外功能有什么不同？我认为它们没有区别。您可以像处理功能一样，以可读性为目标设计效率优化。隐藏在抽象背后，二者可以对读者完全透明。^([5](ch01.html#idm45606857311024))
- en: Yet we tend to mark optimizations as the primary source of readability problems.
    The foremost damaging consequence of this and other misconceptions in this chapter
    is that it’s often used as an excuse to ignore performance improvements completely.
    This often leads to something called *premature pessimization*, the act of making
    the program less efficient, the opposite of optimization.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们往往会将优化标记为可读性问题的主要来源。本章中其他错误观念的主要破坏性后果是，它们往往被用作完全忽略性能改进的借口。这往往导致所谓的*过早悲观化*，即使程序变得效率更低，反之亦然。
- en: 'Easy on yourself, easy on the code: All other things being equal, notably code
    complexity and readability, certain efficient design patterns and coding idioms
    should just flow naturally from your fingertips and are no harder to write than
    the pessimized alternatives. This is not premature optimization; it is avoiding
    gratuitous [unnecessary] pessimization.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 轻松对待自己，轻松对待代码：在其他一切相同的情况下，特别是代码复杂性和可读性，某些高效的设计模式和编码惯例应该从您的指尖自然流淌，并且比最优化的替代方案写起来更加容易。这不是过早优化；这是避免无谓的[不必要]悲观化。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'H. Sutter and A. Alexandrescu, *C++ Coding Standards: 101 Rules, Guidelines,
    and Best Practices* (Addison-Wesley, 2004)'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: H. Sutter 和 A. Alexandrescu，《C++ 编程规范：101 条规则、指南和最佳实践》（Addison-Wesley，2004 年）
- en: Readability is essential. I would even argue that unreadable code is rarely
    efficient over the long haul. When software evolves, it’s easy to break previously
    made, too-clever optimization because we misinterpret or misunderstand it. Similar
    to bugs and mistakes, it’s easier to cause performance issues in tricky code.
    In [Chapter 10](ch10.html#ch-opt), you will see examples of deliberate efficiency
    changes, with a focus on maintainability and readability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性至关重要。我甚至认为不可读的代码在长期来看很少高效。当软件演化时，很容易破坏先前的过于巧妙的优化，因为我们误解或误解它。类似于错误和错误，很难在复杂代码中引入性能问题。您将在[第
    10 章](ch10.html#ch-opt)中看到故意的效率更改示例，重点是可维护性和可读性。
- en: Readability Is Important!
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性很重要！
- en: It’s easier to optimize readable code than make heavily optimized code readable.
    This is true for both humans and compilers that might attempt to optimize your
    code!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 优化易读的代码比将严重优化的代码变得易读更容易。这对于人类和试图优化您的代码的编译器来说都是真实的！
- en: Optimization often results in less readable code because we don’t design good
    efficiency into our software from the beginning. If you refuse to think about
    efficiency now, it might be too late to optimize the code later without impacting
    readability. It’s much easier to find a way to introduce a simpler and more efficient
    way of doing things in the fresh modules where we just started to design APIs
    and abstractions. As you will learn in [Chapter 3](ch03.html#ch-efficiency), we
    can do performance optimizations on many different levels, not only via nitpicking
    and code tuning. Perhaps we can choose a more efficient algorithm, faster data
    structure, or a different system trade-off. These will likely result in much cleaner,
    maintainable code and better performance than improving efficiency after releasing
    the software. Under many constraints, like backward compatibility, integrations,
    or strict interfaces, our only way to improve performance would be to introduce
    additional, often significant, complexity to the code or system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有从一开始就设计软件的良好效率，优化通常会导致代码不易读。如果现在拒绝考虑效率，后期要优化代码可能会对可读性产生影响。在我们刚开始设计 API
    和抽象的新模块中，找到引入更简单、更高效方法的途径要容易得多，正如您将在[第三章](ch03.html#ch-efficiency)中学到的那样，我们可以在许多不同的层面上进行性能优化，而不仅仅是通过挑剔和代码调整。也许我们可以选择更高效的算法、更快的数据结构或不同的系统权衡。这些将很可能导致更清洁、更易维护的代码和更好的性能，而不是在发布软件后再优化效率。在许多约束条件下，如向后兼容性、集成或严格接口，我们提高性能的唯一途径可能是引入额外的、通常是显著的代码或系统复杂性。
- en: Code after optimization can be more readable
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化后的代码可能更易读
- en: Surprisingly, code after optimization can be more readable! Let’s look at a
    few Go code examples. [Example 1-1](#code-get1) is a naive use of a getter pattern
    that I have personally seen hundreds of times when reviewing student or junior
    developer Go code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，优化后的代码可能更易读！让我们看几个 Go 代码示例。[示例 1-1](#code-get1) 是一种天真的获取器模式的使用方式，我在审核学生或初级开发者的
    Go 代码时经常看到。
- en: Example 1-1\. Simple calculation for the ratio of reported errors
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 报告错误比例的简单计算
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_software_efficiency_matters_CO1-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_software_efficiency_matters_CO1-1)'
- en: This is a simplified example, but there is quite a popular pattern of passing
    a function or interface to get the elements needed for operation instead of passing
    them directly. It is useful when elements are dynamically added, cached, or fetched
    from remote databases.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简化的例子，但传递函数或接口以获取操作所需的元素的模式非常流行。当元素是动态添加的、缓存的或从远程数据库获取时，这种方式非常有用。
- en: '[![2](assets/2.png)](#co_software_efficiency_matters_CO1-2)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_software_efficiency_matters_CO1-2)'
- en: Notice we execute `Get` to retrieve reports three times.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们执行 `Get` 三次以检索报告。
- en: I think you would agree that code from [Example 1-1](#code-get1) would work
    for most cases. It is simple and quite readable. Yet, I would most likely not
    accept such code because of potential efficiency and accuracy issues. I would
    suggest simple modification as in [Example 1-2](#code-get2) instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你会同意，[示例 1-1](#code-get1) 中的代码对大多数情况都适用。它简单而且相当易读。然而，由于可能存在效率和准确性问题，我可能不会接受这样的代码。我建议像[示例 1-2](#code-get2)
    那样进行简单的修改。
- en: Example 1-2\. Simple, more efficient calculation for the ratio of reported errors
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 更高效的计算报告错误比例的简单方法
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_software_efficiency_matters_CO2-1)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_software_efficiency_matters_CO2-1)'
- en: In comparison with [Example 1-1](#code-get1), instead of calling `Get` in three
    places, I do it once and reuse the result via the `got` variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与[示例 1-1](#code-get1)相比，我只调用`Get`一次，并通过变量`got`重复使用结果。
- en: Some developers could argue that the `FailureRatio` function is potentially
    used very rarely; it’s not on a critical path, and the current `ReportGetter`
    implementation is very cheap and fast. They could argue that without measuring
    or benchmarking we can’t decide what’s more efficient (which is mostly true!).
    They could call my suggestion a “premature optimization.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员可能会争辩说，`FailureRatio` 函数可能很少使用；它不在关键路径上，而当前的 `ReportGetter` 实现非常便宜和快速。他们可能会认为，没有测量或基准测试，我们无法决定哪种更有效（这在大多数情况下是正确的！）。他们可能会称呼我的建议为“过早优化”。
- en: 'However, I deem it a very popular case of premature pessimization. It is a
    silly case of rejecting more efficient code that doesn’t speed up things a lot
    right now but doesn’t harm either. On the contrary, I would argue that [Example 1-2](#code-get2)
    is superior in many aspects:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我认为这是一个非常普遍的过早悲观化案例。这是一个愚蠢的情况，拒绝更高效的代码，虽然现在并没有显著加快速度，但也没有造成任何损害。相反，我认为[示例 1-2](#code-get2)
    在许多方面更为优越：
- en: Without measurements, the [Example 1-2](#code-get2) code is more efficient.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测量数据，[示例 1-2](#code-get2) 的代码更高效。
- en: Interfaces allow us to replace the implementation. They represent a certain
    contract between users and implementations. From the point of view of the `FailureRatio`
    function, we cannot assume anything beyond that contract. Most likely, we cannot
    assume that the `ReportGetter.Get` code will always be fast and cheap.^([6](ch01.html#idm45606843921408))
    Tomorrow, someone might swap the `Get` code with the expensive I/O operation against
    a filesystem, implementation with mutexes, or call to the remote database.^([7](ch01.html#idm45606843871360))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接口允许我们替换实现。它们代表用户和实现之间的某种契约。从`FailureRatio`函数的角度来看，我们不能假设超出该契约的任何内容。很可能，我们不能假设`ReportGetter.Get`代码将始终快速且廉价。^([6](ch01.html#idm45606843921408))
    明天，有人可能会用针对文件系统的昂贵I/O操作，带有互斥锁的实现或对远程数据库的调用来替换`Get`代码。^([7](ch01.html#idm45606843871360))
- en: We, of course, can iterate and optimize it later with a proper efficiency flow
    that we will discuss in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow),
    but if it’s a reasonable change that actually improves other things too, there
    is no harm in doing it now.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以稍后通过适当的效率流程进行迭代和优化，我们将在[“效率感知开发流程”](ch03.html#ch-conq-eff-flow)中讨论，但如果这是一个合理的改变，实际上还能改善其他事情，现在做也没有坏处。
- en: '[Example 1-2](#code-get2) code is safer.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](#code-get2) 的代码更安全。'
- en: It is potentially not visible in plain sight, but the code from [Example 1-1](#code-get1)
    has a considerable risk of introducing race conditions. We may hit a problem if
    the `ReportGetter` implementation is synchronized with other threads that dynamically
    change the `Get()` result over time. It’s better to avoid races and ensure consistency
    within a function body. Race errors are the hardest to debug and detect, so it’s
    better to be safe than sorry.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这在肉眼中可能看不见，但来自[示例 1-1](#code-get1) 的代码有引入竞态条件的相当大风险。如果`ReportGetter`实现与动态更改`Get()`结果的其他线程同步，我们可能会遇到问题。最好避免竞争，并确保函数体内的一致性。竞态错误是最难调试和检测的，因此宁愿安全也不要后悔。
- en: '[Example 1-2](#code-get2) code is more readable.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](#code-get2) 的代码更可读。'
- en: We might be adding one more line and an extra variable, but at the end, the
    code in [Example 1-2](#code-get2) is explicitly telling us that we want to use
    the same result across three usages. By replacing three instances of the `Get()`
    call with a simple variable, we also minimize the potential side effects, making
    our `FailureRatio` purely functional (except the first line). By all means, [Example 1-2](#code-get2)
    is thus more readable than [Example 1-1](#code-get1).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会添加一行额外的变量，但最终，在[示例 1-2](#code-get2) 中的代码明确告诉我们，我们希望在三个使用中使用相同的结果。通过用一个简单的变量替换三个`Get()`调用实例，我们还可以最小化潜在的副作用，使我们的`FailureRatio`函数纯函数化（除了第一行）。毫无疑问，从所有方面来看，[示例 1-2](#code-get2)
    比[示例 1-1](#code-get1) 更可读。
- en: Such a statement might be accurate, but evil is in the “premature” part. Not
    every performance optimization is premature. Furthermore, such a rule is not a
    license for rejecting or forgetting about more efficient solutions with comparable
    complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的说法可能是准确的，但邪恶在于“过早”的部分。并非每种性能优化都是过早的。此外，这样的规则并不授权我们拒绝或忽视具有相当复杂性的更高效解决方案。
- en: Another example of optimized code yielding clarity is visualized by the code
    in Examples [1-3](#code-prea1) and [1-4](#code-prea2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优化代码清晰度的例子可以通过示例[1-3](#code-prea1)和[1-4](#code-prea2)中的代码可视化。
- en: Example 1-3\. Simple loop without optimization
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-3\. 简单循环，没有优化
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_software_efficiency_matters_CO3-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_software_efficiency_matters_CO3-1)'
- en: Returning named parameter called `slice` will create a variable holding an empty
    `string` slice at the start of the function call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回名为`slice`的命名参数将在函数调用开始时创建一个持有空`string`切片的变量。
- en: '[![2](assets/2.png)](#co_software_efficiency_matters_CO3-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_software_efficiency_matters_CO3-2)'
- en: We append seven `string` items to the slice and repeat that `n` times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向切片追加七个`string`项，并重复`n`次。
- en: '[Example 1-3](#code-prea1) shows how we usually fill slices in Go, and you
    might say nothing is wrong here. It just works. However, I would argue that this
    is not how we should append in the loop if we know exactly how many elements we
    will append to the slice up front. Instead, in my opinion, we should always write
    it as in [Example 1-4](#code-prea2).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-3](#code-prea1) 展示了我们通常在 Go 中如何填充切片，您可能会认为这里没有任何问题。它只是有效地工作。然而，我认为如果我们事先知道我们将向切片附加多少元素，那么我们不应该在循环中这样写。在我看来，我们应该始终像
    [示例 1-4](#code-prea2) 中那样编写。'
- en: Example 1-4\. Simple loop with pre-allocation optimization. Is this less readable?
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-4\. 带有预分配优化的简单循环。这样的代码可读性更低吗？
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_software_efficiency_matters_CO4-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_software_efficiency_matters_CO4-1)'
- en: We are creating a variable holding the string `slice`. We are also allocating
    space (capacity) for `n * 7` strings for this slice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个包含字符串 `slice` 的变量。我们还为此切片分配了 `n * 7` 个字符串的空间（容量）。
- en: '[![2](assets/2.png)](#co_software_efficiency_matters_CO4-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_software_efficiency_matters_CO4-2)'
- en: We append seven `string` items to the slice and repeat that `n` times.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向切片附加了七个 `string` 项目，并重复 `n` 次。
- en: 'We will talk about efficiency optimizations like those in Examples [1-2](#code-get2)
    and [1-4](#code-prea2) in [“Pre-Allocate If You Can”](ch11.html#ch-basic-prealloc),
    with the more profound Go runtime knowledge from [Chapter 4](ch04.html#ch-hardware).
    In principle, both allow our program to do less work. In [Example 1-4](#code-prea2),
    thanks to initial pre-allocation, the internal `append` implementation does not
    need to extend slice size in memory progressively. We do it once at the start.
    Now, I would like you to focus on the following question: is this code more or
    less readable?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论效率优化，如示例 [1-2](#code-get2) 和 [1-4](#code-prea2)，以及来自[“预先分配如果可能”](ch11.html#ch-basic-prealloc)的更深刻的
    Go 运行时知识，与 [第四章](ch04.html#ch-hardware)。原则上，这两者都使我们的程序工作量减少。在 [示例 1-4](#code-prea2)
    中，由于初始预分配，内部的 `append` 实现在内存中不需要逐步扩展切片大小。我们一开始就完成了。现在，我希望您关注以下问题：这段代码可读性更高还是更低？
- en: Readability can often be subjective, but I would argue the more efficient code
    from [Example 1-4](#code-prea2) is more understandable. It adds one more line,
    so we could say the code is a bit more complex, but at the same time, it is explicit
    and clear in the message. Not only does it help Go runtime perform less work,
    but it also hints to the reader about the purpose of this loop and how many iterations
    we expect exactly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性通常是主观的，但我认为来自 [示例 1-4](#code-prea2) 的更有效率的代码更易理解。它增加了一行，因此我们可以说代码有点更复杂，但同时，它在消息上是显式且清晰的。它不仅帮助
    Go 运行时执行更少的工作，还向读者提示了此循环的目的以及我们期望的迭代次数。
- en: If you have never seen raw usage of the built-in `make` function in Go, you
    probably would say that this code is less readable. That is fair. However, once
    you realize the benefit and start using this pattern consistently across the code,
    it becomes a good habit. Even more, thanks to that, any slice creation without
    such pre-allocation tells you something too. For instance, it could say that the
    number of iterations is unpredictable, so you know to be more careful. You know
    one thing before you even looked at the loop’s content! To make such a habit consistent
    across the Prometheus and Thanos codebase, we even added a related [entry to the
    Thanos Go coding style guide](https://oreil.ly/Nq6tY).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从未见过在 Go 中内置的 `make` 函数的原始用法，您可能会认为这段代码可读性较低。这是公平的。然而，一旦您意识到其好处并在整个代码中始终如一地使用此模式，它就会成为一种良好的习惯。甚至更多，由于这一点，任何没有此类预分配的切片创建也告诉了您一些信息。例如，它可能表明迭代次数是不可预测的，因此您需要更加小心。您甚至在查看循环内容之前就知道了一件事！为了使这样的习惯在
    Prometheus 和 Thanos 代码库中保持一致，我们甚至添加了相关的[Thanos Go 编码风格指南条目](https://oreil.ly/Nq6tY)。
- en: Readability Is Not Written in Stone; It Is Dynamic
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性不是一成不变的；它是动态的。
- en: The ability to understand certain software code can change over time, even if
    the code never changes. Conventions come and go as the language community tries
    new things. With strict consistency, you can help the reader understand even more
    complex pieces of your program by introducing a new, clear convention.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码从未更改，理解特定软件代码的能力随时间可能会发生变化。随着语言社区尝试新事物，传统会来来去去。通过严格一致性，您可以通过引入新的清晰约定帮助读者理解甚至更复杂的程序片段。
- en: Readability now versus past
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在与过去的可读性
- en: Generally, developers often apply Knuth’s “premature optimization is the root
    of all evil” quote^([8](ch01.html#idm45606843577968)) to reduce readability problems
    with optimizations. However, this quote was made a long time ago. While we can
    learn a lot about general programming from the past, there are many things we
    have improved enormously from 1974\. For example, back then it was popular to
    add information about the type of the variable to its name, as showcased in [Example 1-5](#code-hung).^([9](ch01.html#idm45606843574448))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，开发者经常引用 Knuth 的“过早优化是所有邪恶之根源”这句话^([8](ch01.html#idm45606843577968)) 来减少优化带来的可读性问题。
    然而，这句话是很久以前说的。 虽然我们可以从过去的一般编程中学到很多东西，但我们已经在 1974 年后极大地改进了许多事物。 例如，那时流行的做法是向变量名称添加其类型信息，正如
    [示例 1-5](#code-hung) 中展示的那样^([9](ch01.html#idm45606843574448))。
- en: Example 1-5\. Example of Systems Hungarian notation applied to Go code
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-5。 应用于 Go 代码的系统匈牙利命名法示例
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hungarian notation was useful because compilers and Integrated Development Environments
    (IDEs) were not very mature at that point. But nowadays, on our IDEs or even repository
    websites like GitHub, we can hover over the variable to immediately know its type.
    We can go to the variable definition in milliseconds, read the commentary, and
    find all invocations and mutations. With smart code suggestions, advanced highlighting,
    and dominance of object-oriented programming developed in the mid-1990s, we have
    tools in our hands that allow us to add features and efficiency optimizations
    (complexity) without significantly impacting the practical readability.^([10](ch01.html#idm45606843547632))
    Furthermore, the accessibility and capabilities of the observability and debugging
    tools have grown enormously, which we will explore in [Chapter 6](ch06.html#ch-observability).
    It still does not permit clever code but allows us to more quickly understand
    bigger codebases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法曾经非常有用，因为当时编译器和集成开发环境（IDE）并不是很成熟。 但是现在，在我们的 IDE 或甚至像 GitHub 这样的仓库网站上，我们可以将鼠标悬停在变量上以立即知道其类型。
    我们可以在毫秒内转到变量定义，阅读评论，并查找所有调用和变异。 随着智能代码建议、高级突出显示和在 1990 年代中期开发的面向对象编程的主导地位，我们手头的工具使我们能够在不显著影响实际可读性的情况下添加功能和效率优化（复杂性）。^([10](ch01.html#idm45606843547632))
    此外，观察性和调试工具的可访问性和功能已经极大地增长，我们将在 [第 6 章](ch06.html#ch-observability) 中探讨这一点。 它仍然不允许巧妙的代码，但允许我们更快地理解更大的代码库。
- en: To sum up, performance optimization is like another feature in our software,
    and we should treat it accordingly. It can add complexity, but there are ways
    to minimize the cognitive load required to understand our code.^([11](ch01.html#idm45606843544416))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，性能优化就像我们软件中的另一个功能，我们应该相应地对待它。 它可能会增加复杂性，但有方法可以减少理解我们代码所需的认知负荷。^([11](ch01.html#idm45606843544416))
- en: How to Make Efficient Code More Readable
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使高效的代码更易读
- en: Remove or avoid unnecessary optimization.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除或避免不必要的优化。
- en: Encapsulate complex code behind clear abstraction (e.g., interface).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂代码封装在清晰的抽象背后（例如接口）。
- en: Keep the “hot” code (the critical part that requires better efficiency) separate
    from the “cold” code (rarely executed).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“热”代码（需要更好效率的关键部分）与“冷”代码（很少执行的代码）分开。
- en: As we learned in this chapter, there are even cases when a more efficient program
    is often a side effect of the simple, explicit, and understandable code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中学到的，有时更高效的程序往往是简单、明确和可理解代码的副产品。
- en: You Aren’t Going to Need It
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: You Aren’t Going to Need It
- en: You Aren’t Going to Need It (YAGNI) is a powerful and popular rule that I use
    often while writing or reviewing any software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: You Aren’t Going to Need It (YAGNI) 是一条强大且流行的规则，在编写或审核任何软件时我经常使用。
- en: One of the most widely publicized principles of XP [Extreme Programming] is
    the You Aren’t Going to Need It (YAGNI) principle. The YAGNI principle highlights
    the value of delaying an investment decision in the face of uncertainty about
    the return on the investment. In the context of XP, this implies delaying the
    implementation of fuzzy features until uncertainty about their value is resolved.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XP [极限编程] 最广为人知的原则之一是 **You Aren’t Going to Need It (YAGNI)** 原则。 YAGNI 原则强调在面对投资回报不确定性时延迟投资决策的价值。
    在 XP 的背景下，这意味着推迟实现模糊功能，直到确定其价值的不确定性得到解决。
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hakan Erdogmu and John Favaro, “Keep Your Options Open: Extreme Programming
    and the Economics of Flexibility”'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Hakan Erdogmu 和 John Favaro，《保持选择的开放性：极限编程与灵活性经济学》
- en: In principle, it means avoiding doing the extra work that is not strictly needed
    for the current requirements. It relies on the fact that requirements constantly
    change, and we have to embrace iterating rapidly on our software.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从原则上讲，它意味着避免做那些当前需求中并非绝对必要的额外工作。这基于需求经常变化的事实，我们必须接受在软件上快速迭代的观点。
- en: 'Let’s imagine a potential situation where Katie, a senior software engineer,
    is assigned the task of creating a simple web server. Nothing fancy, just an HTTP
    server that exposes some REST endpoint. Katie is an experienced developer who
    has created probably a hundred similar endpoints in the past. She goes ahead,
    programs functionality, and tests the server in no time. With some time left,
    she decides to add extra functionality: a [simple bearer token authorization layer](https://oreil.ly/EuKD0).
    Katie knows that such change is outside the current requirements, but she has
    written hundreds of REST endpoints, and each had a similar authorization. Experience
    tells her it’s highly likely such requirements will come soon, too, so she will
    be prepared. Do you think such a change would make sense and should be accepted?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一种潜在的情况，凯蒂，一位资深软件工程师，被分配任务创建一个简单的Web服务器。没什么花哨的，只是一个暴露一些REST端点的HTTP服务器。凯蒂是一位经验丰富的开发者，在过去可能已经创建了数百个类似的端点。她前进，编写功能，并在很短时间内测试了服务器。还有一些时间，她决定添加额外的功能：一个[简单的持有者令牌授权层](https://oreil.ly/EuKD0)。凯蒂知道这样的变更超出了当前的需求，但是她以前创建过数百个REST端点，每一个都有类似的授权。经验告诉她，这样的需求很可能很快也会出现，所以她想要做好准备。你认为这样的变更是否有意义，应该被接受？
- en: While Katie has shown good intention and solid experience, we should refrain
    from merging such change to preserve the quality of the web server code and overall
    development cost-effectiveness. In other words, we should apply the YAGNI rule.
    Why? In most cases, we cannot predict a feature. Sticking to requirements allows
    us to save time and complexity. There is a risk that the project will never need
    an authorization layer, for example, if the server is running behind a dedicated
    authorization proxy. In such a case, the extra code Katie wrote can bring a high
    cost even if not used. It is additional code to read, which adds to the cognitive
    load. Furthermore, it will be harder to change or refactor such code when needed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管凯蒂表现出了良好的意图和扎实的经验，但为了保持Web服务器代码的质量和整体开发的成本效益，我们应该避免合并这样的变更。换句话说，我们应当遵循YAGNI规则。为什么呢？在大多数情况下，我们无法预测一个功能。坚持需求能够帮助我们节省时间和复杂性。有一种风险，即项目可能永远不需要授权层，例如，如果服务器在专用授权代理后运行。在这种情况下，即使不使用，凯蒂编写的额外代码也会带来很高的成本。这是额外的阅读代码，增加了认知负荷。此外，当需要时，更改或重构这样的代码会更加困难。
- en: Now, let’s step into a grayer area. We explained to Katie why we needed to reject
    the authorization code. She agreed, and instead, she decided to add some critical
    monitoring to the server by instrumenting it with a few vital metrics. Does this
    change violate the YAGNI rule too?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入一个更加模糊的领域。我们向凯蒂解释了为什么需要拒绝授权代码。她同意了，并且决定通过在服务器上添加一些关键的监控来仪器化它，这些监控是一些关键指标。这种变更是否也违反了YAGNI规则？
- en: If monitoring is part of the requirements, it does not violate the YAGNI rule
    and should be accepted. If it’s not, without knowing the full context, it’s hard
    to say. Critical monitoring should be explicitly mentioned in the requirements.
    Still, even if it is not, web server observability is the first thing that will
    be needed when we run such code anywhere. Otherwise, how will we know that it
    is even running? In this case, Katie is technically doing something important
    that is immediately useful. In the end, we should apply common sense and judgment,
    and add or explicitly remove monitoring from the software requirements before
    merging this change.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果监控是需求的一部分，它不违反YAGNI规则，应当被接受。如果不是，在不了解完整背景的情况下，很难说。关键监控应明确列入需求中。但即使没有，当我们在任何地方运行这样的代码时，Web服务器的可观察性是首要需要的。否则，我们如何知道它是否正在运行？在这种情况下，凯蒂在技术上做了一些立即有用的重要事情。最终，我们应当运用常识和判断，在合并这种变更之前，向软件需求中添加或明确删除监控。
- en: Later, in her free time, Katie decided to add a simple cache to the necessary
    computation that enhances the performance of the separate endpoint reads. She
    even wrote and performed a quick benchmark to verify the endpoint’s latency and
    resource consumption improvements. Does that violate the YAGNI rule?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，在她的空闲时间里，Katie决定为增强单独端点读取的性能添加一个简单的缓存。她甚至编写并执行了一个快速的基准测试，以验证端点的延迟和资源消耗的改进。这是否违反了YAGNI规则呢？
- en: The sad truth about software development is that performance efficiency and
    response time are often missing from stakeholders’ requirements. The target performance
    goal for an application is to “just work” and be “fast enough,” without details
    on what that means. We will discuss how to define practical software efficiency
    requirements in [“Resource-Aware Efficiency Requirements”](ch03.html#ch-conq-req).
    For this example, let’s assume the worst. There was nothing in the requirements
    list about performance. Should we then apply the YAGNI rule and reject Katie’s
    change?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件开发的悲哀之一是，性能效率和响应时间通常不在利益相关者的需求之列。应用程序的目标性能目标是“只要能工作”和“足够快”，但没有详细说明这意味着什么。我们将讨论如何在[“资源感知效率需求”](ch03.html#ch-conq-req)中定义实际的软件效率需求。在这个例子中，让我们假设最坏的情况。在需求列表中没有关于性能的内容。那么我们是否应该应用YAGNI规则并拒绝Katie的更改呢？
- en: Again, it is hard to tell without full context. Implementing a robust and usable
    cache is not trivial, so how complex is the new code? Is the data we are working
    on easily “cachable”?^([12](ch01.html#idm45606843499040)) Do we know how often
    such an endpoint will be used (is it a critical path)? How far should it scale?
    On the other hand, computing the same result for a heavily used endpoint is highly
    inefficient, so cache is a good pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解清楚没有完整上下文是很难说的。实施一个健壮且可用的缓存并不是件小事，所以新代码有多复杂呢？我们正在处理的数据是否容易“可缓存”？^([12](ch01.html#idm45606843499040))
    我们知道这样的端点会被多频繁地使用吗（它是一个关键路径吗）？它应该扩展到多远？另一方面，为一个频繁使用的端点计算相同结果非常低效，所以缓存是一个很好的模式。
- en: 'I would suggest Katie take a similar approach as she did with monitoring change:
    consider discussing it with the team to clarify the performance guarantees that
    the web service should offer. That will tell us if the cache is required now or
    is violating the YAGNI rule.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议Katie采取与她处理监控变更类似的方法：考虑与团队讨论，明确Web服务应该提供的性能保证。这将告诉我们，缓存现在是否需要或违反了YAGNI规则。
- en: As a last change, Katie went ahead and applied a reasonable efficiency optimization,
    like the slice pre-allocation improvement you learned in [Example 1-4](#code-prea2).
    Should we accept such a change?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的更改，Katie继续进行了一个合理的效率优化，就像你在[示例 1-4](#code-prea2)中学到的切片预分配改进一样。我们应该接受这样的改变吗？
- en: I would be strict here and say yes. My suggestion is to always pre-allocate,
    as in [Example 1-4](#code-prea2) when you know the number of elements up front.
    Isn’t that violating the core statement behind the YAGNI rule? Even if something
    is generally applicable, you shouldn’t do it before you are sure you *are* going
    to need it?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我会在这里严格一点，答案是肯定的。我建议总是预先分配，就像在[示例 1-4](#code-prea2)中，当你预先知道元素的数量时。这是否违反了YAGNI规则背后的核心声明呢？即使某事通常适用，你也不应该在确定*会*需要之前就去做吧？
- en: I would argue that small efficiency habits that do not reduce code readability
    (some even improve it) should generally be an essential part of the developer’s
    job, even if not explicitly mentioned in the requirements. We will cover them
    as [“Reasonable Optimizations”](ch03.html#ch-conq-opt-reasonable). Similarly,
    no project requirements state basic best practices like code versioning, having
    small interfaces, or avoiding big dependencies.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，小的效率习惯，如果不会降低代码可读性（甚至会改善），通常应该成为开发者工作的重要部分，即使在需求中没有明确提到。我们将把它们作为[“合理优化”](ch03.html#ch-conq-opt-reasonable)来讨论。同样，没有项目需求规定像代码版本控制、拥有小接口或避免大依赖等基本最佳实践。
- en: The main takeaway here is that using the YAGNI rule helps, but it is not permission
    for developers to completely ignore performance efficiency. Thousands of small
    things usually make up excessive resource usage and latency of an application,
    not just a single thing we can fix later. Ideally, well-defined requirements help
    clarify your software’s efficiency needs, but they will never cover all the details
    and best practices we should try to apply.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要观点是，遵循YAGNI规则是有帮助的，但并不意味着开发人员完全可以忽略性能效率。通常成千上万的小事情造成应用程序的过多资源使用和延迟，而不仅仅是我们可以稍后修复的单个问题。理想情况下，清晰定义的需求有助于澄清软件的效率需求，但它们永远无法涵盖我们应该尝试应用的所有细节和最佳实践。
- en: Hardware Is Getting Faster and Cheaper
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件正在变得更快更便宜
- en: When I started programming we not only had slow processors, we also had very
    limited memory—sometimes measured in kilobytes. So we had to think about memory
    and optimize memory consumption wisely.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我开始编程时，我们不仅拥有缓慢的处理器，还有非常有限的内存——有时甚至只有几千字节。因此，我们必须考虑内存并明智地优化内存消耗。
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Valentin Simonov, [“Optimize for Readability First”](https://oreil.ly/I2NPk)
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 瓦伦丁·西蒙诺夫，《优先选择可读性》
- en: Undoubtedly, hardware is more powerful and less expensive than ever before.
    We see technological advancement on almost every front every year or month. From
    single-core Pentium CPUs with a 200-MHz clock rate in 1995, to smaller, energy-efficient
    CPUs capable of 3- to 4-GHz speeds. RAM sizes increased from dozens of MB in 2000
    to 64 GB in personal computers 20 years later, with faster access patterns. In
    the past, small capacity hard disks moved to SSD, then 7 GBps fast NVME SSD disks
    with a few TB of space. Network interfaces have achieved 100 gigabits throughput.
    In terms of remote storage, I remember floppy disks with 1.44 MB of space, then
    read-only CD-ROMs with a capacity of up to 553 MB; next we had Blu-Ray, read-write
    capability DVDs, and now it’s easy to get SD cards with TB sizes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，现在的硬件比以往任何时候都更强大、更便宜。我们几乎每年或每个月都能看到技术的进步。从1995年的单核奔腾CPU，时钟速率为200 MHz，到现在的小型、节能的CPU，速度可达3到4
    GHz。内存大小从2000年的几十MB增加到20年后个人电脑的64GB，访问速度更快。过去，小容量硬盘转向SSD，然后是每秒7GB的快速NVME SSD硬盘，几TB的存储空间。网络接口实现了每秒100Gb的吞吐量。在远程存储方面，我记得有1.44MB空间的软盘，接着是容量高达553MB的只读CD-ROM；接下来我们有蓝光、可读写的DVD，现在可以轻松获取带有TB容量的SD卡。
- en: Now let’s add to the preceding facts the popular opinion that the amortized
    hourly value of typical hardware is cheaper than the developer hour. With all
    of this, one would say that it does not matter if a single function in code takes
    1 MB more or does excessive disk reads. Why should we delay features, and educate
    or invest in performance-aware engineers if we can buy bigger servers and pay
    less overall?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加入前述事实，普遍观点是典型硬件的摊销小时价值比开发人员的时间更便宜。考虑到这一切，有人会说，如果代码中的一个函数多占用了1 MB或进行了过多的磁盘读取，也无关紧要。为什么我们要推迟功能，培养或投资于性能意识的工程师，如果我们可以购买更大的服务器并总体支付更少呢？
- en: As you can probably imagine, it’s not that simple. Let’s unpack this quite harmful
    argument descoping efficiency from the software development to-do list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你可以想象，事情并不是那么简单。让我们拆解这种非常有害的论点，将效率从软件开发的待办列表中剥离出来。
- en: First of all, stating that spending more money on hardware is cheaper than investing
    expensive developer time into efficiency topics is very shortsighted. It is like
    claiming that we should buy a new car and sell an old one every time something
    breaks, because repairing is nontrivial and costs a lot. Sometimes that might
    work, but in most cases it’s not very efficient or sustainable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声称在硬件上花更多的钱比在效率话题上投资昂贵的开发时间非常短视。这就像声称每次出了问题就买辆新车并卖掉旧车一样，因为修理不容易而且费用高昂。有时候这样做可能有效，但在大多数情况下，这并不是非常高效或可持续的。
- en: Let’s assume a software developer’s annual salary oscillates around $100,000\.
    With [other employment costs](https://oreil.ly/AxI0Y), let’s say the company has
    to pay $120,000 yearly, so $10,000 monthly. For $10,000 in 2021, you could buy
    a server with 1 TB of DDR4 memory, two high-end CPUs, 1-gigabit network card,
    and 10 TB of hard disk space. Let’s ignore for now the energy consumption cost.
    Such a deal means that our software can overallocate terabytes of memory every
    month, and we would still be better off than hiring an engineer to optimize this,
    right? Unfortunately, it doesn’t work like this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设软件开发人员的年薪大约在10万美元左右。考虑到[其他就业成本](https://oreil.ly/AxI0Y)，公司每年需要支付12万美元，即每月1万美元。2021年以1万美元购买一台配备1
    TB DDR4内存、两个高端CPU、1吉比特网络卡和10 TB硬盘空间的服务器。暂时忽略能源消耗成本。这样的交易意味着我们的软件每个月可以超额分配数TB的内存，而我们仍然比雇佣工程师来优化要好，对吧？不幸的是，事情并非如此。
- en: It turns out that terabytes of allocation are more common than you think, and
    you don’t need to wait a whole month! [Figure 1-2](#img-thanos-mem-profile) shows
    a screenshot of the heap memory profile of a single replica (of six total) of
    a single [Thanos](https://thanos.io) service (of dozens) running in a single cluster
    for five days. We will discuss how to read and use profiles in [Chapter 9](ch09.html#ch-observability3),
    but [Figure 1-2](#img-thanos-mem-profile) shows the total memory allocated by
    some `Series` function since the last restart of the process five days before.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域的分配量往往比你想象的要多得多，不必等待整整一个月！[图 1-2](#img-thanos-mem-profile)展示了一个单副本（总共六个副本之一）在单个集群中运行五天的堆内存概况的屏幕截图。我们将在[第9章](ch09.html#ch-observability3)讨论如何阅读和使用这些概况，但[图 1-2](#img-thanos-mem-profile)展示了自进程重启五天前某个`Series`函数的总分配内存。
- en: '![efgo 0102](assets/efgo_0102.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0102](assets/efgo_0102.png)'
- en: Figure 1-2\. Snippet of memory profile showing all memory allocations within
    five days made by high-traffic service
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 显示高流量服务在五天内的所有内存分配片段的内存概况
- en: Most of that memory was already released, but notice that this software from
    the Thanos project used 17.61 TB in total for only five days of running.^([13](ch01.html#idm45606843474240))
    If you write desktop applications or tools instead, you will hit a similar scale
    issue sooner or later. Taking the previous example, if one function is overallocating
    1 MB, that is enough to run it 100 times for critical operation in our application
    with only 100 desktop users to get to 10 TB wasted in total. Not in a month, but
    on a single run done by 100 users. As a result, slight inefficiency can quickly
    create overabundant hardware resources.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内存已经被释放，但请注意，来自Thanos项目的这款软件在仅运行五天的情况下总共使用了17.61 TB。^([13](ch01.html#idm45606843474240))
    如果您写桌面应用程序或工具，迟早会遇到类似的规模问题。根据先前的例子，如果一个函数超额分配1 MB，那么仅仅通过100个桌面用户的一次运行，该函数就可以在我们的应用程序中进行100次关键操作，总计浪费掉10
    TB。这不是一个月的时间，而是由100个用户一次运行造成的。因此，轻微的低效率很快就会导致过多的硬件资源。
- en: There is more. To afford an overallocation of 10 TB, it is not enough to buy
    a server with that much memory and pay for energy consumption. The amortized cost,
    among other things, has to include writing, buying, or at least maintaining firmware,
    drivers, operating systems, and software to monitor, update, and operate the server.
    Since for extra hardware we need additional software, by definition, this requires
    spending money on engineers, so we are back where we were. We might have saved
    engineering costs by avoiding focusing on performance optimizations. In return,
    we would spend more on other engineers required to maintain overused resources,
    or pay a cloud provider that already calculated such extra cost, plus a profit,
    into the cloud usage bill.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。要负担得起10 TB的超额分配，购买具有如此多内存的服务器并支付能源消耗是不够的。分摊成本，除其他外，还必须包括编写、购买或至少维护固件、驱动程序、操作系统以及用于监视、更新和操作服务器的软件。由于额外硬件需要额外软件，按定义，这需要花钱雇佣工程师，所以我们回到了起点。通过避免专注于性能优化来节省工程成本，我们可能会在维护过度使用的资源所需的其他工程师身上花更多钱，或者支付一个已经在云使用账单中计算了额外成本及利润的云服务提供商。
- en: On the other hand, today 10 TB of memory costs a lot, but tomorrow it might
    be a marginal cost due to technological advancements. What if we ignore performance
    problems and wait until server costs decrease or more users replace their laptops
    or phones with faster ones? Waiting is easier than debugging tricky performance
    issues!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，今天10 TB的内存成本很高，但明天由于技术进步可能只是边际成本。如果我们忽视性能问题，并等待服务器成本降低或更多用户用更快的设备替换他们的笔记本电脑或手机，会怎么样？等待比调试棘手的性能问题更容易！
- en: Unfortunately, we cannot skip software development efficiency and expect hardware
    advancements to mitigate needs and performance mistakes. Hardware is getting faster
    and more powerful, yes. But, unfortunately, not fast enough. Let’s go through
    three main reasons behind this nonintuitive effect.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能忽视软件开发效率，期望硬件进步来缓解需求和性能问题。硬件确实变得更快更强大，是的。但不幸的是，速度还不够快。让我们来看看这种非直观效应背后的三个主要原因。
- en: Software expands to fill the available memory
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件会扩展以填充可用的内存
- en: This effect is known as Parkinson’s Law.^([14](ch01.html#idm45606843465968))
    It states that no matter how many resources we have, the demands tend to match
    the supply. For example, Parkinson’s Law is heavily visible in universities. No
    matter how much time the professor gives for assignments or exam preparations,
    students will always use all of it and probably do most of it last-minute.^([15](ch01.html#idm45606843465280))
    We can see similar behavior in software development too.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效应被称为帕金森法则。^([14](ch01.html#idm45606843465968)) 它指出，无论我们拥有多少资源，需求总是倾向于匹配供给。例如，帕金森法则在大学中明显可见。无论教授给予作业或考试准备多少时间，学生总是会用光所有时间，可能大部分都是在最后一刻完成的。^([15](ch01.html#idm45606843465280))
    我们在软件开发中也可以看到类似的行为。
- en: Software gets slower more rapidly than hardware becomes faster
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件比硬件变得更快地变慢
- en: Niklaus Wirth mentions a “fat software” term that explains why there will always
    be more demand for more hardware.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Niklaus Wirth提到了一个“肥软件”的术语，解释了为什么总是会有更多对更多硬件需求的需求。
- en: Increased hardware power has undoubtedly been the primary incentive for vendors
    to tackle more complex problems.... But it is not the inherent complexity that
    should concern us; it is the self-inflicted complexity. There are many problems
    that were solved long ago, but for the same problems, we are now offered solutions
    wrapped in much bulkier software.
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 增加的硬件性能无疑是厂商处理更复杂问题的主要动力......但应该担心的不是固有复杂性，而是自我造成的复杂性。有许多问题早已解决，但对于同样的问题，我们现在提供的解决方案包装在更庞大的软件中。
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Niklaus Wirth, [“A Plea for Lean Software”](https://oreil.ly/bctyb)
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Niklaus Wirth, [“精简软件的呼吁”](https://oreil.ly/bctyb)
- en: Software is getting slower faster than hardware is getting more powerful because
    products have to invest in a better user experience to get profitable. These include
    prettier operating systems, glowing icons, complex animations, high-definition
    videos on websites, or fancy emojis that mimic your facial expression, thanks
    to facial recognition techniques. It’s a never-ending battle for clients, which
    brings more complexity, and thus increased computational demands.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 软件变得比硬件变得更快更强大更快，因为产品必须投资于更好的用户体验才能获得利润。这些包括更漂亮的操作系统，发光图标，复杂的动画，网站上的高清视频或模仿您面部表情的花哨表情符号，感谢面部识别技术。这是客户的永恒战斗，带来了更多的复杂性，因此增加了计算需求。
- en: On top of that, rapid democratization of software occurs thanks to better access
    to computers, servers, mobile phones, IoT devices, and any other kind of electronics.
    As Marc Andreessen said, [“Software is eating the world”](https://oreil.ly/QUND4).
    The COVID-19 pandemic that started in late 2019 accelerated digitalization even
    more as remote, internet-based services became the critical backbone of modern
    society. We might have more computation power available every day, but more functionalities
    and user interactions consume all of it and demand even more. In the end, I would
    argue that our overused 1 MB in the aforementioned single function might become
    a critical bottleneck on such a scale pretty quickly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于更好地访问计算机、服务器、手机、物联网设备和任何其他类型的电子设备，软件的快速民主化也在发生。正如Marc Andreessen所说，“软件正在吞噬世界”。自2019年末开始的COVID-19大流行加速了数字化进程，远程基于互联网的服务成为现代社会的重要支柱。每天我们可能有更多的计算能力可用，但更多的功能和用户交互都会耗尽所有资源，甚至需要更多。最后，我认为我们在前述单一功能中过度使用的1
    MB可能很快就会成为一个重要的瓶颈。
- en: 'If that still feels very hypothetical, just look at the software around you.
    We use social media, where Facebook alone [generates 4 PB](https://oreil.ly/oowCN)^([16](ch01.html#idm45606843454544))
    of data per day. We search online, causing Google to process 20 PB of data per
    day. However, one would say those are rare, planet-scale systems with billions
    of users. Typical developers don’t have such problems, right? When I looked at
    most of the software co-created or used, they hit some performance issues related
    to significant data usage sooner or later. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然感觉非常假设性，只需看看你周围的软件。我们使用社交媒体，其中仅Facebook每天[生成4PB](https://oreil.ly/oowCN)^([16](ch01.html#idm45606843454544))的数据。我们在网上搜索，导致谷歌每天处理20PB的数据。然而，有人可能会说这些都是罕见的、全球规模的系统，拥有数十亿用户。典型的开发人员没有这样的问题，对吧？当我看到大多数共同创造或使用的软件时，他们迟早会遇到与大数据使用相关的性能问题。
- en: A Prometheus UI page, written in React, was performing a search on millions
    of metric names or tried to fetch hundreds of megabytes of compressed samples,
    causing browser latencies and explosive memory usage.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用React编写的Prometheus UI页面在数百万个度量名称上执行搜索，或尝试获取数百兆字节的压缩样本，导致浏览器延迟和爆炸性内存使用。
- en: With low usage, a single Kubernetes cluster at our infrastructure generated
    0.5 TB of logs daily (most of them never used).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在低使用率下，我们基础设施的一个Kubernetes集群每天生成0.5TB的日志（其中大部分从未被使用）。
- en: The excellent grammar checking tool I used to write this book was making too
    many network calls when the text had more than 20,000 words, slowing my browser
    considerably.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我用来撰写本书的优秀语法检查工具在文本超过20,000字时进行了过多的网络调用，严重拖慢了我的浏览器。
- en: Our simple script for formatting our documentation in Markdown and link checking
    took minutes to process all elements.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用 Markdown 格式化和链接检查的简单脚本，花了几分钟处理所有元素。
- en: Our Go static analysis job and linting exceeded 4 GB of memory and crashed our
    CI jobs.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的Go静态分析作业和linting超过了4GB内存，导致我们的CI作业崩溃。
- en: My IDE used to take 20 minutes to index all code from our mono-repo, despite
    doing it on a top-shelf laptop.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的IDE曾经需要20分钟才能索引我们的单体库中的所有代码，尽管我使用的是顶级笔记本电脑。
- en: I still haven’t edited my 4K ultrawide videos from GoPro because the software
    is too laggy.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我仍未编辑我的GoPro 4K超广角视频，因为软件太卡了。
- en: I could go on forever with examples, but the point is that we live in a really
    “big data” world. As a result, we have to optimize memory and other resources
    wisely.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以举例说个没完没了，但关键是我们生活在一个真正的“大数据”世界中。因此，我们必须明智地优化内存和其他资源。
- en: It will be much worse in the future. Our software and hardware have to handle
    the data growing at extreme rates, faster than any hardware development. We are
    just on the edge of introducing [5G networks capable of transfers up to 20 gigabits
    per second](https://oreil.ly/CWvFG). We introduce mini-computers in almost every
    item we buy, like TVs, bikes, washing machines, freezers, desk lamps, or even
    [deodorants](https://oreil.ly/DvZil)! We call this movement the “Internet of Things”
    (IoT). Data from these devices is [estimated to grow from 18.3 ZB in 2019 to 73.1
    ZB by 2025](https://oreil.ly/J1o6D).^([17](ch01.html#idm45606843442000)) The industry
    can produce 8K TVs, rendering resolutions of 7,680 × 4,320, so approximately 33
    million pixels. If you have written computer games, you probably understand this
    problem well—it will take a lot of efficient effort to render so many pixels in
    highly realistic games with immersive, highly destructive environments at 60+
    frames per second. Modern cryptocurrencies and blockchain algorithms also pose
    challenges in computational energy efficiencies; e.g., Bitcoin energy consumption
    during the value peak was using [roughly 130 Terawatt-hours of energy (0.6% of
    global electricity consumption)](https://oreil.ly/NfnJ9).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 未来情况将会更糟。我们的软件和硬件必须处理数据以极快速度增长，这比任何硬件发展都要快。我们正处于引入[每秒传输高达20吉比特的5G网络](https://oreil.ly/CWvFG)的边缘。我们几乎在每一件购买的物品中引入了迷你计算机，如电视、自行车、洗衣机、冰柜、台灯，甚至[除臭剂](https://oreil.ly/DvZil)!
    我们称这种运动为“物联网”（IoT）。预计从这些设备中获取的数据将从2019年的18.3 ZB增长到2025年的73.1 ZB[^17]。该行业可以生产8K电视，分辨率为7,680
    × 4,320，约3300万像素。如果您编写过电脑游戏，您可能很了解这个问题——在高度逼真的游戏中，以60帧以上的速度渲染这么多像素需要大量的有效工作。现代加密货币和区块链算法也对计算能效提出了挑战；例如，比特币在价值高峰期间的能源消耗达到了[约130太瓦时（全球电力消耗的0.6%）](https://oreil.ly/NfnJ9)。
- en: Technological limits
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术限制
- en: The last reason, but not least, behind not fast enough hardware progression
    is that hardware advancement has stalled on some fronts like CPU speed (clock
    rate) or memory access speeds. We will cover some challenges of that situation
    in [Chapter 4](ch04.html#ch-hardware), but I believe every developer should be
    aware of the fundamental technological limits we are hitting right now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原因，但同样重要的是，导致硬件进展不够快的背后原因之一是，硬件的进步在某些方面停滞不前，比如CPU速度（时钟频率）或内存访问速度。我们将在[第四章](ch04.html#ch-hardware)中讨论这种情况的一些挑战，但我认为每个开发者都应该意识到我们当前所面临的基本技术限制。
- en: It would be odd to read a modern book about efficiency that doesn’t mention
    Moore’s Law, right? You’ve probably heard of it somewhere before. It was first
    stated in 1965 by former CEO and cofounder of Intel, Gordon Moore.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的效率书籍中读到不提及摩尔定律会感到奇怪，对吧？你可能在某处已经听说过它。这一定律是由英特尔的前首席执行官和联合创始人戈登·摩尔于1965年首次提出的。
- en: The complexity for minimum component costs [the number of transistors, with
    minimal manufacturing cost per chip] has increased at a rate of roughly a factor
    of two per year. ... Over the longer term, the rate of increase is a bit more
    uncertain, although there is no reason to believe it will not remain nearly constant
    for at least 10 years. That means by 1975, the number of components per integrated
    circuit for minimum cost will be 65,000.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最小组件成本的复杂性（每个芯片的晶体管数量，具有最低制造成本）每年以约两倍的速度增加……从长远来看，增长率更加不确定，尽管没有理由认为它在至少10年内不会保持几乎恒定的状态。这意味着到1975年，为了最低成本，集成电路每个组件的数量将达到65,000个。
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gordon E. Moore, [“Cramming More Components onto Integrated Circuits”](https://oreil.ly/WhuWd),
    *Electronics* 38 (1965)
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 戈登·E·摩尔，《“在集成电路上装更多的元件”》（https://oreil.ly/WhuWd），《电子》38（1965年）
- en: Moore’s observation had a big impact on the semiconductor industry. But decreasing
    the transistors’ size would not have been that beneficial if not for Robert H.
    Dennard and his team. In 1974, their experiment revealed that power use stays
    proportional to the transistor dimension (constant power density).^([18](ch01.html#idm45606843429376))
    This means that smaller transistors were more power efficient. In the end, both
    laws promised exponential performance per watt growth of transistors. It motivated
    investors to continuously research and develop ways to decrease the size of MOSFET^([19](ch01.html#idm45606843427616))
    transistors. We can also fit more of them on even smaller, more dense microchips,
    which reduced manufacturing costs. The industry continuously decreased the amount
    of space needed to fit the same amount of computing power, enhancing any chip,
    from CPU through RAM and flash memory, to GPS receivers and high-definition camera
    sensors.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔的观察对半导体行业产生了巨大影响。但如果不是因为罗伯特·H·丹纳德及其团队，减小晶体管尺寸可能不会那么有利。在1974年，他们的实验揭示，功耗与晶体管尺寸成正比（恒定功率密度）。^([18](ch01.html#idm45606843429376))这意味着更小的晶体管更加节能。最终，这两条法则都承诺了晶体管每瓦性能的指数增长。这激励投资者不断研究和开发减小金属氧化物半导体场效应晶体管的尺寸的方法。我们还可以在更小、更密集的微芯片上安装更多的晶体管，从而降低制造成本。该行业不断减少了安装相同计算能力所需的空间，改善了从CPU、RAM和闪存到GPS接收器和高清摄像头传感器的任何芯片的性能。
- en: In practice, Moore’s prediction lasted not 10 years as he thought, but nearly
    60 so far, and it still holds. We continue to invent tinier, microscopic transistors,
    currently oscillating around ~70 nm. Probably we can make them even smaller. Unfortunately,
    as we can see on [Figure 1-3](#img-hardware), we reached the physical limit of
    Dennard’s scaling around 2006.^([20](ch01.html#idm45606843423600))
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，摩尔的预测没有像他想的那样持续10年，而是接近60年，至今仍然有效。我们继续发明更小的微小晶体管，目前大约在约70纳米左右波动。可能我们可以使它们更小。不幸的是，正如我们可以从[图1-3](#img-hardware)看到的那样，我们在2006年左右达到了丹纳德的比例缩放的物理极限。^([20](ch01.html#idm45606843423600))
- en: '![efgo 0103](assets/efgo_0103.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0103](assets/efgo_0103.png)'
- en: 'Figure 1-3\. Image inspired by [“Performance Matters” by Emery Berger](https://oreil.ly/Tyfog):
    Moore’s Law versus Dennard’s Rule'
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. 受[“性能至上”（Emery Berger著）](https://oreil.ly/Tyfog)启发的图像：摩尔定律与丹纳德规则
- en: While technically, power usage of the higher density of tiny transistors remains
    constant, such dense chips heat up quickly. Beyond 3–4 GHz of clock speed, it
    takes significantly more power and other costs to cool the transistors to keep
    them running. As a result, unless you plan to run software on the bottom of the
    ocean,^([21](ch01.html#idm45606843420032)) you are not getting CPUs with faster
    instruction execution anytime soon. We only can have more cores.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管技术上，高密度小晶体管的功耗保持恒定，但这些密集的芯片很快就会发热。超过3-4 GHz的时钟速度后，为了保持其运行，冷却晶体管将需要显著更多的电力和其他成本。因此，除非你计划在海底底部运行软件^[21](ch01.html#idm45606843420032)，否则短期内不会有更快的指令执行CPU。我们只能拥有更多的核心。
- en: Faster execution is more energy efficient
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快的执行更节能。
- en: 'So, what we have learned so far? Hardware speed is getting capped, the software
    is getting bulkier, and we have to handle continuous growth in data and users.
    Unfortunately, that’s not the end. There is a vital resource we tend to forget
    about while developing the software: power. Every computation of our process takes
    electricity, which is heavily constrained on many platforms like mobile phones,
    smartwatches, IoT devices, or laptops. Nonintuitively there is a strong correlation
    between energy efficiency and software speed and efficiency. I love the Chandler
    Carruth presentation, which explained this surprising relation well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学到了什么？硬件速度受到限制，软件变得越来越臃肿，而我们必须处理数据和用户的持续增长。不幸的是，这还不是结束。在开发软件时，我们经常忽略的一个重要资源是电力。我们的每一个计算过程都需要电力，而在诸如手机、智能手表、物联网设备或笔记本电脑等平台上，电力资源是严重受限的。令人意外的是，能效与软件速度和效率之间存在着强烈的关联。我喜欢
    Chandler Carruth 的演讲，他很好地解释了这种令人惊讶的关系：
- en: 'If you ever read about “power-efficient instructions” or “optimizing for power
    usage,” you should become very suspicious. ... This is mostly total junk science.
    Here is the number one leading theory about how to save battery life: Finish running
    the program. Seriously, race to sleep. The faster your software runs, the less
    power it consumes. ... Every single general-usage microprocessor you can get today,
    the way it conserves power is by turning itself off. As rapidly and as frequently
    as possible.'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你读过“节能指令”或“优化电力使用”的内容，你应该变得非常怀疑……这基本上是一种完全没有科学根据的东西。关于如何节省电池寿命的头号理论是：尽快运行程序，然后进入休眠状态。你的软件运行得越快，消耗的电力就越少……今天的每一个通用微处理器，在节省电力方面的方式都是通过尽可能快速且频繁地关闭自己。
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Chandler Carruth, [“Efficiency with Algorithms, Performance with Data Structures”](https://oreil.ly/9OftP),
    CppCon 2014
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Chandler Carruth，[《算法效率，数据结构性能》](https://oreil.ly/9OftP)，CppCon 2014
- en: To sum up, avoid the common trap of thinking about hardware as a continuously
    faster and cheaper resource that will save us from optimizing our code. It’s a
    trap. Such a broken loop makes engineers gradually lower their coding standards
    in performance, and demand more and faster hardware. Cheaper and more accessible
    hardware then creates even more mental room to skip efficiency and so on. There
    are amazing innovations like Apple’s M1 silicons,^([22](ch01.html#idm45606843409552))
    RISC-V standard,^([23](ch01.html#idm45606843408144)) and more practical Quantum
    computing appliances, which promise a lot. Unfortunately, as of 2022, hardware
    is growing slower than software efficiency needs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，要避免常见的陷阱，即把硬件想象成一个持续变快和变便宜的资源，这样就能避免优化我们的代码。这是一个陷阱。这种破碎的循环使工程师逐渐降低了他们的性能编码标准，并且要求更多、更快的硬件。更便宜、更易得的硬件又会创造出更多的心理空间来跳过效率等等。有像苹果的
    M1 硅片^[22](ch01.html#idm45606843409552)，RISC-V 标准^[23](ch01.html#idm45606843408144)等令人惊叹的创新，还有更实际的量子计算设备，它们承诺了很多。不幸的是，截至2022年，硬件的增长速度远远落后于软件效率的需求。
- en: Efficiency Improves Accessibility and Inclusiveness
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率提高了可访问性和包容性。
- en: Software developers are often “spoiled” and detached from typical human reality
    in terms of the machines we use. It’s often the case that engineers create and
    test software on premium, high-end laptop or mobile devices. We need to realize
    that many people and organizations are utilizing older hardware or worse internet
    connections.^([24](ch01.html#idm45606843404912)) People might have to run your
    applications on slower computers. It might be worth considering efficiency in
    our development process to improve overall software accessibility and inclusiveness.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员通常对我们使用的高端笔记本电脑或移动设备的机器性能“宠坏”并与典型人类现实脱节。工程师们通常在高级、高端的笔记本电脑或移动设备上创建和测试软件。我们需要意识到，许多人和组织正在使用较老的硬件或更差的互联网连接。^([24](ch01.html#idm45606843404912))
    人们可能不得不在较慢的计算机上运行您的应用程序。考虑到我们的开发过程中的效率，以改善软件的总体可访问性和包容性可能是值得的。
- en: We Can Scale Horizontally Instead
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以选择水平扩展
- en: As we learned in the previous sections, we expect our software to handle more
    data sooner or later. But it’s unlikely your project will have billions of users
    from day one. We can avoid enormous software complexity and development cost by
    pragmatically choosing a much lower target number of users, operations, or data
    sizes to aim for at the beginning of our development cycle. For example, we usually
    simplify the initial programming cycle by assuming a low number of notes in the
    mobile note-taking app, fewer requests per second in the proxy being built, or
    smaller files in the data converter tool the team is working on. It’s OK to simplify
    things. It’s also important to roughly predict performance requirements in the
    early design phase.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中学到的，我们预计我们的软件迟早会处理更多的数据。但是你的项目从一开始就不太可能有数十亿的用户。我们可以通过在开发周期初期选择更低的目标用户数、操作数或数据大小来避免巨大的软件复杂性和开发成本。例如，在移动笔记应用程序中，我们通常简化初始编程周期，假设笔记数目较少，正在构建的代理每秒请求较少，或者团队正在处理的数据转换工具中的文件较小。简化事情是可以的。在早期设计阶段大致预测性能要求也很重要。
- en: Similarly, finding the expected load and usage in the mid to long term of software
    deployment is essential. The software design that guarantees similar performance
    levels, even with increased traffic, is *scalable*. Generally, scalability is
    very difficult and expensive to achieve in practice.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，找到软件部署中中长期预期负载和使用情况至关重要。即使在交通量增加的情况下，也要确保软件设计可以保证相似的性能水平是*可伸缩的*。一般来说，可伸缩性在实践中非常难以实现且昂贵。
- en: 'Even if a system is working reliably today, that doesn’t mean it will necessarily
    work reliably in the future. One common reason for degradation is increased load:
    perhaps the system has grown from 10,000 concurrent users to 100,000 concurrent
    users, or from 1 million to 10 million. Perhaps it is processing much larger volumes
    of data than it did before. Scalability is the term we use to describe a system’s
    ability to cope with increased load.'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使系统今天能够可靠地工作，这并不意味着它将来一定会可靠地工作。系统性能下降的一个常见原因是负载增加：也许系统从一开始的1万并发用户增长到10万并发用户，或者从100万增长到1000万。也许它正在处理比以前更大量的数据。可伸缩性是我们用来描述系统处理增加负载能力的术语。
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Martin Kleppmann, *Designing Data-Intensive Applications* (O’Reilly, 2017)
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Martin Kleppmann，《设计数据密集型应用》（O'Reilly，2017）
- en: Inevitably, while talking about efficiency, we might touch on some scalability
    topics in this book. However, for this chapter’s purpose, we can distinguish the
    scalability of our software into two types, presented in [Figure 1-4](#img-scalability).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论效率的同时，我们可能会在本书中涉及一些可伸缩性的话题。然而，对于本章的目的，我们可以将软件的可伸缩性区分为两种类型，如[图1-4](#img-scalability)所示。
- en: '![efgo 0104](assets/efgo_0104.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0104](assets/efgo_0104.png)'
- en: Figure 1-4\. Vertical versus horizontal scalability
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-4\. 垂直与水平可伸缩性比较
- en: Vertical scalability
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直可伸缩性
- en: The first and sometimes simplest way of scaling our application is by running
    the software on hardware with more resources—“vertical” scalability. For example,
    we could introduce parallelism for software to use not one but three CPU cores.
    If the load increases, we provide more CPU cores. Similarly, if our process is
    memory intensive, we might bump up running requirements and ask for bigger RAM
    space. The same with any other resource, like disk, network, or power. Obviously,
    that does not come without consequences. In the best case, you have that room
    in the target machine. Potentially, you can make that room by rescheduling other
    processes to different machines (e.g., when running in the cloud) or closing them
    temporarily (useful when running on a laptop or smartphone). Worst case, you may
    need to buy a bigger computer, or a more capable smartphone or laptop. The latter
    option is usually very limited, especially if you provide software for customers
    to run on their noncloud premises. In the end, the usability of resource-hungry
    applications or websites that scale only vertically is much lower.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们应用程序的第一种，有时最简单的方法是在具有更多资源的硬件上运行软件——“垂直”扩展。例如，我们可以为软件引入并行性，不是使用一个而是三个CPU核心。如果负载增加，我们提供更多的CPU核心。同样，如果我们的过程需要大量内存，我们可能需要增加运行要求，并请求更大的RAM空间。像磁盘、网络或电源这样的其他资源也是如此。显然，这并不是没有后果的。在最好的情况下，您在目标机器上有这个空间。潜在地，您可以通过将其他进程重新调度到不同的机器（例如，在云中运行时）或暂时关闭它们（在笔记本电脑或智能手机上运行时有用）。最坏的情况是，您可能需要购买更大的计算机，或者更有能力的智能手机或笔记本电脑。后一种选择通常非常有限，特别是如果您提供软件供客户在他们的非云场地上运行。最终，只能垂直扩展的资源消耗型应用程序或网站的可用性要低得多。
- en: The situation is slightly better if you or your customers run your software
    in the cloud. You can “just” buy a bigger server. As of 2022, you can scale up
    your software on the AWS platform to 128 CPU cores, almost 4 TB of RAM, and 14
    GBps of bandwidth.^([25](ch01.html#idm45606843384320)) In extreme cases, you can
    also buy an [IBM mainframe with 190 cores and 40 TB of memory](https://oreil.ly/P0auH),
    which requires different programming paradigms.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您或您的客户在云中运行您的软件，则情况略有改善。您可以“只需”购买一个更大的服务器。截至2022年，在AWS平台上，您可以将您的软件扩展到128个CPU核心，几乎4
    TB的RAM和14 GBps的带宽。^([25](ch01.html#idm45606843384320)) 在极端情况下，您还可以购买一台[IBM主机，具有190个核心和40
    TB的内存](https://oreil.ly/P0auH)，需要不同的编程范例。
- en: Unfortunately, vertical scalability has its limits on many fronts. Even in the
    cloud or datacenters, we simply cannot infinitely scale up the hardware. First
    of all, giant machines are rare and expensive. Secondly, as we will learn in [Chapter 4](ch04.html#ch-hardware),
    bigger machines run into complex issues caused by many hidden single points of
    failures. Pieces like memory bus, network interfaces, NUMA nodes, and the operating
    system itself can be overloaded and too slow.^([26](ch01.html#idm45606843380848))
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，垂直扩展在许多方面都有其局限性。即使在云端或数据中心，我们也不能无限地扩展硬件。首先，大型机器是稀缺且昂贵的。其次，正如我们将在[第四章](ch04.html#ch-hardware)中学到的，更大的机器会遇到由许多隐藏的单点故障引起的复杂问题。例如内存总线、网络接口、NUMA节点和操作系统本身可能会过载和过慢。^([26](ch01.html#idm45606843380848))
- en: Horizontal scalability
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 横向扩展
- en: 'Instead of a bigger machine, we might try to offload and share the computation
    across multiple remote, smaller, less complex, and much cheaper devices. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一个更大的机器，我们可以尝试在多个远程、更小、更简单和更便宜的设备之间进行计算卸载和共享。例如：
- en: To search for messages with the word “home” in a mobile messaging app, we could
    fetch millions of past messages (or store them locally in the first place) and
    run regex matching on each. Instead, we can design an API and remotely call a
    backend system that splits the search into 100 jobs matching 1/100 of the dataset.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动消息应用程序中搜索包含“home”一词的消息，我们可以获取数百万条过去的消息（或者在第一时间将它们存储在本地），并对每条运行正则表达式匹配。相反，我们可以设计一个API，并远程调用一个后端系统，将搜索分成100个匹配数据集的1/100的作业。
- en: Instead of building “monolith” software, we could distribute different functionalities
    to separate components and move to a “microservice” design.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是构建“单块”软件，我们可以将不同功能分布到单独的组件中，并转向“微服务”设计。
- en: Instead of running a game that requires expensive CPUs and GPUs on a personal
    computer or gaming console, we could run it in a cloud and [stream the input and
    output in high resolution](https://oreil.ly/FKmTE).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是在个人电脑或游戏主机上运行需要昂贵CPU和GPU的游戏，我们可以在云中运行，并且以高分辨率[流式传输输入和输出](https://oreil.ly/FKmTE)。
- en: Horizontal scalability is easier to use as it has fewer limitations, and usually
    allows great dynamics. For instance, if the software is used only in a certain
    company, you might have almost no users at night, and large traffic during the
    day. With horizontal scalability it’s easy to implement autoscaling that scales
    out and back in seconds based on demand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展更容易使用，因为它有较少的限制，并且通常允许更大的动态性。例如，如果软件仅在某个公司使用，夜间可能几乎没有用户，而白天流量很大。通过水平扩展，可以轻松实现根据需求进行自动扩展和缩减的自动化功能，响应速度快。
- en: On the other hand, horizontal scalability is much harder to implement on the
    software side. Distributed systems, network impacts, and hard problems that cannot
    be sharded are some of the many complications in the development of such systems.
    That’s why it’s often better to stick to vertical scalability in some cases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，软件方面的水平扩展要困难得多。分布式系统、网络影响以及无法分片的困难问题是开发此类系统时的许多复杂性之一。因此，在某些情况下，通常更好地坚持垂直扩展。
- en: 'With horizontal and vertical scalability in mind, let’s look at a specific
    scenario from the past. Many modern databases rely on compaction to efficiently
    store and look up data. We can reuse many indices during this process, deduplicate
    the same data, and gather fragmented pieces into the sequential data stream for
    faster reads. At the beginning of the Thanos project, we decided to reuse a very
    naive compaction algorithm for simplicity. We calculated that, in theory, we don’t
    need to make the compaction process parallel within a single block of data. Given
    a steady stream of 100 GB (or more) of eventually compacted data from a single
    source, we could rely on a single CPU, a minimal amount of memory, and some disk
    space. The implementation was initially very naive and unoptimized, following
    the YAGNI rule and avoiding premature optimization patterns. We wanted to avoid
    the complexity and effort of optimizing the project’s reliability and functionality
    features. As a result, users who deployed our project quickly hit compaction problems:
    too slow to cope with incoming data or to consume hundreds of GB of memory per
    operation. The cost was the first problem, but not the most urgent. The bigger
    issue was that many Thanos users did not have bigger machines in their datacenters
    to scale the memory vertically.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到水平和垂直扩展，让我们看看过去的一个具体场景。许多现代数据库依赖于压缩来高效存储和查找数据。在此过程中，我们可以重复使用许多索引，去重相同数据，并将碎片化的数据片段聚集到顺序数据流中，以加快读取速度。在Thanos项目初期，我们决定为简单起见重用一个非常朴素的压缩算法。理论上，我们计算出在一个数据块内不需要并行进行压缩过程。给定来自单一源的稳定的、最终压缩后的100
    GB（或更多）数据流，我们可以依赖于单个CPU、少量内存和一些磁盘空间。最初的实现非常朴素且未经优化，遵循了YAGNI原则，避免了过早优化的模式。我们希望避免优化项目的可靠性和功能特性的复杂性和努力。结果，部署我们项目的用户很快遇到了压缩问题：处理传入数据过慢或每次操作消耗数百GB内存。成本是第一个问题，但不是最紧迫的问题。更大的问题是，许多Thanos用户在其数据中心没有更大的机器来垂直扩展内存。
- en: At first glance, the compaction problem looked like a scalability problem. The
    compaction process depended on resources that we could not just add up infinitely.
    As users wanted a solution fast, together with the community, we started brainstorming
    potential horizontal scalability techniques. We talked about introducing a compactor
    scheduler service that would assign compaction jobs to different machines, or
    intelligent peer networks using a gossip protocol. Without going into details,
    both solutions would add enormous complexity, probably doubling or tripling the
    complication of developing and running the whole system. Luckily, it took a few
    days of brave and experienced developer time to redesign the code for efficiency
    and performance. It allowed the newer version of Thanos to make compactions twice
    as fast, and stream data directly from the disk, allowing minimal peak memory
    consumption. A few years later, the Thanos project still doesn’t have any complex
    horizontal scalability for compaction, besides simple sharding, even with thousands
    of successful users running it with billions of metrics.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，压缩问题看起来像是一个可扩展性问题。压缩过程依赖于我们无法无限添加的资源。由于用户想要快速解决方案，我们与社区一起开始集思广益，探讨潜在的水平扩展技术。我们讨论了引入一个压缩调度服务，该服务将把压缩作业分配给不同的机器，或者使用一种八卦协议的智能对等网络。不详细讨论，这两种解决方案都会增加巨大的复杂性，可能会使整个系统的开发和运行的复杂性翻倍或翻三倍。幸运的是，经过几天勇敢和经验丰富的开发人员的时间重新设计代码以提高效率和性能。这使得新版本的灭霸能够将压缩速度提高一倍，并直接从磁盘流式传输数据，从而使内存消耗达到最低。几年后，灭霸项目仍然没有任何复杂的水平扩展用于压缩，除了简单的分片，即使有成千上万的成功用户在其中运行数十亿的指标。
- en: It might feel funny now, but in some ways, this story is quite scary. We were
    so close to bringing enormous, distributed system-level complexity, based on social
    and customer pressure. It would be fun to develop, but it could also risk collapsing
    the project’s adoption. We might add it someday, but first we will make sure there
    is no other efficiency optimization to compaction. A similar situation has been
    repeated in my career in both open and closed sources for smaller and bigger projects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能感觉有趣，但在某种程度上，这个故事相当可怕。我们几乎要引入基于社会和客户压力的巨大分布式系统级复杂性。这可能很有趣，但也可能会冒着项目被抛弃的风险。也许我们以后会添加，但首先我们会确保没有其他效率优化可以压缩。在我的职业生涯中，无论是在开源还是闭源的小型和大型项目中，类似的情况都反复出现。
- en: Premature Scalability Is Worse than Premature Efficiency Optimizations!
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过早的可扩展性比过早的效率优化更糟糕！
- en: Make sure you consider improving the efficiency on the algorithm and code level
    before introducing complex scalable patterns.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入复杂的可扩展模式之前，请确保考虑在算法和代码层面提高效率。
- en: As presented by the “lucky” Thanos compaction situation, if we don’t focus on
    the efficiency of our software, we can quickly be forced to introduce premature
    horizontal scalability. It is a massive trap because, with some optimization effort,
    we might completely avoid jumping into scalability method complications. In other
    words, avoiding complexity can bring even bigger complexity. This appears to me
    as an unnoticed but critical problem in the industry. It is also one of the main
    reasons why I wrote this book.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“幸运”的灭霸压缩情况所展示的那样，如果我们不专注于软件的效率，我们很快就会被迫引入过早的水平扩展。这是一个巨大的陷阱，因为通过一些优化工作，我们可能完全可以避免陷入扩展方法的复杂性。换句话说，避免复杂性可能会带来更大的复杂性。这对我来说是一个未被注意但却是行业中的一个关键问题。这也是我写这本书的主要原因之一。
- en: The complications come from the fact that [complexity has to live somewhere](https://oreil.ly/0PcmN).
    We don’t want to complicate code, so we have to complicate the system, which,
    if built from inefficient components, wastes resources and an enormous amount
    of developer or operator time. Horizontal scalability is especially complex. By
    design, it involves network operations. As we might know from the CAP Theorem,^([27](ch01.html#idm45606843362992))
    we inevitably hit either availability or consistency issues as soon as we start
    distributing our process. Trust me, mitigating these elemental constraints, dealing
    with race conditions, and understanding the world of network latencies and unpredictability
    is a hundred times more difficult than adding small efficiency optimization, e.g.,
    hidden behind the `io.Reader` interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性源于“复杂性必须存在”的事实。我们不想使代码复杂化，因此我们必须使系统复杂化，如果从低效组件构建，会浪费资源和大量开发者或运维人员的时间。横向扩展尤其复杂。从设计上来说，它涉及网络操作。正如我们可能从CAP定理中了解的那样，^([27](ch01.html#idm45606843362992))
    一旦我们开始分布我们的流程，我们不可避免地遇到可用性或一致性问题。相信我，缓解这些基本约束，处理竞争条件，并理解网络延迟和不可预测性的世界比添加小的效率优化要困难一百倍，比如隐藏在`io.Reader`接口后面。
- en: It might seem to you that this section touches only on infrastructure systems.
    That’s not true. It applies to all software. For example, if you write a frontend
    software or dynamic website, you might be tempted to move small client computations
    to the backend. We should probably only do that if the computation depends on
    the load and grows out of user space hardware capabilities. Moving it to the server
    prematurely might cost you the complexity caused by extra network calls, more
    error cases to handle, and server saturations causing Denial of Service (DoS).^([28](ch01.html#idm45606843360512))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分可能让你觉得只涉及基础设施系统。这是不正确的。它适用于所有软件。例如，如果你编写前端软件或动态网站，你可能会被诱惑将小客户端计算移到后端。我们可能只有在计算依赖负载并且超出用户空间硬件能力时才应该这样做。过早地将其移到服务器上可能会增加复杂性，因为需要额外的网络调用，更多的错误处理情况以及导致服务器饱和的拒绝服务（DoS）问题。^([28](ch01.html#idm45606843360512))
- en: Another example comes from my experience. My master’s thesis was about a “Particle
    Engine Using Computing Cluster.” In principle, the goal was to add a particle
    engine to a 3D game in a [Unity engine](https://unity.com). The trick was that
    the particle engine was not supposed to operate on client machines, instead offloading
    “expensive” computation to a nearby supercomputer in my university called “Tryton.”^([29](ch01.html#idm45606843358880))
    Guess what? Despite the ultrafast InfiniBand network,^([30](ch01.html#idm45606843358192))
    all particles I tried to simulate (realistic rain and crowd) were much slower
    and less reliable when offloaded to our supercomputer. It was not only less complex
    but also much faster to compute all on client machines.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子来自我的经验。我的硕士论文是关于“使用计算集群的粒子引擎”。原则上，目标是在[Unity引擎](https://unity.com)中添加一个粒子引擎到3D游戏中。诀窍在于，粒子引擎不应在客户端机器上运行，而是将“昂贵”的计算卸载到我大学附近的超级计算机“Tryton”上。^([29](ch01.html#idm45606843358880))
    你猜怎么着？尽管使用了超快的InfiniBand网络，^([30](ch01.html#idm45606843358192)) 我尝试模拟的所有粒子（比如真实的雨和人群）在转移到我们的超级计算机后速度更慢，可靠性更低。不仅更简单，而且在客户端机器上计算所有内容速度也更快。
- en: Summing up, when someone says, “Don’t optimize, we can just scale horizontally,”
    be very suspicious. Generally, it is simpler and cheaper to start from efficiency
    improvements before we escalate to a scalability level. On the other hand, a judgment
    should tell you when optimizations are becoming too complex and scalability might
    be a better option. You will learn more about that in [Chapter 3](ch03.html#ch-efficiency).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当有人说，“不要优化，我们可以横向扩展”，应该非常怀疑。通常，从效率改进开始比从扩展性水平上升更简单更便宜。另一方面，判断应该告诉你，当优化变得过于复杂时，扩展性可能是一个更好的选择。关于这一点，你会在[第3章](ch03.html#ch-efficiency)中了解更多。
- en: Time to Market Is More Important
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 市场时间更为重要
- en: Time is expensive. One aspect of this is that software developer time and expertise
    cost a lot. The more features you want your application or system to have, the
    more time is needed to design, implement, test, secure, and optimize the solution’s
    performance. The second aspect is that the more time a company or individual spends
    to deliver the product or service, the longer their “time to market” is, which
    can hurt the financial results.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是昂贵的。其中一个方面是软件开发人员的时间和专业知识成本高昂。你希望应用程序或系统拥有的功能越多，设计、实施、测试、保障和优化解决方案所需的时间就越多。第二个方面是，公司或个人花费的时间越长，产品或服务的“上市时间”就越长，这可能会影响财务结果。
- en: Once time was money. Now it is more valuable than money. A McKinsey study reports
    that, on average, companies lose 33% of after-tax profit when they ship products
    six months late, as compared with losses of 3.5% when they overspend 50% on product
    development.
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 曾经时间就是金钱。现在它比金钱更有价值。麦肯锡的一项研究报告称，平均而言，公司如果将产品延迟六个月交付，税后利润将损失33%，相比之下，如果产品开发超支50%，损失只有3.5%。
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Charles H. House and Raymond L. Price, [“The Return Map: Tracking Product Teams”](https://oreil.ly/SmLFQ)'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查尔斯·H·豪斯和雷蒙德·L·普赖斯，《[产品团队追踪回报图](https://oreil.ly/SmLFQ)》
- en: It’s hard to measure such impact, but your product might no longer be pioneering
    when you are “late” to market. You might miss valuable opportunities or respond
    too late to a competitor’s new product. That’s why companies mitigate this risk
    by adopting Agile methodologies or proof of concept (POC) and minimal viable product
    (MVP) patterns.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 很难衡量这种影响，但当你“迟到”市场时，你的产品可能不再是领先的。你可能会错过宝贵的机会，或者对竞争对手的新产品反应过晚。因此，公司通过采用敏捷方法论或概念验证（POC）和最小可行产品（MVP）模式来减少这种风险。
- en: 'Agile and smaller iterations help, but in the end, to achieve faster development
    cycles, companies try other things too: scale their teams (hire more people, redesign
    teams), simplify the product, do more automation, or do partnerships. Sometimes
    they try to reduce the product quality. As Facebook’s proud initial motto was
    “Move fast and break things,”^([31](ch01.html#idm45606843327472)) it’s very common
    for companies to descope software quality in areas like code maintainability,
    reliability, and efficiency to “beat” the market.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷和较小的迭代有所帮助，但最终，为了实现更快的开发周期，公司也会尝试其他方法：扩展他们的团队（招聘更多人，重新设计团队）、简化产品、增加自动化，或者进行合作伙伴关系。有时他们试图降低产品质量。正如Facebook的自豪初衷是“快速行动，打破常规”，公司常常在诸如代码可维护性、可靠性和效率等方面减少软件质量，以“击败”市场。
- en: This is what our last misconception is all about. Descoping your software’s
    efficiency to get to the market faster is not always the best idea. It’s good
    to know the consequences of such a decision. Know the risk first.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们最后一个误解所涉及的内容。为了更快地进入市场，减少软件的效率并不总是最佳选择。了解这种决定的后果是很好的。首先要了解风险。
- en: Optimization is a difficult and expensive process. Many engineers argue that
    this process delays entry into the marketplace and reduces profit. This may be
    true, but it ignores the cost associated with poor-performing products (particularly
    when there is competition in the marketplace).
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优化是一个困难且昂贵的过程。许多工程师认为这个过程会延迟进入市场并降低利润。这可能是真的，但它忽略了与产品性能不佳相关的成本（尤其是在市场竞争激烈时）。
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Randall Hyde, [“The Fallacy of Premature Optimization”](https://oreil.ly/mMjHb)
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 兰德尔·海德，《[过早优化的谬误](https://oreil.ly/mMjHb)》
- en: Bugs, security issues, and poor performance happen, but they might damage the
    company. Without looking too far, let’s look at a game released in late 2020 by
    the biggest Polish game publisher, CD Projekt. [*Cyberpunk 2077*](https://oreil.ly/ohJft)
    was known to be a very ambitious, open world, massive, and high-quality production.
    Well marketed, from a publisher with a good reputation, despite the delays, excited
    players around the world bought eight million preorders. Unfortunately, when released
    in December 2020, the otherwise excellent game had massive performance issues.
    It had bugs, crashes, and a low frame rate on all consoles and most PC setups.
    On some older consoles like PS4 or Xbox One, the game was claimed to be unplayable.
    There were, of course, updates with plenty of fixes and drastic improvements over
    the following months and years.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Bugs、安全问题和性能不佳时有发生，但它们可能会损害公司。毋庸置疑，我们可以看看波兰最大的游戏发行商CD Projekt在2020年底发布的一款游戏。[*赛博朋克2077*](https://oreil.ly/ohJft)被认为是一款非常雄心勃勃、开放世界、庞大且高质量的作品。尽管市场营销做得很好，来自声誉良好的发行商，尽管推迟了，全球的玩家们还是购买了800万份预购。不幸的是，2020年12月发布时，本来是优秀游戏却存在严重的性能问题。在所有游戏主机和大多数PC配置上都有bug、崩溃和低帧率。在像PS4或Xbox
    One这样的老旧游戏主机上，据说这款游戏几乎无法游玩。当然，在接下来的几个月和几年里，有许多更新，大量的修复和显著的改进。
- en: Unfortunately, it was too late. The damage was done. The issues, which for me
    felt somewhat minor, were enough to shake CD Projekt’s financial perspectives.
    Five days after launch, the company lost one-third of its stock value, [costing
    the founders more than $1 billion](https://oreil.ly/x5Qd8). Millions of players
    asked for game refunds. [Investors sued](https://oreil.ly/CRKg4) CD Projekt over
    game issues, and famous [lead developers left the company](https://oreil.ly/XwcX9).
    Perhaps the publisher will survive and recover. Still, one can only imagine the
    implications of a broken reputation impacting future productions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一切都为时已晚。损害已经造成。对我来说，这些问题似乎有些小，但已足以动摇CD Projekt的财务前景。在发布后五天，公司股价损失了三分之一，[造成创始人损失超过10亿美元](https://oreil.ly/x5Qd8)。数百万玩家要求退款。[投资者因游戏问题起诉](https://oreil.ly/CRKg4)CD
    Projekt，著名的[主导开发者离开了公司](https://oreil.ly/XwcX9)。也许这家发行商会幸存并恢复。但我们只能想象一个破损声誉对未来制作的影响。
- en: More experienced and mature organizations know well the critical value of software
    performance, especially the client-facing ones. Amazon found that if its website
    loaded one second slower, [it would lose $1.6 billion annually](https://oreil.ly/cHT2j).
    Amazon also reported that [100 ms of latency costs 1% of profit](https://oreil.ly/Bod7k).
    Google realized that slowing down their web search from [400 ms to 900 ms caused
    a 20% drop in traffic](https://oreil.ly/hHmYJ). For some businesses, it’s even
    worse. It was estimated that if a broker’s electronic trading platform is 5 milliseconds
    slower than the competition, it could lose 1% of its cash flow, if not more. If
    10 milliseconds slower, [this number grows to a 10% drop in revenue](https://oreil.ly/fK7mE).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 更有经验和成熟的组织深知软件性能的关键价值，特别是那些面向客户的组织。亚马逊发现，如果其网站加载慢了一秒钟，[将会导致每年损失16亿美元](https://oreil.ly/cHT2j)。亚马逊还报告称，[每增加100毫秒的延迟就会损失1%的利润](https://oreil.ly/Bod7k)。谷歌意识到，将其网页搜索速度从[400毫秒降低到900毫秒会导致流量下降20%](https://oreil.ly/hHmYJ)。对一些企业来说，情况甚至更糟。据估计，如果经纪人的电子交易平台比竞争对手慢5毫秒，可能会损失1%甚至更多的现金流。如果慢10毫秒，[这个数字将增长到收入减少10%](https://oreil.ly/fK7mE)。
- en: Realistically speaking, it’s true that millisecond-level slowness might not
    matter in most software cases. For example, let’s say we want to implement a file
    converter from PDF to DOCX. Does it matter if the whole experience lasts 4 seconds
    or 100 milliseconds? In many cases, it does not. However, when someone puts that
    as a market value and a competitor’s product has a latency of 200 milliseconds,
    code efficiency and speed suddenly become a matter of winning or losing customers.
    And if it’s physically possible to have such fast file conversion, competitors
    will try to achieve it sooner or later. This is also why so many projects, even
    open source, are very loud about their performance results. While sometimes it
    feels like a cheap marketing trick, this works because if you have two similar
    solutions with similar feature sets and other characteristics, you will pick the
    fastest one. It’s not all about the speed, though—resource consumption matters
    as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从现实角度来看，毫秒级的慢速在大多数软件情况下可能并不重要。例如，假设我们想要实现从PDF到DOCX的文件转换器。整个体验是否持续4秒或100毫秒是否重要？在许多情况下，并不重要。然而，当有人把这个作为市场价值，并且竞争对手的产品延迟为200毫秒时，代码的效率和速度突然成为赢得或失去客户的问题。如果在物理上可能实现如此快的文件转换，竞争对手迟早会试图实现它。这也是为什么许多项目，甚至是开源项目，非常强调它们的性能结果的原因。虽然有时感觉像是廉价的营销手段，但这确实有效，因为如果你有两个功能集和其他特征相似的解决方案，你会选择速度最快的那个。不过，不仅仅是速度，资源消耗也很重要。
- en: Efficiency Is Often More Important in Market than Features!
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在市场上，效率通常比功能更重要！
- en: During my experience as a consultant for infrastructure systems, I saw many
    cases where customers migrated away from solutions requiring a larger amount of
    RAM or disk storage, even if that meant some loss in functionalities.^([32](ch01.html#idm45606843308816))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为基础设施系统顾问的经验中，我见过很多情况，客户选择远离需要更多RAM或磁盘存储的解决方案，即使这意味着在功能上有所损失。^([32](ch01.html#idm45606843308816))
- en: To me, the verdict is simple. If you want to win the market, skipping efficiency
    in your software might not be the best idea. Don’t wait with optimization until
    the last moment. On the other hand, time to market is critical, so balancing a
    good enough amount of efficiency work into your software development process is
    crucial. One way of doing this is to set the nonfunctional goals early (discussed
    in [“Resource-Aware Efficiency Requirements”](ch03.html#ch-conq-req)). In this
    book, we will focus a lot on finding that healthy balance and reducing the effort
    (thus the time) required to improve the efficiency of your software. Let’s now
    look at what is the pragmatic way to think about the performance of our software.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，结论很简单。如果你想在市场上获胜，忽视软件中的效率可能不是最好的选择。不要等到最后一刻再进行优化。另一方面，市场时间至关重要，因此在软件开发过程中平衡足够的效率工作至关重要。其中一种方法是早期设定非功能性目标（在[“资源感知效率需求”](ch03.html#ch-conq-req)中讨论）。在本书中，我们将重点放在找到健康平衡，并减少改进软件效率所需的工作量（因此时间）上。现在让我们看看如何实用地思考软件性能。
- en: The Key to Pragmatic Code Performance
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用代码性能的关键
- en: In [“Behind Performance”](#ch-eff-s-performance), we learned that performance
    splits into accuracy, speed, and efficiency. I mentioned that in this book when
    I use the word *efficiency*, it naturally means efficient resource consumption,
    but also our code’s speed (latency). A practical suggestion is hidden in that
    decision regarding how we should think about our code performing in production.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“性能背后”](#ch-eff-s-performance)，我们了解到性能可以分为准确性、速度和效率。我提到在本书中，当我使用“*效率*”这个词时，它自然指的是资源的高效利用，但也包括我们代码的速度（延迟）。一个实用的建议隐藏在我们如何思考代码在生产中表现的决策中。
- en: The secret here is to stop focusing strictly on the speed and latency of our
    code. Generally, for nonspecialized software, speed matters only marginally; the
    waste and unnecessary consumption of resources are what introduce slowdowns. And
    achieving high speed with bad efficiency will always introduce more problems than
    benefits. As a result, we should generally focus on efficiency. Sadly, it is often
    overlooked.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的秘密在于不要严格关注我们代码的速度和延迟。一般来说，对于非专用软件，速度仅在边缘地方有所影响；浪费和不必要的资源消耗才会导致减慢。而且，用低效率达到高速度总会带来更多问题而不是好处。因此，我们通常应该关注效率。可悲的是，这通常被忽视。
- en: Let’s say you want to travel from city A to city B across the river. You can
    grab a fast car and drive over a nearby bridge to get to city B quickly. But if
    you jump into the water and slowly swim across the river, you will get to city
    B much faster. Slower actions can still be faster when done efficiently, for example,
    by picking a shorter route. One could say that to improve travel performance and
    beat the swimmer, we could get a faster car, improve the road surface to reduce
    drag, or even add a rocket engine. We could potentially beat the swimmer, yes,
    but those drastic changes might be more expensive than simply doing less work
    and renting a boat instead.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想从城市A快速到达城市B，穿过河流。你可以选择一辆快车，驶过附近的桥梁，快速到达城市B。但是，如果你跳入水中慢慢游过河流，你也能更快到达城市B。当有效率地完成时，较慢的行动仍然可以更快。例如，选择一条更短的路径。可以说，为了提高旅行效率并超过游泳者，我们可以选择更快的汽车，改善道路表面以减少阻力，甚至加装火箭引擎。我们可能会打败游泳者，但是这些剧变可能比简化工作并租用一艘小船更昂贵。
- en: Similar patterns exist in software. Let’s say our algorithm does search functionality
    on certain words stored on disk and performs slowly. Given that we operate on
    persistent data, the slowest operation is usually the data access, especially
    if our algorithm does this extensively. It’s very tempting to not think about
    efficiency and instead find a way to convince users to use SSD instead of HDD
    storage. This way, we could potentially reduce latency up to 10 times. That would
    improve performance by increasing the speed element of the equation. On the contrary,
    if we could find a way to enhance the current algorithm to read data only a few
    times instead of a million, we could achieve even lower latencies. That would
    mean we can have the same or even better effect by keeping the cost low.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中也存在类似的模式。假设我们的算法在磁盘上进行某些单词的搜索功能并且执行缓慢。鉴于我们操作持久数据，通常最慢的操作通常是数据访问，特别是如果我们的算法广泛执行此操作。非常诱人的做法是不去考虑效率，而是找到一种方法说服用户使用SSD而不是HDD存储。这样，我们可以将延迟降低到最多10倍。这将通过增加等式中的速度元素来提高性能。相反，如果我们能找到一种方法来改进当前算法，只需少数几次读取数据而不是百万次，我们可以实现更低的延迟。这意味着我们可以通过保持成本低来达到相同甚至更好的效果。
- en: I want to propose focusing our efforts on efficiency instead of mere execution
    speed. That is also why this book’s title is *Efficient Go*, not something more
    general and catchy^([33](ch01.html#idm45606843292640)) like *Ultra Performance
    Go* or *Fastest Go Implementations*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议将我们的努力集中在效率而不是纯粹的执行速度上。这也是为什么本书的标题是*Efficient Go*，而不是像*Ultra Performance
    Go*或*Fastest Go Implementations*这样更一般和引人注目的标题^([33](ch01.html#idm45606843292640))。
- en: 'It’s not that speed is less relevant. It is important, and as you will learn
    in [Chapter 3](ch03.html#ch-efficiency), you can have more efficient code that
    is much slower and vice versa. Sometimes it’s a trade-off you will need to make.
    Both speed and efficiency are essential. Both can impact each other. In practice,
    when the program is doing less work on the critical path, it will most likely
    have lower latency. In the HDD versus SDD example, changing to a faster disk might
    allow you to remove some caching logic, which results in better efficiency: less
    memory and CPU time used. The other way around works sometimes too—as we learned
    in [“Hardware Is Getting Faster and Cheaper”](#ch-eff-s-hardware), the faster
    your process is, the less energy it consumes, improving battery efficiency.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 速度并非毫不重要。它很重要，正如你将在[第三章](ch03.html#ch-efficiency)中学到的那样，你可以编写更高效但更慢的代码，反之亦然。有时这是你需要做出的权衡。速度和效率都是至关重要的。它们彼此之间会相互影响。在实践中，当程序在关键路径上执行的工作较少时，通常会具有较低的延迟。在HDD与SSD的例子中，更换更快的硬盘可能允许您删除一些缓存逻辑，从而提高效率：减少内存和CPU时间的使用。有时候反过来也可以——正如我们在[“硬件变得更快更便宜”](#ch-eff-s-hardware)中所学到的，进程越快，消耗的能量就越少，提高了电池的效率。
- en: 'I would argue that we generally should focus on improving efficiency before
    speed as the first step when improving performance. As you will see in [“Optimizing
    Latency”](ch10.html#ch-opt-latency-example), only by changing efficiency was I
    able to reduce latency seven times, with just one CPU core. You might be surprised
    that sometimes after improving efficiency, you have achieved desired latency!
    Let’s go through some further reasons why efficiency might be superior:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，在优化性能时，我们通常应该首先专注于提高效率，而不是速度。正如你将在[“优化延迟”](ch10.html#ch-opt-latency-example)中看到的那样，仅通过改善效率，我就能够仅用一个CPU核心将延迟降低七倍。有时候，改善效率后，你可能会惊讶地发现已经达到了期望的延迟！让我们进一步探讨为何效率可能更为重要的一些原因：
- en: It is much harder to make efficient software slow.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 制作高效软件变慢要困难得多。
- en: This is similar to the fact that readable code is easier to optimize. However,
    as I mentioned before, efficient code usually performs better simply because less
    work has to be done. In practice, this also translates to the fact that slow software
    is often inefficient.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这与可读性代码更易优化的事实类似。但正如我之前提到的，由于需要做的工作较少，高效代码通常表现更好。在实践中，这也意味着慢速软件通常是低效的。
- en: Speed is more fragile.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 速度更易受影响。
- en: As you will learn in [“Reliability of Experiments”](ch07.html#ch-obs-rel), the
    latency of the software process depends on a huge amount of external factors.
    One can optimize the code for fast execution in a dedicated and isolated environment,
    but it can be much slower when left running for a longer time. At some point,
    CPUs might be throttled due to thermal issues with the server. Other processes
    (e.g., periodic backup) might surprisingly slow your main software. The network
    might be throttled. There are tons of hidden unknowns to consider when we program
    for mere execution speed. This is why efficiency is usually what we, as programmers,
    can control the most.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在[“实验的可靠性”](ch07.html#ch-obs-rel)中学到的，软件流程的延迟取决于大量外部因素。一个人可以优化代码以在专用和隔离环境中快速执行，但在长时间运行后可能会慢得多。在某些时候，由于服务器的热问题，CPU可能会被限制频率。其他进程（例如定期备份）可能会意外地减慢您的主要软件。网络可能会被限制。在编程时，要考虑到大量隐藏的未知因素。这就是为什么效率通常是我们作为程序员能够最好控制的因素。
- en: Speed is less portable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 速度不够便携。
- en: If we optimize only for speed, we cannot assume it will work the same when moving
    our application from the developer machine to a server or between various client
    devices. Different hardware, environments, and operating systems can diametrically
    change the latency of our application. That’s why it’s critical to design software
    for efficiency. First of all, there are fewer things that can be affected. Secondly,
    if you make two calls to the database on your developer machine, chances are that
    you will do the same number of calls, no matter if you deploy it to an IoT device
    in the space station or an ARM-based mainframe.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅优化速度，那么当将应用程序从开发者机器移至服务器或不同客户端设备时，不能保证其能够同样运行。不同的硬件、环境和操作系统可能会完全改变应用程序的延迟。因此，设计高效软件至关重要。首先，受影响的因素较少。其次，如果在开发者机器上对数据库进行两次调用，那么无论是将其部署到空间站的物联网设备还是基于ARM的大型机，调用次数可能都是相同的。
- en: Generally, efficiency is something we should do right after or together with
    readability. We should start thinking about it from the very beginning of the
    software design. A healthy efficiency awareness, when not taken to the extreme,
    results in robust development hygiene. It allows us to avoid silly performance
    mistakes that are hard to improve on in later development stages. Doing less work
    also often reduces the overall complexity of the code, and improves code maintainability
    and extensibility.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，效率是我们在可读性之后或与可读性同时要考虑的事情。我们应该从软件设计的最开始就开始考虑效率问题。健康的效率意识，如果不过度强调，会导致健壮的开发习惯。它使我们能够避免那些在后期开发阶段难以改进的低效性能错误。做更少的工作通常还能减少代码的总体复杂性，提高代码的可维护性和可扩展性。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I think it’s very common for developers to start their development process with
    compromises in mind. We often sit down with the attitude that we must compromise
    certain software qualities from the beginning. We are often taught to sacrifice
    qualities of our software, like efficiency, readability, testability, etc., to
    accomplish our goals.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，开发者通常在开始开发过程时心存妥协。我们经常坐下来时带着必须从一开始就妥协某些软件品质的态度。我们经常被教导要牺牲软件的质量，如效率、可读性、可测试性等，以完成我们的目标。
- en: In this chapter, I wanted to encourage you to be a bit more ambitious and greedy
    for software quality. Hold out and try not to sacrifice any quality until you
    have to—until it is demonstrated that there is no reasonable way you can achieve
    all of your goals. Don’t start your negotiations with default compromises in mind.
    Some problems are hard without simplifications and compromises, but many have
    solutions with some effort and appropriate tools.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我希望鼓励你在软件质量上更有野心、更贪婪一些。坚持下去，并且尽量不要在不必要之前牺牲任何质量——直到证明无法实现所有目标为止。不要从默认的妥协立场开始你的谈判。有些问题在没有简化和妥协的情况下确实很难，但许多问题在一些努力和适当的工具下是可以解决的。
- en: Hopefully, at this point, you are aware that we have to think about efficiency,
    ideally from the early development stages. We learned what performance consists
    of. In addition, we learned that many misconceptions are worth challenging when
    appropriate. We need to be aware of the risk of premature pessimization and premature
    scalability as much as we need to consider avoiding premature optimizations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到此为止，你已经意识到我们必须从早期开发阶段开始考虑效率的问题。我们了解了性能的组成。此外，我们了解到许多误解在适当时是值得挑战的。我们需要意识到过早的悲观和过早的可扩展性，就像我们需要考虑避免过早的优化一样重要。
- en: Finally, we learned that efficiency in the performance equation might give us
    an advantage. It is easier to improve performance by improving efficiency first.
    It helped my students and me many times to effectively approach the subject of
    performance optimizations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解到性能方程中的效率可能会给我们带来优势。通过先提高效率来改善性能是比较容易的。这在有效地处理性能优化主题上多次帮助了我的学生和我。
- en: In the next chapter, we will walk through a quick introduction to Go. Knowledge
    is key to better efficiency, but it’s extra hard if we are not proficient with
    the basics of the programming language we use.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将快速介绍一下 Go 语言。知识是提高效率的关键，但如果我们对所使用的编程语言的基础不熟练，这将变得非常困难。
- en: ^([1](ch01.html#idm45606840459904-marker)) I even did a small [experiment on
    Twitter](https://oreil.ly/997J5), proving this point.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45606840459904-marker)) 我甚至在 Twitter 上做了一个小的 [实验](https://oreil.ly/997J5)，证明了这一点。
- en: ^([2](ch01.html#idm45606840401472-marker)) The UK Cambridge Dictionary [defines](https://oreil.ly/AXq4Q)
    the noun *performance* as “How well a person, machine, etc. does a piece of work
    or an activity.”
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm45606840401472-marker)) 英国剑桥词典 [定义](https://oreil.ly/AXq4Q)
    名词*性能*为“一个人、机器等完成工作或活动的能力有多强”。
- en: ^([3](ch01.html#idm45606849124608-marker)) I would even recommend, with your
    changelog, sticking to common standard formats like [you can see here](https://oreil.ly/rADTI).
    This material also contains valuable tips on clean release notes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#idm45606849124608-marker)) 我甚至建议，与您的变更日志一起，遵循像[这里所示的](https://oreil.ly/rADTI)
    通用标准格式。这些材料还包含了关于清晰发布说明的宝贵提示。
- en: ^([4](ch01.html#idm45606840462688-marker)) Can we say “less performant” in this
    sentence? We can’t, because the word *performant* does not exist in English vocabulary.
    Perhaps it indicates that our software can’t be “performant”—there is always room
    to improve things. In a practical sense, there are limits to how fast our software
    can be. [H. J. Bremermann in 1962 suggested](https://oreil.ly/1sl3f) there is
    a computational physical limit that depends on the mass of the system. We can
    estimate that 1 kg of the ultimate laptop can process ~10^(50) bits per second,
    while the computer with the mass of the planet Earth can process at a maximum
    of 10^(75) bits per second. While those numbers feel enormous, even such a large
    computer would take ages to force all chess movements [estimated to 10^(120) complexity](https://oreil.ly/6qS1T).
    Those numbers have practical use in cryptography to assess the difficulty of cracking
    certain encryption algorithms.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.html#idm45606840462688-marker)) 我们可以在这个句子中使用“less performant”吗？不能，因为*performant*这个词在英语词汇中并不存在。也许这表明我们的软件不能够“高效”——总有改进的余地。在实际意义上，我们的软件能力有其极限。[1962年，H.
    J. Bremermann 提出](https://oreil.ly/1sl3f) 存在一个计算物理上的极限，这取决于系统的质量。我们可以估计，一台质量极轻的笔记本电脑每秒能处理
    ~10^(50) 位，而地球质量的计算机最多每秒能处理 10^(75) 位。尽管这些数字看起来巨大，但即使是这样一台大型计算机也需要很长时间才能强制执行所有的象棋走法（估计为
    10^(120) 复杂度）。这些数字在密码学中有着实际应用，用来评估破解特定加密算法的难度。
- en: ^([5](ch01.html#idm45606857311024-marker)) It’s worth mentioning that hiding
    features or optimization can sometimes lead to lower readability. Sometimes explicitness
    is much better and avoids surprises.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#idm45606857311024-marker)) 值得一提的是，有时隐藏功能或优化可能会导致可读性降低。有时明确性更好，可以避免意外。
- en: ^([6](ch01.html#idm45606843921408-marker)) As the part of the interface “contract,”
    there might be a comment stating that implementations should cache the result.
    Hence, the caller should be safe to call it many times. Still, I would argue that
    it’s better to avoid relying on something not assured by a type system to prevent
    surprises.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#idm45606843921408-marker)) 作为接口“契约”的一部分，可能会有一条注释说明实现应该缓存结果。因此，调用者可以放心多次调用它。但我认为，最好避免依赖于类型系统未保证的东西，以防意外。
- en: ^([7](ch01.html#idm45606843871360-marker)) All three examples of `Get` implementations
    could be considered costly to invoke. Input-output (I/O) operations against the
    filesystem are significantly slower than reading or writing something from memory.
    Something that involves mutexes means you potentially have to wait on other threads
    before accessing it. Call to database usually involves all of them, plus potentially
    communication over the network.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01.html#idm45606843871360-marker)) 所有三个`Get`实现的示例可能被认为是昂贵的调用。与内存中读取或写入相比，针对文件系统的输入输出（I/O）操作要慢得多。涉及互斥锁意味着在访问之前可能需要等待其他线程。调用数据库通常涉及所有这些，并且可能涉及网络通信。
- en: ^([8](ch01.html#idm45606843577968-marker)) This famous quote is used to stop
    someone from spending time on optimization effort. Generally overused, it comes
    from Donald Knuth’s [“Structured Programming with `goto` statements”](https://oreil.ly/m3P50)
    (1974).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01.html#idm45606843577968-marker)) 这句著名的引用用来阻止某人花费时间在优化上。通常被滥用，它来自唐纳德·库努斯的[“带有
    `goto` 语句的结构化编程”](https://oreil.ly/m3P50)（1974）。
- en: '^([9](ch01.html#idm45606843574448-marker)) This type of style is usually referred
    to as Hungarian notation, which is used extensively in Microsoft. There are two
    types of this notation too: App and Systems. Literature indicates that [Apps Hungarian
    can still give many benefits](https://oreil.ly/rYLX4).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch01.html#idm45606843574448-marker)) 这种类型的风格通常被称为匈牙利命名法，它在微软公司被广泛使用。这种记法也分为两种：App
    和 Systems。文献表明，[Apps Hungarian 仍然可以带来许多好处](https://oreil.ly/rYLX4)。
- en: ^([10](ch01.html#idm45606843547632-marker)) It is worth highlighting that these
    days, it is recommended to write code in a way that is easily compatible with
    IDE functionalities; e.g., your code structure should be a [“connected” graph](https://oreil.ly/mFzH9).
    This means that you connect functions in a way that IDE can assist. Any dynamic
    dispatching, code injection, and lazy loading disables those functionalities and
    should be avoided unless strictly necessary.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch01.html#idm45606843547632-marker)) 值得强调的是，如今建议以与IDE功能轻松兼容的方式编写代码；例如，你的代码结构应该是[“连通”的图](https://oreil.ly/mFzH9)。这意味着你连接函数的方式应该是IDE可以帮助的。任何动态分派、代码注入和延迟加载会禁用这些功能，除非绝对必要。
- en: ^([11](ch01.html#idm45606843544416-marker)) Cognitive load is the amount of
    “brain processing and memory” a [person must use to understand a piece of code
    or function](https://oreil.ly/5CJ9X).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch01.html#idm45606843544416-marker)) 认知负荷是指“大脑处理和记忆”的量，一个[人必须用来理解代码或函数](https://oreil.ly/5CJ9X)。
- en: ^([12](ch01.html#idm45606843499040-marker)) *Cachability* is often [defined](https://oreil.ly/WNaRz)
    as the ability to be cached. It is possible to cache (save) any information to
    retrieve it later, faster. However, the data might be valid only for a short time
    or only for a tiny amount of requests. If the data depends on external factors
    (e.g., user or input) and changes frequently, it’s not well cachable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch01.html#idm45606843499040-marker)) *可缓存性*通常被[定义](https://oreil.ly/WNaRz)为可以被缓存的能力。可以缓存（保存）任何信息以便以后检索，速度更快。但是，数据可能仅在短时间内有效，或者仅适用于少量请求。如果数据依赖于外部因素（例如用户或输入）并且频繁更改，则其缓存效果不佳。
- en: ^([13](ch01.html#idm45606843474240-marker)) That is a simplification, of course.
    The process might have used more memory. Profiles do not show memory used by memory
    maps, stacks, and many other caches required for modern applications to work.
    We will learn more about this in [Chapter 4](ch04.html#ch-hardware).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch01.html#idm45606843474240-marker)) 当然，这只是一个简化。该过程可能使用了更多的内存。配置文件不显示现代应用程序运行所需的内存映射、堆栈和许多其他缓存。我们将在[第四章](ch04.html#ch-hardware)中学到更多相关内容。
- en: ^([14](ch01.html#idm45606843465968-marker)) Cyril Northcote Parkinson was a
    British historian who articulated the management phenomenon that is now known
    as Parkinson’s Law. Stated as “Work expands to fill the time available for its
    completion,” it was initially referred to as the government office efficiency
    that highly correlates to the official’s number in the decision-making body.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch01.html#idm45606843465968-marker)) Cyril Northcote Parkinson是一位英国历史学家，阐述了现在被称为帕金森法则的管理现象。这一法则称为“工作会膨胀以填满其完成所需的时间”，最初是指高度与决策机构中官员数量相关联的政府办公室效率。
- en: ^([15](ch01.html#idm45606843465280-marker)) At least that’s what my studying
    looked like. This phenomenon is also known as the [“student syndrome”](https://oreil.ly/4Vpqb).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch01.html#idm45606843465280-marker)) 至少这就是我学习的样子。这种现象也被称为[“学生综合症”](https://oreil.ly/4Vpqb)。
- en: ^([16](ch01.html#idm45606843454544-marker)) *PB* means petabyte. One petabyte
    is 1,000 TB. If we assume an average two-hour-long 4K movie takes 100 GB, this
    means with 1 PB, we could store 10,000 movies, translating to roughly two to three
    years of constant watching.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch01.html#idm45606843454544-marker)) *PB*意味着皮字节。一皮字节等于1,000 TB。如果我们假设一个平均两小时长的4K电影占用100
    GB，那么用1 PB可以存储10,000部电影，相当于大约两到三年的持续观看时间。
- en: ^([17](ch01.html#idm45606843442000-marker)) 1 zettabyte is 1 million PB, one
    billion of TB. I won’t even try to visualize this amount of data. :)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch01.html#idm45606843442000-marker)) 1赫赫字节等于1百万PB，一百亿TB。我甚至不敢尝试想象这么多的数据量。
    :)
- en: '^([18](ch01.html#idm45606843429376-marker)) Robert H. Dennard et al., [“Design
    of Ion-Implanted MOSFET’s with Very Small Physical Dimension”](https://oreil.ly/OAGPC),
    *IEEE Journal of Solid-State Circuits* 9, no. 5 (October 1974): 256–268.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch01.html#idm45606843429376-marker)) Robert H. Dennard等人，《“非常小物理尺寸的离子注入MOSFET设计”》[IEEE固态电路杂志](https://oreil.ly/OAGPC)，9卷5期（1974年10月）：256–268页。
- en: ^([19](ch01.html#idm45606843427616-marker)) [MOSFET](https://oreil.ly/mhc5k)
    stands for “metal–oxide–semiconductor field-effect transistor,” which is, simply
    speaking, an insulated gate allowing to switch electronic signals. This particular
    technology is behind most memory chips and microprocessors produced between 1960
    and now. It has proven to be highly scalable and capable of miniaturization. It
    is the most frequently manufactured device in history, with 13 sextillion pieces
    produced between 1960 and 2018.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch01.html#idm45606843427616-marker)) [MOSFET](https://oreil.ly/mhc5k)代表“金属氧化物半导体场效应晶体管”，简单来说，它是一个允许切换电子信号的绝缘门。这种特定技术驱动了1960年至今大多数存储芯片和微处理器的背后。它已被证明具有高度可扩展性和微小化能力。它是历史上生产数量最多的器件，1960年至2018年间生产了13兆兆个器件。
- en: ^([20](ch01.html#idm45606843423600-marker)) Funnily enough, marketing reasons
    led companies to hide the inability to reduce the size of transistors effectively
    by switching the CPU generation naming convention from transistor gate length
    to the size of the process. 14 nm generation CPUs still have 70 nm transistors,
    similar to 10, 7, and 5 nm processes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch01.html#idm45606843423600-marker)) 有趣的是，出于营销原因，公司们通过将CPU世代命名约定从晶体管门长度转换为工艺尺寸来隐藏有效减少晶体管大小的能力。14纳米世代的CPU仍然使用70纳米的晶体管，类似于10、7和5纳米工艺。
- en: ^([21](ch01.html#idm45606843420032-marker)) I am not joking. [Microsoft has
    proven](https://oreil.ly/nJzkN) that running servers 40 meters underwater is a
    great idea that improves energy efficiency.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch01.html#idm45606843420032-marker)) 我不是在开玩笑。[微软已经证明](https://oreil.ly/nJzkN)，将服务器放在水下40米是一个极好的主意，可以提高能效。
- en: '^([22](ch01.html#idm45606843409552-marker)) [The M1 chip](https://oreil.ly/emBke)
    is a great example of an interesting trade-off: choosing speed and both energy
    and performance efficiency over the flexibility of hardware scaling.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch01.html#idm45606843409552-marker)) [M1芯片](https://oreil.ly/emBke)是一个有趣权衡的优秀示例：选择速度和能效性能的灵活性，而不是硬件扩展性。
- en: ^([23](ch01.html#idm45606843408144-marker)) RISC-V is an open standard for the
    instruction set architecture, allowing easier manufacturing of compatible “reduced
    instruction set computer” chips. Such a set is much simpler and allows more optimized
    and specialized hardware than general-usage CPUs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch01.html#idm45606843408144-marker)) RISC-V是一种开放标准的指令集架构，可以更容易地制造兼容的“精简指令集计算机”芯片。这种集合比一般用途的CPU更简单，并且允许更优化和专门化的硬件。
- en: ^([24](ch01.html#idm45606843404912-marker)) To ensure developers understand
    and empathize with users who have a slower connection, Facebook introduced [“2G
    Tuesdays”](https://oreil.ly/fZSoQ) that turn on the simulated 2G network mode
    on the Facebook application.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ^([24](ch01.html#idm45606843404912-marker)) 为了确保开发者理解并与网络连接较慢的用户产生共鸣，Facebook
    引入了[“2G Tuesdays”](https://oreil.ly/fZSoQ)，在 Facebook 应用上开启模拟的 2G 网络模式。
- en: ^([25](ch01.html#idm45606843384320-marker)) That option is not as expensive
    as we might think. Instance type x1e.32xlarge [costs $26.60 per hour](https://oreil.ly/9fw5G),
    so “only” $19,418 per month.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^([25](ch01.html#idm45606843384320-marker)) 这个选项并不像我们想象的那么昂贵。实例类型 x1e.32xlarge
    [每小时费用为 $26.60](https://oreil.ly/9fw5G)，所以一个月“只有” $19,418。
- en: ^([26](ch01.html#idm45606843380848-marker)) Even hardware management has to
    be different for machines with extremely large hardware. That’s why Linux kernels
    have the special [hugemem](https://oreil.ly/tlWh3) type of kernels that can manage
    up to four times more memory and ~eight times more logical cores for x86 systems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([26](ch01.html#idm45606843380848-marker)) 即使是对于具有极大硬件的机器，硬件管理也必须有所不同。这就是为什么
    Linux 内核有专门的[hugemem](https://oreil.ly/tlWh3)类型内核，可以管理多达四倍的内存和大约八倍的 x86 系统逻辑核心。
- en: ^([27](ch01.html#idm45606843362992-marker)) [CAP](https://oreil.ly/EYqPI) is
    a core system design principle. Its acronym comes from Consistency, Availability,
    and Partition tolerance. It defines a simple rule that only two of the three can
    be achieved.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([27](ch01.html#idm45606843362992-marker)) [CAP](https://oreil.ly/EYqPI) 是核心系统设计原则。它的首字母缩写来自一致性（Consistency）、可用性（Availability）和分区容忍性（Partition
    tolerance）。它定义了一个简单的规则，即这三者中只能同时实现两个。
- en: ^([28](ch01.html#idm45606843360512-marker)) Denial of Service is a state of
    the system that makes the system unresponsive, usually due to malicious attack.
    It can also be trigged “accidentally” by an unexpectedly large load.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([28](ch01.html#idm45606843360512-marker)) 拒绝服务是系统处于无响应状态，通常是由于恶意攻击引起的。它也可能因意外的大负载而“意外”触发。
- en: ^([29](ch01.html#idm45606843358880-marker)) Around 2015, it was the fastest
    supercomputer in Poland, offering 1.41 PFlop/s and over 1,600 nodes, most of them
    with dedicated GPUs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([29](ch01.html#idm45606843358880-marker)) 大约在 2015 年，这是波兰最快的超级计算机，提供 1.41
    PFlop/s 的性能和超过 1,600 个节点，其中大多数节点配备了专用的 GPU。
- en: ^([30](ch01.html#idm45606843358192-marker)) InfiniBand is a high-performance
    network communication standard, especially popular before fiber optic was invented.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([30](ch01.html#idm45606843358192-marker)) InfiniBand 是一种高性能网络通信标准，特别是在光纤发明之前非常流行。
- en: ^([31](ch01.html#idm45606843327472-marker)) Funny enough, Mark Zuckerberg at
    an F8 conference in 2014 [announced a change of the famous motto to “Move fast
    with stable infra”](https://oreil.ly/Yt2VI).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ^([31](ch01.html#idm45606843327472-marker)) 有趣的是，Mark Zuckerberg 在 2014 年的 F8
    大会上[宣布了将著名的座右铭更改为“Move fast with stable infra”](https://oreil.ly/Yt2VI)。
- en: ^([32](ch01.html#idm45606843308816-marker)) One example I see often in the cloud-native
    world is moving logging stack from Elasticsearch to simpler solutions like Loki.
    Despite the lack of configurable indexing, the Loki project can offer better logging
    read performance with a smaller amount of resources.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ^([32](ch01.html#idm45606843308816-marker)) 在云原生世界中，我经常看到的一个例子是将日志堆栈从 Elasticsearch
    移动到像 Loki 这样更简单的解决方案。尽管缺乏可配置的索引功能，Loki 项目能够以更少的资源提供更好的日志读取性能。
- en: '^([33](ch01.html#idm45606843292640-marker)) There is also another reason. The
    “Efficient Go” name is very close to one of the best documentation pieces you
    might find about the Go programming language: [“Effective Go”](https://oreil.ly/OHbMt)!
    It might also be one of the first pieces of information I have read about Go.
    It’s specific, actionable, and I recommend reading it if you haven’t.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^([33](ch01.html#idm45606843292640-marker)) 还有另一个原因。 “Efficient Go” 这个名称与你可能在
    Go 编程语言中找到的最好的文档之一——[“Effective Go”](https://oreil.ly/OHbMt)非常相似！这可能也是我读过的关于 Go
    的第一篇文章。它具体、可操作，如果你还没有阅读过，我推荐你阅读一下。
