- en: Chapter 6\. Data Structure Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 数据结构实例
- en: 6.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.0 简介
- en: Go has 4 basic types of data structures — arrays, slices, maps and structs.
    We have a separate chapter on structs altogether so we’ll discuss that separately.
    In this chapter we’ll be discussing arrays, slices and maps only. We’ll start
    off with some background information on them before getting into specific recipes
    on using them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有4种基本的数据结构 — 数组、切片、映射和结构体。我们单独有一章讨论结构体，所以我们将分开讨论它。在本章中，我们只讨论数组、切片和映射。我们将先讲解它们的背景信息，然后再深入讨论它们的具体用法。
- en: Array
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are data structures that represent an ordered sequence of elements of
    the same type. Array sizes are static, they are set when the array is defined
    and cannot be changed subsequently. Arrays are values. This is an important difference
    because in some languages an array is like a pointer to the first item in the
    array. This means if we pass an array to a function we will be passing a copy
    of the array and this could be expensive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是表示相同类型元素的有序序列的数据结构。数组的大小是静态的，在定义数组时设置，之后无法更改。数组是值类型。这是一个重要的区别，因为在某些语言中，数组类似于指向数组中第一个项的指针。这意味着如果我们将数组传递给函数，我们将传递数组的副本，这可能会很昂贵。
- en: Slice
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: Slices are data structures that also represent an ordered sequence of elements.
    In fact slices are built on top of arrays and are used much more often than arrays
    because of its flexibility. Slices have no fixed length. Internally, a slice is
    a struct that consists of a pointer to an array, the length of the segment of
    the array, and the capacity of the underlying array.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也是表示有序元素序列的数据结构。事实上，切片是建立在数组之上的，并且由于其灵活性，比数组更常用。切片没有固定的长度。在内部，切片是一个结构体，包含一个指向数组的指针，数组段的长度以及底层数组的容量。
- en: Map
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are data structures that associate the values of one type (called the *key*)
    with values of another type (called the *value*). Such data structures are very
    common in many other programming languages, called in different names like hash
    table, hash map and dictionary. Internally, a map is a pointer to `runtime.hmap`
    structure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种将一个类型的值（称为*键*）与另一个类型的值（称为*值*）相关联的数据结构。这样的数据结构在许多其他编程语言中很常见，有不同的名称，如哈希表、哈希映射和字典。在内部，映射是一个指向`runtime.hmap`结构的指针。
- en: It’s important to understand that these 3 data structures are the basic building
    blocks of all other data structures, but they are also fundamentally very different
    from each other. In short, arrays are fixed length order lists that are values.
    Slices are structs that has the first element that is a pointer to an array. Maps
    are pointers to an internal hashmap struct.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这3种数据结构很重要，它们是所有其他数据结构的基础构建模块，但它们彼此之间也有根本性的不同。简而言之，数组是固定长度的有序列表，是值类型。切片是一个结构体，其第一个元素是指向数组的指针。映射是指向内部哈希映射结构的指针。
- en: 6.1 Creating arrays or slices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 创建数组或切片
- en: Problem
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create arrays or slices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建数组或切片。
- en: Solution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are many ways of creating arrays or slices including directly from literals,
    or from another array, or using `make`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组或切片的方法有很多，包括直接使用文字、从另一个数组创建，或使用`make`函数。
- en: Discussion
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Arrays and slices are very different constructs but conceptually they are very
    similar. As a result, creating arrays and slices are also very similar.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片在概念上有很大的差异，但在概念上它们非常相似。因此，创建数组和切片也非常相似。
- en: Defining arrays
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义数组
- en: You can define an array by declaring the size of the array in square brackets,
    followed by the data type of the elements. Arrays and slices can only have elements
    of the same type. You can also initialize the array during the declaration by
    putting the elements in curly brackets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在方括号中声明数组的大小，然后跟着元素的数据类型来定义数组。数组和切片只能包含相同类型的元素。你也可以在声明时用花括号初始化数组。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you run the code snippet above, this is what you will see.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码片段，你将会看到这个结果。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default values for an int or float array is 0\. Note that the size of the
    array cannot be changed once it’s created, but the elements can be changed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: int或float数组的默认值为0。请注意，一旦创建数组，数组的大小就不能再改变，但元素可以改变。
- en: Defining slices
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义切片
- en: Slices are constructs that are built on top of arrays. Most of the time when
    you need to deal with ordered lists, you would normally use slices because they
    are more flexible and also much cheaper to use, especially if the underlying array
    is large.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是建立在数组之上的构造。大多数情况下，当需要处理有序列表时，通常会使用切片，因为它们更灵活，而且如果底层数组很大，使用起来也更便宜。
- en: Slices are defined exactly the same way, except you don’t provide the size of
    the slice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的定义方式完全相同，只是不提供切片的大小。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the code snippet above, this is what you will see.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述代码片段，你将看到这个。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can also create slices through the `make` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`make`函数创建切片。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you use `make`, you need to provide the type, the length and an optional
    capacity. If you don’t provide the capacity, it will default to the given length.
    This is what you will see if you run the snippet above.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`make`，需要提供类型、长度和可选的容量。如果不提供容量，默认为给定的长度。如果你运行上述片段，你将看到这个。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `make` initializes the slice as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`make`也初始化了切片。
- en: To find out the length of an array or a slice, you can use the `len` function.
    To find out the capacity of an array or a slice, you can use the `cap` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出数组或切片的长度，可以使用`len`函数。要找出数组或切片的容量，可以使用`cap`函数。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `make` function above allocates an array of 15 integers, then creates a
    slice with length of 10 and capacity of 15 that points at the first 10 elements
    of the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`make`函数分配了一个包含15个整数的数组，然后创建了一个长度为10、容量为15的切片，指向数组的前10个元素。
- en: If you run the code above, this is what you get.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述代码，这就是你会得到的结果。
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also create new slices with the `new` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用`new`方法创建新的切片。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `new` method doesn’t return the slice directly, it only returns a pointer
    to the slice. It also doesn’t initialize the slice, instead it just zeros it.
    You can see what you get when you run the code above.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`方法不直接返回切片，它只返回一个指向切片的指针。它也不初始化切片，而是将其置零。运行上述代码时，你会看到得到什么。'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can’t create new arrays using the `make` function, but we can create new
    arrays using the `new` function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`make`函数创建新数组，但可以使用`new`函数创建新数组。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we get is a pointer to an array as below.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个指向数组的指针如下。
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 6.2 Accessing arrays or slices
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 访问数组或切片
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access elements in an array of a slice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你想访问数组或切片中的元素。
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are a few ways to access elements in an array or a slice. Arrays and slices
    are ordered lists so elements in them can be accessed by their index. The elements
    can be access through a single index or through a range of indices. You can also
    access them by iterating through the elements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以访问数组或切片中的元素。数组和切片是有序列表，因此可以通过它们的索引访问元素。可以通过单个索引或索引范围访问元素。还可以通过迭代元素访问它们。
- en: Discussion
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Accessing arrays and slices are almost the same. As they are ordered lists,
    we can access an element of an array or a slice through its index.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组和切片几乎是相同的。由于它们是有序列表，我们可以通过索引访问数组或切片的元素。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given the slice above, the 4th element in the slice, given the index 3 (we start
    with 0) is 25 and can be accessed using the name of variable, followed by square
    brackets, and indicating the index within the square brackets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定上面的切片，给定索引3（从0开始），切片中的第4个元素是25，并可以使用变量名，后跟方括号和方括号内的索引访问。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can also access a range of number by using the starting index, followed by
    a colon `:` and the ending index. The ending index is not included and this results
    in a slice (of course).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用起始索引，后跟冒号`:`和结束索引来访问一系列数字。结束索引不包括在内，这导致一个切片（当然）。
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we don’t have a starting index, the slice will start at 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有起始索引，切片将从0开始。
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we don’t have an ending index, the slice will end with the last element of
    the original slice (or array).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有结束索引，切片将以原始切片（或数组）的最后一个元素结束。
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Needless to say if you don’t have either a starting or ending index, the whole
    original slice is returned. While this sounds silly, there is a valid use for
    this — it simply converts an array into a slice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，如果你没有起始索引或结束索引，将返回整个原始切片。虽然这听起来很愚蠢，但这确实有其有效用途——它简单地将一个数组转换为切片。
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also access elements in an array or a slice by iterating through the
    array or slice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过迭代数组或切片来访问数组或切片中的元素。
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This uses a normal `for` loop, iterating through the length of the slice, incrementing
    the count at every loop. The resulting output is as below.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个普通的`for`循环，迭代切片的长度，每次循环增加计数。得到的输出如下。
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This uses a `for …​ range` loop and returns the index `i` and the value `v`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一个`for …​ range`循环，并返回索引`i`和值`v`。
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resulting output is as below
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的输出如下
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 6.3 Modifying arrays or slices
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 修改数组或切片
- en: Problem
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to add, insert or remove elements in an array or a slice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要在数组或切片中添加、插入或删除元素。
- en: Solution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are a few ways to modify elements in an array or a slice. Elements can
    be appended to the end of the slice, inserted at a particular index, removed or
    modified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以修改数组或切片中的元素。元素可以附加到切片的末尾，插入到特定索引位置，删除或修改。
- en: Discussion
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Besides accessing the elements in an array or slice, you would also want to
    add, modify or remove elements in a slice. While you cannot add or remove elements
    in an array, you can always modify its elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问数组或切片中的元素外，您还可能希望在切片中添加、修改或删除元素。虽然无法在数组中添加或删除元素，但您始终可以修改其元素。
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you modify the element at the given index, it will change the array or
    slice accordingly. In this case, when you run the code, you will get this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您修改给定索引处的元素时，它将相应地更改数组或切片。在这种情况下，当您运行代码时，将得到这个结果。
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Appending
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加
- en: Arrays cannot change its size, so appending or adding elements to an array is
    out of question. Appending to slices is quite straightforward though. We can just
    use the `append` function, passing it the slice and the new element and we will
    be returned with a new slice that has the appended element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数组无法改变其大小，因此无法向数组附加或添加元素。但是向切片附加元素非常简单。我们只需使用`append`函数，将其传递给切片和新元素，我们将得到一个具有附加元素的新切片。
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run the code above, you will get this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上述代码，您将得到这个结果。
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You cannot append an element of a different type to the slice. However you can
    append multiple items to the slice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能将不同类型的元素附加到切片中。但是您可以向切片附加多个项目。
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means you can actually append a slice (or an array) to another slice by
    using the slice unpacking notation `…​`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您实际上可以使用切片解包符号`…​`将一个切片（或数组）附加到另一个切片中。
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, appending both an element and an unpacked slice at the same time is
    not allowed. You can only choose to append multiple elements or an unpacked slice,
    but not both at the same time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是同时附加一个元素和一个解包的切片是不允许的。您只能选择附加多个元素或一个解包的切片，但不能同时进行。
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inserting
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入
- en: While appending adds an element to the end of the slice, inserting means adding
    an element anywhere in between elements in a slice. Again, this only applies to
    slices because array sizes are fixed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然附加会向切片的末尾添加一个元素，但插入意味着在切片中的元素之间的任何位置添加一个元素。再次强调，这仅适用于切片，因为数组的大小是固定的。
- en: There is no built-in function for insertion, unlike `append` but we can still
    use `append` for the task. Let’s say we want to insert the number 1000 between
    elements at index 2 and 3.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与`append`不同，插入没有内置函数，但我们仍然可以使用`append`来完成任务。假设我们想在索引2和3之间的元素之间插入数字1000。
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we need to create a slice from the start of the original slice, to the
    index 2 plus 1\. This will reserve a space for the new element we want to add.
    Next we append this slice to another slice that begins at the index 2 to the end
    of the original slice, using the unpack notation. With this, we have created a
    new element between the index 2 and 3\. Finally, we set the new element, 1000,
    at index 2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从原始切片的开头创建一个切片，到索引2加1。这将为我们希望添加的新元素保留空间。接下来，我们将这个切片附加到另一个从索引2到原始切片末尾的切片中，使用解包符号。通过这种方式，我们在索引2和3之间创建了一个新元素。最后，我们在索引2处设置新元素1000。
- en: As as result we will get this new slice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果我们将得到这个新的切片。
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What if we want to add an element to the beginning of the slice? Let’s say we
    want to add the integer 2000 to the beginning of the slice. This is quite simple,
    we simply append the value, in the form of a slice, to the unpacked values of
    the original slice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在切片的开头添加一个元素怎么办？假设我们想要将整数2000添加到切片的开头。这很简单，我们只需将值以切片的形式附加到原始切片的解包值中。
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That was the case with inserting a single element. What if we want to insert
    another slice in between another slice? Let’s say we want to insert the slice
    `[]int{1000, 2000, 3000, 4000}` in between our `numbers` slice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在插入单个元素时的情况。如果我们想在另一个切片中间插入另一个切片怎么办？假设我们想在我们的`numbers`切片中间插入切片`[]int{1000,
    2000, 3000, 4000}`。
- en: There are a few ways of doing this, but we’ll stick with using `append`, which
    is one of the shortest way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点，但我们将坚持使用`append`，这是最简洁的方法之一。
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First of all, we need to create another slice, `tail` to store the *tail* part
    of the original slice. We can’t simply slice it and store into another variable
    (this is called *shallow copy*), because remember — slices are not arrays, they
    are a pointer to a part of the array, and its length. If we slice `numbers` and
    store it in `tail`, when we change `numbers`, `tail` will also change, and that
    is not what we want. Instead, we want to create a new slice by appending it to
    an empty slice of ints.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建另一个切片，`tail`，来存储原始切片的*尾*部分。我们不能简单地对其进行切片并存储到另一个变量中（这称为*浅复制*），因为请记住——切片不是数组，它们是数组的一部分和其长度的指针。如果我们对`numbers`进行切片并存储到`tail`中，当我们改变`numbers`时，`tail`也会改变，这不是我们想要的。相反，我们希望通过将其附加到一个空的`int`切片来创建一个新的切片。
- en: Now that we have put the tail aside, we append the head of `numbers` to the
    unpacked `inserted`. Finally we append `numbers` (which now consist of the head
    of the original slice, and `inserted`) and the `tail`. This is what we should
    get.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`tail`放在一边，我们将`numbers`的头部附加到未打包的`inserted`中。最后，我们附加`numbers`（现在由原始切片的头部和`inserted`组成）和`tail`。这是我们应该得到的结果。
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Removing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除
- en: Removing elements from a slice is very easy. If it’s at the start or end of
    the slice, you simply re-slice it accordingly to remove either the start or the
    end of the slice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从切片中删除元素非常容易。如果它位于切片的开头或结尾，您只需相应地重新切片即可删除切片的开头或结尾。
- en: Let’s take out the first element of the slice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先取出切片的第一个元素。
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you run the code above, you will get this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您将得到这个结果。
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now let’s take out the last element of the slice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先取出切片的最后一个元素。
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you run the code above, you will get this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您将得到这个结果。
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Removing elements in between is quite straightforward too. You simply append
    the head of the original slice with the tail of the original slice, removing whatever
    is in between. In this case, we want to remove the element at index 2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 中间删除元素也很简单。您只需将原始切片的头部与原始切片的尾部附加在一起，移除其中的任何内容。在这种情况下，我们想要删除索引为2的元素。
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we run the code above, we get this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们得到了这个结果。
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 6.4 Making arrays and slices safe for concurrent use
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 使数组和切片在并发使用时安全
- en: Problem
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make arrays and slices safe for concurrent use by multiple goroutines.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过多个goroutine安全地使用数组和切片。
- en: Solution
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a mutex from the `sync` library to safeguard the array or slice. Lock the
    array or slice before modifying it, and unlock it after modifications are made.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sync`库中的互斥体（mutex）来保护数组或切片。在修改数组或切片之前对其进行锁定，并在修改完成后解锁。
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Arrays and slices are not safe for concurrent use. If you are going to share
    a slice or array between goroutines, you need to make it safe from race conditions.
    Go provides a `sync` package that can be used for this, in particular `Mutex`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片在并发使用时不安全。如果要在多个goroutine之间共享一个切片或数组，则需要使其免受竞争条件的影响。Go语言提供了一个`sync`包，特别是`Mutex`。
- en: Let’s take a look first at how a race condition can come about. Race conditions
    occur when a shared resource is used by multiple goroutines trying to access it
    at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看一下竞争条件是如何产生的。竞争条件发生在多个goroutine试图同时访问共享资源时。
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the example above, we have a slice of integers named `shared`, that is used
    by 2 functions named `increase` and `decrease`. These 2 functions simply takes
    each element in the shared slice and increases or decreases it by 1 respectively.
    However before we increase or decrease the element, we wait for a very short period
    of time, with the `increase` function waiting for a longer time. This simulates
    the differences in timing between multiple goroutines. We print out the `shared`
    slice before we start modifying the shared element and also after we modify it
    to show the state of the shared slice before and after.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有一个名为`shared`的整数切片，被两个名为`increase`和`decrease`的函数使用。这两个函数简单地逐个获取共享切片中的元素并分别增加或减少1。但在增加或减少元素之前，我们等待了一个非常短的时间，其中`increase`函数等待的时间更长。这模拟了多个goroutine之间时间差异的情况。我们在修改共享元素之前打印出`shared`切片的状态，并在修改后再次打印出来以展示其状态变化。
- en: We call the `increase` and `decrease functions from +main` and we make each
    call to the functions a separate goroutine. At the end of the program we wait
    a bit to let all the goroutines finish up (else all goroutines will end when the
    program ends).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`+main`调用`increase`和`decrease`函数，并且每次函数调用都作为一个单独的goroutine。程序结束时，我们稍等片刻以确保所有的goroutine都完成（否则所有的goroutine将在程序结束时结束）。
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we run the program, you will see something like this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，你会看到类似这样的输出。
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you run it multiple times it will be a bit different each time. You will
    notice that even though we spin out a goroutine in sequence (sending in the sequence
    number to `modify` each time), the sequence that actually executes is random,
    which is an expected behavior. What we wouldn’t expect is that the goroutines
    overlap each other and the shared slice is incremented or decremented depending
    on which goroutine accesses it first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次运行它，每次的结果可能会略有不同。你会注意到即使我们按顺序启动goroutine（每次将顺序号发送给`modify`），实际执行的顺序是随机的，这是预期的行为。但我们不希望看到的是goroutine彼此重叠，共享切片根据哪个goroutine先访问而递增或递减。
- en: 'For example, if we look at the first line in the output `[-4 a] : [1 2 3 4
    5 6]` is printed before the loop to decrease each element is called. Subsequently
    after the loop the line that is printed is `[-4 b] : [-2 -2 1 3 4 5]` and you
    can see the first 3 elements are not what is expected!'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，如果我们查看输出的第一行`[-4 a] : [1 2 3 4 5 6]`，会发现在调用减少每个元素的循环之前打印出来了。然后，在循环之后打印的行是`[-4
    b] : [-2 -2 1 3 4 5]`，可以看到前3个元素并不符合预期！'
- en: Also you can will realise that the overlap even happens within the loop for
    increasing or decreasing the element.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你会意识到即使在增加或减少元素的循环内部，重叠也会发生。
- en: How can we prevent such race conditions? Go has the `sync` package in the standard
    library that provides us with a *mutex* or a mutual exclusion lock.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如何防止这种竞争条件？Go语言在标准库中提供了`sync`包，它为我们提供了*mutex*或互斥锁。
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here’s the output if you call these functions from `main` as before.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像以前一样从`main`中调用这些函数，这里是输出结果。
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The results are a lot more organized. The goroutines no longer overlap, the
    increase and decrease of elements are orderly and consistent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果更加有条理。goroutine不再重叠，元素的增加和减少有序而一致。
- en: 6.5 Sorting arrays of slices
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 对切片数组进行排序
- en: Problem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort elements in an array or slice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要对数组或切片中的元素进行排序。
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: For `int`, `float64` and `string` arrays or slices you can use `sort.Ints`,
    `sort.Float64s` and `sort.Strings`. You can also use a custom comparator by using
    `sort.Slice`. For structs, you can create a sortable interface by implementing
    the `sort.Interface` interface and then using `sort.Sort` to sort the array or
    slice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`int`、`float64`和`string`数组或切片，你可以使用`sort.Ints`、`sort.Float64s`和`sort.Strings`。你也可以通过使用`sort.Slice`来使用自定义比较器。对于结构体，你可以通过实现`sort.Interface`接口来创建一个可排序的接口，然后使用`sort.Sort`来对数组或切片进行排序。
- en: Discussion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Arrays and slices are ordered sequence of elements. However this doesn’t mean
    they are sorted in any way, it only means the elements are always laid out in
    the same sequence. To sort the arrays or slices, we can use the various functions
    in the `sort` package.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片是有序元素序列。然而，这并不意味着它们以任何方式排序，只是表示元素始终以相同的顺序排列。要对数组或切片进行排序，我们可以使用`sort`包中的各种函数。
- en: For `int`, `float64` and `string` we can use the corresponding `sort.Ints`,
    `sort.Float64s` and `sort.Strings` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`int`、`float64`和`string`，我们可以使用相应的`sort.Ints`、`sort.Float64s`和`sort.Strings`函数。
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run the code above, this is what we will see.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，这就是我们将看到的。
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is sorted in ascending order. What if we want to sort it in descending
    order? There is no ready-made function to sort in descending order, but we want
    easily use a simple `for` loop to reverse the sorted slice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按升序排序的。如果我们想要按降序排序怎么办？目前没有现成的函数可以按降序排序，但我们可以简单地使用一个 `for` 循环来反转排序后的切片。
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We simply find the middle of the slice, and then using a loop, we exchange the
    elements with their opposite side, starting from that middle. If we run the snippet
    above, this is what you will get.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地找到切片的中间部分，然后使用循环，从中间开始，将元素与它们的对侧交换。如果我们运行上面的片段，你将会得到这样的结果。
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can also use the `sort.Slice` function, passing in our own `less` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `sort.Slice` 函数，传入我们自己的 `less` 函数。
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will product the output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生输出。
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `less` function, which is the second parameter in the `sort.Slice` function,
    takes in 2 parameters `i` and `j`, indices of the consecutive elements of the
    slice. It’s supposed to return true if the element at `i` is less than the element
    at `j` when sorting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 函数是 `sort.Slice` 函数的第二个参数，接受两个参数 `i` 和 `j`，是切片连续元素的索引。它的作用是在排序时，如果 `i`
    处的元素小于 `j` 处的元素则返回 true。'
- en: What if the elements are the same? Using `sort.Slice` means the elements order
    might be reversed from their original order (or remain the same). If you want
    the order to be consistently the same as the original, you can use `sort.SliceStable`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素相同怎么办？使用 `sort.Slice` 意味着元素的顺序可能与它们的原始顺序相反（或保持不变）。如果希望顺序始终与原始顺序一致，可以使用 `sort.SliceStable`。
- en: The `sort.Slice` function works with slices with any types, so this means you
    can also sort custom structs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort.Slice` 函数可以处理任何类型的切片，这意味着你也可以对自定义结构体进行排序。'
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you run the code above you will the output below, with the `people` slice
    sorted according to the ages of the people.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述代码，你将会看到下面的输出，`people` 切片按照人们的年龄排序。
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Another way of sorting structs is by implementing the `sort.Interface`. Let’s
    see how we can do this for the `Person` struct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种排序结构体的方法是实现 `sort.Interface`。让我们看看如何为 `Person` 结构体做这个操作。
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We want to sort a slice of structs, so we need to associate the interface functions
    to the slice, not the struct. We create a type named `ByAge` that is a slice of
    `Person` structs. Next, we associate the `Len`, `Less` and `Swap` functions to
    `ByAge`, making it a struct that implements `sort.Interface`. The `Less` method
    here is the same as the one we used in the `sort.Slice` function above.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要对结构体切片进行排序，所以我们需要将接口函数关联到切片，而不是结构体。我们创建一个名为 `ByAge` 的类型，它是 `Person` 结构体的切片。接下来，我们将
    `Len`、`Less` 和 `Swap` 函数关联到 `ByAge`，使其成为一个实现了 `sort.Interface` 的结构体。这里的 `Less`
    方法与我们在上面 `sort.Slice` 函数中使用的方法相同。
- en: Using this is quite simple. We cast `people` to `ByAge`, and pass that into
    `sort.Sort`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个非常简单。我们将 `people` 强制转换为 `ByAge`，然后将其传入 `sort.Sort`。
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you run the code above, you will see the same results as below.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，你将会看到与下面相同的结果。
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Implementing `sort.Interface` is a bit long-winded, but there are certainly
    some advantages. For one, we can use the `sort.Reverse` to sort by descending
    order.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `sort.Interface` 有点冗长，但显然有一些优势。首先，我们可以使用 `sort.Reverse` 按降序排序。
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This produces the following output.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出。
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can also use the `sort.IsSorted` function to check if the slice is already
    sorted.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `sort.IsSorted` 函数来检查切片是否已经排序。
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The biggest advantage though, is using `sort.Interface` is a lot more performant
    than using `sort.Slice`. Let’s do a simple benchmark.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势在于，使用 `sort.Interface` 比使用 `sort.Slice` 更高效。让我们做一个简单的基准测试。
- en: '[PRE60]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here’s the results of the benchmark.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基准测试的结果。
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, using the `sort.Interface` is more efficient. This is because
    `sort.Slice` uses `interface{}` as the first parameter. This means it takes in
    any structs but is less efficient.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 `sort.Interface` 更有效率。这是因为 `sort.Slice` 使用 `interface{}` 作为第一个参数。这意味着它可以接受任何结构体但效率较低。
- en: 6.6 Creating maps
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 创建地图
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create new maps.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建新的地图。
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `map` keyword to declare it, and then use the `make` function to initialize
    it. Maps must be intialized before use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 关键字声明它，然后使用 `make` 函数进行初始化。在使用之前必须先初始化地图。
- en: Discussion
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To create a map, we can use the `map` keyword.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地图，我们可以使用 `map` 关键字。
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The snippet above declares a map named `people`, that maps a key of type string
    to a value of type int. The `people` map can’t be used yet since its zero-value
    is nil. To use it we need to initialize it with the `make` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的片段声明了一个名为`people`的映射，将一个字符串键映射到一个整数值。目前不能使用`people`映射，因为它的零值是nil。要使用它，我们需要用`make`方法初始化它。
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If it looks silly to you that you have to repeat `map[string]int` in both the
    declaration and initialization, you should look at doing both at the same time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得在声明和初始化中都要重复使用`map[string]int`看起来有些傻，你应该考虑同时做这两件事。
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is will create an empty map. To populate the map you can map a string to
    an int.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个空映射。要填充映射，你可以将一个字符串映射到一个整数。
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can also initialize the map this way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用这种方式初始化映射。
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you print the map out, this is how it will look.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印映射，它将如此显示。
- en: '[PRE67]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 6.7 Accessing maps
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 访问映射
- en: Problem
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access keys and values in a map.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要访问映射中的键和值。
- en: Solution
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the key within square brackets to access the value in a map. You can also
    use a `for …​ range` loop to iterate through map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号内的键来访问映射中的值。你也可以使用`for …​ range`循环来遍历映射。
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Accessing the values given a key is straightforward. Just use the key within
    square brackets to access the values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 访问给定键的值是直截了当的。只需使用方括号内的键来访问值。
- en: '[PRE68]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What if the key doesn’t exist? Nothing happens, Go simply returns the zero-value
    of the value type. In our case the zero value of an integer is 0, so if we do
    this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不存在会怎么样？什么都不会发生，Go会简单地返回值类型的零值。在我们的例子中，整数的零值是0，所以如果我们这样做。
- en: '[PRE69]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It will simply returns a 0\. This might not be what we’re looking for (especially
    if 0 is a valid response) so there is a mechanism to check if the key exists or
    not.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它将简单地返回0。这可能不是我们要找的（特别是如果0是一个有效的响应），因此有一个机制可以检查键是否存在。
- en: '[PRE70]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The *comma, ok* pattern is commonly used in many cases, and can be used here
    to check if the key exists in the map. The use is obvious, if the key exists,
    `ok` becomes true, else if is be false. The `ok` is not a keyword though, you
    can use any variable name, it’s using the multiple value assignment. The value
    is still returned but since you know the key doesn’t exist and it’s just a zero-value,
    you would probably not use it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*逗号, ok*模式在许多情况下都很常见，也可以用来检查映射中是否存在键。使用方式很明显，如果键存在，`ok`就会变成true，否则就是false。尽管`ok`不是关键字，你可以使用任何变量名，它使用了多值赋值。尽管值仍然被返回，但由于你知道键不存在并且它只是一个零值，你可能不会使用它。'
- en: We can also use a `for …​ range` loop to iterate through a map, just like what
    we did with arrays and slices, except instead of getting the index and the element,
    we get the key and the value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`for …​ range`循环来遍历映射，就像我们处理数组和切片时所做的那样，不同之处在于，这里我们获取键和值。
- en: '[PRE71]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Running the code above will give us this output.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的代码将给我们这个输出。
- en: '[PRE72]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you just want the keys, you can just leave out the the second value you get
    from the range.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想要键，你可以省略从range中获取的第二个值。
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You will get this output.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到这个输出。
- en: '[PRE74]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How about if we want just the values? There is no special way of getting just
    the values, you have to use the same mechanism, and put them all in a slice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想要值怎么办？没有特别的方法可以直接获取值，你必须使用相同的机制，并将它们放在一个切片中。
- en: '[PRE75]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will get this output.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到这个输出。
- en: '[PRE76]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 6.8 Modifying maps
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.8 修改映射
- en: Problem
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to modify or remove elements in a map.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要修改或删除映射中的元素。
- en: Solution
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `delete` function to remove key-value pairs from a map. To modify the
    value, just re-assign the value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`delete`函数从映射中删除键值对。要修改值，只需重新赋值。
- en: Discussion
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Modifying a value is simply overriding the existing value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 修改值就是简单地覆盖现有的值。
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The value of `people["Alice"]` will become 23.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`people["Alice"]`的值将变成23。'
- en: To remove a key, Go provides a built-in function named `delete`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除键，Go提供了一个名为`delete`的内置函数。
- en: '[PRE78]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This will be the output.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出结果。
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What happens if you try to delete a key that doesn’t exist? Nothing happens.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试删除一个不存在的键会发生什么？什么都不会发生。
- en: 6.9 Sorting maps
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.9 排序映射
- en: Problem
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want sort a map by its keys.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要按键排序映射。
- en: Solution
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Get the keys of the map in a slice and sort that slice. Then using the sorted
    slice of keys, iterate through map again.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将映射的键获取到一个切片中并对该切片进行排序。然后使用排序后的键切片，再次遍历映射。
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Maps are unordered. This means each time you iterate through a map, the order
    of the key-value pairs might not be the same as the previous time. So how can
    we ensure that it’s the same each time?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是无序的。这意味着每次遍历映射时，键值对的顺序可能与上次不同。那么我们如何确保每次都是相同的顺序呢？
- en: First, we extract the keys out into a slice.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将键提取到一个切片中。
- en: '[PRE80]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Then we sort the keys accordingly. In this case we want to sort by descending
    order.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据需要对键进行排序。在这种情况下，我们要按照降序排序。
- en: '[PRE81]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finally we can access the map by the descending order of the keys.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按键的降序访问映射。
- en: '[PRE82]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When we run the code, we will see this.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，我们将看到这个结果。
- en: '[PRE83]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: About the Author
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者简介
- en: '**Chang Sau Sheong** has been in the software development industry for more
    than 27 years, and has been involved in building software products in many industries
    and using various technologies. He is an active member of the software development
    communities for Java, Ruby previously and now focuses mostly on Go, running meetups
    and giving talks in conferences all around the world. He also runs the GopherCon
    Singapore, one of the largest community-led developer conferences in Southeast
    Asia, and has been doing so since 2017\. Sau Sheong has written 4 programming
    books, 3 in Ruby and the last one in Go.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**张守祥**在软件开发行业已超过27年，并参与了多个行业的软件产品构建，使用了多种技术。他是Java、Ruby社区的活跃成员，现在主要专注于Go语言，在全球各地的会议上组织和发表演讲。他还主办着GopherCon新加坡，这是东南亚最大的社区主导的开发者大会之一，自2017年以来一直如此。张守祥已经写了4本编程书籍，其中3本是关于Ruby，最后一本是关于Go的。'
