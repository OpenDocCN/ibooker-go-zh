- en: 'Chapter 6\. appending issue: Slices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 追加问题：切片
- en: '![image](assets/f0175-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0175-01.png)'
- en: '**We’ve learned we can’t add more elements to an array.** That’s a real problem
    for our program, because we don’t know in advance how many pieces of data our
    file contains. But that’s where Go **slices** come in. Slices are a collection
    type that can grow to hold additional items—just the thing to fix our current
    program! We’ll also see how slices give users an easier way to provide data to
    *all* your programs, and how they can help you write functions that are more convenient
    to call.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们已经学到，无法向数组添加更多元素。** 这对我们的程序来说是个真正的问题，因为我们事先不知道文件中包含多少数据。但这就是 Go **切片**派上用场的地方。切片是一种集合类型，可以动态增加项，正好可以修复我们当前的程序！我们还将看到切片如何为用户提供更简单的方式来提供*所有*程序所需的数据，并且如何帮助您编写更方便调用的函数。'
- en: Slices
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: There actually *is* a Go data structure that we can add more values to—it’s
    called a **slice**. Like arrays, slices are made up of multiple elements, all
    of the same type. *Unlike* arrays, functions are available that allow us to add
    extra elements onto the end of a slice.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上*有*一种 Go 数据结构，我们可以向其中添加更多值，它被称为**切片**。与数组一样，切片由多个相同类型的元素组成。*不同于*数组的是，函数可用于允许我们将额外的元素添加到切片的末尾。
- en: To declare the type for a variable that holds a slice, you use an empty pair
    of square brackets, followed by the type of elements the slice will hold.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个变量，其类型为切片，请使用一对空方括号，后跟切片将容纳的元素类型。
- en: '![image](assets/f0176-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0176-01.png)'
- en: This is just like the syntax for declaring an array variable, except that you
    don’t specify the size.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这与声明数组变量的语法类似，只是不指定大小。
- en: '![image](assets/f0176-02.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0176-02.png)'
- en: Unlike with array variables, declaring a slice variable doesn’t automatically
    create a slice. For that, you can call the built-in `make` function. You pass
    `make` the type of the slice you want to create (which should be the same as the
    type of the variable you’re going to assign it to), and the length of slice it
    should create.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组变量不同，声明切片变量不会自动创建切片。为此，您可以调用内置的`make`函数。将切片的类型（应与要分配给它的变量的类型相同）和应创建的切片长度传递给`make`。
- en: '![image](assets/f0176-03.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0176-03.png)'
- en: Once the slice is created, you assign and retrieve its elements using the same
    syntax you would for an array.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建切片后，使用与数组相同的语法分配和检索其元素。
- en: '![image](assets/f0176-04.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0176-04.png)'
- en: You don’t have to declare the variable and create the slice in separate steps;
    using `make` with a short variable declaration will infer the variable’s type
    for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必分开声明变量并创建切片；使用带有短变量声明的`make`函数将为您推断变量的类型。
- en: '![image](assets/f0176-05.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0176-05.png)'
- en: The built-in `len` function works the same way with slices as it does with arrays.
    Just pass `len` a slice, and its length will be returned as an integer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`len`函数与切片一样使用，就像它与数组一样使用。只需将切片传递给`len`，它的长度将作为整数返回。
- en: '![image](assets/f0177-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0177-01.png)'
- en: 'Both `for` and `for`...`range` loops work just the same with slices as they
    do with arrays, too:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于切片，`for`和`for`...`range`循环的工作方式与数组完全相同：
- en: '![image](assets/f0177-02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0177-02.png)'
- en: Slice literals
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片字面量
- en: Just like with arrays, if you know in advance what values a slice will start
    with, you can initialize the slice with those values using a **slice literal**.
    A slice literal looks a lot like an array literal, but where an array literal
    has the length of the array in square brackets, a slice literal’s square brackets
    are empty. The empty brackets are then followed by the type of elements the slice
    will hold, and a list in curly braces of the initial values each element will
    have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，如果您事先知道切片将从哪些值开始，可以使用切片字面量初始化切片。切片字面量看起来很像数组字面量，但数组字面量在方括号中有数组长度，而切片字面量的方括号是空的。然后，空括号后跟切片将容纳的元素类型，并在大括号中列出每个元素的初始值。
- en: There’s no need to call the `make` function; using a slice literal in your code
    will create the slice *and* prepopulate it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要调用`make`函数；在代码中使用切片字面量将创建切片，并预填充它。
- en: '![image](assets/f0177-03.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0177-03.png)'
- en: These examples are like the previous ones we showed, except that instead of
    assigning values to the slice elements one by one, the entire slice is initialized
    using slice literals.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例与我们之前展示的示例类似，只是不是逐个为切片元素分配值，而是使用切片字面量初始化整个切片。
- en: '![image](assets/f0177-04.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0177-04.png)'
- en: Pool Puzzle
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](assets/f0178-01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0178-01.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从代码池中获取代码片段，并将它们放入空白行中。**不要**重复使用相同的片段，你不需要使用所有的片段。你的**目标**是创建一个能够运行并产生所示输出的程序。
- en: '![image](assets/f0178-02.png)![image](assets/f0178-03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0178-02.png)![图片](assets/f0178-03.png)'
- en: '**Note: each snippet from the pool can only be used once!**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个代码池中的片段只能使用一次！**'
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_Solution_4).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/arrow.png) 答案在[“池谜题解答”](#pool_puzzle_Solution_4)中。'
- en: '![image](assets/f0179-01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0179-01.png)'
- en: '**Because slices are built on top of arrays. You can’t understand how slices
    work without understanding arrays. Here, we’ll show you why...**'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**因为切片是建立在数组之上的。如果不了解数组，就不能理解切片的工作原理。在这里，我们将向你展示为什么……**'
- en: The slice operator
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片操作符
- en: Every slice is built on top of an **underlying array**. It’s the underlying
    array that actually holds the slice’s data; the slice is merely a view into some
    (or all) of the array’s elements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个切片都建立在一个**底层数组**之上。实际上，是底层数组保存了切片的数据；切片只是对数组元素的一种（或全部）视图。
- en: When you use the `make` function or a slice literal to create a slice, the underlying
    array is created for you automatically (and you can’t access it, except through
    the slice). But you can also create the array yourself, and then create a slice
    based on it with the **slice operator**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`make`函数或切片文字创建一个切片时，底层数组会自动为你创建（你无法直接访问它，除非通过切片）。但你也可以自己创建数组，然后基于它使用**切片操作符**创建一个切片。
- en: '![image](assets/f0180-01.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0180-01.png)'
- en: 'The slice operator looks similar to the syntax for accessing an individual
    element or slice of an array, except that it has two indexes: the index of the
    array where the slice should start, and the index of the array that the slice
    should stop before.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符看起来类似于访问数组单个元素或切片的语法，不同之处在于它有两个索引：切片应该从数组的哪个索引开始，以及切片应该在数组的哪个索引之前停止。
- en: '![image](assets/f0180-02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0180-02.png)'
- en: Notice that we emphasize that the second index is the index the slice will stop
    before. That is, the slice should include the elements up to, but *not* including,
    the second index. If you use `underlyingArray[i:j]` as a slice operator, the resulting
    slice will actually contain the elements `underlyingArray[i]` through `underlyingArray[j-1]`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们强调第二个索引是切片将在哪里停止的索引。也就是说，切片应该包括元素直到第二个索引，但*不*包括第二个索引。如果你使用`underlyingArray[i:j]`作为切片操作符，生成的切片实际上将包含元素`underlyingArray[i]`到`underlyingArray[j-1]`。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: (We know, it’s counterintuitive. But a similar notation has been used in the
    Python programming language for over 20 years, and it seems to work OK.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: （我们知道，这有些违反直觉。但类似的表示法在Python编程语言中已经使用了20多年，而且似乎工作得很好。）
- en: '![image](assets/f0180-03.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0180-03.png)'
- en: If you want a slice to include the last element of an underlying array, you
    actually specify a second index that’s one *beyond* the end of the array in your
    slice operator.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望切片包含底层数组的最后一个元素，实际上你需要指定第二个索引，该索引比切片操作符中的数组末尾元素索引多一个。
- en: '![image](assets/f0181-01.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0181-01.png)'
- en: 'Make sure you don’t go any further than that, though, or you’ll get an error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要再往前走，否则会出现错误：
- en: '![image](assets/f0181-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0181-02.png)'
- en: The slice operator has defaults for both the start and stop indexes. If you
    omit the start index, a value of `0` (the first element of the array) will be
    used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符对于起始索引和停止索引都有默认值。如果省略起始索引，将使用`0`（数组的第一个元素）。
- en: '![image](assets/f0181-03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0181-03.png)'
- en: And if you omit the stop index, everything from the start index to the end of
    the underlying array will be included in the resulting slice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了停止索引，那么从起始索引到底层数组末尾的所有内容都会包含在生成的切片中。
- en: '![image](assets/f0181-04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0181-04.png)'
- en: Underlying arrays
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层数组
- en: As we mentioned, a slice doesn’t hold any data itself; it’s merely a view into
    the elements of an underlying array. You can think of a slice as a microscope,
    focusing on a particular portion of the contents of a slide (the underlying array).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，切片本身不保存任何数据；它只是对底层数组元素的一种视图。你可以把切片想象成一种显微镜，聚焦于幻灯片（即底层数组）内容的特定部分。
- en: '![image](assets/f0182-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0182-01.png)'
- en: When you take a slice of an underlying array, you can only “see” the portion
    of the array’s elements that are visible through the slice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您获取底层数组的切片时，您只能“看到”通过切片可见的部分数组元素。
- en: '![image](assets/f0182-02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0182-02.png)'
- en: It’s even possible to have multiple slices point to the same underlying array.
    Each slice will then be a view into its own subset of the array’s elements. The
    slices can even overlap!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可能存在多个切片指向同一个底层数组的情况。每个切片将是对其自己子集中的数组元素的视图。这些切片甚至可以重叠！
- en: '![image](assets/f0182-03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0182-03.png)'
- en: Change the underlying array, change the slice
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改底层数组，更改切片
- en: 'Now, here’s something to be careful about: because a slice is just a view into
    the contents of an array, if you change the underlying array, those changes will
    *also* be visible within the slice!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一些需要注意的事情：因为切片只是对数组内容的一种视图，如果您更改底层数组，这些更改也将在切片中*可见*！
- en: '![image](assets/f0183-01.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0183-01.png)'
- en: Assigning a new value to a slice element will change the corresponding element
    in the underlying array.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个切片元素赋予一个新值将会改变底层数组中对应的元素。
- en: '![image](assets/f0183-02.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0183-02.png)'
- en: If multiple slices point to the same underlying array, a change to the array’s
    elements will be visible in *all* the slices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个切片指向同一个底层数组，对数组元素的更改将在*所有*切片中可见。
- en: '![image](assets/f0183-03.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0183-03.png)'
- en: Because of these potential issues, you may find it’s generally better to create
    slices using `make` or a slice literal, rather than creating an array and using
    a slice operator on it. With `make` and with slice literals, you never have to
    work with the underlying array.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些潜在问题，您可能会发现，通常最好使用`make`或切片文字创建切片，而不是创建一个数组并在其上使用切片操作符。使用`make`和切片文字，您永远不必直接操作底层数组。
- en: Add onto a slice with the “append” function
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“append”函数添加到切片
- en: '![image](assets/f0184-01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0184-01.png)'
- en: Go offers a built-in `append` function that takes a slice, and one or more values
    you want to append to the end of that slice. It returns a new, larger slice with
    all the same elements as the original slice, plus the new elements added onto
    the end.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言提供了一个内置的`append`函数，接受一个切片和一个或多个要追加到该切片末尾的值。它返回一个新的、更大的切片，其中包含与原始切片相同的所有元素，以及添加到末尾的新元素。
- en: '![image](assets/f0184-02.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0184-02.png)'
- en: You don’t have to keep track of what index you want to assign new values to,
    or anything! Just call `append` with your slice and the value(s) you want added
    to the end, and you’ll get a new, longer slice back. It’s really that easy!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需跟踪要分配新值的索引，也无需其他任何操作！只需使用您的切片和要添加到末尾的值(s)，调用`append`，您将得到一个新的、更长的切片。就是这么简单！
- en: Well, with one caution...
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有一个注意事项...
- en: Notice that we’re making sure to assign the return value of `append` back to
    the *same* slice variable we passed to `append`. This is to avoid some potentially
    inconsistent behavior in the slices returned from `append`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们确保将`append`的返回值分配回*相同*的切片变量，我们传递给`append`。这是为了避免从`append`返回的切片中可能出现的一些不一致的行为。
- en: A slice’s underlying array can’t grow in size. If there isn’t room in the array
    to add elements, all its elements will be copied to a new, larger array, and the
    slice will be updated to refer to this new array. But since all this happens behind
    the scenes in the `append` function, there’s no easy way to tell whether the slice
    returned from `append` has the *same* underlying array as the slice you passed
    in, or a *different* underlying array. If you keep both slices, this can lead
    to some unpredictable behavior.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的底层数组大小不能增长。如果数组中没有足够的空间来添加元素，所有元素将被复制到一个新的、更大的数组中，并且切片将被更新以引用这个新数组。但由于所有这些操作都是在`append`函数的背后进行的，因此很难判断从`append`返回的切片是否具有与传入的切片*相同*的底层数组，还是*不同*的底层数组。如果保留了两个切片，这可能导致一些不可预测的行为。
- en: Below, for example, we have four slices, the last three created by calls to
    `append`. Here we are *not* following the convention of assigning `append`’s return
    value back to the same variable. When we assign a value to an element of the `s4`
    slice, we can see the change reflected in `s3`, because `s4` and `s3` happen to
    share the same underlying array. But the change is *not* reflected in `s2` or
    `s1`, because they have a *different* underlying array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面，我们有四个切片，最后三个通过调用`append`创建。这里我们*没有*遵循将`append`的返回值重新分配给同一变量的约定。当我们将值分配给`s4`切片的元素时，可以看到在`s3`中反映出变化，因为`s4`和`s3`恰好共享相同的底层数组。但是这种变化*不*反映在`s2`或`s1`中，因为它们有一个*不同*的底层数组。
- en: '![image](assets/f0185-01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0185-01.png)'
- en: So when calling `append`, it’s conventional to just assign the return value
    back to the same slice variable you passed to `append`. You don’t need to worry
    about whether two slices have the same underlying array if you’re only storing
    one slice!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在调用`append`时，通常只需将返回值分配回传递给`append`的同一切片变量即可。如果只存储一个切片，就不需要担心两个切片是否有相同的底层数组！
- en: '![image](assets/f0185-02.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0185-02.png)'
- en: Slices and zero values
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片和零值
- en: 'As with arrays, if you access a slice element that no value has been assigned
    to, you’ll get the zero value for that type back:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，如果访问尚未分配值的切片元素，您将得到该类型的零值返回：
- en: '![image](assets/f0186-01.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0186-01.png)'
- en: 'Unlike arrays, the slice variable itself *also* has a zero value: it’s `nil`.
    That is, a slice variable that no slice has been assigned to will have a value
    of `nil`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，切片变量本身*也*有一个零值：它是`nil`。也就是说，一个尚未分配切片的切片变量将具有值`nil`。
- en: '![image](assets/f0186-02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0186-02.png)'
- en: 'In other languages, that might require testing whether a variable actually
    contains a slice before attempting to use it. But in Go, functions are intentionally
    written to treat a `nil` slice value as if it were an empty slice. For example,
    the `len` function will return `0` if it’s passed a `nil` slice:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，这可能需要在尝试使用之前测试变量是否实际包含切片。但在Go语言中，函数被有意地编写为将`nil`切片值视为如果它是一个空切片。例如，如果`len`函数被传递一个`nil`切片，它将返回`0`：
- en: '![image](assets/f0186-03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0186-03.png)'
- en: The `append` function also treats `nil` slices like empty slices. If you pass
    an empty slice to `append`, it will add the item you specify to the slice, and
    return a slice with one item. If you pass a `nil` slice to `append`, you’ll *also*
    get a slice with one item back, even though there technically was no slice to
    “append” the item to. The `append` function will create the slice behind the scenes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`函数还将`nil`切片视为空切片。如果将空切片传递给`append`，它将添加你指定的项目到切片，并返回一个包含一个项目的切片。如果将`nil`切片传递给`append`，你*同样*会得到一个包含一个项目的切片，尽管从技术上讲没有切片来“追加”项目。`append`函数会在幕后创建切片。'
- en: '![image](assets/f0186-04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0186-04.png)'
- en: This means you generally don’t have to worry about whether you have an empty
    slice or a `nil` slice. You can treat them both the same, and your code will “just
    work”!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你通常不需要担心你是否有一个空切片或`nil`切片。你可以将它们都视为相同，你的代码会“自动工作”！
- en: '![image](assets/f0186-05.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0186-05.png)'
- en: Reading additional file lines using slices and “append”
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用切片和“append”读取额外的文件行
- en: 'Now that we know about slices and the `append` function, we can finally fix
    our `average` program! Remember, `average` was failing as soon as we added a fourth
    line to the *data.txt* file it reads from:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了切片和`append`函数，终于可以修复我们的`average`程序了！记住，一旦我们在读取*data.txt*文件时添加了第四行：
- en: '![image](assets/f0187-01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0187-01.png)'
- en: 'We traced the problem back to our `datafile` package, which stores the file
    lines in an array that can’t grow beyond three elements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们追溯到了我们的`datafile`包的问题，该包将文件行存储在一个不能超过三个元素的数组中：
- en: '![image](assets/f0187-02.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0187-02.png)'
- en: Most of our work with slices has just centered on understanding them. Now that
    we do, updating the `GetFloats` function to use a slice instead of an array doesn’t
    involve much effort.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大部分与切片的工作都集中在了理解它们上。现在我们理解了，更新`GetFloats`函数以使用切片而不是数组并不需要太多努力。
- en: First, we update the function declaration to return a slice of `float64` values
    instead of an array. Previously, we stored the array in a variable called `numbers`;
    we’ll just use that same variable name to hold the slice. We won’t assign a value
    to `numbers`, so at first it will be `nil`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新函数声明，以返回`float64`值的切片而不是数组。之前，我们将数组存储在名为`numbers`的变量中；现在我们将使用相同的变量名来保存切片。我们不会给`numbers`赋值，所以一开始它将是`nil`。
- en: Instead of assigning values read from the file to a specific array index, we
    can just call `append` to extend the slice (or create a slice, if it’s `nil`)
    and add new values. That means we can get rid of the code to create and update
    the `i` variable that tracks the index. We assign the `float64` value returned
    from `ParseFloat` to a new temporary variable, just to hold it while we check
    for any errors in parsing. Then we pass the `numbers` slice and the new value
    from the file to `append`, making sure to assign the return value back to the
    `numbers` variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不再将文件读取的值分配给特定的数组索引，而是可以调用`append`来扩展切片（如果是`nil`则创建一个切片）并添加新值。这意味着我们可以摆脱创建和更新跟踪索引的`i`变量的代码。我们将从`ParseFloat`返回的`float64`值分配给一个新的临时变量，仅用于在检查解析错误时暂时保存它。然后将`numbers`切片和文件中的新值传递给`append`，确保将返回值重新分配给`numbers`变量。
- en: Aside from that, the code in `GetFloats` can remain the same—the slice is basically
    a drop-in replacement for the array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`GetFloats`中的代码可以保持不变——切片基本上可以无缝替代数组。
- en: '![image](assets/f0188-01.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0188-01.png)'
- en: Trying our improved program
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试我们改进的程序
- en: The slice returned from the `GetFloats` function works like a drop-in replacement
    for an array in our main `average` program, too. In fact, we don’t have to make
    *any* changes to the main program!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GetFloats`函数返回的切片可像主程序中的数组一样直接替换，毫不费力。事实上，我们根本不需要对主程序做*任何*修改！
- en: Because we used a `:=` short variable declaration to assign the `GetFloats`
    return value to a variable, the `numbers` variable automatically switches from
    an inferred type of `[3]float64` (an array) to a type of `[]float64` (a slice).
    And because the `for`...`range` loop and the `len` functions work the same way
    with a slice as they do with an array, no changes are needed to that code, either!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`:=`来将`GetFloats`的返回值赋给一个变量，`numbers`变量自动从推断类型`[3]float64`（数组）切换到类型`[]float64`（切片）。并且因为`for`...`range`循环和`len`函数在处理切片时与处理数组的方式相同，因此对该代码不需要进行任何更改！
- en: '![image](assets/f0189-01.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0189-01.png)'
- en: That means we’re ready to try the changes out! Ensure the *data.txt* file is
    still saved in your Go workspace’s *bin* subdirectory, and then compile and run
    the code using the same commands as before. It will read all the lines of *data.txt*
    and display their average. Then try updating *data.txt* to have more lines, or
    fewer; it will still work regardless!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经准备好尝试这些更改了！确保*data.txt*文件仍然保存在你的Go工作空间的*bin*子目录中，然后使用与之前相同的命令编译和运行代码。它将读取*data.txt*的所有行并显示它们的平均值。然后尝试更新*data.txt*以拥有更多或更少的行；无论如何，它都能正常工作！
- en: '![image](assets/f0189-02.png)![image](assets/f0189-03.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0189-02.png)![图片](assets/f0189-03.png)'
- en: Returning a nil slice in the event of an error
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在出错时返回一个空切片
- en: 'Let’s make one more small improvement to the `GetFloats` function. Currently,
    we’re returning the `numbers` slice even in the event of an error. That means
    that we could be returning a slice with invalid data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`GetFloats`函数做一个小的改进。目前，即使出现错误，我们仍然返回`numbers`切片。这意味着我们可能会返回包含无效数据的切片：
- en: '![image](assets/f0190-01.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0190-01.png)'
- en: The code that calls `GetFloats` *should* check the returned error value, see
    that it’s not `nil`, and ignore the contents of the returned slice. But really,
    why bother to return the slice at all, if the data it contains is invalid? Let’s
    update `GetFloats` to return `nil` instead of a slice in the event of an error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`GetFloats`的代码*应该*检查返回的错误值，看看它是否不是`nil`，并忽略返回切片的内容。但实际上，如果切片包含的数据无效，为什么还要返回切片呢？让我们更新`GetFloats`，在出错时返回`nil`而不是切片。
- en: '![image](assets/f0190-02.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0190-02.png)'
- en: Let’s recompile the program (which will include the updated `datafile` package)
    and run it. It should work the same as before. But now our error-handling code
    is a little bit cleaner.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新编译程序（包括更新后的`datafile`包）并运行它。它应该与以前一样工作。但现在我们的错误处理代码更加清晰了一些。
- en: '![image](assets/f0190-03.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0190-03.png)'
- en: '![image](assets/arrow.png) Answers in [“![image](assets/common1.png) Exercise
    Solution”](#exercise_solutions_10).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在[“![image](assets/common1.png) 练习解答”](#exercise_solutions_10)。'
- en: Command-line arguments
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数
- en: '![image](assets/f0191-02.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0191-02.png)'
- en: '**There is an alternative—users could pass the values to the program as command-line
    arguments.**'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**还有一种方法——用户可以将数值作为命令行参数传递给程序。**'
- en: Just as you can control the behavior of many Go functions by passing them arguments,
    you can pass arguments to many programs you run from the terminal or command prompt.
    This is known as a program’s *command-line interface*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以通过向许多 Go 函数传递参数来控制它们的行为一样，你也可以向从终端或命令提示符运行的许多程序传递参数。这被称为程序的*命令行界面*。
- en: 'You’ve already seen command-line arguments used in this very book. When we
    run the `cd` (“change directory”) command, we pass it the name of the directory
    we want to change to as an argument. When we run the `go` command, we often pass
    it multiple arguments: the subcommand (`run`, `install`, etc.) we want to use,
    and the name of the file or package we want the subcommand to work on.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你已经看到了命令行参数的使用。当我们运行`cd`（“change directory”）命令时，我们将要切换到的目录名作为参数传递给它。当我们运行`go`命令时，我们经常传递多个参数：我们想要使用的子命令（`run`、`install`等）以及我们希望子命令处理的文件或包的名称。
- en: '![image](assets/f0191-03.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0191-03.png)'
- en: Getting command-line arguments from the os.Args slice
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从`os.Args`切片获取命令行参数
- en: Let’s set up a new version of the `average` program, called `average2`, that
    takes the values to average as command-line arguments.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个名为`average2`的新版本的`average`程序，它接受要计算平均值的数值作为命令行参数。
- en: The `os` package has a package variable, `os.Args`, that gets set to a slice
    of strings representing the command-line arguments the currently running program
    was executed with. We’ll start by simply printing the `os.Args` slice to see what
    it contains.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包有一个包变量，`os.Args`，它被设置为一个字符串切片，表示当前运行的程序执行时带有的命令行参数。我们首先将简单地打印出`os.Args`切片，以查看它包含了什么内容。'
- en: Create a new *average2* directory alongside the *average* directory in your
    workspace, and save a *main.go* file within it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工作空间中*average*目录旁边创建一个名为*average2*的新目录，并在其中保存一个*main.go*文件。
- en: '![image](assets/f0192-01.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0192-01.png)'
- en: Then, save the following code in *main.go*. It simply imports the `fmt` and
    `os` packages, and passes the `os.Args` slice to `fmt.Println`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*main.go*中保存以下代码。它简单地导入了`fmt`和`os`包，并将`os.Args`切片传递给`fmt.Println`。
- en: '![image](assets/f0192-02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0192-02.png)'
- en: 'Let’s try it out. From your terminal or command prompt, run this command to
    compile and install the program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。从你的终端或命令提示符中运行以下命令来编译和安装程序：
- en: '`go install github.com/headfirstgo/average2`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`go install github.com/headfirstgo/average2`'
- en: That will install an executable file named *average2* (or *average2.exe* on
    Windows) to your Go workspace’s *bin* subdirectory. Use the `cd` command to change
    to *bin*, and type **average2**, but don’t hit the Enter key just yet. Following
    the program name, type a space, and then type one or more arguments, separated
    by spaces. *Then* hit Enter. The program will run and print the value of `os.Args`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的Go工作空间的*bin*子目录中安装一个名为*average2*（在Windows上为*average2.exe*）的可执行文件。使用`cd`命令切换到*bin*，并输入**average2**，但还不要立即按Enter键。在程序名称后面，输入一个空格，然后输入一个或多个用空格分隔的参数。*然后*按Enter键。程序将运行并打印出`os.Args`的值。
- en: Rerun `average2` with different arguments, and you should see different output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的参数重新运行`average2`，你应该看到不同的输出。
- en: '![image](assets/f0192-03.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0192-03.png)'
- en: The slice operator can be used on other slices
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片操作符可以用在其他切片上
- en: 'This is working pretty well, but there’s one problem: the name of the executable
    is being included as the first element of `os.Args`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行得相当顺利，但有一个问题：可执行文件的名称被包括在`os.Args`的第一个元素中。
- en: '![image](assets/f0193-01.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0193-01.png)'
- en: That should be easy to remove, though. Remember how we used the slice operator
    to get a slice that included everything but the first element of an array?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这应该很容易移除。还记得我们如何使用切片操作符获取一个包含数组除第一个元素以外的所有元素的切片吗？
- en: '![image](assets/f0193-02.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0193-02.png)'
- en: The slice operator can be used on slices just like it can on arrays. If we use
    a slice operator of `[1:]` on `os.Args`, it will give us a new slice that omits
    the first element (whose index is `0`), and includes the second element (index
    `1`) through the end of the slice.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符可以像在数组上一样在切片上使用。如果我们在`os.Args`上使用切片操作符`[1:]`，它将给我们一个新的切片，省略了第一个元素（索引为`0`），并包括第二个元素（索引`1`）到切片的末尾。
- en: '![image](assets/f0193-03.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0193-03.png)'
- en: If we recompile and rerun `average2`, this time we’ll see that the output includes
    only the actual command-line arguments.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新编译并重新运行`average2`，这次我们将看到输出只包括实际的命令行参数。
- en: '![image](assets/f0193-04.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0193-04.png)'
- en: Updating our program to use command-line arguments
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的程序以使用命令行参数
- en: Now that we’re able to get the command-line arguments as a slice of strings,
    let’s update the `average2` program to convert the arguments to actual numbers,
    and calculate their average. We’ll mostly be able to reuse the concepts we learned
    about in our original `average` program and the `datafile` package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够将命令行参数作为字符串切片获取，让我们更新`average2`程序将参数转换为实际数字，并计算它们的平均值。我们将大部分概念重用到我们原始的`average`程序和`datafile`包中学到的概念。
- en: We use the slice operator on `os.Args` to omit the program name, and assign
    the resulting slice to an `arguments` variable. We set up a `sum` variable that
    will hold the total of all the numbers we’re given. Then we use a `for`...`range`
    loop to process the elements of the `arguments` slice (using the `_` blank identifier
    to ignore the element index). We use `strconv.ParseFloat` to convert the argument
    string to a `float64`. If we get an error, we log it and exit, but otherwise we
    add the current number to `sum`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`os.Args`上使用切片操作符来省略程序名称，并将结果切片赋给一个`arguments`变量。我们设置一个`sum`变量，它将保存我们得到的所有数字的总和。然后我们使用`for`...`range`循环来处理`arguments`切片的元素（使用`_`空白标识符来忽略元素索引）。我们使用`strconv.ParseFloat`将参数字符串转换为`float64`。如果出现错误，我们记录并退出，否则我们将当前数字添加到`sum`中。
- en: When we’ve looped through all the arguments, we use `len(arguments)` to determine
    how many data samples we’re averaging. We then divide `sum` by this sample count
    to get the average.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们循环遍历所有参数时，我们使用`len(arguments)`来确定我们要计算平均值的数据样本数量。然后我们将`sum`除以这个样本计数以获得平均值。
- en: '![image](assets/f0194-01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0194-01.png)'
- en: With these changes saved, we can recompile and rerun the program. It will take
    the numbers you provide as arguments and average them. Give as few or as many
    arguments as you like; it will still work!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改后，我们可以重新编译并重新运行程序。它将接受您提供的数字作为参数并计算它们的平均值。无论您提供多少参数，它都能正常工作！
- en: '![image](assets/f0194-02.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0194-02.png)'
- en: Variadic functions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: 'Now that we know about slices, we can cover a feature of Go that we haven’t
    talked about so far. Have you noticed that some function calls can take as few,
    or as many, arguments as needed? Look at `fmt.Println` or `append`, for example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了切片，我们可以介绍一下迄今为止我们还没有讨论过的 Go 特性。你是否注意到一些函数调用可以接受所需数量的参数？例如看看`fmt.Println`或`append`：
- en: '![image](assets/f0195-01.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0195-01.png)'
- en: Don’t try doing this with just any function, though! With all the functions
    we’ve defined so far, there had to be an *exact* match between the number of parameters
    in the function definition and the number of arguments in the function call. Any
    difference would result in a compile error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，不要尝试对任何函数都这样做！到目前为止，我们定义的所有函数，在函数定义中的参数数量和函数调用中的参数数量之间必须有*精确*匹配。任何差异都会导致编译错误。
- en: '![image](assets/f0195-02.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0195-02.png)'
- en: So how do `Println` and `append` do it? They’re declared as variadic functions.
    A **variadic function** is one that can be called with a *varying* number of arguments.
    To make a function variadic, use an ellipsis (`...`) before the type of the last
    (or only) function parameter in the function declaration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`Println`和`append`是如何做到的呢？它们被声明为可变参数函数。**可变参数函数**是可以使用*不同数量*的参数调用的函数。要使函数可变参数，可以在函数声明中的最后（或唯一）函数参数的类型之前使用省略号（`...`）。
- en: '![image](assets/f0195-03.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0195-03.png)'
- en: The last parameter of a variadic function receives the variadic arguments as
    a slice, which the function can then process like any other slice.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数的最后一个参数接收可变参数作为一个切片，函数可以像处理任何其他切片一样处理它们。
- en: 'Here’s a variadic version of the `twoInts` function, and it works just fine
    with any number of arguments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`twoInts`函数的可变参数版本，它可以很好地处理任意数量的参数：
- en: '![image](assets/f0196-01.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0196-01.png)'
- en: Here’s a similar function that works with strings. Notice that if we provide
    no variadic arguments, it’s not an error; the function just receives an empty
    slice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类似的函数，适用于字符串。请注意，如果我们没有提供变参参数，这并不是错误；函数会接收到一个空切片。
- en: '![image](assets/f0196-02.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0196-02.png)'
- en: A function can take one or more nonvariadic arguments as well. Although a function
    caller can omit variadic arguments (resulting in an empty slice), nonvariadic
    arguments are always required; it’s a compile error to omit those. Only the *last*
    parameter in a function definition can be variadic; you can’t place it in front
    of required parameters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受一个或多个非变参参数。虽然函数调用者可以省略变参参数（导致空切片），但非变参参数总是必需的；省略它们会导致编译错误。只有在函数定义中的*最后*一个参数可以是变参；你不能把它放在必需参数的前面。
- en: '![image](assets/f0196-03.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0196-03.png)'
- en: Using variadic functions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变参函数
- en: Here’s a `maximum` function that takes any number of `float64` arguments and
    returns the greatest value out of all of them. The arguments to `maximum` are
    stored in a slice in the `numbers` parameter. To start, we set the current maximum
    value to `-Inf`, a special value representing negative infinity, obtained by calling
    `math.Inf`. (We could start with a current maximum of `0`, but this way `maximum`
    will work with negative numbers.) Then we use `for`...`range` to process each
    argument in the `numbers` slice, comparing it to the current maximum, and setting
    it as the new maximum if it’s greater. Whatever maximum remains after processing
    all the arguments is the one we return.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`maximum`函数，它接受任意数量的`float64`参数，并返回其中最大的值。`maximum`的参数存储在`numbers`参数的切片中。首先，我们将当前最大值设置为`-Inf`，这是一个特殊值，表示负无穷大，通过调用`math.Inf`获得。（我们也可以从当前最大值`0`开始，但这样`maximum`将能处理负数。）然后，我们使用`for`...`range`处理`numbers`切片中的每个参数，将其与当前最大值进行比较，并在其大于当前最大值时将其设置为新的最大值。处理完所有参数后，剩余的最大值即为我们要返回的值。
- en: '![image](assets/f0197-01.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0197-01.png)'
- en: Here’s an `inRange` function that takes a minimum value, a maximum value, and
    any number of additional `float64` arguments. It will discard any argument that
    is below the given minimum or above the given maximum, returning a slice containing
    only the arguments that were in the specified range.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`inRange`函数，它接受最小值、最大值和任意数量的额外`float64`参数。它会丢弃低于给定最小值或高于给定最大值的任何参数，返回仅包含在指定范围内的参数的切片。
- en: '![image](assets/f0197-02.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0197-02.png)'
- en: Code Magnets
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/f0198-01.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0198-01.png)'
- en: A Go program that defines and uses a variadic function is scrambled up on the
    fridge. Can you reconstruct the code snippets to make a working program that will
    produce the given output?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序定义并使用变参函数时会被打乱。你能重构代码片段以构建一个能够生成指定输出的工作程序吗？
- en: '![image](assets/f0198-02.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0198-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_4).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/arrow.png) 答案在 [“代码磁铁解决方案”](#code_magnets_solution_4) 中。'
- en: Using a variadic function to calculate averages
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变参函数计算平均数
- en: Let’s create a variadic `average` function that can take any number of `float64`
    arguments and return their average. It will look much like the logic from our
    `average2` program. We’ll set up a `sum` variable to hold the total of the argument
    values. Then we’ll loop through the range of arguments, adding each one to the
    value in `sum`. Finally, we’ll divide `sum` by the number of arguments (converted
    to a `float64`) to get the average. The result is a function that can average
    as many (or as few) numbers as we want.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个变参的`average`函数，它可以接受任意数量的`float64`参数并返回它们的平均值。它的逻辑类似于我们的`average2`程序。我们将设置一个`sum`变量来保存参数值的总和。然后，我们将循环遍历参数的范围，将每个参数添加到`sum`中。最后，我们将`sum`除以参数数量（转换为`float64`）以获得平均值。结果是一个可以计算任意数量（或少量）数字平均值的函数。
- en: '![image](assets/f0198-03.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0198-03.png)'
- en: Passing slices to variadic functions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将切片传递给变参函数
- en: Our new `average` variadic function works so well, we should try updating our
    `average2` program to make use of it. We can paste the `average` function into
    our `average2` code as is.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`average`变参函数效果非常好，我们应该尝试更新我们的`average2`程序以利用它。我们可以将`average`函数原样粘贴到我们的`average2`代码中。
- en: In the `main` function, we’re still going to need to convert each of the command-line
    arguments from a `string` to a `float64` value. We’ll create a slice to hold the
    resulting values, and store it in a variable named `numbers`. After each command-line
    argument is converted, instead of using it to calculate the average directly,
    we’ll just append it to the `numbers` slice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们仍然需要将每个命令行参数从`string`转换为`float64`值。我们将创建一个切片来保存结果值，并将其存储在名为`numbers`的变量中。在每个命令行参数被转换后，我们不再直接用它来计算平均值，而是将其追加到`numbers`切片中。
- en: We then *attempt* to pass the `numbers` slice to the `average` function. But
    when we go to compile the program, that results in an error...
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后*尝试*将`numbers`切片传递给`average`函数。但当我们尝试编译程序时，结果出现错误……
- en: '![image](assets/f0199-01.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0199-01.png)'
- en: The `average` function is expecting one or more `float64` arguments, not a *slice*
    of `float64` values...
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`average`函数期望一个或多个`float64`参数，而不是一组`float64`值的*切片*……'
- en: So what now? Are we forced to choose between making our functions variadic and
    being able to pass slices to them?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在怎么办？我们是被迫在使函数可变参数和能够将切片传递给它们之间做出选择吗？
- en: Fortunately, Go provides special syntax for this situation. When calling a variadic
    function, simply add an ellipsis (`...`) following the slice you want to use in
    place of variadic arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go语言为这种情况提供了特殊的语法。在调用可变参数函数时，只需在要替代可变参数的切片后面添加省略号（`...`）即可。
- en: '![image](assets/f0200-01.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0200-01.png)'
- en: So all we need to do is add an ellipsis following the `numbers` slice in our
    call to `average`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只需要在调用`average`时，在`numbers`切片后面添加省略号即可。
- en: '![image](assets/f0200-02.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0200-02.png)'
- en: With that change made, we should be able to compile and run our program again.
    It will convert our command-line arguments to a slice of `float64` values, then
    pass that slice to the variadic `average` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们应该能够重新编译并运行我们的程序。它将把我们的命令行参数转换为一个`float64`值的切片，然后将该切片传递给可变参数`average`函数。
- en: '![image](assets/f0200-03.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0200-03.png)'
- en: Slices have saved the day!
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片拯救了我们！
- en: '![image](assets/f0201-01.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0201-01.png)'
- en: Working with lists of values is essential for any programming language. With
    arrays and slices, you can keep your data in collections of whatever size you
    need. And with features like `for`...`range` loops, Go makes it easy to process
    the data in those collections, too!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何编程语言来说，处理值列表是至关重要的。通过数组和切片，您可以将数据保留在任何所需大小的集合中。而且，通过像`for`...`range`循环这样的特性，Go语言还可以轻松处理这些集合中的数据！
- en: Your Go Toolbox
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Go工具箱
- en: '![image](assets/f0202-01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0202-01.png)'
- en: '**That’s it for [Chapter 6](#appending_issuecolon_slices)! You’ve added slices
    to your toolbox.**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是关于[第6章](#appending_issuecolon_slices)的全部内容！您已经将切片添加到了您的工具箱中。**'
- en: '![image](assets/f0202-02.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0202-02.png)'
- en: Pool Puzzle Solution
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pool Puzzle Solution
- en: '![image](assets/f0203-01.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0203-01.png)'
- en: Code Magnets Solution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Code Magnets Solution
- en: '![image](assets/f0204-01.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0204-01.png)'
