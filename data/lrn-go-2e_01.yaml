- en: Chapter 1\. Setting Up Your Go Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 设置你的Go开发环境
- en: Every programming language needs a development environment, and Go is no exception.
    If you’ve already built a Go program or two, then you have a working environment,
    but you might have missed out on some of the newer techniques and tools. If this
    is your first time setting up Go on your computer, don’t worry; it’s easy to install
    Go and its supporting tools. After setting up the environment and verifying it,
    you will build a simple program, learn about the different ways to build and run
    Go code, and then explore some tools and techniques that make Go development easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都需要一个开发环境，Go也不例外。如果你已经构建了一两个Go程序，那么你有一个工作的环境，但你可能错过了一些更新的技术和工具。如果这是你第一次在计算机上设置Go，不用担心；安装Go及其支持工具非常简单。设置环境并验证后，你将构建一个简单的程序，了解不同构建和运行Go代码的方式，然后探索一些使Go开发更轻松的工具和技术。
- en: Installing the Go Tools
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Go工具
- en: To build Go code, you need to download and install the Go development tools.
    You can find the latest version of the tools at the downloads page on the [Go
    website](https://go.dev/dl). Choose the download for your platform and install
    it. The *.pkg* installer for Mac and the *.msi* installer for Windows automatically
    install Go in the correct location, remove any old installations, and put the
    Go binary in the default executable path.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建Go代码，你需要下载并安装Go开发工具。你可以在[Go官网下载页面](https://go.dev/dl)找到最新版本的工具。选择适合你平台的下载并安装。Mac使用*.pkg*安装程序，Windows使用*.msi*安装程序会自动将Go安装到正确的位置，移除旧版本安装，并将Go二进制文件放在默认的可执行路径中。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you are a Mac developer, you can install Go using [Homebrew](https://brew.sh)
    with the command `brew install go`. Windows developers who use [Chocolatey](https://chocolatey.org)
    can install Go with the command `choco install golang`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Mac开发者，可以使用[Homebrew](https://brew.sh)命令`brew install go`安装Go。使用[Chocolatey](https://chocolatey.org)的Windows开发者可以使用命令`choco
    install golang`安装Go。
- en: 'The various Linux and BSD installers are gzipped TAR files and expand to a
    directory named *go*. Copy this directory to */usr/local* and add */usr/local/go/bin*
    to your `$PATH` so that the `go` command is accessible:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 各种Linux和BSD安装程序都是gzip压缩的TAR文件，会解压缩为一个名为*go*的目录。将此目录复制到*/usr/local*并将*/usr/local/go/bin*添加到你的`$PATH`，以便`go`命令可用：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You might need root permissions to write to */usr/local*. If the `tar` command
    fails, rerun it with `sudo tar -C /usr/local -xzf go1.20.5.linux-amd64.tar.gz`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要root权限才能写入*/usr/local*。如果`tar`命令失败，请使用`sudo tar -C /usr/local -xzf go1.20.5.linux-amd64.tar.gz`重新运行。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Go programs compile to a single native binary and do not require any additional
    software to be installed in order to run them. This is in contrast to languages
    like Java, Python, and JavaScript, which require you to install a virtual machine
    to run your program. Using a single native binary makes it a lot easier to distribute
    programs written in Go. This book doesn’t cover containers, but developers who
    use Docker or Kubernetes can often package a Go app inside a scratch or distroless
    image. You can find details in Geert Baeke’s blog post [“Distroless or Scratch
    for Go Apps”](https://oreil.ly/W0VUB).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序编译为单个本地二进制文件，不需要安装其他软件即可运行它们。这与需要安装虚拟机来运行程序的Java、Python和JavaScript等语言形成对比。使用单个本地二进制文件使得Go程序的分发变得更加容易。本书不涵盖容器技术，但使用Docker或Kubernetes的开发者通常可以将Go应用程序打包在scratch或distroless镜像中。你可以在Geert
    Baeke的博客文章["Distroless or Scratch for Go Apps"](https://oreil.ly/W0VUB)中找到详细信息。
- en: 'You can validate that your environment is set up correctly by opening up a
    terminal or command prompt and typing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开终端或命令提示符并输入以下命令来验证你的环境是否设置正确：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If everything is set up correctly, you should see something like this printed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，你应该看到类似以下内容的输出：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This tells you that this is Go version 1.20.5 on macOS. (Darwin is the operating
    system at the heart of macOS, and arm64 is the name for the 64-bit chips based
    on ARM’s designs.) On x64 Linux, you would see:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你这是在macOS上的Go版本1.20.5。（Darwin是macOS核心的操作系统，arm64是基于ARM设计的64位芯片的名称。）在x64 Linux上，你会看到：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Troubleshooting Your Go Installation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决Go安装问题
- en: If you get an error instead of the version message, it’s likely that you don’t
    have `go` in your executable path, or you have another program named `go` in your
    path. On macOS and other Unix-like systems, use `which go` to see the `go` command
    being executed, if any. If nothing is returned, you need to fix your executable
    path.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到错误而不是版本消息，则可能是你的可执行路径中没有`go`，或者你的路径中有另一个名为`go`的程序。在macOS和其他类Unix系统上，使用`which
    go`命令查看是否执行了`go`命令，如果没有返回任何内容，则需要修复你的可执行路径。
- en: If you’re on Linux or BSD, it’s possible you installed the 64-bit Go development
    tools on a 32-bit system or the development tools for the wrong chip architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Linux或BSD系统，在32位系统上安装了64位Go开发工具，或者安装了错误芯片架构的开发工具，这是有可能的。
- en: Go Tooling
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go工具
- en: 'All of the Go development tools are accessed via the `go` command. In addition
    to `go version`, there’s a compiler (`go build`), code formatter (`go fmt`), dependency
    manager (`go mod`), test runner (`go test`), a tool that scans for common coding
    mistakes (`go vet`), and more. They are covered in detail in Chapters [10](ch10.html#unique_chapter_id_10),
    [11](ch11.html#unique_chapter_id_11), and [15](ch15.html#unique_chapter_id_15).
    For now, let’s take a quick look at the most commonly used tools by writing everyone’s
    favorite first application: “Hello, World!"”'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Go开发工具都通过`go`命令访问。除了`go version`之外，还有编译器(`go build`)、代码格式化器(`go fmt`)、依赖管理器(`go
    mod`)、测试运行器(`go test`)、扫描常见编码错误的工具(`go vet`)等。它们在第[10](ch10.html#unique_chapter_id_10)、[11](ch11.html#unique_chapter_id_11)和[15](ch15.html#unique_chapter_id_15)章节详细讨论。现在，让我们通过编写大家最喜欢的第一个应用程序“Hello,
    World!"”来快速看看最常用的工具。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since the introduction of Go in 2009, several changes have occurred in the way
    Go developers organize their code and their dependencies. Because of this churn,
    there’s lots of conflicting advice, and most of it is obsolete (for example, you
    can safely ignore discussions about `GOROOT` and `GOPATH`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自2009年Go发布以来，Go开发者在组织代码和处理依赖方面发生了几次变化。因此，有许多互相矛盾的建议，大多数已经过时（例如，你可以安全地忽略关于`GOROOT`和`GOPATH`的讨论）。
- en: 'For modern Go development, the rule is simple: you are free to organize your
    projects as you see fit and store them anywhere you want.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代的Go开发，规则很简单：你可以按自己的意愿组织项目并将其存储在任何地方。
- en: Your First Go Program
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Go程序
- en: Let’s go over the basics of writing a Go program. Along the way, you will see
    the parts that make up a simple Go program. You might not understand everything
    just yet, and that’s OK; that’s what the rest of the book is for!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来学习编写Go程序的基础知识。在此过程中，你会看到构成简单Go程序的各个部分。你可能暂时不会理解所有内容，没关系，书中的其余部分会帮你理解！
- en: Making a Go Module
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作一个Go模块
- en: 'The first thing you need to do is create a directory to hold your program.
    Call it *ch1*. On the command line, enter the new directory. If your computer’s
    terminal uses bash or zsh, this looks like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是创建一个目录来容纳你的程序。将其命名为*ch1*。在命令行中，进入这个新目录。如果你的计算机终端使用bash或zsh，看起来会像这样：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the directory, run the `go mod init` command to mark this directory
    as a Go module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录内部，运行`go mod init`命令将这个目录标记为Go模块：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will learn more about what a module is in [Chapter 10](ch10.html#unique_chapter_id_10),
    but for now, all you need to know is that a Go project is called a *module*. A
    module is not just source code. It is also an exact specification of the dependencies
    of the code within the module. Every module has a *go.mod* file in its root directory.
    Running `go mod init` creates this file for you. The contents of a basic *go.mod*
    file look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第[Chapter 10](ch10.html#unique_chapter_id_10)学到更多关于模块的内容，但现在你只需要知道，一个Go项目被称为*module*（模块）。一个模块不仅仅是源代码，它还是该模块内代码依赖的精确规范。每个模块在其根目录下都有一个*go.mod*文件。运行`go
    mod init`会为你创建这个文件。一个基本的*go.mod*文件内容如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *go.mod* file declares the name of the module, the minimum supported version
    of Go for the module, and any other modules that your module depends on. You can
    think of it as being similar to the *requirements.txt* file used by Python or
    the *Gemfile* used by Ruby.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.mod*文件声明了模块的名称、模块支持的最低Go版本，以及任何其他依赖于该模块的模块。你可以将它视为类似于Python使用的*requirements.txt*文件或Ruby使用的*Gemfile*文件。'
- en: You shouldn’t edit the *go.mod* file directly. Instead, use the `go get` and
    `go mod tidy` commands to manage changes to the file. Again, all things related
    to modules are covered in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应直接编辑*go.mod*文件。相反，请使用`go get`和`go mod tidy`命令来管理对文件的更改。再次强调，与模块相关的所有内容都在[第10章](ch10.html#unique_chapter_id_10)中讨论。
- en: go build
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go build
- en: 'Now let’s write some code! Open up a text editor, enter the following text,
    and save it inside *ch1* with the filename *hello.go*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们写些代码！打开文本编辑器，输入以下文本，并将其保存在*ch1*文件夹内，文件名为*hello.go*：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '(Yes, the indentation in this code example looks sloppy: I meant to do that!
    You will see why in just a bit.)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，这个代码示例中的缩进看起来很杂乱：我故意这样做的！你很快就会明白为什么。）
- en: Let’s quickly go over the parts of the Go file you created. The first line is
    a package declaration. Within a Go module, code is organized into one or more
    packages. The `main` package in a Go module contains the code that starts a Go
    program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下您创建的Go文件的各部分。第一行是包声明。在Go模块中，代码被组织为一个或多个包。Go模块中的`main`包包含启动Go程序的代码。
- en: Next there is an import declaration. The `import` statement lists the packages
    referenced in this file. You’re using a function in the `fmt` (usually pronounced
    “fumpt”) package from the standard library, so you list the package here. Unlike
    other languages, Go imports only whole packages. You can’t limit the import to
    specific types, functions, constants, or variables within a package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个导入声明。`import`语句列出了此文件中引用的包。您在这里使用了标准库中`fmt`（通常发音为“fumpt”）包中的函数。与其他语言不同，Go只导入整个包。您不能将导入限制为包内的特定类型、函数、常量或变量。
- en: All Go programs start from the `main` function in the `main` package. You declare
    this function with `func main()` and a left brace. Like Java, JavaScript, and
    C, Go uses braces to mark the start and end of code blocks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Go程序都从`main`包中的`main`函数开始。您可以使用`func main()`和左括号来声明这个函数。与Java、JavaScript和C类似，Go使用大括号来标记代码块的开始和结束。
- en: The body of the function consists of a single line. It says that you are calling
    the `Println` function in the `fmt` package with the argument `"Hello, world!"`.
    As an experienced developer, you can likely guess what this function call does.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的主体由一行组成。它表示您正在调用`fmt`包中的`Println`函数，并传递参数`"Hello, world!"`。作为经验丰富的开发者，您可能已经猜到这个函数调用的作用。
- en: 'After the file is saved, go back to your terminal or command prompt and type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件保存后，返回到您的终端或命令提示符，并键入：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates an executable called `hello_world` (or *hello_world.exe* on Windows)
    in the current directory. Run it and you will unsurprisingly see `Hello, world!`
    printed on the screen:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hello_world`的可执行文件（在Windows上为*hello_world.exe*），保存在当前目录中。运行它，你会惊讶地看到屏幕上打印出`Hello,
    world!`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The name of the binary matches the name in the module declaration. If you want
    a different name for your application, or if you want to store it in a different
    location, use the `-o` flag. For example, if you wanted to compile the code to
    a binary called “hello,” you would use the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件的名称与模块声明中的名称相匹配。如果您希望应用程序有不同的名称，或者希望将其存储在不同的位置，请使用`-o`标志。例如，如果您想将代码编译为名为“hello”的二进制文件，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [“Using go run to Try Out Small Programs”](ch11.html#go_run), I will cover
    another way to execute a Go program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“使用`go run`来尝试运行小程序”](ch11.html#go_run)中，我将介绍执行Go程序的另一种方式。
- en: go fmt
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go fmt
- en: One of the chief design goals for Go was to create a language that allowed you
    to write code efficiently. This meant having simple syntax and a fast compiler.
    It also led Go’s authors to reconsider code formatting. Most languages allow a
    great deal of flexibility in the way code is formatted. Go does not. Enforcing
    a standard format makes it a great deal easier to write tools that manipulate
    source code. This simplifies the compiler and allows the creation of some clever
    tools for generating code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的主要设计目标之一是创建一种能够高效编写代码的语言。这意味着具有简单的语法和快速的编译器。这也导致Go语言的作者重新考虑了代码格式化的问题。大多数语言允许以多种方式格式化代码。但Go语言不允许这样做。强制执行标准格式使得编写操作源代码的工具变得更加容易。这简化了编译器，并允许创建一些聪明的用于生成代码的工具。
- en: There is a secondary benefit as well. Developers have historically wasted extraordinary
    amounts of time on format wars. Since Go defines a standard way of formatting
    code, Go developers avoid arguments over [brace style](https://oreil.ly/dAsbS)
    and [tabs versus spaces](https://oreil.ly/dSkol). For example, Go programs use
    tabs to indent, and it is a syntax error if the opening brace is not on the same
    line as the declaration or command that begins the block.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个次要的好处。开发人员历来在格式争论上浪费了大量时间。由于 Go 定义了一种标准的代码格式化方式，Go 开发者避免了关于[大括号风格](https://oreil.ly/dAsbS)和[制表符还是空格](https://oreil.ly/dSkol)的争论。例如，Go
    程序使用制表符缩进，如果开括号不与声明或开始块的命令在同一行，会导致语法错误。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Many Go developers think the Go team defined a standard format as a way to avoid
    developer arguments and discovered the tooling advantages later. However, [Russ
    Cox, the development lead for Go, has publicly stated](https://oreil.ly/rZEUv)
    that better tooling was his original motivation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Go 开发者认为，Go 团队定义标准格式是为了避免开发者争论，并后来发现了工具化的优势。然而，[Go 的开发主导人 Russ Cox 公开表示](https://oreil.ly/rZEUv)
    更好的工具化是他最初的动机。
- en: 'The Go development tools include a command, `go fmt`, which automatically fixes
    the whitespace in your code to match the standard format. However, it can’t fix
    braces on the wrong line. Run it with the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Go 开发工具包含一个命令，`go fmt`，它可以自动修复代码中的空白以匹配标准格式。但它无法修复放置在错误行的大括号。运行以下命令：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using `./...` tells a Go tool to apply the command to all the files in the current
    directory and all subdirectories. You will see it again as you learn about more
    Go tools.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `./...` 告诉 Go 工具将命令应用于当前目录及其所有子目录中的所有文件。当你了解更多 Go 工具时，你会再次遇到它。
- en: If you open up *hello.go*, you’ll see that the line with `fmt.Println` is now
    properly indented with a single tab.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 *hello.go*，你会看到包含 `fmt.Println` 的行现在使用单个制表符正确缩进了。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to run `go fmt` before you compile your code, and, at the very least,
    before you commit source code changes to your repository! If you forget, make
    a separate commit that does *only* **`go fmt ./...`** so you don’t hide logic
    changes in an avalanche of formatting changes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在编译代码之前运行 `go fmt`，并且至少在提交源代码更改到仓库之前！如果忘记了，请进行单独的提交，只包含 **`go fmt ./...`**，这样你就不会把逻辑变更混入格式更改的大雪崩中。
- en: go vet
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go vet
- en: 'In one class of bugs, the code is syntactically valid but quite likely incorrect.
    The `go` tool includes a command called `go vet` to detect these kinds of errors.
    Add one to the program and watch it get detected. Change the `fmt.Println` line
    in *hello.go* to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类别的 bug 中，代码在语法上是有效的，但很可能是不正确的。`go` 工具包括一个称为 `go vet` 的命令来检测这些类型的错误。向程序添加一个并观察它被检测到。将
    *hello.go* 中的 `fmt.Println` 行修改为以下内容：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`fmt.Printf` is similar to `printf` in C, Java, Ruby, and many other languages.
    If you haven’t seen `fmt.Printf` before, it is a function with a template for
    its first parameter, and values for the placeholders in the template in the remaining
    parameters.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf` 类似于 C、Java、Ruby 和许多其他语言中的 `printf`。如果你以前没有见过 `fmt.Printf`，它是一个函数，其第一个参数是模板，其余参数是模板中占位符的值。'
- en: 'In this example, you have a template (`"Hello, %s!\n"`) with a `%s` placeholder,
    but no value was specified for the placeholder. This code will compile and run,
    but it’s not correct. One of the things that `go vet` detects is whether a value
    exists for every placeholder in a formatting template. Run `go vet` on the modified
    code, and it finds an error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你有一个模板（`"Hello, %s!\n"`），其中包含 `%s` 占位符，但没有为占位符指定值。这段代码可以编译和运行，但是不正确。`go
    vet` 的其中一个检测项目是检查格式化模板中每个占位符是否有值。在修改后的代码上运行 `go vet`，它会发现一个错误：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that `go vet` found the bug, you can easily fix it. Change line 6 in *hello.go*
    to:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `go vet` 发现了这个 bug，你可以轻松修复它。将 *hello.go* 中的第 6 行修改为：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While `go vet` catches several common programming errors, there are things that
    it cannot detect. Luckily, third-party Go code-quality tools can close the gap.
    Some of the most popular code-quality tools are covered in [“Using Code-Quality
    Scanners”](ch11.html#code_quality).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `go vet` 可以捕获几种常见的编程错误，但它无法检测一些问题。幸运的是，第三方的 Go 代码质量工具可以填补这个空白。一些最受欢迎的代码质量工具在
    [“使用代码质量扫描器”](ch11.html#code_quality) 中有介绍。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Just as you should run `go fmt` to make sure your code is formatted properly,
    run `go vet` to scan for possible bugs in valid code. These commands are just
    the first step in ensuring that your code is of high quality. In addition to the
    advice in this book, all Go developers should read through [Effective Go](https://oreil.ly/GBRut)
    and the [Code Review Comments page on Go’s wiki](https://oreil.ly/FHi_h) to understand
    what idiomatic Go code looks like.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您应该运行`go fmt`来确保代码格式正确一样，运行`go vet`来扫描有效代码中可能存在的错误。这些命令只是确保代码高质量的第一步。除了本书的建议外，所有
    Go 开发者都应该阅读["Effective Go"](https://oreil.ly/GBRut)和[Go 代码审查评论页面](https://oreil.ly/FHi_h)，以了解符合习惯用法的
    Go 代码是什么样子的。
- en: Choose Your Tools
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择您的工具
- en: While you wrote a small Go program using nothing more than a text editor and
    the `go` command, you’ll probably want more advanced tools when working on larger
    projects. Go IDEs provide many advantages over text editors, including automatic
    formatting on save, code completion, type checking, error reporting, and integrated
    debugging. Excellent [Go development tools](https://oreil.ly/cav8N) are available
    for most text editors and IDEs. If you don’t already have a favorite tool, two
    of the most popular Go development environments are Visual Studio Code and GoLand.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以仅使用文本编辑器和`go`命令编写小型 Go 程序，但在处理更大项目时，您可能需要更高级的工具。与文本编辑器相比，Go IDE 提供了许多优势，包括保存时自动格式化、代码完成、类型检查、错误报告和集成调试。大多数文本编辑器和
    IDE 都提供了出色的[Go 开发工具](https://oreil.ly/cav8N)。如果您还没有喜欢的工具，两个最受欢迎的 Go 开发环境是 Visual
    Studio Code 和 GoLand。
- en: Visual Studio Code
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: If you are looking for a free development environment, [Visual Studio Code](https://oreil.ly/zktT8)
    from Microsoft is your best option. Since it was released in 2015, VS Code has
    become the most popular source code editor for developers. It does not ship with
    Go support, but you can make it a Go development environment by downloading the
    Go extension from the extensions gallery.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找一个免费的开发环境，[Microsoft 的 Visual Studio Code](https://oreil.ly/zktT8) 是您的最佳选择。自
    2015 年发布以来，VS Code 已成为开发者最受欢迎的源代码编辑器。它不包含 Go 支持，但您可以通过从扩展库下载 Go 扩展来将其打造成 Go 开发环境。
- en: VS Code’s Go support relies on third-party extensions that are accessed via
    its built-in Marketplace. This includes the Go Development tools, the [Delve debugger](https://oreil.ly/sosLu),
    and [gopls](https://oreil.ly/TLapT), a Go language server developed by the Go
    team. While you need to install the Go compiler yourself, the Go extension will
    install Delve and gopls for you.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 的 Go 支持依赖于通过其内置市场访问的第三方扩展。这包括 Go 开发工具、[Delve 调试器](https://oreil.ly/sosLu)，以及[由
    Go 团队开发的 gopls](https://oreil.ly/TLapT)，一个 Go 语言服务器。虽然您需要自行安装 Go 编译器，但 Go 扩展会为您安装
    Delve 和 gopls。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: What is a language server? It’s a standard specification for an API that enables
    editors to implement intelligent editing behavior, like code completion, quality
    checks, or finding all the places a variable or function is used in your code.
    You can learn more about language servers and their capabilities by checking out
    the [Language Server Protocol website](https://oreil.ly/2T2fw).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是语言服务器？它是一个标准规范，用于启用编辑器实现智能编辑行为，如代码完成、质量检查或查找变量或函数在代码中使用的所有位置。您可以通过访问[语言服务器协议网站](https://oreil.ly/2T2fw)了解更多关于语言服务器及其能力的信息。
- en: Once your tools are set up, you can open your project and work with it. [Figure 1-1](#visual_studio_code)
    shows you what your project window should look like. [“Getting Started with VS
    Code Go”](https://oreil.ly/XhoeB) is a walkthrough that demonstrates the VS Code
    Go extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好工具后，您可以打开项目并开始使用它。[图 1-1](#visual_studio_code)展示了项目窗口的样子。["使用 VS Code 进行
    Go 编程入门"](https://oreil.ly/XhoeB)是一个教程，演示了 VS Code 的 Go 扩展。
- en: '![VS Code](assets/lgo2_0101.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![VS Code](assets/lgo2_0101.png)'
- en: Figure 1-1\. Visual Studio Code
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. Visual Studio Code
- en: GoLand
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GoLand
- en: '[GoLand](https://oreil.ly/6cXjL) is the Go-specific IDE from JetBrains. While
    JetBrains is best known for Java-centric tools, GoLand is an excellent Go development
    environment. As you can see in [Figure 1-2](#goland), GoLand’s user interface
    looks similar to IntelliJ, PyCharm, RubyMine, WebStorm, Android Studio, or any
    of the other JetBrains IDEs. Its Go support includes refactoring, syntax highlighting,
    code completion and navigation, documentation pop-ups, a debugger, code coverage,
    and more. In addition to Go support, GoLand includes JavaScript/HTML/CSS and SQL
    database tools. Unlike VS Code, GoLand doesn’t require you to install a plug-in
    to get it to work.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[GoLand](https://oreil.ly/6cXjL) 是 JetBrains 推出的 Go 专用 IDE。尽管 JetBrains 以 Java
    为中心的工具而闻名，GoLand 是一个出色的 Go 开发环境。正如你在 [图 1-2](#goland) 中所见，GoLand 的用户界面类似于 IntelliJ、PyCharm、RubyMine、WebStorm、Android
    Studio 或其他 JetBrains 的 IDE。其支持包括重构、语法高亮、代码补全和导航、文档弹出、调试器、代码覆盖等。除了 Go 支持外，GoLand
    还包括 JavaScript/HTML/CSS 和 SQL 数据库工具。不像 VS Code 需要你安装插件才能使用。'
- en: '![GoLand Window](assets/lgo2_0102.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![GoLand 窗口](assets/lgo2_0102.png)'
- en: Figure 1-2\. GoLand
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. GoLand
- en: If you have already subscribed to IntelliJ Ultimate, you can add Go support
    via a plug-in. While GoLand is commercial software, JetBrains has a [Free License
    Program](https://oreil.ly/48gEF) for students and core open source contributors.
    If you don’t qualify for a free license, a 30-day free trial is available. After
    that, you have to pay for GoLand.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经订阅了 IntelliJ Ultimate，可以通过插件添加 Go 支持。虽然 GoLand 是商业软件，JetBrains 为学生和核心开源贡献者提供
    [免费许可计划](https://oreil.ly/48gEF)。如果你不符合免费许可的条件，可以使用 30 天的免费试用。之后，你需要付费购买 GoLand。
- en: The Go Playground
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The Go Playground
- en: There’s one more important tool for Go development, but this is one that you
    don’t install. Visit [The Go Playground](http://go.dev/play) and you’ll see a
    window that resembles [Figure 1-3](#the_go_playground). If you have used a command-line
    environment like `irb`, `node`, or `python`, you’ll find The Go Playground has
    a similar feel. It gives you a place to try out and share small programs. Enter
    your program into the window and click the Run button to execute the code. The
    Format button runs `go fmt` on your program and updates your imports. The Share
    button creates a unique URL that you can send to someone else to take a look at
    your program or to come back to your code at a future date (the URLs have proven
    to be persistent for a long time, but I wouldn’t rely on the playground as your
    source code repository).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的 Go 开发工具，但这并不是你需要安装的。访问 [The Go Playground](http://go.dev/play) ，你会看到一个类似于
    [图 1-3](#the_go_playground) 的窗口。如果你曾使用过 `irb`、`node` 或 `python` 这样的命令行环境，你会发现
    The Go Playground 的感觉很类似。它为你提供一个地方来尝试和分享小程序。将你的程序输入窗口并点击运行按钮来执行代码。点击格式化按钮会运行 `go
    fmt` 并更新你的导入。点击分享按钮会创建一个独特的 URL，你可以将其发送给他人查看你的程序，或在未来的某个日期返回你的代码（这些 URL 已被证明长期有效，但我不建议将
    Playground 作为你的源代码仓库）。
- en: '![Go Playground](assets/lgo2_0103.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Go Playground](assets/lgo2_0103.png)'
- en: Figure 1-3\. The Go Playground
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. The Go Playground
- en: As you can see in [Figure 1-4](#the_go_playground_supports_multiple_files),
    you can simulate multiple files by separating each file with a line that looks
    like `-- filename.go --`. You can even create simulated subdirectories by including
    a `/` in the filename, such as `-- subdir/my_code.go --` .
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [图 1-4](#the_go_playground_supports_multiple_files) 中看到的，你可以通过像 `-- filename.go
    --` 这样的行来模拟多个文件。你甚至可以通过在文件名中包含 `/`，如 `-- subdir/my_code.go --`，来创建模拟的子目录。
- en: Be aware that The Go Playground is on someone else’s computer (in particular,
    Google’s computer), so you don’t have completely free rein. It gives you a choice
    of a few versions of Go (usually the current release, the previous release, and
    the latest development version). You can make network connections only to `localhost`,
    and processes that run for too long or use too much memory are stopped. If your
    program depends on time, you need to take into account that the clock is set to
    November 10, 2009, 23:00:00 UTC (the date of the initial announcement of Go).
    Even with these limitations, The Go Playground is a useful way to try out new
    ideas without creating a new project locally. Throughout this book, you’ll find
    links to The Go Playground so you can run code examples without copying them onto
    your computer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go Playground 是在别人的计算机上（特别是 Google 的计算机），所以你没有完全自由。它为您提供了几个版本的 Go（通常是当前版本、上一个版本和最新的开发版本）。您只能连接到
    `localhost`，并且长时间运行或使用过多内存的进程会被停止。如果您的程序依赖于时间，请考虑时钟设置为 2009 年 11 月 10 日 23:00:00
    UTC（Go 初始公告的日期）。即使存在这些限制，Go Playground 也是一个有用的方式，可以在不在本地创建新项目的情况下尝试新想法。在本书的整个过程中，您将找到指向
    Go Playground 的链接，以便您可以运行代码示例而无需将它们复制到您的计算机上。
- en: Warning
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do not put sensitive information (such as personally identifiable information,
    passwords, or private keys) into your playground! If you click the Share button,
    the information is saved on Google’s servers and is accessible to anyone who has
    the associated Share URL. If you do this by accident, contact Google at *security@golang.org*
    with the URL and the reason the content needs to be removed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将敏感信息（例如个人身份信息、密码或私钥）放入您的 Playground 中！如果单击“共享”按钮，信息将保存在 Google 的服务器上，并可通过相关的共享
    URL 访问。如果不小心这样做，请联系 Google 的 *security@golang.org* 并提供 URL 及删除内容的原因。
- en: '![Go Playground Multiple Files](assets/lgo2_0104.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Go Playground 多文件](assets/lgo2_0104.png)'
- en: Figure 1-4\. The Go Playground supports multiple files
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. Go Playground 支持多文件
- en: Makefiles
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile
- en: An IDE is nice to use, but it’s hard to automate. Modern software development
    relies on repeatable, automatable builds that can be run by anyone, anywhere,
    at any time. Requiring this kind of tooling is good software engineering practice.
    It avoids the age-old situation where a developer absolves themselves of any build
    problems with a shrug and the statement, “It works on my machine!” The way to
    do this is to use some kind of script to specify your build steps. Go developers
    have adopted `make` as their solution. It lets developers specify a set of operations
    that are necessary to build a program and the order in which the steps must be
    performed. You may not be familiar with `make`, but it’s been used to build programs
    on Unix systems since 1976.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDE 很方便，但很难自动化。现代软件开发依赖于可重复、可自动化的构建，可以由任何人、任何地方、任何时候运行。需要这种工具的做法是良好的软件工程实践。它避免了开发人员用耸肩和声明“在我的机器上可以运行！”来摆脱任何构建问题的情况。做到这一点的方法是使用某种脚本来指定构建步骤。Go
    开发者已经采用 `make` 作为他们的解决方案。它允许开发者指定构建程序所需的一组操作以及执行步骤的顺序。您可能不熟悉 `make`，但它自 1976 年以来就被用来构建
    Unix 系统上的程序。
- en: 'Create a file called *Makefile* in the *ch1* directory with the following contents:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ch1* 目录中创建名为*Makefile*的文件，并包含以下内容：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even if you haven’t seen a Makefile before, figuring out what’s going on is
    not too difficult. Each possible operation is called a *target*. The `.DEFAULT_GOAL`
    defines which target is run when no target is specified. In this case, the default
    is the `build` target. Next you have the target definitions. The word before the
    colon (`:`) is the name of the target. Any words after the target (like `vet`
    in the line `build: vet`) are the other targets that must be run before the specified
    target runs. The tasks that are performed by the target are on the indented lines
    after the target. The `.PHONY` line keeps `make` from getting confused if a directory
    or file in your project has the same name as one of the listed targets.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '即使你以前没有见过 Makefile，弄清楚其中的情况也不是太困难。每个可能的操作被称为*目标*。`.DEFAULT_GOAL` 定义了在没有指定目标时运行的目标。在本例中，默认是`build`目标。接下来是目标的定义。冒号（`:`）前的单词是目标的名称。目标后面的任何单词（例如在`build:
    vet`行中的`vet`）是在指定目标运行之前必须运行的其他目标。目标执行的任务位于目标后的缩进行中。`.PHONY` 行防止 `make` 在项目中的目录或文件与列出的目标之一同名时混淆。'
- en: 'Run `make` and you should see the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `make`，您应该看到以下输出：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Entering a single command formats the code correctly, checks it for nonobvious
    errors, and compiles it. You can also vet the code with `make vet`, or just run
    the formatter with `make fmt`. This might not seem like a big improvement, but
    ensuring that formatting and vetting always happen before a developer (or a script
    running on a continuous integration build server) triggers a build means you won’t
    miss any steps.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入单个命令可以正确格式化代码，检查非明显错误并编译它。你也可以用`make vet`来审核代码，或者只是运行格式化器`make fmt`。这可能看起来不是很大的改进，但确保在触发构建之前总是进行格式化和审核，无论是开发人员还是运行在持续集成构建服务器上的脚本，都意味着你不会错过任何步骤。
- en: One drawback to Makefiles is that they are exceedingly picky. You *must* indent
    the steps in a target with a tab. They are also not supported out-of-the-box on
    Windows. If you are doing your Go development on a Windows computer, you need
    to install `make` first. The easiest way to do so is to first install a package
    manager like [Chocolatey](https://chocolatey.org) and then use it to install `make`
    (for Chocolatey, the command is `choco install make`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile的一个缺点是它们非常挑剔。在目标中，你*必须*用制表符缩进步骤。它们也不会默认支持Windows。如果你在Windows计算机上进行Go开发，你需要先安装`make`。最简单的方法是先安装像[Chocolatey](https://chocolatey.org)这样的包管理器，然后使用它来安装`make`（对于Chocolatey，命令是`choco
    install make`）。
- en: If you want to learn more about writing Makefiles, there’s a good [tutorial
    by Chase Lambert](https://oreil.ly/Vytcj), but it does use a tiny bit of C to
    explain the concepts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于编写Makefile的内容，Chase Lambert有一篇很好的[教程](https://oreil.ly/Vytcj)，但它确实使用了少量的C来解释这些概念。
- en: You can find the code from this chapter in the [Chapter 1 repository](https://oreil.ly/eOfkK)
    for this book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的[第1章代码库](https://oreil.ly/eOfkK)中找到本章的代码。
- en: The Go Compatibility Promise
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go兼容性承诺
- en: 'As with all programming languages, the Go development tools are periodically
    updated. Since Go 1.2, a new release has occurred roughly every six months. Patch
    releases with bug and security fixes are also released as needed. Given the rapid
    development cycles and the Go team’s commitment to backward compatibility, Go
    releases tend to be incremental rather than expansive. The [Go Compatibility Promise](https://oreil.ly/p_NMY)
    is a detailed description of how the Go team plans to avoid breaking Go code.
    It says that there won’t be backward-breaking changes to the language or the standard
    library for any Go version that starts with 1, unless the change is required for
    a bug or security fix. In his GopherCon 2022 keynote talk [“Compatibility: How
    Go Programs Keep Working”](https://oreil.ly/Ohkr7), Russ Cox discusses all the
    ways that the Go Team works to keep Go code from breaking. He says, “I believe
    that prioritizing compatibility was the most important design decision that we
    made in Go 1.”'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有编程语言一样，Go开发工具定期更新。自Go 1.2以来，大约每六个月发布一次新版本。还会根据需要发布包含错误修复和安全修复的补丁版本。考虑到快速的开发周期和Go团队对向后兼容性的承诺，Go的发布往往是增量的而非扩展的。[Go兼容性承诺](https://oreil.ly/p_NMY)详细描述了Go团队计划如何避免破坏Go代码。它表明，除非为了修复错误或安全漏洞，否则不会对以1开头的任何Go版本进行向后兼容性变更。在他的GopherCon
    2022主题演讲[“兼容性：如何保持Go程序的正常运行”](https://oreil.ly/Ohkr7)中，Russ Cox讨论了Go团队确保Go代码不破坏的所有方法。他说：“我认为，优先考虑兼容性是我们在Go
    1中做出的最重要的设计决策。”
- en: This guarantee doesn’t apply to the `go` commands. There have been backward-incompatible
    changes to the flags and functionality of the `go` commands, and it’s entirely
    possible that it will happen again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这一保证不适用于`go`命令。`go`命令的标志和功能发生了不兼容的更改，这种情况很可能会再次发生。
- en: Staying Up-to-Date
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持更新
- en: Go programs compile to a standalone native binary, so you don’t need to worry
    that updating your development environment could cause your currently deployed
    programs to fail. You can have programs compiled with different versions of Go
    running simultaneously on the same computer or virtual machine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序编译为独立的本地二进制文件，因此你不必担心更新开发环境会导致当前部署的程序失败。你可以在同一台计算机或虚拟机上同时运行使用不同Go版本编译的程序。
- en: When you are ready to update the Go development tools installed on your computer,
    Mac and Windows users have the easiest path. Those who installed with `brew` or
    `chocolatey` can use those tools to update. Those who used the installers on [*https://golang.org/dl*](https://golang.org/dl)
    can download the latest installer, which removes the old version when it installs
    the new one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备更新计算机上安装的 Go 开发工具时，Mac 和 Windows 用户有最简单的路径。那些使用 `brew` 或 `chocolatey` 安装的用户可以使用这些工具进行更新。那些使用[*https://golang.org/dl*](https://golang.org/dl)上的安装程序的用户可以下载最新的安装程序，在安装新版本时删除旧版本。
- en: 'Linux and BSD users need to download the latest version, move the old version
    to a backup directory, unpack the new version, and then delete the old version:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 BSD 用户需要下载最新版本，将旧版本移动到备份目录，解压新版本，然后删除旧版本：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, you don’t need to move the existing installation to a new location;
    you could just delete it and install the new version. However, this falls in the
    “better safe than sorry” category. If something goes wrong while installing the
    new version, it’s good to have the previous one around.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，您无需将现有安装移动到新位置；您可以直接删除它并安装新版本。但是，这属于“安全第一”的范畴。如果在安装新版本时出现问题，保留之前的版本是很有好处的。
- en: Exercises
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Each chapter has exercises at the end to let you try out the ideas that I cover.
    You can find answers to these exercises in the [Chapter 1 repository](https://oreil.ly/c-oc3).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每章末尾都有练习，让您可以尝试我介绍的想法。您可以在[第1章代码库](https://oreil.ly/c-oc3)中找到这些练习的答案。
- en: Take the “Hello, world!” program and run it on The Go Playground. Share a link
    to the code in the playground with a coworker who would love to learn about Go.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取“Hello, world!” 程序并在 Go Playground 上运行它。与希望学习有关 Go 的同事分享代码在 playground 上的链接。
- en: Add a target to the Makefile called `clean` that removes the `hello_world` binary
    and any other temporary files created by `go build`. Take a look at the [Go command
    documentation](https://oreil.ly/uqsMy) to find a `go` command to help implement
    this.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Makefile 中添加一个名为 `clean` 的目标，用于删除 `hello_world` 二进制文件和 `go build` 创建的任何其他临时文件。查看[Go
    命令文档](https://oreil.ly/uqsMy)，找到帮助实现此功能的 `go` 命令。
- en: Experiment with modifying the formatting in the “Hello, world!” program. Add
    blank lines, spaces, change indentation, insert newlines. After making a modification,
    run `go fmt` to see if the formatting change is undone. Also, run `go build` to
    see if the code still compiles. You can also add additional `fmt.Println` calls
    so you can see what happens if you put blank lines in the middle of a function.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试修改“Hello, world!” 程序中的格式。添加空行、空格，更改缩进，插入新行。在做出修改后，运行 `go fmt` 查看格式化是否被撤销。此外，运行
    `go build` 查看代码是否仍然可以编译。您还可以在函数中间添加额外的 `fmt.Println` 调用，以查看会发生什么。
- en: Wrapping Up
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to install and configure your Go development
    environment. You also learned about tools for building Go programs and ensuring
    code quality. Now that your environment is ready, you’re on to the next chapter,
    where you’ll explore the built-in types in Go and how to declare variables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何安装和配置您的 Go 开发环境。您还了解了构建 Go 程序和确保代码质量的工具。现在您的环境已准备就绪，接下来将进入下一章，在那里您将探索
    Go 中的内置类型以及如何声明变量。
