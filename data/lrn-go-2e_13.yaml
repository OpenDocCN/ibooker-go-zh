- en: Chapter 13\. The Standard Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。标准库
- en: One of the best parts of developing with Go is being able to take advantage
    of its standard library. Like Python, it has a “batteries included” philosophy,
    providing many of the tools that you need to build an application. Since Go is
    a relatively new language, it ships with a library that is focused on problems
    faced in modern programming environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go开发的最大优势之一是能够利用其标准库。像Python一样，Go也有“电池包含”的哲学，提供了构建应用程序所需的许多工具。由于Go是一种相对较新的语言，它附带了一个专注于现代编程环境中遇到的问题的库。
- en: I can’t cover all the standard library packages, and luckily, I don’t have to,
    as there are many excellent sources of information on the standard library, starting
    with the [documentation](https://oreil.ly/g970a). Instead, I’ll focus on several
    of the most important packages and how their design and use demonstrate the principles
    of idiomatic Go. Some packages (`errors`, `sync`, `context`, `testing`, `reflect`,
    and `unsafe`) are covered in their own chapters. In this chapter, you’ll look
    at Go’s built-in support for I/O, time, JSON, and HTTP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法覆盖所有标准库包，幸运的是，我也不需要，因为有许多优秀的信息源涵盖了标准库，从[文档](https://oreil.ly/g970a)开始。相反，我将重点放在几个最重要的包上，以及它们的设计和使用如何展示Go的成语风格的原则。一些包（`errors`，`sync`，`context`，`testing`，`reflect`和`unsafe`）在它们自己的章节中进行了介绍。在这一章中，你将看到Go对I/O、时间、JSON和HTTP的内置支持。
- en: io and Friends
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io及其伙伴们
- en: 'For a program to be useful, it needs to read in and write out data. The heart
    of Go’s input/output philosophy can be found in the `io` package. In particular,
    two interfaces defined in this package are probably the second and third most-used
    interfaces in Go: `io.Reader` and `io.Writer`.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要使程序有用，它需要读取和写入数据。Go的输入/输出哲学的核心可以在`io`包中找到。特别是在该包中定义的两个接口可能是Go中使用第二和第三最多的接口：`io.Reader`和`io.Writer`。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: What’s number one? That’d be `error`, which you already looked at in [Chapter 9](ch09.html#unique_chapter_id_09).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一名是什么？那将是`error`，你已经在[第9章](ch09.html#unique_chapter_id_09)中看过了。
- en: 'Both `io.Reader` and `io.Writer` define a single method:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`和`io.Writer`都定义了一个单一方法：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Write` method on the `io.Writer` interface takes in a slice of bytes,
    which are written to the interface implementation. It returns the number of bytes
    written and an error if something went wrong. The `Read` method on `io.Reader`
    is more interesting. Rather than return data through a return parameter, a slice
    is passed into the implementation and modified. Up to `len(p)` bytes will be written
    into the slice. The method returns the number of bytes written. This might seem
    a little strange. You might expect this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`接口上的`Write`方法接受一个字节切片，将其写入接口实现。它返回写入的字节数以及如果出现错误则返回错误。`io.Reader`上的`Read`方法更有趣。与通过返回参数返回数据不同，一个切片被传递到实现中并进行修改。最多会写入`len(p)`字节到切片中。该方法返回写入的字节数。这可能看起来有点奇怪。你可能期望这样：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There’s a very good reason `io.Reader` is defined the way it is. Let’s write
    a function that’s representative of how to work with an `io.Reader` to illustrate:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`被定义为它的样子有一个非常好的原因。让我们编写一个代表如何使用`io.Reader`的函数来说明：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are three things to note. First, you create your buffer once and reuse
    it on every call to `r.Read`. This allows you to use a single memory allocation
    to read from a potentially large data source. If the `Read` method were written
    to return a `[]byte`, it would require a new allocation on every single call.
    Each allocation would end up on the heap, which would make quite a lot of work
    for the garbage collector.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有三件事需要注意。首先，你只需创建一次缓冲区，并在每次调用`r.Read`时重复使用它。这允许你使用单个内存分配从可能很大的数据源中读取。如果`Read`方法被编写为返回一个`[]byte`，则每次调用都需要一个新的分配。每个分配都将最终在堆上，这将为垃圾收集器造成相当多的工作。
- en: If you want to reduce the allocations further, you could create a pool of buffers
    when the program launches. You would then take a buffer out of the pool when the
    function starts, and return it when it ends. By passing in a slice to `io.Reader`,
    memory allocation is under the control of the developer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步减少分配，可以在程序启动时创建一个缓冲池。然后，在函数开始时从池中取出一个缓冲区，在函数结束时归还它。通过将一个切片传递给`io.Reader`，内存分配就在开发者的控制之下。
- en: Second, you use the `n` value returned from `r.Read` to know how many bytes
    were written to the buffer and iterate over a subslice of your `buf` slice, processing
    the data that was read.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，你使用从`r.Read`返回的`n`值来知道写入缓冲区的字节数，并迭代处理被读取的`buf`切片的子切片数据。
- en: Finally, you know that you’re done reading from `r` when the error returned
    from `r.Read` is `io.EOF`. This error is a bit odd, in that it isn’t really an
    error. It indicates that there’s nothing left to read from the `io.Reader`. When
    `io.EOF` is returned, you are finished processing and return your result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当从`r.Read`返回的错误是`io.EOF`时，你知道已经完成从`r`的读取。这种错误有点奇怪，因为它并不是真正的错误。它表示从`io.Reader`中没有剩余可读取的内容。当返回`io.EOF`时，你完成处理并返回你的结果。
- en: The `Read` method in `io.Reader` has one unusual aspect. In most cases when
    a function or method has an error return value, you check the error before you
    try to process the nonerror return values. You do the opposite for `Read` because
    bytes might have been copied into the buffer before an error was triggered by
    the end of the data stream or by an unexpected condition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`中的`Read`方法有一个不寻常的方面。在大多数情况下，当函数或方法有一个错误返回值时，你在处理非错误返回值之前会先检查错误。但是对于`Read`来说，你要做相反的操作，因为字节可能已经被复制到缓冲区中，然后才会因数据流结束或意外条件而触发错误。'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you get to the end of an `io.Reader` unexpectedly, a different sentinel error
    is returned (`io.ErrUnexpectedEOF`). Note that it starts with the string `Err`
    to indicate that it is an unexpected state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意外地到达了`io.Reader`的末尾，会返回不同的哨兵错误(`io.ErrUnexpectedEOF`)。请注意，它以`Err`开头，表示这是一个意外的状态。
- en: 'Because `io.Reader` and `io.Writer` are such simple interfaces, they can be
    implemented many ways. You can create an `io.Reader` from a string by using the
    `strings.NewReader` function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`io.Reader`和`io.Writer`是如此简单的接口，它们可以有很多种实现方式。你可以使用`strings.NewReader`函数从字符串创建一个`io.Reader`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As I discussed in [“Interfaces Are Type-Safe Duck Typing”](ch07.html#interface_duck_typing),
    implementations of `io.Reader` and `io.Writer` are often chained together in a
    decorator pattern. Because `countLetters` depends on an `io.Reader`, you can use
    the exact same `countLetters` function to count English letters in a gzip-compressed
    file. First you write a function that, when given a filename, returns a `*gzip.Reader`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“接口是类型安全的鸭子类型”](ch07.html#interface_duck_typing)中讨论的那样，`io.Reader`和`io.Writer`的实现通常在装饰器模式中链接在一起。因为`countLetters`依赖于`io.Reader`，你可以使用完全相同的`countLetters`函数来计算gzip压缩文件中的英文字母数。首先，编写一个函数，给定文件名后返回一个`*gzip.Reader`：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function demonstrates the way to properly wrap types that implement `io.Reader`.
    You create an `*os.File` (which meets the `io.Reader` interface), and after making
    sure it’s valid, you pass it to the `gzip.NewReader` function, which returns a
    `*gzip.Reader` instance. If it is valid, you return the `*gzip.Reader` and a closure
    that properly cleans up your resources when it is invoked.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数演示了正确包装实现`io.Reader`的类型的方法。你创建一个`*os.File`（符合`io.Reader`接口），在确保它有效后，将其传递给`gzip.NewReader`函数，该函数返回一个`*gzip.Reader`实例。如果有效，返回`*gzip.Reader`和一个闭包，当调用时会适当地清理你的资源。
- en: 'Since `*gzip.Reader` implements `io.Reader`, you can use it with `countLetters`
    just as you used the `*strings.Reader` previously:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`*gzip.Reader`实现了`io.Reader`，所以你可以像之前使用`*strings.Reader`一样使用它来与`countLetters`配合使用：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can find the code for `countLetters` and `buildGZipReader` in the *sample_code/io_friends*
    directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第13章存储库](https://oreil.ly/XOPbD)的*sample_code/io_friends*目录中找到`countLetters`和`buildGZipReader`的代码。
- en: 'Because there are standard interfaces for reading and writing, there’s a standard
    function in the `io` package for copying from an `io.Reader` to an `io.Writer`,
    `io.Copy`. There are other standard functions for adding new functionality to
    existing `io.Reader` and `io.Writer` instances. These include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有用于读取和写入的标准接口，`io`包中有一个用于从`io.Reader`复制到`io.Writer`的标准函数，`io.Copy`。还有其他标准函数用于为现有的`io.Reader`和`io.Writer`实例添加新功能。其中包括以下内容：
- en: '`io.MultiReader`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.MultiReader`'
- en: Returns an `io.Reader` that reads from multiple `io.Reader` instances, one after
    another
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从多个`io.Reader`实例依次读取的`io.Reader`。
- en: '`io.LimitReader`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.LimitReader`'
- en: Returns an `io.Reader` that reads only up to a specified number of bytes from
    the supplied `io.Reader`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从提供的`io.Reader`读取指定字节数的`io.Reader`。
- en: '`io.MultiWriter`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.MultiWriter`'
- en: Returns an `io.Writer` that writes to multiple `io.Writer` instances at the
    same time
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个 `io.Writer`，可以同时向多个 `io.Writer` 实例写入数据。
- en: Other packages in the standard library provide their own types and functions
    to work with `io.Reader` and `io.Writer`. You’ve seen a few of them already, but
    there are many more. These cover compression algorithms, archives, cryptography,
    buffers, byte slices, and strings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的其他包提供了它们自己的类型和函数来处理 `io.Reader` 和 `io.Writer`。你已经看到了其中的一些，但还有更多。这些包括压缩算法、存档、加密、缓冲区、字节切片和字符串。
- en: 'Other one-method interfaces are defined in `io`, such as `io.Closer` and `io.Seeker`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 包中还定义了其他单方法接口，例如 `io.Closer` 和 `io.Seeker`：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `io.Closer` interface is implemented by types like `os.File` that need
    to do cleanup when reading or writing is complete. Usually, `Close` is called
    via a `defer`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Closer` 接口由像 `os.File` 这样的类型实现，它们在读取或写入完成后需要进行清理。通常情况下，通过 `defer` 调用 `Close`：'
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Warning
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you are opening the resource in a loop, do not use `defer`, as it will not
    run until the function exits. Instead, you should call `Close` before the end
    of the loop iteration. If there are errors that can lead to an exit, you must
    call `Close` there too.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环中打开资源，请不要使用 `defer`，因为它不会在函数退出之前运行。相反，应在循环迭代结束前调用 `Close`。如果存在可能导致退出的错误，则也必须在那里调用
    `Close`。
- en: The `io.Seeker` interface is used for random access to a resource. The valid
    values for `whence` are the constants `io.SeekStart`, `io.SeekCurrent`, and `io.SeekEnd`.
    This should have been made clearer by using a custom type, but in a surprising
    design oversight, `whence` is of type `int`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Seeker` 接口用于对资源进行随机访问。`whence` 的有效值为常量 `io.SeekStart`、`io.SeekCurrent`
    和 `io.SeekEnd`。如果使用自定义类型来明确此点会更好，但出人意料的设计疏忽，`whence` 的类型却是 `int`。'
- en: The `io` package defines interfaces that combine these four interfaces in various
    ways. They include `io.ReadCloser`, `io.ReadSeeker`, `io.ReadWriteCloser`, `io.ReadWriteSeeker`,
    `io.ReadWriter`, `io.WriteCloser`, and `io.WriteSeeker`. Use these interfaces
    to specify what your functions expect to do with the data. For example, rather
    than just using an `os.File` as a parameter, use the interfaces to specify exactly
    what your function will do with the parameter. Not only does it make your functions
    more general-purpose, it also makes your intent clearer. Furthermore, make your
    code compatible with these interfaces if you are writing your own data sources
    and sinks. In general, strive to create interfaces as simple and decoupled as
    the interfaces defined in `io`. They demonstrate the power of simple abstractions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 包定义了几种方式将这四种接口组合起来的接口。它们包括 `io.ReadCloser`、`io.ReadSeeker`、`io.ReadWriteCloser`、`io.ReadWriteSeeker`、`io.ReadWriter`、`io.WriteCloser`
    和 `io.WriteSeeker`。使用这些接口来指定你的函数将如何处理数据。例如，不要只将 `os.File` 作为参数传递，而是使用接口精确地指定你的函数将如何处理参数。这不仅使得你的函数更具通用性，也使你的意图更加清晰。此外，如果你正在编写自己的数据源和接收器，应使你的代码兼容这些接口。总的来说，应力求创建与
    `io` 包定义的接口一样简单和解耦的接口。它们展示了简单抽象的力量。'
- en: 'In addition to the interfaces in the `io` package, there are several helper
    functions for common operations. For example, the `io.ReadAll` function reads
    all the data from an `io.Reader` into a byte slice. One of the more clever functions
    in `io` demonstrates a pattern for adding a method to a Go type. If you have a
    type that implements `io.Reader` but not `io.Closer` (such as `strings.Reader`)
    and need to pass it to a function that expects an `io.ReadCloser`, pass your `io.Reader`
    into `io.NopCloser` and get back a type that implements `io.ReadCloser`. If you
    look at the implementation, it’s very simple:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `io` 包中的接口外，还有几个用于常见操作的辅助函数。例如，`io.ReadAll` 函数从 `io.Reader` 中读取所有数据到一个字节切片中。`io`
    中的一种更聪明的函数展示了一种向 Go 类型添加方法的模式。如果你有一个实现了 `io.Reader` 但没有实现 `io.Closer` 的类型（例如 `strings.Reader`），并且需要将其传递给期望
    `io.ReadCloser` 的函数，则可以将你的 `io.Reader` 传递给 `io.NopCloser`，从而得到一个实现了 `io.ReadCloser`
    的类型。如果查看其实现，你会发现它非常简单：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Anytime you need to add additional methods to a type so that it can meet an
    interface, use this embedded type pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为某种类型添加额外的方法以满足某个接口，可以使用嵌入类型模式。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `io.NopCloser` function violates the general rule of not returning an interface
    from a function, but it’s a simple adapter for an interface that is guaranteed
    to stay the same because it is part of the standard library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.NopCloser` 函数违反了不从函数返回接口的一般规则，但它是一个简单的适配器，用于保证接口保持不变，因为它是标准库的一部分。'
- en: Among other things, the `os` package contains functions for interacting with
    files. The functions `os.ReadFile` and `os.WriteFile` read an entire file into
    a slice of bytes and write a slice of bytes into a file, respectively. These functions
    (and `io.ReadAll`) are fine for small amounts of data, but they are not appropriate
    for large data sources. When working with larger data sources, use the `Create`,
    `NewFile`, `Open`, and `OpenFile` functions in the `os` package. They return an
    `*os.File` instance, which implements the `io.Reader` and `io.Writer` interfaces.
    You can use an `*os.File` instance with the `Scanner` type in the `bufio` package.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包包含与文件交互的函数。函数`os.ReadFile`和`os.WriteFile`分别将整个文件读入字节片段并将字节片段写入文件。这些函数（以及`io.ReadAll`）适用于小数据量，但不适合大数据源。处理较大数据源时，请使用`os`包中的`Create`、`NewFile`、`Open`和`OpenFile`函数。它们返回一个实现了`io.Reader`和`io.Writer`接口的`*os.File`实例。您可以将`*os.File`实例与`bufio`包中的`Scanner`类型一起使用。'
- en: time
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: 'Like most languages, Go’s standard library includes time support, which is
    found, unsurprisingly, in the `time` package. Two main types are used to represent
    time: `time.Duration` and `time.Time`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Go标准库包含时间支持，通常在`time`包中。用于表示时间的两个主要类型是`time.Duration`和`time.Time`。
- en: 'A period of time is represented with a `time.Duration`, a type based on an
    `int64`. The smallest amount of time that Go can represent is one nanosecond,
    but the `time` package defines constants of type `time.Duration` to represent
    a nanosecond, microsecond, millisecond, second, minute, and hour. For example,
    you represent a duration of 2 hours and 30 minutes as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 时间段由`time.Duration`表示，这是基于`int64`的类型。Go能表示的最小时间单位是纳秒，但`time`包定义了`time.Duration`类型的常量，表示纳秒、微秒、毫秒、秒、分钟和小时。例如，表示2小时30分钟的持续时间如下：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These constants make the use of a `time.Duration` both readable and type-safe.
    They demonstrate a good use of a typed constant.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量使得使用`time.Duration`既可读性强又类型安全。它们展示了类型化常量的良好使用。
- en: 'Go defines a sensible string format, a series of numbers, that can be parsed
    into a `time.Duration` with the `time.ParseDuration` function. This format is
    described in the standard library documentation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go定义了一种合理的字符串格式，一系列数字，可以使用`time.ParseDuration`函数解析为`time.Duration`。此格式在标准库文档中有描述：
- en: A duration string is a possibly signed sequence of decimal numbers, each with
    optional fraction and a unit suffix, such as “300ms”, “-1.5h” or “2h45m”. Valid
    time units are “ns”, “us” (or “µs”), “ms”, “s”, “m”, “h”.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 时间段字符串是一系列可能带有可选小数部分和单位后缀的十进制数字，例如“300ms”、“-1.5h”或“2h45m”。有效的时间单位有“ns”、“us”（或“µs”）、“ms”、“s”、“m”、“h”。
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Go Standard Library Documentation](https://oreil.ly/wmZdy)'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Go标准库文档](https://oreil.ly/wmZdy)'
- en: Several methods are defined on `time.Duration`. It meets the `fmt.Stringer`
    interface and returns a formatted duration string via the `String` method. It
    also has methods to get the value as a number of hours, minutes, seconds, milliseconds,
    microseconds, or nanoseconds. The `Truncate` and `Round` methods truncate or round
    a `time.Duration` to the units of the specified `time.Duration`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Duration`上定义了几种方法。它符合`fmt.Stringer`接口，并通过`String`方法返回格式化的持续时间字符串。它还具有将值作为小时数、分钟数、秒数、毫秒数、微秒数或纳秒数返回的方法。`Truncate`和`Round`方法将`time.Duration`截断或四舍五入到指定的`time.Duration`单位。'
- en: A moment of time is represented with the `time.Time` type, complete with a time
    zone. You acquire a reference to the current time with the function `time.Now`.
    This returns a `time.Time` instance set to the current local time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 时间的瞬间由`time.Time`类型表示，带有时区信息。使用`time.Now`函数获取当前时间的引用，返回一个设置为当前本地时间的`time.Time`实例。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The fact that a `time.Time` instance contains a time zone means that you should
    not use `==` to check whether two `time.Time` instances refer to the same moment
    in time. Instead, use the `Equal` method, which corrects for time zone.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Time`实例包含时区信息，因此不应使用`==`来检查两个`time.Time`实例是否指向同一时刻。相反，请使用`Equal`方法，该方法会校正时区。'
- en: The `time.Parse` function converts from a `string` to a `time.Time`, while the
    `Format` method converts a `time.Time` to a `string`. While Go usually adopts
    ideas that worked well in the past, it uses [its own date and time formatting
    language](https://oreil.ly/yfm_V). It relies on the idea of formatting the date
    and time January 2, 2006 at 3:04:05PM MST (Mountain Standard Time) to specify
    your format.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Parse`函数将`string`转换为`time.Time`，而`Format`方法将`time.Time`转换为`string`。虽然Go通常采纳在过去表现良好的想法，但它使用[自己的日期和时间格式语言](https://oreil.ly/yfm_V)。它依赖于格式化日期和时间为2006年1月2日下午3:04:05PM
    MST（山区标准时间）来指定您的格式。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Why that date? Because each part of it represents one of the numbers from 1
    to 7 in sequence, that is, 01/02 03:04:05PM ’06 -0700 (MST is 7 hours before UTC).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择这个日期？因为它的每一部分都按照顺序代表从1到7的数字，也就是说，01/02 03:04:05PM ’06 -0700（MST比UTC提前7小时）。
- en: For example, the following code
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'prints out this output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出以下输出：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While the date and time used for formatting is intended to be a clever mnemonic,
    I find it hard to remember and have to look it up each time I want to use it.
    Luckily, the most commonly used date and time formats have been given their own
    constants in the `time` package.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用于格式化的日期和时间旨在成为一个聪明的记忆技巧，但我发现很难记住，每次想要使用它时都必须查找。幸运的是，在`time`包中，最常用的日期和时间格式都已经被赋予了自己的常量。
- en: Just as there are methods on `time.Duration` to extract portions of it, there
    are methods defined on `time.Time` to do the same, including `Day`, `Month`, `Year`,
    `Hour`, `Minute`, `Second`, `Weekday`, `Clock` (which returns the time portion
    of a `time.Time` as separate hour, minute, and second `int` values), and `Date`
    (which returns the year, month, and day as separate `int` values). You can compare
    one `time.Time` instance against another with the `After`, `Before`, and `Equal`
    methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`time.Duration`上有提取部分的方法一样，在`time.Time`上也定义了类似的方法，包括`Day`、`Month`、`Year`、`Hour`、`Minute`、`Second`、`Weekday`、`Clock`（返回`time.Time`的时间部分作为单独的小时、分钟和秒`int`值）和`Date`（返回年、月和日作为单独的`int`值）。您可以使用`After`、`Before`和`Equal`方法比较一个`time.Time`实例与另一个。
- en: The `Sub` method returns a `time.Duration` that represents the elapsed time
    between two `time.Time` instances, while the `Add` method returns a `time.Time`
    that is `time.Duration` later, and the `AddDate` method returns a new `time.Time`
    instance that’s incremented by the specified number of years, months, and days.
    As with `time.Duration`, there are `Truncate` and `Round` methods defined as well.
    All these methods are defined on a value receiver, so they do not modify the `time.Time`
    instance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sub`方法返回一个表示两个`time.Time`实例之间经过的时间的`time.Duration`，而`Add`方法返回比当前时间晚`time.Duration`的`time.Time`，`AddDate`方法返回增加指定年、月和日数的新`time.Time`实例。与`time.Duration`一样，还定义了`Truncate`和`Round`方法。所有这些方法都在值接收器上定义，因此它们不会修改`time.Time`实例。'
- en: Monotonic Time
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**单调时间**'
- en: 'Most operating systems keep track of two sorts of time: the *wall clock*, which
    corresponds to the current time, and the *monotonic clock*, which counts up from
    the time the computer was booted. The reason for tracking two clocks is that the
    wall clock doesn’t uniformly increase. Daylight Saving Time, leap seconds, and
    Network Time Protocol (NTP) updates can make the wall clock move unexpectedly
    forward or backward. This can cause problems when setting a timer or finding the
    amount of time that’s elapsed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统会跟踪两种类型的时间：*挂钟*，它对应于当前时间，以及*单调时钟*，它从计算机启动时开始计数。跟踪两个时钟的原因是挂钟不会均匀地增长。夏令时、闰秒和网络时间协议（NTP）更新可能会使挂钟意外地前进或后退。这在设置定时器或查找经过的时间时可能会导致问题。
- en: To address this potential problem, Go uses monotonic time to track elapsed time
    whenever a timer is set or a `time.Time` instance is created with `time.Now`.
    This support is invisible; timers use it automatically. The `Sub` method uses
    the monotonic clock to calculate the `time.Duration` if both `time.Time` instances
    have it set. If they don’t (because one or both of the instances was not created
    with `time.Now`), the `Sub` method uses the time specified in the instances to
    calculate the `time.Duration` instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个潜在问题，Go语言使用单调时间来跟踪经过的时间，每当设置定时器或使用`time.Now`创建`time.Time`实例时，都会用到单调时间。这种支持是透明的；定时器会自动使用它。`Sub`方法使用单调时钟来计算`time.Duration`，如果两个`time.Time`实例都已设置。如果它们没有（因为一个或两个实例没有使用`time.Now`创建），那么`Sub`方法会使用实例中指定的时间来计算`time.Duration`。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to understand the sorts of problems that can occur when not handling
    monotonic time correctly, take a look at the Cloudflare [blog post](https://oreil.ly/IxS2D)
    that detailed a bug caused by the lack of monotonic time support in an earlier
    version of Go.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解在未正确处理单调时间时可能发生的问题的类型，请查看Cloudflare的[博文](https://oreil.ly/IxS2D)，详细描述了Go早期版本中由于缺乏单调时间支持而导致的错误。
- en: Timers and Timeouts
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时器和超时
- en: As I covered in [“Time Out Code”](ch12.html#time_out), the `time` package includes
    functions that return channels that output values after a specified time. The
    `time.After` function returns a channel that outputs once, while the channel returned
    by `time.Tick` returns a new value every time the specified `time.Duration` elapses.
    These are used with Go’s concurrency support to enable timeouts or recurring tasks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“超时代码”](ch12.html#time_out)中所介绍的，`time`包包含返回通道的函数，这些通道在指定时间后输出值。`time.After`函数返回一个仅输出一次的通道，而`time.Tick`返回的通道在每个指定的`time.Duration`经过后返回一个新值。这些函数与Go的并发支持一起使用，以实现超时或定期任务。
- en: You can also trigger a single function to run after a specified `time.Duration`
    with the `time.AfterFunc` function. Don’t use `time.Tick` outside trivial programs,
    because the underlying `time.Ticker` cannot be shut down (and therefore cannot
    be garbage collected). Use the `time.NewTicker` function instead, which returns
    a `*time.Ticker` that has the channel to listen to, as well as methods to reset
    and stop the ticker.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`time.AfterFunc`函数在指定的`time.Duration`后触发单个函数运行。不要在非平凡程序之外使用`time.Tick`，因为底层的`time.Ticker`无法关闭（因此无法被垃圾回收）。相反，请使用`time.NewTicker`函数，它返回一个`*time.Ticker`，该类型具有用于监听的通道以及重置和停止计时器的方法。
- en: encoding/json
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: encoding/json
- en: REST APIs have enshrined JSON as the standard way to communicate between services,
    and Go’s standard library includes support for converting Go data types to and
    from JSON. The word *marshaling* means converting from a Go data type to an encoding,
    and *unmarshaling* means converting to a Go data type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: REST API已经将JSON确立为服务之间通信的标准方式，而Go的标准库包含了将Go数据类型与JSON相互转换的支持。*Marshaling*一词表示从Go数据类型到编码的转换，*unmarshaling*则表示从编码到Go数据类型的转换。
- en: Using Struct Tags to Add Metadata
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用结构体标签添加元数据
- en: 'Let’s say that you are building an order management system and have to read
    and write the following JSON:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个订单管理系统，并且必须读取和写入以下JSON：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You define types to map this data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了类型来映射这些数据：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You specify the rules for processing your JSON with *struct tags*, strings that
    are written after the fields in a struct. Even though struct tags are strings
    marked with backticks, they cannot extend past a single line. Struct tags are
    composed of one or more tag/value pairs, written as *`tagName:"tagValue"`* and
    separated by spaces. Because they are just strings, the compiler cannot validate
    that they are formatted correctly, but `go vet` does. Also, note that all these
    fields are exported. Like any other package, the code in the `encoding/json` package
    cannot access an unexported field on a struct in another package.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*结构体标签*来指定处理JSON的规则，这些标签写在结构体字段后面。尽管结构体标签是用反引号标记的字符串，但它们不能超过单行。结构体标签由一个或多个标签/值对组成，写成*`tagName:"tagValue"`*，并用空格分隔。因为它们只是字符串，编译器无法验证它们的格式，但`go
    vet`可以。还要注意，所有这些字段都是可导出的。与任何其他包一样，`encoding/json`包中的代码无法访问另一个包中未导出的结构体字段。
- en: For JSON processing, use the tag `json` to specify the name of the JSON field
    that should be associated with the struct field. If no `json` tag is provided,
    the default behavior is to assume that the name of the JSON object field matches
    the name of the Go struct field. Despite this default behavior, it’s best to use
    the struct tag to specify the name of the field explicitly, even if the field
    names are identical.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JSON处理，使用标签`json`来指定应与结构体字段关联的JSON字段的名称。如果未提供`json`标签，则默认行为是假定JSON对象字段的名称与Go结构体字段的名称相匹配。尽管存在此默认行为，最好还是使用结构体标签显式指定字段的名称，即使字段名称相同。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When unmarshaling from JSON into a struct field with no `json` tag, the name
    match is case-insensitive. When marshaling a struct field with no `json` tag back
    to JSON, the JSON field will always have an uppercase first letter, because the
    field is exported.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当将JSON解组到没有`json`标签的结构体字段时，名称匹配是不区分大小写的。当将没有`json`标签的结构体字段编组回JSON时，JSON字段的首字母始终大写，因为该字段是可导出的。
- en: If a field should be ignored when marshaling or unmarshaling, use a dash (`-`)
    for the name. If the field should be left out of the output when it is empty,
    add `,omitempty` after the name. For example, in the `Order` struct, if you didn’t
    want to include `CustomerID` in the output if it was set to an empty string, the
    struct tag would be `json:"customer_id,omitempty"`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编组或解组时应忽略某个字段，请使用破折号（`-`）作为字段名。如果该字段在为空时应从输出中省略，则在字段名后添加`,omitempty`。例如，在`Order`结构中，如果不希望在输出中包含`CustomerID`，如果其设置为空字符串，则结构标记应为`json:"customer_id,omitempty"`。
- en: Warning
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Unfortunately, the definition of “empty” doesn’t exactly align with the zero
    value, as you might expect. The zero value of a struct doesn’t count as empty,
    but a zero-length slice or map does.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，“空”这一定义与零值并不完全对齐，正如你所期望的那样。结构体的零值并不算作空，但零长度的切片或映射则属于空。
- en: Struct tags allow you to use metadata to control how your program behaves. Other
    languages, most notably Java, encourage developers to place annotations on various
    program elements to describe *how* they should be processed, without explicitly
    specifying *what* is going to do the processing. While declarative programming
    allows for more concise programs, automatic processing of metadata makes it difficult
    to understand how a program behaves. Anyone who has worked on a large Java project
    with annotations has had a moment of panic when something goes wrong and they
    don’t understand which code is processing a particular annotation and what changes
    it made. Go favors explicit code over short code. Struct tags are never evaluated
    automatically; they are processed when a struct instance is passed into a function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结构标记允许您使用元数据来控制程序的行为。其他语言，尤其是Java，鼓励开发者在各种程序元素上放置注解，以描述处理方式，而不显式指定处理内容。虽然声明性编程能够实现更简洁的程序，但元数据的自动处理使得理解程序行为变得困难。在一个大型Java项目中，有注解的开发者在出现问题时，往往会陷入一片茫然，不知道哪段代码处理了特定的注解，以及做了哪些改变。Go更倾向于显式代码而不是短小的代码。结构标记永远不会自动评估；它们在将结构实例传递给函数时进行处理。
- en: Unmarshaling and Marshaling
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解组和编组
- en: 'The `Unmarshal` function in the `encoding/json` package is used to convert
    a slice of bytes into a struct. If you have a string named `data`, this is the
    code to convert `data` to a struct of type `Order`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding/json`包中的`Unmarshal`函数用于将字节切片转换为结构体。如果有一个名为`data`的字符串，则以下代码将`data`转换为类型为`Order`的结构体：'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `json.Unmarshal` function populates data into an input parameter, just like
    the implementations of the `io.Reader` interface. As I discussed in [“Pointers
    Are a Last Resort”](ch06.html#last_resort), this allows for efficient reuse of
    the same struct over and over, giving you control over memory usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Unmarshal`函数将数据填充到输入参数中，就像`io.Reader`接口的实现一样。正如我在[“指针是最后的选择”](ch06.html#last_resort)中所讨论的，这样可以有效地重复使用同一个结构体，从而控制内存使用。'
- en: 'You use the `Marshal` function in the `encoding/json` package to write an `Order`
    instance back as JSON, stored in a slice of bytes:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`encoding/json`包中的`Marshal`函数将`Order`实例写回为JSON，存储在字节切片中：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This leads to the question: how are you able to evaluate struct tags? You might
    also be wondering how `json.Marshal` and `json.Unmarshal` are able to read and
    write a struct of any type. After all, every other method that you’ve written
    has worked only with types that were known when the program was compiled (even
    the types listed in a type switch are enumerated ahead of time). The answer to
    both questions is reflection. You can find out more about reflection in [Chapter 16](ch16.html#unique_chapter_id_16).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：你如何能够评估结构标记？你可能还想知道`json.Marshal`和`json.Unmarshal`如何能够读取和写入任何类型的结构体。毕竟，你编写的其他方法仅与程序编译时已知的类型一起工作（即使在类型开关中列出的类型也是预先枚举的）。对这两个问题的答案是反射。你可以在[第16章](ch16.html#unique_chapter_id_16)了解更多关于反射的信息。
- en: JSON, Readers, and Writers
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON、读者和写者
- en: The `json.Marshal` and `json.Unmarshal` functions work on slices of bytes. As
    you just saw, most data sources and sinks in Go implement the `io.Reader` and
    `io.Writer` interfaces. While you could use `io.ReadAll` to copy the entire contents
    of an `io.Reader` into a byte slice so it can be read by `json.Unmarshal`, this
    is inefficient. Similarly, you could write to an in-memory byte slice buffer using
    `json.Marshal` and then write that byte slice to the network or disk, but it’d
    be better if you could write to an `io.Writer` directly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Marshal` 和 `json.Unmarshal` 函数在字节片上工作。正如你刚才看到的，Go 中的大多数数据源和汇合都实现了 `io.Reader`
    和 `io.Writer` 接口。虽然你可以使用 `io.ReadAll` 将 `io.Reader` 的整个内容复制到字节片中，以便 `json.Unmarshal`
    读取，但这是低效的。类似地，你可以使用 `json.Marshal` 写入到内存中的字节片缓冲区，然后将该字节片写入网络或磁盘，但最好直接写入到 `io.Writer`。'
- en: The `encoding/json` package includes two types that allow you to handle these
    situations. The `json.Decoder` and `json.Encoder` types read from and write to
    anything that meets the `io.Reader` and `io.Writer` interfaces, respectively.
    Let’s take a quick look at how they work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding/json` 包含两种类型，允许你处理这些情况。`json.Decoder` 和 `json.Encoder` 类型分别从符合 `io.Reader`
    和 `io.Writer` 接口的任何地方读取和写入。让我们快速看看它们的工作方式。'
- en: 'Start with your data in `toFile`, which implements a simple struct:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的数据 `toFile` 开始，它实现了一个简单的结构体：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `os.File` type implements both the `io.Reader` and `io.Writer` interfaces,
    so it can be used to demonstrate `json.Decoder` and `json.Encoder`. First, you
    write `toFile` to a temp file by passing the temp file to `json.NewEncoder`, which
    returns a `json.Encoder` for the temp file. You then pass `toFile` to the `Encode`
    method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.File` 类型实现了 `io.Reader` 和 `io.Writer` 接口，因此可以用来演示 `json.Decoder` 和 `json.Encoder`。首先，通过将临时文件传递给
    `json.NewEncoder` 将 `toFile` 写入临时文件，该方法返回一个临时文件的 `json.Encoder`。然后，将 `toFile`
    传递给 `Encode` 方法：'
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once `toFile` is written, you can read the JSON back in by passing a reference
    to the temp file to `json.NewDecoder` and then calling the `Decode` method on
    the returned `json.Decoder` with a variable of type `Person`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `toFile` 写入完成，你可以通过将临时文件的引用传递给 `json.NewDecoder`，然后在返回的 `json.Decoder` 上调用
    `Decode` 方法，类型为 `Person` 的变量进行 JSON 读取：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see a complete example on [The Go Playground](https://oreil.ly/eLk64)
    or in the *sample_code/json* directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [Go Playground](https://oreil.ly/eLk64) 上看到完整的示例，或在 [第 13 章示例代码/json 目录](https://oreil.ly/XOPbD)
    中找到。
- en: Encoding and Decoding JSON Streams
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码和解码 JSON 流
- en: What do you do when you have multiple JSON structs to read or write at once?
    Our friends `json.Decoder` and `json.Encoder` can be used for these situations
    too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个 JSON 结构需要一次性读取或写入时，我们的朋友 `json.Decoder` 和 `json.Encoder` 也可以用于这些情况。
- en: 'Assume you have the following data:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下数据：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the sake of this example, assume it’s stored in a string called `streamData`,
    but it could be in a file or even an incoming HTTP request (you’ll see how HTTP
    servers work in just a bit).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本示例，假设它存储在一个名为 `streamData` 的字符串中，但它可以在文件中或甚至是传入的 HTTP 请求中（稍后你将看到 HTTP 服务器如何工作）。
- en: You’re going to store this data into your `t` variable, one JSON object at a
    time.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你将这些数据逐个 JSON 对象地存储到你的 `t` 变量中。
- en: 'Just as before, you initialize your `json.Decoder` with the data source, but
    this time you use a `for` loop and run until you get an error. If the error is
    `io.EOF`, you have successfully read all the data. If not, there was a problem
    with the JSON stream. This lets you read and process the data, one JSON object
    at a time:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，你用数据源初始化你的 `json.Decoder`，但这次你使用 `for` 循环并运行直到出现错误。如果错误是 `io.EOF`，则成功读取所有数据。如果不是，则
    JSON 流存在问题。这让你能够逐个 JSON 对象地读取和处理数据：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Writing out multiple values with the `json.Encoder` works just like using it
    to write out a single value. In this example, you are writing to a `bytes.Buffer`,
    but any type that meets the `io.Writer` interface will work:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `json.Encoder` 写出多个值的方式与使用它写出单个值的方式完全相同。在这个示例中，你将写入到一个 `bytes.Buffer`，但任何符合
    `io.Writer` 接口的类型都可以工作：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can run this example on [The Go Playground](https://oreil.ly/XGbRQ) or find
    it in the *sample_code/encode_decode* directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [Go Playground](https://oreil.ly/XGbRQ) 上运行这个示例，或在 [第 13 章示例代码/encode_decode
    目录](https://oreil.ly/XOPbD) 中找到。
- en: This example has multiple JSON objects in the data stream that aren’t wrapped
    in an array, but you can also use the `json.Decoder` to read a single object from
    an array without loading the entire array into memory at once. This can greatly
    increase performance and reduce memory usage. An example is in the [Go documentation](https://oreil.ly/_LTZQ).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在数据流中有多个未包装在数组中的JSON对象，但你也可以使用`json.Decoder`从数组中读取单个对象，而无需一次性加载整个数组到内存中。这可以极大地提高性能并减少内存使用。在[Go文档](https://oreil.ly/_LTZQ)中有一个示例。
- en: Custom JSON Parsing
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义JSON解析
- en: 'While the default functionality is often sufficient, sometimes you need to
    override it. While `time.Time` supports JSON fields in RFC 3339 format out of
    the box, you might have to deal with other time formats. You can handle this by
    creating a new type that implements two interfaces, `json.Marshaler` and `json.Unmarshaler`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认功能通常足够使用，但有时你需要进行覆盖。虽然`time.Time`默认支持RFC 3339格式的JSON字段，但你可能需要处理其他时间格式。你可以通过创建一个实现`json.Marshaler`和`json.Unmarshaler`两个接口的新类型来处理这个问题：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You embedded a `time.Time` instance into a new struct called `RFC822ZTime` so
    that you still have access to the other methods on `time.Time`. As was discussed
    in [“Pointer Receivers and Value Receivers”](ch07.html#pointer_value_receivers),
    the method that reads the time value is declared on a value receiver, while the
    method that modifies the time value is declared on a pointer receiver.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将一个`time.Time`实例嵌入到一个称为`RFC822ZTime`的新结构体中，这样你仍然可以访问`time.Time`上的其他方法。正如在[“指针接收器和值接收器”](ch07.html#pointer_value_receivers)中讨论的那样，读取时间值的方法声明为值接收器，而修改时间值的方法声明为指针接收器。
- en: 'You then change the type of your `DateOrdered` field and can work with RFC
    822 formatted times instead:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你改变了`DateOrdered`字段的类型，并可以使用RFC 822格式化时间进行处理：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can run this code on [The Go Playground](https://oreil.ly/I_cSY) or find
    it in the *sample_code/custom_json* directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Go Playground](https://oreil.ly/I_cSY)上运行此代码，或在[第13章的代码库](https://oreil.ly/XOPbD)的*sample_code/custom_json*目录中找到它。
- en: 'This approach has a philosophical drawback: the date format of the JSON determines
    the types of the fields in your data structure. This is a drawback to the `encoding/json`
    approach. You could have `Order` implement `json.Marshaler` and `json.Unmarshaler`,
    but that requires you to write code to handle all the fields, even the ones that
    don’t require custom support. The struct tag format does not provide a way to
    specify a function to parse a particular field. That leaves you with creating
    a custom type for the field.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一个哲学上的缺点：JSON 的日期格式决定了数据结构中字段的类型。这是`encoding/json`方法的一个缺点。你可以让`Order`实现`json.Marshaler`和`json.Unmarshaler`，但这需要你编写代码来处理所有字段，即使那些不需要定制支持的字段也是如此。结构体标签格式并没有提供一种指定解析特定字段的函数的方式。这使得你不得不为字段创建一个自定义类型。
- en: Another option is described in a [blog post by Ukiah Smith](https://oreil.ly/Jl05c).
    It allows you to redefine only the fields that don’t match the default marshaling
    behavior by taking advantage of how struct embedding (which was covered in [“Use
    Embedding for Composition”](ch07.html#struct_embedding)) interacts with JSON marshaling
    and unmarshaling. If a field on an embedded struct has the same name as the containing
    struct, that field is ignored when marshaling or unmarshaling JSON.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择在Ukiah Smith的[博客文章](https://oreil.ly/Jl05c)中有描述。它允许你仅重新定义那些不匹配默认编组行为的字段，通过利用结构体嵌入（在[“使用嵌入进行组合”](ch07.html#struct_embedding)中介绍过）。如果嵌入结构体的字段与包含结构体的同名，那么在JSON编组或解组时，该字段将被忽略。
- en: 'In this example, the fields for `Order` look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Order`的字段看起来像这样：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `MarshalJSON` method looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarshalJSON`方法看起来像这样：'
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the `MarshalJSON` method for `Order`, you define a type `Dup` whose underlying
    type is `Order`. The reason for creating `Dup` is that a type based on another
    type has the same fields as the underlying type, but not the methods. If you didn’t
    have `Dup`, there would be an infinite loop of calls to `MarshalJSON` when you
    call `json.Marshal`, eventually resulting in a stack overflow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Order`的`MarshalJSON`方法，你定义了一个类型为`Dup`，其基础类型是`Order`。创建`Dup`的原因是，基于另一个类型的类型具有与基础类型相同的字段，但不具有方法。如果没有`Dup`，在调用`json.Marshal`时将会导致`MarshalJSON`的无限循环调用，最终导致堆栈溢出。
- en: You define an anonymous struct that has the `DateOrdered` field and an embedded
    `Dup`. You then assign the `Order` instance to the embedded field in `tmp`, assign
    the `DateOrdered` field in `tmp` the time formatted as RFC822Z, and call `json.Marshal`
    on `tmp`. This produces the desired JSON output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个具有`DateOrdered`字段和嵌入式`Dup`的匿名结构体。然后将`Order`实例分配给`tmp`中的嵌入字段，在`tmp`中为`DateOrdered`字段分配RFC822Z格式的时间，并在`tmp`上调用`json.Marshal`。这会产生所需的JSON输出。
- en: 'There is similar logic in `UnmarshalJSON`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmarshalJSON`中也有类似的逻辑：'
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In `UnmarshalJSON`, the call to `json.Unmarshal` populates the fields in `o`
    (except `DateOrdered`) because it’s embedded into `tmp`. You then populate `DateOrdered`
    in `o` by using `time.Parse` to process the `DateOrdered` field in `tmp`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UnmarshalJSON`中，对`json.Unmarshal`的调用填充了`o`中的字段（除了`DateOrdered`），因为它被嵌入到`tmp`中。然后，你使用`time.Parse`处理`tmp`中的`DateOrdered`字段，并在`o`中填充`DateOrdered`。
- en: You can run this code on [The Go Playground](https://oreil.ly/JHsdO) or find
    it in the *sample_code/custom_json2* directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Go Playground](https://oreil.ly/JHsdO)上运行此代码，或在[第13章存储库](https://oreil.ly/XOPbD)的*sample_code/custom_json2*目录中找到它。
- en: While this does keep `Order` from having a field tied to the JSON format, the
    `MarshalJSON` and `UnmarshalJSON` methods on `Order` are coupled to the format
    of the time field in the JSON. You cannot reuse `Order` to support JSON that has
    the time formatted another way.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以使`Order`不与JSON格式绑定，但`Order`上的`MarshalJSON`和`UnmarshalJSON`方法与JSON中时间字段的格式耦合在一起。你无法重用`Order`来支持其他时间格式的JSON。
- en: To limit the amount of code that cares about what your JSON looks like, define
    two structs. Use one for converting to and from JSON and the other for data processing.
    Read in JSON to your JSON-aware type, and then copy it to the other. When you
    want to write out JSON, do the reverse. This does create some duplication, but
    it keeps your business logic from depending on wire protocols.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制关心JSON外观的代码量，定义两个结构体。使用一个结构体进行JSON的转换，另一个进行数据处理。将JSON读入你的JSON-aware类型，然后将其复制到另一个类型。当你想要写出JSON时，做相反的操作。这确实会产生一些重复，但它可以使你的业务逻辑不依赖于通信协议。
- en: You can pass a `map[string]any` to `json.Marshal` and `json.Unmarshal` to translate
    back and forth between JSON and Go, but save that for the exploratory phase of
    your coding and replace it with a concrete type when you understand what you are
    processing. Go uses types for a reason; they document the expected data and the
    types of the expected data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`map[string]any`传递给`json.Marshal`和`json.Unmarshal`，在JSON和Go之间进行双向转换，但在编码探索阶段保存它，并在理解正在处理的数据后用具体类型替换它。Go使用类型是有原因的；它们文档化了预期数据和预期数据的类型。
- en: While JSON is probably the most commonly used encoder in the standard library,
    Go ships with others, including XML and Base64\. If you have a data format that
    you want to encode and you can’t find support for it in the standard library or
    a third-party module, you can write one yourself. You’ll learn how to implement
    our own encoder in [“Use Reflection to Write a Data Marshaler”](ch16.html#csv_marshaler).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JSON可能是标准库中最常用的编码器，Go还包含其他编码器，包括XML和Base64。如果你有一种数据格式需要编码，而标准库或第三方模块中找不到支持，你可以自己编写一个。你将会学习如何在[“使用反射编写数据编组器”](ch16.html#csv_marshaler)中实现我们自己的编码器。
- en: Warning
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The standard library includes `encoding/gob`, which is a Go-specific binary
    representation that is a bit like serialization in Java. Just as Java serialization
    is the wire protocol for Enterprise Java Beans and Java RMI, the gob protocol
    is intended as the wire format for a Go-specific RPC (remote procedure call) implementation
    in the `net/rpc` package. Don’t use either `encoding/gob` or `net/rpc`. If you
    want to do remote method invocation with Go, use a standard protocol like [GRPC](https://grpc.io)
    so that you aren’t tied to a specific language. No matter how much you love Go,
    if you want your services to be useful, make them callable by developers using
    other languages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包括`encoding/gob`，这是Go特有的二进制表示，有点像Java中的序列化。就像Java序列化是Enterprise Java Beans和Java
    RMI的传输协议一样，gob协议旨在成为`net/rpc`包中Go特有RPC（远程过程调用）实现的传输格式。不要使用`encoding/gob`或`net/rpc`。如果你想要在Go中进行远程方法调用，请使用像[GRPC](https://grpc.io)这样的标准协议，这样你就不会被绑定到特定的语言。无论你有多么喜欢Go，如果你希望你的服务有用，让其他语言的开发者能够调用它们。
- en: net/http
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: net/http
- en: 'Every language ships with a standard library, but the expectations of what
    a standard library should include have changed over time. As a language launched
    in the 2010s, Go’s standard library includes something that other language distributions
    had considered the responsibility of a third party: a production-quality HTTP/2
    client and server.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都附带了一个标准库，但随着时间的推移，标准库应该包含的预期也在变化。作为在2010年代推出的语言，Go的标准库包括一些其他语言分发版本认为应该由第三方负责的内容：一个高质量的HTTP/2客户端和服务器。
- en: The Client
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: 'The `net/http` package defines a `Client` type to make HTTP requests and receive
    HTTP responses. A default client instance (cleverly named `DefaultClient`) is
    found in the `net/http` package, but you should avoid using it in production applications,
    because it defaults to having no timeout. Instead, instantiate your own. You need
    to create only a single `http.Client` for your entire program, as it properly
    handles multiple simultaneous requests across goroutines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包定义了一个`Client`类型，用于发出HTTP请求和接收HTTP响应。在`net/http`包中可以找到一个默认的客户端实例（巧妙地命名为`DefaultClient`），但是在生产应用程序中应避免使用它，因为它默认没有超时设置。相反，应实例化自己的客户端。对于整个程序，只需要创建一个`http.Client`，它可以正确处理跨goroutine的多个同时请求：'
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you want to make a request, you create a new `*http.Request` instance
    with the `http.NewRequestWithContext` function, passing it a context, the method,
    and URL that you are connecting to. If you are making a `PUT`, `POST`, or `PATCH`
    request, specify the body of the request with the last parameter as an `io.Reader`.
    If there is no body, use `nil`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要发出请求时，可以使用`http.NewRequestWithContext`函数创建一个新的`*http.Request`实例，传递一个上下文、方法和要连接的URL。如果要进行`PUT`、`POST`或`PATCH`请求，请将请求体作为最后一个参数作为`io.Reader`指定。如果没有请求体，请使用`nil`：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I’ll talk about what a context is in [Chapter 14](ch14.html#unique_chapter_id_14).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.html#unique_chapter_id_14)中，我将讨论上下文的概念。
- en: 'Once you have an `*http.Request` instance, you can set any headers via the
    `Headers` field of the instance. Call the `Do` method on the `http.Client` with
    your `http.Request`, and the result is returned in an `http.Response`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了`*http.Request`实例，您可以通过实例的`Headers`字段设置任何标头。使用`http.Client`的`Do`方法和您的`http.Request`，结果将返回为`http.Response`：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The response has several fields with information on the request. The numeric
    code of the response status is in the `StatusCode` field, the text of the response
    code is in the `Status` field, the response headers are in the `Header` field,
    and any returned content is in a `Body` field of type `io.ReadCloser`. This allows
    you to use it with `json.Decoder` to process REST API responses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 响应具有几个字段，其中包含有关请求的信息。响应状态的数值代码在`StatusCode`字段中，响应代码的文本在`Status`字段中，响应头在`Header`字段中，任何返回的内容在`Body`类型为`io.ReadCloser`的字段中。这使您可以与`json.Decoder`一起处理REST
    API响应：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can find this code in the *sample_code/client* directory in the [Chapter
    13 repository](https://oreil.ly/XOPbD).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第13章的代码库](https://oreil.ly/XOPbD)的*sample_code/client*目录中找到此代码。
- en: Warning
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There are functions in the `net/http` package to make `GET`, `HEAD`, and `POST`
    calls. Avoid using these functions because they use the default client, which
    means they don’t set a request timeout.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包中有用于进行`GET`、`HEAD`和`POST`调用的函数。应避免使用这些函数，因为它们使用默认客户端，这意味着它们不会设置请求超时。'
- en: The Server
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器
- en: The HTTP Server is built around the concept of an `http.Server` and the `http.Handler`
    interface. Just as the `http.Client` sends HTTP requests, the `http.Server` is
    responsible for listening for HTTP requests. It is a performant HTTP/2 server
    that supports TLS.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器围绕着`http.Server`和`http.Handler`接口的概念构建。就像`http.Client`发送HTTP请求一样，`http.Server`负责监听HTTP请求。它是一个性能优越的支持TLS的HTTP/2服务器。
- en: 'A request to a server is handled by an implementation of the `http.Handler`
    interface that’s assigned to the `Handler` field. This interface defines a single
    method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对请求的处理由分配给`Handler`字段的`http.Handler`接口的实现来处理。此接口定义了一个方法：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `*http.Request` should look familiar, as it’s the exact same type that’s
    used to send a request to an HTTP server. The `http.ResponseWriter` is an interface
    with three methods:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`*http.Request`应该看起来很熟悉，因为它正是用于向HTTP服务器发送请求的类型。`http.ResponseWriter`是一个接口，有三个方法：'
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These methods must be called in a specific order. First, call `Header` to get
    an instance of `http.Header` and set any response headers you need. If you don’t
    need to set any headers, you don’t need to call it. Next, call `WriteHeader` with
    the HTTP status code for your response. (All the status codes are defined as constants
    in the `net/http` package. This would have been a good place to define a custom
    type, but that was not done; all status code constants are untyped integers.)
    If you are sending a response that has a 200 status code, you can skip `WriteHeader`.
    Finally, call the `Write` method to set the body for the response. Here’s what
    a trivial handler looks like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法必须按特定顺序调用。首先，调用`Header`以获取`http.Header`的实例，并设置任何你需要的响应头。如果不需要设置任何头部，可以跳过此步骤。接下来，使用你的响应的HTTP状态码调用`WriteHeader`。（所有状态码都在`net/http`包中定义为常量。这里本应是定义自定义类型的好地方，但没有这样做；所有状态码常量都是无类型整数。）如果要发送的响应具有200状态码，可以跳过`WriteHeader`。最后，调用`Write`方法设置响应体。以下是一个简单处理程序的示例：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You instantiate a new `http.Server` just like any other struct:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化新的`http.Server`与实例化其他结构体一样简单：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Addr` field specifies the host and port the server listens on. If you don’t
    specify them, your server defaults to listening on all hosts on the standard HTTP
    port, 80\. You specify timeouts for the server’s reads, writes, and idles by using
    `time.Duration` values. Be sure to set these to properly handle malicious or broken
    HTTP clients, as the default behavior is to not time out at all. Finally, you
    specify the `http.Handler` for your server with the `Handler` field.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Addr`字段指定服务器监听的主机和端口。如果不指定，服务器将默认监听所有主机的标准HTTP端口80。你可以使用`time.Duration`值设置服务器的读取、写入和空闲超时，以正确处理恶意或损坏的HTTP客户端，因为默认行为是根本不设置超时。最后，使用`Handler`字段为服务器指定`http.Handler`。'
- en: You can find this code in the *sample_code/server* directory in the [Chapter
    13 repository](https://oreil.ly/XOPbD).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第13章代码库](https://oreil.ly/XOPbD)的*sample_code/server*目录中找到这段代码。
- en: A server that handles only a single request isn’t terribly useful, so the Go
    standard library includes a request router, `*http.ServeMux`. You create an instance
    with the `http.NewServeMux` function. It meets the `http.Handler` interface, so
    it can be assigned to the `Handler` field in `http.Server`. It also includes two
    methods that allow it to dispatch requests. The first method is called `Handle`
    and takes in two parameters, a path and an `http.Handler`. If the path matches,
    the `http.Handler` is invoked.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只处理单个请求的服务器并不是非常有用，因此Go标准库包含一个请求路由器`*http.ServeMux`。你可以使用`http.NewServeMux`函数创建一个实例。它满足`http.Handler`接口，因此可以分配给`http.Server`的`Handler`字段。它还包含两个方法用于调度请求。第一个方法叫做`Handle`，接受两个参数，一个路径和一个`http.Handler`。如果路径匹配，就会调用`http.Handler`。
- en: 'While you could create implementations of `http.Handler`, the more common pattern
    is to use the `HandleFunc` method on `*http.ServeMux`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以创建`http.Handler`的实现，但更常见的模式是在`*http.ServeMux`上使用`HandleFunc`方法：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method takes in a function or closure and converts it to an `http.HandlerFunc`.
    You explored the `http.HandlerFunc` type in [“Function Types Are a Bridge to Interfaces”](ch07.html#function_type_interface).
    For simple handlers, a closure is sufficient. For more complicated handlers that
    depend on other business logic, use a method on a struct, as demonstrated in [“Implicit
    Interfaces Make Dependency Injection Easier”](ch07.html#dependency_injection).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受一个函数或闭包，并将其转换为`http.HandlerFunc`。你在[“函数类型是接口的桥梁”](ch07.html#function_type_interface)中探讨了`http.HandlerFunc`类型。对于简单的处理程序，闭包足够了。对于依赖于其他业务逻辑的更复杂的处理程序，请使用结构体的方法，如[“隐式接口使依赖注入更容易”](ch07.html#dependency_injection)中所示。
- en: 'Go 1.22 extends the path syntax to optionally allow HTTP verbs and path wildcard
    variables. The value of a wildcard variable is read using the `PathValue` method
    on `http.Request`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.22扩展了路径语法，可选择允许HTTP动词和路径通配符变量。通配符变量的值通过`http.Request`的`PathValue`方法读取：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Warning
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The package-level functions `http.Handle`, `http.HandleFunc`, `http.ListenAndServe`,
    and `http.ListenAndServeTLS` that work with a package-level instance of the `*http.ServeMux`
    called `http.​DefaultServeMux`. Don’t use them outside trivial test programs.
    The `http.Server` instance is created in the `http.ListenAndServe` and `http.ListenAndServeTLS`
    functions, so you are unable to configure server properties like timeouts. Furthermore,
    third-party libraries could have registered their own handlers with the `http.DefaultServeMux`,
    and there’s no way to know without scanning through all your dependencies (both
    direct and indirect). Keep your application under control by avoiding shared state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 包级别的函数`http.Handle`、`http.HandleFunc`、`http.ListenAndServe`和`http.ListenAndServeTLS`与名为`http.DefaultServeMux`的包级别实例一起工作。不要在非常简单的测试程序之外使用它们。`http.Server`实例是在`http.ListenAndServe`和`http.ListenAndServeTLS`函数中创建的，因此你无法配置服务器属性如超时。此外，第三方库可能已经使用`http.DefaultServeMux`注册了它们自己的处理程序，而没有扫描所有依赖项（直接和间接的）就无法知道这一点。通过避免共享状态，保持你的应用程序受控制。
- en: 'Because `*http.ServeMux` dispatches requests to `http.Handler` instances, and
    since `*http.ServeMux` implements `http.Handler`, you can create an `*http.ServeMux`
    instance with multiple related requests and register it with a parent `*http.ServeMux`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`*http.ServeMux`分派请求给`http.Handler`实例，而且`*http.ServeMux`本身也实现了`http.Handler`接口，所以你可以创建一个`*http.ServeMux`实例，并注册它到父`*http.ServeMux`中：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, a request for `/person/greet` is handled by handlers attached
    to `person`, while `/dog/greet` is handled by handlers attached to `dog`. When
    you register `person` and `dog` with `mux`, you use the `http.StripPrefix` helper
    function to remove the part of the path that’s already been processed by `mux`.
    You can find this code in the *sample_code/server_mux* directory in the [Chapter
    13 repository](https://oreil.ly/XOPbD).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请求`/person/greet`由附加到`person`的处理程序处理，而`/dog/greet`由附加到`dog`的处理程序处理。当你将`person`和`dog`注册到`mux`时，使用`http.StripPrefix`辅助函数来移除已经被`mux`处理过的路径部分。你可以在[第13章代码库](https://oreil.ly/XOPbD)的*sample_code/server_mux*目录中找到这段代码。
- en: Middleware
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间件
- en: One of the most common requirements of an HTTP server is to perform a set of
    actions across multiple handlers, such as checking whether a user is logged in,
    timing a request, or checking a request header. Go handles these cross-cutting
    concerns with the *middleware pattern*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器最常见的需求之一是在多个处理程序中执行一组操作，如检查用户是否已登录、计时请求或检查请求头。Go使用*中间件模式*处理这些横切关注点。
- en: 'Rather than using a special type, the middleware pattern uses a function that
    takes in an `http.Handler` instance and returns an `http.Handler`. Usually, the
    returned `http.Handler` is a closure that is converted to an `http.HandlerFunc`.
    Here are two middleware generators, one that provides timing of requests and another
    that uses perhaps the worst access controls imaginable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件模式不是使用特殊类型，而是使用一个接受`http.Handler`实例并返回`http.Handler`实例的函数。通常，返回的`http.Handler`是一个转换为`http.HandlerFunc`的闭包。这里有两个中间件生成器，一个提供请求的定时，另一个使用可能是最糟糕的访问控制：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These two middleware implementations demonstrate what middleware does. First,
    you do setup operations or checks. If the checks don’t pass, you write the output
    in the middleware (usually with an error code) and return. If all is well, you
    call the handler’s `ServeHTTP` method. When that returns, you run cleanup operations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个中间件实现展示了中间件的作用。首先，进行设置操作或检查。如果检查未通过，则在中间件中编写输出（通常使用错误代码）并返回。如果一切正常，则调用处理程序的`ServeHTTP`方法。当返回时，运行清理操作。
- en: The `TerribleSecurityProvider` shows how to create configurable middleware.
    You pass in the configuration information (in this case, the password), and the
    function returns middleware that uses that configuration information. It is a
    bit of a mind bender, as it returns a closure that returns a closure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`TerribleSecurityProvider`展示了如何创建可配置的中间件。你传递配置信息（在本例中是密码），函数返回使用该配置信息的中间件。这有点令人费解，因为它返回一个返回闭包的闭包。'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering how to pass values through the layers of middleware.
    This is done via the context, which you’ll look at in [Chapter 14](ch14.html#unique_chapter_id_14).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想知道如何通过中间件层传递值。这通过上下文（context）完成，在[第14章](ch14.html#unique_chapter_id_14)中会详细介绍。
- en: 'You add middleware to your request handlers by chaining them:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将中间件链接起来，你可以将中间件添加到请求处理程序中：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We get back your middleware from `TerribleSecurityProvider` and then wrap your
    handler in a series of function calls. This calls the `terribleSecurity` closure
    first, then calls the `RequestTimer`, which then calls your actual request handler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `TerribleSecurityProvider` 获取你的中间件，然后通过一系列函数调用包装你的处理程序。首先调用 `terribleSecurity`
    闭包，然后调用 `RequestTimer`，然后调用你的实际请求处理程序。
- en: 'Because `*http.ServeMux` implements the `http.Handler` interface, you can apply
    a set of middleware to all the handlers registered with a single request router:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `*http.ServeMux` 实现了 `http.Handler` 接口，你可以将一组中间件应用于注册到单个请求路由器的所有处理程序：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can find this code in the *sample_code/middleware* directory in the [Chapter
    13 repository](https://oreil.ly/XOPbD).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [第 13 章仓库](https://oreil.ly/XOPbD) 的 *sample_code/middleware* 目录中找到这段代码。
- en: Use third-party modules to enhance the server
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用第三方模块增强服务器功能。
- en: 'Just because the server is production quality doesn’t mean that you shouldn’t
    use third-party modules to improve its functionality. If you don’t like the function
    chains for middleware, you can use a third-party module called [`alice`](https://oreil.ly/_cS1w),
    which allows you to use the following syntax:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为服务器是生产质量的，并不意味着你不应该使用第三方模块来提升其功能。如果你不喜欢中间件的函数链，可以使用一个名为 [`alice`](https://oreil.ly/_cS1w)
    的第三方模块，它允许你使用以下语法：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While `*http.ServeMux` gained some much-requested features in Go 1.22, its routing
    and variable support are still basic. Nesting `*http.ServeMux` instances is also
    a bit clunky. If you find yourself needing more advanced features, such as routing
    based on a header value, specifying a path variable using a regular expression,
    or better handler nesting, many third-party request routers are available. Two
    of the most popular ones are [gorilla mux](https://oreil.ly/CrQ4i) and [chi](https://oreil.ly/twYcG).
    Both are considered idiomatic because they work with `http.Handler` and `http.HandlerFunc`
    instances, demonstrating the Go philosophy of using composable libraries that
    fit together with the standard library. They also work with idiomatic middleware,
    and both projects provide optional middleware implementations of common concerns.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Go 1.22 中 `*http.ServeMux` 增加了一些广受欢迎的功能，但其路由和变量支持仍然很基础。嵌套 `*http.ServeMux`
    实例也有些笨拙。如果你发现自己需要更高级的功能，比如基于头部值进行路由、使用正则表达式指定路径变量或更好的处理程序嵌套，那么有许多第三方请求路由器可供选择。其中两个最受欢迎的是
    [gorilla mux](https://oreil.ly/CrQ4i) 和 [chi](https://oreil.ly/twYcG)。它们都被认为是惯用的，因为它们与
    `http.Handler` 和 `http.HandlerFunc` 实例配合使用，展示了使用与标准库相容的可组合库的 Go 哲学。它们还与惯用的中间件一起工作，这两个项目还提供了常见问题的可选中间件实现。
- en: Several popular web frameworks also implement their own handler and middleware
    patterns. Two of the most popular are [Echo](https://oreil.ly/7UdEi) and [Gin](https://oreil.ly/vvTve).
    They simplify web development by incorporating features like automating the binding
    of data in requests or responses to JSON. They also provide adapter functions
    that enable you to use `http.Handler` implementations, providing a migration path.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 几个流行的 Web 框架还实现了自己的处理程序和中间件模式。其中两个最受欢迎的是 [Echo](https://oreil.ly/7UdEi) 和 [Gin](https://oreil.ly/vvTve)。它们通过包含自动绑定请求或响应数据到
    JSON 等功能，简化了 Web 开发。它们还提供了适配器函数，使你可以使用 `http.Handler` 实现，提供了迁移路径。
- en: ResponseController
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ResponseController
- en: In [“Accept Interfaces, Return Structs”](ch07.html#accept_interface), you learned
    that modifying interfaces breaks backward compatibility. You also learned that
    you can evolve an interface over time by defining new interfaces and using type
    switches and type assertions to see whether the new interfaces are implemented.
    The drawback to creating these additional interfaces is that it is difficult to
    know that they exist, and using type switches to check for them is verbose.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“接受接口，返回结构体”](ch07.html#accept_interface) 中，你学到了修改接口会破坏向后兼容性。你还学到了可以通过定义新接口并使用类型开关和类型断言来检查是否实现了新接口，随时间演变接口。创建这些额外接口的缺点是很难知道它们的存在，使用类型开关来检查它们也很冗长。
- en: 'You can find an example of this in the `http` package. When the package was
    designed, the choice was made to make `http.ResponseWriter` an interface. This
    meant that additional methods could not be added to it in future releases, or
    the Go Compatibility Guarantee would be broken. To represent new optional functionality
    for an `http.ResponseWriter` instance, the `http` package contains a couple of
    interfaces that may be implemented by `http.ResponseWriter` implementations: `http.Flusher`
    and `http.Hijacker`. The methods on these interfaces are used to control the output
    for a response.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`http`包中找到此类示例。在设计该包时，选择将`http.ResponseWriter`设为接口。这意味着不能在未来的发布版本中向其添加额外的方法，否则将破坏Go兼容性保证。为了表示`http.ResponseWriter`实例的新可选功能，`http`包包含了几个可能由`http.ResponseWriter`实现的接口：`http.Flusher`和`http.Hijacker`。这些接口上的方法用于控制响应的输出。
- en: 'In Go 1.20, a new concrete type was added to the `http` package, `http.ResponseController`.
    It demonstrates another way to expose methods that have been added to an existing
    API:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go 1.20中，`http`包新增了一个具体类型`http.ResponseController`。它展示了向现有API添加方法的另一种方式：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, you want to return data to the client as it is calculated,
    if the `http.ResponseWriter` supports `Flush`. If not, you will return all the
    data after all of it has been calculated. The factory function `http.NewResponseController`
    takes in an `http.ResponseWriter` and returns a pointer to an `http.ResponseController`.
    This concrete type has methods for the optional functionality of an `http.ResponseWriter`.
    You check whether the optional method is implemented by the underlying `http.ResponseWriter`
    by comparing the returned error to `http.ErrNotSupported` using `errors.Is`. You
    can find this code in the *sample_code/response_controller* directory in the [Chapter
    13 repository](https://oreil.ly/XOPbD).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，如果`http.ResponseWriter`支持`Flush`，则需要将计算后的数据即时返回给客户端。否则，在所有数据都计算完毕后再返回。工厂函数`http.NewResponseController`接收一个`http.ResponseWriter`并返回一个指向`http.ResponseController`的指针。这个具体类型具有用于`http.ResponseWriter`可选功能的方法。通过将返回的错误与`http.ErrNotSupported`比较，使用`errors.Is`来检查底层`http.ResponseWriter`是否实现了可选方法。你可以在[第13章存储库](https://oreil.ly/XOPbD)的*sample_code/response_controller*目录中找到这段代码。
- en: 'Because `http.ResponseController` is a concrete type that wraps access to an
    `http.ResponseWriter` implementation, new methods can be added to it over time
    without breaking existing implementations. This makes new functionality discoverable
    and provides a way to check for the presence or absence of an optional method
    with a standard error check. This pattern is an interesting way to handle situations
    where an interface needs to evolve. In fact, `http.ResponseController` contains
    two methods that don’t have corresponding interfaces: `SetReadDeadline` and `SetWriteDeadline`.
    Future optional methods on `http.ResponseWriter` will likely be added via this
    technique.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`http.ResponseController`是一个具体类型，它包装了对`http.ResponseWriter`实现的访问，所以可以随着时间的推移向其添加新方法，而不会破坏现有的实现。这使得新功能可以被发现，并提供了一种标准错误检查的方法来检查可选方法的存在或不存在。这种模式是处理接口需要演变的情况的一种有趣方式。事实上，`http.ResponseController`包含两个没有对应接口的方法：`SetReadDeadline`和`SetWriteDeadline`。未来可能会通过这种技术向`http.ResponseWriter`添加新的可选方法。
- en: Structured Logging
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化日志
- en: Since its initial release, the Go standard library has included a simple logging
    package, `log`. While it’s fine for small programs, it doesn’t easily produce
    *structured* logs. Modern web services can have millions of simultaneous users,
    and at that scale you need software to process log output in order to understand
    what’s going on. A structured log uses a documented format for each log entry,
    making it easier to write programs that process log output and discover patterns
    and anomalies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 自其首次发布以来，Go标准库包含了一个简单的日志包`log`。虽然对于小型程序来说很好用，但它不容易生成*结构化*日志。现代Web服务可能有数百万同时在线用户，在这种规模下，您需要软件来处理日志输出以理解发生的情况。结构化日志使用每个日志条目的文档化格式，使得编写处理日志输出并发现模式和异常的程序变得更加容易。
- en: JSON is commonly used for structured logs, but even whitespace separated key-value
    pairs are easier to process than unstructured logs that don’t separate values
    into fields. While you certainly could write JSON by using the `log` package,
    it doesn’t provide any support for simplifying structured log creation. The `log/slog`
    package resolves this problem.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: JSON通常用于结构化日志，但甚至是使用空格分隔的键值对比起不将值分隔为字段的非结构化日志更易处理。虽然您当然可以通过使用`log`包来编写JSON，但它不提供任何简化结构化日志创建的支持。`log/slog`包解决了这个问题。
- en: Adding `log/slog` to the standard library demonstrated several good Go library
    design practices. The first good decision was to include structured logging in
    the standard library. Having a standard structured logger makes it easier to write
    modules that work together. Several third-party structured loggers have been released
    to address the shortcomings of `log`, including [zap](https://oreil.ly/gkd0p),
    [logrus](https://oreil.ly/7QpFC), [go-kit log](https://oreil.ly/Obk0L), and many
    others. The problem with a fragmented logging ecosystem is that you want control
    over where log output goes and what level of messages are logged. If your code
    depends on third-party modules that use different loggers, this becomes impossible.
    The usual advice to prevent logging fragmentation is to not log in a module intended
    as a library, but that’s impossible to enforce and makes it harder to monitor
    what’s going on in a third-party library. The `log/slog` package was new in Go
    1.21, but the fact that it solves these inconsistencies makes it likely that within
    a few years, it will be used in the vast majority of Go programs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将`log/slog`添加到标准库展示了几个良好的Go库设计实践。第一个良好的决定是在标准库中包含结构化记录。拥有标准化的结构化记录器使得编写协同工作的模块变得更加容易。已发布了几个第三方结构化记录器来解决`log`的不足，包括[zap](https://oreil.ly/gkd0p)，[logrus](https://oreil.ly/7QpFC)，[go-kit
    log](https://oreil.ly/Obk0L)等等。碎片化的记录生态系统的问题在于您希望控制日志输出的位置以及记录的消息级别。如果您的代码依赖于使用不同记录器的第三方模块，这将变得不可能。避免记录分片的通常建议是不要在作为库的模块中记录，但这是不可强制执行的，并且使得监视第三方库中发生的情况更加困难。`log/slog`包在Go
    1.21中是新推出的，但它解决了这些不一致性的事实使得它可能在未来几年内被广泛应用于大多数Go程序中。
- en: The second good decision was to make structured logging its own package and
    not part of the `log` package. While both packages have similar purposes, they
    have very different design philosophies. Trying to add structured logging into
    an unstructured logging package would confuse the API. By making them separate
    packages, you know at a glance that `slog.Info` is a structured log and `log.Print`
    is unstructured, even if you don’t remember whether `Info` is for structured or
    unstructured logging.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个良好的决定是将结构化记录作为其自己的包，而不是`log`包的一部分。尽管这两个包有着类似的目的，但它们有着非常不同的设计哲学。试图将结构化记录添加到非结构化记录包中会混淆API。通过将它们作为独立的包，您一眼就能知道`slog.Info`是结构化记录，而`log.Print`是非结构化记录，即使您记不清`Info`是用于结构化还是非结构化记录。
- en: 'The next good decision was to make the `log/slog` API scalable. It starts simply,
    with a default logger available via functions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个良好的决定是使`log/slog` API可扩展化。它从简单开始，通过函数提供默认记录器：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These functions allow you to log simple messages at various logging levels.
    The output looks like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数允许您以各种记录级别记录简单消息。输出如下所示：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are two things to notice. First, the default logger suppresses debug messages
    by default. You’ll see how to control the logging level when I discuss creating
    your own logger in a bit.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事需要注意。首先，默认记录器默认抑制调试消息。稍后在讨论如何创建自己的记录器时，您将看到如何控制记录级别。
- en: The second point is a bit more subtle. While this is plain-text output, it uses
    whitespace to make a structured log. The first column is the date in year/month/day
    format. The second column is the time in 24-hour time. The third column is the
    logging level. Finally, there is the message.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点则更加微妙。虽然这是纯文本输出，但它利用空白来生成结构化日志。第一列是年/月/日格式的日期。第二列是24小时制的时间。第三列是记录级别。最后是消息内容。
- en: 'The power of structured logging comes from the ability to add fields with custom
    values. Update your logs with some custom fields:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化记录的强大之处在于能够添加具有自定义值的字段。通过一些自定义字段更新您的日志：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You use the same function as before, but now you add optional arguments. Optional
    arguments come in pairs. The first part is the key, which should be a string.
    The second part is the value. This log line prints out the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像之前一样使用相同的函数，但现在可以添加可选参数。可选参数成对出现。第一部分是键，应为字符串。第二部分是值。此日志行输出以下内容：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After the message, you have key-value pairs, again space separated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息之后，你有键-值对，再次以空格分隔。
- en: 'While this text format is far easier to parse than an unstructured log, you
    might want to use something like JSON instead. You also might want to customize
    where the log is written or the logging level. To do that, you create a structured
    logging instance:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种文本格式比非结构化日志更容易解析，但你可能希望使用类似JSON的东西。你可能还希望自定义日志的写入位置或日志级别。为此，你可以创建一个结构化日志实例：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You are using the `slog.HandlerOptions` struct to define the minimum logging
    level for the new logger. You then use the `NewJSONHandler` method on `slog.HandlerOptions`
    to create a `slog.Handler` that writes logs using JSON to the specified `io.Writer`.
    In this case, you are using the standard error output. Finally, you use the `slog.New`
    function to create a `*slog.Logger` that wraps the `slog.Handler`. You then create
    a `lastLogin` value to log, along with a user ID. This gives the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用`slog.HandlerOptions`结构来定义新日志记录器的最低日志级别。然后，你使用`slog.HandlerOptions`上的`NewJSONHandler`方法来创建一个`slog.Handler`，将日志使用JSON写入指定的`io.Writer`。在这种情况下，你使用标准错误输出。最后，你使用`slog.New`函数创建一个包装了`slog.Handler`的`*slog.Logger`。然后，你创建一个`lastLogin`值来记录，还有一个用户ID。这将产生以下输出：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If JSON and text aren’t sufficient for your output needs, you can define your
    own implementation of the `slog.Handler` interface and pass it to `slog.New`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JSON和文本不能满足你的输出需求，你可以定义自己实现`slog.Handler`接口的实现，并将其传递给`slog.New`。
- en: 'Finally, the `log/slog` package takes performance into consideration. If you
    aren’t careful, your program might end up spending more time writing logs than
    doing the work it was designed to perform. You can choose to write data out to
    `log/slog` in a number of ways. You have already seen the simplest (but slowest)
    method, using alternating keys and values on the `Debug`, `Info`, `Warn`, and
    `Error` methods. For improved performance with fewer allocations, use the `LogAttrs`
    method instead:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`log/slog`包考虑了性能问题。如果你不小心，你的程序可能会花更多时间写日志，而不是执行它设计进行的工作。你可以选择以多种方式将数据写入`log/slog`。你已经看到了最简单（但最慢）的方法，即在`Debug`、`Info`、`Warn`和`Error`方法上交替使用键和值。为了提高性能并减少分配次数，建议使用`LogAttrs`方法：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first parameter is a `context.Context`, next comes the logging level, and
    then zero or more `slog.Attr` instances. There are factory functions for the most
    commonly used types, and you can use `slog.Any` for the ones that don’t have functions
    already supplied.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`context.Context`，接下来是日志级别，然后是零个或多个`slog.Attr`实例。对于最常用的类型，有工厂函数可用，对于没有提供函数的类型，你可以使用`slog.Any`。
- en: 'Because of the Go Compatibility Promise, the `log` package isn’t going away.
    Existing programs that use it will continue to work, as will programs that use
    third-party structured loggers. If you have code that uses a `log.Logger`, the
    `slog.NewLogLogger` function provides a bridge to the original `log` package.
    It creates a `log.Logger` instance that uses a `slog.Handler` to write its output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性承诺，`log`包不会被移除。使用它的现有程序将继续工作，同样适用于使用第三方结构化日志记录器的程序。如果你的代码使用了`log.Logger`，`slog.NewLogLogger`函数提供了一个桥接到原始`log`包的方法。它创建一个使用`slog.Handler`来写输出的`log.Logger`实例：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This produces the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can find all the coding examples for `log/slog` in the *sample_code/structured_logging*
    directory in the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第13章代码库](https://oreil.ly/XOPbD)的*sample_code/structured_logging*目录中找到所有`log/slog`的编码示例。
- en: The `log/slog` API includes more features, including dynamic logging-level support,
    context support (the context is covered in [Chapter 14](ch14.html#unique_chapter_id_14)),
    grouping values, and creating a common header of values. You can learn more by
    looking at its [API documentation](https://oreil.ly/LRhGf). Most importantly,
    look at how `log/slog` was put together so you can learn how to construct APIs
    of your own.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`log/slog` API包括更多功能，包括动态日志级别支持、上下文支持（上下文在[第14章](ch14.html#unique_chapter_id_14)中讨论），值分组和创建共同的值头。你可以通过查看其[API文档](https://oreil.ly/LRhGf)来了解更多信息。最重要的是，看看`log/slog`是如何组合的，以便学习如何构建自己的API。'
- en: Exercises
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you’ve learned more about the standard library, work through these
    exercises to reinforce what you’ve learned. Solutions are in the *exercise_solutions*
    directory of the [Chapter 13 repository](https://oreil.ly/XOPbD).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更多地了解了标准库，通过这些练习来巩固你所学的知识。解决方案在[第13章代码库](https://oreil.ly/XOPbD)的*exercise_solutions*目录中。
- en: Write a small web server that returns the current time in RFC 3339 format when
    you send it a `GET` command. You can use a third-party module if you’d like.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小的Web服务器，当你发送`GET`命令时返回当前时间的RFC 3339格式。如果愿意，可以使用第三方模块。
- en: Write a small middleware component that uses JSON structured logging to log
    the IP address of each incoming request to your web server.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小的中间件组件，使用JSON结构化日志记录每个传入请求到你的Web服务器的IP地址。
- en: 'Add the ability to return the time as JSON. Use the `Accept` header to control
    whether JSON or text is returned (default to text). The JSON should be structured
    as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以JSON格式返回时间的功能。使用`Accept`头来控制返回JSON还是文本（默认为文本）。JSON应按以下结构进行组织：
- en: '[PRE52]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Wrapping Up
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: 'In this chapter, you looked at some of the most commonly used packages in the
    standard library and saw how they embody best practices that should be emulated
    in your code. You’ve also seen other sound software engineering principles: how
    some decisions might have been made differently given experience, and how to respect
    backward compatibility so you can build applications on a solid foundation.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了标准库中一些最常用的包，并了解了它们如何体现应在你的代码中效仿的最佳实践。你还看到了其他合理的软件工程原则：在经验丰富的情况下可能会做出不同的决策，以及如何尊重向后兼容性，从而可以在坚实的基础上构建应用程序。
- en: In the next chapter, you’re going to look at the context, a package and pattern
    for passing state and timers through Go code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到上下文、通过Go代码传递状态和计时器的包和模式。
