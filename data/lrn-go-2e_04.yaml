- en: Chapter 4\. Blocks, Shadows, and Control Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。块、遮蔽和控制结构
- en: 'Now that I have covered variables, constants, and built-in types, you are ready
    to look at programming logic and organization. I’ll start by explaining blocks
    and how they control when an identifier is available. Then I’ll present Go’s control
    structures: `if`, `for`, and `switch`. Finally, I will talk about `goto` and the
    one situation when you should use it.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讲解了变量、常量和内置类型，你已经准备好学习编程逻辑和组织了。我将首先解释块及其控制标识符何时可用。然后我会介绍Go语言的控制结构：`if`、`for`和`switch`。最后，我将讨论`goto`及其唯一应用场景。
- en: Blocks
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块
- en: Go lets you declare variables in lots of places. You can declare them outside
    of functions, as the parameters to functions, and as local variables within functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多地方，Go语言允许你声明变量。你可以在函数外部声明它们，作为函数的参数，以及在函数内部作为局部变量。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: So far, you’ve written only the `main` function, but you’ll write functions
    with parameters in the next chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只写了`main`函数，但在下一章节中你将编写带参数的函数。
- en: Each place where a declaration occurs is called a *block*. Variables, constants,
    types, and functions declared outside of any functions are placed in the *package*
    block. You’ve used `import` statements in your programs to gain access to printing
    and math functions (and I will talk about them in detail in [Chapter 10](ch10.html#unique_chapter_id_10)).
    They define names for other packages that are valid for the file that contains
    the `import` statement. These names are in the *file* block. All the variables
    defined at the top level of a function (including the parameters to a function)
    are in a block. Within a function, every set of braces (`{}`) defines another
    block, and in a bit you will see that the control structures in Go define blocks
    of their own.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每次声明发生的地方称为*块*。变量、常量、类型和在任何函数外声明的函数位于*包* 块中。你在程序中使用`import`语句来访问打印和数学函数（我将在[第10章](ch10.html#unique_chapter_id_10)详细讨论它们）。它们为其他包定义了在包含`import`语句的文件中有效的名称。这些名称位于*文件*
    块中。函数的顶级所有变量（包括函数的参数）都位于一个块中。在函数内部，每一组大括号（`{}`）定义另一个块，在稍后你将看到Go语言中的控制结构定义了它们自己的块。
- en: 'You can access an identifier defined in any outer block from within any inner
    block. This raises the question: what happens when you have a declaration with
    the same name as an identifier in a containing block? If you do that, you *shadow*
    the identifier created in the outer block.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从任何外部块中访问在其中一个内部块中定义的标识符。这引出了一个问题：当你在一个包含块中有一个与标识符同名的声明时会发生什么？如果这样做，你会*遮蔽*
    外部块中创建的标识符。
- en: Shadowing Variables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮蔽变量
- en: Before I explain what shadowing is, let’s take a look at some code (see [Example 4-1](#EX3_1-2)).
    You can run it on [The Go Playground](https://oreil.ly/50t6b) or in the *sample_code/shadow_variables*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释什么是遮蔽之前，让我们看一些代码（参见[示例4-1](#EX3_1-2)）。你可以在[The Go Playground](https://oreil.ly/50t6b)上运行它，或者在[第4章示例代码/遮蔽变量](https://oreil.ly/Fqw5B)目录中的仓库中运行它。
- en: Example 4-1\. Shadowing variables
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-1。遮蔽变量
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before you run this code, try to guess what it’s going to print out:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 'Before you run this code, try to guess what it’s going to print out:'
- en: Nothing prints; the code does not compile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么也不打印；代码无法编译
- en: 10 on line one, 5 on line two, 5 on line three
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 on line one, 5 on line two, 5 on line three
- en: 10 on line one, 5 on line two, 10 on line three
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 on line one, 5 on line two, 10 on line three
- en: 'Here’s what happens:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是发生的事情：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A *shadowing variable* is a variable that has the same name as a variable in
    a containing block. For as long as the shadowing variable exists, you cannot access
    a shadowed variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*遮蔽变量* 是指与包含块中的变量同名的变量。只要遮蔽变量存在，就无法访问被遮蔽的变量。'
- en: In this case, you almost certainly didn’t want to create a brand-new `x` inside
    the `if` statement. Instead, you probably wanted to assign 5 to the `x` declared
    at the top level of the function block. At the first `fmt.Println` inside the
    `if` statement, you are able to access the `x` declared at the top level of the
    function. On the next line, though, you *shadow* `x` by *declaring a new variable
    with the same name* inside the block created by the `if` statement’s body. At
    the second `fmt.Println`, when you access the variable named `x`, you get the
    shadowing variable, which has the value of 5\. The closing brace for the `if`
    statement’s body ends the block where the shadowing `x` exists, and at the third
    `fmt.Println`, when you access the variable named `x`, you get the variable declared
    at the top level of the function, which has the value of 10\. Notice that this
    `x` didn’t disappear or get reassigned; there was just no way to access it once
    it was shadowed in the inner block.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你几乎肯定不想在`if`语句内部创建一个全新的`x`。相反，你可能想要将5赋给函数块顶层声明的`x`。在`if`语句内部的第一个`fmt.Println`处，你可以访问函数块顶层声明的`x`。然而，在接下来的一行中，你通过在`if`语句体内部创建的块中*声明同名新变量*来*遮蔽*了`x`。在第二个`fmt.Println`处，当你访问名为`x`的变量时，你得到的是具有值5的遮蔽变量。`if`语句体的闭合括号结束了包含遮蔽`x`的块，在第三个`fmt.Println`处，当你访问名为`x`的变量时，你得到的是函数顶层声明的变量，其值为10。注意，这个`x`并没有消失或被重新赋值；一旦在内部块中遮蔽了它，就无法访问它。
- en: I mentioned in the previous chapter that in some situations I avoid using `:=`
    because it can make it unclear what variables are being used. That’s because it
    is very easy to accidentally shadow a variable when using `:=`. Remember, you
    can use `:=` to create and assign to multiple variables at once. Also, not all
    variables on the lefthand side have to be new for `:=` to be legal. You can use
    `:=` as long as there is at least one new variable on the lefthand side. Let’s
    look at another program (see [Example 4-2](#EX3_2)), which you can find on [The
    Go Playground](https://oreil.ly/U_m4B) or in the *sample_code/shadow_multiple_assignment*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上一章提到过，在某些情况下，我避免使用`:=`，因为这可能会使使用的变量不清晰。这是因为在使用`:=`时很容易意外地遮蔽一个变量。记住，你可以使用`:=`同时创建和赋值多个变量。此外，左侧并不是所有变量都必须是新变量才能合法使用`:=`。让我们看另一个程序（见[示例 4-2](#EX3_2)），你可以在[The
    Go Playground](https://oreil.ly/U_m4B)或[第4章代码库](https://oreil.ly/Fqw5B)的*sample_code/shadow_multiple_assignment*目录中找到它。
- en: Example 4-2\. Shadowing with multiple assignment
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 使用多重赋值进行遮蔽
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this code gives you the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会得到以下结果：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although there was an existing definition of `x` in an outer block, `x` was
    still shadowed within the `if` statement. That’s because `:=` reuses only variables
    that are declared in the current block. When using `:=`, make sure that you don’t
    have any variables from an outer scope on the lefthand side unless you intend
    to shadow them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管外部块中存在`x`的定义，但`x`仍然在`if`语句内部被遮蔽了。这是因为`:=`只重新使用当前块中声明的变量。在使用`:=`时，请确保左侧没有来自外部作用域的变量，除非你打算遮蔽它们。
- en: You also need to be careful to ensure that you don’t shadow a package import.
    I’ll talk more about importing packages in [Chapter 10](ch10.html#unique_chapter_id_10),
    but you’ve been importing the `fmt` package to print out results of our programs.
    Let’s see what happens when you declare a variable called `fmt` within your `main`
    function, as shown in [Example 4-3](#EX3_3). You can try to run it on [The Go
    Playground](https://oreil.ly/CKQvm) or in the *sample_code/shadow_package_names*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要注意确保不要遮蔽导入的包。我会在[第10章](ch10.html#unique_chapter_id_10)更详细地讨论导入包的内容，但你一直在导入`fmt`包来打印我们程序的结果。让我们看看当你在`main`函数内部声明一个名为`fmt`的变量时会发生什么，正如[示例 4-3](#EX3_3)所示。你可以在[The
    Go Playground](https://oreil.ly/CKQvm)或[第4章代码库](https://oreil.ly/Fqw5B)的*sample_code/shadow_package_names*目录中尝试运行它。
- en: Example 4-3\. Shadowing package names
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 遮蔽包名
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you try to run this code, you get an error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试运行这段代码时，会得到一个错误：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the problem isn’t that you named your variable `fmt`; it’s that
    you tried to access something that the local variable `fmt` didn’t have. Once
    the local variable `fmt` is declared, it shadows the package named `fmt` in the
    file block, making it impossible to use the `fmt` package for the rest of the
    `main` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意问题不是你将变量命名为`fmt`，而是你尝试访问本地变量`fmt`没有的内容。一旦声明了本地变量`fmt`，它将屏蔽文件块中的`fmt`包，使得在`main`函数的其余部分中无法使用`fmt`包。
- en: Since shadowing is useful in a few instances (later chapters will point them
    out), `go vet` does not report it as a likely error. In [“Using Code-Quality Scanners”](ch11.html#code_quality),
    you’ll learn about third-party tools that can detect accidental shadowing in your
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在某些情况下屏蔽是有用的（稍后章节将指出），`go vet`不会将其报告为可能的错误。在[“使用代码质量扫描工具”](ch11.html#code_quality)中，您将学习有关可以检测代码中意外屏蔽的第三方工具。
- en: if
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if
- en: The `if` statement in Go is much like the `if` statement in most programming
    languages. Because it is such a familiar construct, I’ve used it in previous sample
    code without worrying that it’d be confusing. [Example 4-5](#EX3_5) shows a more
    complete sample.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`if`语句与大多数编程语言中的`if`语句非常相似。因为它是如此熟悉的结构，所以我在之前的示例代码中使用它时并不担心会造成困惑。[示例 4-5](#EX3_5)展示了一个更完整的示例。
- en: Example 4-5\. `if` and `else`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. `if`和`else`
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The most visible difference between `if` statements in Go and other languages
    is that you don’t put parentheses around the condition. But Go adds another feature
    to `if` statements that helps you better manage your variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go中`if`语句与其他语言的最显著区别是你不需要在条件周围加括号。但Go在`if`语句中添加了另一个功能，帮助您更好地管理变量。
- en: As I discussed in [“Shadowing Variables”](#shadowing), any variable declared
    within the braces of an `if` or `else` statement exists only within that block.
    This isn’t that uncommon; it is true in most languages. What Go adds is the ability
    to declare variables that are scoped to the condition and to both the `if` and
    `else` blocks. Take a look at [Example 4-6](#EX3_6), which rewrites our previous
    example to use this scope.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“变量屏蔽”](#shadowing)中所讨论的，任何在`if`或`else`语句的大括号内声明的变量仅存在于该块中。这并不罕见；大多数语言都是如此。Go增加的是能够声明仅在条件和`if`以及`else`块中有效的变量。看看[示例 4-6](#EX3_6)，它重新编写了我们先前的示例以使用这种作用域。
- en: Example 4-6\. Scoping a variable to an `if` statement
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 将变量作用域限制为`if`语句
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Having this special scope is handy. It lets you create variables that are available
    only where they are needed. Once the series of `if/else` statements ends, `n`
    is undefined. You can test this by trying to run the code in [Example 4-7](#EX3_6-2)
    on [The Go Playground](https://oreil.ly/rz671) or in the *sample_code/if_bad_scope*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这种特殊作用域非常方便。它允许你创建仅在需要时可用的变量。一旦`if/else`语句系列结束，`n`就变得未定义。你可以尝试在[示例 4-7](#EX3_6-2)中的[Go
    Playground](https://oreil.ly/rz671)或[第 4 章代码库](https://oreil.ly/Fqw5B)中的*sample_code/if_bad_scope*目录运行此代码来测试。
- en: Example 4-7\. Out of scope…​
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 超出范围…​
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Attempting to run this code produces a compilation error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行此代码会产生编译错误：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, you can put any *simple statement* before the comparison in an
    `if` statement—including a function call that doesn’t return a value or an assignment
    of a new value to an existing variable. But don’t do this. Use this feature only
    to define new variables that are scoped to the `if/else` statements; anything
    else would be confusing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，您可以在`if`语句中的比较之前放置任何*简单语句*，包括不返回值的函数调用或将新值分配给现有变量。但不要这样做。只使用此功能定义仅限于`if/else`语句的新变量；其他任何操作都可能会令人困惑。
- en: Also be aware that just like any other block, a variable declared as part of
    an `if` statement will shadow variables with the same name that are declared in
    containing blocks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，就像任何其他块一样，作为`if`语句的一部分声明的变量将屏蔽包含块中具有相同名称的变量。
- en: for, Four Ways
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四种`for`
- en: 'As in other languages in the C family, Go uses a `for` statement to loop. What
    makes Go different from other languages is that `for` is the *only* looping keyword
    in the language. Go accomplishes this by using the `for` keyword in four formats:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言家族中的其他语言一样，Go使用`for`语句进行循环。使Go与其他语言不同的是，`for`是该语言中*唯一*的循环关键字。Go通过四种格式使用`for`关键字来实现这一点：
- en: A complete, C-style `for`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的，类似C风格的`for`
- en: A condition-only `for`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅有条件的`for`
- en: An infinite `for`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无限的`for`
- en: '`for-range`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-range`'
- en: The Complete for Statement
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的`for`语句
- en: The first `for` loop style is the complete `for` declaration you might be familiar
    with from C, Java, or JavaScript, as shown in [Example 4-8](#EX3_8-1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `for` 循环风格是你可能从 C、Java 或 JavaScript 中熟悉的完整 `for` 声明，如 [示例 4-8](#EX3_8-1)
    所示。
- en: Example 4-8\. A complete `for` statement
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 一个完整的 `for` 语句
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might be unsurprised to find that this program prints out the numbers from
    0 to 9, inclusive.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对发现这个程序打印出从 0 到 9 的数字感到不惊讶。
- en: Just like the `if` statement, the `for` statement does not use parentheses around
    its parts. Otherwise, it should look familiar. The `if` statement has three parts,
    separated by semicolons. The first part is an initialization that sets one or
    more variables before the loop begins. You should remember two important details
    about the initialization section. First, you *must* use `:=` to initialize the
    variables; `var` is *not* legal here. Second, just as variable declarations in
    `if` statements, you can shadow a variable here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `if` 语句一样，`for` 语句在其各部分周围不使用括号。否则，它看起来应该很熟悉。`if` 语句有三个部分，用分号分隔。第一部分是初始化，在循环开始前设置一个或多个变量。关于初始化部分，你应该记住两个重要的细节。首先，你必须使用
    `:=` 来初始化变量；在这里不合法使用 `var`。其次，就像 `if` 语句中的变量声明一样，你可以在这里遮蔽一个变量。
- en: The second part is the comparison. This must be an expression that evaluates
    to a `bool`. It is checked immediately *before* each iteration of the loop. If
    the expression evaluates to `true`, the loop body is executed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是比较。这必须是一个评估为 `bool` 的表达式。它在每次循环迭代之前立即检查。如果表达式评估为 `true`，则执行循环体。
- en: The last part of a standard `for` statement is the increment. You usually see
    something like `i{plus}{plus}` here, but any assignment is valid. It runs immediately
    after each iteration of the loop, before the condition is evaluated.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 `for` 语句的最后部分是增量。通常你会在这里看到像 `i++` 这样的东西，但任何赋值都是有效的。它在每次循环迭代之后立即运行，然后再评估条件。
- en: 'Go allows you to leave out one or more of the three parts of the `for` statement.
    Most commonly, you’ll either leave off the initialization if it is based on a
    value calculated before the loop:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你省略 `for` 语句的三个部分中的一个或多个。最常见的情况是，如果它是基于循环前计算的值：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'or you’ll leave off the increment because you have a more complicated increment
    rule inside the loop:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你会因为在循环内有更复杂的增量规则而省略增量：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Condition-Only for Statement
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅有条件的 `for` 语句
- en: When you leave off both the initialization and the increment in a `for` statement,
    do not include the semicolons. (If you do, `go fmt` will remove them.) That leaves
    a `for` statement that functions like the `while` statement found in C, Java,
    JavaScript, Python, Ruby, and many other languages. It looks like [Example 4-9](#EX3_9-1).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `for` 语句中省略初始化和增量时，请不要包含分号。（如果你这样做，`go fmt` 会将它们删除。）这留下了一个像在 C、Java、JavaScript、Python、Ruby
    和许多其他语言中找到的 `while` 语句一样工作的 `for` 语句。看起来像 [示例 4-9](#EX3_9-1)。
- en: Example 4-9\. A condition-only `for` statement
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 仅有条件的 `for` 语句
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Infinite for Statement
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限 `for` 语句
- en: 'The third `for` statement format does away with the condition too. Go has a
    version of a `for` loop that loops forever. If you learned to program in the 1980s,
    your first program was probably an infinite loop in BASIC that printed `HELLO`
    to the screen forever:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种 `for` 语句格式也取消了条件。Go 有一个版本的 `for` 循环，永远循环。如果你在 1980 年代学习编程，你的第一个程序可能是在 BASIC
    中的一个无限循环，永远打印 `HELLO` 到屏幕上：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 4-10](#EX3_10-2) shows the Go version of this program. You can run
    it locally or try it out on [The Go Playground](https://oreil.ly/whOi-) or in
    the *sample_code/infinite_for* directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-10](#EX3_10-2) 展示了这个程序的 Go 版本。你可以在本地运行它，或者在 [The Go Playground](https://oreil.ly/whOi-)
    或 [第 4 章存储库](https://oreil.ly/Fqw5B) 的 *sample_code/infinite_for* 目录中试用它。'
- en: Example 4-10\. Infinite looping nostalgia
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 无限循环怀旧
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running this program gives you the same output that filled the screens of millions
    of Commodore 64s and Apple ][s:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序会给你同样的输出，这个输出填满了数百万台 Commodore 64 和 Apple ][ 的屏幕：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Press Ctrl-C when you are tired of walking down memory lane.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你厌倦了走在记忆的长廊上时，请按 Ctrl-C。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you run [Example 4-10](#EX3_10-2) on The Go Playground, you’ll find that
    it will stop execution after a few seconds. As a shared resource, the playground
    doesn’t allow any one program to run for too long.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 The Go Playground 上运行 [示例 4-10](#EX3_10-2)，你会发现它会在几秒钟后停止执行。作为共享资源，Playground
    不允许任何一个程序运行太长时间。
- en: break and continue
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: break 和 continue
- en: How do you get out of an infinite `for` loop without using the keyboard or turning
    off your computer? That’s the job of the `break` statement. It exits the loop
    immediately, just like the `break` statement in other languages. Of course, you
    can use `break` with any `for` statement, not just the infinite `for` statement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在不使用键盘或关闭计算机的情况下退出无限`for`循环？这是`break`语句的任务。它立即退出循环，就像其他语言中的`break`语句一样。当然，你可以在任何`for`语句中使用`break`，不仅限于无限`for`语句。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Go has no equivalent of the `do` keyword in Java, C, and JavaScript. If you
    want to iterate at least once, the cleanest way is to use an infinite `for` loop
    that ends with an `if` statement. If you have some Java code, for example, that
    uses a `do/while` loop:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java、C和JavaScript中，Go没有等同于`do`关键字。如果你想至少迭代一次，最简洁的方法是使用以`if`语句结束的无限`for`循环。例如，如果你有一些Java代码使用了`do/while`循环：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'the Go version looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Go版本如下：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the condition has a leading `!` to *negate* the condition from the
    Java code. The Go code is specifying how to *exit* the loop, while the Java code
    specifies how to stay in it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意条件前面有一个`!`用于*否定*Java代码中的条件。Go代码指定如何*退出*循环，而Java代码则指定如何*保持*在循环中。
- en: Go also includes the `continue` keyword, which skips over the rest of the `for`
    loop’s body and proceeds directly to the next iteration. Technically, you don’t
    need a `continue` statement. You could write code like [Example 4-11](#EX3_11-2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go还包括`continue`关键字，它跳过`for`循环的其余部分，直接进入下一次迭代。技术上，你不需要`continue`语句。你可以像[示例4-11](#EX3_11-2)那样编写代码。
- en: Example 4-11\. Confusing code
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-11\. 令人困惑的代码
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But this is not idiomatic. Go encourages short `if` statement bodies, as left-aligned
    as possible. Nested code is more difficult to follow. Using a `continue` statement
    makes it easier to understand what’s going on. [Example 4-12](#EX3_12-2) shows
    the code from the previous example, rewritten to use `continue` instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是惯用写法。Go鼓励短小的`if`语句体，尽可能左对齐。嵌套代码更难以跟踪。使用`continue`语句使理解正在发生的事情变得更容易。[示例4-12](#EX3_12-2)展示了从前面示例中重写为使用`continue`的代码。
- en: Example 4-12\. Using `continue` to make code clearer
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-12\. 使用`continue`使代码更清晰
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, replacing chains of `if/else` statements with a series of `if`
    statements that use `continue` makes the conditions line up. This improves the
    layout of your conditions, which means your code is easier to read and understand.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，用一系列使用`continue`语句的`if`语句来替换`if/else`语句链，可以使条件对齐。这改善了条件的布局，意味着你的代码更易读和理解。
- en: The for-range Statement
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for-range`语句'
- en: The fourth `for` statement format is for iterating over elements in some of
    Go’s built-in types. It is called a `for-range` loop and resembles the iterators
    found in other languages. This section shows how to use a `for-range` loop with
    strings, arrays, slices, and maps. When I cover channels in [Chapter 12](ch12.html#unique_chapter_id_12),
    I will talk about how to use them with `for-range` loops.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个`for`语句格式用于遍历一些Go内置类型中的元素。它被称为`for-range`循环，类似于其他语言中的迭代器。本节展示如何在字符串、数组、切片和映射中使用`for-range`循环。当我在[第12章](ch12.html#unique_chapter_id_12)中讲解通道时，我会讨论如何在其中使用`for-range`循环。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a `for-range` loop only to iterate over the built-in compound types
    and user-defined types that are based on them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能用`for-range`循环来迭代内置复合类型和基于它们的用户定义类型。
- en: First, let’s take a look at using a `for-range` loop with a slice. You can try
    out the code in [Example 4-13](#EX4_13) on [The Go Playground](https://oreil.ly/XwuTL)
    or in the `forRangeKeyValue` function in *main.go* in the *sample_code/for_range*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在切片中使用`for-range`循环。你可以在[示例4-13](#EX4_13)中尝试这段代码，也可以在[Go Playground](https://oreil.ly/XwuTL)或[第4章代码库](https://oreil.ly/Fqw5B)的*sample_code/for_range*目录中的*main.go*中的`forRangeKeyValue`函数中进行尝试。
- en: Example 4-13\. The `for-range` loop
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-13\. `for-range`循环
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running this code produces the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What makes a `for-range` loop interesting is that you get two loop variables.
    The first variable is the position in the data structure being iterated, while
    the second is the value at that position. The idiomatic names for the two loop
    variables depend on what is being looped over. When looping over an array, slice,
    or string, an `i` for *index* is commonly used. When iterating through a map,
    `k` (for *key*) is used instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使 `for-range` 循环有趣的是你会得到两个循环变量。第一个变量是正在迭代的数据结构中的位置，而第二个变量是该位置上的值。这两个循环变量的惯用名称取决于正在循环的内容。当遍历数组、切片或字符串时，通常使用
    `i` 作为 *index*。当遍历映射时，则使用 `k`（表示 *key*）。
- en: The second variable is frequently called `v` for *value*, but is sometimes given
    a name based on the type of the values being iterated. Of course, you can give
    the variables any names that you like. If the body of the loop contains only a
    few statements, single-letter variable names work well. For longer (or nested)
    loops, you’ll want to use more descriptive names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量通常称为 `v`，表示 *value*，但有时会根据正在迭代的值的类型命名。当然，你可以给变量任意名称。如果循环体只包含几条语句，单字母变量名效果很好。对于更长（或嵌套的）循环，应使用更具描述性的名称。
- en: What if you don’t need to use the first variable within your `for-range` loop?
    Remember, Go requires you to access all declared variables, and this rule applies
    to the ones declared as part of a `for` loop too. If you don’t need to access
    the key, use an underscore (`_`) as the variable’s name. This tells Go to ignore
    the value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `for-range` 循环中不需要使用第一个变量怎么办？请记住，Go 要求你访问所有声明的变量，这条规则也适用于 `for` 循环中声明的变量。如果你不需要访问键，可以使用下划线
    (`_`) 作为变量名。这告诉 Go 忽略该值。
- en: Let’s rewrite the slice ranging code to not print out the position. You can
    run the code in [Example 4-14](#EX3_14) on [The Go Playground](https://oreil.ly/2fO12)
    or in the `forRangeIgnoreKey` function in *main.go* in the *sample_code/for_range*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写切片遍历代码，不打印位置信息。你可以在 [示例 4-14](#EX3_14) 中运行代码，也可以在 [Go Playground](https://oreil.ly/2fO12)
    上运行，或者在 [第 4 章代码库](https://oreil.ly/Fqw5B) 的 *sample_code/for_range* 目录中的 *main.go*
    中的 `forRangeIgnoreKey` 函数中运行。
- en: Example 4-14\. Ignoring the slice index in a `for-range` loop
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 在 `for-range` 循环中忽略切片索引
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this code produces the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Anytime you are in a situation where a value is returned, but you want to ignore
    it, use an underscore to hide the value. You’ll see the underscore pattern again
    when I talk about functions in [Chapter 5](ch05.html#unique_chapter_id_05) and
    packages in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何返回值但要忽略它的情况下，请使用下划线来隐藏值。当我在 [第 5 章](ch05.html#unique_chapter_id_05) 谈到函数和
    [第 10 章](ch10.html#unique_chapter_id_10) 谈到包时，你会再次看到下划线的模式。
- en: 'What if you want the key but don’t want the value? In this situation, Go allows
    you to just leave off the second variable. This is valid Go code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要键而不想要值怎么办？在这种情况下，Go 允许你只留下第二个变量。这是有效的 Go 代码：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The most common reason for iterating over the key is when a map is being used
    as a set. In those situations, the value is unimportant. However, you can also
    leave off the value when iterating over arrays or slices. This is rare, as the
    usual reason for iterating over a linear data structure is to access the data.
    If you find yourself using this format for an array or slice, there’s an excellent
    chance that you have chosen the wrong data structure and should consider refactoring.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历键的最常见原因是在映射用作集时。在这些情况下，值并不重要。然而，当遍历数组或切片时，也可以省略值。这种情况很少见，因为遍历线性数据结构的常见原因是访问数据。如果你发现自己在数组或切片上使用此格式，很可能选择了错误的数据结构，应考虑重构。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you look at channels in [Chapter 12](ch12.html#unique_chapter_id_12), you’ll
    see a situation where a `for-range` loop returns only a single value each time
    the loop iterates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [第 12 章](ch12.html#unique_chapter_id_12) 看 channels 时，你会看到 `for-range` 循环每次迭代只返回单个值的情况。
- en: Iterating over maps
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历映射
- en: There’s something interesting about how a `for-range` loop iterates over a map.
    You can run the code in [Example 4-15](#example4_15) on [The Go Playground](https://oreil.ly/VplnA)
    or in the *sample_code/iterate_map* directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-range` 循环遍历映射的方式非常有趣。你可以在 [示例 4-15](#example4_15) 中运行代码，也可以在 [Go Playground](https://oreil.ly/VplnA)
    上运行，或者在 [第 4 章代码库](https://oreil.ly/Fqw5B) 的 *sample_code/iterate_map* 目录中运行。'
- en: Example 4-15\. Map iteration order varies
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. Map 迭代顺序变化
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you build and run this program, the output varies. Here is one possibility:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建并运行这个程序时，输出会有所不同。以下是一种可能性：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The order of the keys and values varies; some runs may be identical. This is
    actually a security feature. In earlier Go versions, the iteration order for keys
    in a map was usually (but not always) the same if you inserted the same items
    into a map. This caused two problems:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值的顺序变化；某些运行可能是相同的。这实际上是一个安全功能。在早期的 Go 版本中，如果你向 map 中插入相同的项，键的迭代顺序通常（但不总是）是相同的。这导致了两个问题：
- en: People would write code that assumed that the order was fixed, and this code
    would break at weird times.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们可能编写假设顺序固定的代码，但这些代码会在奇怪的时候出错。
- en: If maps always hash items to the exact same values, and you know that a server
    is storing user data in a map, you can slow down a server with an attack called
    *Hash DoS* by sending it specially crafted data with keys that all hash to the
    same bucket.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 map 总是将项哈希到完全相同的值，并且你知道服务器在 map 中存储用户数据，你可以通过发送具有所有哈希到同一个桶的密钥的特殊制作数据来减慢服务器，这称为
    *Hash DoS* 攻击。
- en: To prevent both of these problems, the Go team made two changes to the map implementation.
    First, they modified the hash algorithm for maps to include a random number that’s
    generated every time a map variable is created. Next, they made the order of a
    `for-range` iteration over a map vary a bit each time the map is looped over.
    These two changes make it far harder to implement a Hash DoS attack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这两个问题，Go 团队对 map 实现进行了两个更改。首先，他们修改了 map 的哈希算法，以包括每次创建 map 变量时生成的随机数。其次，他们使得
    `for-range` 在 map 上的迭代顺序每次都有所变化。这两个变化使得实现 Hash DoS 攻击变得更加困难。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This rule has one exception. To make it easier to debug and log maps, the formatting
    functions (like `fmt.Println`) always output maps with their keys in ascending
    sorted order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个例外。为了更容易调试和记录 map，格式化函数（如 `fmt.Println`）总是按升序输出它们的键。
- en: Iterating over strings
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代字符串
- en: As I mentioned earlier, you can also use a string with a `for-range` loop. Let’s
    take a look. You can run the code in [Example 4-16](#EX3_15) on your computer
    or on [The Go Playground](https://oreil.ly/C3LRy) or in the *sample_code/iterate_string*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你也可以使用 `for-range` 循环来处理字符串。让我们来看看。你可以在你的计算机上或者在[The Go Playground](https://oreil.ly/C3LRy)或在[第四章仓库](https://oreil.ly/Fqw5B)的*sample_code/iterate_string*目录中运行[示例
    4-16](#EX3_15)中的代码。
- en: Example 4-16\. Iterating over strings
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 迭代字符串
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output when the code iterates over the word “hello” has no surprises:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码迭代单词“hello”时，输出没有什么意外：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the first column is the index; in the second, the numeric value of the letter;
    and in the third is the numeric value of the letter type converted to a string.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一列是索引；第二列是字母的数值；第三列是转换为字符串的字母类型的数值。
- en: 'Looking at the result for “apple_π!” is more interesting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 查看“apple_π!”的结果更有趣：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice two things about this output. First, notice that the first column skips
    the number 7\. Second, the value at position 6 is 960\. That’s far larger than
    what can fit in a byte. But in [Chapter 3](ch03.html#unique_chapter_id_03), you
    saw that strings were made out of bytes. What’s going on?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意此输出的两个问题。首先，注意第一列跳过了编号 7\. 其次，位置 6 的值是 960\. 这远远超过了一个字节可以容纳的范围。但是在[第三章](ch03.html#unique_chapter_id_03)中，你看到字符串是由字节组成的。这是怎么回事？
- en: What you are seeing is special behavior from iterating over a string with a
    `for-range` loop. It iterates over the *runes*, not the *bytes*. Whenever a `for-range`
    loop encounters a multibyte rune in a string, it converts the UTF-8 representation
    into a single 32-bit number and assigns it to the value. The offset is incremented
    by the number of bytes in the rune. If the `for-range` loop encounters a byte
    that doesn’t represent a valid UTF-8 value, the Unicode replacement character
    (hex value 0xfffd) is returned instead.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用 `for-range` 循环迭代字符串时，会出现特殊的行为。它迭代的是 *runes* 而不是 *bytes*。每当 `for-range` 循环遇到字符串中的多字节
    rune 时，它将 UTF-8 表示转换为一个单一的 32 位数值并赋给该值。偏移量按 rune 的字节长度增加。如果 `for-range` 循环遇到一个不能表示有效
    UTF-8 值的字节，则返回 Unicode 替换字符（十六进制值为 0xfffd）。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use a `for-range` loop to access the runes in a string in order. The first variable
    holds the number of bytes from the beginning of the string, but the type of the
    second variable is rune.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for-range` 循环按顺序访问字符串中的字符。第一个变量保存从字符串开头的字节数，但第二个变量的类型是 rune。
- en: The for-range value is a copy
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for-range` 的值是一个副本'
- en: You should be aware that each time the `for-range` loop iterates over your compound
    type, it *copies* the value from the compound type to the value variable. *Modifying
    the value variable will not modify the value in the compound type*. [Example 4-17](#EX4_16)
    shows a quick program to demonstrate this. You can try it out on [The Go Playground](https://oreil.ly/ShwR0)
    or in the `forRangeIsACopy` function in *main.go* in the *sample_code/for_range*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，每次 `for-range` 循环迭代你的复合类型时，它会将复合类型的值复制到值变量中。*修改值变量不会修改复合类型中的值*。[示例 4-17](#EX4_16)
    展示了一个快速演示这一点的程序。你可以在 [The Go Playground](https://oreil.ly/ShwR0) 或 [第 4 章代码库](https://oreil.ly/Fqw5B)
    的 *sample_code/for_range* 目录中的 `forRangeIsACopy` 函数中尝试。
- en: Example 4-17\. Modifying the value doesn’t modify the source
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 修改值不会修改源
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running this code gives the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会得到以下输出：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In versions of Go before 1.22, the value variable is created once and is reused
    on each iteration through the `for` loop. Since Go 1.22, the default behavior
    is to create a new index and value variable on each iteration through the `for`
    loop. This change may not seem important, but it prevents a common bug. When I
    talk about goroutines and `for-range` loops in [“Goroutines, for Loops, and Varying
    Variables”](ch12.html#shared_var_goroutine), you’ll see that prior to Go 1.22,
    if you launched goroutines in a `for-range` loop, you needed to be careful in
    how you passed the index and value to the goroutines, or you’d get surprisingly
    wrong results.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 1.22 版本之前，值变量只会被创建一次，并在 `for` 循环的每次迭代中重用。从 Go 1.22 开始，默认行为是在 `for` 循环的每次迭代中创建一个新的索引和值变量。这个变更可能看起来不重要，但它可以防止一个常见的
    bug。当我在 [“Goroutines, for Loops, and Varying Variables”](ch12.html#shared_var_goroutine)
    中讨论 goroutines 和 `for-range` 循环时，你会看到在 Go 1.22 之前，如果在 `for-range` 循环中启动 goroutines，你需要小心如何传递索引和值给
    goroutines，否则可能会得到意外的结果。
- en: Because this is a backward-breaking change (even if it is a change that eliminates
    a common bug), you can control whether to enable this behavior by specifying the
    Go version in the `go` directive in the *go.mod* file for your module. I talk
    about this in greater detail in [“Using go.mod”](ch10.html#go_mod).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个向后兼容性的变更（即使是消除了一个常见的错误），你可以通过在你的模块的 *go.mod* 文件中指定 Go 版本来控制是否启用此行为。我在
    [“Using go.mod”](ch10.html#go_mod) 中详细讨论了这个问题。
- en: Just as with the other three forms of the `for` statement, you can use `break`
    and `continue` with a `for-range` loop.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `for` 语句的其他三种形式一样，你可以在 `for-range` 循环中使用 `break` 和 `continue`。
- en: Labeling Your for Statements
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给你的 for 语句加上标签
- en: By default, the `break` and `continue` keywords apply to the `for` loop that
    directly contains them. What if you have nested `for` loops and want to exit or
    skip over an iterator of an outer loop? Let’s look at an example. You’re going
    to modify the earlier string iterating program to stop iterating through a string
    as soon as it hits a letter “l.” You can run the code in [Example 4-18](#EX3_17)
    on [The Go Playground](https://oreil.ly/ToDkq) or in the *sample_code/for_label*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`break` 和 `continue` 关键字适用于直接包含它们的 `for` 循环。如果你有嵌套的 `for` 循环，并且想要退出或跳过外部循环的迭代器，该怎么办？我们来看一个例子。你将修改早期的字符串迭代程序，在字符串中第一次遇到字母“l”时停止迭代。你可以在
    [示例 4-18](#EX3_17) 中运行这段代码，也可以在 [The Go Playground](https://oreil.ly/ToDkq) 或
    [第 4 章代码库](https://oreil.ly/Fqw5B) 的 *sample_code/for_label* 目录中运行。
- en: Example 4-18\. Labels
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 标签
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that the label `outer` is indented by `go fmt` to the same level as
    the surrounding function. Labels are always indented to the same level as the
    braces for the block. This makes them easier to notice. Running the program gives
    the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签 `outer` 被 `go fmt` 缩进到与周围函数相同的级别。标签总是缩进到与块的大括号相同的级别，这样更容易注意到。运行程序会得到以下输出：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Nested `for` loops with labels are rare. They are most commonly used to implement
    algorithms similar to the following pseudocode:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 带标签的嵌套 `for` 循环很少见。它们最常用于实现类似以下伪代码的算法：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Choosing the Right for Statement
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的 for 语句
- en: Now that I’ve covered all forms of the `for` statement, you might be wondering
    when to use which format. Most of the time, you’re going to use the `for-range`
    format. A `for-range` loop is the best way to walk through a string, since it
    properly gives you back runes instead of bytes. You have also seen that a `for-range`
    loop works well for iterating through slices and maps, and you’ll see in [Chapter 12](ch12.html#unique_chapter_id_12)
    that channels work naturally with `for-range` as well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经覆盖了所有形式的`for`语句，你可能想知道何时使用哪种格式。大多数情况下，你会使用`for-range`格式。`for-range`循环是遍历字符串的最佳方式，因为它能正确地返回符文而不是字节。你还看到了`for-range`循环在遍历切片和映射时表现良好，并且在[第12章](ch12.html#unique_chapter_id_12)中你将看到`for-range`与通道的自然结合。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Favor a `for-range` loop when iterating over all the contents of an instance
    of one of the built-in compound types. It avoids a great deal of boilerplate code
    that’s required when you use an array, slice, or map with one of the other `for`
    loop styles.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历所有内置复合类型实例的内容时，最好使用`for-range`循环。它避免了在使用数组、切片或映射时所需的大量样板代码。
- en: 'When should you use the complete `for` loop? The best place for it is when
    you aren’t iterating from the first element to the last element in a compound
    type. While you could use some combination of `if`, `continue`, and `break` within
    a `for-range` loop, a standard `for` loop is a clearer way to indicate the start
    and end of your iteration. Compare these two code snippets, both of which iterate
    over the second through the second-to-last elements in an array. First the `for-range`
    loop:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当应该使用完整的`for`循环？最佳场景是在复合类型中不从第一个元素到最后一个元素进行迭代时。虽然你可以在`for-range`循环中使用一些`if`、`continue`和`break`的组合，但标准的`for`循环更清晰地表示你的迭代的起始和结束。比较下面这两段代码片段，它们都是在数组中从第二个到倒数第二个元素进行迭代。首先是`for-range`循环：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And here’s the same code, with a standard `for` loop:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同的代码，使用了标准的`for`循环：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The standard `for` loop code is both shorter and easier to understand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`for`循环代码既更短又更易于理解。
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This pattern does not work for skipping over the beginning of a string. Remember,
    a standard `for` loop doesn’t properly handle multibyte characters. If you want
    to skip over some of the runes in a string, you need to use a `for-range` loop
    so that it will properly process runes for you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式无法跳过字符串的开头。记住，标准的`for`循环不能正确处理多字节字符。如果你想跳过字符串中的某些符文，你需要使用`for-range`循环，这样它才能正确地为你处理符文。
- en: The remaining two `for` statement formats are used less frequently. The condition-only
    `for` loop is, like the `while` loop it replaces, useful when you are looping
    based on a calculated value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种`for`语句格式使用较少。仅条件的`for`循环就像替代它的`while`循环一样，在基于计算值进行循环时非常有用。
- en: The infinite `for` loop is useful in some situations. The body of the `for`
    loop should always contain a `break` or `return` because you’ll rarely want to
    loop forever. Real-world programs should bound iteration and fail gracefully when
    operations cannot be completed. As shown previously, an infinite `for` loop can
    be combined with an `if` statement to simulate the `do` statement that’s present
    in other languages. An infinite `for` loop is also used to implement some versions
    of the *iterator* pattern, which you will look at when I review the standard library
    in [“io and Friends”](ch13.html#io_friends).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无限的`for`循环在某些情况下非常有用。`for`循环的主体应始终包含`break`或`return`，因为你很少希望无限循环。现实世界的程序应限制迭代，并在无法完成操作时优雅地失败。如前所示，无限的`for`循环可以与`if`语句结合使用，以模拟其他语言中存在的`do`语句。无限的`for`循环还用于实现一些版本的*迭代器*模式，在我回顾标准库时你将会看到[“io
    and Friends”](ch13.html#io_friends)。
- en: switch
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开关
- en: Like many C-derived languages, Go has a `switch` statement. Most developers
    in those languages avoid `switch` statements because of their limitations on values
    that can be switched on and the default fall-through behavior. But Go is different.
    It makes `switch` statements useful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多C衍生语言一样，Go语言有`switch`语句。在这些语言中，大多数开发者避免使用`switch`语句，因为其对可以切换的值有限制，并且有默认的穿透行为。但是Go语言不同，它使得`switch`语句变得很有用。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For those readers who are more familiar with Go, I’m going to cover *expression
    switch* statements in this chapter. I’ll discuss *type switch* statements when
    I talk about interfaces in [Chapter 7](ch07.html#unique_chapter_id_07).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些熟悉Go语言的读者，我将在本章中介绍*表达式switch*语句。当我在[第7章](ch07.html#unique_chapter_id_07)讨论接口时，我将讨论*类型switch*语句。
- en: At first glance, `switch` statements in Go don’t look all that different from
    how they appear in C/C++, Java, or JavaScript, but there are a few surprises.
    Let’s take a look at a sample `switch` statement. You can run the code in [Example 4-19](#EX3_18)
    on [The Go Playground](https://oreil.ly/VKf4N) or in the `basicSwitch` function
    in `main.go` in the *sample_code/switch* directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，在 Go 中，`switch` 语句看起来并不比在 C/C++、Java 或 JavaScript 中的样子有多大的不同，但其中还是有些意外的地方。让我们看一个
    `switch` 语句的示例。你可以在 [Example 4-19](#EX3_18) 中的代码或在 [第四章仓库](https://oreil.ly/Fqw5B)
    中的 *sample_code/switch* 目录下的 `main.go` 文件中的 `basicSwitch` 函数中运行这段代码。
- en: Example 4-19\. The `switch` statement
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-19\. `switch` 语句
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you run this code, you get the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，会得到以下输出：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I’ll go over the features of the `switch` statement to explain the output. As
    is the case with `if` statements, you don’t put parentheses around the value being
    compared in a `switch`. Also as if an `if` statement, you can declare a variable
    that’s scoped to all branches of the `switch` statement. In this case, you are
    scoping the variable `size` to all cases in the `switch` statement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我将详细介绍 `switch` 语句的特性以解释其输出。和 `if` 语句一样，在 `switch` 中，你不需要在比较的值周围加上括号。同样如 `if`
    语句一样，你可以在 `switch` 语句中声明一个在所有分支中都可见的变量。在这种情况下，你将变量 `size` 的作用域限定在 `switch` 语句的所有
    `case` 中。
- en: All `case` clauses (and the optional `default` clause) are contained inside
    a set of braces. But you should note that you don’t put braces around the contents
    of the `case` clauses. You can have multiple lines inside a `case` (or `default`)
    clause, and they are all considered to be part of the same block.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `case` 子句（和可选的 `default` 子句）都包含在一对大括号内。但请注意，你不需要在 `case` 子句的内容周围加上大括号。你可以在
    `case`（或 `default`）子句内有多行代码，它们都被认为是同一个代码块的一部分。
- en: Inside `case 5:`, you declare `wordLen`, a new variable. Since this is a new
    block, you can declare new variables within it. Just like any other block, any
    variables declared within a `case` clause’s block are visible only within that
    block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `case 5:` 内，你声明了一个新变量 `wordLen`。由于这是一个新的代码块，你可以在其中声明新的变量。和其他任何代码块一样，`case`
    子句的代码块内声明的变量只在该代码块内可见。
- en: If you are used to putting a `break` statement at the end of every `case` in
    your `switch` statements, you’ll be happy to notice that they are gone. By default,
    cases in `switch` statements in Go don’t fall through. This is more in line with
    the behavior in Ruby or (if you are an old-school programmer) Pascal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯在 `switch` 语句中的每个 `case` 结尾放置 `break` 语句，那么你会高兴地注意到它们已经消失了。在 Go 中，默认情况下，`switch`
    语句中的 `case` 不会穿透。这与 Ruby 或者（如果你是老派程序员的话）Pascal 的行为更加一致。
- en: 'This prompts the question: if cases don’t fall through, what do you do if there
    are multiple values that should trigger the exact same logic? In Go, you separate
    multiple matches with commas, as you do when matching 1, 2, 3, and 4 or 6, 7,
    8, and 9\. That’s why you get the same output for both `a` and `cow`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：如果 `case` 不再穿透，那么如果有多个值应该触发相同的逻辑，你该怎么办？在 Go 中，你用逗号分隔多个匹配值，就像匹配 1、2、3
    和 4 或者 6、7、8 和 9 一样。这就是为什么对于 `a` 和 `cow` 你会得到相同的输出。
- en: 'Which leads to the next question: if you don’t have fall-through, and you have
    an empty case (as you do in the sample program when the length of your argument
    is 6, 7, 8, or 9 characters), what happens? In Go, *an empty case means nothing
    happens*. That’s why you don’t see any output from your program when you use *octopus*
    or *gopher* as the parameter.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了下一个问题：如果你没有了穿透，而且你有一个空的 `case`（就像在样例程序中当你的参数长度是 6、7、8 或 9 个字符时一样），会发生什么？在
    Go 中，*空的 `case` 意味着什么也不会发生*。这就是为什么当你使用 *octopus* 或 *gopher* 作为参数时，程序不会输出任何内容。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For the sake of completeness, Go does include a `fallthrough` keyword, which
    lets one case continue on to the next one. Please think twice before implementing
    an algorithm that uses it. If you find yourself needing to use `fallthrough`,
    try to restructure your logic to remove the dependencies between cases.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 出于完整性考虑，Go 确实包含了 `fallthrough` 关键字，它允许一个 `case` 继续执行下一个 `case`。在使用 `fallthrough`
    的算法之前，请三思。如果你发现自己需要使用 `fallthrough`，尝试重构你的逻辑以消除 `case` 之间的依赖关系。
- en: In the sample program, you are switching on the value of an integer, but that’s
    not all you can do. You can switch on any type that can be compared with `==`,
    which includes all built-in types except slices, maps, channels, functions, and
    structs that contain fields of these types.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例程序中，您正在根据整数值进行`switch`，但这并不是您可以做的全部。您可以对任何可以使用`==`进行比较的类型进行`switch`，其中包括除切片、映射、通道、函数和包含这些类型字段的结构体之外的所有内置类型。
- en: Even though you don’t need to put a `break` statement at the end of each `case`
    clause, you can use them when you want to exit early from a `case`. However, the
    need for a `break` statement might indicate that you are doing something too complicated.
    Consider refactoring your code to remove it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在每个`case`子句的末尾不需要放置`break`语句，但当您希望从`case`中早期退出时，可以使用它们。但是，需要`break`语句可能表明您正在做某些过于复杂的事情。考虑重构您的代码以去除它。
- en: There is one more place where you might find yourself using a `break` statement
    in a `case` in a `switch` statement. If you have a `switch` statement inside a
    `for` loop, and you want to break out of the `for` loop, put a label on the `for`
    statement and put the name of the label on the `break`. If you don’t use a label,
    Go assumes that you want to break out of the `case`. Let’s look at a quick example
    where you want to break out of the `for` loop once it reaches 7\. You can run
    the code in [Example 4-20](#EX3_19) on [The Go Playground](https://oreil.ly/xH2Ij)
    or in the `missingLabel` function in *main.go* in the *sample_code/switch* directory
    in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个地方可能会使用`break`语句在`switch`语句的`case`中。如果您在`for`循环内部有一个`switch`语句，并且希望跳出`for`循环，请在`for`语句上放置一个标签，并在`break`上放置标签的名称。如果不使用标签，Go会假设您想跳出`case`。让我们看一个快速示例，您希望一旦达到7就跳出`for`循环。您可以在[Example 4-20](#EX3_19)中运行代码，在[The
    Go Playground](https://oreil.ly/xH2Ij)或在[第4章存储库](https://oreil.ly/Fqw5B)的*sample_code/switch*目录中的*main.go*文件中的`missingLabel`函数中运行它。
- en: Example 4-20\. The case of the missing label
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20\. 缺少标签的情况
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running this code produces the following output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That’s not what is intended. The goal was to break out of the `for` loop when
    it got a 7, but the `break` was interpreted as exiting the `case`. To resolve
    this, you need to introduce a label, just as you did when breaking out of a nested
    `for` loop. First, you label the `for` statement:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是预期的行为。目标是在遇到7时跳出`for`循环，但`break`被解释为退出`case`。要解决此问题，您需要引入一个标签，就像在跳出嵌套的`for`循环时所做的那样。首先，给`for`语句加上标签：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then you use the label on your break:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以在您的`break`上使用标签：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can see these changes on [The Go Playground](https://oreil.ly/PeaBI) or
    in the `labeledBreak` function in *main.go* in the *sample_code/switch* directory
    in the [Chapter 4 repository](https://oreil.ly/Fqw5B). When you run it again,
    you get the expected output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[The Go Playground](https://oreil.ly/PeaBI)上查看这些更改，或者在[第4章存储库](https://oreil.ly/Fqw5B)中的*sample_code/switch*目录中的*main.go*文件中的`labeledBreak`函数中查看它。再次运行时，您将获得预期的输出：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Blank Switches
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白`switch`
- en: You can use `switch` statements in another, more powerful way. Just as Go allows
    you to leave out parts from a `for` statement’s declaration, you can write a `switch`
    statement that doesn’t specify the value that you’re comparing against. This is
    called a *blank switch*. A regular `switch` only allows you to check a value for
    equality. A blank `switch` allows you to use any boolean comparison for each `case`.
    You can try out the code in [Example 4-21](#EX3_21) on [The Go Playground](https://oreil.ly/v7qI5)
    or in the `basicBlankSwitch` function in *main.go* in the *sample_code/blank_switch*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以另一种更强大的方式使用`switch`语句。正如Go允许您从`for`语句的声明中省略部分内容一样，您可以编写一个不指定要比较的值的`switch`语句。这被称为*空白`switch`*。常规的`switch`只允许您检查相等的值。空白`switch`允许您对每个`case`使用任何布尔比较。您可以在[Example 4-21](#EX3_21)中尝试这段代码，在[The
    Go Playground](https://oreil.ly/v7qI5)或在[第4章存储库](https://oreil.ly/Fqw5B)的*sample_code/blank_switch*目录中的*main.go*文件中的`basicBlankSwitch`函数中。
- en: Example 4-21\. The blank `switch`
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 空白的`switch`
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When you run this program, you get the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此程序时，会得到以下输出：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Just as with a regular `switch` statement, you can optionally include a short
    variable declaration as part of your blank `switch`. But unlike a regular `switch`,
    you can write logical tests for your cases. Blank switches are pretty cool, but
    don’t overdo them. If you find that you have written a blank `switch` where all
    your cases are equality comparisons against the same variable:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的`switch`语句一样，你可以选择在空的`switch`中包含一个短变量声明。但与普通的`switch`不同的是，你可以为你的情况编写逻辑测试。空的`switch`很酷，但不要过度使用。如果你发现自己写了一个所有情况都是对同一变量的相等比较的空`switch`：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'you should replace it with an expression `switch` statement:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该用一个表达式`switch`语句替换它：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Choosing Between if and switch
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`if`和`switch`之间的选择
- en: As a matter of functionality, there isn’t much difference between a series of
    `if/else` statements and a blank `switch` statement. Both allow a series of comparisons.
    So, when should you use `switch`, and when should you use a set of `if` or `if/else`
    statements? A `switch` statement, even a blank `switch`, indicates that a relationship
    exists between the values or comparisons in each case. To demonstrate the difference
    in clarity, rewrite the FizzBuzz program from [Example 4-11](#EX3_11-2) using
    a blank `switch`, as shown in [Example 4-22](#EX3_22). You can also find this
    code in the *sample_code/simplest_fizzbuzz* directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就功能而言，一系列`if/else`语句和空的`switch`语句之间没有太大区别。两者都允许一系列比较。那么，何时应该使用`switch`，何时应该使用一组`if`或`if/else`语句呢？`switch`语句，即使是空的`switch`，表明每个`case`中的值或比较之间存在关系。为了演示清晰度的差异，可以使用空的`switch`重新编写[FizzBuzz程序](#EX3_11-2)（参见[示例
    4-22](#EX3_22)）。你也可以在[第4章代码库](https://oreil.ly/Fqw5B)的*sample_code/simplest_fizzbuzz*目录中找到这段代码。
- en: Example 4-22\. Rewriting a series of `if` statements with a blank `switch`
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-22。用空的`switch`重写一系列`if`语句
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Most people would agree that this is the most readable version. There’s no more
    need for `continue` statements, and the default behavior is made explicit with
    the `default` case.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人都会同意这是最可读的版本。不再需要`continue`语句，`default`情况下的默认行为也变得明确。
- en: Of course, nothing in Go prevents you from doing all sorts of unrelated comparisons
    on each `case` in a blank `switch`. However, this is not idiomatic. If you find
    yourself in a situation where you want to do this, use a series of `if/else` statements
    (or perhaps consider refactoring your code).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Go语言中，没有任何东西能阻止你在空`switch`的每个`case`上做各种无关的比较。然而，这并不符合习惯用法。如果你发现自己处于这样一种情况下，应该使用一系列`if/else`语句（或者考虑重构你的代码）。
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Favor blank `switch` statements over `if/else` chains when you have multiple
    related cases. Using a `switch` makes the comparisons more visible and reinforces
    that they are a related set of concerns.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个相关的情况时，更倾向于使用空的`switch`语句而不是`if/else`链。使用`switch`可以使比较更加明显，并强调它们是一组相关的问题。
- en: goto—Yes, goto
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`goto`——是的，`goto`'
- en: Go has a fourth control statement, but chances are, you will never use it. Ever
    since Edsger Dijkstra wrote [“Go To Statement Considered Harmful”](https://oreil.ly/YK2tl)
    in 1968, the `goto` statement has been the black sheep of the coding family. There
    are good reasons for this. Traditionally, `goto` was dangerous because it could
    jump to nearly anywhere in a program; you could jump into or out of a loop, skip
    over variable definitions, or into the middle of a set of statements in an `if`
    statement. This made it difficult to understand what a `goto`-using program did.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有第四种控制语句，但很可能你永远不会使用它。自从Edsger Dijkstra在1968年写下[“谈谈‘goto’语句的害处”](https://oreil.ly/YK2tl)以来，`goto`语句一直是编码家族中的害群之马。这有充分的理由。传统上，`goto`很危险，因为它可以跳转到程序中的几乎任何地方；你可以跳进或跳出循环，跳过变量定义，或者跳入`if`语句中一组语句的中间。这使得理解使用`goto`的程序变得困难。
- en: Most modern languages don’t include `goto`. Yet Go has a `goto` statement. You
    should still do what you can to avoid using it, but it has some uses, and the
    limitations that Go places on it make it a better fit with structured programming.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代语言不包括`goto`。然而Go语言有一个`goto`语句。你仍然应该尽量避免使用它，但它有一些用途，而Go语言对它施加的限制使其更适合结构化编程。
- en: In Go, a `goto` statement specifies a labeled line of code, and execution jumps
    to it. However, you can’t jump anywhere. Go forbids jumps that skip over variable
    declarations and jumps that go into an inner or parallel block.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，`goto`语句指定了一个带标签的代码行，并且执行跳转到它。但你不能随处跳转。Go语言禁止跳过变量声明和进入内部或并行块的跳转。
- en: The program in [Example 4-23](#EX3_23) shows two illegal `goto` statements.
    You can attempt to run it on [The Go Playground](https://oreil.ly/l016p) or in
    the *sample_code/broken_goto* directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[4-23](#EX3_23)中的程序展示了两个非法的`goto`语句。你可以尝试在[Go Playground](https://oreil.ly/l016p)或[第4章存储库](https://oreil.ly/Fqw5B)的*sample_code/broken_goto*目录中运行它。
- en: Example 4-23\. Go’s `goto` has rules
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-23\. Go的`goto`有规则。
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Trying to run this program produces the following errors:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个程序会产生以下错误：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So what should you use `goto` for? Mostly, you shouldn’t. Labeled `break` and
    `continue` statements allow you to jump out of deeply nested loops or skip iteration.
    The program in [Example 4-24](#EX3_24) has a legal `goto` and demonstrates one
    of the few valid use cases. You can also find this code in the *sample_code/good_goto*
    directory in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`goto`应该用在什么地方？大多数情况下，不应该用。带标签的`break`和`continue`语句允许您跳出深度嵌套的循环或跳过迭代。[示例4-24](#EX3_24)中的程序具有合法的`goto`，展示了少数几个有效使用场景之一。你还可以在[第4章存储库](https://oreil.ly/Fqw5B)的*sample_code/good_goto*目录中找到这段代码。
- en: Example 4-24\. A reason to use `goto`
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-24\. 使用`goto`的理由。
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example is contrived, but it shows how `goto` can make a program clearer.
    In this simple case, there is some logic that you don’t want to run in the middle
    of the function, but you do want to run at the end of the function. There are
    ways to do this without `goto`. You could set up a boolean flag or duplicate the
    complicated code after the `for` loop instead of having a `goto`, but both approaches
    have drawbacks. Littering your code with boolean flags to control the logic flow
    is arguably the same functionality as the `goto` statement, just more verbose.
    Duplicating complicated code is problematic because it makes your code harder
    to maintain. These situations are rare, but if you cannot find a way to restructure
    your logic, using a `goto` like this actually improves your code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是人为构造的，但它展示了`goto`如何使程序更清晰。在这个简单的情况下，有一些逻辑你不想在函数中间运行，但你希望在函数结束时运行。有方法可以在没有`goto`的情况下做到这一点。你可以设置一个布尔标志或在`for`循环之后复制复杂的代码，而不是使用`goto`，但这两种方法都有缺点。在你的代码中满布布尔标志以控制逻辑流的功能与`goto`语句几乎相同，只是更冗长。复制复杂的代码是有问题的，因为它使得你的代码更难维护。这些情况很少见，但如果你找不到重构逻辑的方法，像这样使用`goto`实际上会改进你的代码。
- en: 'If you want to see a real-world example, you can take a look at the `floatBits`
    method in the file *atof.go* in the `strconv` package in the standard library.
    It’s too long to include in its entirety, but the method ends with this code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看一个实际的例子，你可以看一下标准库中`strconv`包的文件*atof.go*中的`floatBits`方法。这个方法太长了，无法完全包含，但方法以这段代码结束：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Before these lines, there are several condition checks. Some require the code
    after the `overflow` label to run, while other conditions require skipping that
    code and going directly to `out`. Depending on the condition, there are `goto`
    statements that jump to `overflow` or `out`. You could probably come up with a
    way to avoid the `goto` statements, but they all make the code harder to understand.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行之前，有几个条件检查。有些需要运行`overflow`标签后的代码，而其他条件则需要跳过该代码直接到`out`。根据条件，有`goto`语句跳转到`overflow`或`out`。你可能可以想出一种避免`goto`语句的方法，但它们都会使代码更难理解。
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You should try very hard to avoid using `goto`. But in the rare situations where
    it makes your code more readable, it is an option.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尽力避免使用`goto`。但在它使你的代码更易读的罕见情况下，它是一个选项。
- en: Exercises
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now it’s time to apply everything you’ve learned about control structures and
    blocks in Go. You can find answers to these exercises in the [Chapter 4 repository](https://oreil.ly/Fqw5B).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候应用你在Go中学到的所有关于控制结构和块的知识了。你可以在[第4章存储库](https://oreil.ly/Fqw5B)中找到这些练习的答案。
- en: Write a `for` loop that puts 100 random numbers between 0 and 100 into an `int`
    slice.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`for`循环，将100个0到100之间的随机数放入一个`int`切片中。
- en: 'Loop over the slice you created in exercise 1\. For each value in the slice,
    apply the following rules:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历你在练习1中创建的切片。对于切片中的每个值，应用以下规则：
- en: If the value is divisible by 2, print “Two!”
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值可被2整除，打印“二！”
- en: If the value is divisible by 3, print “Three!”
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值可被3整除，打印“三！”
- en: IIf the value is divisible by 2 and 3, print “Six!”. Don’t print anything else.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值可同时被2和3整除，打印“六！”。不打印其他任何内容。
- en: Otherwise, print “Never mind”.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，打印“不要紧”。
- en: 'Start a new program. In `main`, declare an `int` variable called `total`. Write
    a `for` loop that uses a variable named `i` to iterate from 0 (inclusive) to 10
    (exclusive). The body of the `for` loop should be as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新程序。在`main`函数中声明一个名为`total`的`int`变量。编写一个`for`循环，使用名为`i`的变量从0（包含）迭代到10（不包含）。`for`循环的主体应如下所示：
- en: '[PRE54]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After the `for` loop, print out the value of `total`. What is printed out? What
    is the likely bug in this code?
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`for`循环结束后，打印出`total`的值。会打印出什么？这段代码中可能存在的 bug 是什么？
- en: Wrapping Up
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered a lot of important topics for writing idiomatic Go. You’ve
    learned about blocks, shadowing, and control structures, and how to use them correctly.
    At this point, you’re able to write simple Go programs that fit within the `main`
    function. It’s time to move on to larger programs, using functions to organize
    your code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章覆盖了许多编写符合惯例的 Go 语言的重要主题。你已经学习了关于代码块、变量屏蔽和控制结构的知识，并学会了如何正确使用它们。此时，你已经能够编写简单的
    Go 程序，适合在`main`函数中运行。是时候转向更大的程序了，使用函数来组织你的代码。
