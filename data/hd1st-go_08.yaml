- en: 'Chapter 7\. labeling data: Maps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章 标记数据：Maps
- en: '![image](assets/f0205-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0205-01.png)'
- en: '**Throwing things in piles is fine, until you need to find something again.**
    You’ve already seen how to create lists of values using *arrays* and *slices*.
    You’ve seen how to apply the same operation to *every value* in an array or slice.
    But what if you need to work with a *particular* value? To find it, you’ll have
    to start at the beginning of the array or slice, and *look through Every. Single.
    Value.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**将东西随意堆放是可以的，直到你需要再次找到某样东西。** 你已经学会了如何使用 *数组* 和 *切片* 创建值的列表。你也学会了如何对数组或切片中的
    *每个值* 应用相同的操作。但是如果你需要处理 *特定的* 值呢？为了找到它，你必须从数组或切片的开头开始，*查找每一个单独的值*。'
- en: What if there were a kind of collection where every value had a label on it?
    You could quickly find just the value you needed! In this chapter, we’ll look
    at **maps**, which do just that.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种集合，每个值都带有标签，那该多好啊？你可以快速找到你需要的值！在这一章中，我们将介绍 **maps**，它们正是做这件事的。
- en: Counting votes
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计选票
- en: A seat on the Sleepy Creek County School Board is up for grabs this year, and
    polls have been showing that the election is really close. Now that it’s election
    night, the candidates are excitedly watching the votes roll in.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今年，Sleepy Creek 县学校董事会的一个席位空缺，民意调查显示选举结果非常接近。现在已经是选举之夜，候选人们正兴奋地观看选票的涌入。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: This is another example that debuted in Head First Ruby, in the hashes chapter.
    Ruby hashes are a lot like Go maps, so this example works great here, too!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个在《Head First Ruby》中首次亮相的例子，出现在哈希章节。Ruby 的哈希与 Go 的 maps 非常相似，所以这个例子在这里也非常适用！
- en: '![image](assets/f0206-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0206-01.png)'
- en: '**Name: Amber Graham'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**姓名：安伯·格雷厄姆**'
- en: 'Occupation: Manager**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 职业：经理**
- en: '![image](assets/f0206-02.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0206-02.png)'
- en: '**Name: Brian Martin'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**姓名：布莱恩·马丁**'
- en: 'Occupation: Accountant**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 职业：会计**
- en: There are two candidates on the ballot, Amber Graham and Brian Martin. Voters
    also have the option to “write in” a candidate’s name (that is, type in a name
    that doesn’t appear on the ballot). Those won’t be as common as the main candidates,
    but we can expect a few such names to appear.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 投票中有两位候选人，安伯·格雷厄姆和布莱恩·马丁。选民还可以选择“写入”候选人的名字（即输入一个未出现在选票上的名字）。这些情况不会像主要候选人那样常见，但我们预计会有一些这样的名字出现。
- en: The electronic voting machines in use this year record the votes to text files,
    one vote per line. (Budgets are tight, so the city council chose the cheap voting
    machine vendor.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 今年使用的电子投票机会将选票记录到文本文件中，每行一票。（由于预算紧张，市议会选择了廉价的投票机供应商。）
- en: 'Here’s a file with all the votes for District A:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于 A 区所有选票的文件：
- en: '![image](assets/f0206-03.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0206-03.png)'
- en: We need to process each line of the file and tally the total number of times
    each name occurs. The name with the most votes will be our winner!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理文件的每一行，并统计每个名字出现的总次数。得票最多的名字将成为我们的获胜者！
- en: Reading names from a file
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取名字
- en: Our first order of business is to read the contents of the *votes.txt* file.
    The `datafile` package from previous chapters already has a `GetFloats` function
    that reads each line of a file into a slice, but `GetFloats` can only read `float64`
    values. We’re going to need a separate function that can return the file lines
    as a slice of `string` values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一项工作是读取 *votes.txt* 文件的内容。前几章中的 `datafile` 包已经有一个 `GetFloats` 函数，它可以将文件的每一行读取到一个切片中，但
    `GetFloats` 只能读取 `float64` 值。我们需要一个单独的函数，能够将文件行作为 `string` 值的切片返回。
- en: So let’s start by creating a *strings.go* file alongside the *floats.go* file
    in the *datafile* package directory. In that file, we’ll add a `GetStrings` function.
    The code in `GetStrings` will look much like the code in `GetFloats` (we’ve grayed
    out the code that’s identical below). But instead of converting each line to a
    `float64` value, `GetStrings` will just add the line directly to the slice we’re
    returning, as a `string` value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们首先在 *datafile* 包目录中与 *floats.go* 文件并列创建一个 *strings.go* 文件。在那个文件中，我们将添加一个
    `GetStrings` 函数。`GetStrings` 中的代码将与 `GetFloats` 中的代码非常相似（我们已经灰化了相同的代码）。但是，与将每一行转换为
    `float64` 值不同的是，`GetStrings` 将直接将行添加到我们要返回的切片中，作为 `string` 值。
- en: '![image](assets/f0207-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0207-01.png)'
- en: Now let’s create the program that will actually count the votes. We’ll name
    it `count`. Within your Go workspace, go into the *[src/github.com/headfirstgo](http://src/github.com/headfirstgo)*
    directory and create a new directory named *count*. Then create a file named *main.go*
    within the *count* directory.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建实际计数选票的程序。我们将其命名为`count`。在您的Go工作空间中，进入*[src/github.com/headfirstgo](http://src/github.com/headfirstgo)*目录并创建一个名为*count*的新目录。然后在*count*目录中创建一个名为*main.go*的文件。
- en: Before writing the full program, let’s confirm that our `GetStrings` function
    is working. At the top of the `main` function, we’ll call `datafile.GetStrings`,
    passing it `"votes.txt"` as the name of the file to read from. We’ll store the
    returned slice of strings in a new variable named `lines`, and any error in a
    variable named `err`. As usual, if `err` is not `nil`, we’ll log the error and
    exit. Otherwise, we’ll simply call `fmt.Println` to print out the contents of
    the `lines` slice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完整程序之前，让我们确认我们的`GetStrings`函数是否正常工作。在`main`函数的顶部，我们将调用`datafile.GetStrings`，将`"votes.txt"`作为要读取的文件名传递给它。我们将把返回的字符串切片存储在名为`lines`的新变量中，将任何错误存储在名为`err`的变量中。通常情况下，如果`err`不为`nil`，我们会记录错误并退出。否则，我们将简单地调用`fmt.Println`来打印出`lines`切片的内容。
- en: '![image](assets/f0208-01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0208-01.png)'
- en: As we’ve done with other programs, you can compile this program (plus any packages
    it depends on, `datafile` in this case) by running `go install` and providing
    it the package import path. If you used the directory structure shown above, that
    import path should be `github.com/headfirstgo/count`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对其他程序所做的那样，您可以通过运行`go install`并提供包导入路径（在这种情况下是`datafile`）来编译此程序及其依赖的任何包。如果您使用了上述的目录结构，那么导入路径应该是`github.com/headfirstgo/count`。
- en: '![image](assets/f0208-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0208-02.png)'
- en: That will save an executable file named *count* (or *count.exe* on Windows)
    in the *bin* subdirectory of your Go workspace.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的Go工作空间的*bin*子目录中保存一个名为*count*（或在Windows上为*count.exe*）的可执行文件。
- en: As with the *data.txt* file in previous chapters, we need to ensure a *votes.txt*
    file is saved in the current directory when we run our program. In the *bin* subdirectory
    of your Go workspace, save a file with the contents shown at right. In your terminal,
    use the `**cd**` command to change to that same subdirectory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前几章的*data.txt*文件一样，我们需要确保在运行程序时当前目录中保存了*votes.txt*文件。在您的Go工作空间的*bin*子目录中，保存一个具有右侧显示内容的文件。在终端中，使用`**cd**`命令切换到相同的子目录。
- en: '![image](assets/f0209-01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0209-01.png)'
- en: Now you should be able to run the executable by typing `**./count**` (or `**count.exe**`
    on Windows). It should read every line of *votes.txt* into a slice of strings,
    then print that slice out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够通过键入`**./count**`（或在Windows上键入`**count.exe**`）来运行可执行文件。它应该将*votes.txt*的每一行读入一个字符串切片，然后将该切片打印出来。
- en: '![image](assets/f0209-02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0209-02.png)'
- en: Counting names the hard way, with slices
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用切片来进行名字计数的困难方式
- en: 'Reading a slice of names from the file didn’t require learning anything new.
    But now comes the challenge: how do we count the number of times each name occurs?
    We’ll show you two ways, first with slices, and then with a new data structure,
    *maps*.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取一个名字切片并不需要学习任何新东西。但现在来面对挑战：我们如何计算每个名字出现的次数？我们将展示两种方法，首先是使用切片，然后是使用一个新的数据结构——*映射*。
- en: For our first solution, we’ll create two slices, each with the same number of
    elements, in a specific order. The first slice would hold the names we found in
    the file, with each name occurring once. We could call that one `names`. The second
    slice, `counts`, would hold the number of times each name was found in the file.
    The element `counts[0]` would hold the count for `names[0]`, `counts[1]` would
    hold the count for `names[1]`, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个解决方案，我们将创建两个切片，每个切片具有相同数量的元素，以特定的顺序。第一个切片将保存我们在文件中找到的名字，每个名字出现一次。我们可以称之为`names`。第二个切片`counts`将保存文件中每个名字出现的次数。元素`counts[0]`将保存`names[0]`的计数，`counts[1]`将保存`names[1]`的计数，依此类推。
- en: '![image](assets/f0209-03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0209-03.png)'
- en: Let’s update the `count` program to actually count the number of times each
    name occurs in the file. We’ll try this plan of using a `names` slice to hold
    each unique candidate name, and a corresponding `counts` slice to track the number
    of times each name occurs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`count`程序，实际上计算文件中每个名字出现的次数。我们将尝试这个方案，使用一个`names`切片来保存每个唯一候选人名字，并使用一个对应的`counts`切片来跟踪每个名字出现的次数。
- en: '![image](assets/f0210-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0210-01.png)'
- en: As always, we can recompile the program with `go install`. If we run the resulting
    executable, it will read the *votes.txt* file and print each name it finds, along
    with the number of times that name occurs!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们可以使用`go install`重新编译程序。如果我们运行生成的可执行文件，它将读取*votes.txt*文件，并打印出它找到的每个名称，以及该名称出现的次数！
- en: '![image](assets/f0210-02.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0210-02.png)'
- en: Let’s take a closer look at how this works...
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它是如何工作的...
- en: Our `count` program uses a loop nested *inside* another loop to tally the name
    counts. The outer loop assigns lines of the file to the `line` variable, one at
    a time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`count`程序使用一个内循环嵌套*在*另一个循环中来统计名称计数。外部循环逐行将文件赋给`line`变量。
- en: '![image](assets/f0211-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0211-01.png)'
- en: The *inner* loop searches each element of the `names` slice, looking for a name
    equal to the current line from the file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*内部*循环搜索`names`切片的每个元素，查找与文件当前行相等的名称。'
- en: '![image](assets/f0211-02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0211-02.png)'
- en: Say someone adds a write-in candidate to their ballot, causing a line from the
    text file to be loaded with the string `"Carlos Diaz"`. The program will check
    the elements of `names`, one by one, to see if any of them equal `"Carlos Diaz"`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有人在选票上增加了一个自荐候选人，导致文本文件中的一行加载了字符串`"Carlos Diaz"`。程序将逐一检查`names`的元素，以查看是否有任何元素等于`"Carlos
    Diaz"`。
- en: '![image](assets/f0211-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0211-03.png)'
- en: If none matches, the program will append the string `"Carlos Diaz"` to the `names`
    slice, and a corresponding count of `1` to the `counts` slice (because this line
    represents the first vote for `"Carlos Diaz"`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配项，程序将字符串`"Carlos Diaz"`附加到`names`切片，并将`1`对应地添加到`counts`切片（因为这行代表了对`"Carlos
    Diaz"`的第一次投票）。
- en: '![image](assets/f0211-04.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0211-04.png)'
- en: But suppose the next line is the string `"Brian Martin"`. Because that string
    already exists in the `names` slice, the program will find it and add `1` to the
    corresponding value in `counts` instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设下一行是字符串`"Brian Martin"`。因为该字符串已经存在于`names`切片中，程序将找到它，并在`counts`中相应的值上加`1`。
- en: '![image](assets/f0211-05.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0211-05.png)'
- en: Maps
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'But here’s the problem with storing the names in slices: for each and every
    line of the file, you have to search through many (if not all) of the values in
    the `names` slice to compare them. That may work okay in a small district like
    Sleepy Creek County, but in a bigger district with lots of votes, this approach
    will be way too slow!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是将名称存储在切片中存在一个问题：对于文件的每一行，您必须搜索`names`切片中的许多（如果不是全部）值来进行比较。这在像Sleepy Creek县这样的小区域可能还好，但在有大量选票的大区域中，这种方法将会非常慢！
- en: '![image](assets/f0212-01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0212-01.png)'
- en: Putting data in a slice is like stacking it in a big pile; you can get particular
    items back out, but you’ll have to search through *everything* to find them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 把数据放入切片就像把它堆放在一个大堆里；你可以取回特定的项，但必须搜索*所有*东西才能找到它们。
- en: '![image](assets/f0212-02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0212-02.png)'
- en: '**Slice**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片**'
- en: 'Go has another way of storing collections of data: *maps*. A **map** is a collection
    where each value is accessed via a *key*. Keys are an easy way to get data back
    out of your map. It’s like having neatly labeled file folders instead of a messy
    pile.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Go还有另一种存储数据集合的方式：*映射*。**映射**是一种通过*键*访问每个值的集合。键是从映射中轻松取回数据的一种方式，就像有整齐标签的文件夹而不是一堆乱七八糟的东西。
- en: '![image](assets/f0212-03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0212-03.png)'
- en: '**Map**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**'
- en: Whereas arrays and slices can only use *integers* as indexes, a map can use
    *any* type for keys (as long as values of that type can be compared using `==`).
    That includes numbers, strings, and more. The values all have to be of the same
    type, and the keys all have to be of the same type, but the keys don’t have to
    be the same type as the values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而数组和切片只能使用*整数*作为索引，映射可以使用*任何*类型作为键（只要该类型的值可以使用`==`进行比较）。这包括数字、字符串等。所有值必须是相同类型，所有键必须是相同类型，但键不必与值的类型相同。
- en: To declare a variable that holds a map, you type the `map` keyword, followed
    by square brackets (`[]`) containing the key type. Then, following the brackets,
    provide the value type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个包含映射的变量，你需要输入`map`关键字，后面跟着方括号（`[]`）包含键类型。然后，在方括号后面，提供值类型。
- en: '![image](assets/f0213-01.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-01.png)'
- en: Just as with slices, declaring a map variable doesn’t automatically create a
    map; you need to call the `make` function (the same function you can use to create
    slices). Instead of a slice type, you can pass `make` the type of the map you
    want to create (which should be the same as the type of the variable you’re going
    to assign it to).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，声明映射变量并不会自动创建映射；你需要调用`make`函数（与用于创建切片的相同函数）。与切片类型不同，你可以将要创建的映射类型传递给`make`（应与要分配给它的变量类型相同）。
- en: '![image](assets/f0213-02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-02.png)'
- en: 'You may find it’s easier to just use a short variable declaration, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你会发现仅仅使用短变量声明更容易：
- en: '![image](assets/f0213-03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-03.png)'
- en: 'The syntax to assign values to a map and get them back out again looks a lot
    like the syntax to assign and get values for arrays or slices. But while arrays
    and slices only let you use integers as element indexes, you can choose almost
    any type to use for a map’s keys. The `ranks` map uses `string` keys:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分配值给映射并再次获取它们的语法看起来很像为数组或切片分配和获取值的语法。但是，数组和切片只允许使用整数作为元素索引，而你几乎可以选择任何类型来用作映射的键。`ranks`映射使用`string`键：
- en: '![image](assets/f0213-04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-04.png)'
- en: '**Arrays and slices only let you use integer indexes. But you can choose almost
    any type to use for a map’s keys.**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**数组和切片只能使用整数索引。但你几乎可以选择任何类型来用作映射键。**'
- en: 'Here’s another map with strings as keys and strings as values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个以字符串为键和字符串为值的映射：
- en: '![image](assets/f0213-05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-05.png)'
- en: 'Here’s a map with integers as keys and booleans as values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个以整数为键和布尔值为值的映射：
- en: '![image](assets/f0213-06.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0213-06.png)'
- en: Map literals
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射字面量
- en: Just as with arrays and slices, if you know keys and values that you want your
    map to have in advance, you can use a **map literal** to create it. A map literal
    starts with the map type (in the form `map[*KeyType*]*ValueType*`). This is followed
    by curly braces containing key/value pairs you want the map to start with. For
    each key/value pair, you include the key, a colon, and then the value. Multiple
    key/value pairs are separated by commas.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组和切片类似，如果你事先知道要在映射中使用的键和值，可以使用**映射字面量**来创建它。映射字面量以映射类型开头（形式为`map[*KeyType*]*ValueType*`）。然后是包含你想要映射开始的键/值对的大括号。对于每个键/值对，包括键，冒号，然后是值。多个键/值对用逗号分隔。
- en: '![image](assets/f0214-01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0214-01.png)'
- en: 'Here are a couple of the preceding map examples, re-created using map literals:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面几个映射示例，使用映射字面量重新创建：
- en: '![image](assets/f0214-02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0214-02.png)'
- en: As with slice literals, leaving the curly braces empty creates a map that starts
    empty.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像切片字面量一样，如果大括号为空，就会创建一个空的映射。
- en: '![image](assets/f0214-03.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0214-03.png)'
- en: Zero values within maps
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射内的零值
- en: As with arrays and slices, if you access a map key that hasn’t been assigned
    to, you’ll get a zero value back.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组和切片类似，如果访问尚未分配的映射键，将返回一个零值。
- en: '![image](assets/f0215-01.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0215-01.png)'
- en: Depending on the value type, the zero value may not actually be `0`. For maps
    with a value type of `string`, for example, the zero value will be an empty string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据值类型不同，零值实际上可能不是`0`。例如，对于值类型为`string`的映射，零值将是空字符串。
- en: '![image](assets/f0215-02.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0215-02.png)'
- en: As with arrays and slices, zero values can make it safe to manipulate a map
    value even if you haven’t explicitly assigned to it yet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组和切片类似，即使你尚未显式分配给它，零值也可以确保安全地操作映射值。
- en: '![image](assets/f0215-03.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0215-03.png)'
- en: The zero value for a map variable is nil
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射变量的零值是`nil`
- en: 'As with slices, the zero value for the map variable itself is `nil`. If you
    declare a `map` variable, but don’t assign it a value, its value will be `nil`.
    That means no map exists to add new keys and values to. If you try, you’ll get
    a panic:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片一样，映射变量本身的零值是`nil`。如果声明了一个映射变量，但没有为它分配值，那么它的值将是`nil`。这意味着没有映射存在来添加新的键和值。如果尝试这样做，会导致恐慌：
- en: '![image](assets/f0215-04.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0215-04.png)'
- en: Before attempting to add keys and values, create a map using `make` or a map
    literal, and assign it to your map variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试添加键和值之前，使用`make`或映射字面量创建一个映射，并将其分配给你的映射变量。
- en: '![image](assets/f0215-05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0215-05.png)'
- en: How to tell zero values apart from assigned values
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何区分零值和分配的值
- en: Zero values, although useful, can sometimes make it difficult to tell whether
    a given key has been assigned the zero value, or if it has never been assigned.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然零值很有用，但有时很难判断给定键是否已分配了零值，或者它从未被分配过。
- en: 'Here’s an example of a program where this could be an issue. This code erroneously
    reports that the student `"Carl"` is failing, when in reality he just hasn’t had
    any grades logged:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个程序示例，其中可能会出现此问题。这段代码错误地报告学生`"Carl"`不及格，实际上他只是没有记录任何成绩：
- en: '![image](assets/f0216-01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0216-01.png)'
- en: To address situations like this, accessing a map key optionally returns a second,
    Boolean value. It will be `true` if the returned value has actually been assigned
    to the map, or `false` if the returned value just represents the default zero
    value. Most Go developers assign this Boolean value to a variable named `ok` (because
    the name is nice and short).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这类情况，访问映射键时可选择返回第二个布尔值。如果返回的值确实已分配给映射，则此值将为`true`；如果返回的值只是表示默认的零值，则为`false`。大多数Go开发者将此布尔值分配给名为`ok`的变量（因为名称简短好记）。
- en: '![image](assets/f0216-02.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0216-02.png)'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Go maintainers refer to this as the “comma ok idiom.” We’ll see it again
    with type assertions in [Chapter 11](ch11_split_000.html#what_can_you_doquestcolon_interfaces).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的维护者们将此称为“comma ok惯用法”。我们将在[第11章](ch11_split_000.html#what_can_you_doquestcolon_interfaces)中再次见到它，用于类型断言。
- en: If you only want to test whether a value is present, you can have the value
    itself ignored by assigning it to the `_` blank identifier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想测试一个值是否存在，可以通过将其分配给`_`空白标识符来忽略值本身。
- en: '![image](assets/f0216-03.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0216-03.png)'
- en: The second return value can be used to decide whether you should treat the value
    you got from the map as an assigned value that just happens to match the zero
    value for that type, or as an unassigned value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个返回值可用于确定您应该将从映射中获取的值视为已分配值，恰好与该类型的零值匹配，还是作为未分配值。
- en: 'Here’s an update to our code that tests whether the requested key has actually
    had a value assigned before it reports a failing grade:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们代码的更新版本，测试请求的键是否确实在报告不及格之前已分配了值：
- en: '![image](assets/f0217-01.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0217-01.png)'
- en: Removing key/value pairs with the “delete” function
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“delete”函数删除键/值对
- en: 'At some point after assigning a value to a key, you may want to remove it from
    your map. Go provides the built-in `delete` function for this purpose. Just pass
    the `delete` function two things: the map you want to delete a key from, and the
    key you want deleted. That key and its corresponding value will be removed from
    the map.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值分配给键后的某个时刻，您可能希望从映射中删除它。Go语言为此提供了内置的`delete`函数。只需将`delete`函数传递两个参数：要从中删除键的映射，以及要删除的键。该键及其对应的值将从映射中删除。
- en: In the code below, we assign values to keys in two different maps, then delete
    them again. After that, when we try accessing those keys, we get a zero value
    (which is `0` for the `ranks` map, `false` for the `isPrime` map). The secondary
    Boolean value is also `false` in each case, which means that the key is not present.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们在两个不同的映射中分配值给键，然后再次删除它们。之后，当我们尝试访问这些键时，我们得到一个零值（对于`ranks`映射是`0`，对于`isPrime`映射是`false`）。第二个布尔值在每种情况下也都是`false`，这意味着该键不存在。
- en: '![image](assets/f0218-01.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0218-01.png)'
- en: Updating our vote counting program to use maps
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的投票计数程序以使用映射
- en: Now that we understand maps a bit better, let’s see if we can use what we’ve
    learned to simplify our vote counting program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对映射有了更深入的了解，让我们看看能否利用所学知识简化我们的投票计数程序。
- en: '![image](assets/f0219-01.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0219-01.png)'
- en: Previously, we used a pair of slices, one called `names` that held candidate
    names, and one called `counts` held vote counts for each name. For each name we
    read from the file, we had to search through the slice of names, one by one, for
    a match. We then incremented the vote count for that name in the corresponding
    element of the `counts` slice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们使用了一对切片，一个称为`names`，保存候选人的名字，另一个称为`counts`，保存每个名字的投票数。对于从文件中读取的每个名字，我们必须逐个搜索`names`切片，找到匹配项。然后，在`counts`切片的相应元素中递增该名字的投票计数。
- en: '![image](assets/f0219-02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0219-02.png)'
- en: Using a map will be much simpler. We can replace the two slices with a single
    map (which we’ll also call `counts`). Our map will use candidate names as its
    keys, and integers (which will hold the vote counts for that name) as its values.
    Once that’s set up, all we have to do is use each candidate name we read from
    the file as a map key, and increment the value that key holds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射将更加简单。我们可以用一个单独的映射（我们也称之为`counts`）替换这两个切片。我们的映射将使用候选人姓名作为键，并使用整数（用于保存该姓名的投票数）作为值。设置好后，我们只需将从文件中读取的每个候选人姓名用作映射键，并增加该键所持有的值。
- en: 'Here’s some simplified code that creates a map and increments the values for
    some candidate names directly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些简化的代码，用于创建映射并直接递增一些候选人姓名的值：
- en: '![image](assets/f0219-03.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0219-03.png)'
- en: Our previous program needed separate logic to add new elements to both slices
    if the name wasn’t found...
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的程序需要单独的逻辑来向两个切片添加新元素，如果找不到姓名的话...
- en: '![image](assets/f0219-04.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0219-04.png)'
- en: But we don’t need to do that with a map. If the key we’re accessing doesn’t
    already exist, we’ll get the zero value back (literally `0` in this case, since
    our values are integers). We then increment that value, giving us `1`, which gets
    assigned to the map. When we encounter that name again, we’ll get the assigned
    value, which we can then increment as normal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们用映射不需要这样做。如果我们访问的键不存在，我们将得到零值返回（在这种情况下实际上是`0`，因为我们的值是整数）。然后我们增加该值，得到`1`，并将其分配给映射。当我们再次遇到该姓名时，我们将得到已分配的值，然后可以像往常一样递增。
- en: Next, let’s try incorporating our `counts` map into the actual program, so it
    can tally the votes from the actual file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试将我们的`counts`映射整合到实际程序中，以便它可以统计来自实际文件的投票。
- en: '![image](assets/f0220-01.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0220-01.png)'
- en: We’ll be honest; after all that work to learn about maps, the final code looks
    a little anticlimactic! We replace the two slice declarations with a single map
    declaration. Next is the code in the loop that processes strings from the file.
    We replace the original 11 lines of code there with a single line, which increments
    the count in the map for the current candidate name. And we replace the loop at
    the end that prints the results with a single line that prints the whole `counts`
    map.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，经过所有学习映射的工作，最终的代码看起来有点平淡无奇！我们用单个映射声明替换了两个切片声明。接下来是处理来自文件的字符串的循环中的原始代码。我们用一行代码替换了原来的11行代码，该代码在映射中递增当前候选人姓名的计数。最后，我们用一行代码替换了打印结果的末尾循环，该行代码打印整个`counts`映射。
- en: '![image](assets/f0220-02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0220-02.png)'
- en: Trust us, though, the code only *looks* anticlimactic. There are still complex
    operations going on here. But the map is handling them all for you, which means
    you don’t have to write as much code!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，相信我们，代码看起来只是*看似*平淡无奇。这里仍然有复杂的操作。但是映射已经为你处理了所有这些，这意味着你不需要写那么多代码！
- en: As before, you can recompile the program using the `go install` command. When
    we rerun the executable, the *votes.txt* file will be loaded and processed. We’ll
    see the `counts` map printed, with the number of times each name was encountered
    in the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，你可以使用`go install`命令重新编译程序。当我们重新运行可执行文件时，将加载并处理*votes.txt*文件。我们将看到打印的`counts`映射，其中显示了文件中每个姓名遇到的次数。
- en: '![image](assets/f0220-03.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0220-03.png)'
- en: Using for...range loops with maps
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for`...`range`循环与映射
- en: '![image](assets/f0221-01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0221-01.png)'
- en: '**Name: Kevin Wagner'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**姓名：凯文·瓦格纳'
- en: 'Occupation: Election Volunteer**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 职业：选举志愿者**
- en: 'That’s true. A format of one name and one vote count per line would probably
    be better:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。每行一个名字和一个投票计数的格式可能更好：
- en: '![image](assets/f0221-02.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0221-02.png)'
- en: To format each key and value from the map as a separate line, we’re going to
    need to loop through each entry in the map.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将映射中的每个键和值格式化为单独的行，我们需要循环遍历映射中的每个条目。
- en: The same `for`...`range` loop we’ve been using to process array and slice elements
    works on maps, too. Instead of assigning an integer index to the first variable
    you provide, however, the current map key will be assigned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用来处理数组和切片元素的相同`for`...`range`循环在映射上也适用。不过，与将整数索引分配给提供的第一个变量不同，当前映射键将被分配。
- en: '![image](assets/f0221-03.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0221-03.png)'
- en: The `for`...`range` loop makes it easy to loop through a map’s keys and values.
    Just provide a variable to hold each key, and another to hold the corresponding
    value, and it will automatically loop through each entry in the map.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`...`range`循环使得遍历映射键和值变得容易。只需提供一个变量来保存每个键，另一个变量来保存相应的值，它将自动遍历映射中的每个条目。'
- en: '![image](assets/f0222-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0222-01.png)'
- en: 'If you only need to loop through the keys, you can omit the variable that holds
    the values:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要遍历键，可以省略保存值的变量：
- en: '![image](assets/f0222-02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0222-02.png)'
- en: 'And if you only need the values, you can assign the keys to the `_` blank identifier:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要值，您可以将键分配给 `_` 空白标识符：
- en: '![image](assets/f0222-03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0222-03.png)'
- en: But there’s one potential issue with this example... If you save the preceding
    example to a file and run it with `go run`, you’ll find that the map keys and
    values are printed in a random order. If you run the program multiple times, you’ll
    get a different order each time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个例子可能存在一个潜在问题…… 如果您将前面的例子保存到文件并使用`go run`运行，您会发现映射的键和值以随机顺序打印出来。如果多次运行程序，每次都会得到不同的顺序。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '(Note: The same is not true of code run via the online Go Playground site.
    There, the order will still be random, but it will produce the same output each
    time it’s run.)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: （注意：在在线 Go Playground 站点上运行的代码不适用相同规则。在那里，顺序仍然是随机的，但每次运行时会产生相同的输出。）
- en: '![image](assets/f0222-04.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0222-04.png)'
- en: The for...range loop handles maps in random order!
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`...`range`循环以随机顺序处理映射！'
- en: The `for`...`range` loop processes map keys and values in a random order because
    a map is an *unordered* collection of keys and values. When you use a `for`...`range`
    loop with a map, you never know what order you’ll get the map’s contents in! Sometimes
    that’s fine, but if you need more consistent ordering, you’ll need to write the
    code for that yourself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`...`range`循环以随机顺序处理映射的键和值，因为映射是一个*无序*的键和值的集合。当您在映射上使用`for`...`range`循环时，您无法预测将以何种顺序获取映射的内容！有时这没关系，但如果需要更一致的顺序，就需要自己编写代码来处理。'
- en: Here’s an update to the previous program that always prints the names in alphabetical
    order. It does using two separate `for` loops. The first loops over each key in
    the map, ignoring the values, and adds them to a slice of strings. Then, the slice
    is passed to the `sort` package’s `Strings` function to sort it alphabetically,
    in place.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一个程序的更新版本，始终按字母顺序打印姓名。它使用两个单独的`for`循环。第一个循环遍历映射中的每个键，忽略值，并将它们添加到一个字符串切片中。然后，将该切片传递给`sort`包的`Strings`函数，按字母顺序对其进行就地排序。
- en: The second `for` loop doesn’t loop over the map, it loops over the sorted slice
    of names. (Which, thanks to the preceding code, now contains every key from the
    map in alphabetical order.) It prints the name and then gets the value that matches
    that name from the map. It still processes every key and value in the map, but
    it gets the keys from the sorted slice, not the map itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`for`循环不是遍历映射，而是遍历排序后的姓名切片。（由于前面的代码，此切片现在包含按字母顺序排列的映射中的每个键。）它打印姓名，然后从映射中获取与该姓名匹配的值。它仍然处理映射中的每个键和值，但是从排序后的切片中获取键，而不是从映射本身获取。
- en: '![image](assets/f0223-01.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0223-01.png)'
- en: If we save the above code and run it, this time the student names are printed
    in alphabetical order. This will be true no matter how many times we run the program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存上述代码并运行它，这次将按字母顺序打印学生姓名。无论我们运行程序多少次，这都是真实的。
- en: If it doesn’t matter what order your map data is processed in, using a `for`...`range`
    loop directly on the map will probably work for you. But if order matters, you
    may want to consider setting up your own code to handle the processing order.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不在乎映射数据的处理顺序，直接在映射上使用`for`...`range`循环可能适合您。但是如果顺序很重要，您可能需要考虑编写自己的代码来处理处理顺序。
- en: '![image](assets/f0223-02.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0223-02.png)'
- en: Updating our vote counting program with a for...range loop
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`for`...`range`循环更新我们的投票计数程序
- en: There aren’t a lot of candidates in Sleepy Creek County, so we don’t see a need
    to sort the output by name. We’ll just use a `for`...`range` loop to process the
    keys and values directly from the map.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在斯利比克里克县的候选人不多，因此我们不需要按姓名排序输出。我们将使用`for`...`range`循环直接处理来自映射的键和值。
- en: '![image](assets/f0224-01.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0224-01.png)'
- en: It’s a pretty simple change to make; we just replace the line that prints the
    entire map with a `for`...`range` loop. We’ll assign each key to a `name` variable,
    and each value to a `count` variable. Then we’ll call `Printf` to print the current
    candidate name and vote count.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的更改；我们只需用 `for`...`range` 循环替换打印整个映射的行。我们将每个键分配给一个 `name` 变量，每个值分配给一个
    `count` 变量。然后我们将调用 `Printf` 来打印当前候选人的姓名和选票数。
- en: '![image](assets/f0224-02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0224-02.png)'
- en: Another compilation via `go install`, another run of the executable, and we’ll
    see our output in its new format. Each candidate name and their vote count is
    here, neatly formatted on its own line.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `go install` 进行另一个编译，再运行可执行文件，我们就能看到以新格式输出的结果了。每个候选人的姓名和他们的选票数都在这里，整洁地格式化在各自的行上。
- en: '![image](assets/f0224-03.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0224-03.png)'
- en: The vote counting program is complete!
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投票计数程序完成！
- en: '![image](assets/f0225-01.png)![image](assets/f0225-02.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0225-01.png)![image](assets/f0225-02.png)'
- en: Our vote counting program is complete!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票计数程序已完成！
- en: When the only data collections we had available were arrays and slices, we needed
    a lot of extra code and processing time to look values up. But maps have made
    the process easy! Anytime you need to be able to find a collection’s values again,
    you should consider using a map!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只能使用数组和切片作为数据集合时，我们需要大量的额外代码和处理时间来查找值。但是使用了映射（map）后，这一过程变得很简单！每当你需要再次查找集合的值时，你都应该考虑使用映射！
- en: Code Magnets
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/bag.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/bag.png)'
- en: A Go program that uses a `for`...`range` loop to print out the contents of a
    map is scrambled up on the fridge. Can you reconstruct the code snippets to make
    a working program that will produce the given output? (It’s okay if the output
    order differs between runs of the program.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用 `for`...`range` 循环来打印映射内容的 Go 程序被混在冰箱上。你能重建代码片段，使之成为一个能够产生给定输出的可工作程序吗？（如果程序运行时输出顺序不同也没关系。）
- en: '![image](assets/f0226-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0226-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](ch07_split_001.html#code_magnets_solution_5).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在[“代码磁铁解决方案”](ch07_split_001.html#code_magnets_solution_5)中。'
- en: Your Go Toolbox
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的 Go 工具箱
- en: '![image](assets/f0227-01.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0227-01.png)'
- en: '**That’s it for [Chapter 7](ch07_split_000.html#labeling_datacolon_maps)! You’ve
    added maps to your toolbox.**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是[第七章](ch07_split_000.html#labeling_datacolon_maps)的全部内容！你已经把地图添加到了你的工具箱里。**'
- en: '![image](assets/f0227-02.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0227-02.png)'
- en: Code Magnets Solution
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁解决方案
- en: '![image](assets/f0229-01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image   ![image](assets/f0229-01.png)'
