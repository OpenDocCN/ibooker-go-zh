- en: 'Chapter 16\. a pattern to follow: HTML Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。一个遵循的模式：HTML模板
- en: '![image](assets/f0445-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0445-01.png)'
- en: '**Your web app needs to respond with HTML, not plain text.** Plain text is
    fine for emails and social media posts. But your pages need to be formatted. They
    need headings and paragraphs. They need forms where your users can submit data
    to your app. To do any of that, you need HTML code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**您的Web应用程序需要用HTML来响应，而不是纯文本。** 纯文本对于电子邮件和社交媒体帖子来说很好。但您的页面需要格式。它们需要标题和段落。它们需要表单，用户可以向您的应用程序提交数据。为了做到这些，您需要HTML代码。'
- en: And eventually, you’ll need to insert data into that HTML code. That’s why Go
    offers the `html/template` package, a powerful way to include data in your app’s
    HTML responses. Templates are key to building bigger, better web apps, and in
    this final chapter, we’ll show you how to use them!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您将需要将数据插入到HTML代码中。这就是为什么Go提供了`html/template`包的原因，这是一种强大的方式，可以将数据包含到您应用程序的HTML响应中。模板是构建更大、更好的Web应用程序的关键，在这最后一章中，我们将向您展示如何使用它们！
- en: A guestbook app
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个留言板应用程序
- en: Let’s put everything we’ve learned in [Chapter 15](ch15.html#responding_to_requestscolon_web_apps)
    to use. We’re going to build a simple guestbook app for a website. Your visitors
    will be able to enter messages in a form, which will be saved to a file. They’ll
    also be able to view a list of all the previous signatures.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们在[第15章](ch15.html#responding_to_requestscolon_web_apps)中学到的东西用起来。我们将为网站构建一个简单的留言板应用程序。您的访客将能够在表单中输入消息，并将其保存到文件中。他们还可以查看以前所有签名的列表。
- en: '![image](assets/f0446-01.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0446-01.png)'
- en: There’s a lot left to cover before we can get this app working, but don’t worry—we’ll
    be breaking this process down into little steps. Let’s take a look at what will
    be involved...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能让这个应用程序正常工作之前，还有很多内容需要覆盖，但不要担心——我们将把这个过程分解成小步骤。让我们看看将涉及哪些内容……
- en: We’ll need to set up our app and get it to respond to requests for the main
    guestbook page. This part won’t be too difficult; we’ve already covered everything
    we need to know in the previous chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置我们的应用程序，并使其响应主留言板页面的请求。这部分不会太难；我们已经在前一章中覆盖了所有需要了解的内容。
- en: Then we need to include HTML in our response. We’ll be creating a simple page
    using just a few HTML tags, which we’ll store in a file. Then we’ll load the HTML
    code in from the file and use that in our app’s response.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在响应中包含HTML。我们将创建一个简单的页面，只使用几个HTML标签，并将其存储在文件中。然后我们将从文件中加载HTML代码，并在我们应用程序的响应中使用它。
- en: We’ll need to take the signatures that our visitors have entered, and incorporate
    them into the HTML. We’ll show you how to do this, using the `html/template` package.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取访客输入的签名，并将它们合并到HTML中。我们将向您展示如何使用`html/template`包来完成这一操作。
- en: Then we’ll need to create a separate page with a form for adding a signature.
    We can do this fairly easily using HTML.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个单独的页面，用于添加签名的表单。我们可以使用HTML相当容易地完成这个任务。
- en: Lastly, when a user submits the form, we’ll need to save the form contents as
    a new signature. We’ll save it to a text file along with all the other submitted
    signatures so we can load it back in later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户提交表单时，我们需要将表单内容保存为新的签名。我们将其保存到文本文件中，并与所有其他提交的签名一起加载回来。
- en: '![image](assets/f0446-02.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0446-02.png)'
- en: Functions to handle a request and check errors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求和检查错误的函数
- en: Our first task will be to display the main guestbook page. With all the practice
    we’ve had writing sample web apps, this shouldn’t be too difficult. In our `main`
    function, we’ll call `http.HandleFunc` and set up the app to call a function named
    `viewHandler` for any request with a path of `"/guestbook"`. Then we’ll call `http.ListenAndServe`
    to start the server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务将是显示主留言板页面。通过编写示例Web应用程序的实践，这应该不会太难。在我们的`main`函数中，我们将调用`http.HandleFunc`并设置应用程序，以便为路径为`"/guestbook"`的任何请求调用名为`viewHandler`的函数。然后，我们将调用`http.ListenAndServe`来启动服务器。
- en: For now, the `viewHandler` function will look just like the handler functions
    in our previous examples. It accepts an `http.ResponseWriter` and a pointer to
    an `http.Request`, just like previous handlers. We’ll convert a string for the
    response to a `[]byte`, and use the `Write` method on the `ResponseWriter` to
    add it to the response.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`viewHandler`函数看起来与我们之前示例中的处理程序函数完全相同。它接受一个`http.ResponseWriter`和一个`http.Request`的指针，就像之前的处理程序一样。我们将一个字符串转换为`[]byte`，并使用`ResponseWriter`的`Write`方法将其添加到响应中。
- en: The `check` function is the only part of this code that’s really new. We’re
    going to have a lot of potential `error` return values in this web app, and we
    don’t want to repeat code to check and report them everywhere. So we’ll pass each
    error to our new `check` function. If the `error` is nil, `check` does nothing,
    but otherwise it logs the error and exits the program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`函数是此代码中唯一真正新的部分。在这个Web应用程序中，我们可能会有很多潜在的`error`返回值，并且我们不想在每个地方重复代码来检查和报告它们。因此，我们将每个错误传递给我们的新`check`函数。如果`error`为nil，则`check`什么也不做，但否则它会记录错误并退出程序。'
- en: '![image](assets/f0447-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0447-01.png)'
- en: Calling `Write` on the `ResponseWriter` may or may not return an error, so we
    pass the `error` return value to `check`. Notice that we *don’t* pass the `error`
    return value from `http.ListenAndServe` to `check`, though. That’s because `ListenAndServe`
    always returns an error. (If there is no error, `ListenAndServe` never returns.)
    Since we know this error will never be `nil`, we just immediately call `log.Fatal`
    on it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ResponseWriter`上调用`Write`可能会返回错误，所以我们将`error`返回值传递给`check`。注意，我们*不会*将`error`返回值从`http.ListenAndServe`传递给`check`。这是因为`ListenAndServe`总是返回一个错误。（如果没有错误，`ListenAndServe`永远不会返回。）由于我们知道这个错误永远不会是`nil`，我们只是立即在其上调用`log.Fatal`。
- en: Setting up a project directory and trying the app
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目目录并尝试应用程序
- en: We’ll be creating several files for this project, so you might want to take
    a moment and create a new directory to hold them all. (It doesn’t have to be within
    your Go workspace directory.) Save the preceding code within this directory, in
    a file named *guestbook.go*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将创建几个文件，因此您可能希望花一点时间创建一个新目录来保存它们。（它不必在您的Go工作区目录内。）将前述代码保存在此目录中，文件名为*guestbook.go*。
- en: '![image](assets/f0448-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0448-01.png)'
- en: Let’s try running it. In your terminal, change to the directory where *guestbook.go*
    is saved and run it using **`go run`**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着运行它。在您的终端中，切换到保存*guestbook.go*的目录，并使用**`go run`**运行它。
- en: '![image](assets/f0448-02.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0448-02.png)'
- en: 'Then visit this URL in your browser:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在浏览器中访问此URL：
- en: '`*[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`*[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*`'
- en: 'It’s the same as the URLs for our previous apps, except for the */guestbook*
    path on the end. Your browser will make a request to the app, which will respond
    with our placeholder text:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前应用程序的URL相同，只是在末尾加上了*/guestbook*路径。您的浏览器将向应用程序发出请求，应用程序将以我们的占位文本作出响应：
- en: '![image](assets/f0448-03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0448-03.png)'
- en: Our app is now responding to requests. Our first task is complete!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在正在响应请求。我们的第一个任务完成了！
- en: '![image](assets/f0448-04.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0448-04.png)'
- en: We’re just responding using plain text, though. Up next, we’re going to format
    our response using HTML.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只是使用纯文本进行响应。接下来，我们将使用HTML格式化我们的响应。
- en: Making a signature list in HTML
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML中创建签名列表
- en: So far, we’ve just been sending snippets of text to the browser. We need actual
    HTML, so that we can apply formatting to the page. HTML uses tags to apply formatting
    to text.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是向浏览器发送了一些文本片段。我们需要实际的HTML，以便对页面应用格式。HTML使用标签对文本应用格式。
- en: Don’t worry if you haven’t written HTML before; we’ll be covering the basics
    as we go!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有编写HTML，不用担心；随着我们的进展，我们将涵盖基础知识！
- en: Save the HTML code below in the same directory as *guestbook.go*, in a file
    named *view.html*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在与*guestbook.go*相同的目录中，将下面的HTML代码保存在名为*view.html*的文件中。
- en: 'Here are the HTML elements used in this file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中使用的HTML元素如下：
- en: '`<h1>`: A level-one heading. Usually shown in large, bold text.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1>`：一级标题。通常显示为大号加粗文本。'
- en: '`<div>`: A division element. Not directly visible on its own, but it’s used
    for dividing the page into sections.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div>`：分割元素。单独使用时不直接可见，但用于将页面分割为各个部分。'
- en: '`<p>`: A paragraph of text. We’ll be treating each signature as a separate
    paragraph.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p>`：段落文本。我们将每个签名视为独立的段落。'
- en: '`<a>`: Stands for “anchor.” Creates a link.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<a>`：代表“锚点”。创建一个链接。'
- en: '![image](assets/f0449-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0449-01.png)'
- en: Now, let’s try viewing the HTML in a browser. Launch your favorite web browser,
    choose “Open File…” from the menu, and open the HTML file you just saved.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在浏览器中查看HTML。启动您喜欢的网络浏览器，从菜单中选择“打开文件…”，并打开您刚刚保存的HTML文件。
- en: '![image](assets/f0449-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0449-02.png)'
- en: Notice how the elements on the page correspond with the HTML code. Each element
    has a opening tag (`<h1>`, `<div>`, `<p>`, etc.), and a corresponding closing
    tag (`</h1>`, `</div>`, `</p>`, etc.). Any text between the opening and closing
    tags is used as the element’s content on the page. It’s also possible for elements
    to contain other elements (as the `<div>` elements on this page do).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意页面上的元素如何与HTML代码对应。每个元素都有一个开放标签（`<h1>`，`<div>`，`<p>`等），以及相应的闭合标签（`</h1>`，`</div>`，`</p>`等）。在开放和闭合标签之间的任何文本将用作页面上元素的内容。元素还可以包含其他元素（就像此页面上的`<div>`元素一样）。
- en: You can click on the link if you want, but it will only produce a “Page not
    found” error right now. Before we can fix that, we’ll need to figure out how to
    serve this HTML via our web app...
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以单击链接，但现在只会产生“页面未找到”错误。在我们修复这个问题之前，我们需要弄清楚如何通过我们的Web应用程序提供此HTML...
- en: '![image](assets/f0449-03.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0449-03.png)'
- en: Making our app respond with HTML
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的应用程序响应HTML
- en: Our HTML works when we load it directly into our browser from the *view.html*
    file, but we need to serve it via the app. Let’s update our *guestbook.go* code
    to respond with the HTML we’ve created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接从*view.html*文件加载HTML到浏览器时，我们的HTML可以正常工作，但我们需要通过应用程序提供它。让我们更新我们的*guestbook.go*代码以响应我们创建的HTML。
- en: 'Go provides a package that will load the HTML in from the file *and* insert
    signatures into it for us: the `html/template` package. For now, we’ll just load
    the contents of *view.html* in as is; inserting signatures will be our next step.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个包，可以从文件中加载HTML并为我们插入签名：`html/template`包。现在，我们将加载*view.html*的内容，插入签名将是我们的下一步。
- en: 'We’ll need to update the `import` statement to add the `html/template` package.
    The only other changes we’ll need to make are within the `viewHandler` function.
    We’ll call the `template.ParseFiles` function and pass it the name of the file
    we want to load: `"view.html"`. This will use the contents of *view.html* to create
    a `Template` value. `ParseFiles` will return a pointer to this `Template`, and
    possibly an `error` value, which we pass to our `check` function.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`import`语句以添加`html/template`包。我们需要做的唯一其他更改是在`viewHandler`函数内部。我们将调用`template.ParseFiles`函数并传递要加载的文件名：“view.html”。这将使用*view.html*的内容创建一个`Template`值。`ParseFiles`将返回指向此`Template`的指针，可能还会返回一个`error`值，我们将其传递给我们的`check`函数。
- en: To get output from the `Template` value, we call its `Execute` method with two
    arguments... We pass our `ResponseWriter` value as the place to write the output.
    The second value is the data we want to insert into the template, but since we’re
    not inserting anything right now, we just pass `nil`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`Template`值获取输出，我们调用其`Execute`方法并传入两个参数... 我们将我们的`ResponseWriter`值传递为写入输出的位置。第二个值是我们想要插入模板中的数据，但由于我们现在不插入任何内容，所以我们只传递`nil`。
- en: '![image](assets/f0450-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0450-01.png)'
- en: We’ll be learning more about the `html/template` package shortly, but for now
    let’s just see if this works. In your terminal, run *guestbook.go*. (Make sure
    you’re in your project directory when you do this, or the `ParseFiles` function
    won’t be able to find *view.html*.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将学习更多关于`html/template`包的知识，但现在让我们看看这是否有效。在终端中运行*guestbook.go*。（确保在运行此命令时您在项目目录中，否则`ParseFiles`函数将无法找到*view.html*。）
- en: 'In your browser, go back to the URL:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，返回到以下URL：
- en: '*[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*'
- en: Instead of the “signature list goes here” placeholder, you should see the HTML
    from *view.html*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到来自*view.html*的HTML，而不是“签名列表在这里”占位符。
- en: '![image](assets/f0450-02.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0450-02.png)'
- en: The “text/template” package
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “text/template”包
- en: Our app is responding with our HTML code. That’s two tasks complete!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序正在响应我们的HTML代码。这是两个任务完成了！
- en: Right now, though, we’re just showing a placeholder list of signatures that
    we hardcoded. Our next task will be to use the `html/template` package to insert
    a list of signatures into the HTML, one that will be updated when the list changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，目前我们只显示了一个硬编码的占位符签名列表。我们下一个任务将是使用`html/template`包将签名列表插入到HTML中，当列表更改时将更新。
- en: '![image](assets/f0451-01.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0451-01.png)'
- en: The `html/template` package is based on the `text/template` package. You work
    with the two packages in almost exactly the same way, but `html/template` has
    some extra security features needed for working with HTML. Let’s learn how to
    use the `text/template` package first, and then later we’ll take what we’ve learned
    and apply it to the `html/template` package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`html/template` 包基于 `text/template` 包。你几乎完全相同的方式使用这两个包，但 `html/template` 添加了一些必要的安全功能，用于处理
    HTML。让我们先学习如何使用 `text/template` 包，稍后再将我们所学的应用到 `html/template` 包上。'
- en: The program below uses `text/template` to parse and print a template string.
    It prints its output to the terminal, so you won’t need your web browser to try
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序使用 `text/template` 来解析并打印一个模板字符串。它将输出打印到终端，因此您不需要使用浏览器来尝试它。
- en: In `main`, we call the `text/template` package’s `New` function, which returns
    a pointer to a new `Template` value. Then we call the `Parse` method on the `Template`,
    and pass it the string `"Here's my template!\n"`. `Parse` uses its string argument
    as the template’s text, unlike `ParseFiles`, which loads the template text in
    from files. `Parse` returns the template and an `error` value. We store the template
    in the `tmpl` variable, and pass the `error` to a `check` function (identical
    to the one in *guestbook.go*) to report any non-`nil` errors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们调用 `text/template` 包的 `New` 函数，它返回一个指向新 `Template` 值的指针。然后我们在
    `Template` 上调用 `Parse` 方法，并传递字符串 `"Here's my template!\n"`。`Parse` 使用其字符串参数作为模板的文本，不同于
    `ParseFiles` 从文件加载模板文本。`Parse` 返回模板和一个 `error` 值。我们将模板存储在 `tmpl` 变量中，并将 `error`
    传递给一个 `check` 函数（与 *guestbook.go* 中的函数相同），以报告任何非 `nil` 错误。
- en: Then we call the `Execute` method on the `Template` value in `tmpl`, just like
    we did in *guestbook.go*. Instead of an `http.ResponseWriter`, though, we pass
    `os.Stdout` as the place to write the output. This causes the `"Here's my template!\n"`
    template string to be displayed as output when the program is run.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `tmpl` 中调用 `Template` 值的 `Execute` 方法，就像在 *guestbook.go* 中一样。不过，这次我们将
    `os.Stdout` 作为输出位置传递。这会导致程序运行时将 `"Here's my template!\n"` 模板字符串显示为输出。
- en: '![image](assets/f0451-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0451-02.png)'
- en: Using the io.Writer interface with a template’s Execute method
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `io.Writer` 接口和模板的 `Execute` 方法
- en: '![image](assets/f0452-01.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0452-01.png)'
- en: The `os.Stdout` value is part of the `os` package. `Stdout` stands for “standard
    output.” It acts like a file, but any data written to it is output to the terminal
    instead of being saved to disk. (Functions like `fmt.Println`, `fmt.Printf`, and
    so on write data to `os.Stdout` behind the scenes.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Stdout` 值是 `os` 包的一部分。`Stdout` 代表“标准输出”。它的行为类似于文件，但将写入到它的任何数据都输出到终端，而不是保存到磁盘。（像
    `fmt.Println`、`fmt.Printf` 等函数在后台写入数据到 `os.Stdout`。）'
- en: How can `http.ResponseWriter` and `os.Stdout` both be valid arguments for `Template.Execute`?
    Let’s bring up its documentation and see...
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.ResponseWriter` 和 `os.Stdout` 如何都能作为 `Template.Execute` 的有效参数？让我们查看它的文档...'
- en: '![image](assets/f0452-02.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0452-02.png)'
- en: 'Hmm, this says the first argument to `Execute` should be an `io.Writer`. What’s
    that? Let’s check the documentation for the `io` package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，这里说 `Execute` 的第一个参数应该是一个 `io.Writer`。那是什么？让我们查一下 `io` 包的文档：
- en: '![image](assets/f0452-03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0452-03.png)'
- en: It looks like `io.Writer` is an interface! It’s satisfied by any type with a
    `Write` method that accepts a slice of `byte` values, and returns an `int` with
    the number of bytes written and an `error` value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `io.Writer` 是一个接口！它可以由任何具有接受 `byte` 值切片并返回写入的字节数和一个 `error` 值的 `Write` 方法满足。
- en: ResponseWriters and os.Stdout both satisfy io.Writer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ResponseWriters` 和 `os.Stdout` 都满足 `io.Writer` 接口。'
- en: 'We’ve already seen that `http.ResponseWriter` values have a `Write` method.
    We’ve used `Write` in several earlier examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `http.ResponseWriter` 值有一个 `Write` 方法。我们在几个早期的示例中使用了 `Write`：
- en: '![image](assets/f0453-01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0453-01.png)'
- en: 'It turns out the `os.Stdout` value has a `Write` method, too! If you pass it
    a slice of `byte` values, that data will be written to the terminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 原来 `os.Stdout` 值也有一个 `Write` 方法！如果你向它传递一个 `byte` 值的切片，这些数据将被写入终端：
- en: '![image](assets/f0453-02.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0453-02.png)'
- en: That means both `http.ResponseWriter` values and `os.Stdout` satisfy the `io.Writer`
    interface, and can be passed to a `Template` value’s `Execute` method. `Execute`
    will write out the template by calling the `Write` method on whatever value is
    passed to it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `http.ResponseWriter` 值和 `os.Stdout` 都满足 `io.Writer` 接口，并且可以传递给 `Template`
    值的 `Execute` 方法。`Execute` 方法会调用传递给它的值的 `Write` 方法来输出模板。
- en: 'If you pass in an `http.ResponseWriter`, it means the template will be written
    to the HTTP response. And if you pass in `os.Stdout`, it means the template will
    be written to the output in the terminal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传入一个`http.ResponseWriter`，意味着模板将被写入到HTTP响应中。如果你传入`os.Stdout`，意味着模板将被写入到终端的输出中：
- en: '![image](assets/f0453-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0453-03.png)'
- en: Inserting data into templates using actions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作向模板插入数据
- en: The second parameter to a `Template` value’s `Execute` method allows you to
    pass in data to insert in the template. Its type is the empty interface, meaning
    you can pass in a value of any type you want.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Template`值的`Execute`方法的第二个参数允许你传入要插入模板的数据。它的类型是空接口，意味着你可以传入任何类型的值。'
- en: '![image](assets/f0454-01.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0454-01.png)'
- en: 'So far, our templates haven’t provided any places to insert data, so we’ve
    just been passing `nil` for the data value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模板尚未提供任何插入数据的位置，因此我们一直使用`nil`作为数据值：
- en: '![image](assets/f0454-02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0454-02.png)'
- en: To insert data in a template, you add **actions** to the template text. Actions
    are denoted with double curly braces, `{{ }}`. Inside the double braces, you specify
    data you want to insert or an operation you want the template to perform. Whenever
    the template encounters an action, it will evaluate its contents, and insert the
    result into the template text in place of the action.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中插入数据，你需要在模板文本中添加**动作**。动作用双花括号`{{ }}`表示。在双花括号内部，你可以指定要插入的数据或者模板执行的操作。每当模板遇到一个动作时，它会评估其内容，并将结果插入到模板文本中，取代动作本身。
- en: Within an action, you can reference the data value that was passed to the `Execute`
    method with a single period, called “dot.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在动作内部，你可以使用一个句点引用传递给`Execute`方法的数据值，称为“dot”。
- en: This code sets up a template with a single action. It then calls `Execute` on
    the template several times, with a different data value each time. `Execute` replaces
    the action with the data value before writing the result to `os.Stdout`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个带有单个动作的模板。然后它多次调用模板的`Execute`方法，每次使用不同的数据值。`Execute`在将结果写入`os.Stdout`之前，将动作替换为数据值。
- en: '![image](assets/f0454-03.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0454-03.png)'
- en: There are lots of other things you can do with template actions, too. Let’s
    set up an `executeTemplate` function that will let us experiment with them more
    easily. It will take a template string that we’ll pass to `Parse` to create a
    new template, and a data value that we’ll pass to `Execute` on that template.
    As before, each template will be written to `os.Stdout`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他可以使用模板动作实现的功能。让我们设置一个`executeTemplate`函数，让我们更轻松地进行实验。它将接受一个模板字符串，我们将其传递给`Parse`以创建新模板，并接受一个数据值，我们将其传递给该模板的`Execute`方法。与之前一样，每个模板将被写入到`os.Stdout`中。
- en: '![image](assets/f0455-01.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0455-01.png)'
- en: As we mentioned, you can use a single period to refer to “dot,” the current
    value within the data the template is working with. Although the value of dot
    can change in various contexts within the template, initially it refers to the
    value that was passed to `Execute`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前文提到的，你可以使用一个句点来引用“dot”，即模板正在处理的数据中的当前值。虽然句点的值在模板内的不同上下文中可能会改变，但最初它指的是传递给`Execute`的值。
- en: '![image](assets/f0455-02.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0455-02.png)'
- en: Making parts of a template optional with “if” actions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“if”动作使模板的部分内容成为可选项
- en: A section of a template between an `{{if}}` action and its corresponding `{{end}}`
    marker will be included only if a condition is true. Here we execute the same
    template text twice, once when dot is `true` and once when it’s `false`. Thanks
    to the `{{if}}` action, the “Dot is true!” text is only included in the output
    when dot is `true`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`{{if}}`动作及其对应的`{{end}}`标记之间的模板部分仅在条件为真时才会包含。在此示例中，我们执行相同的模板文本两次，一次是在`dot`为`true`时，一次是在`dot`为`false`时。由于`{{if}}`动作的存在，只有在`dot`为`true`时，“Dot
    is true!”文本才会包含在输出中。
- en: '![image](assets/f0455-03.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0455-03.png)'
- en: Repeating parts of a template with “range” actions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“range”动作重复模板的部分内容
- en: A section of a template between a `{{range}}` action and its corresponding `{{end}}`
    marker will be repeated for each value collected in an array, slice, map, or channel.
    Any actions within that section will also be repeated.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`{{range}}`动作及其对应的`{{end}}`标记之间的模板部分将根据数组、切片、映射或通道中收集的每个值重复。该部分内的任何动作也将被重复。
- en: Within the repeated section, the value of dot will be set to the current element
    from the collection, allowing you to include each element in the output or do
    other processing with it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复的部分内，dot的值将设置为集合中的当前元素，允许您将每个元素包含在输出中或对其进行其他处理。
- en: This template includes a `{{range}}` action that will output each element in
    a slice. Before and after the loop, the value of dot will be the slice itself.
    But *within* the loop, dot refers to the current element of the slice. You’ll
    see this reflected in the output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板包括一个`{{range}}`动作，将会输出切片中的每个元素。循环之前和之后，dot的值将是切片本身。但是在循环*内部*，dot指的是切片的当前元素。你会在输出中看到这一点。
- en: '![image](assets/f0456-01.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0456-01.png)'
- en: This template works with a slice of `float64` values, which it will display
    as a list of prices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板处理一个`float64`值的切片，它会将其显示为价格列表。
- en: '![image](assets/f0456-02.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0456-02.png)'
- en: 'If the value provided to the `{{range}}` action is empty or `nil`, the loop
    won’t be run at all:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供给`{{range}}`动作的值为空或`nil`，则循环将不会运行：
- en: '![image](assets/f0456-03.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0456-03.png)'
- en: Inserting struct fields into a template with actions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动作将结构体字段插入模板
- en: Simple types usually can’t hold the variety of information needed to fill in
    a template, though. It’s more common to use struct types when executing a template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行模板时，简单类型通常无法保存填充模板所需的各种信息。在这种情况下，使用结构体类型更为常见。
- en: 'If the value in dot is a struct, then an action with dot followed by a field
    name will insert that field’s value in the template. Here we create a `Part` struct
    type, then set up a template that will output a `Part` value’s `Name` and `Count`
    fields:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果dot中的值是一个结构体，那么接下来一个带有dot和字段名的动作将在模板中插入该字段的值。在这里，我们创建了一个`Part`结构体类型，然后设置了一个模板，该模板将输出`Part`值的`Name`和`Count`字段：
- en: '![image](assets/f0457-01.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0457-01.png)'
- en: Finally, below we declare a `Subscriber` struct type and a template that prints
    them. The template will output the `Name` field regardless, but it uses an `{{if}}`
    action to output the `Rate` field only if the `Active` field is set to `true`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下面我们声明了一个`Subscriber`结构体类型和一个打印它们的模板。该模板将无论如何输出`Name`字段，但是它使用`{{if}}`动作仅在`Active`字段设置为`true`时才输出`Rate`字段。
- en: '![image](assets/f0457-02.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0457-02.png)'
- en: 'There’s a lot more you can do with templates, and we don’t have space to cover
    it all here. To learn more, look up the documentation for the `text/template`
    package:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用模板做很多其他事情，我们这里没有足够的空间来覆盖它们所有。要了解更多，请查阅`text/template`包的文档：
- en: '![image](assets/f0457-03.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0457-03.png)'
- en: Reading a slice of signatures in from a file
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取签名切片
- en: Now that we know how to insert data into a template, we’re almost ready to insert
    signatures into the guestbook page. But first, we’re going to need signatures
    that we can insert.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将数据插入模板，我们几乎可以将签名插入到访客留言板页面中了。但是首先，我们需要一些可以插入的签名。
- en: In your project directory, save a few lines of text to a plain-text file named
    *signatures.txt*. These are going to serve as our “signatures” for now.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中，保存几行文本到一个名为*signatures.txt*的纯文本文件中。这些暂时将作为我们的“签名”。
- en: Now we need the ability to load these signatures into our app. In *guestbook.go*,
    add a new `getStrings` function. This function will work a lot like the `datafile.GetStrings`
    function we wrote back in [Chapter 7](ch07_split_000.html#labeling_datacolon_maps),
    reading a file and appending each line to a slice of strings, which it then returns.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要能够将这些签名加载到我们的应用程序中。在*guestbook.go*中，添加一个新的`getStrings`函数。这个函数的工作方式类似于我们在[第7章](ch07_split_000.html#labeling_datacolon_maps)中编写的`datafile.GetStrings`函数，它会读取文件并将每一行追加到一个字符串切片中，然后返回这个切片。
- en: '![image](assets/f0458-01.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0458-01.png)'
- en: But there are a couple differences. First, the new `getStrings` will rely on
    our `check` function to report errors rather than returning them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但是也有一些区别。首先，新的`getStrings`将依赖我们的`check`函数来报告错误，而不是直接返回它们。
- en: Second, if the file doesn’t exist, `getStrings` will just return `nil` in place
    of the slice of strings, rather than reporting an error. It does this by passing
    any `error` value it gets from `os.Open` to the `os.IsNotExist` function, which
    will return `true` if the error indicates that the file doesn’t exist.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果文件不存在，`getStrings`将会返回`nil`而不是报告错误，而是通过将从`os.Open`获取的任何`error`值传递给`os.IsNotExist`函数来做到这一点，如果错误指示文件不存在，则该函数将返回`true`。
- en: '![image](assets/f0458-02.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0458-02.png)'
- en: We’ll also make a small change to the `viewHandler` function, adding a call
    to `getStrings` and a temporary `fmt.Printf` call to show us what was loaded from
    the file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将对`viewHandler`函数进行小小的更改，添加一个调用`getStrings`的调用以及一个临时的`fmt.Printf`调用，以显示从文件加载的内容。
- en: '![image](assets/f0459-01.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0459-01.png)'
- en: Let’s try the `getStrings` function out. In your terminal, change to your project
    directory, and run *guestbook.go*. Visit *[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*
    in your browser, so that the `viewHandler` function is called. It will call `getStrings`,
    which will load and return a slice with the contents of *signatures.txt*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试`getStrings`函数。在您的终端中，切换到项目目录，并运行*guestbook.go*。在浏览器中访问*[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*，这样就会调用`viewHandler`函数。它将调用`getStrings`，后者将加载并返回包含*signatures.txt*内容的切片。
- en: '![image](assets/f0459-02.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0459-02.png)'
- en: there are no Dumb Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: What happens if the signatures.txt file doesn’t exist, and `getStrings`
    returns `nil`? Won’t that cause problems rendering the template?**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q：如果`signatures.txt`文件不存在，并且`getStrings`返回`nil`，会导致渲染模板时出现问题吗？**'
- en: '**A:** There’s no need to worry. Just as we’ve already seen with the `append`
    function, other functions in Go are generally set up to treat `nil` slices and
    maps as if they were empty. For example, the `len` function simply returns `0`
    if it’s passed a `nil` slice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 没有必要担心。就像我们已经在`append`函数中看到的那样，Go中的其他函数通常会将`nil`切片和映射视为为空。例如，如果传递了`nil`切片，`len`函数会简单地返回`0`：'
- en: '![image](assets/f0459-03.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0459-03.png)'
- en: And template actions treat `nil` slices and maps as if they were empty, too.
    As we learned, for example, the `{{range}}` action simply skips outputting its
    contents if it’s given a `nil` value. So having `getStrings` return `nil` instead
    of a slice will be fine; if no signatures are loaded from the file, the template
    will just skip outputting any signatures.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并且模板操作也将`nil`的切片和映射视为为空。正如我们所学的那样，例如，`{{range}}`操作如果给定了`nil`值，将简单地跳过输出其内容。因此，`getStrings`返回一个`nil`切片而不是一个切片将是合适的；如果从文件中没有加载任何签名，模板将跳过输出任何签名。
- en: A struct to hold the signatures and signature count
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个结构体来保存签名和签名计数
- en: Now, we could just pass this slice of signatures to our HTML template’s `Execute`
    method, and have the signatures inserted into the template. But we also want our
    main guestbook page to show the *number* of signatures we’ve received, along with
    the signatures themselves.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这些签名的切片直接传递给我们的HTML模板的`Execute`方法，并将签名插入模板中。但是我们还希望我们的主留言簿页面显示接收到的签名的*数量*，以及签名本身。
- en: We only get to pass one value to the template’s `Execute` method, though. So
    we’ll need to create a struct type that will hold both the total number of signatures
    as well as the slice with the signatures themselves.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能将一个值传递给模板的`Execute`方法。因此，我们需要创建一个结构类型，它将包含签名的总数以及签名本身的切片。
- en: '![image](assets/f0460-01.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0460-01.png)'
- en: 'Near the top of the *guestbook.go* file, add a new declaration for a new `Guestbook`
    struct type. It should have two fields: a `SignatureCount` field to hold the number
    of signatures, and a `Signatures` field to hold the slice with the signatures
    themselves.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在*guestbook.go*文件的顶部附近，添加一个新的声明，用于新的`Guestbook`结构类型。它应该有两个字段：一个`SignatureCount`字段来保存签名的数量，和一个`Signatures`字段来保存签名本身的切片。
- en: '![image](assets/f0460-02.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0460-02.png)'
- en: Now we need to update `viewHandler` to create a new `Guestbook` struct and pass
    it to the template. First, we won’t be needing the `fmt.Printf` call that displays
    the contents of the `signatures` slice anymore, so remove that. (You’ll also need
    to remove `"fmt"` from the `import` section.) Then, create a new `Guestbook` value.
    Set its `SignatureCount` field to the length of the `signatures` slice, and set
    its `Signatures` field to the `signatures` slice itself. Finally, we need to actually
    pass the data into the template. So change the data value being passed as the
    second argument to the `Execute` method from `nil` to our new `Guestbook` value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`viewHandler`函数，以创建一个新的`Guestbook`结构，并将其传递给模板。首先，我们不再需要显示`signatures`切片内容的`fmt.Printf`调用，所以删除它（您还需要从`import`部分删除`"fmt"`）。然后，创建一个新的`Guestbook`值。将其`SignatureCount`字段设置为`signatures`切片的长度，并将其`Signatures`字段设置为`signatures`切片本身。最后，我们需要将数据实际传递给模板。因此，将作为`Execute`方法第二个参数传递的数据值从`nil`更改为我们的新`Guestbook`值。
- en: '![image](assets/f0460-03.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0460-03.png)'
- en: Updating our template to include our signatures
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的模板以包含我们的签名
- en: Now let’s update the template text in *view.html* to display the list of signatures.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新 *view.html* 中的模板文本以显示签名列表。
- en: 'We’re passing the `Guestbook` struct into the template’s `Execute` method,
    so within the template, dot represents that `Guestbook` struct. In the first `div`
    element, replace the `X` placeholder in `X total signatures` with an action that
    inserts the `Guestbook`’s `SignatureCount` field: `{{.SignatureCount}}`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Guestbook` 结构体传递给模板的 `Execute` 方法，因此在模板中，点号代表了 `Guestbook` 结构体。在第一个 `div`
    元素中，用 `X total signatures` 中的 `X` 占位符替换为插入 `Guestbook` 的 `SignatureCount` 字段的操作：`{{.SignatureCount}}`。
- en: 'The second `div` element holds a series of `p` (paragraph) elements, one for
    each signature. Use a `range` action to loop over each signature in the `Signatures`
    slice: `{{range .Signatures}}`. (Don’t forget the corresponding `{{end}}` marker
    before the end of the `div` element.) Within the `range` action, include a `p`
    HTML element with an action that outputs dot nested inside it: `<p>{{.}}</p>`.
    Remember that dot gets set to each element of a slice in turn, so this will cause
    a `p` element to be output for each signature in the slice, with its content set
    to that signature’s text.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `div` 元素包含一系列 `p`（段落）元素，每个签名对应一个。使用 `range` 操作循环遍历 `Signatures` 切片中的每个签名：`{{range
    .Signatures}}`。（不要忘记在 `div` 元素结束之前加上对应的 `{{end}}` 标记。）在 `range` 操作中，包含一个 `p` HTML
    元素，并在其中输出点号的嵌套内容：`<p>{{.}}</p>`。请记住，点号会依次设置为切片中的每个元素，因此这将导致为切片中的每个签名输出一个 `p` 元素，其内容设置为该签名的文本。
- en: '![image](assets/f0461-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0461-01.png)'
- en: Finally, we can test out our template with our data included! Restart the *guestbook.go*
    app, and visit *[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*
    in your browser again. The response should show your template. The total number
    of signatures should be at the top, and each signature should appear within its
    own `<p>` element!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用包含数据的模板进行测试！重新启动 *guestbook.go* 应用程序，并再次在浏览器中访问 *[http://localhost:8080/guestbook](http://localhost:8080/guestbook)*。响应应该显示您的模板。顶部应显示总签名数，并且每个签名应出现在其自己的
    `<p>` 元素中！
- en: '![image](assets/f0461-02.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0461-02.png)'
- en: there are no Dumb Questions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: You mentioned the `html/template` package has some “security features.”
    What are they?**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 你提到 `html/template` 包有一些“安全功能”。它们是什么？**'
- en: '**A:** The `text/template` package inserts values into a template as is, no
    matter what they contain. But that means that visitors could add HTML code as
    a “signature,” and it would be treated as part of the page’s HTML.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** `text/template` 包将值原样插入模板中，无论其包含什么内容。但这意味着访问者可以添加 HTML 代码作为“签名”，并且它将被视为页面
    HTML 的一部分。'
- en: 'You can try this yourself. In *guestbook.go*, change the `html/template` import
    to `text/template`. (You won’t need to change any other code, because the names
    of all the functions in the two packages are identical.) Then, add the following
    as a new line in your *signatures.txt* file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自行尝试。在 *guestbook.go* 中，将 `html/template` 导入更改为 `text/template`。（您不需要更改任何其他代码，因为这两个包中所有函数的名称都相同。）然后，在您的
    *signatures.txt* 文件中添加以下内容作为新行：
- en: '`<script>alert("hi!");</script>`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>alert("hi!");</script>`'
- en: This is an HTML tag containing JavaScript code. If you try running the app and
    reload the signatures page, you’ll see an annoying alert pop up, because the `text/template`
    package included this code in the page as is.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含 JavaScript 代码的 HTML 标签。如果你尝试运行该应用并重新加载签名页面，你会看到一个烦人的警报弹出，因为`text/template`包直接将这段代码包含在页面中。
- en: Now go back to *guestbook.go*, change the import back to `html/template`, and
    restart the app. If you reload the page, instead of an alert pop up, you’ll see
    text that looks just like the above script tag in the page.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 *guestbook.go*，将导入改回`html/template`，然后重新启动应用。如果重新加载页面，你将在页面中看到与上述脚本标签完全相同的文本。
- en: 'But that’s because the `html/template` package automatically “escaped” the
    HTML, replacing the characters that cause it to be treated as HTML with code that
    causes it to appear in the page’s text instead (where it’s harmless). Here’s what
    actually gets inserted into the response:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是因为 `html/template` 包自动“转义”了 HTML，用导致它被视为 HTML 的字符替换为导致它显示在页面文本中的代码（这样是安全的）。以下是实际插入响应的内容：
- en: '`&lt;script&gt;alert(&#34;hi!&#34;);&lt;/script&gt;`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`&lt;script&gt;alert(&#34;hi!&#34;);&lt;/script&gt;`'
- en: Inserting script tags like this is just one of many ways unscrupulous users
    can insert malicious code into your web pages. The `html/template` package makes
    it easy to protect against this and many other attacks!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样插入脚本标签只是不良用户可以将恶意代码插入到您的网页中的众多方式之一。`html/template` 包使得防范这种以及许多其他攻击变得简单！
- en: Letting users add data with HTML forms
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让用户使用 HTML 表单添加数据
- en: 'That’s another task complete. We’re getting close: only two tasks left to go!'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 又完成了另一个任务。我们接近尾声：只剩下两个任务！
- en: Up next, we need to allow visitors to add their own signature. We’ll need to
    create an HTML *form* where they can type a signature in. A form usually provides
    one or more fields that a user can enter data into, and a submit button that allows
    them to send the data to the server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要允许访客添加他们自己的签名。我们需要创建一个 HTML *form*，让他们可以输入签名。表单通常提供一个或多个用户可以输入数据的字段，并提供一个提交按钮，让他们可以将数据发送到服务器。
- en: '![image](assets/f0464-01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0464-01.png)'
- en: 'In your project directory, create a file called *new.html* with the HTML code
    below. There are some tags here that we haven’t seen before:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中，创建一个名为 *new.html* 的文件，并包含以下 HTML 代码。这里有一些我们以前没有见过的标签：
- en: '**`<form>`**: This element encloses all the other form components.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<form>`**: 此元素包含所有其他表单组件。'
- en: '**`<input>` with a `type` attribute of `"text"`**: A text field where the user
    can enter a string. Its `name` attribute will be used to label the field’s value
    in the data sent to the server (kind of like a map key).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<input>` 的 `type` 属性为 `"text"`**: 用户可以输入字符串的文本字段。它的 `name` 属性将用于标记发送到服务器数据中的字段值（类似于映射键）。'
- en: '**`<input>` with a `type` attribute of `"submit"`**: Creates a button that
    the user can click to submit the form’s data.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<input>` 的 `type` 属性为 `"submit"`**: 创建一个用户可以点击以提交表单数据的按钮。'
- en: '![image](assets/f0464-02.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0464-02.png)'
- en: 'If we were to load this HTML in the browser, it would look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中加载此 HTML，它将如下所示：
- en: '![image](assets/f0464-03.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0464-03.png)'
- en: Responding with the HTML form
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应 HTML 表单
- en: 'We already have an “Add Your Signature” link in *view.html* that points to
    a path of */guestbook/new*. Clicking on this link will take you to a new path
    on the same server, so it’s just like typing in this URL:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *view.html* 中已经有一个指向 */guestbook/new* 路径的“添加您的签名”链接。单击此链接将带您到同一服务器上的新路径，所以这就像在输入此
    URL 一样：
- en: '*[http://localhost:8080/guestbook/new](http://localhost:8080/guestbook/new)*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*[http://localhost:8080/guestbook/new](http://localhost:8080/guestbook/new)*'
- en: '![image](assets/f0465-01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0465-01.png)'
- en: But visiting this path right now just responds with the error “404 page not
    found.” We’ll need to set up the app to respond with the form in *new.html* when
    users click the link.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当前访问此路径只会响应错误“404 页面未找到”。我们需要设置应用程序，在用户点击链接时响应 *new.html* 中的表单。
- en: In *guestbook.go*, add a `newHandler` function. It will look much like the early
    versions of our `viewHandler` function. Just like `viewHandler`, `newHandler`
    should take an `http.ResponseWriter` and a pointer to an `http.Request` as parameters.
    It should call `template.ParseFiles` on the *new.html* file. And then it should
    call `Execute` on the resulting template, so that the contents of *new.html* get
    written to the HTTP response. We won’t be inserting any data into this template,
    so we pass `nil` as the data value for the call to `Execute`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *guestbook.go* 中，添加一个 `newHandler` 函数。它将类似于我们的 `viewHandler` 函数的早期版本。与 `viewHandler`
    一样，`newHandler` 应该接受一个 `http.ResponseWriter` 和一个 `http.Request` 的指针作为参数。它应该对 *new.html*
    文件调用 `template.ParseFiles`。然后，它应该调用 `Execute` 在生成的模板上，以便 *new.html* 的内容被写入 HTTP
    响应。我们不会向此模板插入任何数据，因此将 `nil` 作为调用 `Execute` 的数据值传递进去。
- en: Then we need to ensure that the `newHandler` function is called when the “Add
    Your Signature” link is clicked. In the `main` function, add another call to `http.HandleFunc`,
    and set up `newHandler` as the handler function for requests with a path of */guestbook/new*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要确保在点击“添加您的签名”链接时调用 `newHandler` 函数。在 `main` 函数中，添加另一个对 `http.HandleFunc`
    的调用，并将 `newHandler` 设置为路径为 */guestbook/new* 的请求的处理函数。
- en: '![image](assets/f0465-02.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0465-02.png)'
- en: If we save the above code and restart *guestbook.go*, then click the “Add Your
    Signature” link, we’ll be taken to the */guestbook/new* path. The `newHandler`
    function will be called, which will load our form HTML from *new.html* and include
    it in the response.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存上述代码并重新启动 *guestbook.go*，然后点击“添加您的签名”链接，我们将被带到 */guestbook/new* 路径。将调用
    `newHandler` 函数，该函数将从 *new.html* 加载我们的表单 HTML 并包含在响应中。
- en: '![image](assets/f0465-03.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0465-03.png)'
- en: Form submission requests
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单提交请求
- en: We’ve completed yet another task. Just one to go!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又完成了另一个任务。就剩一个了！
- en: '![image](assets/f0466-01.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0466-01.png)'
- en: When someone visits the */guestbook/new* path, either by entering it directly
    or by clicking a link, our form for entering a signature is displayed. But if
    you fill in that form and click Submit, nothing useful happens.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人访问*/guestbook/new*路径时，无论是直接输入还是点击链接，我们都会显示一个用于输入签名的表单。但如果你填写该表单并点击提交，将不会发生任何有用的事情。
- en: '![image](assets/f0466-02.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0466-02.png)'
- en: The browser will just make another request for the */guestbook/new* path. The
    content of the `"signature"` form field will be added as an ugly-looking parameter
    on the end of the URL. And because our `newHandler` function doesn’t know how
    to do anything useful with the form data, it will simply be discarded.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将会再次请求*/guestbook/new*路径。`"signature"`表单字段的内容将作为一个看起来不好看的参数添加到URL的末尾。因为我们的`newHandler`函数不知道如何处理表单数据，所以它将被简单丢弃。
- en: '![image](assets/f0466-03.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0466-03.png)'
- en: Our app can respond to requests to display the form, but there’s no way for
    the form to submit its data back to the app. We’ll need to fix this before we
    can save visitors’ signatures.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用可以响应请求以显示表单，但没有办法将表单数据提交回应用程序。在我们能保存访客签名之前，我们需要解决这个问题。
- en: Path and HTTP method for form submissions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单提交的路径和HTTP方法
- en: 'Submitting a form actually requires *two* requests to the server: one to *get*
    the form, and a second to *send* the user’s entries back to the server. Let’s
    update the form’s HTML to specify where and how this second request should be
    sent.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，提交表单需要向服务器发送*两个*请求：一个用于*获取*表单，另一个用于*发送*用户的输入数据回服务器。让我们更新表单的HTML以指定第二个请求应该发送到何处以及如何发送。
- en: 'Edit *new.html*, and add two new HTML attributes to the `form` element. The
    first attribute, `action`, will specify the path to use for the submission request.
    Instead of letting the path default back to */guestbook/new*, we’ll specify a
    new path: */guestbook/create*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑*new.html*，并向`form`元素添加两个新的HTML属性。第一个属性`action`将指定提交请求的路径。我们不会让路径默认回到*/guestbook/new*，而是指定一个新路径：*/guestbook/create*。
- en: We’ll also need a second attribute, named `method`, which should have a value
    of `"POST"`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要第二个名为`method`的属性，其值应为`"POST"`。
- en: '![image](assets/f0467-01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0467-01.png)'
- en: 'That `method` attribute requires a little explanation... HTTP defines several
    *methods* that a request can use. These aren’t the same as methods on a Go value,
    but the meaning is similar. GET and POST are among the most common methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对这个`method`属性进行一点解释... HTTP定义了几种请求可以使用的*方法*。虽然这些不同于Go值上的方法，但意义类似。GET和POST是最常见的方法之一。
- en: '**GET**: Used when your browser needs to *get* something from the server, usually
    because you entered a URL or clicked a link. This could be an HTML page, an image,
    or some other resource.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：当您的浏览器需要*从服务器获取*某些内容时使用，通常是因为您输入了一个URL或点击了一个链接。这可以是HTML页面、图像或其他资源。'
- en: '**POST**: Used when your browser needs to *add* some data to the server, usually
    because you submitted a form with new data.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：当您的浏览器需要*向服务器添加*一些数据时使用，通常是因为您提交了带有新数据的表单。'
- en: 'We’re adding new data to the server: a new guestbook signature. So it seems
    like we should submit the data using a POST request.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向服务器添加新数据：一个新的访客留言签名。所以看起来我们应该使用POST请求提交数据。
- en: Forms are submitted using GET requests by default, though. This is why we needed
    to add a `method` attribute with a value of `"POST"` to the `form` element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，默认情况下表单使用GET请求提交。这就是为什么我们需要向`form`元素添加一个值为`"POST"`的`method`属性的原因。
- en: Now, if we reload the */guestbook/new* page and resubmit the form, the request
    will use a path of */guestbook/create* instead. We’ll get a “404 page not found”
    error, but that’s because we haven’t set up a handler for the */guestbook/create*
    path yet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新加载*/guestbook/new*页面并重新提交表单，请求将使用路径*/guestbook/create*。我们会得到一个“404页面找不到”错误，但这是因为我们还没有为*/guestbook/create*路径设置处理程序。
- en: '![image](assets/f0467-02.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0467-02.png)'
- en: We’ll also see that the form data is no longer added onto the end of the URL.
    This is because the form is being submitted using a POST request.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表单数据现在不再附加在URL的末尾。这是因为表单是通过POST请求提交的。
- en: '![image](assets/f0467-03.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0467-03.png)'
- en: Getting values of form fields from the request
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从请求中获取表单字段的值
- en: Now that we’re submitting the form using a POST request, the form data is embedded
    in the request itself, rather than being appended to the request path as a parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用 POST 请求提交表单，表单数据嵌入在请求本身中，而不是作为参数附加到请求路径中。
- en: Let’s address that “404 page not found” error we get when form data is submitted
    to the */guestbook/create* path. When we do, we’ll also see how to access the
    form data from the POST request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一下当表单数据提交到*/guestbook/create*路径时出现的“404 页面未找到”错误。在此过程中，我们还将看到如何从 POST 请求中访问表单数据。
- en: As usual, we’ll do this by adding a request handler function. In the `main`
    function of *guestbook.go*, call `http.HandleFunc`, and assign requests with a
    path of `"/guestbook/create"` to a new `createHandler` function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将通过添加请求处理函数来完成这项工作。在*guestbook.go*的`main`函数中，调用`http.HandleFunc`，并将路径为`"/guestbook/create"`的请求分配给一个新的`createHandler`函数。
- en: Then add a definition for the `createHandler` function itself. It should accept
    an `http.ResponseWriter` and a pointer to an `http.Request`, just like the other
    handler functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`createHandler`函数本身的定义。它应该接受一个`http.ResponseWriter`和一个指向`http.Request`的指针，就像其他处理函数一样。
- en: Unlike the other handler functions, though, `createHandler` is meant to work
    with form data. That data can be accessed through the `http.Request` pointer that
    gets passed to the handler function. (That’s right, after ignoring `http.Request`
    values all this time, we finally get to use one!)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他处理函数不同，`createHandler`旨在处理表单数据。可以通过传递给处理程序函数的`http.Request`指针访问该数据。（是的，在忽略了这么长时间的`http.Request`值后，我们终于可以使用一个了！）
- en: For now, let’s just take a look at the data the request contains. Call the `FormValue`
    method on the `http.Request`, and pass it the string `"signature"`. This will
    return a string with the value of the `"signature"` form field. Store it in a
    variable named `signature`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先查看请求包含的数据。在`http.Request`上调用`FormValue`方法，并传递字符串`"signature"`。这将返回一个包含`"signature"`表单字段值的字符串。将其存储在名为`signature`的变量中。
- en: Let’s write the field value to the response so we can see it in the browser.
    Call the `Write` method on the `http.ResponseWriter`, and pass `signature` to
    it (but convert it to a slice of bytes first, of course). As always, `Write` will
    return a number of bytes written and an `error` value. We’ll ignore the number
    of bytes by assigning it to `_`, and call `check` on the `error`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将字段值写入响应中，以便在浏览器中查看。在`http.ResponseWriter`上调用`Write`方法，并将`signature`传递给它（但首先要将其转换为字节片）。与往常一样，`Write`将返回写入的字节数和一个`error`值。我们将通过将其赋值为`_`来忽略字节数，并对`error`调用`check`。
- en: '![image](assets/f0468-01.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0468-01.png)'
- en: Let’s see if our form submissions are getting through to the `createHandler`
    function. Restart *guestbook.go*, visit the */guestbook/new* page, and submit
    the form again.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的表单提交是否成功到达了`createHandler`函数。重新启动*guestbook.go*，访问*/guestbook/new*页面，然后再次提交表单。
- en: '![image](assets/f0469-01.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0469-01.png)'
- en: You’ll be taken to the */guestbook/create* path, and instead of a “404 page
    not found” error, the app will respond with the value you entered in the `"signature"`
    field!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被带到*/guestbook/create*路径，而不是显示“404 页面未找到”错误，应用程序将用您在`"signature"`字段中输入的值作出响应！
- en: '![image](assets/f0469-02.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0469-02.png)'
- en: If you want, you can click your browser’s back button to return to the */guestbook/new*
    page, and try different submissions. Whatever you enter will be echoed to the
    browser.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以点击浏览器的后退按钮返回*/guestbook/new*页面，并尝试不同的提交。无论输入什么内容，都将回显到浏览器中。
- en: Setting up a handler for HTML form submissions was a big step. We’re getting
    close!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为 HTML 表单提交设置处理程序是一个重要的步骤。我们正在接近！
- en: Saving the form data
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存表单数据
- en: Our `createHandler` function is receiving the request with the form data, and
    is able to retrieve the guestbook signature from it. Now all we need to do is
    add that signature to our *signatures.txt* file. We’ll handle that within the
    `createHandler` function itself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`createHandler`函数正在接收包含表单数据的请求，并能从中检索出来宾客签名。现在我们所需要做的就是在`createHandler`函数内部将该签名添加到我们的*signatures.txt*文件中。我们将在`createHandler`函数内部处理这个问题。
- en: First, we’ll get rid of the call to the `Write` method on the `ResponseWriter`;
    we only needed that to confirm we could access the signature form field.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将去掉对`ResponseWriter`的`Write`方法的调用；我们只需要确认我们可以访问签名表单字段。
- en: 'Now, let’s add the code below. The `os.OpenFile` function is called in a slightly
    unusual way, and the details aren’t directly relevant to writing a web app, so
    we won’t describe it fully here. (See [Appendix A](app01.html#understanding_osdotopenfile_opening_file)
    if you want more info.) For now, all you need to know is that this code does three
    basic things:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加下面的代码。`os.OpenFile` 函数以略有不同的方式调用，细节与编写 Web 应用程序无直接关系，因此我们不会在这里完全描述它。（如果您想了解更多信息，请参见
    [附录 A](app01.html#understanding_osdotopenfile_opening_file)。）现在，您需要知道的是，此代码执行三个基本操作：
- en: It opens the *signatures.txt* file, creating it if it doesn’t exist.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打开了 *signatures.txt* 文件，如果文件不存在则创建它。
- en: It adds a line of text to the end of the file.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在文件末尾添加一行文本。
- en: It closes the file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它关闭文件。
- en: '![image](assets/f0470-01.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0470-01.png)'
- en: The `fmt.Fprintln` function adds a line of text to a file. It takes the file
    to write to and the string to write (no need to convert to a `[]byte`) as arguments.
    Just like the `Write` methods we saw earlier in this chapter, `Fprintln` returns
    the number of bytes successfully written to the file (which we ignore), and any
    error encountered (which we pass to the `check` function).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprintln` 函数向文件添加一行文本。它接受要写入的文件和要写入的字符串（无需转换为 `[]byte`）作为参数。就像我们在本章前面看到的
    `Write` 方法一样，`Fprintln` 返回成功写入文件的字节数（我们忽略），以及遇到的任何错误（我们传递给 `check` 函数）。'
- en: Finally, we call the `Close` method on the file. You might notice that we did
    *not* use the `defer` keyword. This is because we’re writing to the file, rather
    than reading from it. Calling `Close` on a file you’re writing to can result in
    errors that we need to handle, and we can’t readily do that if we use `defer`.
    So, we simply call `Close` as part of the regular program flow and then pass its
    return value to `check`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在文件上调用 `Close` 方法。你可能注意到我们没有使用 `defer` 关键字。这是因为我们正在向文件写入，而不是从中读取。在写入文件后调用
    `Close` 可能会导致错误，我们需要处理这些错误，如果使用 `defer` 就无法很容易地做到这一点。因此，我们简单地在常规程序流程中调用 `Close`，然后将其返回值传递给
    `check`。
- en: Save the previous code and restart *guestbook.go*. Fill in and submit the form
    on the */guestbook/go* page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 保存前面的代码并重新启动 *guestbook.go*。在 */guestbook/go* 页面上填写并提交表单。
- en: '![image](assets/f0471-01.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0471-01.png)'
- en: Your browser will load the */guestbook/create* path, which shows as a totally
    blank page now (because `createHandler` is no longer writing anything to the `http.ResponseWriter`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的浏览器会加载 */guestbook/create* 路径，这个路径现在显示为完全空白（因为 `createHandler` 不再向 `http.ResponseWriter`
    写入任何内容）。
- en: '![image](assets/f0471-02.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0471-02.png)'
- en: But if you look at the contents of the *signatures.txt* file, you’ll see a new
    signature saved at the end!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你查看 *signatures.txt* 文件的内容，你会看到新的签名保存在末尾！
- en: '![image](assets/f0471-03.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0471-03.png)'
- en: And if you visit the list of signatures at */guestbook*, you’ll see the signature
    count has increased by one, and the new signature appears in the list!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 */guestbook* 上的签名列表，你会看到签名数增加了一条，并且新的签名出现在列表中！
- en: '![image](assets/f0471-04.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0471-04.png)'
- en: HTTP redirects
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 重定向
- en: We have our `createHandler` function saving new signatures. There’s just one
    more thing we need to take care of. When a user submits the form, their browser
    loads the */guestbook/create* path, which shows a blank page.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `createHandler` 函数保存新的签名。还有一件事需要处理。当用户提交表单时，他们的浏览器会加载 */guestbook/create*
    路径，显示一个空白页面。
- en: '![image](assets/f0472-01.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0472-01.png)'
- en: There’s nothing useful to show at the */guestbook/create* path anyway; it’s
    just there to accept requests to add a new signature. Instead, let’s have the
    browser load the */guestbook* path, so the user can see their new signature in
    the guestbook.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */guestbook/create* 路径上没有有用的内容可供展示；它只是用来接受添加新签名请求的。相反，让我们让浏览器加载 */guestbook*
    路径，这样用户就可以在访客留言板中看到他们的新签名。
- en: At the end of the `createHandler` function, we’ll add a call to `http.Redirect`,
    which sends a response to the browser directing it to load a different resource
    than the one it requested. `Redirect` takes an `http.ResponseWriter` and a `*http.Request`
    as its first two arguments, so we’ll just give it the values from the `writer`
    and `request` parameters to `createHandler`. Then `Redirect` needs a string with
    a path to redirect the browser to; we’ll redirect to `"/guestbook"`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `createHandler` 函数的结尾，我们将添加一个调用 `http.Redirect`，它向浏览器发送一个响应，指示其加载与请求的资源不同的资源。`Redirect`
    的前两个参数是 `http.ResponseWriter` 和 `*http.Request`，因此我们将从 `createHandler` 的 `writer`
    和 `request` 参数中获取它们的值。然后 `Redirect` 需要一个字符串，指定将浏览器重定向到的路径；我们将重定向到 `"/guestbook"`。
- en: 'The last argument to `Redirect` needs to be a status code to give the browser.
    Every HTTP response needs to include a status code. Our responses so far have
    had their codes set automatically for us: successful responses had a code of 200
    (“OK”), and requests for nonexistent pages had a code of 404 (“Not found”). We
    need to specify a code for `Redirect`, though, so we’ll use the constant `http.StatusFound`,
    which will cause the redirect response to have a status of 302 (“Found”).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redirect`的最后一个参数需要是一个状态码，以便向浏览器发送。每个HTTP响应都需要包含一个状态码。到目前为止，我们的响应已经自动设置了它们的代码：成功的响应代码为200（“OK”），对不存在页面的请求代码为404（“Not
    found”）。不过，对于`Redirect`，我们需要指定一个代码，因此我们将使用常量`http.StatusFound`，这将导致重定向响应的状态为302（“Found”）。'
- en: '![image](assets/f0472-02.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0472-02.png)'
- en: 'Now that we’ve added the call to `Redirect`, submitting the signature form
    should work something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`Redirect`的调用，提交签名表单应该像这样工作：
- en: The browser submits an HTTP POST request to the */guestbook/create* path.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器向*/guestbook/create*路径提交了一个HTTP POST请求。
- en: The app responds with a redirect to */guestbook*.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序响应并重定向到*/guestbook*。
- en: The browser sends a GET request for the */guestbook* path.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器发送了一个GET请求，用于*/guestbook*路径。
- en: Let’s try it all out!
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们试试所有功能！
- en: Let’s see if the redirect works! Restart *guestbook.go*, and visit the */guestbook/new*
    path. Fill in the form and submit it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看重定向是否有效！重新启动*guestbook.go*，并访问*/guestbook/new*路径。填写表单并提交。
- en: '![image](assets/f0473-01.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0473-01.png)'
- en: The app will save the form contents to *signatures.txt*, then immediately redirect
    the browser to the */guestbook* path. When the browser requests */guestbook*,
    the app will load the updated *signatures.txt* file, and the user will see their
    new signature in the list!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将表单内容保存到*signatures.txt*，然后立即将浏览器重定向到*/guestbook*路径。当浏览器请求*/guestbook*时，应用程序将加载更新的*signatures.txt*文件，并且用户将在列表中看到他们的新签名！
- en: '![image](assets/f0473-02.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0473-02.png)'
- en: Our app is saving signatures submitted from the form and displaying them along
    with all the others. All our features are complete.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序正在保存从表单提交的签名，并与所有其他签名一起显示。我们的所有功能都已完成。
- en: It took quite a few components to make it all work, but you now have a usable
    web app!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 需要很多组件才能使所有这些工作正常运行，但现在您拥有了一个可用的Web应用程序！
- en: '![image](assets/f0473-03.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0473-03.png)'
- en: Our complete app code
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的完整应用程序代码
- en: The code for our app has gotten so long, we’ve only been able to look at it
    in bits and pieces. Let’s take one more moment to look at all the code in one
    place!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序代码已经变得如此之长，我们只能逐步查看它。让我们再花一点时间将所有代码放在一起看看吧！
- en: The *guestbook.go* file makes up the bulk of the code for the app. (In an app
    intended for wide use, we might have split some of this code into multiple packages
    and source files within our Go workspace directory, and you can do that yourself
    if you want.) We’ve gone through and added comments documenting the `Guestbook`
    type and each of the functions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*guestbook.go*文件占据了应用程序代码的大部分。（在一个旨在广泛使用的应用程序中，我们可能已将一些此代码拆分为多个包和源文件，位于我们的Go工作区目录中，如果您愿意，您也可以这样做。）我们已经浏览并添加了对`Guestbook`类型和每个函数的注释。'
- en: '![image](assets/f0474-01.png)![image](assets/f0475-01.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0474-01.png)![image](assets/f0475-01.png)'
- en: The *view.html* file provides the HTML template for the list of signatures.
    Template actions provide places to insert the number of signatures, as well as
    the entire signature list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*view.html*文件为签名列表提供HTML模板。模板操作提供了插入签名数量以及整个签名列表的位置。'
- en: '![image](assets/f0476-01.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0476-01.png)'
- en: The *new.html* file simply holds the HTML form for new signatures. No data will
    be inserted into it, so no template actions are present.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*new.html*文件只是包含用于新签名的HTML表单。不会向其中插入任何数据，因此不存在模板操作。'
- en: '![image](assets/f0476-02.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0476-02.png)'
- en: And that’s it—a complete web app that can store user-submitted signatures and
    retrieve them again later!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——一个完整的Web应用程序，可以存储用户提交的签名，并稍后再次检索它们！
- en: Writing web apps can be complex, but the `net/http` and `html/template` packages
    leverage the power of Go to make the whole process simpler for you!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Web应用程序可能很复杂，但`net/http`和`html/template`包利用Go的力量使整个过程对您来说更加简单！
- en: '![image](assets/f0476-03.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0476-03.png)'
- en: Your Go Toolbox
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Go工具箱
- en: '![image](assets/f0477-01.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0477-01.png)'
- en: '**That’s it for [Chapter 16](ch16_split_000.html#a_pattern_to_follow_html_templates)!
    You’ve added templates to your toolbox.**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是[第16章](ch16_split_000.html#a_pattern_to_follow_html_templates)的全部内容！您已经将模板添加到了您的工具箱中。**'
- en: '![image](assets/f0477-02.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0477-02.png)'
