- en: Chapter 2\. Efficient Introduction to Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章\. 高效入门 Go 语言
- en: Go is efficient, scalable, and productive. Some programmers find it fun to work
    in; others find it unimaginative, even boring. ... Those are not contradictory
    positions. Go was designed to address the problems faced in software development
    at Google, which led to a language that is not a breakthrough research language
    but is nonetheless an excellent tool for engineering large software projects.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go 是高效、可扩展且高生产力的。一些程序员觉得在其中工作很有趣；另一些人则认为它缺乏想象力，甚至乏味。……这些观点并不矛盾。Go 的设计是为了解决谷歌在软件开发中遇到的问题，这导致了一种不是突破性研究语言，但却是大型软件项目工程的优秀工具。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/3EItq)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 罗布·派克，《谷歌的 Go：服务于软件工程的语言设计》(来源：[https://oreil.ly/3EItq](https://oreil.ly/3EItq))
- en: I am a huge fan of the Go programming language. The number of things developers
    around the world have been able to achieve with Go is impressive. For a few years
    in a row, Go has been on the list of [top five languages people love or want to
    learn](https://oreil.ly/la9bx). It is used in many businesses, including bigger
    tech companies like Apple, American Express, Cloudflare, Dell, Google, Netflix,
    Red Hat, Twitch, and [others](https://oreil.ly/DSM73). Of course, as with everything,
    nothing is perfect. I would probably change, remove, or add a few things to Go,
    but if you would wake me in the middle of the night and ask me to quickly write
    reliable backend code, I would write it in Go. CLI? In Go. Quick, reliable script?
    In Go as well. The first language to learn as a junior programmer? Go. Code for
    IoT, robots, and microprocessors? The answer is also Go.^([1](ch02.html#idm45606843247856))
    Infrastructure configuration? As of 2022, I don’t think there is a better tool
    for robust templating than Go.^([2](ch02.html#idm45606843245632))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我是 Go 编程语言的铁杆粉丝。全球开发者用 Go 取得的成就令人印象深刻。连续几年，Go 都在[人们喜欢或想学习的前五种语言列表](https://oreil.ly/la9bx)上。它在许多企业中都有使用，包括像苹果、美国运通、Cloudflare、戴尔、谷歌、Netflix、红帽、Twitch
    和[其他公司](https://oreil.ly/DSM73)。当然，像所有事物一样，没有完美的东西。如果你在半夜叫醒我，让我快速编写可靠的后端代码，我会选择用
    Go。命令行界面？也用 Go。快速、可靠的脚本？同样也是用 Go。作为初级程序员学习的第一门语言？Go。用于物联网、机器人和微处理器的代码？答案同样是 Go。^([1](ch02.html#idm45606843247856))
    基础设施配置？截至 2022 年，我认为没有比 Go 更好的工具用于强大的模板化了。^([2](ch02.html#idm45606843245632))
- en: Don’t get me wrong, there are languages with specialized capabilities or ecosystems
    that are superior to Go. For example, think about graphical user interfaces (GUIs),
    advanced rendering parts of the game industry, or code running in browsers.^([3](ch02.html#idm45606843243616))
    However, once you realize the many advantages of the Go language, it is pretty
    painful to jump back to others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误会，有些语言具有专门的能力或生态系统，这些方面可能比 Go 更优秀。例如，想想图形用户界面（GUI）、游戏行业的高级渲染部分或在浏览器中运行的代码。^([3](ch02.html#idm45606843243616))
    然而，一旦你意识到 Go 语言的诸多优点，再回到其他语言就会感觉相当痛苦。
- en: In [Chapter 1](ch01.html#ch-efficiency-matters), we spent some time establishing
    an efficiency awareness for our software. As a result, we learned that our goal
    is to write efficient code with the least development effort and cost. This chapter
    will explain why the Go programming language can be a solid option to achieve
    this balance between performance and other software qualities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch-efficiency-matters)中，我们花了一些时间来建立我们软件的效率意识。结果，我们学到了我们的目标是用最少的开发工作和成本编写高效的代码。本章将解释为什么
    Go 编程语言可以成为实现性能和其他软件质量平衡的可靠选择。
- en: We will start with [“Basics You Should Know About Go”](#ch-go-intro), then continue
    with [“Advanced Language Elements”](#ch-go-adv). Both sections list the short
    but essential facts everyone should know about Go, something I wish I had known
    when I started my journey with Go in 2014\. These sections will cover much more
    than just basic information about efficiency and can be used as an introduction
    to Go. However, if you are entirely new to the language, I would still recommend
    reading those sections, then checking other resources mentioned in the summary,
    perhaps writing your first program in Go, and then getting back to this book.
    On the other hand, if you consider yourself a more advanced user or expert, I
    suggest not skipping this chapter. I explain a few lesser-known facts about Go
    that you might find interesting or controversial (it’s OK, everyone can have their
    own opinions!).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 [“Go 基础知识”](#ch-go-intro) 开始，然后继续学习 [“高级语言元素”](#ch-go-adv)。这两个部分列出了关于 Go
    的简短但关键的信息，这是我在 2014 年开始学习 Go 时希望自己早些知道的内容。这些部分将涵盖远不止基本的效率信息，并可以作为学习 Go 的入门。然而，如果你完全是这门语言的新手，我仍然建议先阅读这些部分，然后再查看摘要中提到的其他资源，也许在
    Go 中写下你的第一个程序，然后再回到这本书。另一方面，如果你认为自己是一个更高级的用户或专家，我建议不要跳过这一章节。我会解释关于 Go 的一些较少人知的事实，可能会引起你的兴趣或争议（没关系，每个人都可以有自己的观点！）。
- en: Last but not least, we will finish by answering the tricky question about the
    overall Go efficiency capabilities in [“Is Go “Fast”?”](#ch-go-fast), as compared
    to other languages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将回答一个关于总体 Go 效率能力的棘手问题，在 [“Go 是否‘快速’？”](#ch-go-fast) 中，与其他语言相比。
- en: Basics You Should Know About Go
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 基础知识
- en: Go is an open source project maintained by Google within a distributed team
    called the “Go team.” The project consists of the programming language specification,
    compilator, tooling, documentation, and standard libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是由谷歌维护的开源项目，在一个名为“Go team”的分布式团队内进行。该项目包括编程语言规范、编译器、工具、文档和标准库。
- en: Let’s go through some facts and best practices to understand Go basics and its
    characteristics in fast-forward mode. While some advice here might feel opinionated,
    this is based on my experience working with Go since 2014—a background full of
    incidents, past mistakes, and lessons learned the hard way. I’m sharing them here
    so you don’t need to make those errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一些关于 Go 基础知识和特性的事实和最佳实践。尽管这里的一些建议可能带有个人意见，但这是基于我自 2014 年以来与 Go 工作的经验——一个充满事件、过去错误和艰难汲取的背景。我在这里分享它们，希望你不需要再犯这些错误。
- en: Imperative, Compiled, and Statically Typed Language
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式、编译型和静态类型语言
- en: The central part of the Go project is the general-purpose language with the
    same name, primarily designed for systems programming. As you will notice in [Example 2-1](#code-basic),
    Go is an imperative language, so we have (some) control over how things are executed.
    In addition, it’s statically typed and compiled, which means that the compiler
    can perform many optimizations and checks before the program runs. These characteristics
    alone are an excellent start to make Go suitable for reliable and efficient programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go 项目的核心部分是同名的通用编程语言，主要设计用于系统编程。正如你在 [Example 2-1](#code-basic) 中会注意到的，Go 是一种命令式语言，因此我们对执行过程有（某些）控制权。此外，它是静态类型和编译型的，这意味着编译器可以在程序运行之前执行许多优化和检查。这些特性本身已经足够使
    Go 适合于可靠和高效的程序。
- en: Example 2-1\. Simple program printing “Hello World” and exiting
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-1\. 打印“Hello World”并退出的简单程序
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both project and language are called “Go,” yet sometimes you can refer to them
    as “Golang.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目和语言都称为“Go”，但有时候你也可以称它们为“Golang”。
- en: Go Versus Golang
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 与 Golang
- en: As a rule of thumb, we should always use the “Go” name everywhere, unless it’s
    clashing with the English word *go* or an ancient game called “Go.” “Golang” came
    from the domain choice ([*https://golang.org*](https://golang.org)) since “go”
    was unavailable to its authors. So use “Golang” when searching for resources about
    this programming language on the web.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我们应该在任何地方都使用“Go”这个名称，除非它与英语单词 *go* 或一种古老的游戏“围棋”冲突。 “Golang” 来自于域名选择（[*https://golang.org*](https://golang.org)），因为作者无法获取“go”这个域名。因此，在网络上搜索与这种编程语言相关的资源时，请使用“Golang”。
- en: Go also has its mascot, called the [“Go gopher”](https://oreil.ly/SbxVX). We
    see this cute gopher in various forms, situations, and combinations, such as conference
    talks, blog posts, or project logos. Sometimes Go developers are called “gophers”
    too!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go还有自己的吉祥物，称为[“Go地鼠”](https://oreil.ly/SbxVX)。我们可以在各种形式、情况和组合中看到这只可爱的地鼠，例如会议演讲、博客文章或项目标志。有时Go开发人员也被称为“地鼠”！
- en: Designed to Improve Serious Codebases
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计用于改进严肃的代码库
- en: 'It all started when three experienced programmers from Google sketched the
    idea of the Go language around 2007:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一切始于三位Google经验丰富的程序员在2007年勾勒出Go语言的想法：
- en: Rob Pike
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Rob Pike
- en: Cocreator of UTF-8 and the Plan 9 operating system. Coauthor of many programming
    languages before Go, such as Limbo for writing distributed systems and Newsqueak
    for writing concurrent applications in graphical user interfaces. Both were inspired
    by Hoare’s Communicating Sequential Processes (CSP).^([4](ch02.html#idm45606843188400))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8和Plan 9操作系统的共同创作者。在Go之前，他与Limbo一起编写用于编写分布式系统和Newsqueak用于编写图形用户界面中并发应用程序。这两者都受到了Hoare的通信顺序处理（CSP）的启发。^([4](ch02.html#idm45606843188400))
- en: Robert Griesemer
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Robert Griesemer
- en: Among other work, Griesemer developed the [Sawzall language](https://oreil.ly/gYKMj)
    and did a doctorate with Niklaus Wirth. The same Niklaus wrote “A Plea for Lean
    Software” quoted in [“Software gets slower more rapidly than hardware becomes
    faster”](ch01.html#ch-eff-s-hardware-slower).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他工作，Griesemer开发了[Sawzall语言](https://oreil.ly/gYKMj)，并在Niklaus Wirth指导下完成了博士学位。同一位Niklaus撰写的“关于精简软件的呼吁”被引用在[“软件变慢比硬件变快更迅速”](ch01.html#ch-eff-s-hardware-slower)一书中。
- en: Ken Thompson
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ken Thompson
- en: One of the original authors of the first Unix system. Sole creator of the `grep`
    command-line utility. Ken cocreated UTF-8 and Plan 9 with Rob Pike. He wrote a
    couple of languages, too, e.g., the Bon and B programming languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Unix系统的原始作者之一。 `grep` 命令行实用程序的唯一创建者。Ken与Rob Pike共同创造了UTF-8和Plan 9。他还撰写了几种语言，例如Bon和B编程语言。
- en: These three aimed to create a new programming language that was meant to improve
    mainstream programming, led by C++, Java, and Python at that point. After a year,
    it became a full-time project, with Ian Taylor and Russ Cox joining in 2008 what
    was [later referenced as the Go team](https://oreil.ly/Nnj6N). The Go team announced
    the public Go project in 2009, with version 1.0 released in March 2012.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这三位旨在创建一种新的编程语言，旨在改进当时由C++、Java和Python主导的主流编程。一年后，它成为一个全职项目，Ian Taylor和Russ
    Cox于2008年加入，这些人后来被称为[Go团队](https://oreil.ly/Nnj6N)。 Go团队在2009年宣布了公开的Go项目，并于2012年3月发布了1.0版本。
- en: 'The main frustrations^([5](ch02.html#idm45606843146464)) related to C++ mentioned
    in the design of Go were:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++相关的主要挫折^([5](ch02.html#idm45606843146464))在Go设计中提到：
- en: Complexity, many ways of doing the same thing, too many features
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性，多种做同样事情的方式，太多的功能
- en: Ultralong compilation times, especially for bigger codebases
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是对于更大的代码库，编译时间特别长
- en: Cost of updates and refactors in large projects
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型项目中更新和重构的成本
- en: Not easy to use and memory model prone to errors
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不易使用且内存模型容易出错
- en: These elements are why Go was born, from the frustration of existing solutions
    and the ambition to allow more by doing less. The guiding principles were to make
    a language that does not trade safety for less repetition, yet allows simpler
    code. It does not sacrifice execution efficiency for faster compilation or interpreting,
    yet ensures that build times are quick enough. [Go tries to compile as fast as
    possible, e.g., thanks to explicit imports](https://oreil.ly/qxuUS). Especially
    with caching enabled by default, only changed code is compiled, so build times
    are rarely longer than a minute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素是Go诞生的原因，源于对现有解决方案的挫折和允许更少实现更多的雄心。其指导原则是制造一种不以牺牲安全性换取少重复的语言，但允许更简单的代码。它不为了更快的编译或解释而牺牲执行效率，但确保构建时间足够快。[Go试图尽可能快地编译，例如通过显式导入](https://oreil.ly/qxuUS)。特别是默认启用缓存，只有更改的代码才会被编译，因此构建时间很少超过一分钟。
- en: You Can Treat Go Code as Script!
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以把Go代码当作脚本来使用！
- en: While technically Go is a compiled language, you can run it like you would run
    JavaScript, Shell, or Python. It’s as simple as invoking `go run <executable package>
    <flags>`. It works great because the compilation is ultrafast. You can treat it
    like a scripting language while maintaining the advantages of compilation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go在技术上是一种编译语言，但你可以像运行JavaScript、Shell或Python一样运行它。只需调用`go run <executable
    package> <flags>`即可。这很方便，因为编译速度非常快。你可以像使用脚本语言一样使用它，同时保持编译的优势。
- en: In terms of syntax, Go was meant to be simple, light on keywords, and familiar.
    Syntax is based on C with type derivation (automatic type detection, like `auto`
    in C++), and no forward declarations, no header files. Concepts are kept orthogonal,
    which allows easier combination and reasoning about them. Orthogonality for elements
    means that, for example, we can add methods to any type or data definition (adding
    methods is separate from creating types). Interfaces are orthogonal to types too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法方面，Go 的设计初衷是简单、关键字少且熟悉。语法基于 C，支持类型推导（自动类型检测，类似于 C++ 的 `auto`），没有前置声明，没有头文件。概念保持正交性，这使得它们更容易组合和推理。元素的正交性意味着，例如，我们可以为任何类型或数据定义添加方法（方法添加与类型创建分开）。接口对类型也是正交的。
- en: Governed by Google, Yet Open Source
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由 Google 管理，同时又是开源的。
- en: Since announcing Go, all development has been done in [open source](https://oreil.ly/ZeKm6),
    with public mailing lists and bug trackers. Changes go to the public, authoritative
    source code, held under the [BSD style license](https://oreil.ly/XBDEK). The Go
    team reviews all contributions. The process is the same if the change or idea
    is coming from Google or not. The project road maps and proposals are developed
    in public too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自从宣布 Go 以来，所有开发都在[开源](https://oreil.ly/ZeKm6)进行，使用公共邮件列表和 Bug 跟踪器。更改提交到公共权威源代码，采用[BSD
    风格许可证](https://oreil.ly/XBDEK)。Go 团队审核所有贡献。无论变更或想法来自 Google 还是其他方，流程都是一样的。项目路线图和提案也是公开开发的。
- en: Unfortunately, the sad truth is that there are many open source projects, but
    some projects are less open than others. Google is still the only company stewarding
    Go and has the last decisive control over it. Even if anyone can modify, use,
    and contribute, projects coordinated by a single vendor risk selfish and damaging
    decisions like relicensing or blocking certain features. While there were some
    controversial cases where the Go team decision surprised the community,^([6](ch02.html#idm45606843127920))
    overall the project is very reasonably well governed. Countless changes came from
    outside of Google, and the Go 2.0 draft proposal process has been well respected
    and community driven. In the end, I believe consistent decision-making and stewarding
    from the Go team bring many benefits too. Conflicts and different views are inevitable,
    and having one consistent overview, even if not perfect, might be better than
    no decision or many ways of doing the same thing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，悲伤的事实是有许多开源项目，但有些项目比其他项目更不开放。Google 仍然是 Go 的唯一公司监护人，并对其拥有最终决策权。即使任何人都可以修改、使用和贡献，由单一供应商协调的项目存在着风险，如重新许可或阻止某些功能。虽然有些颇具争议的情况使得
    Go 团队的决定让社区感到惊讶，^([6](ch02.html#idm45606843127920)) 总体而言，该项目管理得非常合理。无数变更来自 Google
    外部，并且 Go 2.0 草案提案过程得到了良好的尊重和社区驱动。最终，我认为来自 Go 团队的一致决策和监护也带来了许多好处。冲突和不同看法是不可避免的，即使不完美，有一个一致的视角可能比没有决策或多种做法更好。
- en: So far, this project setup has proven to work well for adoption and language
    stability. For our software efficiency goals, such alignment couldn’t be better
    too. We have a big company invested in ensuring each release doesn’t bring any
    performance regressions. Some internal Google software depends on Go, e.g., [Google
    Cloud Platform](https://oreil.ly/vjyOc). And many people rely on the Google Cloud
    Platform to be reliable. On the other hand, we have a vast Go community that gives
    feedback, finds bugs, and contributes ideas and optimizations. And if that’s not
    enough, we have open source code, allowing us, mere mortal developers, to dive
    into the actual Go libraries, runtime (see [“Go Runtime”](#ch-go-runtime)), etc.,
    to understand the performance characteristics of the particular code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这种项目设置已被证明对采用和语言稳定性非常有效。对于我们的软件效率目标，这种对齐也是再好不过了。我们有一个大公司投入其中，确保每个发布版本都不会带来性能退化。一些内部
    Google 软件依赖于 Go，例如，[Google Cloud Platform](https://oreil.ly/vjyOc)。而许多人依赖于 Google
    Cloud Platform 的可靠性。另一方面，我们有庞大的 Go 社区提供反馈，发现错误并贡献想法和优化。而且如果这还不够，我们有开源代码，让我们这些凡人开发者能够深入了解实际的
    Go 库、运行时（参见[“Go Runtime”](#ch-go-runtime)）等，以理解特定代码的性能特征。
- en: Simplicity, Safety, and Readability Are Paramount
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单性、安全性和可读性至关重要。
- en: Robert Griesemer [mentioned in GopherCon 2015](https://oreil.ly/s3ZZ5) that
    first of all, they knew when they first started building Go what things NOT to
    do. The main guiding principle was simplicity, safety, and readability. In other
    words, Go follows the pattern of “less is more.” This is a potent idiom that spans
    many areas. In Go, there is only one *idiomatic* coding style,^([7](ch02.html#idm45606843118368))
    and a tool called `gofmt` ensures most of it. In particular, code formatting (next
    to naming) is an element that is rarely settled among programmers. We spend time
    arguing about it and tuning it to our specific needs and beliefs. Thanks to a
    single style enforced by tooling, we save enormous time. As one of the [Go proverbs](https://oreil.ly/ua2G8)
    goes, “Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite.”
    Overall, the Go authors planned the language to be minimal so that there is essentially
    one way to write a particular construct. This takes away a lot of decision-making
    when you are writing a program. There is one way of handling errors, one way of
    writing objects, one way of running things concurrently, etc.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·格里塞默在[GopherCon 2015提到过](https://oreil.ly/s3ZZ5)，在他们最初开始构建Go语言时，首先知道了哪些事情不应该做。主要的指导原则是简单性、安全性和可读性。换句话说，Go语言遵循“少即是多”的模式。这是一个贯穿多个领域的强有力的习语。在Go语言中，只有一种*习惯用法*的编码风格^([7](ch02.html#idm45606843118368))，并且有一个名为`gofmt`的工具可以确保大部分都符合这种风格。特别是代码格式化（紧随命名之后）很少有程序员能达成一致。我们花时间争论它，并根据特定的需求和信念调整它。多亏了工具强制执行单一风格，我们节省了大量时间。正如一个[Go谚语](https://oreil.ly/ua2G8)所说，“gofmt的风格不是任何人的最爱，但gofmt是每个人的最爱。”总体来说，Go语言的作者们设计这门语言尽可能简洁，以便在编写程序时几乎只有一种写法。这在你编写程序时大大减少了决策的负担。处理错误的方式、编写对象的方式、以及并发运行事物的方式，都是唯一的。
- en: A huge number of features might be “missing” from Go, yet [one could say it
    is more expressive than C or C++](https://oreil.ly/CPkvV). Such minimalism allows
    for maintaining the simplicity and readability of the Go code, which improves
    software reliability, safety, and overall higher velocity toward application goals.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言可能会“缺失”大量特性，然而[可以说它比C或C++更具表现力](https://oreil.ly/CPkvV)。这种简约主义允许保持Go代码的简洁性和可读性，从而提高软件的可靠性、安全性和整体更高的应用速度。
- en: Is My Code Idiomatic?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**我的代码是否符合习惯用法？**'
- en: The word *idiomatic* is heavily overused in the Go community. Usually, it means
    Go patterns that are “often” used. Since Go adoption has grown a lot, people have
    improved the initial “idiomatic” style in many creative ways. Nowadays, it’s not
    always clear what’s idiomatic and what’s not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go社区中，“习惯用法”一词被大量使用。通常指的是经常使用的Go模式。由于Go的普及程度大大增加，人们用许多创造性的方式改进了最初的“习惯用法”风格。如今，什么是习惯用法，什么不是，并不总是清晰的。
- en: It’s like the “This is the way” saying from the *Mandalorian* series. It makes
    us feel more confident when we say, “This code is idiomatic.” So the conclusion
    is to use this word with care and [avoid it unless you can elaborate the reasoning
    why some pattern is better](https://oreil.ly/dAAKz).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像《曼达洛人》系列中的“这是正确的方式”一样。当我们说“这段代码符合习惯用法”时，这让我们感到更加自信。因此，总结起来，使用这个词要谨慎，并且[除非你能详细阐述为什么某种模式更好，否则最好避免使用它](https://oreil.ly/dAAKz)。
- en: Interestingly, the “less is more” idiom can help our efficiency efforts for
    this book’s purpose. As we learned in [Chapter 1](ch01.html#ch-efficiency-matters),
    if you do less work at runtime, it usually means faster, lean execution and less
    complex code. In this book, we will try to maintain this aspect while improving
    our code performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，“少即是多”的习语可以帮助我们为本书的目的努力提高效率。正如我们在[第一章](ch01.html#ch-efficiency-matters)中所学到的，如果在运行时做得越少，通常意味着更快、更精简的执行和更少复杂的代码。在本书中，我们将尝试保持这一方面，同时提高我们的代码性能。
- en: Packaging and Modules
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**打包与模块**'
- en: The Go source code is organized into directories representing either packages
    or modules. A package is a collection of source files (with the *.go* suffix)
    in the same directory. The package name is specified with the `package` statement
    at the top of each source file, as seen in [Example 2-1](#code-basic). All files
    in the same directory must the same package name^([8](ch02.html#idm45606843101632))
    (the package name can be different from the directory name). Multiple packages
    can be part of a single Go module. A module is a directory with a *go.mod* file
    that states all dependent modules with their versions required to build the Go
    application. This file is then used by the dependency management tool [Go Modules](https://oreil.ly/z5GqG).
    Each source file in a module can import packages from the same or external modules.
    Some packages can also be “executable.” For example, if a package is called `main`
    and has `func main()` in some file, we can execute it. Sometimes such a package
    is placed in the cmd directory for easier discovery. Note that you cannot import
    the executable package. You can only build or run it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go源代码按照表示包或模块的目录进行组织。包是位于同一目录中的源文件集合（具有*.go*后缀）。包名在每个源文件顶部的`package`语句中指定，如[示例 2-1](#code-basic)所示。同一目录中的所有文件必须具有相同的包名^([8](ch02.html#idm45606843101632))（包名可以与目录名不同）。多个包可以成为单个Go模块的一部分。模块是一个具有*go.mod*文件的目录，该文件列出了构建Go应用程序所需的所有依赖模块及其版本。然后，依赖管理工具[Go
    Modules](https://oreil.ly/z5GqG)使用此文件。模块中的每个源文件都可以导入来自同一或外部模块的包。某些包也可以是“可执行的”。例如，如果一个包名为`main`并且在某个文件中具有`func
    main()`，则可以执行它。有时这样的包会放在cmd目录下以便更容易地发现。请注意，你不能导入可执行包。你只能构建或运行它。
- en: Within the package, you can decide what functions, types, interfaces, and methods
    are exported to package users and which are accessible only in the package scope.
    This is important because exporting the minimal amount of API possible for readability,
    reusability, and reliability is better. Go does not have any `private` or `public`
    keywords for this. Instead, it takes a slightly new approach. As [Example 2-2](#code-export)
    shows, if the construct name starts with an uppercase letter, any code outside
    the package can use it. If the element name begins with a lowercase letter, it’s
    private. It’s worth noting that this pattern works for all constructs equally,
    e.g., functions, types, interfaces, variables, etc. (orthogonality).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在包内部，你可以决定哪些函数、类型、接口和方法对包用户可见，哪些仅在包范围内可访问。这很重要，因为为了可读性、可重用性和可靠性，最好只导出最少量的API。Go语言没有任何`private`或`public`关键字来实现这一点。而是采取了稍微新的方法。如[示例 2-2](#code-export)所示，如果构造名称以大写字母开头，任何包外的代码都可以使用它。如果元素名称以小写字母开头，则它是私有的。值得注意的是，这种模式对所有构造都同样适用，例如函数、类型、接口、变量等（正交性）。
- en: Example 2-2\. Construct accessibility control using naming case
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 使用命名案例构建可访问性控制
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO1-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO1-1)'
- en: Careful readers might notice tricky cases of exported fields or methods on private
    type or `interface`. Can someone outside the package use them if the `struct`
    or `interface` is private? This is quite rarely used, but the answer is yes, you
    can return a private `interface` or type in a public function, e.g., `func New()
    privateStruct { return privateStruct{}}`. Despite the `privateStruct` being private,
    all its public fields and methods are accessible to package users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能会注意到私有类型或接口上导出字段或方法的棘手情况。如果结构体或接口是私有的，包外的人能否使用它们呢？这很少见，但答案是肯定的，你可以在公共函数中返回一个私有的接口或类型，例如，`func
    New() privateStruct { return privateStruct{}}`。尽管`privateStruct`是私有的，但其所有公共字段和方法对包用户都是可访问的。
- en: Internal Packages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部包
- en: You can name and structure your code directories as you want to form packages,
    but one directory name is reserved for special meaning. If you want to ensure
    that only the given package can import other packages, you can create a package
    subdirectory named internal. Any package under the internal directory can’t be
    imported by any package other than the ancestor (and other packages in internal).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意命名和结构化代码目录以形成包，但有一个目录名具有特殊含义。如果你想确保只有给定的包可以导入其他包，可以创建一个名为`internal`的包子目录。任何在`internal`目录下的包都不能被祖先之外的任何包导入（及`internal`下的其他包）。
- en: Dependencies Transparency by Default
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认透明依赖关系
- en: 'In my experience, it is common to import precompiled libraries, such as in
    C++, C#, or Java, and use exported functions and classes defined in some header
    files. However, importing compiled code has some benefits:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，通常导入预编译库，例如在 C++、C# 或 Java 中，并使用一些头文件中定义的导出函数和类。但导入编译代码也有一些好处：
- en: It relieves engineers from making an effort to compile particular code, i.e.,
    find and download correct versions of dependencies, special compilation tooling,
    or extra resources.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减轻了工程师编译特定代码的工作量，即查找和下载正确版本的依赖项、特殊编译工具或额外资源。
- en: It might be easier to sell such a prebuilt library without exposing the source
    code and worrying about the client copying the business value-providing code.^([9](ch02.html#idm45606842831664))
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能更容易销售这样一个预编译库，而无需暴露源代码并担心客户复制业务价值提供的代码。^([9](ch02.html#idm45606842831664))
- en: In principle, this is meant to work well. Developers of the library maintain
    specific programmatic contracts (APIs), and users of such libraries do not need
    to worry about implementation complexities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，这应该是有效的。库的开发者维护特定的程序化契约（API），这些库的用户无需担心实现复杂性。
- en: Unfortunately, in practice, this is rarely that perfect. Implementation can
    be broken or inefficient, the interfaces can mislead, and documentation can be
    missing. In such cases, access to the source code is invaluable, allowing us to
    more deeply understand implementation. We can find issues based on specific source
    code, not by guessing. We can even propose a fix to the library or fork the package
    and use it immediately. We can extract the required pieces and use them to build
    something else.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在实践中，这很少是完美的。实现可能有问题或效率低下，接口可能误导，并且可能缺少文档。在这种情况下，访问源代码是非常宝贵的，允许我们更深入地理解实现。我们可以根据具体的源代码找到问题，而不是靠猜测。我们甚至可以提出对库的修复建议或分叉该包并立即使用它。我们可以提取所需的部分并用它们构建其他东西。
- en: 'Go assumes this imperfection by requiring each library’s parts (in Go: module’s
    packages) to be explicitly imported using a package URI called “import path.”
    Such import is also strictly controlled, i.e., unused imports or cyclic dependencies
    cause a compilation error. Let’s see different ways to declare these imports in
    [Example 2-3](#code-imports).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go 假设这种不完美，要求每个库的部分（在 Go 中称为模块的包）都必须使用称为“导入路径”的包 URI 明确导入。这种导入也是严格控制的，即未使用的导入或循环依赖会导致编译错误。让我们看看在
    [示例 2-3](#code-imports) 中声明这些导入的不同方式。
- en: Example 2-3\. Portion of `import` statements from `github.com/prometheus/​prome⁠theus`
    module, main.go file
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. 来自 `github.com/prometheus/​prome⁠theus` 模块的 `import` 语句部分，main.go 文件
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO2-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO2-1)'
- en: If the import declaration does not have a domain with a path structure, it means
    the package from the “standard”^([10](ch02.html#idm45606842772304)) library is
    imported. This particular import allows us to use code from the `$(go env GOROOT)/src/context/`
    directory with `context` reference, e.g., `context.Background()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入声明没有域和路径结构，这意味着从“标准”库导入包。这种特定的导入允许我们使用来自 `$(go env GOROOT)/src/context/`
    目录的代码，并使用 `context` 引用，例如 `context.Background()`。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO2-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO2-2)'
- en: The package can be imported explicitly without any identifier. We don’t want
    to reference any construct from this package, but we want to have some global
    variables initialized. In this case, the `pprof` package will add debugging endpoints
    to the global HTTP server router. While allowed, in practice we should avoid reusing
    global, modifiable variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式导入包而不带任何标识符。我们不希望引用该包的任何构造，但我们希望初始化一些全局变量。在这种情况下，`pprof` 包将在全局 HTTP 服务器路由器中添加调试端点。虽然允许，但实际上我们应避免重用全局的可修改变量。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO2-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO2-3)'
- en: Nonstandard packages can be imported using an import path in the form of an
    internet domain name and an optional path to the package in a certain module.
    For example, the Go tooling integrates well with `https://github.com`, so if you
    host your Go code in a Git repository, it will find a specified package. In this
    case, it’s the `https://github.com/oklog/run` Git repository with the `run` package
    in the `github.com/oklog/run` module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 非标准软件包可以通过互联网域名形式的导入路径引入，以及特定模块中软件包的可选路径。例如，Go工具链很好地集成了`https://github.com`，因此如果您在Git仓库中托管Go代码，它会找到指定的软件包。在这种情况下，是`https://github.com/oklog/run`
    Git仓库中的`run`软件包在`github.com/oklog/run`模块中。
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO2-4)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO2-4)'
- en: If the package is taken from the current module (in this case, our module is
    `github.com/prometheus/prometheus`), packages will be resolved from your local
    directory. In our example, `<module root>/config`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件包来自当前模块（在本例中，我们的模块是`github.com/prometheus/prometheus`），软件包将从您的本地目录解析。在我们的例子中，是`<module
    root>/config`。
- en: This model focuses on open and clearly defined dependencies. It works exceptionally
    well with the open source distribution model, where the community can collaborate
    on robust packages in the public Git repositories. Of course, a module or package
    can also be hidden using standard version control authentication protocols. Furthermore,
    the official tooling [does not support distributing packages in binary form](https://oreil.ly/EnkBT),
    so the dependency source is highly encouraged to be present for compilation purposes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型专注于开放和明确定义的依赖关系。它与开源分发模型非常契合，社区可以在公共的Git仓库上协作开发稳健的软件包。当然，模块或软件包也可以使用标准的版本控制认证协议进行隐藏。此外，官方工具链[不支持以二进制形式分发软件包](https://oreil.ly/EnkBT)，因此强烈鼓励依赖源码以便于编译。
- en: The challenges of software dependency are not easy to solve. Go learned from
    the mistakes of C++ and others, and takes a careful approach to avoid long compilation
    times, and an effect commonly called “dependency hell.”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 软件依赖的挑战并不容易解决。Go语言吸取了C++等语言的经验教训，采用谨慎的方法来避免长时间的编译，并避免所谓的“依赖地狱”问题的影响。
- en: Through the design of the standard library, great effort was spent on controlling
    dependencies. It can be better to copy a little code than to pull in a big library
    for one function. (A test in the system build complains if new core dependencies
    arise.) Dependency hygiene trumps code reuse. One example of this in practice
    is that the (low-level) net package has its own integer-to-decimal conversion
    routine to avoid depending on the bigger and dependency-heavy formatted I/O package.
    Another is that the string conversion package strconv has a private implementation
    of the definition of “printable” characters rather than pull in the large Unicode
    character class tables; that strconv honors the Unicode standard is verified by
    the package’s tests.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过标准库的设计，花费了大量精力来控制依赖关系。有时候复制少量代码比引入一个大型库来完成一个功能更好。（如果出现新的核心依赖关系，系统构建中的一个测试会报警。）依赖卫生优先于代码复用。在实践中的一个例子是，低级别的net包有自己的十进制转换例程，避免依赖更大、依赖重的格式化I/O包。另一个例子是strconv字符串转换包具有“可打印”字符定义的私有实现，而不是引入大型Unicode字符类表；strconv通过包的测试来验证其符合Unicode标准。
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/wqKGT)'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Rob Pike，《Google的Go语言：在软件工程服务中的语言设计》(“Go at Google: Language Design in the
    Service of Software Engineering”)，[链接](https://oreil.ly/wqKGT)'
- en: Again, with efficiency in mind, potential minimalism in dependencies and transparency
    brings enormous value. Fewer unknowns means we can quickly detect main bottlenecks
    and focus on the most significant value optimizations first. We don’t need to
    work around it if we notice potential room for optimization in our dependency.
    Instead, we are usually welcome to contribute the fix directly to the upstream,
    which helps both sides!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调效率，依赖的最小化和透明度带来了巨大的价值。减少未知因素意味着我们可以快速检测主要的瓶颈，并优先关注最重要的价值优化。如果我们注意到依赖项中存在优化的潜力空间，我们无需绕过它。相反，我们通常欢迎直接向上游贡献修复，这有助于双方！
- en: Consistent Tooling
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的工具链
- en: 'From the beginning, Go had a powerful and consistent set of tools as part of
    its command-line interface tool, called `go`. Let’s enumerate a few utilities:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Go语言作为其命令行接口工具的一部分拥有强大且一致的工具集，称为`go`。让我们列举一些实用工具：
- en: '`go bug` opens a new browser tab with the correct place where you can file
    an official bug report (Go repository on GitHub).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go bug` 打开一个新的浏览器标签，指向可以提交官方错误报告的正确位置（Go 仓库在 GitHub 上）。'
- en: '`go build -o <output path> <packages>` builds given Go packages.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go build -o <输出路径> <包>` 编译给定的 Go 包。'
- en: '`go env` shows all Go-related environment variables currently set in your terminal
    session.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go env` 显示当前终端会话中设置的所有与 Go 相关的环境变量。'
- en: '`go fmt <file, packages or directories>` formats given artifacts to the desired
    style, cleans whitespaces, fixes wrong indentations, etc. Note that the source
    code does not need to be even valid and compilable Go code. You can also install
    an extended official formatter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go fmt <文件、包或目录>` 格式化给定的文件到所需的风格，清理空白字符，修复错误的缩进等。请注意，源代码甚至不需要是有效和可编译的 Go 代码。你也可以安装一个扩展的官方格式化工具。'
- en: '[`goimports`](https://oreil.ly/6fDcy) also cleans and formats your `import`
    statements.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`goimports`](https://oreil.ly/6fDcy) 还会清理和格式化你的 `import` 语句。'
- en: For the best experience, set your programming IDE to run `goimports -w $FILE`
    on every file to not worry about the manual indentation anymore!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳体验，请设置你的编程 IDE 每次在文件上运行 `goimports -w $FILE`，以免再担心手动缩进问题！
- en: '`go get <package@version>` allows you to install the desired dependency with
    the expected version. Use the `@latest` suffix to get the latest version of `@none`
    to uninstall the dependency.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go get <包@版本>` 允许你安装所需的依赖项与期望的版本。使用 `@latest` 后缀获取最新版本或 `@none` 以卸载该依赖项。'
- en: '`go help <command/topic>` prints documentation about the command or given topic.
    For example, `go help environment` tells you all about the possible environment
    variables Go uses.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go help <命令/主题>` 打印关于给定命令或主题的文档。例如，`go help environment` 告诉你所有关于 Go 使用的可能环境变量。'
- en: '`go install <package>` is similar to `go get` and installs the binary if the
    given package is “executable.”'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go install <包>` 类似于 `go get`，如果给定的包是“可执行”的，则安装二进制文件。'
- en: '`go list` lists Go packages and modules. It allows flexible output formatting
    using Go templates (explained later), e.g., `go list -mod=readonly -m -f ''{{
    if and (not .Indirect) (not .Main)}}{{.Path}}{{end}}'' all` lists all direct nonexecutable
    dependent modules.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go list` 列出 Go 包和模块。它允许使用 Go 模板（稍后解释）进行灵活的输出格式化，例如 `go list -mod=readonly
    -m -f ''{{ if and (not .Indirect) (not .Main)}}{{.Path}}{{end}}'' all` 列出所有直接非可执行依赖模块。'
- en: '`go mod` allows managing dependent modules.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go mod` 允许管理依赖模块。'
- en: '`go test` allows running unit tests, fuzz tests, and benchmarks. We will discuss
    the latter in detail in [Chapter 8](ch08.html#ch-benchmarking).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go test` 允许运行单元测试、模糊测试和基准测试。我们将在 [第8章](ch08.html#ch-benchmarking) 中详细讨论后者。'
- en: '`go tool` hosts a dozen more advanced CLI tools. We will especially take a
    close look at `go tool pprof` in [“pprof Format”](ch09.html#ch-obs-pprof) for
    performance optimizations.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go tool` 提供了数十个更高级的命令行工具。我们将特别关注 [“pprof Format”](ch09.html#ch-obs-pprof)
    中的 `go tool pprof`，用于性能优化。'
- en: '`go vet` runs basic static analysis checks.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go vet` 执行基本的静态分析检查。'
- en: In most cases, the Go CLI is all you need for effective Go programming.^([11](ch02.html#idm45606842681408))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Go CLI 是进行有效的 Go 编程所需的全部工具。^([11](ch02.html#idm45606842681408))
- en: Single Way of Handling Errors
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一的错误处理方式
- en: 'Errors are an inevitable part of every running software. Especially in distributed
    systems, they are expected by design, with advanced research and algorithms for
    handling different types of failures.^([12](ch02.html#idm45606842674272)) Despite
    the need for errors, most programming languages do not recommend or enforce a
    particular way of failure handling. For example, in C++ you see programmers using
    all means possible to return an error from a function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是每个运行软件不可避免的一部分。特别是在分布式系统中，它们是设计上预期的，具有处理不同类型失败的先进研究和算法。^([12](ch02.html#idm45606842674272))
    尽管需要错误处理，大多数编程语言并不推荐或强制执行特定的错误处理方式。例如，在 C++ 中，你会看到程序员使用各种手段从函数中返回错误：
- en: Exceptions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Integer return codes (if the returned value is nonzero, it means error)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数返回码（如果返回值非零，则表示错误）
- en: Implicit status codes^([13](ch02.html#idm45606842670048))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式状态码^([13](ch02.html#idm45606842670048))
- en: Other sentinel values (if the returned value is `null`, then it’s an error)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他哨兵值（如果返回值是 `null`，则表示错误）
- en: Returning potential error by argument
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过参数返回潜在的错误
- en: Custom error classes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义错误类
- en: Monads^([14](ch02.html#idm45606842664160))
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子^([14](ch02.html#idm45606842664160))
- en: Each option has its pros and cons, but just the fact that there are so many
    ways of handling errors can cause severe issues. It causes surprises by potentially
    hiding that some statements can return an error, introduces complexity and, as
    a result, makes our software unreliable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每种选择都有其利弊，但仅仅有这么多处理错误的方式就可能导致严重问题。它通过潜在地隐藏某些语句可能会返回错误而引起意外，引入复杂性，因此使我们的软件不可靠。
- en: Undoubtedly, the intention for so many options was good. It gives a developer
    choices. Maybe the software you create is noncritical, or is the first iteration,
    so you want to make a “happy path” crystal clear. In such cases, masking some
    “bad paths” sounds like a good short-term idea, right? Unfortunately, as with
    many shortcuts, it poses numerous dangers. Software complexity and demand for
    functionalities cause the code to never go out of the “first iteration,” and noncritical
    code quickly becomes a dependency for something critical. This is one of the most
    important causes of unreliability or hard-to-debug software.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，有这么多选择的初衷是好的。它给开发者提供了选择。也许您创建的软件是非关键的，或者是第一个迭代版本，因此您希望“快乐路径”非常清晰。在这种情况下，掩盖一些“坏路径”似乎是一个不错的短期想法，对吗？不幸的是，就像许多捷径一样，它带来了许多危险。软件复杂性和功能需求导致代码永远无法脱离“第一次迭代”，并且非关键代码很快就会变成关键部分的依赖。这是导致软件不可靠或难以调试的最重要原因之一。
- en: Go takes a unique path by treating the error as a first-citizen language feature.
    It assumes we want to write reliable software, making error handling explicit,
    easy, and uniform across libraries and interfaces. Let’s see some examples in
    [Example 2-4](#code-errors).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Go 采用了一条独特的路径，将错误视为第一类语言特性。它假设我们想要编写可靠的软件，使错误处理变得显式、简单且在库和接口之间统一。让我们在[示例 2-4](#code-errors)中看一些例子。
- en: Example 2-4\. Multiple function signatures with different return arguments
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 具有不同返回参数的多个函数签名
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO3-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO3-1)'
- en: The critical aspect here is that functions and methods define the error flow
    as part of their signature. In this case, the `noErrCanHappen` function states
    that there is no way any error can happen during its invocation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是函数和方法将错误流定义为其签名的一部分。在这种情况下，`noErrCanHappen`函数声明在其调用期间不可能发生任何错误。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO3-2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO3-2)'
- en: By looking at the `doOrErr` function signature, we know some errors can happen.
    We don’t know what type of error yet; we only know it is implementing a built-in
    `error` interface. We also know that there was no error if the error is nil.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`doOrErr`函数的签名，我们知道可能会发生一些错误。我们还不知道错误的类型，但我们只知道它实现了内置的`error`接口。如果错误为 nil，则表示没有错误发生。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO3-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO3-3)'
- en: The fact that Go functions can return multiple arguments is leveraged when calculating
    some result in a “happy path.” If the error can happen, it should be the last
    return argument (always). From the caller side, we should only touch the result
    if the error is nil.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数可以返回多个参数的事实在计算“快乐路径”中得到了充分利用。如果可能发生错误，它应该是最后一个返回参数（始终如此）。从调用者的角度来看，只有在错误为
    nil 的情况下，我们才应该处理结果。
- en: It’s worth noting that Go has an exception mechanism called `panics`, which
    are recoverable using the `recover()` built-in function. While useful or necessary
    for certain cases (e.g., initialization), you should never use `panics` for conventional
    error handling in your production code in practice. They are less efficient, hide
    failures, and overall surprise the programmers. Having errors as part of invocation
    allows the compilator and programmer to be prepared for error cases in the normal
    execution path. [Example 2-5](#code-handling) shows how we can handle errors if
    they occur in our function execution path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Go 语言有一种称为`panics`的异常机制，可以使用内置函数`recover()`进行恢复。虽然在某些情况下（例如初始化）它们是有用或必要的，但在实际的生产代码中，你不应该将`panics`用于传统的错误处理。它们效率较低，隐藏了失败，并且总体上让程序员感到惊讶。将错误作为调用的一部分允许编译器和程序员在正常执行路径中准备处理错误情况。[示例 2-5](#code-handling)展示了如果在函数执行路径中发生错误，我们如何处理它们。
- en: Example 2-5\. Checking and handling errors
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 检查和处理错误
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO4-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO4-1)'
- en: Notice that we did not import the built-in `errors` package, but instead used
    the open source drop-in replacement `github.com/efficientgo/core/errors`. `core`
    module. This is my recommended replacement for the `errors` package and the popular,
    but archived, `github.com/pkg/errors`. It allows a bit more advanced logic, like
    wrapping errors you will see in step three.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有导入内置的`errors`包，而是使用了开源的替代品`github.com/efficientgo/core/errors`。这是我推荐的替代`errors`包和流行但已存档的`github.com/pkg/errors`，允许更高级的逻辑，如您将在第三步看到的错误包装。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO4-2)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO4-2)'
- en: To tell if an error happened, we need to check if the `err` variable is nil
    or not. Then, if an error occurs, we can follow with error handling. Usually,
    it means logging it, exiting the program, incrementing metrics, or even explicitly
    ignoring it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要判断是否发生错误，我们需要检查`err`变量是否为nil。然后，如果发生错误，我们可以进行错误处理。通常意味着记录日志，退出程序，增加度量标准，甚至明确地忽略它。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO4-3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO4-3)'
- en: Sometimes, it’s appropriate to delegate error handling to the caller. For example,
    if the function can fail from many errors, consider wrapping it with a `errors.Wrap`
    function to add a short context of what is wrong. For example, with `github.com/efficientgo/core/errors`,
    we will have context and stack trace, which will be rendered if `%+v` is used
    later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将错误处理委托给调用者是合适的。例如，如果函数可能因多个错误而失败，考虑使用`errors.Wrap`函数对其进行包装，以添加简短的错误上下文。例如，使用`github.com/efficientgo/core/errors`，我们将拥有上下文和堆栈跟踪，稍后使用`%+v`时将呈现这些信息。
- en: How to Wrap Errors?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理错误？
- en: Notice that I recommended `errors.Wrap` (or `errors.Wrapf`) instead of the built-in
    way of wrapping errors. Go defines the `%w` identifier for the `fmt.Errors` type
    of function that allows passing an error. Currently, I would not recommend `%w`
    because it’s not type safe and as explicit as `Wrap`, causing nontrivial bugs
    in the past.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我推荐使用`errors.Wrap`（或`errors.Wrapf`）而不是内置的错误包装方式。Go语言为`fmt.Errors`类型的函数定义了`%w`标识符，允许传递错误。目前，我不推荐使用`%w`，因为它不是类型安全的，也不像`Wrap`那样显式，过去曾导致一些非常规的错误。
- en: The one way of defining errors and handling them is one of Go’s best features.
    Interestingly, it is one of the language disadvantages due to verbosity and certain
    boilerplate involved. It sometimes might feel repetitive, but tools allow you
    to mitigate the boilerplate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义错误并处理它们的方式是Go语言的最佳特性之一。有趣的是，由于冗长和特定的样板，这也是语言的缺点之一。有时可能会感觉重复，但工具可以帮助您减少样板代码。
- en: Some Go IDEs define code templates. For example, in JetBrain’s GoLand product,
    typing **`err`** and pressing the Tab key will generate a valid `if err != nil`
    statement. You can also collapse or expand error handling blocks for readability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Go IDE定义了代码模板。例如，在JetBrains的GoLand产品中，输入**`err`**并按Tab键将生成一个有效的`if err !=
    nil`语句。您还可以折叠或展开以提高可读性的错误处理块。
- en: Another common complaint is that writing Go can feel very “pessimistic,” because
    the errors that may never occur are visible in plain sight. The programmer has
    to decide what to do with them at every step, which takes mental energy and time.
    Yet, in my experience it’s worth the work and makes programs much more predictable
    and easier to debug.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的抱怨是，编写Go代码可能会感觉非常“悲观”，因为那些可能永远不会发生的错误一目了然。程序员必须在每一步决定如何处理这些错误，这需要精力和时间。然而，根据我的经验，这是值得的工作，可以使程序更可预测，更易于调试。
- en: Never Ignore Errors!
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决不忽视错误！
- en: Due to the verbosity of error handling, it’s tempting to skip `err != nil` checks.
    Consider not doing it unless you know a function will never return an error (and
    in future versions!). If you don’t know what to do with the error, consider passing
    it to the caller by default. If you must ignore the error, consider doing it explicitly
    with the `_ =` syntax. Also, always use linters, which will warn you about some
    portion of unchecked errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误处理的冗长，很容易跳过`err != nil`的检查。除非您知道函数永远不会返回错误（甚至在未来版本中也是如此！），否则请不要这样做。如果不知道如何处理错误，请默认将其传递给调用者。如果必须忽略错误，请考虑使用`_
    =`语法明确地进行。此外，请始终使用检查器，它将警告您有些部分未经检查的错误。
- en: Are there any implications of the error handling for general Go code runtime
    efficiency? Yes! Unfortunately, it’s much more significant than developers usually
    anticipate. In my experience, error paths are frequently an order of magnitude
    slower and more expensive to execute than happy paths. One of the reasons is we
    tend not to ignore error flows during our monitoring or benchmarking steps (mentioned
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的Go代码运行时效率是否会受到错误处理的影响？是的！不幸的是，这比开发者通常预期的要显著得多。根据我的经验，错误路径通常比快乐路径执行速度慢一个数量级，而且执行起来更昂贵。其中一个原因是我们在监控或基准测试步骤中往往不会忽略错误流（在[“效率感知开发流程”](ch03.html#ch-conq-eff-flow)中提到）。
- en: Another common reason is that the construction of errors often involves heavy
    string manipulation for creating human-readable messages. As a result, it can
    be costly, especially with lengthy debugging tags, which are touched on later
    in this book. Understanding these implications and ensuring consistent and efficient
    error handling are essential in any software, and we will take a detailed look
    at that in the following chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见原因是，错误的构建通常涉及大量的字符串操作，用于创建可读性强的消息。因此，特别是在本书后面涉及的长调试标签，这可能会成本高昂。理解这些影响并确保一致且高效的错误处理对任何软件都至关重要，我们将在接下来的章节中详细讨论这一点。
- en: Strong Ecosystem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强大的生态系统
- en: A commonly stated strong point of Go is that its ecosystem is exceptionally
    mature for such a “young” language. While items listed in this section are not
    mandatory for solid programming dialects, they improve the whole development experience.
    This is also why the Go community is so large and still growing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Go普遍提到的一个优点是，尽管是一门“年轻”的语言，其生态系统对于坚实的编程方言来说非常成熟。虽然本节列出的项目对于稳固的编程方言并非必要，但它们提升了整个开发体验。这也是为什么Go社区如此庞大且不断发展的原因。
- en: First, Go allows the programmer to focus on business logic without necessarily
    reimplementing or importing third-party libraries for basic functionalities like
    YAML decoding or cryptographic hashing algorithms. Go standard libraries are high
    quality, robust, ultra-backward compatible, and rich in features. They are well
    benchmarked, have solid APIs, and have good documentation. As a result, you can
    achieve most things without importing external packages. For example, running
    an HTTP server is dead simple, as visualized in [Example 2-6](#code-basicserver).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Go允许程序员专注于业务逻辑，而不必重新实现或导入第三方库来进行基本功能，如YAML解码或加密哈希算法。Go标准库质量高，健壮，向后兼容性强，并且功能丰富。它们经过良好的基准测试，具有坚实的API和良好的文档。因此，您可以在不导入外部包的情况下完成大多数任务。例如，运行HTTP服务器非常简单，如在[示例2-6](#code-basicserver)中所示。
- en: Example 2-6\. Minimal code for serving HTTP requests^([15](ch02.html#idm45606839042576))
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-6\. 为提供HTTP请求而编写的最简代码^（[15](ch02.html#idm45606839042576)）
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In most cases, the efficiency of standard libraries is good enough or even better
    than third-party alternatives. For example, especially lower-level elements of
    packages, `net/http` for HTTP client and server code, or `crypto`, `math`, and
    `sort` parts (and more!), have a good amount of optimizations to serve most of
    the use cases. This allows developers to build more complex code on top while
    not worrying about the basics like `sorting` performance. Yet that’s not always
    the case. Some libraries are meant for specific usage, and misusing them may result
    in significant resource waste. We will look at all the things you need to be aware
    of in [Chapter 11](ch11.html#ch-opt2).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，标准库的效率足够好甚至比第三方替代方案更好。例如，特别是包的低级元素，如`net/http`用于HTTP客户端和服务器代码，或者`crypto`、`math`和`sort`等部分（还有更多！），都有大量的优化来满足大多数用例。这使得开发人员可以在其上构建更复杂的代码，而不必担心像`排序`性能这样的基础问题。然而，并非总是如此。有些库是为特定用途而设计的，错误使用它们可能导致显著的资源浪费。我们将在[第11章](ch11.html#ch-opt2)中探讨所有需要注意的事项。
- en: Another highlight of the mature ecosystem is a basic, official in-browser Go
    editor called [Go Playground](https://oreil.ly/9Os3y). It’s a fantastic tool if
    you want to test something out quickly or share an interactive code example. It’s
    also straightforward to extend, so the community often publishes variations of
    the Go Playground to try and share previously experimental language features like
    [generics](https://oreil.ly/f0qpm) (which are now part of the primary language
    and explained in [“Generics”](#ch-go-generics)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的生态系统的另一个亮点是一个基本的官方 Go 在线编辑器，称为 [Go Playground](https://oreil.ly/9Os3y)。如果您想快速测试或共享交互式代码示例，这是一个很棒的工具。它也很容易扩展，因此社区经常发布
    Go Playground 的变体，以尝试和分享先前的实验性语言特性，如 [泛型](https://oreil.ly/f0qpm)（现在已成为主要语言的一部分，并在
    [“泛型”](#ch-go-generics) 中解释）。
- en: Last but not least, the Go project defines its templating language, called [Go
    templates](https://oreil.ly/FdEZ8). In some way, it’s similar to Python’s [Jinja2
    language](https://oreil.ly/U6Em1). While it sounds like a side feature of Go,
    it’s beneficial in any dynamic text or HTML generation. It is also often used
    in popular tools like [Helm](https://helm.sh) or [Hugo](https://gohugo.io).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，Go 项目定义了其模板语言，称为 [Go templates](https://oreil.ly/FdEZ8)。在某种程度上，它类似于
    Python 的 [Jinja2 语言](https://oreil.ly/U6Em1)。尽管听起来像是 Go 的一个附带功能，但在任何动态文本或 HTML
    生成中都是非常有用的。它也经常用于流行工具如 [Helm](https://helm.sh) 或 [Hugo](https://gohugo.io)。
- en: Unused Import or Variable Causes Build Error
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未使用的导入或变量导致构建错误
- en: The compilation will fail if you define a variable in Go but never read any
    value from it or don’t pass it to another function. Similarly, it will fail if
    you added a package to the `import` statement but don’t use that package in your
    file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Go 中定义了一个变量但从未读取其值或不将其传递给另一个函数，则编译将失败。同样地，如果在 `import` 语句中添加了一个包但在文件中未使用该包，则也会失败。
- en: I see that Go developers have gotten used to this feature and love it, but it
    is surprising for newcomers. Failing on unused constructs can be frustrating if
    you want to play with the language quickly, e.g., create some variable without
    using it for debugging purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到 Go 开发者已经习惯了这个功能并且喜欢它，但对新手来说可能会感到惊讶。对未使用的结构进行编译失败可能会令人沮丧，如果你想快速尝试语言，例如为调试目的创建一些未使用的变量。
- en: There are, however, ways to handle these cases explicitly! You can see a few
    examples of dealing with these usage checks in [Example 2-7](#code-unused).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有办法可以明确处理这些情况！您可以在 [示例 2-7](#code-unused) 中看到处理这些使用检查的几个例子。
- en: Example 2-7\. Various examples of unused and used variables
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 多个未使用和已使用的变量示例
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO5-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO5-1)'
- en: Variables `a`, `b`, and `c` are not used, so they cause a compilation error.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `a`、`b` 和 `c` 没有使用，因此会导致编译错误。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO5-4)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO5-4)'
- en: Variable `e` is used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `e` 被使用。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO5-5)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO5-5)'
- en: Variable `f` is technically used for an explicit no identifier (`_`). Such an
    approach is useful if you explicitly want to tell the reader (and compiler) that
    you want to ignore the value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `f` 技术上用于明确的无标识符 (`_`)。如果您明确希望告诉读者（和编译器）您要忽略该值，这种方法非常有用。
- en: Similarly, unused imports will fail the compilation process, so tools like `goimports`
    (mentioned in [“Consistent Tooling”](#ch-go-tooling)) automatically remove unused
    ones. Failing on unused variables and imports effectively ensures that code stays
    clear and relevant. Note that only internal function variables are checked. Elements
    like unused `struct` fields, methods, or types are not checked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，未使用的导入会导致编译失败，因此像 `goimports`（在 [“一致的工具”](#ch-go-tooling) 中提到）会自动删除未使用的导入。对未使用的变量和导入的编译失败有效地确保代码保持清晰和相关。请注意，只有内部函数变量会受到检查，诸如未使用的
    `struct` 字段、方法或类型不会被检查。
- en: Unit Testing and Table Tests
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和表测试
- en: 'Tests are a mandatory part of every application, small or big. In Go, tests
    are a natural part of the development process—easy to write, and focused on simplicity
    and readability. If we want to talk about efficient code, we need to have solid
    testing in place, allowing us to iterate over the program without worrying about
    regressions. Add a file with the *_test.go* suffix to introduce a unit test to
    your code within a package. You can write any Go code within that file, which
    won’t be reachable from the production code. There are, however, four types of
    functions you can add that will be invoked for different testing parts. A certain
    signature distinguishes these types, notably function name prefixes: `Test`, `Fuzz`,
    `Example`, or `Benchmark`, and specific arguments.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是每个应用程序的强制部分，无论大小。在Go语言中，测试是开发过程的自然组成部分——易于编写，并专注于简单性和可读性。如果我们想要谈论高效的代码，我们需要在位于包内的代码中引入一个带有*_test.go*后缀的文件来引入一个单元测试。您可以在该文件中编写任何不会从生产代码中访问的Go代码。但是，您可以添加四种类型的函数，这些函数将被调用以用于不同的测试部分。特定的签名区分这些类型，特别是函数名前缀：`Test`、`Fuzz`、`Example`或`Benchmark`，以及具体的参数。
- en: Let’s walk through the unit test type in [Example 2-8](#code-test). To make
    it more interesting, it’s a table test. Examples and benchmarks are explained
    in [“Code Documentation as a First Citizen”](#ch-go-godoc) and [“Microbenchmarks”](ch08.html#ch-obs-micro).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下[示例 2-8](#code-test)中的单元测试类型。为了使其更有趣，这是一个表格测试。示例和基准测试解释在[“代码文档作为第一公民”](#ch-go-godoc)和[“微基准测试”](ch08.html#ch-obs-micro)中。
- en: Example 2-8\. Example unit table test
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 示例单元表格测试
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO6-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO6-1)'
- en: If the function inside the *_test.go* file is named with the `Test` word and
    takes exactly `t *testing.T`, it is considered a “unit test.” You can run them
    through the `go test` command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*_test.go*文件中的函数命名以`Test`开头，并且接收恰好是`t *testing.T`，那么它被视为“单元测试”。你可以通过`go test`命令来运行它们。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO6-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO6-2)'
- en: Usually, we want to test a specific function using multiple test cases (often
    edge cases) that define different input and expected output. This is where I would
    suggest using table tests. First, define your input and output, then run the same
    function in an easy-to-read loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望使用多个测试用例（通常是边界情况），定义不同的输入和预期输出来测试特定函数。这就是我建议使用表格测试的地方。首先，定义你的输入和输出，然后在一个易于阅读的循环中运行同一个函数。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO6-3)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO6-3)'
- en: Optionally, you can invoke `t.Run`, which allows you to specify a subtest. Defining
    those on dynamic test cases like table tests is a good practice. It will enable
    you to navigate to the failing case quickly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以调用`t.Run`，它允许您指定一个子测试。在像表格测试这样的动态测试用例上定义它们是一个很好的实践。这将使您能够快速导航到失败的案例。
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO6-4)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO6-4)'
- en: The Go `testing.T` type gives useful methods like `Fail` or `Fatal` to abort
    and fail the unit test, or `Error` to continue running and check other potential
    errors. In our example, I propose using a simple helper called `testutil.Equals`
    from our [open source core library](https://oreil.ly/yAit9), giving you a nice
    diff.^([16](ch02.html#idm45606838437664))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的`testing.T`类型提供了诸如`Fail`或`Fatal`之类的有用方法，以中止和失败单元测试，或者`Error`以继续运行和检查其他潜在的错误。在我们的示例中，我建议使用一个简单的辅助工具，称为来自我们[开源核心库](https://oreil.ly/yAit9)的`testutil.Equals`，这将为您提供一个漂亮的差异。^([16](ch02.html#idm45606838437664))
- en: Write tests often. It might surprise you, but writing unit tests for critical
    parts up front will help you implement desired features much faster. This is why
    I recommend following some reasonable form of test-driven development, covered
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 经常编写测试。也许会让你惊讶，但是为关键部分及早编写单元测试将有助于更快地实现所需的功能。这就是为什么我建议遵循一些合理的测试驱动开发形式，详细介绍在[“高效开发流程”](ch03.html#ch-conq-eff-flow)中。
- en: This information should give you a good overview of the language goals, strengths,
    and features before moving to more advanced features.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息应该为您提供了在进入更高级特性之前对语言目标、优势和特性的良好概述。
- en: Advanced Language Elements
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级语言元素
- en: Let’s now discuss the more advanced features of Go. Similar to the basics mentioned
    in the previous section, it’s crucial to overview core language capabilities before
    discussing efficiency improvements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论 Go 的更高级功能。与前一节提到的基础知识类似，重要的是在讨论效率改进之前概述核心语言功能。
- en: Code Documentation as a First Citizen
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为第一公民的代码文档
- en: Every project, at some point, needs solid API documentation. For library-type
    projects, the programmatic APIs are the main entry point. Robust interfaces with
    good descriptions allow developers to hide complexity, bring value, and avoid
    surprises. A code interface overview is essential for applications, too, allowing
    anyone to understand the codebase quickly. Reusing an application’s Go packages
    in other projects is also not uncommon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目在某个时候都需要扎实的 API 文档。对于库类型项目，程序化 API 是主要的入口点。具有良好描述的强大接口允许开发人员隐藏复杂性，带来价值，并避免意外。应用程序也需要代码接口概述，这对于快速理解代码库非常重要。在其他项目中重用应用程序的
    Go 包也并不罕见。
- en: Instead of relying on the community to create many potentially fragmented and
    incompatible solutions, the Go project developed a tool called [`godoc`](https://oreil.ly/TQXxv)
    from the start. It behaves similarly to Python’s [Docstring](https://oreil.ly/UdkzS)
    and Java’s [Javadoc](https://oreil.ly/wlWGT). `godoc` generates a consistent documentation
    HTML website directly from the code and its comments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Go 项目开发了一个名为[`godoc`](https://oreil.ly/TQXxv)的工具，从一开始就不依赖社区创建可能分散和不兼容的解决方案。它的行为类似于
    Python 的[Docstring](https://oreil.ly/UdkzS)和 Java 的[Javadoc](https://oreil.ly/wlWGT)。`godoc`可以直接从代码及其注释生成一致的文档
    HTML 网站。
- en: The amazing part is that you don’t have many special conventions that would
    directly make the code comments less readable from the source code. To use this
    tool effectively, you need to remember five things. Let’s go through them using
    Examples [2-9](#code-godoc) and [2-10](#code-godoc2). The resulting HTML page,
    when [`godoc` is invoked](https://oreil.ly/EYJlx), can be seen in [Figure 2-1](#img-godoc).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊奇的是，您不需要许多特殊的约定来直接降低代码注释的可读性。要有效使用这个工具，您需要记住五件事。我们通过示例[2-9](#code-godoc)和[2-10](#code-godoc2)来详细说明它们。当调用[`godoc`](https://oreil.ly/EYJlx)时，生成的
    HTML 页面可以在[图 2-1](#img-godoc)中看到。
- en: Example 2-9\. Example snippet of block.go file with `godoc` compatible documentation
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 2-9\. `godoc` 兼容文档的 block.go 文件示例代码片段
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO7-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO7-1)'
- en: 'Rule 1: The optional package-level description must be placed on top of the
    `package` entry with no intervening blank line and start with the `Package <name>`
    prefix. If any source files have these entries, `godoc` will collect them all.
    If you have many files, the convention is to have the *doc.go* file with just
    the package-level documentation, package statement, and no other code.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 1: 可选的包级描述必须放在 `package` 条目的顶部，没有空行，并以 `Package <name>` 前缀开始。如果任何源文件有这些条目，`godoc`
    将收集它们。如果有许多文件，通常会在 *doc.go* 文件中只放置包级别的文档、包语句和没有其他代码。'
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO7-2)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO7-2)'
- en: 'Rule 2: Any public construct should have a full sentence commentary, starting
    with the name of the construct (it’s important!), right before its definition.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 2: 任何公共结构都应该有一个完整的句子评论，以结构的名称（这很重要！）开始，紧接着是其定义。'
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO7-4)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO7-4)'
- en: 'Rule 3: Known bugs can be mentioned with `// BUG(who)` statements.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 3: 已知的错误可以用 `// BUG(who)` 语句提及。'
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO7-5)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO7-5)'
- en: Private constructs can have comments, but they will never be exposed in the
    documentation since they are private. Be consistent and start them with a construct
    name, too, for readability.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 私有结构可以有注释，但由于它们是私有的，永远不会在文档中公开。为了可读性，请一致地以结构名称开头。
- en: Example 2-10\. Example snippet of block_test.go file with `godoc` compatible
    documentation
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 2-10\. `godoc` 兼容文档的 block_test.go 文件示例代码片段
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO8-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO8-1)'
- en: 'Rule 4: If you write a function named `Example<ConstructName>` in the test
    file, e.g., `block_test.go`, the `godoc` will generate an interactive code block
    with the desired examples. Note that the package name must have a *_test* suffix,
    too, representing a local testing package that tests the package without access
    to private fields. Since examples are part of the unit test, they will be actively
    run and compiled.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 4：如果您在测试文件（例如 `block_test.go`）中编写了一个名为 `Example<ConstructName>` 的函数，`godoc`
    将生成一个交互式代码块，其中包含所需的示例。请注意，包名也必须有一个 *_test* 后缀，表示一个本地测试包，该包在没有访问私有字段的情况下测试包。由于示例是单元测试的一部分，它们将被积极运行和编译。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO8-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO8-2)'
- en: 'Rule 5: If the example has the last comment starting with `// Output:`, the
    string after it will be asserted with the standard output after the example, allowing
    the example to stay reliable.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 5：如果示例的最后一个注释以 `// Output:` 开头，那么在示例之后将会与标准输出进行断言，使得示例保持可靠。
- en: '![efgo 0201](assets/efgo_0201.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0201](assets/efgo_0201.png)'
- en: Figure 2-1\. `godoc` output of Examples [2-9](#code-godoc) and [2-10](#code-godoc2)
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. `godoc` 输出示例 [2-9](#code-godoc) 和 [2-10](#code-godoc2)
- en: I highly recommend sticking to those five simple rules. Not only because you
    can manually run `godoc` and generate your documentation web page, but the additional
    benefit is that these rules make your Go code comments structured and consistent.
    Everyone knows how to read them and where to find them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议遵循这五个简单的规则。不仅因为您可以手动运行 `godoc` 并生成您的文档网页，而且另一个好处是，这些规则使您的 Go 代码注释结构化和一致。每个人都知道如何阅读它们以及在哪里找到它们。
- en: I recommend using complete English sentences in all comments, even if the will
    not appear in `godoc`. It will help you keep your code commentary self-explanatory
    and explicit. After all, comments are for humans to read.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在所有注释中使用完整的英文句子，即使它们不会出现在 `godoc` 中。这将帮助您保持代码注释的自解释性和明确性。毕竟，注释是供人类阅读的。
- en: Furthermore, the Go team maintains a [public documentation website](https://pkg.go.dev)
    that scrapes all requested public repositories for free. Thus, if your public
    code repository is compatible with `godoc`, it will be rendered correctly, and
    users can read the autogenerated documentation for every module or package version.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go 团队维护着一个[公共文档网站](https://pkg.go.dev)，它会免费爬取所有请求的公共存储库。因此，如果您的公共代码存储库与 `godoc`
    兼容，它将被正确地渲染，用户可以阅读每个模块或包版本的自动生成文档。
- en: Backward Compatibility and Portability
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向后兼容性与可移植性
- en: Go has a strong take on backward compatibility guarantees. This means that core
    APIs, libraries, and language specifications should never break old code created
    for [Go 1.0](https://oreil.ly/YOKfu). This was proven to be well executed. There
    is a lot of trust in upgrading Go to the latest minor or patch versions. Upgrades
    are, in most cases, smooth and without significant bugs and surprises.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对向后兼容性保证非常重视。这意味着核心 API、库和语言规范不应该破坏为 [Go 1.0](https://oreil.ly/YOKfu) 创建的旧代码。这一点已被证明执行得很好。在将
    Go 升级到最新的小版本或补丁版本时，人们非常信任。升级在大多数情况下是平稳的，没有重大的错误和意外。
- en: Regarding efficiency compatibility, it’s hard to discuss any guarantees. There
    is (usually) no guarantee that the function that does two memory allocations now
    will not use hundreds in the next version of the Go project and any library. There
    have been surprises between versions in efficiency and speed characteristics.
    The community is working hard on improving the compilation and language runtime
    (more in [“Go Runtime”](#ch-go-runtime) and [Chapter 4](ch04.html#ch-hardware)).
    Since the hardware and operating systems are also developed, the Go team is experimenting
    with different optimizations and features to allow everyone to execute more efficiently.
    Of course, we don’t speak about major performance regression here, as that is
    usually noticed and fixed in the release candidate period. Yet if we want our
    software to be deliberately fast and efficient, we need to be more vigilant and
    aware of the changes Go introduces.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关于效率兼容性，很难讨论任何保证。通常情况下，并不能保证现在执行两次内存分配的函数在 Go 项目和任何库的下一个版本中不会使用数百次。在效率和速度特性方面，版本之间确实存在一些惊喜。社区正在努力改进编译和语言运行时（更多信息请参见[“Go
    运行时”](#ch-go-runtime) 和 [第 4 章](ch04.html#ch-hardware)）。由于硬件和操作系统也在不断发展，Go 团队正在尝试不同的优化和功能，以使每个人都能更有效地执行。当然，我们并不讨论主要性能回归问题，因为通常会在发布候选期间注意到并修复。然而，如果我们希望我们的软件有意快速和高效，我们需要更加警惕和了解
    Go 引入的变化。
- en: Source code is compiled into binary code that is targeted to each platform.
    Yet Go tooling allows cross-platform compilation, so you can build binaries to
    almost all architectures and operating systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码编译为针对每个平台的二进制代码。然而，Go 工具允许跨平台编译，因此您可以构建几乎所有架构和操作系统的二进制文件。
- en: When you execute the Go binary, which was compiled for a different operating
    system (OS) or architecture, it can return cryptic error messages. For example,
    a common error is an Exec format error when you try running binary for Darwin
    (macOS) on Linux. You must recompile the code source for the correct architecture
    and OS if you see this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行为不同操作系统（OS）或架构编译的 Go 二进制文件时，可能会返回神秘的错误消息。例如，当您尝试在 Linux 上运行为 Darwin（macOS）编译的二进制文件时，常见的错误是
    Exec 格式错误。如果出现这种情况，您必须重新编译代码源以适应正确的架构和操作系统。
- en: Regarding portability, we can’t skip mentioning the Go runtime and its characteristics.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可移植性，我们不能不提 Go 运行时及其特性。
- en: Go Runtime
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 运行时
- en: Many languages decided to solve portability across different hardware and operating
    systems by using virtual machines. Typical examples are [Java Virtual Machine
    (JVM)](https://oreil.ly/fhOmL) for Java bytecode compatible languages (e.g., Java
    or Scala), and [Common Language Runtime (CLR)](https://oreil.ly/StGbU) for .NET
    code, e.g., C#. Such a virtual machine allows for building languages without worrying
    about complex memory management logic (allocation and releasing), differences
    between hardware and operating systems, etc. JVM or CLR interprets the intermediate
    bytecode and transfers program instructions to the host. Unfortunately, while
    making it easier to create a programming language, they also introduce some overhead
    and many unknowns.^([17](ch02.html#idm45606838184304)) To mitigate the overhead,
    virtual machines often use complex optimizations like [just-in-time (JIT) compilation](https://oreil.ly/XXARz)
    to process chunks of specific virtual machine bytecode to machine code on the
    fly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言决定通过使用虚拟机来解决跨不同硬件和操作系统的可移植性问题。典型的例子是[Java 虚拟机（JVM）](https://oreil.ly/fhOmL)，适用于
    Java 字节码兼容语言（例如 Java 或 Scala），以及[公共语言运行时（CLR）](https://oreil.ly/StGbU)，适用于 .NET
    代码，例如 C#。这样的虚拟机允许构建语言而无需担心复杂的内存管理逻辑（分配和释放）、硬件和操作系统之间的差异等。JVM 或 CLR 解释中间字节码并将程序指令传递到主机。然而，尽管这使得创建编程语言更容易，它们也引入了一些开销和许多未知因素。^([17](ch02.html#idm45606838184304))
    为了减少开销，虚拟机通常使用复杂的优化技术，如即时（JIT）编译，以在运行时将特定虚拟机字节码块处理为机器码。
- en: Go does not need any “virtual machine.” Our code and used libraries compile
    fully to machine code during compilation time. Thanks to standard library support
    of large operating systems and hardware, our code, if compiled against particular
    architecture, will run there with no issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不需要任何“虚拟机”。我们的代码和所用的库在编译时完全编译为机器码。由于标准库支持大型操作系统和硬件，我们的代码在针对特定架构编译后，在那里运行没有问题。
- en: Yet something is running in the background (concurrently) when our program starts.
    It’s the [Go runtime](https://oreil.ly/mywcZ) logic that, among other minor features
    of Go, is responsible for memory and concurrency management.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序启动时，后台会同时运行一些内容。这是[Go运行时](https://oreil.ly/mywcZ)的逻辑之一，除了Go的其他较小特性外，它还负责内存和并发管理。
- en: Object-Oriented Programming
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Undoubtedly, object-oriented programming (OOP) got enormous traction over the
    last decades. It was invented around 1967 by Alan Kay, and it’s still the most
    popular paradigm in programming.^([18](ch02.html#idm45606838174512)) OOP allows
    us to leverage advanced concepts like [encapsulation, abstraction, polymorphisms,
    and inheritance](https://oreil.ly/8hA0u). In principle, it allows us to think
    about code as some objects with attributes (in Go fields) and behaviors (methods)
    telling each other what to do. Most OOP examples talk about high-level abstractions
    like an animal that exposes the `Walk()` method or a car that allows to `Ride()`,
    but in practice, objects are usually less abstract yet still helpful, encapsulated,
    and described by a class. There are no classes in Go, but there are `struct` types
    equivalents. [Example 2-11](#code-oop) shows how we can write OOP code in Go to
    compact multiple block objects into one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '无疑，面向对象编程（OOP）在过去几十年中获得了巨大的推广。它由Alan Kay于大约1967年发明，至今仍然是编程中最流行的范式。^([18](ch02.html#idm45606838174512))
    OOP允许我们利用高级概念，如[封装、抽象、多态和继承](https://oreil.ly/8hA0u)。原则上，它允许我们将代码视为具有属性（在Go中为字段）和行为（方法）的对象，彼此告知如何操作。大多数OOP示例讨论高级抽象，如具有`Walk()`方法的动物或允许`Ride()`的汽车，但实际上，对象通常不那么抽象，仍然有助于封装，并由类描述。在Go中没有类，但有`struct`类型的等效物。[示例 2-11](#code-oop)展示了我们如何在Go中编写OOP代码，将多个块对象压缩成一个。  '
- en: Example 2-11\. Example of the OOP in Go with `Group` that can behave like `Block`
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. 在Go中使用`Group`作为`Block`的示例
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO9-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO9-1)'
- en: In Go, there is no separation between structures and classes, like in C++. In
    Go, on top of basic types like `integer`, `string`, etc., there is a `struct`
    type that can have methods (behaviors) and fields (attributes). We can use structures
    as a `class` equivalent to *encapsulate* more complex logic under a more straightforward
    interface. For example, the `Duration()` method on `Block` tells us the duration
    of the time range covered by the block.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，没有像C++中那样的结构和类的分离。在Go中，除了基本类型如`integer`、`string`等外，还有一个可以拥有方法（行为）和字段（属性）的`struct`类型。我们可以使用结构体作为`class`的等效物，*封装*更复杂的逻辑在更简单的接口下。例如，在`Block`上的`Duration()`方法告诉我们覆盖的时间范围的持续时间。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO9-3)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO9-3)'
- en: If we add some struct, e.g., `Block`, into another struct, e.g., `Group`, without
    any name, such a `Block` `struct` is considered embedded instead of being a field.
    Embedding allows Go developers to get the most valuable part of *inheritance*,
    borrowing the embedded structure fields and methods. In this case, `Group` will
    have `Block`’s fields and `Duration` method. This way, we can reuse a significant
    amount of code in our production codebases.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一些结构体，例如`Block`，添加到另一个结构体，例如`Group`，而没有任何名称，这样的`Block`结构体被认为是嵌入的，而不是字段。嵌入允许Go开发人员获取*继承*的最有价值部分，借用嵌入结构的字段和方法。在这种情况下，`Group`将拥有`Block`的字段和`Duration`方法。这样，我们可以在生产代码库中重复使用大量代码。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO9-4)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO9-4)'
- en: 'There are two types of methods you can define in Go: using the “value receiver”
    (e.g., as in the `Duration()` method) or using the “pointer receiver” (with `*`).
    The so-called receiver is the variable after `func`, which represents the type
    we are adding a method to, in our case `Group`. We will mention this in [“Values,
    Pointers, and Memory Blocks”](ch05.html#ch-hw-allocations), but the rule regarding
    which one to use is straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有两种方法可以定义：使用“值接收器”（例如，像`Duration()`方法中的方式）或使用“指针接收器”（使用`*`）。所谓的接收器是`func`之后的变量，表示我们要为其添加方法的类型，在我们的案例中是`Group`。我们将在[“值、指针和内存块”](ch05.html#ch-hw-allocations)中提到这一点，但关于使用哪种方法的规则很简单：
- en: Use the value receiver (no `func (g Group) SomeMethod()`) if your method does
    not modify the `Group` state. For the value receiver, every time we invoke it,
    the `g` will create a local copy of the `Group` object. It is equivalent to `func
    SomeMethod(g Group)`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的方法不修改 `Group` 的状态，请使用值接收器（不要 `func (g Group) SomeMethod()`）。对于值接收器，每次调用时
    `g` 将创建 `Group` 对象的本地副本。这等效于 `func SomeMethod(g Group)`。
- en: Use the pointer receiver (e.g., `func (g *Group) SomeMethod()`) if your method
    is meant to modify the local receiver state or if any other method does that.
    It is equivalent to `func SomeMethod(g *Group)`. In our example, if the `Group.Merge()`
    method would be a value receiver, we will not persist `g.childen` changes or potentially
    inject `g.start` and `g.end` values. Additionally, for consistency, it’s always
    recommended to have a type with all pointer receiver methods if at least one requires
    a pointer.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的方法旨在修改本地接收器状态或者任何其他方法也这样做，请使用指针接收器（例如 `func (g *Group) SomeMethod()`）。对于指针接收器，每次调用时都会修改
    `g` 的本地接收器状态。这等效于 `func SomeMethod(g *Group)`。在我们的示例中，如果 `Group.Merge()` 方法是值接收器，我们将无法持久化
    `g.children` 的更改，或者潜在地注入 `g.start` 和 `g.end` 的值。另外，为了保持一致性，建议始终具有所有指针接收器方法的类型，如果至少有一个方法要求指针接收器。
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO9-5)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO9-5)'
- en: To compact multiple blocks together, our algorithm requires a sorted list of
    blocks. We can use the standard library [`sort.Sort`](https://oreil.ly/N6ZWS),
    which expects the `sort.Interface` interface. The `[]Block` slice does not implement
    this interface, so we convert it to our temporary `sortable` type, explained in
    [Example 2-13](#code-oop-sortable).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将多个块紧凑地放在一起，我们的算法需要一个排好序的块列表。我们可以使用标准库中的 [`sort.Sort`](https://oreil.ly/N6ZWS)，它期望实现
    `sort.Interface` 接口。`[]Block` 切片没有实现此接口，因此我们将其转换为我们临时的 `sortable` 类型，详见 [示例 2-13](#code-oop-sortable)。
- en: '[![5](assets/5.png)](#co_efficient_introduction_to_go_CO9-6)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_efficient_introduction_to_go_CO9-6)'
- en: This is the only missing element for true inheritance. Go does not allow casting
    specific types into another type unless it’s an alias or strict single-struct
    embedding (shown in [Example 2-13](#code-oop-sortable)). After that, you can only
    cast the interface into some type. That’s why we need to specify embedded `struct`
    and `Block` explicitly. As a result, Go is often considered a language that does
    not support full inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真正继承的唯一缺失要素。Go 不允许将特定类型强制转换为另一种类型，除非它是一个别名或者严格的单结构嵌入（如 [示例 2-13](#code-oop-sortable)
    所示）。之后，你只能将接口转换为某些类型。这就是为什么我们需要明确指定嵌入的 `struct` 和 `Block`。因此，Go 通常被认为是一种不支持完全继承的语言。
- en: What does [Example 2-11](#code-oop) give us? First, the `Group` type can reuse
    `Block` functionality, and if done correctly, we can use `Group` as any other
    `Block`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-11](#code-oop) 给了我们什么？首先，`Group` 类型可以重用 `Block` 的功能，如果正确处理，我们可以像处理任何其他
    `Block` 一样处理 `Group`。'
- en: Embedding Multiple Types
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入多种类型
- en: You can embed as many unique structures as you want within one `struct`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个 `struct` 中嵌入任意多个唯一结构。
- en: There is no priority for these—the compilation will fail if the compilator can’t
    tell which method to use because two embedded types have the same `SomeMethod()`
    method. In such cases, use the type name to explicitly tell the compilator what
    should be used.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些没有优先级——如果编译器不能确定使用哪个方法，编译将失败，因为两个嵌入类型具有相同的 `SomeMethod()` 方法。在这种情况下，请使用类型名称显式告诉编译器应该使用哪一个。
- en: As mentioned in [Example 2-11](#code-oop), Go also allows defining interfaces
    that tell what methods `struct` has to implement to match it. Note that there
    is no need to mark a specific `struct` explicitly that implements a particular
    interface, as in other languages like Java. It’s enough just to implement the
    required methods. Let’s see an example of sorting interface exposed by the standard
    library in [Example 2-12](#code-oop-sort).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [示例 2-11](#code-oop) 中所述，Go 也允许定义接口，告诉 `struct` 必须实现哪些方法来匹配它。注意，不需要像 Java
    等其他语言那样显式标记实现特定接口的特定 `struct`，只需实现所需的方法即可。让我们看一个标准库中公开的排序接口的示例，详见 [示例 2-12](#code-oop-sort)。
- en: Example 2-12\. Sorting interface from the standard `sort` Go library
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-12\. 标准 `sort` Go 库中的排序接口
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use our type in the `sort.Sort` function, it has to implement all `sort.Interface`
    methods. [Example 2-13](#code-oop-sortable) shows how `sortable` type does it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `sort.Sort` 函数中使用我们的类型，它必须实现所有 `sort.Interface` 方法。[示例 2-13](#code-oop-sortable)
    展示了 `sortable` 类型如何实现这些方法。
- en: Example 2-13\. Example of the type that can be sorted using `sort.Slice`
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-13\. 可以使用 `sort.Slice` 进行排序的类型示例
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO10-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO10-1)'
- en: We can embed another type (e.g., a slice of `Block` elements) as the only thing
    in our `sortable` struct. This allows easy (but explicit) casting between `[]Block`
    and `sortable`, as we used in the `Compact` method in [Example 2-11](#code-oop).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将另一种类型（例如`Block`元素的切片）作为我们的`sortable`结构中的唯一内容嵌入。这允许我们在[示例 2-11](#code-oop)中使用的`Compact`方法中进行简单（但显式）的强制转换。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO10-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO10-2)'
- en: We can sort by increasing the `start` time using the [`time.Time.Before(...)`](https://oreil.ly/GQ2Ru)
    method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过[`time.Time.Before(...)`](https://oreil.ly/GQ2Ru)方法按增加的`start`时间进行排序。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO10-3)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO10-3)'
- en: We can assert our `sortable` type implements `sort.Interface` using this single-line
    statement, which fails compilation otherwise. I recommend using such statements
    whenever you want to ensure your type stays compatible with a particular interface
    in the future!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这一行语句来断言我们的`sortable`类型实现了`sort.Interface`，否则将无法通过编译。我建议在未来要确保你的类型与特定接口兼容时使用这种语句！
- en: To sum up, `struct` methods, fields, and interfaces are an excellent yet simple
    way of writing both procedural composable and object-oriented code. In my experience,
    eventually it satisfies both low-level and high-level programming needs during
    our software development. While Go does not support all inheritance aspects (type
    to type casting), it provides enough to satisfy almost all OOP cases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`结构体`的方法、字段和接口是编写过程化可组合和面向对象代码的一个出色而简单的方式。根据我的经验，在我们软件开发期间最终能够满足低级和高级编程需求。虽然Go不支持所有继承方面的特性（类型到类型转换），但它提供了足够满足几乎所有面向对象编程案例的内容。
- en: Generics
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用（Generics）
- en: Since version 1.18, Go supports [generics](https://oreil.ly/qYyuQ), one of the
    community’s most desired features. Generics, also called [parametric polymorphism](https://oreil.ly/UIUAg),
    allow type-safe implementations of the functionalities we want to reuse across
    different types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go版本1.18起，支持[通用](https://oreil.ly/qYyuQ)，这是社区最期待的功能之一。通用，又称[参数多态](https://oreil.ly/UIUAg)，允许我们对不同类型重用的功能进行类型安全的实现。
- en: 'The demand for generics in Go started quite big discussions in the Go team
    and community because of two main problems:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go中的通用需求引发了Go团队和社区的广泛讨论，因为它带来了两个主要问题：
- en: Two ways of doing the same thing
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的事情可以有两种做法
- en: From the beginning, Go already supported type-safe reusable code via interfaces.
    You could see that in the preceding OOP example—the [`sort.Sort`](https://oreil.ly/X2NxR)
    can be reusable by all types that implement a `sort.Interface` presented in [Example 2-12](#code-oop-sort).
    We can sort our custom `Block` type by implementing those methods in [Example 2-13](#code-oop-sortable).
    Adding generics means we have [two ways of doing a thing](https://oreil.ly/dL8uE)
    in many cases.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Go就已经通过接口支持了类型安全的可重用代码。你可以在之前的面向对象示例中看到这一点——[`sort.Sort`](https://oreil.ly/X2NxR)可以被所有实现`sort.Interface`的类型重用，如[示例 2-12](#code-oop-sort)中所示。我们可以通过在[示例 2-13](#code-oop-sortable)中实现这些方法来对我们的自定义`Block`类型进行排序。添加通用意味着在许多情况下我们有[两种做一件事的方法](https://oreil.ly/dL8uE)。
- en: However, `interfaces` can be more troublesome for users of our code and slow
    at times due to [some runtime overhead](https://oreil.ly/8tSVf).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`接口`对我们代码的用户可能更为麻烦，并且有时由于[某些运行时开销](https://oreil.ly/8tSVf)而变慢。
- en: Overhead
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 开销（Overhead）
- en: 'Implementing generics can have many negative consequences for the language.
    Depending on the implementation, it can impact different things. For example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实现通用可能会对语言产生许多负面影响。根据实现方式，它可能会影响不同的事物。例如：
- en: We can just skip implementing them like in C, which slows programmers.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以像在C中那样简单跳过它们，这会减慢程序员的速度。
- en: We can use [monomorphization](https://oreil.ly/B062N), which essentially copies
    the code for each type that will be used. This impacts compile time and binary
    size.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用[单态化](https://oreil.ly/B062N)，这实质上是为每种将被使用的类型复制代码。这会影响编译时间和二进制文件大小。
- en: We can use boxing like in Java, which is quite similar to the Go interface implementation.
    In this case, we impact execution time or memory usage.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以像在Java中那样使用装箱，这与Go接口的实现非常相似。在这种情况下，我们可能会影响执行时间或内存使用。
- en: 'The generic dilemma is this: do you want slow programmers, slow compilers and
    bloated binaries, or slow execution times?'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通用困境就在于：你想要缓慢的程序员、缓慢的编译器和臃肿的二进制文件，还是缓慢的执行时间？
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Russ Cox, [“The Generic Dilemma”](https://oreil.ly/WjjV4)
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Russ Cox, [“通用困境”](https://oreil.ly/WjjV4)
- en: After many proposals and debates, the final (extremely detailed!) [design](https://oreil.ly/k9cCR)
    was accepted. Initially, I was very skeptical, but the accepted generic use turned
    out to be clear and reasonable. So far, the community also didn’t jump ahead and
    abuse these mechanics as was feared. We tend to see generics used very rarely—only
    when needed, as it makes the code more complex to maintain.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多提案和辩论之后，最终（非常详细！）[设计](https://oreil.ly/k9cCR)得到了接受。最初，我非常怀疑，但接受的泛型使用结果清晰而合理。到目前为止，社区也没有像担心的那样跳过并滥用这些机制。我们倾向于很少看到泛型的使用——只有在需要时，因为这使得代码更复杂以维护。
- en: For example, we could write a generic sort for all basic types like `int`, `float64`,
    or even `strings`, as presented in [Example 2-14](#code-generics).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为所有基本类型（如`int`、`float64`或甚至`strings`）编写一个泛型排序，如[示例 2-14](#code-generics)中所示。
- en: Example 2-14\. Example implementation of the generic sort for basic types
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14\. 基本类型的泛型排序示例实现
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO11-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO11-1)'
- en: Thanks to generics (also called type parameters), we can implement a single
    type that will implement `sort.Interface` (see [Example 2-13](#code-oop-sortable))
    for all basic types. We can provide custom constraints that look mostly like interfaces
    to limit the types that can be used as a type parameter. Here we use a type that
    represents `Integer | Float | ~string` constraints, so any type that supports
    comparison operators. We can put any other interface, like `any` to match all
    types. We can also use a special `comparable` keyword that will allow us to use
    the object of `T comparable` as a `map` key.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了泛型（也称为类型参数），我们可以实现一个单一类型，该类型将为所有基本类型实现`sort.Interface`（参见[示例 2-13](#code-oop-sortable)）。我们可以提供类似接口的自定义约束，以限制可以用作类型参数的类型。在这里，我们使用表示`Integer
    | Float | ~string`约束的类型，因此任何支持比较操作符的类型都可以使用。我们可以放置任何其他接口，例如`any`来匹配所有类型。我们还可以使用特殊的`comparable`关键字，允许我们将`T
    comparable`对象用作`map`键。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO11-3)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO11-3)'
- en: Any element of `s` slice is now expected to be of type `T` with `Ordered` constraints,
    so the compiler will allow us to compare them for `Less` functionality.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在预期`s`切片的任何元素都是带有`Ordered`约束的`T`类型，因此编译器将允许我们为它们比较`Less`功能。
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO11-4)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO11-4)'
- en: We can now implement a sort function for any basic type that will leverage `sort.Sort`
    implementation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为任何基本类型实现一个排序函数，该函数将利用`sort.Sort`的实现。
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO11-5)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO11-5)'
- en: We don’t need to implement type-specific functions like `sort.Ints`. We can
    do `genericSortBasic[<type>]([]<type>)` as long as the slice is of the types that
    can be ordered!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要像`sort.Ints`那样实现特定于类型的函数。只要切片是可以排序的类型，我们就可以执行`genericSortBasic[<type>]([]<type>)`！
- en: This is great, but it only works for basic types. Unfortunately, we cannot override
    operators like `<` in Go (yet), so to implement generic sort for more complex
    types, we have to do a bit more work. For example, we could design our sort to
    expect each type to implement the `func <typeA> Compare(<typeA>) int` method.^([19](ch02.html#idm45606837116448))
    If we add this method to the `Block` in [Example 2-11](#code-oop), we can sort
    it easily, as presented in [Example 2-15](#code-generics2).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但它只适用于基本类型。不幸的是，在Go语言中我们不能（还）重写像`<`这样的操作符，因此为了实现更复杂类型的泛型排序，我们必须做更多的工作。例如，我们可以设计我们的排序以期望每种类型实现`func
    <typeA> Compare(<typeA>) int`方法。^([19](ch02.html#idm45606837116448)) 如果我们在[示例 2-11](#code-oop)的`Block`中添加此方法，我们就可以轻松地对其进行排序，如[示例 2-15](#code-generics2)中所示。
- en: Example 2-15\. Example implementation of the generic sort for certain types
    of objects
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-15\. 某些对象的泛型排序示例实现
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO12-1)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO12-1)'
- en: Let’s design our constraint. We expect every type to have a `Compare` method
    that accepts the same type. Because constraints and interfaces can also have type
    parameters, we can implement such requirements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计我们的约束。我们期望每种类型都有一个接受相同类型的`Compare`方法。因为约束和接口也可以有类型参数，我们可以实现这样的要求。
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO12-2)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO12-2)'
- en: We can now provide a type that implements a `sort.Interface` interface for such
    kinds of objects. Notice the nested `T` in `Comparable[T]`, as our interface also
    is generic!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为这种类型的对象提供一个实现`sort.Interface`接口的类型。请注意`Comparable[T]`中的嵌套`T`，因为我们的接口也是泛型的！
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO12-4)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO12-4)'
- en: Now we can implement `Compare` for our `Block` type.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的`Block`类型实现`Compare`方法。
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO12-5)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO12-5)'
- en: Thanks to this, we don’t need to implement a `sortable` type for every custom
    type we want to sort. As long as the type has the `Compare` method, we can use
    `genericSort`!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，我们无需为每种想要排序的自定义类型实现`sortable`类型。只要类型有`Compare`方法，我们就可以使用`genericSort`！
- en: The accepted design shows advantages in cases where the user interface alone
    would be cumbersome. But what about the generics dilemma problem? The design allows
    any [implementation](https://oreil.ly/rZBtz), so what trade-off was chosen at
    the end? We won’t go into the details in this book, but Go uses the [dictionaries
    and stenciling](https://oreil.ly/poLls) algorithm, which is between monomorphization
    and boxing.^([20](ch02.html#idm45606836849296))
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接受的设计在用户界面独立操作复杂的情况下显示出明显优势。但是对于泛型困境问题呢？设计允许任何[实现](https://oreil.ly/rZBtz)，那么最终选择了什么权衡？在本书中我们不会深入讨论细节，但Go语言使用了[字典和模板化](https://oreil.ly/poLls)算法，介于单态化和装箱之间。^([20](ch02.html#idm45606836849296))
- en: Generic Code Will Be Faster?
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型代码会更快吗？
- en: The specific implementation of generics in Go (which can change over time) means
    that the generic implementation, in theory, should be faster than interfaces but
    slower than implementing certain functionality for a specific type by hand. In
    practice, however, the potential difference is, in most cases, negligible, so
    use the most readable and easy-to-maintain option first.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中泛型的具体实现（这可能会随时间变化）意味着泛型实现理论上应该比接口更快，但比手动为特定类型实现某些功能更慢。然而，在实践中，这种潜在差异在大多数情况下可以忽略不计，因此首先使用最可读和易于维护的选项。
- en: In my experience, the difference might matter in the efficiency-critical code,
    but the results do not always follow the theory. For example, sometimes [generic
    implementation is faster](https://oreil.ly/9cEIb), and sometimes [using interfaces
    might be more efficient](https://oreil.ly/tiOhS). Conclusion? Always perform benchmarks
    ([Chapter 8](ch08.html#ch-benchmarking)) to be sure!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，在效率关键的代码中，这种差异可能很重要，但结果并不总是符合理论。例如，有时[泛型实现更快](https://oreil.ly/9cEIb)，有时使用接口可能更有效](https://oreil.ly/tiOhS)。结论？始终执行基准测试（[第8章](ch08.html#ch-benchmarking)）以确保！
- en: To sum up, these facts are what I found crucial when teaching others programming
    in Go, based on my own experience with the language. Moreover, it will be helpful
    when diving deeper into the runtime performance of Go later in this book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这些事实是我在教授他人如何使用Go编程时认为至关重要的事实，这些都基于我个人对该语言的经验。此外，当在本书的后续部分深入研究Go语言运行时性能时，这些将会非常有帮助。
- en: However, if you have never programmed in Go before, it’s worth going through
    other materials like the [tour of Go](https://oreil.ly/J3HE3) before jumping to
    the subsequent sections and chapters of this book. Make sure you try writing your
    own basic Go program, write a unit test, and use loops, switches, and concurrency
    mechanisms like channels and routines. Learn common types and standard library
    abstraction. As a person coming to a new language, you need to produce a program
    returning valid results before ensuring that it executes quickly and efficiently.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您以前从未编写过Go程序，最好在进入本书的后续部分和章节之前查看其他材料，例如[Go语言之旅](https://oreil.ly/J3HE3)。确保尝试编写自己的基本Go程序，编写单元测试，并使用循环，开关以及通道和协程等并发机制。学习常见类型和标准库抽象。作为接触新语言的人，您需要在确保程序返回有效结果之前，确保其执行快速和高效。
- en: We learned about some basic and advanced characteristics of Go, so it’s time
    to unwrap the efficiency aspects of the language. How easy is it to write good
    enough or high-performance code in Go?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了Go语言的一些基本和高级特性，现在是时候揭开语言的效率方面了。在Go语言中编写足够好或高性能的代码有多容易呢？
- en: Is Go “Fast”?
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言是“快速”的吗？
- en: Recently, many companies have rewritten their products (e.g., from Ruby, Python,
    and Java) to Go.^([21](ch02.html#idm45606836733504)) Two repeatedly stated reasons
    for moving to Go or starting a new project in Go were readability and excellent
    performance. Readability comes from simplicity and consistency (e.g., single way
    of error handling as you remember from [“Single Way of Handling Errors”](#ch-go-errs)),
    and it’s where Go excels, but what about performance? Is Go fast compared to other
    languages like Python, Java, or C++?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，许多公司已经将他们的产品（例如从Ruby、Python和Java）重写为Go。^([21](ch02.html#idm45606836733504))
    转向Go或者在Go中启动新项目的两个重要原因是可读性和出色的性能。可读性来源于简单和一致性（例如，你还记得从[“处理错误的单一方式”](#ch-go-errs)），这也是Go的优势所在，但是性能如何呢？与Python、Java或C++等其他语言相比，Go有多快呢？
- en: In my opinion, this question is badly formed. Given time and room for complexities,
    any language can be as fast as your machine and operating system allow. That’s
    because, in the end, the code we write is compiled into machine code that uses
    the exact CPU instructions. Also, most languages allow delegating execution to
    other processes, e.g., written in optimized Assembly. Unfortunately, sometimes
    all we use to decide if a language is “fast” are raw, semi-optimized short program
    benchmarks that compare execution time and memory usage across languages. While
    it tells us something, it effectively does not show practical aspects, e.g., how
    complex the programming for efficiency was.^([22](ch02.html#idm45606836729648))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这个问题本质上是不恰当的。在时间和复杂性允许的情况下，任何语言都可以与您的计算机和操作系统允许的一样快。这是因为，最终，我们编写的代码会被编译成使用精确CPU指令的机器代码。此外，大多数语言允许将执行委托给其他进程，例如，使用优化的汇编语言编写。不幸的是，有时我们仅仅依靠原始的、半优化的短程序基准测试来判断一种语言是否“快”，而这些测试仅仅告诉了我们一些东西，但实际上并未显示出实际的方面，例如，编写高效率的编程有多复杂。^([22](ch02.html#idm45606836729648))
- en: Instead, we should look at a programming language in terms of how hard and practical
    it is to write efficient code (not just fast), and how much readability and reliability
    such a process sacrifices. I believe the Go language has a superior balance between
    those elements while keeping it fast and trivial to write basic, functional code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该从编写高效代码（而不仅仅是快速代码）的难度和实用性以及这一过程牺牲了多少可读性和可靠性的角度来看待一种编程语言。我认为Go语言在这些元素之间保持了优越的平衡，同时保持了快速和编写基本、功能性代码的简易性。
- en: 'One of the reasons for being able to write efficient code more easily is the
    hermetic compilation stage, the relatively small amount of unknowns in the Go
    runtime (see [“Go Runtime”](#ch-go-runtime)), the easy-to-use concurrency framework,
    and the maturity of the debugging, benchmarking, and profiling tools (discussed
    in Chapters [8](ch08.html#ch-benchmarking) and [9](ch09.html#ch-observability3)).
    Those Go characteristics did not appear from thin air. Not many know, but Go was
    designed on the shoulders of giants: C, Pascal, and CSP.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更容易编写高效代码的一个原因是封闭的编译阶段、Go运行时中相对较少的未知因素（参见[“Go运行时”](#ch-go-runtime)）、易于使用的并发框架以及调试、基准测试和性能分析工具的成熟性（在第[8](ch08.html#ch-benchmarking)章和第[9](ch09.html#ch-observability3)章讨论）。这些Go的特性并非凭空出现。不多的人知道，Go是站在巨人的肩膀上设计出来的：C、Pascal和CSP。
- en: In 1960, language experts from America and Europe teamed up to create Algol
    60\. In 1970, the Algol tree split into the C and the Pascal branch. ~40 years
    later, the two branches join again in Go.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1960年，来自美国和欧洲的语言专家联手创建了Algol 60。1970年，Algol树分裂成了C和Pascal分支。大约40年后，这两个分支在Go中再次合二为一。
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robert Griesemer, [“The Evolution of Go”](https://oreil.ly/a4V1e)
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 罗伯特·格里塞默，《Go的演变》(The Evolution of Go)，[https://oreil.ly/a4V1e](https://oreil.ly/a4V1e)
- en: As we can see in [Figure 2-2](#img-go-roots), many of the names mentioned in
    [Chapter 1](ch01.html#ch-efficiency-matters) are grandfathers of Go. The great
    concurrency language CSP created by Sir Hoare, Pascal declarations and packages
    created by Wirth, and C basic syntax all contributed to how Go looks today.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[图2-2](#img-go-roots)中看到的那样，许多在[第1章](ch01.html#ch-efficiency-matters)中提到的名字都是Go的奠基人。由霍尔爵士创造的伟大并发语言CSP，由沃思创造的Pascal声明和包以及C基本语法，所有这些都对Go今天的面貌产生了影响。
- en: '![efgo 0202](assets/efgo_0202.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0202](assets/efgo_0202.png)'
- en: Figure 2-2\. Go genealogy
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2. Go的系谱
- en: But not everything can be perfect. In terms of efficiency, Go has its own Achilles’
    heel. As you will learn in [“Go Memory Management”](ch05.html#ch-hw-go-mem), memory
    usage can sometimes be hard to control. Allocations in our program can be surprising
    (especially for new users), and the garbage collections automatic memory release
    process has some overhead and eventual behavior. Especially for data-intensive
    applications, it takes effort to ensure memory or CPU efficiency, similar to machines
    with strictly limited RAM capacities (e.g., IoT).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非一切都能完美无缺。在效率方面，Go 也有其自身的软肋。正如您将在[“Go 内存管理”](ch05.html#ch-hw-go-mem)中了解的那样，内存使用有时可能难以控制。在我们的程序中，分配可能会令人惊讶（特别是对于新用户），而垃圾收集的自动内存释放过程也有一些开销和最终行为。特别是对于数据密集型应用程序，确保内存或
    CPU 效率需要付出努力，类似于严格限制 RAM 容量的机器（例如 IoT）。
- en: Yet the decision to automate this process is highly beneficial, allowing the
    programmer to not worry about memory cleanup, which has proven to be even worse
    and sometimes catastrophic (e.g., deallocating memory twice). An excellent example
    of alternative mechanisms that other languages use is Rust. It implements a unique
    memory ownership model that replaces automatic global garbage collection. Unfortunately,
    while more efficient, it turns out that writing code in Rust is much more complicated
    than in Go. That’s why we see higher adoption of Go. This reflects the Go team’s
    ease-of-use trade-off in this element.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动化此过程的决定非常有利，使程序员无需担心内存清理，这已被证明甚至更糟糕，有时甚至是灾难性的（例如，释放内存两次）。其他语言使用的替代机制的绝佳例子是
    Rust。它实现了一种独特的内存所有权模型，替代了自动全局垃圾回收。不幸的是，尽管更高效，但编写 Rust 代码比 Go 更加复杂。这就是为什么我们看到 Go
    的更高采用率。这反映了 Go 团队在这一元素上易用性的权衡。
- en: Fortunately, there are ways to mitigate the negative performance consequences
    of the garbage collection mechanism in Go and keep our software lean and efficient.
    We will go through those in the following chapters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有办法减轻 Go 中垃圾回收机制的负面性能影响，并保持我们的软件精简和高效。我们将在接下来的章节中讨论这些内容。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In my opinion, Go is an incredibly elegant and consistent language. Moreover,
    it offers many modern and innovative features that make programming more effective
    and reliable. Plus, the code is readable and maintainable by design.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Go 是一种非常优雅和一致的语言。此外，它提供了许多现代和创新的特性，使编程更加高效和可靠。而且，代码本身设计上就具有可读性和可维护性。
- en: This is a critical foundation for the efficiency improvements we will discuss
    later in this book. Like any other feature, optimizations always add complexity,
    so it’s easier to modify simple code than to complicate already complex code.
    Simplicity, safety, and readability are paramount, even for efficient code. Make
    sure you know how to achieve that without thinking about efficiency first!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们稍后将讨论的效率改进的关键基础。像任何其他功能一样，优化总是增加复杂性，因此修改简单代码比复杂化已经复杂的代码更容易。简单性、安全性和可读性至关重要，即使对于高效的代码也是如此。确保您知道如何在不考虑效率的情况下实现这一点！
- en: 'Many resources go into more details for elements I could spend only a subchapter
    on. If you are interested to learn more, there is nothing better than practice.
    If you need more experience with Go before we jump into optimizations, here is
    a short list of excellent resources:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 许多资源详细介绍了我只能用一个子章节来介绍的元素。如果您有兴趣了解更多信息，没有比实践更好的了。如果您在进入优化之前需要更多的 Go 经验，这里有一个优秀资源的简短列表：
- en: '[“Effective Go”](https://oreil.ly/9auky)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“有效的 Go”](https://oreil.ly/9auky)'
- en: '[“How to Write Go Code”](https://oreil.ly/uS51g)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“如何编写 Go 代码”](https://oreil.ly/uS51g)'
- en: '[“A Tour of Go”](https://oreil.ly/LpGBN)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Go 之旅”](https://oreil.ly/LpGBN)'
- en: '[“Practical Go Lessons”](https://oreil.ly/VnFms) by Maximilien Andile, available
    for free in the digital version'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“实用的 Go 课程”](https://oreil.ly/VnFms)由 Maximilien Andile 撰写，数字版免费提供。'
- en: Contributing to any open source project in Go, for example, through the [CNCF
    mentoring initiatives](https://oreil.ly/Y3D2Q) we offer four or more times a year
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，通过我们每年四次或更多次提供的[CNCF指导计划](https://oreil.ly/Y3D2Q)，参与到任何 Go 开源项目中
- en: The true power of the Go optimizations, benchmarking, and efficiency practices
    comes when used in practice, in everyday programming. Therefore, I want to empower
    you to marry efficiency with other good techniques around reliability or abstractions
    for practical use. While fully tailored logic sometimes has to be built for a
    critical path (as you will see in [Chapter 10](ch10.html#ch-opt)), the basic,
    often good enough, efficiency comes from understanding simple rules and language
    capabilities. That’s why I focused on giving you a better overview of Go and its
    features in this chapter. With this knowledge, we can now move to [Chapter 3](ch03.html#ch-efficiency),
    where we will learn how to start the journey to improve the efficiency and overall
    performance of our program’s execution when we need to.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Go的优化、基准测试和效率实践的真正力量，是在实际应用中发挥作用，即在日常编程中。因此，我希望能够让你将效率与可靠性或者实用抽象等其他良好技术结合起来。尽管有时候对于关键路径可能需要完全定制的逻辑（如你将在[第10章](ch10.html#ch-opt)中看到的），但基本的、通常足够的效率来自于理解简单规则和语言能力。这就是为什么我在本章节专注于为你提供关于Go及其特性的更好概述。有了这些知识，我们现在可以继续到[第3章](ch03.html#ch-efficiency)，在那里我们将学习如何开始提高程序执行时的效率和整体性能。
- en: ^([1](ch02.html#idm45606843247856-marker)) New frameworks on tools for writing
    Go on small devices are emerging, e.g., [GoBot](https://gobot.io) and [TinyGo](https://tinygo.org).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45606843247856-marker)) 新的用于在小设备上编写Go的框架和工具正在涌现，例如[GoBot](https://gobot.io)和[TinyGo](https://tinygo.org)。
- en: ^([2](ch02.html#idm45606843245632-marker)) It’s a controversial topic. There
    is quite a battle in the infrastructure industry for the superior language for
    configuration as code. For example, among HCL, Terraform, Go templates (Helm),
    Jsonnet, Starlark, and Cue. In 2018, we even open sourced a tool for writing configuration
    in Go, called [“mimic”](https://oreil.ly/FNjYD). Arguably, the loudest arguments
    against writing configuration in Go are that it feels too much like “programming”
    and requires programming skills from system administrators.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm45606843245632-marker)) 这是一个颇具争议的话题。在基础设施行业中，关于配置即代码的最佳语言存在激烈的竞争。例如，在HCL、Terraform、Go模板（Helm）、Jsonnet、Starlark和Cue之间。2018年，我们甚至开源了一个名为[“mimic”](https://oreil.ly/FNjYD)的工具，用于在Go语言中编写配置。可以说，反对在Go中编写配置的最大声音是它感觉太像“编程”，需要系统管理员的编程技能。
- en: ^([3](ch02.html#idm45606843243616-marker)) WebAssembly is meant to change this,
    though, but [not soon](https://oreil.ly/rZqtp).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm45606843243616-marker)) WebAssembly的意图是改变这一切，不过[不会很快](https://oreil.ly/rZqtp)。
- en: ^([4](ch02.html#idm45606843188400-marker)) CSP is a formal language that allows
    describing interactions in concurrent systems. Introduced by C.A.R. Hoare in *Communications
    of the ACM* (1978), it was an inspiration for the Go language concurrency system.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm45606843188400-marker)) CSP 是一种形式语言，允许描述并发系统中的交互。由C.A.R.
    Hoare在《ACM通讯》（1978年）中引入，它是Go语言并发系统的灵感来源。
- en: ^([5](ch02.html#idm45606843146464-marker)) Similar frustrations triggered another
    part of Google to create yet another language—[Carbon](https://oreil.ly/ijFPA)
    in 2022\. Carbon looks very promising, but it has different goals than Go. It
    is, by design, more efficiency aware and focused on familiarity with C++ concepts
    and interoperability. So let’s see how adoption will catch up for Carbon!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm45606843146464-marker)) 类似的挫折促使Google的另一部分创建了另一种语言——[Carbon](https://oreil.ly/ijFPA)，于2022年发布。Carbon看起来非常有前景，但它的目标与Go不同。它更注重效率和与C++概念的熟悉度及互操作性。所以让我们看看Carbon的采用情况将如何发展！
- en: ^([6](ch02.html#idm45606843127920-marker)) One notable example is [the controversy
    behind dependency management work](https://oreil.ly/3gB9m).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#idm45606843127920-marker)) 一个著名的例子是[依赖管理工作背后的争议](https://oreil.ly/3gB9m)。
- en: ^([7](ch02.html#idm45606843118368-marker)) Of course, there are some inconsistencies
    here and there; that’s why the community created more [strict formatters](https://oreil.ly/RKUme),
    [linters](https://oreil.ly/VnQSC), or [style guides](https://oreil.ly/ETWSq).
    Yet the standard tools are good enough to feel comfortable in every Go codebase.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#idm45606843118368-marker)) 当然，偶尔会有一些不一致之处；这就是为什么社区创建了更多[严格的格式化程序](https://oreil.ly/RKUme)，[代码检查工具](https://oreil.ly/VnQSC)，或者[风格指南](https://oreil.ly/ETWSq)。然而，标准工具已经足够让你在每个Go代码库中感到舒适。
- en: '^([8](ch02.html#idm45606843101632-marker)) There is one exception: unit test
    files that have to end with *_test.go*. These files can have either the same package
    name or the `<package_name>_test` name allowing to mimic external users of the
    package.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#idm45606843101632-marker)) 有一个例外：单元测试文件必须以 *_test.go* 结尾。这些文件可以具有相同的包名或
    `<package_name>_test` 名称，允许模仿包的外部用户。
- en: ^([9](ch02.html#idm45606842831664-marker)) In practice, you can quickly obtain
    the C++ or Go code (even when obfuscated) from the compiled binary anyway, especially
    if you don’t strip the binary from the debugging symbols.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.html#idm45606842831664-marker)) 在实践中，您可以从编译后的二进制文件快速获取 C++ 或 Go 代码（即使混淆了），特别是如果您没有从调试符号中剥离二进制文件。
- en: ^([10](ch02.html#idm45606842772304-marker)) Standard library means packages
    that are shipped together with the Go language tooling and runtime code. Usually,
    only mature and core functionalities are provided, as Go has strong compatibility
    guarantees. Go also maintains an experimental [`golang.org/x/exp`](https://oreil.ly/KBTwn)
    module that contains useful code that must be proven to graduate to the standard
    library.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.html#idm45606842772304-marker)) 标准库意味着与 Go 语言工具和运行时代码一起提供的包。通常只提供成熟和核心功能，因为
    Go 有强大的兼容性保证。Go 还维护着一个实验性的 [`golang.org/x/exp`](https://oreil.ly/KBTwn) 模块，其中包含必须证明能够毕业进入标准库的有用代码。
- en: ^([11](ch02.html#idm45606842681408-marker)) While Go is improving every day,
    sometimes you can add more advanced tools like [`goimports`](https://oreil.ly/pS9MI)
    or [`bingo`](https://oreil.ly/mkjO2) to improve the development experience further.
    In some areas, Go can’t be opinionated and is limited by stability guarantees.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.html#idm45606842681408-marker)) 虽然 Go 每天都在改进，有时您可以添加更高级的工具如 [`goimports`](https://oreil.ly/pS9MI)
    或 [`bingo`](https://oreil.ly/mkjO2) 来进一步改善开发体验。在某些领域，Go 不能提出具体意见，而是受到稳定性保证的限制。
- en: '^([12](ch02.html#idm45606842674272-marker)) [The CAP Theorem](https://oreil.ly/HyBdB)
    mentions an excellent example of treating failures seriously. It states that you
    can only choose two from three system characteristics: consistency, availability,
    and partition. As soon as you distribute your system, you must deal with network
    partition (communication failure). As an error-handling mechanism, you can either
    design your system to wait (lose availability) or operate on partial data (lose
    consistency).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch02.html#idm45606842674272-marker)) [CAP 定理](https://oreil.ly/HyBdB)
    提到了一个优秀的例子，严肃地对待失败。它指出，在三个系统特性（一致性、可用性和分区容错性）中，你只能选择两个。一旦你分布你的系统，你必须处理网络分区（通信失败）。作为一个错误处理机制，你可以设计你的系统等待（失去可用性）或者操作部分数据（失去一致性）。
- en: ^([13](ch02.html#idm45606842670048-marker)) [`bash` has many methods for error
    handling](https://oreil.ly/Tij9n), but the default one is implicit. The programmer
    can optionally print or check `${?}` that holds the exit code of the last command
    executed before any given line. An exit code of 0 means the command is executed
    without any issues.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch02.html#idm45606842670048-marker)) [`bash` 有许多处理错误的方法](https://oreil.ly/Tij9n)，但默认方法是隐式的。程序员可以选择打印或检查
    `${?}`，它保存了在给定行之前执行的最后一个命令的退出代码。退出代码为0表示命令执行没有任何问题。
- en: ^([14](ch02.html#idm45606842664160-marker)) In principle, a monad is an object
    that holds some value optionally, for example, some object `Option<Type>` with
    methods `Get()` and `IsEmpty()`. Furthermore, an “error monad” is an `Option`
    object that holds an error if the value is not set (sometimes referred to as `Result<Type>`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch02.html#idm45606842664160-marker)) 原则上，一个单子（monad）是一个可选地持有某些值的对象，例如一些带有
    `Get()` 和 `IsEmpty()` 方法的对象 `Option<Type>`。此外，“错误单子”是一个 `Option` 对象，如果值未设置，则持有一个错误（有时称为
    `Result<Type>`）。
- en: ^([15](ch02.html#idm45606839042576-marker)) Such code is not recommended for
    production, but the only things that would need to change are avoiding using global
    variables and checking all errors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch02.html#idm45606839042576-marker)) 这样的代码不建议用于生产，但唯一需要改变的是避免使用全局变量和检查所有错误。
- en: ^([16](ch02.html#idm45606838437664-marker)) This assertion pattern is also typical
    in other third-party libraries like the popular [`testify` package](https://oreil.ly/I47fD).
    However, I am not a fan of the `testify` package, because there are too many ways
    of doing the same thing.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch02.html#idm45606838437664-marker)) 这种断言模式在其他第三方库中也很典型，如流行的 [`testify`
    包](https://oreil.ly/I47fD)。但是，我不喜欢 `testify` 包，因为有太多做同一件事情的方式。
- en: ^([17](ch02.html#idm45606838184304-marker)) Since programs, e.g., in Java, compile
    to Java bytecode, many things happen before the code is translated to actual machine-understandable
    code. The complexity of this process is too great to be understood by a mere mortal,
    so [machine learning “AI” tools were created](https://oreil.ly/baNvh) to auto-tune
    JVM.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch02.html#idm45606838184304-marker)) 由于程序（例如Java）编译成Java字节码，许多事情发生在代码被翻译成实际可理解的机器代码之前。这个过程的复杂性对于一个普通人来说太大，因此[机器学习“AI”工具被创建](https://oreil.ly/baNvh)用于自动调整JVM。
- en: ^([18](ch02.html#idm45606838174512-marker)) [A survey in 2020](https://oreil.ly/WrtCH)
    shows that among the top 10 used programming languages, 2 mandates object-oriented
    programming (Java, C#), 6 encourage it, and 2 do not implement OOP. I personally
    almost always favor object-oriented programming for algorithms that have to hold
    some context larger than three variables between data structures or functions.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch02.html#idm45606838174512-marker)) [2020年的一项调查](https://oreil.ly/WrtCH)显示，在使用最多的前10种编程语言中，有2种要求面向对象编程（Java，C#），6种鼓励它，而有2种则不实现OOP。对于那些必须在数据结构或函数之间保持某些较大上下文的算法，我个人几乎总是偏爱面向对象编程。
- en: ^([19](ch02.html#idm45606837116448-marker)) I prefer [functions to methods](https://oreil.ly/Et9CE),
    as they’re easier to use in most cases.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch02.html#idm45606837116448-marker)) 我更喜欢[函数胜过方法](https://oreil.ly/Et9CE)，因为它们在大多数情况下更容易使用。
- en: ^([20](ch02.html#idm45606836849296-marker)) The summary was well explained on
    the [*PlanetScale* blog post](https://oreil.ly/ksqO0).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch02.html#idm45606836849296-marker)) 在[*PlanetScale*博客文章](https://oreil.ly/ksqO0)中，总结得非常清楚。
- en: ^([21](ch02.html#idm45606836733504-marker)) To name a few public changes, we’ve
    seen the [Salesforce case](https://oreil.ly/H3WsC), [AppsFlyer](https://oreil.ly/iazde),
    and [Stream](https://oreil.ly/NSJLD).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch02.html#idm45606836733504-marker)) 举几个公共变更的例子，我们看到了[Salesforce案例](https://oreil.ly/H3WsC)，[AppsFlyer](https://oreil.ly/iazde)，和[Stream](https://oreil.ly/NSJLD)。
- en: ^([22](ch02.html#idm45606836729648-marker)) For example, when we look at some
    [benchmarks](https://oreil.ly/s7qTj), we see Go as sometimes faster, sometimes
    slower than Java. Yet if we look at CPU loads, every time Go or Java is faster,
    it’s simply faster because, for example, the implementation allowed fewer CPU
    cycles to be wasted on memory access. You can achieve that in any programming
    language. The question is, how hard was it to achieve this? We don’t usually measure
    how much time we spend to optimize code in each particular language, how easy
    it is to read or extend such code after optimizations, etc. Only those metrics
    might tell us which programming language is “faster.”
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch02.html#idm45606836729648-marker)) 例如，当我们查看一些[基准测试](https://oreil.ly/s7qTj)时，我们发现Go有时比Java更快，有时比Java更慢。然而，如果我们查看CPU负载，每次Go或Java更快时，它只是因为例如实现允许减少了在内存访问上浪费的CPU周期。你可以在任何编程语言中实现这一点。问题在于，实现这一点有多难？我们通常不测量在每种特定语言中优化代码所花费的时间，以及在优化后阅读或扩展这样的代码有多容易等。只有这些指标可能告诉我们哪种编程语言更“快速”。
