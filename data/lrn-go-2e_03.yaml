- en: Chapter 3\. Composite Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章\. 复合类型
- en: 'In the previous chapter, you looked at literals and predeclared variable types:
    numbers, booleans, and strings. In this chapter, you’ll learn about the composite
    types in Go, the built-in functions that support them, and the best practices
    for working with them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经了解了字面量和预声明变量类型：数字、布尔值和字符串。在本章中，你将了解 Go 中的复合类型、支持它们的内置函数以及与它们一起工作的最佳实践。
- en: Arrays—Too Rigid to Use Directly
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组——过于严格，无法直接使用
- en: Like most programming languages, Go has arrays. However, arrays are rarely used
    directly in Go. You’ll learn why in a bit, but first let’s quickly cover array
    declaration syntax and use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数编程语言一样，Go 也有数组。然而，在 Go 中很少直接使用数组。稍后你将了解原因，但首先让我们快速了解数组声明语法和使用。
- en: 'All elements in the array must be of the type that’s specified. There are a
    few declaration styles. In the first, you specify the size of the array and the
    type of the elements in the array:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的所有元素必须是指定的类型。有几种声明样式。在第一种样式中，你指定数组的大小和数组元素的类型：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates an array of three `int`s. Since no values were specified, all
    of the elements (`x[0]`, `x[1]`, and `x[2]`) are initialized to the zero value
    for an `int`, which is (of course) 0\. If you have initial values for the array,
    you specify them with an *array literal*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含三个 `int` 类型元素的数组。因为没有指定初始值，所有元素（`x[0]`、`x[1]` 和 `x[2]`）都会初始化为 `int`
    类型的零值，当然是 0。如果数组有初始值，可以使用*数组字面量*指定它们：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have a *sparse array* (an array where most elements are set to their
    zero value), you can specify only the indices with nonzero values in the array
    literal:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个*稀疏数组*（大部分元素设置为零值的数组），你可以在数组字面量中仅指定非零值的索引：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates an array of 12 `int`s with the following values: [1, 0, 0, 0,
    0, 4, 6, 0, 0, 0, 100, 15].'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下值的 12 个 `int` 类型数组：[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。
- en: 'When using an array literal to initialize an array, you can replace the number
    that specifies the number of elements in the array with `...`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用数组字面量初始化数组时，可以用 `...` 替换指定数组中元素数量的数字：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can use `==` and `!=` to compare two arrays. Arrays are equal if they are
    the same length and contain equal values:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `==` 和 `!=` 来比较两个数组。如果它们长度相同并且包含相等的值，则它们相等：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Go has only one-dimensional arrays, but you can simulate multidimensional arrays:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 只有一维数组，但你可以模拟多维数组：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This declares `x` to be an array of length 2 whose type is an array of `int`s
    of length 3\. This sounds pedantic, but some languages have true matrix support,
    like Fortran or Julia; Go isn’t one of them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了 `x` 为长度为 2 的数组，其类型是长度为 3 的 `int` 数组。这听起来有些迂腐，但有些语言有真正的矩阵支持，比如 Fortran 或
    Julia；而 Go 不是其中之一。
- en: 'Like most languages, arrays in Go are read and written using bracket syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数语言一样，Go 中的数组是通过方括号语法进行读写的：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You cannot read or write past the end of an array or use a negative index. If
    you do this with a constant or literal index, it is a compile-time error. An out-of-bounds
    read or write with a variable index compiles but fails at runtime with a *panic*
    (you’ll learn more about panics in [“panic and recover”](ch09.html#panic_recover)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能读取或写入数组的末尾或使用负索引。如果你使用常量或字面量索引这样做，会导致编译时错误。使用变量索引进行越界读取或写入会在运行时编译，但会失败并产生*panic*（你将在[“panic
    and recover”](ch09.html#panic_recover)中了解更多关于 panic 的信息）。
- en: 'Finally, the built-in function `len` takes in an array and returns its length:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内置函数 `len` 接受一个数组并返回其长度：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Earlier I said that arrays in Go are rarely used explicitly. This is because
    they come with an unusual limitation: Go considers the *size* of the array to
    be part of the *type* of the array. This makes an array that’s declared to be
    `[3]int` a different type from an array that’s declared to be `[4]int`. This also
    means that you cannot use a variable to specify the size of an array, because
    types must be resolved at compile time, not at runtime.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说过，在 Go 中很少显式使用数组。这是因为它们有一个不寻常的限制：Go 认为数组的*大小*是数组的*类型*的一部分。这意味着声明为 `[3]int`
    的数组与声明为 `[4]int` 的数组是不同的类型。这也意味着你不能使用变量指定数组的大小，因为类型必须在编译时而不是运行时解析。
- en: What’s more, *you can’t use a type conversion to directly convert arrays of
    different sizes to identical types*. Because you can’t convert arrays of different
    sizes into each other, you can’t write a function that works with arrays of any
    size and you can’t assign arrays of different sizes to the same variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*不能使用类型转换直接将不同大小的数组转换为相同类型*。因为不能将不同大小的数组相互转换，所以无法编写处理任何大小数组的函数，也无法将不同大小的数组分配给同一个变量。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll learn how arrays work behind the scenes when I discuss memory layout
    in [Chapter 6](ch06.html#unique_chapter_id_06).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我讨论内存布局时，您将了解数组在背后的工作原理，详见[第6章](ch06.html#unique_chapter_id_06)。
- en: Because of these restrictions, don’t use arrays unless you know the exact length
    you need ahead of time. For example, some of the cryptographic functions in the
    standard library return arrays because the sizes of checksums are defined as part
    of the algorithm. This is the exception, not the rule.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请不要在不提前知道所需长度的情况下使用数组。例如，标准库中的一些加密函数返回数组，因为校验和的大小是算法的一部分。这是例外而不是规则。
- en: 'This raises the question: why is such a limited feature in the language? The
    main reason arrays exist in Go is to provide the backing store for *slices*, which
    are one of the most useful features of Go.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：为什么语言中会有这样一种有限的功能？Go 中存在数组的主要原因是为*切片*提供后备存储，这是 Go 中最有用的功能之一。
- en: Slices
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Most of the time, when you want a data structure that holds a sequence of values,
    a slice is what you should use. What makes slices so useful is that you can grow
    slices as needed. This is because the length of a slice is *not* part of its type.
    This removes the biggest limitations of arrays and allows you to write a single
    function that processes slices of any size (I’ll cover function writing in [Chapter 5](ch05.html#unique_chapter_id_05)).
    After going over the basics of using slices in Go, I’ll cover the best ways to
    use them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当您需要一个保存数值序列的数据结构时，应该使用切片。切片如此有用的原因在于您可以根据需要扩展切片的长度。这是因为切片的长度*不是*其类型的一部分。这消除了数组的最大限制，并允许您编写处理任何大小切片的单个函数（我将在[第5章](ch05.html#unique_chapter_id_05)中讨论函数编写）。在介绍了在
    Go 中使用切片的基础知识后，我将讨论最佳使用方法。
- en: 'Working with slices looks a lot like working with arrays, but subtle differences
    exist. The first thing to notice is that you don’t specify the size of the slice
    when you declare it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片看起来很像使用数组，但存在细微差别。首先要注意的是，在声明时不需要指定切片的大小：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using `[...]` makes an array. Using `[]` makes a slice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[...]`创建数组。使用`[]`创建切片。
- en: 'This creates a slice of three `int`s using a *slice literal*. Just as with
    arrays, you can also specify only the indices with nonzero values in the slice
    literal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用*切片字面量*创建了三个`int`的切片。与数组一样，您还可以仅指定切片字面量中非零值的索引：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This creates a slice of 12 `int`s with the following values: [1, 0, 0, 0, 0,
    4, 6, 0, 0, 0, 100, 15].'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下值的12个`int`的切片：[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。
- en: 'You can simulate multidimensional slices and make a slice of slices:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以模拟多维切片并创建切片的切片：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You read and write slices using bracket syntax, and, just as with arrays, you
    can’t read or write past the end or use a negative index:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用括号语法读取和写入切片，与数组一样，您不能读取或写入超出末尾或使用负索引：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, slices have seemed identical to arrays. You start to see the differences
    between arrays and slices when you look at declaring slices without using a literal:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，切片看起来与数组相同。当您尝试声明不使用字面量的切片时，您开始看到数组和切片之间的区别：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This creates a slice of `int`s. Since no value is assigned, `x` is assigned
    the zero value for a slice, which is something you haven’t seen before: `nil`.
    I’ll talk more about `nil` in [Chapter 6](ch06.html#unique_chapter_id_06), but
    it is slightly different from the `null` that’s found in other languages. In Go,
    `nil` is an identifier that represents the lack of a value for some types. Like
    the untyped numeric constants you saw in the previous chapter, `nil` has no type,
    so it can be assigned or compared against values of different types. A `nil` slice
    contains nothing.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`int`切片。由于未分配任何值，`x`被分配了切片的零值，这是您之前未见过的：`nil`。我将在[第6章](ch06.html#unique_chapter_id_06)中更多地讨论`nil`，但它与其他语言中的`null`略有不同。在
    Go 中，`nil`是一个表示某些类型缺少值的标识符。与前一章中看到的无类型数值常量一样，`nil`没有类型，因此可以将其赋值或与不同类型的值进行比较。`nil`切片不包含任何内容。
- en: 'A slice is the first type you’ve seen that isn’t *comparable*. It is a compile-time
    error to use `==` to see if two slices are identical or `!=` to see if they are
    different. The only thing you can compare a slice with using `==` is `nil`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是你见过的第一个不可*比较*的类型。使用`==`来比较两个切片是否相同或者使用`!=`来比较它们是否不同是编译时错误。你只能将一个切片与`nil`使用`==`比较：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since Go 1.21, the `slices` package in the standard library includes two functions
    to compare slices. The `slices.Equal` function takes in two slices and returns
    `true` if the slices are the same length, and all of the elements are equal. It
    requires the elements of the slice to be comparable. The other function, `slices.EqualFunc`,
    lets you pass in a function to determine equality and does not require the slice
    elements to be comparable. You’ll learn about passing functions into functions
    in [“Passing Functions as Parameters”](ch05.html#func_param). The other functions
    in the `slices` package are covered in [“Adding Generics to the Standard Library”](ch08.html#slice_map_funcs).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go 1.21以来，标准库中的`slices`包包含了两个比较切片的函数。`slices.Equal`函数接受两个切片，并在这两个切片长度相同且所有元素相等时返回`true`。它要求切片的元素是可比较的。另一个函数`slice.EqualFunc`允许你传递一个函数来确定相等性，并且不要求切片元素是可比较的。你将会在[“传递函数作为参数”](ch05.html#func_param)章节学习如何将函数传递给函数。`slices`包中的其他函数在[“向标准库添加泛型”](ch08.html#slice_map_funcs)章节中有详细介绍。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Warning
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `reflect` package contains a function called `DeepEqual` that can compare
    almost anything, including slices. It’s a legacy function, primarily intended
    for testing. Before the inclusion of `slices.Equal` and `slices.EqualFunc`, `reflect.DeepEqual`
    was often used to compare slices. Don’t use it in new code, as it is slower and
    less safe than using the functions in the `slices` package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflect`包中包含一个名为`DeepEqual`的函数，可以比较几乎任何东西，包括切片。这是一个遗留函数，主要用于测试。在包含`slices.Equal`和`slices.EqualFunc`之前，通常使用`reflect.DeepEqual`来比较切片。不要在新代码中使用它，因为它比`slices`包中的函数更慢，也不够安全。'
- en: len
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: len
- en: Go provides several built-in functions to work with slices. You’ve already seen
    the built-in `len` function when looking at arrays. It works for slices too. Passing
    a `nil` slice to `len` returns 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言提供了几个内置函数来处理切片。当你查看数组时，已经看到了内置的`len`函数。它对切片也适用。将一个`nil`切片传递给`len`将返回0。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Functions like `len` are built into Go because they can do things that can’t
    be done by the functions that you can write. You’ve already seen that `len`’s
    parameter can be any type of array or any type of slice. You’ll soon see that
    it also works for strings and maps. In [“Channels”](ch12.html#channels), you’ll
    see it working with channels. Trying to pass a variable of any other type to `len`
    is a compile-time error. As you’ll see in [Chapter 5](ch05.html#unique_chapter_id_05),
    Go doesn’t let developers write a function that accepts any string, array, slice,
    channel, or map, but rejects other types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`len`是Go语言的一部分，因为它可以做一些你自己编写的函数无法做到的事情。你已经看到`len`的参数可以是任何类型的数组或切片。很快你会看到它也适用于字符串和映射。在[“Channels”](ch12.html#channels)章节中，你将看到它与通道一起使用。试图将任何其他类型的变量传递给`len`会导致编译时错误。正如你将在[第5章](ch05.html#unique_chapter_id_05)中看到的，Go语言不允许开发者编写一个接受任何字符串、数组、切片、通道或映射的函数，但却拒绝其他类型。
- en: append
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: append
- en: 'The built-in `append` function is used to grow slices:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`append`函数用于增长切片：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `append` function takes at least two parameters, a slice of any type and
    a value of that type. It returns a slice of the same type, which is assigned to
    the variable that was passed to `append`. In this example, you are appending to
    a `nil` slice, but you can append to a slice that already has elements:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`函数至少接受两个参数，一个任意类型的切片和一个该类型的值。它返回一个相同类型的切片，并将其赋给传递给`append`的变量。在这个示例中，你正在向一个`nil`切片追加，但你也可以向已有元素的切片追加：'
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can append more than one value at a time:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以一次追加多个值：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One slice is appended onto another by using the `...` operator to expand the
    source slice into individual values (you’ll learn more about the `...` operator
    in [“Variadic Input Parameters and Slices”](ch05.html#vararg)):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`...`操作符将源切片扩展为单独的值，可以将一个切片追加到另一个切片（你将在[“可变输入参数和切片”](ch05.html#vararg)中学到更多关于`...`操作符的知识）：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is a compile-time error if you forget to assign the value returned from `append`.
    You might be wondering why as it seems a bit repetitive. I will talk about this
    in greater detail in [Chapter 5](ch05.html#unique_chapter_id_05), but Go is a
    *call-by-value* language. Every time you pass a parameter to a function, Go makes
    a copy of the value that’s passed in. Passing a slice to the `append` function
    actually passes a copy of the slice to the function. The function adds the values
    to the copy of the slice and returns the copy. You then assign the returned slice
    back to the variable in the calling function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记为`append`返回的值分配值，这将是编译时错误。你可能会想知道为什么这似乎有些重复。我将在[第5章](ch05.html#unique_chapter_id_05)中详细讨论这个问题，但是Go是一种*按值传递*的语言。每次将参数传递给函数时，Go都会复制传入的值。将切片传递给`append`函数实际上是将切片的副本传递给函数。函数向切片的副本添加值并返回副本。然后，将返回的切片重新分配给调用函数中的变量。
- en: Capacity
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量
- en: As you’ve seen, a slice is a sequence of values. Each element in a slice is
    assigned to consecutive memory locations, which makes it quick to read or write
    these values. The length of a slice is the number of consecutive memory locations
    that have been assigned a value. Every slice also has a *capacity*, which is the
    number of consecutive memory locations reserved. This can be larger than the length.
    Each time you append to a slice, one or more values is added to the end of the
    slice. Each value added increases the length by one. When the length reaches the
    capacity, there’s no more room to put values. If you try to add additional values
    when the length equals the capacity, the `append` function uses the Go runtime
    to allocate a new backing array for the slice with a larger capacity. The values
    in the original backing array are copied to the new one, the new values are added
    to the end of the new backing array, and the slice is updated to refer to the
    new backing array. Finally, the updated slice is returned.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，切片是值的序列。切片中的每个元素都分配给连续的内存位置，这使得读写这些值非常快速。切片的长度是已分配值的连续内存位置的数量。每个切片还有一个*容量*，即预留的连续内存位置数量。这可以大于长度。每次向切片追加值时，都会向切片末尾添加一个或多个值。每添加一个值，长度增加一次。当长度达到容量时，没有更多空间可放置值。如果在长度等于容量时尝试添加额外的值，则`append`函数使用Go运行时为切片分配一个新的背景数组，其容量更大。原始背景数组中的值被复制到新数组中，新值被添加到新背景数组的末尾，然后更新切片以引用新背景数组。最后，更新后的切片被返回。
- en: When a slice grows via `append`, it takes time for the Go runtime to allocate
    new memory and copy the existing data from the old memory to the new. The old
    memory also needs to be garbage collected. For this reason, the Go runtime usually
    increases a slice by more than one each time it runs out of capacity. The rule
    as of Go 1.18 is to double the capacity of a slice when the current capacity is
    less than 256\. A bigger slice increases by `(current_capacity + 768)/4`. This
    slowly converges at 25% growth (a slice with capacity of 512 will grow by 63%,
    but a slice with capacity 4,096 will grow by only 30%).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当切片通过`append`增长时，Go运行时需要时间来分配新内存，并将现有数据从旧内存复制到新内存。旧内存也需要进行垃圾回收。因此，当当前容量小于256时，Go运行时通常会将切片的容量加倍。截至Go
    1.18，切片的规则是：当当前容量小于256时，切片的容量增加`(current_capacity + 768)/4`。这慢慢地以25%的增长收敛（容量为512的切片将增长63%，但容量为4096的切片只增长30%）。
- en: Just as the built-in `len` function returns the current length of a slice, the
    built-in `cap` function returns the current capacity of a slice. It is used far
    less frequently than `len`. Most of the time, `cap` is used to check if a slice
    is large enough to hold new data, or if a call to `make` is needed to create a
    new slice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内置的`len`函数返回切片的当前长度一样，内置的`cap`函数返回切片的当前容量。与`len`相比，`cap`的使用频率要低得多。大多数情况下，`cap`用于检查切片是否足够大以容纳新数据，或者是否需要调用`make`来创建一个新的切片。
- en: You can also pass an array to the `cap` function, but `cap` always returns the
    same value as `len` for arrays. Don’t put it in your code, but save this trick
    for Go trivia night.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将数组传递给`cap`函数，但对于数组，`cap`总是返回与`len`相同的值。不要将其放入你的代码中，而是将此技巧留到Go知识竞赛之夜。
- en: Let’s take a look at how adding elements to a slice changes the length and capacity.
    Run the code in [Example 3-1](#EX3_1) on [The Go Playground](https://oreil.ly/yiHu-)
    or in the *sample_code/len_cap* directory in the [Chapter 3 repository](https://oreil.ly/dZMDe).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看向切片添加元素如何改变长度和容量。在[示例 3-1](#EX3_1)中运行代码在[Go Playground](https://oreil.ly/yiHu-)或在[第3章存储库](https://oreil.ly/dZMDe)的*sample_code/len_cap*目录中。
- en: Example 3-1\. Understanding capacity
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1。理解容量
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you build and run the code, you’ll see the following output. Notice how
    and when the capacity increases:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建并运行代码时，您将看到以下输出。注意容量如何何时增加：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While it’s nice that slices grow automatically, it’s far more efficient to size
    them once. If you know how many things you plan to put into a slice, create it
    with the correct initial capacity. You do that with the `make` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然切片自动增长很方便，但是一次性为其指定大小要高效得多。如果您知道要放入切片中的事物数量，使用正确的初始容量来创建它。您可以使用`make`函数来实现这一点。
- en: make
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: make
- en: 'You’ve already seen two ways to declare a slice, using a slice literal or the
    `nil` zero value. While useful, neither way allows you to create an empty slice
    that already has a length or capacity specified. That’s the job of the built-in
    `make` function. It allows you to specify the type, length, and, optionally, the
    capacity. Let’s take a look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到两种声明切片的方式，使用切片字面量或`nil`零值。虽然有用，但是这两种方式都不允许您创建已指定长度或容量的空切片。这是内置的`make`函数的任务。它允许您指定类型、长度，并且可选地指定容量。让我们来看一下：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This creates an `int` slice with a length of 5 and a capacity of 5\. Since it
    has a length of 5, `x[0]` through `x[4]` are valid elements, and they are all
    initialized to 0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个长度为5且容量为5的`int`切片。由于长度为5，`x[0]`到`x[4]`都是有效元素，并且它们都初始化为0。
- en: 'One common beginner mistake is to try to populate those initial elements using
    `append`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的初学者错误是尝试使用`append`来填充这些初始元素：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The 10 is placed at the end of the slice, *after* the zero values in elements
    0–4 because `append` always increases the length of a slice. The value of `x`
    is now [0 0 0 0 0 10], with a length of 6 and a capacity of 10 (the capacity was
    doubled as soon as the sixth element was appended).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将10放在切片末尾，在0–4元素的零值之后，因为`append`总是增加切片的长度。现在`x`的值是[0 0 0 0 0 10]，长度为6，容量为10（一旦附加的第六个元素，容量就会加倍）。
- en: 'You can also specify an initial capacity with `make`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`make`指定初始容量：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates an `int` slice with a length of 5 and a capacity of 10.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个长度为5且容量为10的`int`切片。
- en: 'You can also create a slice with zero length but a capacity that’s greater
    than zero:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建长度为零但容量大于零的切片：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this case, you have a non-`nil` slice with a length of 0 but a capacity
    of 10\. Since the length is 0, you can’t directly index into it, but you can append
    values to it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您有一个非`nil`的长度为0但容量为10的切片。由于长度为0，您无法直接对其进行索引，但可以向其附加值：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The value of `x` is now [5 6 7 8], with a length of 4 and a capacity of 10.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`x`的值是[5 6 7 8]，长度为4，容量为10。
- en: Warning
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Never specify a capacity that’s less than the length! It is a compile-time error
    to do so with a constant or numeric literal. If you use a variable to specify
    a capacity that’s smaller than the length, your program will panic at runtime.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 绝不要指定容量小于长度！这是一个编译时错误，如果使用常量或数字字面量这样做。如果您使用变量指定比长度更小的容量，您的程序将在运行时发生恐慌。
- en: Emptying a Slice
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清空切片
- en: 'Go 1.21 added a `clear` function that takes in a slice and sets all of the
    slice’s elements to their zero value. The length of the slice remains unchanged.
    The following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.21添加了一个`clear`函数，接受一个切片并将所有切片的元素设置为它们的零值。切片的长度保持不变。以下代码：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'prints out:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: (Remember, the zero value for a string is an empty string `""`!)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: （记住，字符串的零值是空字符串`""`！）
- en: Declaring Your Slice
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明您的切片
- en: Now that you’ve seen all these ways to create slices, how do you choose which
    slice declaration style to use? The primary goal is to minimize the number of
    times the slice needs to grow. If it’s possible that the slice won’t need to grow
    at all, use a `var` declaration with no assigned value to create a `nil` slice,
    as shown in [Example 3-2](#EX3_7).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到所有这些创建切片的方法，您应该如何选择使用哪种切片声明风格？主要目标是尽量减少切片需要增长的次数。如果可能切片根本不需要增长，请使用没有分配值的`var`声明来创建`nil`切片，如[示例 3-2](#EX3_7)所示。
- en: Example 3-2\. Declaring a slice that might stay `nil`
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2。声明一个可能保持`nil`的切片
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can create a slice using an empty slice literal:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用空切片字面量创建一个切片：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This creates a slice with zero length and zero capacity. It is confusingly different
    from a `nil` slice. Because of implementation reasons, comparing a zero-length
    slice to `nil` returns `false`, while comparing a `nil` slice to `nil` returns
    `true`. For simplicity, favor `nil` slices. A zero-length slice is useful only
    when converting a slice to JSON. You’ll look at this more in [“encoding/json”](ch13.html#json).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个零长度和零容量的切片。这与`nil`切片的不同是令人困惑的。由于实现原因，将零长度的切片与`nil`比较返回`false`，而将`nil`切片与`nil`比较返回`true`。为简单起见，推荐使用`nil`切片。零长度的切片仅在将切片转换为
    JSON 时有用。你将在[“encoding/json”](ch13.html#json)中进一步了解。
- en: If you have some starting values, or if a slice’s values aren’t going to change,
    then a slice literal is a good choice (see [Example 3-3](#EX3_8)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一些起始值，或者切片的值不会改变，那么切片字面量是一个不错的选择（见[示例 3-3](#EX3_8)）。
- en: Example 3-3\. Declaring a slice with default values
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 使用默认值声明切片
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a good idea of how large your slice needs to be, but don’t know
    what those values will be when you are writing the program, use `make`. The question
    then becomes whether you should specify a nonzero length in the call to `make`
    or specify a zero length and a nonzero capacity. There are three possibilities:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对切片需要多大有一个很好的想法，但在编写程序时不知道这些值是多少，请使用`make`。那么问题就变成了在调用`make`时是否应指定一个非零长度，或者指定零长度和非零容量。有三种可能性：
- en: If you are using a slice as a buffer (you’ll see this in [“io and Friends”](ch13.html#io_friends)),
    then specify a nonzero length.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用切片作为缓冲区（你会在[“io and Friends”](ch13.html#io_friends)中看到这一点），那么请指定一个非零长度。
- en: If you are *sure* you know the exact size you want, you can specify the length
    and index into the slice to set the values. This is often done when transforming
    values in one slice and storing them in a second. The downside to this approach
    is that if you have the size wrong, you’ll end up with either zero values at the
    end of the slice or a panic from trying to access elements that don’t exist.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你*确信*知道你想要的确切大小，你可以指定长度并索引到切片中设置值。当在一个切片中转换值并将它们存储在第二个切片中时，通常会这样做。这种方法的缺点是，如果大小错误，你将在切片末尾得到零值，或者因尝试访问不存在的元素而引发恐慌。
- en: In other situations, use `make` with a zero length and a specified capacity.
    This allows you to use `append` to add items to the slice. If the number of items
    turns out to be smaller, you won’t have an extraneous zero value at the end. If
    the number of items is larger, your code will not panic.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他情况下，使用零长度和指定容量的`make`。这允许你使用`append`向切片添加项目。如果项目数量较少，你不会在末尾得到多余的零值。如果项目数量较多，你的代码不会出现恐慌。
- en: The Go community is split between the second and third approaches. I personally
    prefer using `append` with a slice initialized to a zero length. It might be slower
    in some situations, but it is less likely to introduce a bug.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Go 社区在第二种和第三种方法之间存在分歧。我个人更喜欢使用一个初始化为零长度的切片来使用`append`。在某些情况下可能会慢一些，但较不容易引入 bug。
- en: Warning
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`append` always increases the length of a slice! If you have specified a slice’s
    length using `make`, be sure that you mean to append to it before you do so, or
    you might end up with a bunch of surprise zero values at the beginning of your
    slice.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`总是增加切片的长度！如果你使用`make`指定了切片的长度，请确保在这样做之前是有意为之，否则可能会在切片的开头得到一堆意外的零值。'
- en: Slicing Slices
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片切片
- en: A *slice expression* creates a slice from a slice. It’s written inside brackets
    and consists of a starting offset and an ending offset, separated by a colon (:).
    The starting offset is the first position in the slice that is included in the
    new slice, and the ending offset is one past the last position to include. If
    you leave off the starting offset, 0 is assumed. Likewise, if you leave off the
    ending offset, the end of the slice is substituted. You can see how this works
    by running the code in [Example 3-4](#EX3_9) on [The Go Playground](https://oreil.ly/PFtfZ)
    or in the *sample_code/slicing_slices* directory in the [Chapter 3 repository](https://oreil.ly/Ka-rJ).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片表达式*从一个切片中创建一个切片。它写在方括号内，由起始偏移和结束偏移组成，用冒号（:）分隔。起始偏移是包含在新切片中的第一个位置，结束偏移是要包含的最后一个位置的下一个位置。如果省略起始偏移，假定为0。同样，如果省略结束偏移，则用切片的结尾替代。通过在[示例 3-4](#EX3_9)中的代码上运行它，你可以看到它是如何工作的，可以在[The
    Go Playground](https://oreil.ly/PFtfZ)或[第3章代码库](https://oreil.ly/Ka-rJ)的*sample_code/slicing_slices*目录中查看。'
- en: Example 3-4\. Slicing slices
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 切片切片
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It gives the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它会得到以下输出：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When you take a slice from a slice, you are *not* making a copy of the data.
    Instead, you now have two variables that are sharing memory. This means that changes
    to an element in a slice affect all slices that share that element. Let’s see
    what happens when you change values. You can run the code in [Example 3-5](#EX3_10)
    on [The Go Playground](https://oreil.ly/xEw9J) or in the *sample_code/slice_share_storage*
    directory in the [Chapter 3 repository](https://oreil.ly/nYkrx).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个切片中取出另一个切片时，你并没有复制数据。相反，现在你有两个共享内存的变量。这意味着对切片中元素的更改会影响所有共享该元素的切片。让我们看看当你改变值时会发生什么。你可以在[示例 3-5](#EX3_10)中的代码上运行这段代码，在[Go
    Playground](https://oreil.ly/xEw9J)或[第三章代码库](https://oreil.ly/nYkrx)的*sample_code/slice_share_storage*目录中运行。
- en: Example 3-5\. Slices with overlapping storage
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 具有重叠存储的切片
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You get the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Changing `x` modified both `y` and `z`, while changes to `y` and `z` modified
    `x`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`x`同时也修改了`y`和`z`，而对`y`和`z`的修改也会影响`x`。
- en: Slicing slices gets extra confusing when combined with `append`. Try out the
    code in [Example 3-6](#EX3_11) on [The Go Playground](https://oreil.ly/4f4pd)
    or in the *sample_code/slice_append_storage* directory in the [Chapter 3 repository](https://oreil.ly/H1YKD).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`append`结合使用时，切片切片变得更加令人困惑。在[示例 3-6](#EX3_11)中尝试这段代码，在[Go Playground](https://oreil.ly/4f4pd)或[第三章代码库](https://oreil.ly/H1YKD)的*sample_code/slice_append_storage*目录中尝试。
- en: Example 3-6\. `append` makes overlapping slices more confusing
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. `append`使得重叠切片变得更加混乱
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running this code gives the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会得到以下输出：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What’s going on? Whenever you take a slice from another slice, the subslice’s
    capacity is set to the capacity of the original slice, minus the starting offset
    of the subslice within the original slice. This means elements of the original
    slice beyond the end of the subslice, including unused capacity, are shared by
    both slices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从另一个切片中取出一个切片时，子切片的容量被设置为原始切片的容量减去子切片在原始切片中的起始偏移量。这意味着原始切片中子切片之后的元素，包括未使用的容量，会被两个切片共享。
- en: When you make the `y` slice from `x`, the length is set to 2, but the capacity
    is set to 4, the same as `x`. Since the capacity is 4, appending onto the end
    of `y` puts the value in the third position of `x`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从`x`中创建`y`切片时，长度设置为2，但容量设置为4，与`x`相同。由于容量为4，向`y`末尾添加元素会将值放在`x`的第三个位置。
- en: This behavior creates some odd scenarios, with multiple slices appending and
    overwriting each other’s data. See if you can guess what the code in [Example 3-7](#EX3_12)
    prints out, then run it on [The Go Playground](https://oreil.ly/KCveh) or in the
    *sample_code/confusing_slices* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2)
    to see if you guessed correctly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为会产生一些奇怪的场景，多个切片相互添加并覆盖彼此的数据。看看你能否猜到[示例 3-7](#EX3_12)中的代码会打印出什么，然后在[Go Playground](https://oreil.ly/KCveh)或[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/confusing_slices*目录中运行以查看是否猜对了。
- en: Example 3-7\. Even more confusing slices
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 更加令人困惑的切片
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To avoid complicated slice situations, you should either never use `append`
    with a subslice or make sure that `append` doesn’t cause an overwrite by using
    a *full slice expression*. This is a little weird, but it makes clear how much
    memory is shared between the parent slice and the subslice. The full slice expression
    includes a third part, which indicates the last position in the parent slice’s
    capacity that’s available for the subslice. Subtract the starting offset from
    this number to get the subslice’s capacity. [Example 3-8](#EX3_13) shows the first
    four lines from the previous example, modified to use full slice expressions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免复杂的切片情况，你应该要么永远不要在子切片上使用`append`，要么确保`append`不会通过使用*完整切片表达式*而导致覆盖。这有点奇怪，但它清楚地表明了父切片和子切片之间共享的内存量。完整切片表达式包括第三部分，指示了父切片容量中可用于子切片的最后位置。从这个数字中减去起始偏移量即可得到子切片的容量。[示例 3-8](#EX3_13)
    展示了前一示例中修改为使用完整切片表达式的前四行代码。
- en: Example 3-8\. The full slice expression protects against `append`
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 完整切片表达式可以防止`append`的问题
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Try out this code on [The Go Playground](https://oreil.ly/G7YBT) or in the *sample_code/full_slice_expression*
    directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2). Both `y` and
    `z` have a capacity of `2`. Because you limited the capacity of the subslices
    to their lengths, appending additional elements onto `y` and `z` created new slices
    that didn’t interact with the other slices. After this code runs, `x` is set to
    `[a b c d x]`, `y` is set to `[a b i j k]`, and `z` is set to `[c d y]`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在[The Go Playground](https://oreil.ly/G7YBT)或者[第3章代码库](https://oreil.ly/Ur5f2)的*sample_code/full_slice_expression*目录中尝试这段代码。`y`和`z`的容量都为`2`。因为你限制了子切片的容量为它们的长度，向`y`和`z`附加额外元素会创建新的切片，这些切片不会与其他切片交互。运行此代码后，`x`设置为`[a
    b c d x]`，`y`设置为`[a b i j k]`，`z`设置为`[c d y]`。
- en: Warning
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful when taking a slice of a slice! Both slices share the same memory,
    and changes to one are reflected in the other. Avoid modifying slices after they
    have been sliced or if they were produced by slicing. Use a three-part slice expression
    to prevent `append` from sharing capacity between slices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当对切片进行切片时要小心！两个切片共享同一内存，对其中一个的更改会反映在另一个上。避免在切片后修改切片或者在通过切片生成后修改切片。使用三部分切片表达式防止`append`在切片之间共享容量。
- en: copy
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: 'If you need to create a slice that’s independent of the original, use the built-in
    `copy` function. Let’s take a look at a simple example, which you can run on [The
    Go Playground](https://oreil.ly/ilMNY) or in the *sample_code/copy_slice* directory
    in the [Chapter 3 repository](https://oreil.ly/Ur5f2):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要创建与原始切片独立的切片，请使用内置的`copy`函数。我们来看一个简单的例子，可以在[The Go Playground](https://oreil.ly/ilMNY)上运行，或者在[第3章代码库](https://oreil.ly/Ur5f2)的*sample_code/copy_slice*目录中运行：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You get this output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下输出：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `copy` function takes two parameters. The first is the destination slice,
    and the second is the source slice. The function copies as many values as it can
    from source to destination, limited by whichever slice is smaller, and returns
    the number of elements copied. The *capacity* of `x` and `y` doesn’t matter; it’s
    the length that’s important.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`函数接受两个参数。第一个是目标切片，第二个是源切片。该函数尽可能从源切片向目标切片复制尽可能多的值，受限于较小的切片，并返回复制的元素数。`x`和`y`的*容量*不重要；长度才重要。'
- en: 'You can also copy a subset of a slice. The following code copies the first
    two elements of a four-element slice into a two-element slice:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以复制切片的子集。以下代码将四元素切片的前两个元素复制到两元素切片中：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The variable `y` is set to [1 2], and `num` is set to 2.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`y`设置为[1 2]，`num`设置为2。
- en: 'You could also copy from the middle of the source slice:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从源切片的中间复制：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You are copying the third and fourth elements in `x` by taking a slice of the
    slice. Also note that *you don’t assign the output of `copy` to a variable*. If
    you don’t need the number of elements copied, you don’t need to assign it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对切片进行切片来复制`x`的第三和第四个元素。还请注意*不要将`copy`的输出分配给变量*。如果你不需要复制的元素数，那么你不需要分配它。
- en: 'The `copy` function allows you to copy between two slices that cover overlapping
    sections of an underlying slice:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`函数允许在覆盖底层切片的重叠部分之间进行复制：'
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, you are copying the last three values in `x` on top of the first
    three values of `x`. This prints out [2 3 4 4] 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你在`x`的最后三个值之上复制了`x`的前三个值。这将打印出[2 3 4 4] 3。
- en: 'You can use `copy` with arrays by taking a slice of the array. You can make
    the array either the source or the destination of the copy. You can try out the
    following code on [The Go Playground](https://oreil.ly/-mhRW) or in the *sample_code/copy_array*
    directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对数组进行切片来使用`copy`。你可以将数组作为复制的源或目标。你可以在[The Go Playground](https://oreil.ly/-mhRW)上试试以下代码，或者在[第3章代码库](https://oreil.ly/Ur5f2)的*sample_code/copy_array*目录中试试：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first call to `copy` copies the first two values in array `d` into slice
    `y`. The second copies all of the values in slice `x` into array `d`. This produces
    the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`copy`将数组`d`的前两个值复制到切片`y`中。第二次将切片`x`的所有值复制到数组`d`中。这将产生以下输出：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Converting Arrays to Slices
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数组转换为切片
- en: 'Slices aren’t the only thing you can slice. If you have an array, you can take
    a slice from it using a slice expression. This is a useful way to bridge an array
    to a function that takes only slices. To convert an entire array into a slice,
    use the `[:]` syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 切片不是你唯一可以切片的东西。如果你有一个数组，你可以使用切片表达式从中获取切片。这是将数组连接到仅接受切片的函数的有用方式。要将整个数组转换为切片，请使用`[:]`语法：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can also convert a subset of an array into a slice:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将数组的子集转换为切片：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Be aware that taking a slice from an array has the same memory-sharing properties
    as taking a slice from a slice. If you run the following code on [The Go Playground](https://oreil.ly/kliaJ)
    or in the *sample_code/slice_array_memory* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从数组中获取切片具有与从切片中获取切片相同的内存共享属性。如果在[The Go Playground](https://oreil.ly/kliaJ)或[第三章仓库](https://oreil.ly/Ur5f2)中的*sample_code/slice_array_memory*目录中运行以下代码：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'you get this output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到如下输出：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Converting Slices to Arrays
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将切片转换为数组
- en: Use a type conversion to make an array variable from a slice. You can convert
    an entire slice to an array of the same type, or you can create an array from
    a subset of the slice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型转换可以从切片创建一个数组变量。你可以将整个切片转换为相同类型的数组，或者从切片的子集创建数组。
- en: When you convert a slice to an array, the data in the slice is copied to new
    memory. That means that changes to the slice won’t affect the array, and vice
    versa.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将切片转换为数组时，切片中的数据将被复制到新的内存中。这意味着对切片的更改不会影响数组，反之亦然。
- en: 'The following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'prints out:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The size of the array must be specified at compile time. It’s a compile-time
    error to use `[...]` in a slice to array type conversion.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小必须在编译时指定。在切片到数组类型转换中使用`[...]`会导致编译时错误。
- en: 'While the size of the array can be smaller than the size of the slice, it cannot
    be bigger. Unfortunately, the compiler cannot detect this, and your code will
    panic at runtime if you specify an array size that’s bigger than the length (not
    the capacity) of the slice. The following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组的大小可以比切片的大小小，但不能比其大。不幸的是，编译器无法检测到这一点，如果你指定的数组大小比切片的长度（而非容量）大，你的代码将在运行时崩溃。以下代码：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'panics at runtime with the message:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，以下消息导致程序崩溃：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'I haven’t talked about pointers yet, but you can also use a type conversion
    to convert a slice into a pointer to an array:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我还没有讨论过指针，但你也可以使用类型转换将切片转换为数组的指针：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After converting a slice to an array pointer, the storage between the two is
    shared. A change to one will change the other:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将切片转换为数组指针后，两者之间共享存储。对其中一个的更改会影响另一个：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Pointers are covered in [Chapter 6](ch06.html#unique_chapter_id_06).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 指针在[第6章](ch06.html#unique_chapter_id_06)中有详细介绍。
- en: You can try all of the array type conversions on [The Go Playground](https://oreil.ly/Ss4Ea)
    or in the *sample_code/array_conversion* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[The Go Playground](https://oreil.ly/Ss4Ea)或[第三章仓库](https://oreil.ly/Ur5f2)的*sample_code/array_conversion*目录中尝试所有数组类型转换。
- en: In [“Arrays—Too Rigid to Use Directly”](#arrays), I mentioned that you can’t
    use arrays as function parameters when the size of the array being passed in might
    vary. Technically, you can work around this limitation by converting an array
    to a slice, converting the slice to an array of a different size, and then passing
    the second array in to a function. The second array must be shorter than the first
    array, or your program will panic. While this might be helpful in a pinch, if
    you find yourself doing this frequently, strongly consider changing your function’s
    API to take a slice instead of an array.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“数组——直接使用过于严格”](#arrays)中，我提到当传入的数组大小可能变化时，无法将数组用作函数参数。技术上，你可以通过将数组转换为切片，再将切片转换为不同大小的数组，并将第二个数组传递给函数来绕过此限制。第二个数组必须比第一个数组短，否则程序将会崩溃。虽然这在紧急情况下可能有所帮助，但如果你经常这样做，强烈考虑修改函数的API以接受切片而不是数组。
- en: Strings and Runes and Bytes
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串、符文和字节
- en: Now that I’ve talked about slices, we can look at strings again. You might think
    that a string in Go is made out of runes, but that’s not the case. Under the covers,
    Go uses a sequence of bytes to represent a string. These bytes don’t have to be
    in any particular character encoding, but several Go library functions (and the
    `for-range` loop that I discuss in the next chapter) assume that a string is composed
    of a sequence of UTF-8-encoded code points.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讨论了切片，我们可以再次看字符串。你可能会认为Go语言中的字符串是由符文组成的，但事实并非如此。在底层，Go语言使用一系列字节来表示字符串。这些字节可以不必遵循任何特定的字符编码，但是几个Go库函数（以及我在下一章中讨论的`for-range`循环）假设一个字符串由一系列UTF-8编码的代码点组成。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: According to the language specification, Go source code is always written in
    UTF-8\. Unless you use hexadecimal escapes in a string literal, your string literals
    are written in UTF-8.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 根据语言规范，Go源代码总是用UTF-8编写。除非在字符串文字中使用十六进制转义，否则你的字符串文字是用UTF-8编写的。
- en: 'Just as you can extract a single value from an array or a slice, you can extract
    a single value from a string by using an *index expression*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以从数组或切片中提取单个值一样，你也可以通过使用*索引表达式*从字符串中提取单个值：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Like arrays and slices, string indexes are zero-based; in this example, `b`
    is assigned the numeric value of the seventh position in `s`, which is `116` (the
    UTF-8 value of a lowercase t).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 像数组和切片一样，字符串的索引是从零开始的；在这个示例中，`b`被赋予了在`s`中第七个位置的数值`116`（小写字母t的UTF-8值）。
- en: 'The slice expression notation that you used with arrays and slices also works
    with strings:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你用于数组和切片的切片表达式符号也适用于字符串：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This assigns “o t” to `s2`, “Hello” to `s3`, and “there” to `s4`. You can try
    out this code [on The Go Playground](https://oreil.ly/pF8T6) or in the *sample_code/string_slicing*
    directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将“o t”赋给`s2`，“Hello”赋给`s3`，“there”赋给`s4`。你可以在[The Go Playground](https://oreil.ly/pF8T6)或[第3章代码库](https://oreil.ly/Ur5f2)的*sample_code/string_slicing*目录中尝试这段代码。
- en: 'While it’s handy that Go allows you to use slicing notation to make substrings
    and use index notation to extract individual entries from a string, you should
    be careful when doing so. Since strings are immutable, they don’t have the modification
    problems that slices of slices do. There is a different problem, though. A string
    is composed of a sequence of bytes, while a code point in UTF-8 can be anywhere
    from one to four bytes long. The previous example was entirely composed of code
    points that are one byte long in UTF-8, so everything worked out as expected.
    But when dealing with languages other than English or with emojis, you run into
    code points that are multiple bytes long in UTF-8:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go语言允许你使用切片符号来创建子串，并使用索引符号从字符串中提取单个条目，这确实很方便，但在这样做时要小心。由于字符串是不可变的，它们不会像切片的切片那样有修改问题。不过，也存在不同的问题。一个字符串由一系列字节组成，而UTF-8中的一个代码点可以是一到四个字节长。前面的示例完全由UTF-8中长度为一个字节的代码点组成，所以一切都按预期进行。但是在处理非英语或表情符号的语言时，你会遇到长度为多个字节的UTF-8代码点：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, `s3` will still be equal to “Hello.” The variable `s4` is set
    to the sun emoji. But `s2` is not set to “o ![](assets/sun.png).” Instead, you
    get “o ![](assets/replacement.png).” That’s because you copied only the first
    byte of the sun emoji’s code point, which is not a valid code point on its own.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`s3`仍然等于“Hello。”变量`s4`设置为太阳表情符号。但是`s2`并没有被设置为“o ![](assets/sun.png)。”而是得到了“o
    ![](assets/replacement.png)。”这是因为你只复制了太阳表情符号代码点的第一个字节，这个字节单独来看不是有效的代码点。
- en: 'Go allows you to pass a string to the built-in `len` function to find the length
    of the string. Given that string index and slice expressions count positions in
    bytes, it’s not surprising that the length returned is the length in bytes, not
    in code points:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言允许你将字符串传递给内置的`len`函数以找到字符串的长度。由于字符串索引和切片表达式计算的是字节位置，因此返回的长度是以字节为单位的长度，而不是代码点的长度：
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This code prints out 10, not 7, because it takes four bytes to represent the
    sun with smiling face emoji in UTF-8\. You can run these sun emoji examples on
    [The Go Playground](https://oreil.ly/6ngTb) or in the *sample_code/sun_slicing*
    directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印出10，而不是7，因为用UTF-8编码的太阳笑脸表情符号需要四个字节来表示。你可以在[The Go Playground](https://oreil.ly/6ngTb)或[第3章代码库](https://oreil.ly/Ur5f2)的*sample_code/sun_slicing*目录中运行这些太阳表情符号的示例。
- en: Warning
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Even though Go allows you to use slicing and indexing syntax with strings, you
    should use it only when you know that your string contains only characters that
    take up one byte.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go 允许您在字符串中使用切片和索引语法，但只有在您知道您的字符串仅包含占用一个字节的字符时才应使用它。
- en: 'Because of this complicated relationship among runes, strings, and bytes, Go
    has some interesting type conversions between these types. A single rune or byte
    can be converted to a string:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 rune、字符串和字节之间的复杂关系，Go 提供了一些有趣的类型转换。单个 rune 或字节可以转换为字符串：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Warning
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'A common bug for new Go developers is to try to make an `int` into a `string`
    by using a type conversion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 新手 Go 开发者常见的一个错误是尝试通过类型转换将`int`转换为`string`：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This results in `y` having the value “A,” not “65.” As of Go 1.15, `go vet`
    blocks a type conversion to string from any integer type other than `rune` or
    `byte`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致`y`具有值“A”，而不是“65”。从 Go 1.15 开始，`go vet`阻止从除`rune`或`byte`以外的任何整数类型进行字符串类型转换。
- en: A string can be converted back and forth to a slice of bytes or a slice of runes.
    Try [Example 3-9](#EX1-2) on [The Go Playground](https://oreil.ly/N7fOB) or in
    the *sample_code/string_to_slice* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以在字节片段或 rune 切片之间来回转换。在[示例 3-9](#EX1-2)和[第 3 章存储库](https://oreil.ly/Ur5f2)中的*sample_code/string_to_slice*目录中尝试此代码：
- en: Example 3-9\. Converting strings to slices
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 将字符串转换为切片
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When you run this code, you see the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，您会看到以下输出：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first output line has the string converted to UTF-8 bytes. The second has
    the string converted to runes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行输出将字符串转换为 UTF-8 字节。第二行将字符串转换为 runes。
- en: Most data in Go is read and written as a sequence of bytes, so the most common
    string type conversions are back and forth with a slice of bytes. Slices of runes
    are uncommon.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中大多数数据都是按字节序列读取和写入的，因此最常见的字符串类型转换是通过字节切片来回转换。很少使用 rune 切片。
- en: Rather than use the slice and index expressions with strings, you should extract
    substrings and code points from strings using the functions in the `strings` and
    `unicode/utf8` packages in the standard library. In the next chapter, you’ll see
    how to use a `for-range` loop to iterate over the code points in a string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用切片和索引表达式处理字符串，应该使用标准库中`strings`和`unicode/utf8`包中的函数从字符串中提取子字符串和代码点。在下一章中，您将看到如何使用`for-range`循环迭代字符串中的代码点。
- en: Maps
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'Slices are useful when you have sequential data. Like most languages, Go provides
    a built-in data type for situations where you want to associate one value to another.
    The map type is written as `map[keyType]valueType`. Let’s take a look at a few
    ways to declare maps. First, you can use a `var` declaration to create a map variable
    that’s set to its zero value:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有顺序数据时，切片非常有用。与大多数语言一样，Go 提供了一种内置数据类型，用于在您想要将一个值关联到另一个值的情况下使用。映射类型的书写方式为`map[keyType]valueType`。让我们看看声明映射的几种方法。首先，您可以使用`var`声明创建一个映射变量，该变量被设置为其零值：
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this case, `nilMap` is declared to be a map with `string` keys and `int`
    values. The zero value for a map is `nil`. A `nil` map has a length of 0\. Attempting
    to read a `nil` map always returns the zero value for the map’s value type. However,
    *attempting to write to a `nil` map variable causes a panic*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`nilMap`被声明为具有`string`键和`int`值的映射。映射的零值是`nil`。`nil`映射的长度为 0。尝试读取`nil`映射始终返回映射值类型的零值。但是，*尝试向`nil`映射变量写入数据将导致恐慌*。
- en: 'You can use a `:=` declaration to create a map variable by assigning it a *map
    literal*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`:=`声明通过*map 字面量*创建一个映射变量：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In this case, you are using an empty map literal. This is not the same as a
    `nil` map. It has a length of 0, but you can read and write to a map assigned
    an empty map literal. Here’s what a nonempty map literal looks like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您正在使用空的映射字面量。这不同于`nil`映射。它的长度为 0，但您可以读取和写入分配了空映射字面量的映射。以下是一个非空映射字面量的示例：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A map literal’s body is written as the key, followed by a colon (:), then the
    value. A comma separates each key-value pair in the map, even on the last line.
    In this example, the value is a slice of strings. The type of the value in a map
    can be anything. There are some restrictions on the types of the keys that I’ll
    discuss in a bit.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 映射字面量的主体是键，后跟冒号（:），然后是值。每个键值对在映射中用逗号分隔，即使是最后一行也是如此。在这个例子中，值是一个字符串切片。映射中值的类型可以是任何类型。关于键类型的一些限制稍后会讨论。
- en: 'If you know how many key-value pairs you intend to put in the map but don’t
    know the exact values, you can use `make` to create a map with a default size:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道打算放入地图中的键值对数量，但不知道确切的值，可以使用`make`创建具有默认大小的地图：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Maps created with `make` still have a length of 0, and they can grow past the
    initially specified size.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make`创建的地图仍然具有长度为 0，并且它们可以超过最初指定的大小。
- en: 'Maps are like slices in several ways:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 地图在几个方面类似于切片：
- en: Maps automatically grow as you add key-value pairs to them.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着向地图添加键值对，地图会自动增长。
- en: If you know how many key-value pairs you plan to insert into a map, you can
    use `make` to create a map with a specific initial size.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道打算插入地图中的键值对数量，可以使用`make`创建具有特定初始大小的地图。
- en: Passing a map to the `len` function tells you the number of key-value pairs
    in a map.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地图传递给`len`函数可以告诉你地图中键值对的数量。
- en: The zero value for a map is `nil`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图的零值为`nil`。
- en: Maps are not comparable. You can check if they are equal to `nil`, but you cannot
    check if two maps have identical keys and values using `==` or differ using `!=`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图不可比较。你可以检查它们是否等于`nil`，但不能使用`==`检查两个地图是否具有相同的键和值，也不能使用`!=`检查它们是否不同。
- en: The key for a map can be any comparable type. This means *you cannot use a slice
    or a map as the key for a map*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的键可以是任何可比较的类型。这意味着*你不能使用切片或地图作为地图的键*。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When should you use a map, and when should you use a slice? You should use slices
    for lists of data when the data should be processed sequentially or the order
    of the elements is important.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该使用地图，何时应该使用切片？当数据应按顺序处理或元素的顺序重要时，应使用切片来表示数据列表。
- en: Maps are useful when you need to organize values using something other than
    an increasing integer value, such as a name.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用除递增整数值以外的其他方式来组织值时，地图非常有用，例如名称。
- en: Reading and Writing a Map
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入地图
- en: Let’s look at a short program that declares, writes to, and reads from a map.
    You can run the program in [Example 3-10](#EX3_MAP_RW) on [The Go Playground](https://oreil.ly/gBMvf)
    or in the *sample_code/map_read_write* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个声明、写入和读取地图的简短程序。你可以在[示例 3-10](#EX3_MAP_RW)上的[The Go Playground](https://oreil.ly/gBMvf)或[第
    3 章存储库](https://oreil.ly/Ur5f2)的*sample_code/map_read_write*目录中运行此程序。
- en: Example 3-10\. Using a map
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 使用地图
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When you run this program, you’ll see the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，你将看到以下输出：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You assign a value to a map key by putting the key within brackets and using
    `=` to specify the value, and you read the value assigned to a map key by putting
    the key within brackets. Note that you cannot use `:=` to assign a value to a
    map key.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将键放在方括号内并使用`=`指定值来为地图键分配值，通过将键放在方括号内读取分配给地图键的值。请注意，你不能使用`:=`来为地图键分配值。
- en: When you try to read the value assigned to a map key that was never set, the
    map returns the zero value for the map’s value type. In this case, the value type
    is an `int`, so you get back a 0\. You can use the `++` operator to increment
    the numeric value for a map key. Because a map returns its zero value by default,
    this works even when there’s no existing value associated with the key.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试读取从未设置过的地图键的值时，地图将返回地图值类型的零值。在本例中，值类型为`int`，因此会返回 0\. 你可以使用`++`运算符来递增地图键的数值。因为地图默认返回其零值，所以即使与键关联的现有值不存在，这也适用。
- en: The comma ok Idiom
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逗号 ok 习语
- en: 'As you’ve seen, a map returns the zero value if you ask for the value associated
    with a key that’s not in the map. This is handy when implementing things like
    the `totalWins` counter you saw earlier. However, you sometimes do need to find
    out if a key is in a map. Go provides the *comma ok idiom* to tell the difference
    between a key that’s associated with a zero value and a key that’s not in the
    map:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果要查找与地图中不存在的键关联的值，地图将返回零值。这在实现像前面看到的`totalWins`计数器时非常方便。然而，有时确实需要查找键是否存在于地图中。Go
    提供了*逗号 ok 习语*来区分关联零值的键和不在地图中的键：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Rather than assign the result of a map read to a single variable, with the comma
    ok idiom you assign the results of a map read to two variables. The first gets
    the value associated with the key. The second value returned is a bool. It is
    usually named `ok`. If `ok` is `true`, the key is present in the map. If `ok`
    is `false`, the key is not present. In this example, the code prints out `5 true`,
    `0 true`, and `0 false`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 与将映射读取的结果分配给单个变量不同，使用逗号ok惯用法将映射读取的结果分配给两个变量。第一个变量获取与键关联的值。第二个返回的值是一个布尔值，通常命名为`ok`。如果`ok`为`true`，则键存在于映射中。如果`ok`为`false`，则键不存在。在这个示例中，代码打印出`5
    true`，`0 true`和`0 false`。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The comma ok idiom is used in Go when you want to differentiate between reading
    a value and getting back the zero value. You’ll see it again when you read from
    channels in [Chapter 12](ch12.html#unique_chapter_id_12) and when you use type
    assertions in [Chapter 7](ch07.html#unique_chapter_id_07).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，当你想要区分读取一个值和返回零值时，可以使用逗号ok惯用法。你将在[第12章](ch12.html#unique_chapter_id_12)再次看到它，并且在使用类型断言时也会看到它在[第7章](ch07.html#unique_chapter_id_07)。
- en: Deleting from Maps
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从映射中删除
- en: 'Key-value pairs are removed from a map via the built-in `delete` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 键-值对可以通过内置的`delete`函数从映射中移除：
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `delete` function takes a map and a key and then removes the key-value pair
    with the specified key. If the key isn’t present in the map or if the map is `nil`,
    nothing happens. The `delete` function doesn’t return a value.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`函数接收一个映射和一个键，然后移除具有指定键的键-值对。如果键不在映射中或映射为`nil`，则什么也不发生。`delete`函数不返回值。'
- en: Emptying a Map
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清空映射
- en: 'The `clear` function that you saw in [“Emptying a Slice”](#empty_slice) works
    on maps also. A cleared map has its length set to zero, unlike a cleared slice.
    The following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[“清空切片”](#empty_slice)中看到的`clear`函数也适用于映射。清空后的映射长度被设为零，不同于清空切片。以下代码：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'prints out:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE73]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Comparing Maps
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较映射
- en: 'Go 1.21 added a package to the standard library called `maps` that contains
    helper functions for working with maps. You’ll learn more about this package in
    [“Adding Generics to the Standard Library”](ch08.html#slice_map_funcs). Two functions
    in the package are useful for comparing if two maps are equal, `maps.Equal` and
    `maps.EqualFunc`. They are analogous to the `slices.Equal` and `slices.EqualFunc`
    functions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.21添加了一个名为`maps`的包到标准库中，其中包含用于处理映射的辅助函数。你将在[“向标准库添加泛型”](ch08.html#slice_map_funcs)中了解更多关于该包的信息。包中的两个函数对比两个映射是否相等非常有用，`maps.Equal`和`maps.EqualFunc`。它们类似于`slices.Equal`和`slices.EqualFunc`函数：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Using Maps as Sets
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射作为集合
- en: Many languages include a set in their standard library. A *set* is a data type
    that ensures there is at most one of a value, but doesn’t guarantee that the values
    are in any particular order. Checking to see if an element is in a set is fast,
    no matter how many elements are in the set. (Checking to see if an element is
    in a slice takes longer, as you add more elements to the slice.)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言在它们的标准库中包含了集合。*集合*是一种数据类型，确保值最多只有一个，但不保证值的顺序。检查元素是否在集合中是快速的，无论集合中有多少元素。（检查元素是否在切片中则会花费更多时间，因为切片中的元素越多，时间越长。）
- en: Go doesn’t include a set, but you can use a map to simulate some of its features.
    Use the key of the map for the type that you want to put into the set and use
    a `bool` for the value. The code in [Example 3-11](#EX3_SET) demonstrates the
    concept. You can run it on [The Go Playground](https://oreil.ly/wC6XK) or in the
    *sample_code/map_set* directory in the [Chapter 3 repository](https://oreil.ly/Ur5f2).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言不包含集合，但可以使用映射来模拟其部分功能。将映射的键用于要放入集合的类型，并将值用`bool`类型。[示例 3-11](#EX3_SET)中的代码演示了这一概念。你可以在[The
    Go Playground](https://oreil.ly/wC6XK)或[第3章示例代码库](https://oreil.ly/Ur5f2)的*sample_code/map_set*目录中运行它。
- en: Example 3-11\. Using a map as a set
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11. 使用映射作为集合
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You want a set of `int`s, so you create a map where the keys are of `int` type
    and the values are of `bool` type. You iterate over the values in `vals` using
    a `for-range` loop (which I discuss in [“The for-range Statement”](ch04.html#for_range))
    to place them into `intSet`, associating each `int` with the boolean value `true`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个`int`类型的集合，因此创建一个映射，其中键是`int`类型，值是`bool`类型。你使用`for-range`循环（我在[“for-range语句”](ch04.html#for_range)中讨论）迭代`vals`中的值，将它们放入`intSet`中，并将每个`int`与布尔值`true`关联。
- en: We wrote 11 values into `intSet`, but the length of `intSet` is 8, because you
    cannot have duplicate keys in a map. If you look for 5 in `intSet`, it returns
    `true`, because there is a key with the value 5\. However, if you look for 500
    or 100 in `intSet`, it returns `false`. This is because you haven’t put either
    value into `intSet`, which causes the map to return the zero value for the map
    value, and the zero value for a `bool` is `false`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`intSet`写入了11个值，但`intSet`的长度为8，因为在映射中不能有重复的键。如果你在`intSet`中查找5，它会返回`true`，因为存在一个值为5的键。然而，如果你在`intSet`中查找500或100，它会返回`false`。这是因为你没有将这两个值放入`intSet`中，这导致映射返回映射值的零值，而`bool`类型的零值为`false`。
- en: If you need sets that provide operations like union, intersection, and subtraction,
    you can either write one yourself or use one of the many third-party libraries
    that provide the functionality. (You’ll learn more about using third-party libraries
    in [Chapter 10](ch10.html#unique_chapter_id_10).)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要提供像并集、交集和差集等操作的集合，你可以自己编写一个，或者使用其中一个提供这些功能的许多第三方库。（关于使用第三方库，您将在[第10章](ch10.html#unique_chapter_id_10)中学到更多。）
- en: Note
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some people prefer to use `struct{}` for the value when a map is being used
    to implement a set. (I’ll discuss structs in the next section.) The advantage
    is that an empty struct uses zero bytes, while a boolean uses one byte.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢在用映射实现集合时使用`struct{}`作为值。（我将在下一节讨论结构体。）优点是空结构体使用零字节，而布尔值使用一个字节。
- en: 'The disadvantage is that using a `struct{}` makes your code clumsier. You have
    a less obvious assignment, and you need to use the comma ok idiom to check if
    a value is in the set:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是使用`struct{}`会使您的代码变得笨拙。赋值不够明显，并且您需要使用逗号-ok惯用法来检查值是否在集合中：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unless you have very large sets, the difference in memory usage will not likely
    be significant enough to outweigh the disadvantages.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您有非常大的集合，否则内存使用的差异可能不足以抵消其缺点。
- en: Structs
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Maps are a convenient way to store some kinds of data, but they have limitations.
    They don’t define an API since there’s no way to constrain a map to allow only
    certain keys. Also, all values in a map must be of the same type. For these reasons,
    maps are not an ideal way to pass data from function to function. When you have
    related data that you want to group together, you should define a *struct*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是存储某些类型数据的方便方式，但它们有一些限制。它们不定义API，因为没有办法限制映射只允许特定的键。此外，映射中所有值必须是相同类型的。因此，映射不是将数据从一个函数传递到另一个函数的理想方式。当你有想要一起组合的相关数据时，你应该定义一个*结构体*。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you already know an object-oriented language, you might be wondering about
    the difference between classes and structs. The difference is simple: Go doesn’t
    have classes, because it doesn’t have inheritance. This doesn’t mean that Go doesn’t
    have some of the features of object-oriented languages it just does things a little
    differently. You’ll learn more about the object-oriented features of Go in [Chapter 7](ch07.html#unique_chapter_id_07).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解一种面向对象的语言，你可能想知道类和结构体之间的区别。区别很简单：Go语言没有类，因为它没有继承。这并不意味着Go语言没有一些面向对象语言的特性，只是它的实现方式有些不同。您将在[第7章](ch07.html#unique_chapter_id_07)中学到更多关于Go语言面向对象特性的内容。
- en: 'Most languages have a concept that’s similar to a struct, and the syntax that
    Go uses to read and write structs should look familiar:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都有类似结构体的概念，Go语言用于读取和写入结构体的语法看起来应该很熟悉：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A struct type is defined with the keyword `type`, the name of the struct type,
    the keyword `struct`, and a pair of braces (`{}`). Within the braces, you list
    the fields in the struct. Just as you put the variable name first and the variable
    type second in a `var` declaration, you put the struct field name first and the
    struct field type second. Also note that unlike in map literals, no commas separate
    the fields in a struct declaration. You can define a struct type inside or outside
    of a function. A struct type that’s defined within a function can be used only
    within that function. (You’ll learn more about functions in [Chapter 5](ch05.html#unique_chapter_id_05).)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型使用关键字`type`、结构体类型的名称、关键字`struct`和一对大括号`{}`定义。在大括号内，列出结构体的字段。就像在`var`声明中先放变量名后放变量类型一样，在结构体声明中先放结构体字段名后放结构体字段类型。还要注意，与映射字面量不同，结构体声明中没有逗号分隔字段。您可以在函数内或函数外定义结构体类型。在函数内定义的结构体类型只能在该函数内使用。（关于函数，您将在[第5章](ch05.html#unique_chapter_id_05)中学到更多。）
- en: Note
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, you can scope a struct definition to any block level. You’ll learn
    more about blocks in [Chapter 4](ch04.html#unique_chapter_id_04).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以将结构体定义作用域限定在任何块级别。在[第四章](ch04.html#unique_chapter_id_04)中你会学到更多关于块的知识。
- en: 'Once a struct type is declared, you can define variables of that type:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了结构体类型，就可以定义该类型的变量：
- en: '[PRE78]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here we are using a `var` declaration. Since no value is assigned to `fred`,
    it gets the zero value for the `person` struct type. A zero value struct has every
    field set to the field’s zero value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用了`var`声明。由于`fred`没有被赋值，它得到了`person`结构体类型的零值。零值结构体将所有字段设置为字段的零值。
- en: 'A *struct literal* can be assigned to a variable as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构体字面量*也可以分配给变量：'
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Unlike maps, there is no difference between assigning an empty struct literal
    and not assigning a value at all. Both initialize all fields in the struct to
    their zero values. There are two styles for a nonempty struct literal. First,
    a struct literal can be specified as a comma-separated list of values for the
    fields inside of braces:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与映射不同，分配空的结构体字面量和不分配任何值之间没有区别。两者都会将结构体中的所有字段初始化为它们的零值。非空结构体字面量有两种风格。首先，结构体字面量可以被指定为字段值的逗号分隔列表，放在大括号内：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When using this struct literal format, a value for every field in the struct
    must be specified, and the values are assigned to the fields in the order they
    were declared in the struct definition.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种结构体字面量格式时，必须为结构体中的每个字段指定一个值，并且这些值按照结构体定义中声明的顺序赋给字段。
- en: 'The second struct literal style looks like the map literal style:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种结构体字面量风格看起来像映射字面量的风格：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You use the names of the fields in the struct to specify the values. This style
    has some advantages. It allows you to specify the fields in any order, and you
    don’t need to provide a value for all fields. Any field not specified is set to
    its zero value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用结构体中字段的名称来指定值。这种风格有一些优势。它允许你以任意顺序指定字段，并且不需要为所有字段提供值。未指定的字段将被设置为其零值。
- en: 'You cannot mix the two struct literal styles: either all fields are specified
    with names, or none of them are. For small structs where all fields are always
    specified, the simpler struct literal style is fine. In other cases, use the names.
    It’s more verbose, but it makes clear what value is being assigned to what field
    without having to reference the struct definition. It’s also more maintainable.
    If you initialize a struct without using the field names and a future version
    of the struct adds additional fields, your code will no longer compile.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能混合这两种结构体字面量风格：要么所有字段都用名称指定，要么一个也不用。对于所有字段始终被指定的小结构体，简单的结构体字面量风格是可以接受的。在其他情况下，使用名称。这样更冗长，但清楚地表明了赋值给哪个字段的值，无需引用结构体定义。这也更易维护。如果你初始化结构体时不使用字段名称，并且结构体的未来版本添加了额外的字段，你的代码将不再编译。
- en: 'A field in a struct is accessed with dot notation:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体中的字段可以通过点表示法进行访问：
- en: '[PRE82]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Just as you use brackets for both reading and writing to a map, you use dotted
    notation for reading and writing to struct fields.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你用括号同时读取和写入映射一样，你可以使用点表示法读取和写入结构体字段。
- en: Anonymous Structs
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名结构体
- en: 'You can also declare that a variable implements a struct type without first
    giving the struct type a name. This is called an *anonymous struct*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明一个变量实现一个结构体类型，而不先给结构体类型命名。这称为*匿名结构体*：
- en: '[PRE83]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this example, the types of the variables `person` and `pet` are anonymous
    structs. You assign (and read) fields in an anonymous struct just as you do for
    a named struct type. Just as you can initialize an instance of a named struct
    with a struct literal, you can do the same for an anonymous struct as well.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，变量`person`和`pet`的类型是匿名结构体。你可以像对命名结构体类型一样，分配（和读取）匿名结构体中的字段。正如你可以用结构体字面量初始化命名结构体的实例一样，你也可以对匿名结构体做同样的事情。
- en: You might wonder when it’s useful to have a data type that’s associated only
    with a single instance. Anonymous structs are handy in two common situations.
    The first is when you translate external data into a struct or a struct into external
    data (like JSON or Protocol Buffers). This is called *unmarshaling* and *marshaling*
    data, respectively. You’ll learn how to do this in [“encoding/json”](ch13.html#json).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道，拥有仅关联于单个实例的数据类型何时有用。匿名结构体在两种常见情况下非常方便。第一种情况是当你将外部数据转换为结构体，或者将结构体转换为外部数据（如JSON或Protocol
    Buffers）时。分别称为*反序列化*和*序列化*数据。你将在[“encoding/json”](ch13.html#json)中学习如何做到这一点。
- en: Writing tests is another place where anonymous structs pop up. You’ll use a
    slice of anonymous structs when writing table-driven tests in [Chapter 15](ch15.html#unique_chapter_id_15).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试是匿名结构体出现的另一个地方。在[第 15 章](ch15.html#unique_chapter_id_15)中编写表驱动测试时，您将使用匿名结构体的切片。
- en: Comparing and Converting Structs
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较和转换结构体
- en: Whether a struct is comparable depends on the struct’s fields. Structs that
    are entirely composed of comparable types are comparable; those with slice or
    map fields are not (as you will see in later chapters, function and channel fields
    also prevent a struct from being comparable).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是否可比取决于结构体的字段。完全由可比较类型组成的结构体是可比较的；具有切片或映射字段的结构体不可比较（正如您将在后面的章节中看到的，函数和通道字段也会阻止结构体可比较）。
- en: Unlike in Python or Ruby, in Go there’s no magic method that can be overridden
    to redefine equality and make `==` and `!=` work for incomparable structs. You
    can, of course, write your own function that you use to compare structs.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 或 Ruby 不同，在 Go 中没有魔术方法可以被重写来重新定义相等性并使 `==` 和 `!=` 适用于不可比较的结构体。当然，您可以编写自己的函数来比较结构体。
- en: 'Just as Go doesn’t allow comparisons between variables of different primitive
    types, Go doesn’t allow comparisons between variables that represent structs of
    different types. Go does allow you to perform a type conversion from one struct
    type to another *if the fields of both structs have the same names, order, and
    types*. Let’s see what this means. Given this struct:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Go 不允许不同原始类型的变量之间的比较一样，Go 也不允许表示不同类型的结构体之间的比较。如果两个结构体的字段具有相同的名称、顺序和类型，Go
    允许你从一个结构体类型转换为另一个结构体类型。让我们看看这意味着什么。给定这个结构体：
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'you can use a type conversion to convert an instance of `firstPerson` to `secondPerson`,
    but you can’t use `==` to compare an instance of `firstPerson` and an instance
    of `secondPerson`, because they are different types:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类型转换将 `firstPerson` 的实例转换为 `secondPerson`，但是您不能使用 `==` 来比较 `firstPerson`
    的实例和 `secondPerson` 的实例，因为它们是不同的类型：
- en: '[PRE85]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can’t convert an instance of `firstPerson` to `thirdPerson`, because the
    fields are in a different order:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `firstPerson` 的实例转换为 `thirdPerson`，因为字段的顺序不同：
- en: '[PRE86]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can’t convert an instance of `firstPerson` to `fourthPerson` because the
    field names don’t match:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将 `firstPerson` 的实例转换为 `fourthPerson`，因为字段名称不匹配：
- en: '[PRE87]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, you can’t convert an instance of `firstPerson` to `fifthPerson` because
    there’s an additional field:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你不能将 `firstPerson` 的实例转换为 `fifthPerson`，因为有一个额外的字段：
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Anonymous structs add a small twist: if two struct variables are being compared
    and at least one has a type that’s an anonymous struct, you can compare them without
    a type conversion if the fields of both structs have the same names, order, and
    types. You can also assign between named and anonymous struct types if the fields
    of both structs have the same names, order, and types:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名结构体增加了一个小变化：如果正在比较两个结构体变量，并且至少有一个类型是匿名结构体，那么如果两个结构体的字段具有相同的名称、顺序和类型，您可以在不进行类型转换的情况下比较它们。如果两个结构体的字段具有相同的名称、顺序和类型，您还可以在命名和匿名结构体类型之间进行赋值：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Exercises
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: The following exercises will test what you’ve learned about Go’s composite types.
    You can find solutions in the *exercise_solutions* directory in the [Chapter 3
    Repository](https://oreil.ly/d2nrA).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将测试您对 Go 复合类型的了解。您可以在[第 3 章存储库](https://oreil.ly/d2nrA)的 *exercise_solutions*
    目录中找到解决方案。
- en: 'Write a program that defines a variable named `greetings` of type slice of
    strings with the following values: `"Hello"`, `"Hola"`, `"नमस्कार"`, `"こんにちは"`,
    and `"Привіт"`. Create a subslice containing the first two values; a second subslice
    with the second, third, and fourth values; and a third subslice with the fourth
    and fifth values. Print out all four slices.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，定义一个名为 `greetings` 的字符串切片类型的变量，其值为 `"Hello"`、`"Hola"`、`"नमस्कार"`、`"こんにちは"`
    和 `"Привіт"`。创建一个包含前两个值的子切片；第二个子切片包含第二、第三和第四个值；第三个子切片包含第四和第五个值。打印出所有四个切片。
- en: Write a program that defines a string variable called `message` with the value
    `"Hi ![](assets/woman.png) and ![](assets/man.png)"` and prints the fourth rune
    in it as a character, not a number.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，定义一个名为 `message` 的字符串变量，其值为 `"Hi ![](assets/woman.png) and ![](assets/man.png)"`，并打印出其中的第四个符文作为字符，而不是数字。
- en: 'Write a program that defines a struct called `Employee` with three fields:
    `firstName`, `lastName`, and `id`. The first two fields are of type `string`,
    and the last field (`id`) is of type `int`. Create three instances of this struct
    using whatever values you’d like. Initialize the first one using the struct literal
    style without names, the second using the struct literal style with names, and
    the third with a `var` declaration. Use dot notation to populate the fields in
    the third struct. Print out all three structs.'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，定义一个名为`Employee`的结构体，它包含三个字段：`firstName`、`lastName`和`id`。前两个字段的类型是`string`，最后一个字段（`id`）的类型是`int`。使用任意值创建三个此结构体的实例。第一个实例使用结构体字面量样式且没有字段名初始化，第二个实例使用结构体字面量样式并指定字段名，第三个实例使用`var`声明。使用点符号赋值填充第三个结构体的字段。打印出这三个结构体的所有信息。
- en: Wrapping Up
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: 'You’ve learned a lot about composite types in Go. In addition to learning more
    about strings, you now know how to use the built-in generic container types: slices
    and maps. You can also construct your own composite types via structs. In the
    next chapter, you’re going to take a look at Go’s control structures: `for`, `if/else`,
    and `switch`. You will also learn how Go organizes code into blocks and how the
    different block levels can lead to surprising behavior.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于Go语言中复合类型的知识。除了学习更多关于字符串的知识外，现在你还知道如何使用内置的通用容器类型：切片（slices）和映射（maps）。你还可以通过结构体构建自己的复合类型。在下一章中，你将看到Go语言的控制结构：`for`、`if/else`和`switch`。你还将了解Go语言如何将代码组织成块，并且不同的块级别可能会导致意想不到的行为。
