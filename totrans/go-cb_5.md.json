["```go\nvar numbers [10]int\nfmt.Println(numbers)\nrhyme := [4]string{\"twinkle\", \"twinkle\", \"little\", \"star\"}\nfmt.Println(rhyme)\n```", "```go\n[0 0 0 0 0 0 0 0 0 0]\n[twinkle twinkle little star]\n```", "```go\nvar integers []int\nfmt.Println(integers)\nvar sheep = []string{\"baa\", \"baa\", \"black\", \"sheep\"}\nfmt.Println(sheep)\n```", "```go\n[]\n[baa baa black sheep]\n```", "```go\nvar integers = make([]int, 10)\nfmt.Println(integers)\n```", "```go\n[0 0 0 0 0 0 0 0 0 0]\n```", "```go\nintegers = make([]int, 10, 15)\nfmt.Println(integers)\nfmt.Println(\"length:\", len(integers))\nfmt.Println(\"capacity:\", cap(integers))\n```", "```go\n[0 0 0 0 0 0 0 0 0 0]\nlength: 10\ncapacity: 15\n```", "```go\nvar ints *[]int = new([]int)\nfmt.Println(ints)\n```", "```go\n&[]\n```", "```go\nvar ints *[10]int = new([10]int)\nfmt.Println(ints)\n```", "```go\n&[0 0 0 0 0 0 0 0 0 0]\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 59}\n```", "```go\nnumbers[3] // 26\n```", "```go\nnumbers[2:4] // [159, 26]\n```", "```go\nnumbers[:4] // [3 14 159 26]\n```", "```go\nnumbers[2:] // [159 265 53 59]\n```", "```go\nnumbers := [6]int{3, 14, 159, 26, 53, 59} // an array\nnumbers[:] // this is a slice\n```", "```go\nfor i := 0; i < len(numbers); i++ {\n    fmt.Println(numbers[i])\n}\n```", "```go\n3\n14\n159\n25\n53\n59\n```", "```go\nfor i, v := range numbers {\n    fmt.Printf(\"i: %d, v: %d\\n\", i, v)\n}\n```", "```go\ni: 0, v: 3\ni: 1, v: 14\ni: 2, v: 159\ni: 3, v: 25\ni: 4, v: 53\ni: 5, v: 59\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers[2] = 1000\n```", "```go\n[3 14 1000 26 53 58 97]\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers = append(numbers, 97)\nfmt.Println(numbers)\n```", "```go\n[3 14 159 26 53 58 97]\n```", "```go\nnumbers = append(numbers, 97, 932, 38, 4, 626)\n```", "```go\nnums := []int{97, 932, 38, 4, 626}\nnumbers = append(numbers, nums...)\n```", "```go\nnumbers = append(numbers, 1, nums...) // this will produce an error\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers = append(numbers[:2+1], numbers[2:]...)\nnumbers[2] = 1000\n```", "```go\n[3 14 1000 159 26 53 58]\n```", "```go\nnumbers = append([]int{2000}, numbers...)\n```", "```go\nnumbers = []int{3, 14, 159, 26, 53, 58}\ninserted := []int{1000, 2000, 3000, 4000}\n\ntail := append([]int{}, numbers[2:]...)\nnumbers = append(numbers[:2], inserted...)\nnumbers = append(numbers, tail...)\n\nfmt.Println(numbers)\n```", "```go\n[3 14 1000 2000 3000 4000 159 26 53 58]\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers = numbers[1:] // remove element 0\nfmt.Println(numbers)\n```", "```go\n[14 159 26 53 58]\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers = numbers[:len(numbers)-1] // remove last element\nfmt.Println(numbers)\n```", "```go\n[3 14 159 26 53]\n```", "```go\nnumbers := []int{3, 14, 159, 26, 53, 58}\nnumbers = append(numbers[:2], numbers[3:]...)\nfmt.Println(numbers)\n```", "```go\n[3 14 26 53 58]\n```", "```go\nvar shared []int = []int{1, 2, 3, 4, 5, 6}\n\n// increase each element by 1\nfunc increase(num int) {\n\tfmt.Printf(\"[+%d a] : %v\\n\", num, shared)\n\tfor i := 0; i < len(shared); i++ {\n\t\ttime.Sleep(20 * time.Microsecond)\n\t\tshared[i] = shared[i] + 1\n\t}\n\tfmt.Printf(\"[+%d b] : %v\\n\", num, shared)\n}\n\n// decrease each element by 1\nfunc decrease(num int) {\n\tfmt.Printf(\"[-%d a] : %v\\n\", num, shared)\n\tfor i := 0; i < len(shared); i++ {\n\t\ttime.Sleep(10 * time.Microsecond)\n\t\tshared[i] = shared[i] - 1\n\t}\n\tfmt.Printf(\"[-%d b] : %v\\n\", num, shared)\n}\n```", "```go\nfunc main() {\n\tfor i := 0; i < 5; i++ {\n\t\tgo increase(i)\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tgo decrease(i)\n\t}\n\ttime.Sleep(2 * time.Second)\n}\n```", "```go\n[-4 a] : [1 2 3 4 5 6]\n[-1 a] : [0 2 3 4 5 6]\n[-2 a] : [0 1 3 4 5 6]\n[-3 a] : [0 1 2 4 5 6]\n[+0 a] : [-2 1 2 3 5 6]\n[+1 a] : [-3 -1 2 3 4 6]\n[-4 b] : [-2 -2 1 3 4 5]\n[+3 a] : [-2 -2 0 3 4 5]\n[+4 a] : [-1 -1 -1 1 4 5]\n[-1 b] : [1 0 0 0 1 4]\n[-2 b] : [1 0 0 0 1 3]\n[-3 b] : [1 0 0 0 1 2]\n[+2 a] : [1 0 0 0 1 2]\n[-0 a] : [2 2 1 1 1 2]\n[+0 b] : [1 2 3 2 1 3]\n[-0 b] : [1 2 3 3 2 2]\n[+1 b] : [1 2 3 4 4 3]\n[+3 b] : [1 2 3 4 4 4]\n[+4 b] : [1 2 3 4 4 5]\n[+2 b] : [1 2 3 4 5 6]\n```", "```go\nvar shared []int = []int{1, 2, 3, 4, 5, 6}\nvar mutex sync.Mutex\n\n// increase each element by 1\nfunc increaseWithMutex(num int) {\n\tmutex.Lock()\n\tfmt.Printf(\"[+%d a] : %v\\n\", num, shared)\n\tfor i := 0; i < len(shared); i++ {\n\t\ttime.Sleep(20 * time.Microsecond)\n\t\tshared[i] = shared[i] + 1\n\t}\n\tfmt.Printf(\"[+%d b] : %v\\n\", num, shared)\n\tmutex.Unlock()\n}\n\n// decrease each element by 1\nfunc decreaseWithMutex(num int) {\n\tmutex.Lock()\n\tfmt.Printf(\"[-%d a] : %v\\n\", num, shared)\n\tfor i := 0; i < len(shared); i++ {\n\t\ttime.Sleep(10 * time.Microsecond)\n\t\tshared[i] = shared[i] - 1\n\t}\n\tfmt.Printf(\"[-%d b] : %v\\n\", num, shared)\n\tmutex.Unlock()\n}\n}\n```", "```go\nUsing it is quite simple. Firstly we need to declare a mutex. Then, we call +Lock+ on the mutex before we start modifying the shared slice. This will lock up the shared slice such that nothing else can use it. When we're done, we call +Unlock+ to unlock the mutex.\n```", "```go\n[-4 a] : [1 2 3 4 5 6]\n[-4 b] : [0 1 2 3 4 5]\n[+0 a] : [0 1 2 3 4 5]\n[+0 b] : [1 2 3 4 5 6]\n[+1 a] : [1 2 3 4 5 6]\n[+1 b] : [2 3 4 5 6 7]\n[+2 a] : [2 3 4 5 6 7]\n[+2 b] : [3 4 5 6 7 8]\n[+3 a] : [3 4 5 6 7 8]\n[+3 b] : [4 5 6 7 8 9]\n[+4 a] : [4 5 6 7 8 9]\n[+4 b] : [5 6 7 8 9 10]\n[-0 a] : [5 6 7 8 9 10]\n[-0 b] : [4 5 6 7 8 9]\n[-1 a] : [4 5 6 7 8 9]\n[-1 b] : [3 4 5 6 7 8]\n[-2 a] : [3 4 5 6 7 8]\n[-2 b] : [2 3 4 5 6 7]\n[-3 a] : [2 3 4 5 6 7]\n[-3 b] : [1 2 3 4 5 6]\n```", "```go\nintegers := []int{3, 14, 159, 26, 53}\nfloats := []float64{3.14, 1.41, 1.73, 2.72, 4.53}\nstrings := []string{\"the\", \"quick\", \"brown\", \"fox\", \"jumped\"}\n\nsort.Ints(integers)\nsort.Float64s(floats)\nsort.Strings(strings)\n\nfmt.Println(integers)\nfmt.Println(floats)\nfmt.Println(strings)\n```", "```go\n[3 14 26 53 159]\n[1.41 1.73 2.72 3.14 4.53]\n[brown fox jumped quick the]\n```", "```go\nfor i := len(integers)/2 - 1; i >= 0; i-- {\n    opp := len(integers) - 1 - i\n    integers[i], integers[opp] = integers[opp], integers[i]\n}\n\nfmt.Println(integers)\n```", "```go\n[159 53 26 14 3]\n```", "```go\nsort.Slice(floats, func(i, j int) bool {\n    return floats[i] > floats[j]\n})\nfmt.Println(floats)\n```", "```go\n[4.53 3.14 2.72 1.73 1.41]\n```", "```go\npeople := []Person{\n\t{\"Alice\", 22},\n\t{\"Bob\", 18},\n\t{\"Charlie\", 23},\n\t{\"Dave\", 27},\n\t{\"Eve\", 31},\n}\nsort.Slice(people, func(i, j int) bool {\n\treturn people[i].Age < people[j].Age\n})\nfmt.Println(people)\n```", "```go\n[{Bob 18} {Alice 22} {Charlie 23} {Dave 27} {Eve 31}]\n```", "```go\ntype Person struct {\n\tName string\n\tAge  int\n}\n\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n```", "```go\npeople := []Person{\n\t{\"Alice\", 22},\n\t{\"Bob\", 18},\n\t{\"Charlie\", 23},\n\t{\"Dave\", 27},\n\t{\"Eve\", 31},\n}\n\nsort.Sort(ByAge(people))\nfmt.Println(people)\n```", "```go\n[{Bob 18} {Alice 22} {Charlie 23} {Dave 27} {Eve 31}]\n```", "```go\nsort.Sort(sort.Reverse(ByAge(people)))\nfmt.Println(people)\n```", "```go\n[{Eve 31} {Dave 27} {Charlie 23} {Alice 22} {Bob 18}]\n```", "```go\nsort.IsSorted(ByAge(people)) // true if it's sorted\n```", "```go\nfunc BenchmarkSortSlice(b *testing.B) {\n\tf := func(i, j int) bool {\n\t\treturn people[i].Age < people[j].Age\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsort.Slice(people, f)\n\t}\n}\n\nfunc BenchmarkSortInterface(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tsort.Sort(ByAge(people))\n\t}\n}\n```", "```go\n$ go test -bench=BenchmarkSort\ngoos: darwin\ngoarch: arm64\npkg: github.com/sausheong/gocookbook/ch14_data_structures\nBenchmarkSortSlice-10     \t 9376766\t       108.9 ns/op\nBenchmarkSortInterface-10  \t26790697\t        44.33 ns/op\nPASS\nok  \tgithub.com/sausheong/gocookbook/ch14_data_structures\t2.901s\n```", "```go\nvar people map[string]int\n```", "```go\npeople = make(map[string]int)\n```", "```go\npeople := make(map[string]int)\n```", "```go\npeople[\"Alice\"] = 22\n```", "```go\npeople := map[string]int{\n\t\"Alice\":   22,\n\t\"Bob\":     18,\n\t\"Charlie\": 23,\n\t\"Dave\":    27,\n\t\"Eve\":     31,\n}\n```", "```go\nmap[Alice:22 Bob:18 Charlie:23 Dave:27 Eve:31]\n```", "```go\npeople := map[string]int{\n\t\"Alice\":   22,\n\t\"Bob\":     18,\n\t\"Charlie\": 23,\n\t\"Dave\":    27,\n\t\"Eve\":     31,\n}\n\npeople[\"Alice\"] // 22\n```", "```go\npeople[\"Nemo\"] // 0\n```", "```go\nage, ok := people[\"Nemo\"]\nif ok {\n\t// do whatever you want if the value exists\n}\n```", "```go\nfor k, v := range people {\n\tfmt.Println(k, v)\n}\n```", "```go\nAlice 22\nBob 18\nCharlie 23\nDave 27\nEve 31\n```", "```go\nfor k := range people {\n\tfmt.Println(k)\n}\n```", "```go\nAlice\nBob\nCharlie\nDave\nEve\n```", "```go\nvar values []int\nfor _, v := range people {\n\tvalues = append(values, v)\n}\nfmt.Println(values)\n```", "```go\n[22 18 23 27 31]\n```", "```go\npeople[\"Alice\"] = 23\n```", "```go\ndelete(people, \"Alice\")\nfmt.Println(people)\n```", "```go\nmap[Bob:18 Charlie:23 Dave:27 Eve:31]\n```", "```go\nvar keys []string\nfor k := range people {\n\tkeys = append(keys, k)\n}\n```", "```go\n// sort keys by descending order\nfor i := len(keys)/2 - 1; i >= 0; i-- {\n\topp := len(keys) - 1 - i\n\tkeys[i], keys[opp] = keys[opp], keys[i]\n}\n```", "```go\nfor _, key := range keys {\n\tfmt.Println(key, people[key])\n}\n```", "```go\nEve 31\nDave 27\nCharlie 23\nBob 18\nAlice 22\n```"]