<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Generics"><div class="chapter" id="unique_chapter_id_08">
<h1><span class="label">Chapter 8. </span>Generics</h1>


<p>“Don’t repeat yourself” is common software engineering advice. It’s better to reuse a data structure or a function than it is to re-create it, because it’s hard to keep code changes in sync between duplicated code. In a strongly typed language like Go, the type of every function parameter and every struct field must be known at compile time. This strictness enables the compiler to help validate that your code is correct, but sometimes when you’ll want to reuse the logic in a function or the fields in a struct with different types. Go provides this functionality via type parameters, which are colloquially referred to as <em>generics</em>. In this chapter you’ll learn why people want generics, what Go’s implementation of generics can do, what generics can’t do, and how to use them properly.</p>






<section data-type="sect1" data-pdf-bookmark="Generics Reduce Repetitive Code and Increase Type Safety"><div class="sect1" id="id96">
<h1>Generics Reduce Repetitive Code and Increase Type Safety</h1>

<p>Go is a statically typed language,<a data-type="indexterm" data-primary="generic functions" data-secondary="repetitive code reduced" id="ch08-redu"/><a data-type="indexterm" data-primary="repetitive code reduced via generic functions" id="ch08-redu2"/> which means that the types of variables and parameters are checked when the code is compiled. Built-in types (maps, slices, channels) and functions (such as <code>len</code>, <code>cap</code>, or <code>make</code>) are able to accept and return values of different concrete types, but until Go 1.18, user-defined Go types and functions could not.</p>

<p>If you are accustomed to dynamically typed languages, where types are not evaluated until the code runs, you might not understand what the fuss is about generics, and you might be a bit unclear on what they are. It helps to think of them as “type parameters.” So far in this book, you’ve seen functions that take in parameters whose values are specified when the function is called. In <a data-type="xref" href="ch05.html#multiple_return">“Multiple Return Values”</a>, the function <code>divAndRemainder</code> has two <code>int</code> parameters and returns two <code>int</code> values:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">func</code><code class="w"> </code><code class="nx">divAndRemainder</code><code class="p">(</code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">denom</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">denom</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"cannot divide by zero"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">denom</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="nx">denom</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Similarly, you create structs by specifying the type for the fields when the struct is declared. Here, <code>Node</code> has a field of type <code>int</code> and another field of type <code>*Node</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Node</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">next</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In some situations, however, it’s useful to write functions or structs that leave the specific <em>type</em> of a parameter or field unspecified until it is used.</p>

<p>The case for generic types is easy to understand. In <a data-type="xref" href="ch07.html#nil_instances">“Code Your Methods for nil Instances”</a>, you looked at a binary tree for <code>int</code>s. <a data-type="indexterm" data-primary="binary trees" data-secondary="generic types for" id="id1812"/>If you want a binary tree for strings or float64s and want type safety, you have a few options. The first possibility is writing a custom tree for each type, but having that much duplicated code is verbose and error-prone.</p>

<p>Without generics, the only way to avoid duplicated code would be to modify your tree implementation so that it uses an interface to specify how to order values. The interface would look like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Orderable</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// Order returns:</code><code class="w"/>
<code class="w">    </code><code class="c1">// a value &lt; 0 when the Orderable is less than the supplied value,</code><code class="w"/>
<code class="w">    </code><code class="c1">// a value &gt; 0 when the Orderable is greater than the supplied value,</code><code class="w"/>
<code class="w">    </code><code class="c1">// and 0 when the two values are equal.</code><code class="w"/>
<code class="w">    </code><code class="nx">Order</code><code class="p">(</code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now that you have <code>Orderable</code>, you can modify your <code>Tree</code> implementation to support it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Tree</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="w">         </code><code class="nx">Orderable</code><code class="w"/>
<code class="w">    </code><code class="nx">left</code><code class="p">,</code><code class="w"> </code><code class="nx">right</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="p">)</code><code class="w"> </code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="nx">Orderable</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">t</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">Tree</code><code class="p">{</code><code class="nx">val</code><code class="p">:</code><code class="w"> </code><code class="nx">val</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">comp</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">val</code><code class="p">.</code><code class="nx">Order</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">val</code><code class="p">);</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">comp</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nx">t</code><code class="p">.</code><code class="nx">left</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">left</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">comp</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nx">t</code><code class="p">.</code><code class="nx">right</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">right</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">t</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With an <code>OrderableInt</code> type, you can then insert <code>int</code> values:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">OrderableInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">oi</code><code class="w"> </code><code class="nx">OrderableInt</code><code class="p">)</code><code class="w"> </code><code class="nx">Order</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">int</code><code class="p">(</code><code class="nx">oi</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">val</code><code class="p">.(</code><code class="nx">OrderableInt</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">it</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">OrderableInt</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">OrderableInt</code><code class="p">(</code><code class="mi">3</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="c1">// etc...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>While this code works correctly, it doesn’t allow the compiler to validate that the values inserted into your data structure are all the same. If you also had an <code>OrderableString</code> type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">OrderableString</code><code class="w"> </code><code class="kt">string</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">os</code><code class="w"> </code><code class="nx">OrderableString</code><code class="p">)</code><code class="w"> </code><code class="nx">Order</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Compare</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">os</code><code class="p">),</code><code class="w"> </code><code class="nx">val</code><code class="p">.(</code><code class="kt">string</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>the following code compiles:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">it</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="w"/>
<code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">OrderableInt</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code><code class="w"/>
<code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">OrderableString</code><code class="p">(</code><code class="s">"nope"</code><code class="p">))</code><code class="w"/></pre>

<p>The <code>Order</code> function uses <code>any</code> to represent the value that’s passed in. This effectively short-circuits one of Go’s primary advantages: checking compile-time type safety. When you compile code that attempts to insert an <code>OrderableString</code> into a <code>Tree</code> that already contains an <code>OrderableInt</code>, the compiler accepts the code. However, the program panics when run:</p>

<pre data-type="programlisting">panic: interface conversion: interface {} is main.OrderableInt, not string</pre>

<p>You can try out this code in the <em>sample_code/non_generic_tree</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1813"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1814"/></p>

<p>With generics, there’s a way to implement a data structure once for multiple types and detect incompatible data at compile time. You’ll see how to properly use them in just a bit.</p>

<p>While data structures without generics are inconvenient, the real limitation is in writing functions. <a data-type="indexterm" data-primary="standard library" data-secondary="generic functions added to" data-tertiary="implementations pre-generics" id="id1815"/>Several implementation decisions in Go’s standard library were made because generics weren’t originally part of the language. For example, rather than write multiple functions to handle different numeric types, Go implements functions like <code>math.Max</code>, <code>math.Min</code>, and <code>math.Mod</code> using <code>float64</code> parameters, which have a range big enough to represent nearly every other numeric type exactly. (The exceptions are an <code>int</code>, <code>int64</code>, or <code>uint</code> with a value greater than 2<sup>53</sup> – 1 or less than –2<sup>53</sup> – 1.)<a data-type="indexterm" data-startref="ch08-redu" id="id1816"/><a data-type="indexterm" data-startref="ch08-redu2" id="id1817"/></p>

<p>Some other things are<a data-type="indexterm" data-primary="generic functions" data-secondary="actions made possible by" id="id1818"/> impossible without generics. You cannot create a new instance of a variable that’s specified by an interface, nor can you specify that two parameters of the same interface type are also of the same concrete type. Without generics, you cannot write a function to process a slice of any type without resorting to reflection and giving up some performance along with compile-time type safety (this is how <code>sort.Slice</code> works). This meant that before generics were introduced to Go, functions that operate on slices (like <code>map</code>, <code>reduce</code>, and <code>filter</code>) would be repeatedly implemented for each type of slice. While simple algorithms are easy enough to copy, many (if not most) software engineers find it grating to duplicate code simply because the compiler isn’t smart enough to do it automatically.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Introducing Generics in Go"><div class="sect1" id="id97">
<h1>Introducing Generics in Go</h1>

<p>Since the first announcement of Go,<a data-type="indexterm" data-primary="generic functions" data-secondary="introducing" id="ch08-genin"/> people have called for generics to be added to the language.<a data-type="indexterm" data-primary="Cox, Russ" id="id1819"/><a data-type="indexterm" data-primary="generic functions" data-secondary="introducing" data-tertiary="why not initially included" id="id1820"/><a data-type="indexterm" data-primary="resources online" data-secondary="generic functions" data-tertiary="why not initially included" id="id1821"/> Russ Cox, the development lead for Go, wrote a <a href="https://oreil.ly/U4huA">blog post</a> in 2009 
<span class="keep-together">to explain</span> why generics weren’t initially included. Go emphasizes a fast compiler, readable code, and good execution time, and none of the generics implementations that they were aware of would allow them to include all three. <a data-type="indexterm" data-primary="generic functions" data-secondary="introducing" data-tertiary="Type Parameters Proposal URL" id="id1822"/><a data-type="indexterm" data-primary="resources online" data-secondary="generic functions" data-tertiary="Type Parameters Proposal" id="id1823"/>After a decade studying the problem, the Go team has a workable approach, which is outlined in the <a href="https://oreil.ly/31ay7">Type Parameters Proposal</a>.</p>

<p>You can see how generics work in Go<a data-type="indexterm" data-primary="stack" data-secondary="generic functions to create" id="id1824"/><a data-type="indexterm" data-primary="generic functions" data-secondary="introducing" data-tertiary="stack created via" id="id1825"/><a data-type="indexterm" data-primary="stack" id="id1826"/> by looking at a stack. If you don’t have a computer science background, a stack is a data type where values are added and removed in LIFO order. It’s like a pile of dishes waiting to be washed; the ones that were placed first are at the bottom, and you get to them only by working through the ones that were added later. Let’s see how to make a stack using generics:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Stack</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">vals</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="o">*</code><code class="nx">Stack</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Push</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="o">*</code><code class="nx">Stack</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Pop</code><code class="p">()</code><code class="w"> </code><code class="p">(</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="kd">var</code><code class="w"> </code><code class="nx">zero</code><code class="w"> </code><code class="nx">T</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">zero</code><code class="p">,</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">top</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">[</code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">[:</code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">top</code><code class="p">,</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There are a few things to note. <a data-type="indexterm" data-primary="any as type alias for empty interface" data-secondary="generic function creating a stack" id="id1827"/>First, you have <code>[T any]</code> after the type declaration. Type parameter information is placed within brackets and has two parts. The first part is the type parameter name. You can pick any name for the type parameter, but using capital letters is customary. <a data-type="indexterm" data-primary="generic functions" data-secondary="introducing" data-tertiary="type constraint" id="id1828"/>The second part is the <em>type constraint</em>, which uses a Go interface to specify which types are valid. If any type is usable, this is specified with the universe block identifier <code>any</code>, which you first saw in <a data-type="xref" href="ch07.html#empty_interface">“The Empty Interface Says Nothing”</a>. Inside the <code>Stack</code> declaration, you declare <code>vals</code> to be of type <code>[]T</code>.</p>

<p>Next, look at the method declarations. Just as you used <code>T</code> in your <code>vals</code> declaration, you do the same here. You also refer to the type in the receiver section with <code>Stack[T]</code> instead of <code>Stack</code>.</p>

<p>Finally, generics make zero value handling a little interesting. In <code>Pop</code>, you can’t just return <code>nil</code>, because that’s not a valid value for a value type, like <code>int</code>. The easiest way to get a zero value for a generic is to simply declare a variable with <code>var</code> and return it, since by definition, <code>var</code> always initializes its variable to the zero value if no other value is assigned.</p>

<p>Using a generic type is similar to using a nongeneric one:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">intStack</code><code class="w"> </code><code class="nx">Stack</code><code class="p">[</code><code class="kt">int</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nx">intStack</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">intStack</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">intStack</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">intStack</code><code class="p">.</code><code class="nx">Pop</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The only difference is that when you declare your variable, you include the type that you want to use with your <code>Stack</code>—in this case, <code>int</code>. If you try to push a string onto your stack, the compiler will catch it. Adding the line:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">intStack</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="s">"nope"</code><code class="p">)</code><code class="w"/></pre>

<p>produces the compiler error:</p>

<pre data-type="programlisting">cannot use "nope" (untyped string constant) as int value
  in argument to intStack.Push</pre>

<p>You can try out the generic stack on <a href="https://oreil.ly/9vzHB">The Go Playground</a> or in the <em>sample_code/stack</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1829"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1830"/></p>

<p>Add another method to your stack to tell you if the stack contains a value:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="nx">Stack</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Contains</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">s</code><code class="p">.</code><code class="nx">vals</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Unfortunately, this does not compile. It gives an error:</p>

<pre data-type="programlisting">invalid operation: v == val (type parameter T is not comparable with ==)</pre>

<p>Just as <code>interface{}</code> doesn’t say anything, neither does <code>any</code>. You can only store values of <code>any</code> type and retrieve them. <a data-type="indexterm" data-primary="comparison operators" data-secondary="comparable interface" id="id1831"/><a data-type="indexterm" data-primary="any as type alias for empty interface" data-secondary="comparable interface" id="id1832"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="comparable interface" id="id1833"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="comparable interface" id="id1834"/><a data-type="indexterm" data-primary="interfaces" data-secondary="comparable interface for any" id="id1835"/><a data-type="indexterm" data-primary="comparable interface" id="id1836"/>To use <code>==</code>, you need a different type. Since nearly all Go types can be compared with <code>==</code> and <code>!=</code>, a new built-in interface called <code>comparable</code> is defined in the universe block. If you change the definition of <code>Stack</code> to use 
<span class="keep-together"><code>comparable</code>:</span></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Stack</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">comparable</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">vals</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>you can then use your new method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="nx">Stack</code><code class="p">[</code><code class="kt">int</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nx">s</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">s</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">s</code><code class="p">.</code><code class="nx">Push</code><code class="p">(</code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">10</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This prints out the following:</p>

<pre data-type="programlisting">true
false</pre>

<p>You can try out this updated stack on <a href="https://oreil.ly/Qc4J3">The Go Playground</a> or in the <em>sample_code/comparable_stack</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.</p>

<p>Later, you’ll see how to make a generic binary tree. First, I’ll cover some additional concepts: <em>generic functions</em>, how generics work with interfaces, and <em>type terms</em>.<a data-type="indexterm" data-startref="ch08-genin" id="id1837"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Generic Functions Abstract Algorithms"><div class="sect1" id="generic_functions">
<h1>Generic Functions Abstract Algorithms</h1>

<p>As I have hinted, you can also<a data-type="indexterm" data-primary="generic functions" data-secondary="abstract algorithms" id="ch08-abal"/><a data-type="indexterm" data-primary="types" data-secondary="generic function abstract algorithms" id="ch08-abal2"/> write generic functions. Earlier I mentioned that not having generics made it difficult to write map, reduce, and filter implementations that work for all types. Generics make it easy. Here are implementations from the type parameters proposal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// Map turns a []T1 to a []T2 using a mapping function.</code><code class="w"/>
<code class="c1">// This function has two type parameters, T1 and T2.</code><code class="w"/>
<code class="c1">// This works with slices of any type.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">Map</code><code class="p">[</code><code class="nx">T1</code><code class="p">,</code><code class="w"> </code><code class="nx">T2</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">s</code><code class="w"> </code><code class="p">[]</code><code class="nx">T1</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">T1</code><code class="p">)</code><code class="w"> </code><code class="nx">T2</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="nx">T2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="nx">T2</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">r</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">r</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Reduce reduces a []T1 to a single value using a reduction function.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">Reduce</code><code class="p">[</code><code class="nx">T1</code><code class="p">,</code><code class="w"> </code><code class="nx">T2</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">s</code><code class="w"> </code><code class="p">[]</code><code class="nx">T1</code><code class="p">,</code><code class="w"> </code><code class="nx">initializer</code><code class="w"> </code><code class="nx">T2</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">T2</code><code class="p">,</code><code class="w"> </code><code class="nx">T1</code><code class="p">)</code><code class="w"> </code><code class="nx">T2</code><code class="p">)</code><code class="w"> </code><code class="nx">T2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">initializer</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">r</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">r</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// Filter filters values from a slice using a filter function.</code><code class="w"/>
<code class="c1">// It returns a new slice with only the elements of s</code><code class="w"/>
<code class="c1">// for which f returned true.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">Filter</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">s</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">r</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">r</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Functions place their type parameters after the function name and before the variable parameters. <code>Map</code> and <code>Reduce</code> have two type parameters, both of <code>any</code> type, while <code>Filter</code> has one. When you run the code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">words</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"One"</code><code class="p">,</code><code class="w"> </code><code class="s">"Potato"</code><code class="p">,</code><code class="w"> </code><code class="s">"Two"</code><code class="p">,</code><code class="w"> </code><code class="s">"Potato"</code><code class="p">}</code><code class="w"/>
<code class="nx">filtered</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Filter</code><code class="p">(</code><code class="nx">words</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">"Potato"</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">filtered</code><code class="p">)</code><code class="w"/>
<code class="nx">lengths</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Map</code><code class="p">(</code><code class="nx">filtered</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">lengths</code><code class="p">)</code><code class="w"/>
<code class="nx">sum</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Reduce</code><code class="p">(</code><code class="nx">lengths</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">acc</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">acc</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">val</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code><code class="w"/></pre>

<p>you get the output:</p>

<pre data-type="programlisting">[One Two]
[3 3]
6</pre>

<p>Try it for yourself on <a href="https://oreil.ly/Ahf2b">The Go Playground</a> or in the <em>sample_code/map_filter_reduce</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1838"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="id1839"/><a data-type="indexterm" data-startref="ch08-abal" id="id1840"/><a data-type="indexterm" data-startref="ch08-abal2" id="id1841"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Generics and Interfaces"><div class="sect1" id="id243">
<h1>Generics and Interfaces</h1>

<p>You can use any interface as a type constraint,<a data-type="indexterm" data-primary="generic functions" data-secondary="interfaces and" id="id1842"/><a data-type="indexterm" data-primary="interfaces" data-secondary="generic functions and" id="id1843"/><a data-type="indexterm" data-primary="types" data-secondary="type constraint via generic functions" id="id1844"/><a data-type="indexterm" data-primary="any as type alias for empty interface" data-secondary="comparable interface" data-tertiary="interfaces as type constraints" id="id1845"/><a data-type="indexterm" data-primary="comparable interface" data-secondary="interfaces as type constraints" id="id1846"/><a data-type="indexterm" data-primary="interfaces" data-secondary="comparable interface for any" data-tertiary="interfaces as type constraints" id="id1847"/> not just <code>any</code> and <code>comparable</code>. For example, say you wanted to make a type that holds any two values of the same type, as long as the type implements <code>fmt.Stringer</code>. Generics make it possible to enforce this at compile time:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Stringer</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Val1</code><code class="w"> </code><code class="nx">T</code><code class="w"/>
<code class="w">    </code><code class="nx">Val2</code><code class="w"> </code><code class="nx">T</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can also create interfaces that have type parameters. For example, here’s an interface with a method that compares against a value of the specified type and returns a <code>float64</code>. It also embeds <code>fmt.Stringer</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Differ</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Stringer</code><code class="w"/>
<code class="w">    </code><code class="nx">Diff</code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">float64</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You’ll use these two types to create a comparison function. The function takes in two <code>Pair</code> instances that have fields of type <code>Differ</code>, and returns the <code>Pair</code> with the closer values:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">FindCloser</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">Differ</code><code class="p">[</code><code class="nx">T</code><code class="p">]](</code><code class="nx">pair1</code><code class="p">,</code><code class="w"> </code><code class="nx">pair2</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">d1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">pair1</code><code class="p">.</code><code class="nx">Val1</code><code class="p">.</code><code class="nx">Diff</code><code class="p">(</code><code class="nx">pair1</code><code class="p">.</code><code class="nx">Val2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">d2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">pair2</code><code class="p">.</code><code class="nx">Val1</code><code class="p">.</code><code class="nx">Diff</code><code class="p">(</code><code class="nx">pair2</code><code class="p">.</code><code class="nx">Val2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">d1</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">d2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">pair1</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">pair2</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Note that <code>FindCloser</code> takes in <code>Pair</code> instances that have fields that meet the <code>Differ</code> interface. <code>Pair</code> requires that its fields are both of the same type and that the type meets the <code>fmt.Stringer</code> interface; this function is more selective. If the fields in a <code>Pair</code> instance don’t meet <code>Differ</code>, the compiler will prevent you from using that <code>Pair</code> instance with <code>FindCloser</code>.</p>

<p>Now define a couple of types that meet the <code>Differ</code> interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Point2D</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">X</code><code class="p">,</code><code class="w"> </code><code class="nx">Y</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p2</code><code class="w"> </code><code class="nx">Point2D</code><code class="p">)</code><code class="w"> </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"{%d,%d}"</code><code class="p">,</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">X</code><code class="p">,</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">Y</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p2</code><code class="w"> </code><code class="nx">Point2D</code><code class="p">)</code><code class="w"> </code><code class="nx">Diff</code><code class="p">(</code><code class="nx">from</code><code class="w"> </code><code class="nx">Point2D</code><code class="p">)</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">X</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">from</code><code class="p">.</code><code class="nx">X</code><code class="w"/>
<code class="w">    </code><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">Y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">from</code><code class="p">.</code><code class="nx">Y</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">math</code><code class="p">.</code><code class="nx">Sqrt</code><code class="p">(</code><code class="nb">float64</code><code class="p">(</code><code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">float64</code><code class="p">(</code><code class="nx">y</code><code class="o">*</code><code class="nx">y</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Point3D</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">X</code><code class="p">,</code><code class="w"> </code><code class="nx">Y</code><code class="p">,</code><code class="w"> </code><code class="nx">Z</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p3</code><code class="w"> </code><code class="nx">Point3D</code><code class="p">)</code><code class="w"> </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"{%d,%d,%d}"</code><code class="p">,</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">X</code><code class="p">,</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">Y</code><code class="p">,</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">Z</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p3</code><code class="w"> </code><code class="nx">Point3D</code><code class="p">)</code><code class="w"> </code><code class="nx">Diff</code><code class="p">(</code><code class="nx">from</code><code class="w"> </code><code class="nx">Point3D</code><code class="p">)</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">X</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">from</code><code class="p">.</code><code class="nx">X</code><code class="w"/>
<code class="w">    </code><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">Y</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">from</code><code class="p">.</code><code class="nx">Y</code><code class="w"/>
<code class="w">    </code><code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p3</code><code class="p">.</code><code class="nx">Z</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">from</code><code class="p">.</code><code class="nx">Z</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">math</code><code class="p">.</code><code class="nx">Sqrt</code><code class="p">(</code><code class="nb">float64</code><code class="p">(</code><code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">float64</code><code class="p">(</code><code class="nx">y</code><code class="o">*</code><code class="nx">y</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">float64</code><code class="p">(</code><code class="nx">z</code><code class="o">*</code><code class="nx">z</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>And here’s what it looks like to use this code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">pair2Da</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">Point2D</code><code class="p">]{</code><code class="nx">Point2D</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">},</code><code class="w"> </code><code class="nx">Point2D</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">}}</code><code class="w"/>
<code class="w">    </code><code class="nx">pair2Db</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">Point2D</code><code class="p">]{</code><code class="nx">Point2D</code><code class="p">{</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">},</code><code class="w"> </code><code class="nx">Point2D</code><code class="p">{</code><code class="mi">15</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">}}</code><code class="w"/>
<code class="w">    </code><code class="nx">closer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">FindCloser</code><code class="p">(</code><code class="nx">pair2Da</code><code class="p">,</code><code class="w"> </code><code class="nx">pair2Db</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">closer</code><code class="p">)</code><code class="w"/>

<code class="w">    </code><code class="nx">pair3Da</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">Point3D</code><code class="p">]{</code><code class="nx">Point3D</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">},</code><code class="w"> </code><code class="nx">Point3D</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">}}</code><code class="w"/>
<code class="w">    </code><code class="nx">pair3Db</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Pair</code><code class="p">[</code><code class="nx">Point3D</code><code class="p">]{</code><code class="nx">Point3D</code><code class="p">{</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">},</code><code class="w"> </code><code class="nx">Point3D</code><code class="p">{</code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">}}</code><code class="w"/>
<code class="w">    </code><code class="nx">closer2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">FindCloser</code><code class="p">(</code><code class="nx">pair3Da</code><code class="p">,</code><code class="w"> </code><code class="nx">pair3Db</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">closer2</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Run it for yourself on <a href="https://oreil.ly/rnKj9">The Go Playground</a> or in the <em>sample_code/generic_interface</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_hhhh"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_hhh"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Use Type Terms to Specify Operators"><div class="sect1" id="id99">
<h1>Use Type Terms to Specify Operators</h1>

<p>One more thing needs<a data-type="indexterm" data-primary="generic functions" data-secondary="operators via type terms" id="ch08-optt"/><a data-type="indexterm" data-primary="operator generic functions via type terms" id="ch08-optt2"/> to be represented with generics: operators. The <code>divAndRemainder</code> function works fine with <code>int</code>, but using it with other integer types requires type casting, and <code>uint</code> allows you to represent values that are too big for an <code>int</code>. <a data-type="indexterm" data-primary="types" data-secondary="type elements" id="ch08-optt3"/><a data-type="indexterm" data-primary="types" data-secondary="type elements" data-tertiary="type terms" id="ch08-optt4"/><a data-type="indexterm" data-primary="type elements" id="ch08-optt5"/><a data-type="indexterm" data-primary="type elements" data-secondary="type terms" id="ch08-optt6"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type elements" id="ch08-optt7"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type elements" data-tertiary="type terms" id="ch08-optt8"/>If you want to write a generic version of <code>divAndRemainder</code>, you need a way to specify that you can use <code>/</code> and <code>%</code>. Go generics do that with a <em>type element</em>, which is composed of one or more <em>type terms</em> within an interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Integer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int64</code><code class="w"> </code><code class="o">|</code><code class="w"/>
<code class="w">        </code><code class="kt">uint</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint64</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uintptr</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In <a data-type="xref" href="ch07.html#embed_interface">“Embedding and Interfaces”</a>, you learned about embedding interfaces to indicate that the method set of the containing interface includes the methods of the embedded interface. Type elements specify which types can be assigned to a type parameter and which operators are supported. They list concrete types separated by <code>|</code>. The allowed operators are the ones that are valid for <em>all</em> of the listed types. The modulus (<code>%</code>) operator is valid only for integers, so we list all integer types. (You can leave off <code>byte</code> and <code>rune</code> because they are type aliases for <code>uint8</code> and <code>int32</code>, respectively.)</p>

<p>Be aware that interfaces with type elements<a data-type="indexterm" data-primary="interfaces" data-secondary="type elements" data-tertiary="only valid as type constraints" id="id1848"/><a data-type="indexterm" data-primary="errors" data-secondary="compile-time errors" data-tertiary="type elements as other than type constraint" id="id1849"/> are valid only as type constraints. It is a compile-time error to use them as the type for a variable, field, return value, or parameter.</p>

<p>Now you can write your generic version of <code>divAndRemainder</code> and use it with the built-in <code>uint</code> type (or any of the other types listed in <code>Integer</code>):</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">divAndRemainder</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">Integer</code><code class="p">](</code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">denom</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">denom</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"cannot divide by zero"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">denom</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="nx">denom</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="kt">uint</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">18</code><code class="nx">_446_744_073_709_551_615</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="kt">uint</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">9</code><code class="nx">_223_372_036_854_775_808</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">divAndRemainder</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By default, type terms match exactly. If you try to use <code>divAndRemainder</code> with a user-defined type whose underlying type is one of the types listed in <code>Integer</code>, you’ll get an error. This code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">myA</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">myB</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">divAndRemainder</code><code class="p">(</code><code class="nx">myA</code><code class="p">,</code><code class="w"> </code><code class="nx">myB</code><code class="p">))</code><code class="w"/></pre>

<p>produces the following error:<a data-type="indexterm" data-primary="~ (tilde) for types with underlying type" id="id1850"/><a data-type="indexterm" data-primary="tilde (~) for types with underlying type" id="id1851"/><a data-type="indexterm" data-primary="type elements" data-secondary="type terms" data-tertiary="~ for types with underlying type" id="id1852"/><a data-type="indexterm" data-primary="types" data-secondary="type elements" data-tertiary="~ for types with underlying type" id="id1853"/></p>

<pre data-type="programlisting">MyInt does not satisfy Integer (possibly missing ~ for int in Integer)</pre>

<p>The error text gives a hint for how to solve this problem. If you want a type term to be valid for any type that has the type term as its underlying type, put a <code>~</code> before the type term. This changes the definition of <code>Integer</code> as follows:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Integer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">~</code><code class="kt">int</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int64</code><code class="w"> </code><code class="o">|</code><code class="w"/>
<code class="w">        </code><code class="o">~</code><code class="kt">uint</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint64</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uintptr</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can look at the generic version of the <code>divAndRemainder</code> function on <a href="https://oreil.ly/OLd32">The Go Playground</a> or in the <em>sample_code/type_terms</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.</p>

<p>The addition of type terms allows you to define a type that lets you write generic comparison functions:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Ordered</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">~</code><code class="kt">int</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">int64</code><code class="w"> </code><code class="o">|</code><code class="w"/>
<code class="w">        </code><code class="o">~</code><code class="kt">uint</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uint64</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">uintptr</code><code class="w"> </code><code class="o">|</code><code class="w"/>
<code class="w">        </code><code class="o">~</code><code class="kt">float32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="o">~</code><code class="kt">float64</code><code class="w"> </code><code class="o">|</code><code class="w"/>
<code class="w">        </code><code class="o">~</code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Ordered</code> interface lists all types that support the <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> operators. Having a way to specify that a variable represents an orderable type is so useful that Go 1.21 added the <a href="https://oreil.ly/nXRdO"><code>cmp</code> package</a>, which defines this <code>Ordered</code> interface. The package also defines two comparison functions. The <code>Compare</code> function returns either –1, 0, or 1, depending on whether its first parameter is less than, equal to, or greater than its second parameter, and the <code>Less</code> function returns <code>true</code> if its first parameter is less than its second parameter.</p>

<p>It is legal to have both type elements and method elements in an interface used for a type parameter. For example, you could specify that a type must have an underlying type of <code>int</code> and a <code>String() string</code> method:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">type</code><code class="w"> </code><code class="nx">PrintableInt</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">~</code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Be aware that Go will let you declare a type parameter interface that is impossible to actually instantiate. If you had used <code>int</code> instead of <code>~int</code> in <code>PrintableInt</code>, there would be no valid type that meets it, since <code>int</code> has no methods. This might seem bad, but the compiler still comes to your rescue. If you declare a type or function with an impossible type parameter, any attempt to use it causes a compiler error. Assume you declare these types:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">ImpossiblePrintableInt</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">ImpossibleStruct</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">ImpossiblePrintableInt</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="w"> </code><code class="nx">T</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">mi</code><code class="w"> </code><code class="nx">MyInt</code><code class="p">)</code><code class="w"> </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprint</code><code class="p">(</code><code class="nx">mi</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Even though you cannot instantiate <code>ImpossibleStruct</code>, the compiler has no problem with any of these declarations. However, once you try using <code>ImpossibleStruct</code>, the compiler complains. This code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ImpossibleStruct</code><code class="p">[</code><code class="kt">int</code><code class="p">]{</code><code class="mi">10</code><code class="p">}</code><code class="w"/>
<code class="nx">s2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ImpossibleStruct</code><code class="p">[</code><code class="nx">MyInt</code><code class="p">]{</code><code class="mi">10</code><code class="p">}</code><code class="w"/></pre>

<p>produces the following compile-time errors:<a data-type="indexterm" data-primary="errors" data-secondary="compile-time errors" data-tertiary="impossible type parameter interface instantiated" id="id1854"/></p>

<pre data-type="programlisting">int does not implement ImpossiblePrintableInt (missing String method)
MyInt does not implement ImpossiblePrintableInt (possibly missing ~ for
int in constraint ImpossiblePrintableInt)</pre>

<p>Try this on <a href="https://oreil.ly/eFx6t">The Go Playground</a> or in the <em>sample_code/impossible</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.</p>

<p>In addition to built-in primitive types, type terms can also be slices, maps, arrays, channels, structs, or even functions. They are most useful when you want to ensure that a type parameter has a specific underlying type and one or more methods.<a data-type="indexterm" data-startref="ch08-optt" id="id1855"/><a data-type="indexterm" data-startref="ch08-optt2" id="id1856"/><a data-type="indexterm" data-startref="ch08-optt3" id="id1857"/><a data-type="indexterm" data-startref="ch08-optt4" id="id1858"/><a data-type="indexterm" data-startref="ch08-optt5" id="id1859"/><a data-type="indexterm" data-startref="ch08-optt6" id="id1860"/><a data-type="indexterm" data-startref="ch08-optt7" id="id1861"/><a data-type="indexterm" data-startref="ch08-optt8" id="id1862"/></p>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Type Inference and Generics"><div class="sect1" id="id100">
<h1>Type Inference and Generics</h1>

<p>Just as Go supports type inference<a data-type="indexterm" data-primary="generic functions" data-secondary="type inference and" id="id1863"/><a data-type="indexterm" data-primary="type inference and generic functions" id="id1864"/><a data-type="indexterm" data-primary="types" data-secondary="generic functions and type inference" id="id1865"/> when using the <code>:=</code> operator, it also supports type inference to simplify calls to generic functions. You can see this in the calls to <code>Map</code>, <code>Filter</code>, and <code>Reduce</code> earlier. In some situations, type inference isn’t possible (for example, when a type parameter is used only as a return value). When that happens, all type arguments must be specified. Here’s a slightly silly bit of code that demonstrates a situation where type inference doesn’t work:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Integer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">int64</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint8</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint16</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint32</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kt">uint64</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Convert</code><code class="p">[</code><code class="nx">T1</code><code class="p">,</code><code class="w"> </code><code class="nx">T2</code><code class="w"> </code><code class="nx">Integer</code><code class="p">](</code><code class="nx">in</code><code class="w"> </code><code class="nx">T1</code><code class="p">)</code><code class="w"> </code><code class="nx">T2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">T2</code><code class="p">(</code><code class="nx">in</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Convert</code><code class="p">[</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">int64</code><code class="p">](</code><code class="nx">a</code><code class="p">)</code><code class="w"> </code><code class="c1">// can't infer the return type</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Try it out on <a href="https://oreil.ly/tWsu3">The Go Playground</a> or in the <em>sample_code/type_inference</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-startref="ix_hhhh" id="id1866"/><a data-type="indexterm" data-startref="ix_hhh" id="id1867"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Type Elements Limit Constants"><div class="sect1" id="id244">
<h1>Type Elements Limit Constants</h1>

<p>Type elements also specify which constants<a data-type="indexterm" data-primary="type elements" data-secondary="constants that can be assigned to variables" id="id1868"/><a data-type="indexterm" data-primary="types" data-secondary="type elements" data-tertiary="constants that can be assigned to variables" id="id1869"/><a data-type="indexterm" data-primary="const keyword" data-secondary="constants" data-tertiary="generic type assignments" id="id1870"/>
can be assigned to variables of the generic type. Like operators, the constants need to be valid for all the type terms in the type element. There are no constants that can be assigned to every listed type in 
<span class="keep-together"><code>Ordered</code>,</span> so you cannot assign a constant to a variable of that generic type. If you use the <code>Integer</code> interface, the following code will not compile, because you cannot assign the value 1,000 to an 8-bit integer:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// INVALID!</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">PlusOneThousand</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">Integer</code><code class="p">](</code><code class="nx">in</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="nx">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">in</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="nx">_000</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>However, this is valid:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// VALID</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">PlusOneHundred</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">Integer</code><code class="p">](</code><code class="nx">in</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="nx">T</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">in</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">100</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Combining Generic Functions with Generic &#10;Data Structures"><div class="sect1" id="id101">
<h1>Combining Generic Functions with Generic 
<span class="keep-together">Data Structures</span></h1>

<p>Let’s return to the binary tree example<a data-type="indexterm" data-primary="generic functions" data-secondary="generic data structures with" id="ch08-genfd"/><a data-type="indexterm" data-primary="generic data structures with generic functions" id="ch08-genfd2"/><a data-type="indexterm" data-primary="binary trees" data-secondary="generic functions with generic data structures" id="ch08-genfd3"/> and see how to combine everything you’ve learned to make a single tree that works for any concrete type.</p>

<p>The secret is to realize that what your tree needs is a single generic function that compares two values and tells you their order:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">OrderableFunc</code><code class="w"> </code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">t1</code><code class="p">,</code><code class="w"> </code><code class="nx">t2</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>

<p>Now that you have <code>OrderableFunc</code>, you can modify your tree implementation slightly.
First, you’re going to split it into two types, <code>Tree</code> and <code>Node</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Tree</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="w">    </code><code class="nx">OrderableFunc</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nx">root</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="w">         </code><code class="nx">T</code><code class="w"/>
<code class="w">    </code><code class="nx">left</code><code class="p">,</code><code class="w"> </code><code class="nx">right</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You construct a new <code>Tree</code> with a constructor function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">NewTree</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">f</code><code class="w"> </code><code class="nx">OrderableFunc</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">Tree</code><code class="p">[</code><code class="nx">T</code><code class="p">]{</code><code class="w"/>
<code class="w">        </code><code class="nx">f</code><code class="p">:</code><code class="w"> </code><code class="nx">f</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><code>Tree</code> ’s methods are very simple, because they just call <code>Node</code> to do all the real work:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Add</code><code class="p">(</code><code class="nx">v</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">t</code><code class="p">.</code><code class="nx">root</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">root</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="o">*</code><code class="nx">Tree</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Contains</code><code class="p">(</code><code class="nx">v</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">root</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Add</code> and <code>Contains</code> methods on <code>Node</code> are very similar to what you’ve seen before.
The only difference is that the function you are using to order your elements is passed in:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Add</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="nx">OrderableFunc</code><code class="p">[</code><code class="nx">T</code><code class="p">],</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">n</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">]{</code><code class="nx">val</code><code class="p">:</code><code class="w"> </code><code class="nx">v</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">val</code><code class="p">);</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nx">n</code><code class="p">.</code><code class="nx">left</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">left</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">1</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nx">n</code><code class="p">.</code><code class="nx">right</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">right</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">n</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="o">*</code><code class="nx">Node</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Contains</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="nx">OrderableFunc</code><code class="p">[</code><code class="nx">T</code><code class="p">],</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">n</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">val</code><code class="p">);</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">left</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">1</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">n</code><code class="p">.</code><code class="nx">right</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now you need a function that matches the <code>OrderedFunc</code> definition. Luckily, you’ve already seen one: <code>Compare</code> in the <code>cmp</code> package. When you use it with your <code>Tree</code>, it looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">t1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewTree</code><code class="p">(</code><code class="nx">cmp</code><code class="p">.</code><code class="nx">Compare</code><code class="p">[</code><code class="kt">int</code><code class="p">])</code><code class="w"/>
<code class="nx">t1</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="nx">t1</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="nx">t1</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">15</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t1</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">15</code><code class="p">))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t1</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">40</code><code class="p">))</code><code class="w"/></pre>

<p>For structs, you have two options. You can write a function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">OrderPeople</code><code class="p">(</code><code class="nx">p1</code><code class="p">,</code><code class="w"> </code><code class="nx">p2</code><code class="w"> </code><code class="nx">Person</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">cmp</code><code class="p">.</code><code class="nx">Compare</code><code class="p">(</code><code class="nx">p1</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">cmp</code><code class="p">.</code><code class="nx">Compare</code><code class="p">(</code><code class="nx">p1</code><code class="p">.</code><code class="nx">Age</code><code class="p">,</code><code class="w"> </code><code class="nx">p2</code><code class="p">.</code><code class="nx">Age</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Then you can pass that function in when you create your tree:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">t2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewTree</code><code class="p">(</code><code class="nx">OrderPeople</code><code class="p">)</code><code class="w"/>
<code class="nx">t2</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">})</code><code class="w"/>
<code class="nx">t2</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Maria"</code><code class="p">,</code><code class="w"> </code><code class="mi">35</code><code class="p">})</code><code class="w"/>
<code class="nx">t2</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t2</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">}))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t2</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Fred"</code><code class="p">,</code><code class="w"> </code><code class="mi">25</code><code class="p">}))</code><code class="w"/></pre>

<p>Instead of using a function, you can also supply a method to <code>NewTree</code>. As I talked about in <a data-type="xref" href="ch07.html#method_function">“Methods Are Functions Too”</a>, you can use a method expression to treat a method like a function. Let’s do that here. First, write the method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="nx">Person</code><code class="p">)</code><code class="w"> </code><code class="nx">Order</code><code class="p">(</code><code class="nx">other</code><code class="w"> </code><code class="nx">Person</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">cmp</code><code class="p">.</code><code class="nx">Compare</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">cmp</code><code class="p">.</code><code class="nx">Compare</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">Age</code><code class="p">,</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Age</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>And then use it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">t3</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewTree</code><code class="p">(</code><code class="nx">Person</code><code class="p">.</code><code class="nx">Order</code><code class="p">)</code><code class="w"/>
<code class="nx">t3</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">})</code><code class="w"/>
<code class="nx">t3</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Maria"</code><code class="p">,</code><code class="w"> </code><code class="mi">35</code><code class="p">})</code><code class="w"/>
<code class="nx">t3</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t3</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">}))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t3</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">Person</code><code class="p">{</code><code class="s">"Fred"</code><code class="p">,</code><code class="w"> </code><code class="mi">25</code><code class="p">}))</code><code class="w"/></pre>

<p>You can find the code for this tree on <a href="https://oreil.ly/-tus2">The Go Playground</a> or in the <em>sample_code/generic_tree</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_hhh123"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_h123h"/><a data-type="indexterm" data-startref="ch08-genfd" id="id1871"/><a data-type="indexterm" data-startref="ch08-genfd2" id="id1872"/><a data-type="indexterm" data-startref="ch08-genfd3" id="id1873"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="More on comparable"><div class="sect1" id="id102">
<h1>More on comparable</h1>

<p>As you saw in <a data-type="xref" href="ch07.html#compare_interfaces">“Interfaces Are Comparable”</a>, interfaces<a data-type="indexterm" data-primary="comparable interface" id="id1874"/><a data-type="indexterm" data-primary="any as type alias for empty interface" data-secondary="comparable interface" id="id1875"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="comparable interface" id="id1876"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="comparable interface" id="id1877"/><a data-type="indexterm" data-primary="interfaces" data-secondary="comparable interface for any" id="id1878"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="comparable interface" id="id1879"/><a data-type="indexterm" data-primary="interfaces" data-secondary="as comparable" data-secondary-sortas="comparable" id="id1880"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="interfaces comparable" id="id1881"/><a data-type="indexterm" data-primary="panics" data-secondary="comparing uncomparable types" id="id1882"/>are one of the comparable types in Go. This means that you need to be careful when using <code>==</code> and <code>!=</code> with variables of the interface type. If the underlying type of the interface is not comparable, your code panics at runtime.</p>

<p>This pothole still exists when using the <code>comparable</code> interface with generics.<a data-type="indexterm" data-primary="generic functions" data-secondary="operators via type terms" data-tertiary="comparable interface with generics" id="id1883"/> Say you’ve defined an interface and a couple of implementations:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Thinger</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Thing</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">ThingerInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="nx">ThingerInt</code><code class="p">)</code><code class="w"> </code><code class="nx">Thing</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"ThingInt:"</code><code class="p">,</code><code class="w"> </code><code class="nx">t</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">ThingerSlice</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="nx">ThingerSlice</code><code class="p">)</code><code class="w"> </code><code class="nx">Thing</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"ThingSlice:"</code><code class="p">,</code><code class="w"> </code><code class="nx">t</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">You also define a generic function that accepts only values that are <code>comparable</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Comparer</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">comparable</code><code class="p">](</code><code class="nx">t1</code><code class="p">,</code><code class="w"> </code><code class="nx">t2</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">t1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">t2</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"equal!"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It’s legal to call this function with variables of type <code>int</code> or <code>ThingerInt</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">Comparer</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">a2</code><code class="w"> </code><code class="nx">ThingerInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b2</code><code class="w"> </code><code class="nx">ThingerInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">Comparer</code><code class="p">(</code><code class="nx">a2</code><code class="p">,</code><code class="w"> </code><code class="nx">b2</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/></pre>

<p>The compiler won’t allow you to call this function with variables of type <code>ThingerSlice</code> (or <code>[]int</code>):</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">a3</code><code class="w"> </code><code class="nx">ThingerSlice</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b3</code><code class="w"> </code><code class="nx">ThingerSlice</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="nx">Comparer</code><code class="p">(</code><code class="nx">a3</code><code class="p">,</code><code class="w"> </code><code class="nx">b3</code><code class="p">)</code><code class="w"> </code><code class="c1">// compile fails: "ThingerSlice does not satisfy comparable"</code><code class="w"/></pre>

<p>However, it’s perfectly legal to call it with variables of type <code>Thinger</code>. If you use <code>ThingerInt</code>, the code compiles and works as expected:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">a4</code><code class="w"> </code><code class="nx">Thinger</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">a2</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b4</code><code class="w"> </code><code class="nx">Thinger</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">b2</code><code class="w"/>
<code class="nx">Comparer</code><code class="p">(</code><code class="nx">a4</code><code class="p">,</code><code class="w"> </code><code class="nx">b4</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/></pre>

<p>But you can also assign <code>ThingerSlice</code> to variables of type <code>Thinger</code>. That’s where things go wrong:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">a4</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">a3</code><code class="w"/>
<code class="nx">b4</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">b3</code><code class="w"/>
<code class="nx">Comparer</code><code class="p">(</code><code class="nx">a4</code><code class="p">,</code><code class="w"> </code><code class="nx">b4</code><code class="p">)</code><code class="w"> </code><code class="c1">// compiles, panics at runtime</code><code class="w"/></pre>

<p>The compiler won’t stop you from building this code, but if you run it, your program will panic with the message <code>panic: runtime error: comparing uncomparable type main.ThingerSlice</code> (see <a data-type="xref" href="ch09.html#panic_recover">“panic and recover”</a> for more information). You can try this code yourself on <a href="https://oreil.ly/NVIA4">The Go Playground</a> or in the <em>sample_code/more_comparable</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-startref="ix_hhh123" id="id1884"/><a data-type="indexterm" data-startref="ix_h123h" id="id1885"/></p>

<p>For more technical details on how comparable types and generics interact and why this design decision was made, read the blog post <a href="https://oreil.ly/AsWs-">“All Your Comparable Types”</a> from Robert Griesemer on the Go team.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Things That Are Left Out"><div class="sect1" id="id103">
<h1>Things That Are Left Out</h1>

<p>Go remains a small, focused language,<a data-type="indexterm" data-primary="generic functions" data-secondary="features not implemented in Go" id="ch08-not"/> and the generics implementation for Go doesn’t include many features that are found in generics implementations in other languages. This section describes some of the features that are not in the initial implementation of Go generics.</p>

<p>While  you can build a single tree that works with both user-defined and built-in types, languages like Python, Ruby, and C++ solve this problem in a different way. <a data-type="indexterm" data-primary="operator overloading not part of Go" id="id1886"/>They include <em>operator overloading</em>, which allows user-defined types to specify implementations for operators. Go will not be adding this feature. This means that you can’t use <code>range</code> to iterate over user-defined container types or <code>[]</code> to index into them.</p>

<p>There are good reasons for leaving out operator overloading. For one thing, Go has a surprisingly large number of operators. Go also doesn’t have function or method overloading, and you’d need a way to specify different operator functionality for different types. Furthermore, operator overloading can lead to code that’s harder to follow as developers invent clever meanings for symbols (in C++, <code>&lt;&lt;</code> means “shift bits left” for some types and “write the value on the right to the value on the left” for others). These are the sorts of readability issues that Go tries to avoid.</p>

<p>Another useful feature that’s been left out of the initial Go generics implementation is additional type parameters on methods. Looking back on the <code>Map/Reduce/Filter</code> functions, you might think they’d be useful as methods, like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">functionalSlice</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">]</code><code class="w"> </code><code class="p">[]</code><code class="nx">T</code><code class="w"/>

<code class="c1">// THIS DOES NOT WORK</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">fs</code><code class="w"> </code><code class="nx">functionalSlice</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Map</code><code class="p">[</code><code class="nx">E</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="nx">E</code><code class="p">)</code><code class="w"> </code><code class="nx">functionalSlice</code><code class="p">[</code><code class="nx">E</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="nx">functionalSlice</code><code class="p">[</code><code class="nx">E</code><code class="p">],</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">fs</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">fs</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// THIS DOES NOT WORK</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">fs</code><code class="w"> </code><code class="nx">functionalSlice</code><code class="p">[</code><code class="nx">T</code><code class="p">])</code><code class="w"> </code><code class="nx">Reduce</code><code class="p">[</code><code class="nx">E</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">start</code><code class="w"> </code><code class="nx">E</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">E</code><code class="p">,</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="nx">E</code><code class="p">)</code><code class="w"> </code><code class="nx">E</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">start</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">fs</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">f</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>which you could use like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">numStrings</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">functionalSlice</code><code class="p">[</code><code class="kt">string</code><code class="p">]{</code><code class="s">"1"</code><code class="p">,</code><code class="w"> </code><code class="s">"2"</code><code class="p">,</code><code class="w"> </code><code class="s">"3"</code><code class="p">}</code><code class="w"/>
<code class="nx">sum</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">numStrings</code><code class="p">.</code><code class="nx">Map</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">Atoi</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">v</code><code class="w"/>
<code class="p">}).</code><code class="nx">Reduce</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">acc</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">cur</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">acc</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">cur</code><code class="w"/>
<code class="p">})</code><code class="w"/></pre>

<p>Unfortunately for fans of functional programming, this does not work. Rather than chaining method calls together, you need to either nest function calls or use the much more readable approach of invoking the functions one at a time and assigning the intermediate values to variables. The type parameter proposal goes into detail on the reasons for excluding parameterized methods.</p>

<p>Go also has no variadic type parameters.<a data-type="indexterm" data-primary="variadic type parameters not part of Go" id="id1887"/> As discussed in <a data-type="xref" href="ch05.html#vararg">“Variadic Input Parameters and Slices”</a>, to implement a function that takes in a varying number of parameters, you specify that the last parameter type starts with <code>...</code>. For example, there’s no way to specify some sort of type pattern to those variadic parameters, such as alternating <code>string</code> and <code>int</code>. All variadic variables must match a single declared type, which can be generic or not.</p>

<p>Other features left out of Go generics are more esoteric. These include the following:</p>
<dl>
<dt>Specialization</dt>
<dd>
<p>A function or method can be overloaded with one or more type-specific versions in addition to the generic version. Since Go doesn’t have overloading, this feature is not under consideration.</p>
</dd>
<dt>Currying</dt>
<dd>
<p>Allows you to partially instantiate a function or type based on another generic function or type by specifying some of the type parameters.</p>
</dd>
<dt>Metaprogramming</dt>
<dd>
<p>Allows you to specify code that runs at compile time to produce code that runs at runtime.<a data-type="indexterm" data-startref="ch08-not" id="id1888"/></p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Idiomatic Go and Generics"><div class="sect1" id="generic_speed">
<h1>Idiomatic Go and Generics</h1>

<p>Adding generics clearly changes some<a data-type="indexterm" data-primary="generic functions" data-secondary="idiomatic Go and" id="id1889"/> of the advice for how to use Go idiomatically. The use of <code>float64</code> to represent any numeric type will end. You should use <code>any</code> instead of <code>interface{}</code> to represent an unspecified type in a data structure or function parameter. You can handle different slice types with a single function. But don’t feel the need to switch all your code over to using type parameters immediately. Your old code will still work as new design patterns are invented and refined.</p>

<p>It’s still too early to judge the long-term impact of generics on performance. As of this writing, there’s no impact on compilation time. The Go 1.18 compiler was slower than previous versions, but the compiler in Go 1.20 resolved this issue.</p>

<p>Some research has also been done on the<a data-type="indexterm" data-primary="Go runtime" data-secondary="generic function impact on performance" id="id1890"/><a data-type="indexterm" data-primary="Marti, Vicent" id="id1891"/><a data-type="indexterm" data-primary="resources online" data-secondary="Go runtime" data-tertiary="performance and generics" id="id1892"/><a data-type="indexterm" data-primary="Bendersky, Eli" id="id1893"/> runtime impact of generics. Vicent Marti wrote a <a href="https://oreil.ly/YK4HT">detailed blog post</a> exploring cases where generics result in slower code and the
implementation details that explain why this is so. Conversely, Eli Bendersky wrote a <a href="https://oreil.ly/2Mqms">blog post</a> that shows that generics make sorting algorithms faster.</p>

<p>In particular, do not change a function that has an interface parameter into a function with a generic type parameter in hopes of improving performance. For example, converting this trivial function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Ager</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="p">()</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">doubleAge</code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="nx">Ager</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">age</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>into:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doubleAgeGeneric</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="nx">Ager</code><code class="p">](</code><code class="nx">a</code><code class="w"> </code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">age</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>makes the function call about 30% slower in Go 1.20. (For a nontrivial function, there’s no significant performance difference.) You can run the benchmarks using the code in the <em>sample_code/perf</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_hhh1234"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 8" data-tertiary-sortas="hhh" id="ix_h1234h"/></p>

<p>This might be surprising for developers experienced with generics in other languages. In C++, for example, the compiler uses generics on abstract data types to turn what is normally a runtime operation (figuring out which concrete type is being used) into a compile-time one, generating a unique function for each concrete type. This makes the resulting binary larger but also faster. As Vicent explains in his blog post, the current Go compiler generates only unique functions for different underlying types. Furthermore, all pointer types share a single generated function. To differentiate between the different types that are passed in to shared generated functions, the compiler adds additional runtime lookups. This causes the slowdown in performance.</p>

<p>Again, as the generics implementation matures in future versions of Go, expect runtime performance to improve. As always, the goal is to write maintainable programs that are fast enough to meet your needs. Use the benchmarking and profiling tools that are discussed in <a data-type="xref" href="ch15.html#benchmarking">“Using Benchmarks”</a> to measure and improve your code.</p>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Adding Generics to the Standard Library"><div class="sect1" id="slice_map_funcs">
<h1>Adding Generics to the Standard Library</h1>

<p>The initial release of generics in Go 1.18 was<a data-type="indexterm" data-primary="standard library" data-secondary="generic functions added to" id="id1894"/><a data-type="indexterm" data-primary="generic functions" data-secondary="adding to standard library" id="id1895"/> very conservative. It added the new interfaces <code>any</code> and <code>comparable</code> to the universe block, but no API changes occurred in the standard library to support generics. A stylistic change has been made; virtually all uses of <code>interface{}</code> in the standard library were replaced with <code>any</code>.</p>

<p>Now that the Go community is more comfortable with generics, we are starting to see more changes. Starting with Go 1.21, the standard library includes functions that use generics to implement common algorithms for slices, maps, and concurrency. In <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>, I covered the <code>Equal</code> and <code>EqualFunc</code> functions in the <code>slices</code> and <code>maps</code> packages. Other functions in these packages simplify slice and map manipulation. The <code>Insert</code>, <code>Delete</code>, and <code>DeleteFunc</code> functions in the <code>slices</code> package allow developers to avoid building some surprisingly tricky slice-handling code. The <code>maps.Clone</code> function takes advantage of the Go runtime to provide a faster way to create a shallow copy of a map.  In <a data-type="xref" href="ch12.html#sync_once">“Run Code Exactly Once”</a>, you’ll learn about <code>sync.OnceValue</code> and <code>sync.OnceValues</code>, which use generics to build functions that are invoked only once and return one or two values. Prefer using functions in these packages over writing your own implementations. Future versions of the standard library will likely include additional new functions and types that take advantage of generics.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Future Features Unlocked"><div class="sect1" id="id246">
<h1>Future Features Unlocked</h1>

<p>Generics might be the basis for other future features.<a data-type="indexterm" data-primary="generic functions" data-secondary="future feature possibilities" id="id1896"/> One possibility is <em>sum types</em>. Just as type elements are used to specify the types that can be substituted for a type parameter, they could also be used for interfaces in variable parameters. This would enable some interesting features. Today, Go has a problem with a common situation in JSON: a field that can be a single value or a list of values. Even with generics, the only way to handle this is with a field of type <code>any</code>. Adding sum types would allow you to create an interface specifying that a field could be a string, a slice of strings, and nothing else. A type switch could then completely enumerate every valid type, improving type safety. This ability to specify a bounded set of types allows many modern languages (including Rust and Swift) to use sum types to represent enums. Given the weakness of Go’s current enum features, this might be an attractive solution, but it will take time for these ideas to be evaluated and explored.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id105">
<h1>Exercises</h1>

<p>Now that you’ve seen how generics work, apply them to solve the following problems. Solutions are available in the <em>exercise_solutions</em> directory in the <a href="https://oreil.ly/E0Ay8">Chapter 8 repository</a>.<a data-type="indexterm" data-startref="ix_hhh1234" id="id1897"/><a data-type="indexterm" data-startref="ix_h1234h" id="id1898"/></p>
<ol>
<li>
<p>Write a generic function that doubles the value of any integer or float that’s passed in to it. Define any needed generic interfaces.</p>
</li>
<li>
<p>Define a generic interface called <code>Printable</code> that matches a type that implements <code>fmt.Stringer</code> and has an underlying type of <code>int</code> or <code>float64</code>. Define types that meet this interface. Write a function that takes in a <code>Printable</code> and prints its value to the screen using <code>fmt.Println</code>.</p>
</li>
<li>
<p>Write a generic singly linked list data type. Each element can hold a comparable value and has a pointer to the next element in the list. The methods to implement are as follows:</p>
<div class="openblock">
<pre data-type="programlisting" data-code-language="go"><code class="c1">// adds a new element to the end of the linked list</code><code class="w"/>
<code class="nx">Add</code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"/>
<code class="c1">// adds an element at the specified position in the linked list</code><code class="w"/>
<code class="nx">Insert</code><code class="p">(</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="c1">// returns the position of the supplied value, -1 if it's not present</code><code class="w"/>
<code class="nx">Index</code><code class="w"> </code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>
</div>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id346">
<h1>Wrapping Up</h1>

<p>In this chapter, you took a look at generics and how to use them to simplify your code. It’s still early days for generics in Go. It will be exciting to see how they help grow the language while still maintaining the spirit that makes Go special.</p>

<p>In the next chapter, you are going to learn how to properly use one of Go’s most controversial features: errors.</p>
</div></section>
</div></section></div>
</div>
</body></html>