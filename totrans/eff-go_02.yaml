- en: Chapter 2\. Efficient Introduction to Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章\. 高效入门 Go 语言
- en: Go is efficient, scalable, and productive. Some programmers find it fun to work
    in; others find it unimaginative, even boring. ... Those are not contradictory
    positions. Go was designed to address the problems faced in software development
    at Google, which led to a language that is not a breakthrough research language
    but is nonetheless an excellent tool for engineering large software projects.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go 是高效、可扩展且高生产力的。一些程序员觉得在其中工作很有趣；另一些人则认为它缺乏想象力，甚至乏味。……这些观点并不矛盾。Go 的设计是为了解决谷歌在软件开发中遇到的问题，这导致了一种不是突破性研究语言，但却是大型软件项目工程的优秀工具。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/3EItq)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 罗布·派克，《谷歌的 Go：服务于软件工程的语言设计》(来源：[https://oreil.ly/3EItq](https://oreil.ly/3EItq))
- en: I am a huge fan of the Go programming language. The number of things developers
    around the world have been able to achieve with Go is impressive. For a few years
    in a row, Go has been on the list of [top five languages people love or want to
    learn](https://oreil.ly/la9bx). It is used in many businesses, including bigger
    tech companies like Apple, American Express, Cloudflare, Dell, Google, Netflix,
    Red Hat, Twitch, and [others](https://oreil.ly/DSM73). Of course, as with everything,
    nothing is perfect. I would probably change, remove, or add a few things to Go,
    but if you would wake me in the middle of the night and ask me to quickly write
    reliable backend code, I would write it in Go. CLI? In Go. Quick, reliable script?
    In Go as well. The first language to learn as a junior programmer? Go. Code for
    IoT, robots, and microprocessors? The answer is also Go.^([1](ch02.html#idm45606843247856))
    Infrastructure configuration? As of 2022, I don’t think there is a better tool
    for robust templating than Go.^([2](ch02.html#idm45606843245632))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我是 Go 编程语言的铁杆粉丝。全球开发者用 Go 取得的成就令人印象深刻。连续几年，Go 都在[人们喜欢或想学习的前五种语言列表](https://oreil.ly/la9bx)上。它在许多企业中都有使用，包括像苹果、美国运通、Cloudflare、戴尔、谷歌、Netflix、红帽、Twitch
    和[其他公司](https://oreil.ly/DSM73)。当然，像所有事物一样，没有完美的东西。如果你在半夜叫醒我，让我快速编写可靠的后端代码，我会选择用
    Go。命令行界面？也用 Go。快速、可靠的脚本？同样也是用 Go。作为初级程序员学习的第一门语言？Go。用于物联网、机器人和微处理器的代码？答案同样是 Go。^([1](ch02.html#idm45606843247856))
    基础设施配置？截至 2022 年，我认为没有比 Go 更好的工具用于强大的模板化了。^([2](ch02.html#idm45606843245632))
- en: Don’t get me wrong, there are languages with specialized capabilities or ecosystems
    that are superior to Go. For example, think about graphical user interfaces (GUIs),
    advanced rendering parts of the game industry, or code running in browsers.^([3](ch02.html#idm45606843243616))
    However, once you realize the many advantages of the Go language, it is pretty
    painful to jump back to others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误会，有些语言具有专门的能力或生态系统，这些方面可能比 Go 更优秀。例如，想想图形用户界面（GUI）、游戏行业的高级渲染部分或在浏览器中运行的代码。^([3](ch02.html#idm45606843243616))
    然而，一旦你意识到 Go 语言的诸多优点，再回到其他语言就会感觉相当痛苦。
- en: In [Chapter 1](ch01.html#ch-efficiency-matters), we spent some time establishing
    an efficiency awareness for our software. As a result, we learned that our goal
    is to write efficient code with the least development effort and cost. This chapter
    will explain why the Go programming language can be a solid option to achieve
    this balance between performance and other software qualities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch-efficiency-matters)中，我们花了一些时间来建立我们软件的效率意识。结果，我们学到了我们的目标是用最少的开发工作和成本编写高效的代码。本章将解释为什么
    Go 编程语言可以成为实现性能和其他软件质量平衡的可靠选择。
- en: We will start with [“Basics You Should Know About Go”](#ch-go-intro), then continue
    with [“Advanced Language Elements”](#ch-go-adv). Both sections list the short
    but essential facts everyone should know about Go, something I wish I had known
    when I started my journey with Go in 2014\. These sections will cover much more
    than just basic information about efficiency and can be used as an introduction
    to Go. However, if you are entirely new to the language, I would still recommend
    reading those sections, then checking other resources mentioned in the summary,
    perhaps writing your first program in Go, and then getting back to this book.
    On the other hand, if you consider yourself a more advanced user or expert, I
    suggest not skipping this chapter. I explain a few lesser-known facts about Go
    that you might find interesting or controversial (it’s OK, everyone can have their
    own opinions!).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we will finish by answering the tricky question about the
    overall Go efficiency capabilities in [“Is Go “Fast”?”](#ch-go-fast), as compared
    to other languages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Basics You Should Know About Go
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is an open source project maintained by Google within a distributed team
    called the “Go team.” The project consists of the programming language specification,
    compilator, tooling, documentation, and standard libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through some facts and best practices to understand Go basics and its
    characteristics in fast-forward mode. While some advice here might feel opinionated,
    this is based on my experience working with Go since 2014—a background full of
    incidents, past mistakes, and lessons learned the hard way. I’m sharing them here
    so you don’t need to make those errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Imperative, Compiled, and Statically Typed Language
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central part of the Go project is the general-purpose language with the
    same name, primarily designed for systems programming. As you will notice in [Example 2-1](#code-basic),
    Go is an imperative language, so we have (some) control over how things are executed.
    In addition, it’s statically typed and compiled, which means that the compiler
    can perform many optimizations and checks before the program runs. These characteristics
    alone are an excellent start to make Go suitable for reliable and efficient programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Simple program printing “Hello World” and exiting
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both project and language are called “Go,” yet sometimes you can refer to them
    as “Golang.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Go Versus Golang
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a rule of thumb, we should always use the “Go” name everywhere, unless it’s
    clashing with the English word *go* or an ancient game called “Go.” “Golang” came
    from the domain choice ([*https://golang.org*](https://golang.org)) since “go”
    was unavailable to its authors. So use “Golang” when searching for resources about
    this programming language on the web.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Go also has its mascot, called the [“Go gopher”](https://oreil.ly/SbxVX). We
    see this cute gopher in various forms, situations, and combinations, such as conference
    talks, blog posts, or project logos. Sometimes Go developers are called “gophers”
    too!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Designed to Improve Serious Codebases
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It all started when three experienced programmers from Google sketched the
    idea of the Go language around 2007:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Rob Pike
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Cocreator of UTF-8 and the Plan 9 operating system. Coauthor of many programming
    languages before Go, such as Limbo for writing distributed systems and Newsqueak
    for writing concurrent applications in graphical user interfaces. Both were inspired
    by Hoare’s Communicating Sequential Processes (CSP).^([4](ch02.html#idm45606843188400))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Robert Griesemer
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Among other work, Griesemer developed the [Sawzall language](https://oreil.ly/gYKMj)
    and did a doctorate with Niklaus Wirth. The same Niklaus wrote “A Plea for Lean
    Software” quoted in [“Software gets slower more rapidly than hardware becomes
    faster”](ch01.html#ch-eff-s-hardware-slower).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Ken Thompson
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: One of the original authors of the first Unix system. Sole creator of the `grep`
    command-line utility. Ken cocreated UTF-8 and Plan 9 with Rob Pike. He wrote a
    couple of languages, too, e.g., the Bon and B programming languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: These three aimed to create a new programming language that was meant to improve
    mainstream programming, led by C++, Java, and Python at that point. After a year,
    it became a full-time project, with Ian Taylor and Russ Cox joining in 2008 what
    was [later referenced as the Go team](https://oreil.ly/Nnj6N). The Go team announced
    the public Go project in 2009, with version 1.0 released in March 2012.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The main frustrations^([5](ch02.html#idm45606843146464)) related to C++ mentioned
    in the design of Go were:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Complexity, many ways of doing the same thing, too many features
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultralong compilation times, especially for bigger codebases
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost of updates and refactors in large projects
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not easy to use and memory model prone to errors
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements are why Go was born, from the frustration of existing solutions
    and the ambition to allow more by doing less. The guiding principles were to make
    a language that does not trade safety for less repetition, yet allows simpler
    code. It does not sacrifice execution efficiency for faster compilation or interpreting,
    yet ensures that build times are quick enough. [Go tries to compile as fast as
    possible, e.g., thanks to explicit imports](https://oreil.ly/qxuUS). Especially
    with caching enabled by default, only changed code is compiled, so build times
    are rarely longer than a minute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You Can Treat Go Code as Script!
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While technically Go is a compiled language, you can run it like you would run
    JavaScript, Shell, or Python. It’s as simple as invoking `go run <executable package>
    <flags>`. It works great because the compilation is ultrafast. You can treat it
    like a scripting language while maintaining the advantages of compilation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: In terms of syntax, Go was meant to be simple, light on keywords, and familiar.
    Syntax is based on C with type derivation (automatic type detection, like `auto`
    in C++), and no forward declarations, no header files. Concepts are kept orthogonal,
    which allows easier combination and reasoning about them. Orthogonality for elements
    means that, for example, we can add methods to any type or data definition (adding
    methods is separate from creating types). Interfaces are orthogonal to types too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Governed by Google, Yet Open Source
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since announcing Go, all development has been done in [open source](https://oreil.ly/ZeKm6),
    with public mailing lists and bug trackers. Changes go to the public, authoritative
    source code, held under the [BSD style license](https://oreil.ly/XBDEK). The Go
    team reviews all contributions. The process is the same if the change or idea
    is coming from Google or not. The project road maps and proposals are developed
    in public too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the sad truth is that there are many open source projects, but
    some projects are less open than others. Google is still the only company stewarding
    Go and has the last decisive control over it. Even if anyone can modify, use,
    and contribute, projects coordinated by a single vendor risk selfish and damaging
    decisions like relicensing or blocking certain features. While there were some
    controversial cases where the Go team decision surprised the community,^([6](ch02.html#idm45606843127920))
    overall the project is very reasonably well governed. Countless changes came from
    outside of Google, and the Go 2.0 draft proposal process has been well respected
    and community driven. In the end, I believe consistent decision-making and stewarding
    from the Go team bring many benefits too. Conflicts and different views are inevitable,
    and having one consistent overview, even if not perfect, might be better than
    no decision or many ways of doing the same thing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: So far, this project setup has proven to work well for adoption and language
    stability. For our software efficiency goals, such alignment couldn’t be better
    too. We have a big company invested in ensuring each release doesn’t bring any
    performance regressions. Some internal Google software depends on Go, e.g., [Google
    Cloud Platform](https://oreil.ly/vjyOc). And many people rely on the Google Cloud
    Platform to be reliable. On the other hand, we have a vast Go community that gives
    feedback, finds bugs, and contributes ideas and optimizations. And if that’s not
    enough, we have open source code, allowing us, mere mortal developers, to dive
    into the actual Go libraries, runtime (see [“Go Runtime”](#ch-go-runtime)), etc.,
    to understand the performance characteristics of the particular code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity, Safety, and Readability Are Paramount
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Robert Griesemer [mentioned in GopherCon 2015](https://oreil.ly/s3ZZ5) that
    first of all, they knew when they first started building Go what things NOT to
    do. The main guiding principle was simplicity, safety, and readability. In other
    words, Go follows the pattern of “less is more.” This is a potent idiom that spans
    many areas. In Go, there is only one *idiomatic* coding style,^([7](ch02.html#idm45606843118368))
    and a tool called `gofmt` ensures most of it. In particular, code formatting (next
    to naming) is an element that is rarely settled among programmers. We spend time
    arguing about it and tuning it to our specific needs and beliefs. Thanks to a
    single style enforced by tooling, we save enormous time. As one of the [Go proverbs](https://oreil.ly/ua2G8)
    goes, “Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite.”
    Overall, the Go authors planned the language to be minimal so that there is essentially
    one way to write a particular construct. This takes away a lot of decision-making
    when you are writing a program. There is one way of handling errors, one way of
    writing objects, one way of running things concurrently, etc.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伯特·格里塞默在[GopherCon 2015提到过](https://oreil.ly/s3ZZ5)，在他们最初开始构建Go语言时，首先知道了哪些事情不应该做。主要的指导原则是简单性、安全性和可读性。换句话说，Go语言遵循“少即是多”的模式。这是一个贯穿多个领域的强有力的习语。在Go语言中，只有一种*习惯用法*的编码风格^([7](ch02.html#idm45606843118368))，并且有一个名为`gofmt`的工具可以确保大部分都符合这种风格。特别是代码格式化（紧随命名之后）很少有程序员能达成一致。我们花时间争论它，并根据特定的需求和信念调整它。多亏了工具强制执行单一风格，我们节省了大量时间。正如一个[Go谚语](https://oreil.ly/ua2G8)所说，“gofmt的风格不是任何人的最爱，但gofmt是每个人的最爱。”总体来说，Go语言的作者们设计这门语言尽可能简洁，以便在编写程序时几乎只有一种写法。这在你编写程序时大大减少了决策的负担。处理错误的方式、编写对象的方式、以及并发运行事物的方式，都是唯一的。
- en: A huge number of features might be “missing” from Go, yet [one could say it
    is more expressive than C or C++](https://oreil.ly/CPkvV). Such minimalism allows
    for maintaining the simplicity and readability of the Go code, which improves
    software reliability, safety, and overall higher velocity toward application goals.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言可能会“缺失”大量特性，然而[可以说它比C或C++更具表现力](https://oreil.ly/CPkvV)。这种简约主义允许保持Go代码的简洁性和可读性，从而提高软件的可靠性、安全性和整体更高的应用速度。
- en: Is My Code Idiomatic?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**我的代码是否符合习惯用法？**'
- en: The word *idiomatic* is heavily overused in the Go community. Usually, it means
    Go patterns that are “often” used. Since Go adoption has grown a lot, people have
    improved the initial “idiomatic” style in many creative ways. Nowadays, it’s not
    always clear what’s idiomatic and what’s not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go社区中，“习惯用法”一词被大量使用。通常指的是经常使用的Go模式。由于Go的普及程度大大增加，人们用许多创造性的方式改进了最初的“习惯用法”风格。如今，什么是习惯用法，什么不是，并不总是清晰的。
- en: It’s like the “This is the way” saying from the *Mandalorian* series. It makes
    us feel more confident when we say, “This code is idiomatic.” So the conclusion
    is to use this word with care and [avoid it unless you can elaborate the reasoning
    why some pattern is better](https://oreil.ly/dAAKz).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像《曼达洛人》系列中的“这是正确的方式”一样。当我们说“这段代码符合习惯用法”时，这让我们感到更加自信。因此，总结起来，使用这个词要谨慎，并且[除非你能详细阐述为什么某种模式更好，否则最好避免使用它](https://oreil.ly/dAAKz)。
- en: Interestingly, the “less is more” idiom can help our efficiency efforts for
    this book’s purpose. As we learned in [Chapter 1](ch01.html#ch-efficiency-matters),
    if you do less work at runtime, it usually means faster, lean execution and less
    complex code. In this book, we will try to maintain this aspect while improving
    our code performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，“少即是多”的习语可以帮助我们为本书的目的努力提高效率。正如我们在[第一章](ch01.html#ch-efficiency-matters)中所学到的，如果在运行时做得越少，通常意味着更快、更精简的执行和更少复杂的代码。在本书中，我们将尝试保持这一方面，同时提高我们的代码性能。
- en: Packaging and Modules
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**打包与模块**'
- en: The Go source code is organized into directories representing either packages
    or modules. A package is a collection of source files (with the *.go* suffix)
    in the same directory. The package name is specified with the `package` statement
    at the top of each source file, as seen in [Example 2-1](#code-basic). All files
    in the same directory must the same package name^([8](ch02.html#idm45606843101632))
    (the package name can be different from the directory name). Multiple packages
    can be part of a single Go module. A module is a directory with a *go.mod* file
    that states all dependent modules with their versions required to build the Go
    application. This file is then used by the dependency management tool [Go Modules](https://oreil.ly/z5GqG).
    Each source file in a module can import packages from the same or external modules.
    Some packages can also be “executable.” For example, if a package is called `main`
    and has `func main()` in some file, we can execute it. Sometimes such a package
    is placed in the cmd directory for easier discovery. Note that you cannot import
    the executable package. You can only build or run it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Within the package, you can decide what functions, types, interfaces, and methods
    are exported to package users and which are accessible only in the package scope.
    This is important because exporting the minimal amount of API possible for readability,
    reusability, and reliability is better. Go does not have any `private` or `public`
    keywords for this. Instead, it takes a slightly new approach. As [Example 2-2](#code-export)
    shows, if the construct name starts with an uppercase letter, any code outside
    the package can use it. If the element name begins with a lowercase letter, it’s
    private. It’s worth noting that this pattern works for all constructs equally,
    e.g., functions, types, interfaces, variables, etc. (orthogonality).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Construct accessibility control using naming case
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO1-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Careful readers might notice tricky cases of exported fields or methods on private
    type or `interface`. Can someone outside the package use them if the `struct`
    or `interface` is private? This is quite rarely used, but the answer is yes, you
    can return a private `interface` or type in a public function, e.g., `func New()
    privateStruct { return privateStruct{}}`. Despite the `privateStruct` being private,
    all its public fields and methods are accessible to package users.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Internal Packages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can name and structure your code directories as you want to form packages,
    but one directory name is reserved for special meaning. If you want to ensure
    that only the given package can import other packages, you can create a package
    subdirectory named internal. Any package under the internal directory can’t be
    imported by any package other than the ancestor (and other packages in internal).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies Transparency by Default
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In my experience, it is common to import precompiled libraries, such as in
    C++, C#, or Java, and use exported functions and classes defined in some header
    files. However, importing compiled code has some benefits:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: It relieves engineers from making an effort to compile particular code, i.e.,
    find and download correct versions of dependencies, special compilation tooling,
    or extra resources.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might be easier to sell such a prebuilt library without exposing the source
    code and worrying about the client copying the business value-providing code.^([9](ch02.html#idm45606842831664))
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In principle, this is meant to work well. Developers of the library maintain
    specific programmatic contracts (APIs), and users of such libraries do not need
    to worry about implementation complexities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in practice, this is rarely that perfect. Implementation can
    be broken or inefficient, the interfaces can mislead, and documentation can be
    missing. In such cases, access to the source code is invaluable, allowing us to
    more deeply understand implementation. We can find issues based on specific source
    code, not by guessing. We can even propose a fix to the library or fork the package
    and use it immediately. We can extract the required pieces and use them to build
    something else.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Go assumes this imperfection by requiring each library’s parts (in Go: module’s
    packages) to be explicitly imported using a package URI called “import path.”
    Such import is also strictly controlled, i.e., unused imports or cyclic dependencies
    cause a compilation error. Let’s see different ways to declare these imports in
    [Example 2-3](#code-imports).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Portion of `import` statements from `github.com/prometheus/​prome⁠theus`
    module, main.go file
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO2-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: If the import declaration does not have a domain with a path structure, it means
    the package from the “standard”^([10](ch02.html#idm45606842772304)) library is
    imported. This particular import allows us to use code from the `$(go env GOROOT)/src/context/`
    directory with `context` reference, e.g., `context.Background()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO2-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The package can be imported explicitly without any identifier. We don’t want
    to reference any construct from this package, but we want to have some global
    variables initialized. In this case, the `pprof` package will add debugging endpoints
    to the global HTTP server router. While allowed, in practice we should avoid reusing
    global, modifiable variables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO2-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Nonstandard packages can be imported using an import path in the form of an
    internet domain name and an optional path to the package in a certain module.
    For example, the Go tooling integrates well with `https://github.com`, so if you
    host your Go code in a Git repository, it will find a specified package. In this
    case, it’s the `https://github.com/oklog/run` Git repository with the `run` package
    in the `github.com/oklog/run` module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO2-4)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: If the package is taken from the current module (in this case, our module is
    `github.com/prometheus/prometheus`), packages will be resolved from your local
    directory. In our example, `<module root>/config`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: This model focuses on open and clearly defined dependencies. It works exceptionally
    well with the open source distribution model, where the community can collaborate
    on robust packages in the public Git repositories. Of course, a module or package
    can also be hidden using standard version control authentication protocols. Furthermore,
    the official tooling [does not support distributing packages in binary form](https://oreil.ly/EnkBT),
    so the dependency source is highly encouraged to be present for compilation purposes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of software dependency are not easy to solve. Go learned from
    the mistakes of C++ and others, and takes a careful approach to avoid long compilation
    times, and an effect commonly called “dependency hell.”
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Through the design of the standard library, great effort was spent on controlling
    dependencies. It can be better to copy a little code than to pull in a big library
    for one function. (A test in the system build complains if new core dependencies
    arise.) Dependency hygiene trumps code reuse. One example of this in practice
    is that the (low-level) net package has its own integer-to-decimal conversion
    routine to avoid depending on the bigger and dependency-heavy formatted I/O package.
    Another is that the string conversion package strconv has a private implementation
    of the definition of “printable” characters rather than pull in the large Unicode
    character class tables; that strconv honors the Unicode standard is verified by
    the package’s tests.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/wqKGT)'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Again, with efficiency in mind, potential minimalism in dependencies and transparency
    brings enormous value. Fewer unknowns means we can quickly detect main bottlenecks
    and focus on the most significant value optimizations first. We don’t need to
    work around it if we notice potential room for optimization in our dependency.
    Instead, we are usually welcome to contribute the fix directly to the upstream,
    which helps both sides!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Consistent Tooling
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the beginning, Go had a powerful and consistent set of tools as part of
    its command-line interface tool, called `go`. Let’s enumerate a few utilities:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`go bug` opens a new browser tab with the correct place where you can file
    an official bug report (Go repository on GitHub).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go build -o <output path> <packages>` builds given Go packages.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go env` shows all Go-related environment variables currently set in your terminal
    session.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go fmt <file, packages or directories>` formats given artifacts to the desired
    style, cleans whitespaces, fixes wrong indentations, etc. Note that the source
    code does not need to be even valid and compilable Go code. You can also install
    an extended official formatter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`goimports`](https://oreil.ly/6fDcy) also cleans and formats your `import`
    statements.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the best experience, set your programming IDE to run `goimports -w $FILE`
    on every file to not worry about the manual indentation anymore!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`go get <package@version>` allows you to install the desired dependency with
    the expected version. Use the `@latest` suffix to get the latest version of `@none`
    to uninstall the dependency.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go help <command/topic>` prints documentation about the command or given topic.
    For example, `go help environment` tells you all about the possible environment
    variables Go uses.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go install <package>` is similar to `go get` and installs the binary if the
    given package is “executable.”'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go list` lists Go packages and modules. It allows flexible output formatting
    using Go templates (explained later), e.g., `go list -mod=readonly -m -f ''{{
    if and (not .Indirect) (not .Main)}}{{.Path}}{{end}}'' all` lists all direct nonexecutable
    dependent modules.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go mod` allows managing dependent modules.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go test` allows running unit tests, fuzz tests, and benchmarks. We will discuss
    the latter in detail in [Chapter 8](ch08.html#ch-benchmarking).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go tool` hosts a dozen more advanced CLI tools. We will especially take a
    close look at `go tool pprof` in [“pprof Format”](ch09.html#ch-obs-pprof) for
    performance optimizations.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go vet` runs basic static analysis checks.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the Go CLI is all you need for effective Go programming.^([11](ch02.html#idm45606842681408))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Single Way of Handling Errors
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Errors are an inevitable part of every running software. Especially in distributed
    systems, they are expected by design, with advanced research and algorithms for
    handling different types of failures.^([12](ch02.html#idm45606842674272)) Despite
    the need for errors, most programming languages do not recommend or enforce a
    particular way of failure handling. For example, in C++ you see programmers using
    all means possible to return an error from a function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer return codes (if the returned value is nonzero, it means error)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit status codes^([13](ch02.html#idm45606842670048))
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other sentinel values (if the returned value is `null`, then it’s an error)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning potential error by argument
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error classes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads^([14](ch02.html#idm45606842664160))
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each option has its pros and cons, but just the fact that there are so many
    ways of handling errors can cause severe issues. It causes surprises by potentially
    hiding that some statements can return an error, introduces complexity and, as
    a result, makes our software unreliable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly, the intention for so many options was good. It gives a developer
    choices. Maybe the software you create is noncritical, or is the first iteration,
    so you want to make a “happy path” crystal clear. In such cases, masking some
    “bad paths” sounds like a good short-term idea, right? Unfortunately, as with
    many shortcuts, it poses numerous dangers. Software complexity and demand for
    functionalities cause the code to never go out of the “first iteration,” and noncritical
    code quickly becomes a dependency for something critical. This is one of the most
    important causes of unreliability or hard-to-debug software.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Go takes a unique path by treating the error as a first-citizen language feature.
    It assumes we want to write reliable software, making error handling explicit,
    easy, and uniform across libraries and interfaces. Let’s see some examples in
    [Example 2-4](#code-errors).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Multiple function signatures with different return arguments
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO3-1)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The critical aspect here is that functions and methods define the error flow
    as part of their signature. In this case, the `noErrCanHappen` function states
    that there is no way any error can happen during its invocation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO3-2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the `doOrErr` function signature, we know some errors can happen.
    We don’t know what type of error yet; we only know it is implementing a built-in
    `error` interface. We also know that there was no error if the error is nil.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO3-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The fact that Go functions can return multiple arguments is leveraged when calculating
    some result in a “happy path.” If the error can happen, it should be the last
    return argument (always). From the caller side, we should only touch the result
    if the error is nil.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that Go has an exception mechanism called `panics`, which
    are recoverable using the `recover()` built-in function. While useful or necessary
    for certain cases (e.g., initialization), you should never use `panics` for conventional
    error handling in your production code in practice. They are less efficient, hide
    failures, and overall surprise the programmers. Having errors as part of invocation
    allows the compilator and programmer to be prepared for error cases in the normal
    execution path. [Example 2-5](#code-handling) shows how we can handle errors if
    they occur in our function execution path.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Checking and handling errors
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO4-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we did not import the built-in `errors` package, but instead used
    the open source drop-in replacement `github.com/efficientgo/core/errors`. `core`
    module. This is my recommended replacement for the `errors` package and the popular,
    but archived, `github.com/pkg/errors`. It allows a bit more advanced logic, like
    wrapping errors you will see in step three.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO4-2)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: To tell if an error happened, we need to check if the `err` variable is nil
    or not. Then, if an error occurs, we can follow with error handling. Usually,
    it means logging it, exiting the program, incrementing metrics, or even explicitly
    ignoring it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO4-3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it’s appropriate to delegate error handling to the caller. For example,
    if the function can fail from many errors, consider wrapping it with a `errors.Wrap`
    function to add a short context of what is wrong. For example, with `github.com/efficientgo/core/errors`,
    we will have context and stack trace, which will be rendered if `%+v` is used
    later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: How to Wrap Errors?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that I recommended `errors.Wrap` (or `errors.Wrapf`) instead of the built-in
    way of wrapping errors. Go defines the `%w` identifier for the `fmt.Errors` type
    of function that allows passing an error. Currently, I would not recommend `%w`
    because it’s not type safe and as explicit as `Wrap`, causing nontrivial bugs
    in the past.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The one way of defining errors and handling them is one of Go’s best features.
    Interestingly, it is one of the language disadvantages due to verbosity and certain
    boilerplate involved. It sometimes might feel repetitive, but tools allow you
    to mitigate the boilerplate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Some Go IDEs define code templates. For example, in JetBrain’s GoLand product,
    typing **`err`** and pressing the Tab key will generate a valid `if err != nil`
    statement. You can also collapse or expand error handling blocks for readability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Another common complaint is that writing Go can feel very “pessimistic,” because
    the errors that may never occur are visible in plain sight. The programmer has
    to decide what to do with them at every step, which takes mental energy and time.
    Yet, in my experience it’s worth the work and makes programs much more predictable
    and easier to debug.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Never Ignore Errors!
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the verbosity of error handling, it’s tempting to skip `err != nil` checks.
    Consider not doing it unless you know a function will never return an error (and
    in future versions!). If you don’t know what to do with the error, consider passing
    it to the caller by default. If you must ignore the error, consider doing it explicitly
    with the `_ =` syntax. Also, always use linters, which will warn you about some
    portion of unchecked errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Are there any implications of the error handling for general Go code runtime
    efficiency? Yes! Unfortunately, it’s much more significant than developers usually
    anticipate. In my experience, error paths are frequently an order of magnitude
    slower and more expensive to execute than happy paths. One of the reasons is we
    tend not to ignore error flows during our monitoring or benchmarking steps (mentioned
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Another common reason is that the construction of errors often involves heavy
    string manipulation for creating human-readable messages. As a result, it can
    be costly, especially with lengthy debugging tags, which are touched on later
    in this book. Understanding these implications and ensuring consistent and efficient
    error handling are essential in any software, and we will take a detailed look
    at that in the following chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Strong Ecosystem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A commonly stated strong point of Go is that its ecosystem is exceptionally
    mature for such a “young” language. While items listed in this section are not
    mandatory for solid programming dialects, they improve the whole development experience.
    This is also why the Go community is so large and still growing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: First, Go allows the programmer to focus on business logic without necessarily
    reimplementing or importing third-party libraries for basic functionalities like
    YAML decoding or cryptographic hashing algorithms. Go standard libraries are high
    quality, robust, ultra-backward compatible, and rich in features. They are well
    benchmarked, have solid APIs, and have good documentation. As a result, you can
    achieve most things without importing external packages. For example, running
    an HTTP server is dead simple, as visualized in [Example 2-6](#code-basicserver).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Minimal code for serving HTTP requests^([15](ch02.html#idm45606839042576))
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In most cases, the efficiency of standard libraries is good enough or even better
    than third-party alternatives. For example, especially lower-level elements of
    packages, `net/http` for HTTP client and server code, or `crypto`, `math`, and
    `sort` parts (and more!), have a good amount of optimizations to serve most of
    the use cases. This allows developers to build more complex code on top while
    not worrying about the basics like `sorting` performance. Yet that’s not always
    the case. Some libraries are meant for specific usage, and misusing them may result
    in significant resource waste. We will look at all the things you need to be aware
    of in [Chapter 11](ch11.html#ch-opt2).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Another highlight of the mature ecosystem is a basic, official in-browser Go
    editor called [Go Playground](https://oreil.ly/9Os3y). It’s a fantastic tool if
    you want to test something out quickly or share an interactive code example. It’s
    also straightforward to extend, so the community often publishes variations of
    the Go Playground to try and share previously experimental language features like
    [generics](https://oreil.ly/f0qpm) (which are now part of the primary language
    and explained in [“Generics”](#ch-go-generics)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the Go project defines its templating language, called [Go
    templates](https://oreil.ly/FdEZ8). In some way, it’s similar to Python’s [Jinja2
    language](https://oreil.ly/U6Em1). While it sounds like a side feature of Go,
    it’s beneficial in any dynamic text or HTML generation. It is also often used
    in popular tools like [Helm](https://helm.sh) or [Hugo](https://gohugo.io).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Unused Import or Variable Causes Build Error
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compilation will fail if you define a variable in Go but never read any
    value from it or don’t pass it to another function. Similarly, it will fail if
    you added a package to the `import` statement but don’t use that package in your
    file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: I see that Go developers have gotten used to this feature and love it, but it
    is surprising for newcomers. Failing on unused constructs can be frustrating if
    you want to play with the language quickly, e.g., create some variable without
    using it for debugging purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, ways to handle these cases explicitly! You can see a few
    examples of dealing with these usage checks in [Example 2-7](#code-unused).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Various examples of unused and used variables
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO5-1)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Variables `a`, `b`, and `c` are not used, so they cause a compilation error.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO5-4)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Variable `e` is used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO5-5)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Variable `f` is technically used for an explicit no identifier (`_`). Such an
    approach is useful if you explicitly want to tell the reader (and compiler) that
    you want to ignore the value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, unused imports will fail the compilation process, so tools like `goimports`
    (mentioned in [“Consistent Tooling”](#ch-go-tooling)) automatically remove unused
    ones. Failing on unused variables and imports effectively ensures that code stays
    clear and relevant. Note that only internal function variables are checked. Elements
    like unused `struct` fields, methods, or types are not checked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing and Table Tests
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tests are a mandatory part of every application, small or big. In Go, tests
    are a natural part of the development process—easy to write, and focused on simplicity
    and readability. If we want to talk about efficient code, we need to have solid
    testing in place, allowing us to iterate over the program without worrying about
    regressions. Add a file with the *_test.go* suffix to introduce a unit test to
    your code within a package. You can write any Go code within that file, which
    won’t be reachable from the production code. There are, however, four types of
    functions you can add that will be invoked for different testing parts. A certain
    signature distinguishes these types, notably function name prefixes: `Test`, `Fuzz`,
    `Example`, or `Benchmark`, and specific arguments.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the unit test type in [Example 2-8](#code-test). To make
    it more interesting, it’s a table test. Examples and benchmarks are explained
    in [“Code Documentation as a First Citizen”](#ch-go-godoc) and [“Microbenchmarks”](ch08.html#ch-obs-micro).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Example unit table test
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO6-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If the function inside the *_test.go* file is named with the `Test` word and
    takes exactly `t *testing.T`, it is considered a “unit test.” You can run them
    through the `go test` command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO6-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we want to test a specific function using multiple test cases (often
    edge cases) that define different input and expected output. This is where I would
    suggest using table tests. First, define your input and output, then run the same
    function in an easy-to-read loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO6-3)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can invoke `t.Run`, which allows you to specify a subtest. Defining
    those on dynamic test cases like table tests is a good practice. It will enable
    you to navigate to the failing case quickly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO6-4)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The Go `testing.T` type gives useful methods like `Fail` or `Fatal` to abort
    and fail the unit test, or `Error` to continue running and check other potential
    errors. In our example, I propose using a simple helper called `testutil.Equals`
    from our [open source core library](https://oreil.ly/yAit9), giving you a nice
    diff.^([16](ch02.html#idm45606838437664))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Write tests often. It might surprise you, but writing unit tests for critical
    parts up front will help you implement desired features much faster. This is why
    I recommend following some reasonable form of test-driven development, covered
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This information should give you a good overview of the language goals, strengths,
    and features before moving to more advanced features.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Language Elements
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now discuss the more advanced features of Go. Similar to the basics mentioned
    in the previous section, it’s crucial to overview core language capabilities before
    discussing efficiency improvements.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Code Documentation as a First Citizen
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every project, at some point, needs solid API documentation. For library-type
    projects, the programmatic APIs are the main entry point. Robust interfaces with
    good descriptions allow developers to hide complexity, bring value, and avoid
    surprises. A code interface overview is essential for applications, too, allowing
    anyone to understand the codebase quickly. Reusing an application’s Go packages
    in other projects is also not uncommon.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Instead of relying on the community to create many potentially fragmented and
    incompatible solutions, the Go project developed a tool called [`godoc`](https://oreil.ly/TQXxv)
    from the start. It behaves similarly to Python’s [Docstring](https://oreil.ly/UdkzS)
    and Java’s [Javadoc](https://oreil.ly/wlWGT). `godoc` generates a consistent documentation
    HTML website directly from the code and its comments.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The amazing part is that you don’t have many special conventions that would
    directly make the code comments less readable from the source code. To use this
    tool effectively, you need to remember five things. Let’s go through them using
    Examples [2-9](#code-godoc) and [2-10](#code-godoc2). The resulting HTML page,
    when [`godoc` is invoked](https://oreil.ly/EYJlx), can be seen in [Figure 2-1](#img-godoc).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Example snippet of block.go file with `godoc` compatible documentation
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO7-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: The optional package-level description must be placed on top of the
    `package` entry with no intervening blank line and start with the `Package <name>`
    prefix. If any source files have these entries, `godoc` will collect them all.
    If you have many files, the convention is to have the *doc.go* file with just
    the package-level documentation, package statement, and no other code.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO7-2)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Any public construct should have a full sentence commentary, starting
    with the name of the construct (it’s important!), right before its definition.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO7-4)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 3: Known bugs can be mentioned with `// BUG(who)` statements.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO7-5)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Private constructs can have comments, but they will never be exposed in the
    documentation since they are private. Be consistent and start them with a construct
    name, too, for readability.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Example snippet of block_test.go file with `godoc` compatible
    documentation
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO8-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 4: If you write a function named `Example<ConstructName>` in the test
    file, e.g., `block_test.go`, the `godoc` will generate an interactive code block
    with the desired examples. Note that the package name must have a *_test* suffix,
    too, representing a local testing package that tests the package without access
    to private fields. Since examples are part of the unit test, they will be actively
    run and compiled.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO8-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 5: If the example has the last comment starting with `// Output:`, the
    string after it will be asserted with the standard output after the example, allowing
    the example to stay reliable.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![efgo 0201](assets/efgo_0201.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. `godoc` output of Examples [2-9](#code-godoc) and [2-10](#code-godoc2)
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I highly recommend sticking to those five simple rules. Not only because you
    can manually run `godoc` and generate your documentation web page, but the additional
    benefit is that these rules make your Go code comments structured and consistent.
    Everyone knows how to read them and where to find them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using complete English sentences in all comments, even if the will
    not appear in `godoc`. It will help you keep your code commentary self-explanatory
    and explicit. After all, comments are for humans to read.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the Go team maintains a [public documentation website](https://pkg.go.dev)
    that scrapes all requested public repositories for free. Thus, if your public
    code repository is compatible with `godoc`, it will be rendered correctly, and
    users can read the autogenerated documentation for every module or package version.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Backward Compatibility and Portability
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a strong take on backward compatibility guarantees. This means that core
    APIs, libraries, and language specifications should never break old code created
    for [Go 1.0](https://oreil.ly/YOKfu). This was proven to be well executed. There
    is a lot of trust in upgrading Go to the latest minor or patch versions. Upgrades
    are, in most cases, smooth and without significant bugs and surprises.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Regarding efficiency compatibility, it’s hard to discuss any guarantees. There
    is (usually) no guarantee that the function that does two memory allocations now
    will not use hundreds in the next version of the Go project and any library. There
    have been surprises between versions in efficiency and speed characteristics.
    The community is working hard on improving the compilation and language runtime
    (more in [“Go Runtime”](#ch-go-runtime) and [Chapter 4](ch04.html#ch-hardware)).
    Since the hardware and operating systems are also developed, the Go team is experimenting
    with different optimizations and features to allow everyone to execute more efficiently.
    Of course, we don’t speak about major performance regression here, as that is
    usually noticed and fixed in the release candidate period. Yet if we want our
    software to be deliberately fast and efficient, we need to be more vigilant and
    aware of the changes Go introduces.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Source code is compiled into binary code that is targeted to each platform.
    Yet Go tooling allows cross-platform compilation, so you can build binaries to
    almost all architectures and operating systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the Go binary, which was compiled for a different operating
    system (OS) or architecture, it can return cryptic error messages. For example,
    a common error is an Exec format error when you try running binary for Darwin
    (macOS) on Linux. You must recompile the code source for the correct architecture
    and OS if you see this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Regarding portability, we can’t skip mentioning the Go runtime and its characteristics.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Go Runtime
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many languages decided to solve portability across different hardware and operating
    systems by using virtual machines. Typical examples are [Java Virtual Machine
    (JVM)](https://oreil.ly/fhOmL) for Java bytecode compatible languages (e.g., Java
    or Scala), and [Common Language Runtime (CLR)](https://oreil.ly/StGbU) for .NET
    code, e.g., C#. Such a virtual machine allows for building languages without worrying
    about complex memory management logic (allocation and releasing), differences
    between hardware and operating systems, etc. JVM or CLR interprets the intermediate
    bytecode and transfers program instructions to the host. Unfortunately, while
    making it easier to create a programming language, they also introduce some overhead
    and many unknowns.^([17](ch02.html#idm45606838184304)) To mitigate the overhead,
    virtual machines often use complex optimizations like [just-in-time (JIT) compilation](https://oreil.ly/XXARz)
    to process chunks of specific virtual machine bytecode to machine code on the
    fly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Go does not need any “virtual machine.” Our code and used libraries compile
    fully to machine code during compilation time. Thanks to standard library support
    of large operating systems and hardware, our code, if compiled against particular
    architecture, will run there with no issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Yet something is running in the background (concurrently) when our program starts.
    It’s the [Go runtime](https://oreil.ly/mywcZ) logic that, among other minor features
    of Go, is responsible for memory and concurrency management.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Undoubtedly, object-oriented programming (OOP) got enormous traction over the
    last decades. It was invented around 1967 by Alan Kay, and it’s still the most
    popular paradigm in programming.^([18](ch02.html#idm45606838174512)) OOP allows
    us to leverage advanced concepts like [encapsulation, abstraction, polymorphisms,
    and inheritance](https://oreil.ly/8hA0u). In principle, it allows us to think
    about code as some objects with attributes (in Go fields) and behaviors (methods)
    telling each other what to do. Most OOP examples talk about high-level abstractions
    like an animal that exposes the `Walk()` method or a car that allows to `Ride()`,
    but in practice, objects are usually less abstract yet still helpful, encapsulated,
    and described by a class. There are no classes in Go, but there are `struct` types
    equivalents. [Example 2-11](#code-oop) shows how we can write OOP code in Go to
    compact multiple block objects into one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. Example of the OOP in Go with `Group` that can behave like `Block`
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO9-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In Go, there is no separation between structures and classes, like in C++. In
    Go, on top of basic types like `integer`, `string`, etc., there is a `struct`
    type that can have methods (behaviors) and fields (attributes). We can use structures
    as a `class` equivalent to *encapsulate* more complex logic under a more straightforward
    interface. For example, the `Duration()` method on `Block` tells us the duration
    of the time range covered by the block.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO9-3)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If we add some struct, e.g., `Block`, into another struct, e.g., `Group`, without
    any name, such a `Block` `struct` is considered embedded instead of being a field.
    Embedding allows Go developers to get the most valuable part of *inheritance*,
    borrowing the embedded structure fields and methods. In this case, `Group` will
    have `Block`’s fields and `Duration` method. This way, we can reuse a significant
    amount of code in our production codebases.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO9-4)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of methods you can define in Go: using the “value receiver”
    (e.g., as in the `Duration()` method) or using the “pointer receiver” (with `*`).
    The so-called receiver is the variable after `func`, which represents the type
    we are adding a method to, in our case `Group`. We will mention this in [“Values,
    Pointers, and Memory Blocks”](ch05.html#ch-hw-allocations), but the rule regarding
    which one to use is straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Use the value receiver (no `func (g Group) SomeMethod()`) if your method does
    not modify the `Group` state. For the value receiver, every time we invoke it,
    the `g` will create a local copy of the `Group` object. It is equivalent to `func
    SomeMethod(g Group)`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the pointer receiver (e.g., `func (g *Group) SomeMethod()`) if your method
    is meant to modify the local receiver state or if any other method does that.
    It is equivalent to `func SomeMethod(g *Group)`. In our example, if the `Group.Merge()`
    method would be a value receiver, we will not persist `g.childen` changes or potentially
    inject `g.start` and `g.end` values. Additionally, for consistency, it’s always
    recommended to have a type with all pointer receiver methods if at least one requires
    a pointer.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO9-5)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: To compact multiple blocks together, our algorithm requires a sorted list of
    blocks. We can use the standard library [`sort.Sort`](https://oreil.ly/N6ZWS),
    which expects the `sort.Interface` interface. The `[]Block` slice does not implement
    this interface, so we convert it to our temporary `sortable` type, explained in
    [Example 2-13](#code-oop-sortable).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_efficient_introduction_to_go_CO9-6)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: This is the only missing element for true inheritance. Go does not allow casting
    specific types into another type unless it’s an alias or strict single-struct
    embedding (shown in [Example 2-13](#code-oop-sortable)). After that, you can only
    cast the interface into some type. That’s why we need to specify embedded `struct`
    and `Block` explicitly. As a result, Go is often considered a language that does
    not support full inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: What does [Example 2-11](#code-oop) give us? First, the `Group` type can reuse
    `Block` functionality, and if done correctly, we can use `Group` as any other
    `Block`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Multiple Types
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can embed as many unique structures as you want within one `struct`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There is no priority for these—the compilation will fail if the compilator can’t
    tell which method to use because two embedded types have the same `SomeMethod()`
    method. In such cases, use the type name to explicitly tell the compilator what
    should be used.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Example 2-11](#code-oop), Go also allows defining interfaces
    that tell what methods `struct` has to implement to match it. Note that there
    is no need to mark a specific `struct` explicitly that implements a particular
    interface, as in other languages like Java. It’s enough just to implement the
    required methods. Let’s see an example of sorting interface exposed by the standard
    library in [Example 2-12](#code-oop-sort).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. Sorting interface from the standard `sort` Go library
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To use our type in the `sort.Sort` function, it has to implement all `sort.Interface`
    methods. [Example 2-13](#code-oop-sortable) shows how `sortable` type does it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Example of the type that can be sorted using `sort.Slice`
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO10-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: We can embed another type (e.g., a slice of `Block` elements) as the only thing
    in our `sortable` struct. This allows easy (but explicit) casting between `[]Block`
    and `sortable`, as we used in the `Compact` method in [Example 2-11](#code-oop).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO10-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We can sort by increasing the `start` time using the [`time.Time.Before(...)`](https://oreil.ly/GQ2Ru)
    method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO10-3)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We can assert our `sortable` type implements `sort.Interface` using this single-line
    statement, which fails compilation otherwise. I recommend using such statements
    whenever you want to ensure your type stays compatible with a particular interface
    in the future!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, `struct` methods, fields, and interfaces are an excellent yet simple
    way of writing both procedural composable and object-oriented code. In my experience,
    eventually it satisfies both low-level and high-level programming needs during
    our software development. While Go does not support all inheritance aspects (type
    to type casting), it provides enough to satisfy almost all OOP cases.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since version 1.18, Go supports [generics](https://oreil.ly/qYyuQ), one of the
    community’s most desired features. Generics, also called [parametric polymorphism](https://oreil.ly/UIUAg),
    allow type-safe implementations of the functionalities we want to reuse across
    different types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The demand for generics in Go started quite big discussions in the Go team
    and community because of two main problems:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Two ways of doing the same thing
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning, Go already supported type-safe reusable code via interfaces.
    You could see that in the preceding OOP example—the [`sort.Sort`](https://oreil.ly/X2NxR)
    can be reusable by all types that implement a `sort.Interface` presented in [Example 2-12](#code-oop-sort).
    We can sort our custom `Block` type by implementing those methods in [Example 2-13](#code-oop-sortable).
    Adding generics means we have [two ways of doing a thing](https://oreil.ly/dL8uE)
    in many cases.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: However, `interfaces` can be more troublesome for users of our code and slow
    at times due to [some runtime overhead](https://oreil.ly/8tSVf).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Overhead
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing generics can have many negative consequences for the language.
    Depending on the implementation, it can impact different things. For example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We can just skip implementing them like in C, which slows programmers.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use [monomorphization](https://oreil.ly/B062N), which essentially copies
    the code for each type that will be used. This impacts compile time and binary
    size.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use boxing like in Java, which is quite similar to the Go interface implementation.
    In this case, we impact execution time or memory usage.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generic dilemma is this: do you want slow programmers, slow compilers and
    bloated binaries, or slow execution times?'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Russ Cox, [“The Generic Dilemma”](https://oreil.ly/WjjV4)
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After many proposals and debates, the final (extremely detailed!) [design](https://oreil.ly/k9cCR)
    was accepted. Initially, I was very skeptical, but the accepted generic use turned
    out to be clear and reasonable. So far, the community also didn’t jump ahead and
    abuse these mechanics as was feared. We tend to see generics used very rarely—only
    when needed, as it makes the code more complex to maintain.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could write a generic sort for all basic types like `int`, `float64`,
    or even `strings`, as presented in [Example 2-14](#code-generics).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Example implementation of the generic sort for basic types
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO11-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to generics (also called type parameters), we can implement a single
    type that will implement `sort.Interface` (see [Example 2-13](#code-oop-sortable))
    for all basic types. We can provide custom constraints that look mostly like interfaces
    to limit the types that can be used as a type parameter. Here we use a type that
    represents `Integer | Float | ~string` constraints, so any type that supports
    comparison operators. We can put any other interface, like `any` to match all
    types. We can also use a special `comparable` keyword that will allow us to use
    the object of `T comparable` as a `map` key.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO11-3)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Any element of `s` slice is now expected to be of type `T` with `Ordered` constraints,
    so the compiler will allow us to compare them for `Less` functionality.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO11-4)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement a sort function for any basic type that will leverage `sort.Sort`
    implementation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO11-5)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to implement type-specific functions like `sort.Ints`. We can
    do `genericSortBasic[<type>]([]<type>)` as long as the slice is of the types that
    can be ordered!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it only works for basic types. Unfortunately, we cannot override
    operators like `<` in Go (yet), so to implement generic sort for more complex
    types, we have to do a bit more work. For example, we could design our sort to
    expect each type to implement the `func <typeA> Compare(<typeA>) int` method.^([19](ch02.html#idm45606837116448))
    If we add this method to the `Block` in [Example 2-11](#code-oop), we can sort
    it easily, as presented in [Example 2-15](#code-generics2).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. Example implementation of the generic sort for certain types
    of objects
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO12-1)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Let’s design our constraint. We expect every type to have a `Compare` method
    that accepts the same type. Because constraints and interfaces can also have type
    parameters, we can implement such requirements.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO12-2)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We can now provide a type that implements a `sort.Interface` interface for such
    kinds of objects. Notice the nested `T` in `Comparable[T]`, as our interface also
    is generic!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO12-4)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Now we can implement `Compare` for our `Block` type.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO12-5)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this, we don’t need to implement a `sortable` type for every custom
    type we want to sort. As long as the type has the `Compare` method, we can use
    `genericSort`!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The accepted design shows advantages in cases where the user interface alone
    would be cumbersome. But what about the generics dilemma problem? The design allows
    any [implementation](https://oreil.ly/rZBtz), so what trade-off was chosen at
    the end? We won’t go into the details in this book, but Go uses the [dictionaries
    and stenciling](https://oreil.ly/poLls) algorithm, which is between monomorphization
    and boxing.^([20](ch02.html#idm45606836849296))
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Generic Code Will Be Faster?
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specific implementation of generics in Go (which can change over time) means
    that the generic implementation, in theory, should be faster than interfaces but
    slower than implementing certain functionality for a specific type by hand. In
    practice, however, the potential difference is, in most cases, negligible, so
    use the most readable and easy-to-maintain option first.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, the difference might matter in the efficiency-critical code,
    but the results do not always follow the theory. For example, sometimes [generic
    implementation is faster](https://oreil.ly/9cEIb), and sometimes [using interfaces
    might be more efficient](https://oreil.ly/tiOhS). Conclusion? Always perform benchmarks
    ([Chapter 8](ch08.html#ch-benchmarking)) to be sure!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, these facts are what I found crucial when teaching others programming
    in Go, based on my own experience with the language. Moreover, it will be helpful
    when diving deeper into the runtime performance of Go later in this book.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have never programmed in Go before, it’s worth going through
    other materials like the [tour of Go](https://oreil.ly/J3HE3) before jumping to
    the subsequent sections and chapters of this book. Make sure you try writing your
    own basic Go program, write a unit test, and use loops, switches, and concurrency
    mechanisms like channels and routines. Learn common types and standard library
    abstraction. As a person coming to a new language, you need to produce a program
    returning valid results before ensuring that it executes quickly and efficiently.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We learned about some basic and advanced characteristics of Go, so it’s time
    to unwrap the efficiency aspects of the language. How easy is it to write good
    enough or high-performance code in Go?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Is Go “Fast”?
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently, many companies have rewritten their products (e.g., from Ruby, Python,
    and Java) to Go.^([21](ch02.html#idm45606836733504)) Two repeatedly stated reasons
    for moving to Go or starting a new project in Go were readability and excellent
    performance. Readability comes from simplicity and consistency (e.g., single way
    of error handling as you remember from [“Single Way of Handling Errors”](#ch-go-errs)),
    and it’s where Go excels, but what about performance? Is Go fast compared to other
    languages like Python, Java, or C++?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, this question is badly formed. Given time and room for complexities,
    any language can be as fast as your machine and operating system allow. That’s
    because, in the end, the code we write is compiled into machine code that uses
    the exact CPU instructions. Also, most languages allow delegating execution to
    other processes, e.g., written in optimized Assembly. Unfortunately, sometimes
    all we use to decide if a language is “fast” are raw, semi-optimized short program
    benchmarks that compare execution time and memory usage across languages. While
    it tells us something, it effectively does not show practical aspects, e.g., how
    complex the programming for efficiency was.^([22](ch02.html#idm45606836729648))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we should look at a programming language in terms of how hard and practical
    it is to write efficient code (not just fast), and how much readability and reliability
    such a process sacrifices. I believe the Go language has a superior balance between
    those elements while keeping it fast and trivial to write basic, functional code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons for being able to write efficient code more easily is the
    hermetic compilation stage, the relatively small amount of unknowns in the Go
    runtime (see [“Go Runtime”](#ch-go-runtime)), the easy-to-use concurrency framework,
    and the maturity of the debugging, benchmarking, and profiling tools (discussed
    in Chapters [8](ch08.html#ch-benchmarking) and [9](ch09.html#ch-observability3)).
    Those Go characteristics did not appear from thin air. Not many know, but Go was
    designed on the shoulders of giants: C, Pascal, and CSP.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In 1960, language experts from America and Europe teamed up to create Algol
    60\. In 1970, the Algol tree split into the C and the Pascal branch. ~40 years
    later, the two branches join again in Go.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robert Griesemer, [“The Evolution of Go”](https://oreil.ly/a4V1e)
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we can see in [Figure 2-2](#img-go-roots), many of the names mentioned in
    [Chapter 1](ch01.html#ch-efficiency-matters) are grandfathers of Go. The great
    concurrency language CSP created by Sir Hoare, Pascal declarations and packages
    created by Wirth, and C basic syntax all contributed to how Go looks today.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![efgo 0202](assets/efgo_0202.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Go genealogy
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But not everything can be perfect. In terms of efficiency, Go has its own Achilles’
    heel. As you will learn in [“Go Memory Management”](ch05.html#ch-hw-go-mem), memory
    usage can sometimes be hard to control. Allocations in our program can be surprising
    (especially for new users), and the garbage collections automatic memory release
    process has some overhead and eventual behavior. Especially for data-intensive
    applications, it takes effort to ensure memory or CPU efficiency, similar to machines
    with strictly limited RAM capacities (e.g., IoT).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Yet the decision to automate this process is highly beneficial, allowing the
    programmer to not worry about memory cleanup, which has proven to be even worse
    and sometimes catastrophic (e.g., deallocating memory twice). An excellent example
    of alternative mechanisms that other languages use is Rust. It implements a unique
    memory ownership model that replaces automatic global garbage collection. Unfortunately,
    while more efficient, it turns out that writing code in Rust is much more complicated
    than in Go. That’s why we see higher adoption of Go. This reflects the Go team’s
    ease-of-use trade-off in this element.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are ways to mitigate the negative performance consequences
    of the garbage collection mechanism in Go and keep our software lean and efficient.
    We will go through those in the following chapters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, Go is an incredibly elegant and consistent language. Moreover,
    it offers many modern and innovative features that make programming more effective
    and reliable. Plus, the code is readable and maintainable by design.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: This is a critical foundation for the efficiency improvements we will discuss
    later in this book. Like any other feature, optimizations always add complexity,
    so it’s easier to modify simple code than to complicate already complex code.
    Simplicity, safety, and readability are paramount, even for efficient code. Make
    sure you know how to achieve that without thinking about efficiency first!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Many resources go into more details for elements I could spend only a subchapter
    on. If you are interested to learn more, there is nothing better than practice.
    If you need more experience with Go before we jump into optimizations, here is
    a short list of excellent resources:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[“Effective Go”](https://oreil.ly/9auky)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Write Go Code”](https://oreil.ly/uS51g)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“A Tour of Go”](https://oreil.ly/LpGBN)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Practical Go Lessons”](https://oreil.ly/VnFms) by Maximilien Andile, available
    for free in the digital version'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributing to any open source project in Go, for example, through the [CNCF
    mentoring initiatives](https://oreil.ly/Y3D2Q) we offer four or more times a year
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The true power of the Go optimizations, benchmarking, and efficiency practices
    comes when used in practice, in everyday programming. Therefore, I want to empower
    you to marry efficiency with other good techniques around reliability or abstractions
    for practical use. While fully tailored logic sometimes has to be built for a
    critical path (as you will see in [Chapter 10](ch10.html#ch-opt)), the basic,
    often good enough, efficiency comes from understanding simple rules and language
    capabilities. That’s why I focused on giving you a better overview of Go and its
    features in this chapter. With this knowledge, we can now move to [Chapter 3](ch03.html#ch-efficiency),
    where we will learn how to start the journey to improve the efficiency and overall
    performance of our program’s execution when we need to.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45606843247856-marker)) New frameworks on tools for writing
    Go on small devices are emerging, e.g., [GoBot](https://gobot.io) and [TinyGo](https://tinygo.org).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45606843245632-marker)) It’s a controversial topic. There
    is quite a battle in the infrastructure industry for the superior language for
    configuration as code. For example, among HCL, Terraform, Go templates (Helm),
    Jsonnet, Starlark, and Cue. In 2018, we even open sourced a tool for writing configuration
    in Go, called [“mimic”](https://oreil.ly/FNjYD). Arguably, the loudest arguments
    against writing configuration in Go are that it feels too much like “programming”
    and requires programming skills from system administrators.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm45606843243616-marker)) WebAssembly is meant to change this,
    though, but [not soon](https://oreil.ly/rZqtp).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm45606843188400-marker)) CSP is a formal language that allows
    describing interactions in concurrent systems. Introduced by C.A.R. Hoare in *Communications
    of the ACM* (1978), it was an inspiration for the Go language concurrency system.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#idm45606843146464-marker)) Similar frustrations triggered another
    part of Google to create yet another language—[Carbon](https://oreil.ly/ijFPA)
    in 2022\. Carbon looks very promising, but it has different goals than Go. It
    is, by design, more efficiency aware and focused on familiarity with C++ concepts
    and interoperability. So let’s see how adoption will catch up for Carbon!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#idm45606843127920-marker)) One notable example is [the controversy
    behind dependency management work](https://oreil.ly/3gB9m).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.html#idm45606843118368-marker)) Of course, there are some inconsistencies
    here and there; that’s why the community created more [strict formatters](https://oreil.ly/RKUme),
    [linters](https://oreil.ly/VnQSC), or [style guides](https://oreil.ly/ETWSq).
    Yet the standard tools are good enough to feel comfortable in every Go codebase.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch02.html#idm45606843101632-marker)) There is one exception: unit test
    files that have to end with *_test.go*. These files can have either the same package
    name or the `<package_name>_test` name allowing to mimic external users of the
    package.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch02.html#idm45606842831664-marker)) In practice, you can quickly obtain
    the C++ or Go code (even when obfuscated) from the compiled binary anyway, especially
    if you don’t strip the binary from the debugging symbols.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch02.html#idm45606842772304-marker)) Standard library means packages
    that are shipped together with the Go language tooling and runtime code. Usually,
    only mature and core functionalities are provided, as Go has strong compatibility
    guarantees. Go also maintains an experimental [`golang.org/x/exp`](https://oreil.ly/KBTwn)
    module that contains useful code that must be proven to graduate to the standard
    library.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch02.html#idm45606842681408-marker)) While Go is improving every day,
    sometimes you can add more advanced tools like [`goimports`](https://oreil.ly/pS9MI)
    or [`bingo`](https://oreil.ly/mkjO2) to improve the development experience further.
    In some areas, Go can’t be opinionated and is limited by stability guarantees.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch02.html#idm45606842674272-marker)) [The CAP Theorem](https://oreil.ly/HyBdB)
    mentions an excellent example of treating failures seriously. It states that you
    can only choose two from three system characteristics: consistency, availability,
    and partition. As soon as you distribute your system, you must deal with network
    partition (communication failure). As an error-handling mechanism, you can either
    design your system to wait (lose availability) or operate on partial data (lose
    consistency).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch02.html#idm45606842670048-marker)) [`bash` has many methods for error
    handling](https://oreil.ly/Tij9n), but the default one is implicit. The programmer
    can optionally print or check `${?}` that holds the exit code of the last command
    executed before any given line. An exit code of 0 means the command is executed
    without any issues.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch02.html#idm45606842664160-marker)) In principle, a monad is an object
    that holds some value optionally, for example, some object `Option<Type>` with
    methods `Get()` and `IsEmpty()`. Furthermore, an “error monad” is an `Option`
    object that holds an error if the value is not set (sometimes referred to as `Result<Type>`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch02.html#idm45606839042576-marker)) Such code is not recommended for
    production, but the only things that would need to change are avoiding using global
    variables and checking all errors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch02.html#idm45606838437664-marker)) This assertion pattern is also typical
    in other third-party libraries like the popular [`testify` package](https://oreil.ly/I47fD).
    However, I am not a fan of the `testify` package, because there are too many ways
    of doing the same thing.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch02.html#idm45606838184304-marker)) Since programs, e.g., in Java, compile
    to Java bytecode, many things happen before the code is translated to actual machine-understandable
    code. The complexity of this process is too great to be understood by a mere mortal,
    so [machine learning “AI” tools were created](https://oreil.ly/baNvh) to auto-tune
    JVM.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch02.html#idm45606838174512-marker)) [A survey in 2020](https://oreil.ly/WrtCH)
    shows that among the top 10 used programming languages, 2 mandates object-oriented
    programming (Java, C#), 6 encourage it, and 2 do not implement OOP. I personally
    almost always favor object-oriented programming for algorithms that have to hold
    some context larger than three variables between data structures or functions.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch02.html#idm45606837116448-marker)) I prefer [functions to methods](https://oreil.ly/Et9CE),
    as they’re easier to use in most cases.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch02.html#idm45606836849296-marker)) The summary was well explained on
    the [*PlanetScale* blog post](https://oreil.ly/ksqO0).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: ^([21](ch02.html#idm45606836733504-marker)) To name a few public changes, we’ve
    seen the [Salesforce case](https://oreil.ly/H3WsC), [AppsFlyer](https://oreil.ly/iazde),
    and [Stream](https://oreil.ly/NSJLD).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: ^([22](ch02.html#idm45606836729648-marker)) For example, when we look at some
    [benchmarks](https://oreil.ly/s7qTj), we see Go as sometimes faster, sometimes
    slower than Java. Yet if we look at CPU loads, every time Go or Java is faster,
    it’s simply faster because, for example, the implementation allowed fewer CPU
    cycles to be wasted on memory access. You can achieve that in any programming
    language. The question is, how hard was it to achieve this? We don’t usually measure
    how much time we spend to optimize code in each particular language, how easy
    it is to read or extend such code after optimizations, etc. Only those metrics
    might tell us which programming language is “faster.”
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
