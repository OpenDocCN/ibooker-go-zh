- en: Chapter 2\. Efficient Introduction to Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is efficient, scalable, and productive. Some programmers find it fun to work
    in; others find it unimaginative, even boring. ... Those are not contradictory
    positions. Go was designed to address the problems faced in software development
    at Google, which led to a language that is not a breakthrough research language
    but is nonetheless an excellent tool for engineering large software projects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/3EItq)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I am a huge fan of the Go programming language. The number of things developers
    around the world have been able to achieve with Go is impressive. For a few years
    in a row, Go has been on the list of [top five languages people love or want to
    learn](https://oreil.ly/la9bx). It is used in many businesses, including bigger
    tech companies like Apple, American Express, Cloudflare, Dell, Google, Netflix,
    Red Hat, Twitch, and [others](https://oreil.ly/DSM73). Of course, as with everything,
    nothing is perfect. I would probably change, remove, or add a few things to Go,
    but if you would wake me in the middle of the night and ask me to quickly write
    reliable backend code, I would write it in Go. CLI? In Go. Quick, reliable script?
    In Go as well. The first language to learn as a junior programmer? Go. Code for
    IoT, robots, and microprocessors? The answer is also Go.^([1](ch02.html#idm45606843247856))
    Infrastructure configuration? As of 2022, I don’t think there is a better tool
    for robust templating than Go.^([2](ch02.html#idm45606843245632))
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get me wrong, there are languages with specialized capabilities or ecosystems
    that are superior to Go. For example, think about graphical user interfaces (GUIs),
    advanced rendering parts of the game industry, or code running in browsers.^([3](ch02.html#idm45606843243616))
    However, once you realize the many advantages of the Go language, it is pretty
    painful to jump back to others.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#ch-efficiency-matters), we spent some time establishing
    an efficiency awareness for our software. As a result, we learned that our goal
    is to write efficient code with the least development effort and cost. This chapter
    will explain why the Go programming language can be a solid option to achieve
    this balance between performance and other software qualities.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with [“Basics You Should Know About Go”](#ch-go-intro), then continue
    with [“Advanced Language Elements”](#ch-go-adv). Both sections list the short
    but essential facts everyone should know about Go, something I wish I had known
    when I started my journey with Go in 2014\. These sections will cover much more
    than just basic information about efficiency and can be used as an introduction
    to Go. However, if you are entirely new to the language, I would still recommend
    reading those sections, then checking other resources mentioned in the summary,
    perhaps writing your first program in Go, and then getting back to this book.
    On the other hand, if you consider yourself a more advanced user or expert, I
    suggest not skipping this chapter. I explain a few lesser-known facts about Go
    that you might find interesting or controversial (it’s OK, everyone can have their
    own opinions!).
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we will finish by answering the tricky question about the
    overall Go efficiency capabilities in [“Is Go “Fast”?”](#ch-go-fast), as compared
    to other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Basics You Should Know About Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is an open source project maintained by Google within a distributed team
    called the “Go team.” The project consists of the programming language specification,
    compilator, tooling, documentation, and standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through some facts and best practices to understand Go basics and its
    characteristics in fast-forward mode. While some advice here might feel opinionated,
    this is based on my experience working with Go since 2014—a background full of
    incidents, past mistakes, and lessons learned the hard way. I’m sharing them here
    so you don’t need to make those errors.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative, Compiled, and Statically Typed Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central part of the Go project is the general-purpose language with the
    same name, primarily designed for systems programming. As you will notice in [Example 2-1](#code-basic),
    Go is an imperative language, so we have (some) control over how things are executed.
    In addition, it’s statically typed and compiled, which means that the compiler
    can perform many optimizations and checks before the program runs. These characteristics
    alone are an excellent start to make Go suitable for reliable and efficient programs.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Simple program printing “Hello World” and exiting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both project and language are called “Go,” yet sometimes you can refer to them
    as “Golang.”
  prefs: []
  type: TYPE_NORMAL
- en: Go Versus Golang
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a rule of thumb, we should always use the “Go” name everywhere, unless it’s
    clashing with the English word *go* or an ancient game called “Go.” “Golang” came
    from the domain choice ([*https://golang.org*](https://golang.org)) since “go”
    was unavailable to its authors. So use “Golang” when searching for resources about
    this programming language on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Go also has its mascot, called the [“Go gopher”](https://oreil.ly/SbxVX). We
    see this cute gopher in various forms, situations, and combinations, such as conference
    talks, blog posts, or project logos. Sometimes Go developers are called “gophers”
    too!
  prefs: []
  type: TYPE_NORMAL
- en: Designed to Improve Serious Codebases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It all started when three experienced programmers from Google sketched the
    idea of the Go language around 2007:'
  prefs: []
  type: TYPE_NORMAL
- en: Rob Pike
  prefs: []
  type: TYPE_NORMAL
- en: Cocreator of UTF-8 and the Plan 9 operating system. Coauthor of many programming
    languages before Go, such as Limbo for writing distributed systems and Newsqueak
    for writing concurrent applications in graphical user interfaces. Both were inspired
    by Hoare’s Communicating Sequential Processes (CSP).^([4](ch02.html#idm45606843188400))
  prefs: []
  type: TYPE_NORMAL
- en: Robert Griesemer
  prefs: []
  type: TYPE_NORMAL
- en: Among other work, Griesemer developed the [Sawzall language](https://oreil.ly/gYKMj)
    and did a doctorate with Niklaus Wirth. The same Niklaus wrote “A Plea for Lean
    Software” quoted in [“Software gets slower more rapidly than hardware becomes
    faster”](ch01.html#ch-eff-s-hardware-slower).
  prefs: []
  type: TYPE_NORMAL
- en: Ken Thompson
  prefs: []
  type: TYPE_NORMAL
- en: One of the original authors of the first Unix system. Sole creator of the `grep`
    command-line utility. Ken cocreated UTF-8 and Plan 9 with Rob Pike. He wrote a
    couple of languages, too, e.g., the Bon and B programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: These three aimed to create a new programming language that was meant to improve
    mainstream programming, led by C++, Java, and Python at that point. After a year,
    it became a full-time project, with Ian Taylor and Russ Cox joining in 2008 what
    was [later referenced as the Go team](https://oreil.ly/Nnj6N). The Go team announced
    the public Go project in 2009, with version 1.0 released in March 2012.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main frustrations^([5](ch02.html#idm45606843146464)) related to C++ mentioned
    in the design of Go were:'
  prefs: []
  type: TYPE_NORMAL
- en: Complexity, many ways of doing the same thing, too many features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultralong compilation times, especially for bigger codebases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost of updates and refactors in large projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not easy to use and memory model prone to errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements are why Go was born, from the frustration of existing solutions
    and the ambition to allow more by doing less. The guiding principles were to make
    a language that does not trade safety for less repetition, yet allows simpler
    code. It does not sacrifice execution efficiency for faster compilation or interpreting,
    yet ensures that build times are quick enough. [Go tries to compile as fast as
    possible, e.g., thanks to explicit imports](https://oreil.ly/qxuUS). Especially
    with caching enabled by default, only changed code is compiled, so build times
    are rarely longer than a minute.
  prefs: []
  type: TYPE_NORMAL
- en: You Can Treat Go Code as Script!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While technically Go is a compiled language, you can run it like you would run
    JavaScript, Shell, or Python. It’s as simple as invoking `go run <executable package>
    <flags>`. It works great because the compilation is ultrafast. You can treat it
    like a scripting language while maintaining the advantages of compilation.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of syntax, Go was meant to be simple, light on keywords, and familiar.
    Syntax is based on C with type derivation (automatic type detection, like `auto`
    in C++), and no forward declarations, no header files. Concepts are kept orthogonal,
    which allows easier combination and reasoning about them. Orthogonality for elements
    means that, for example, we can add methods to any type or data definition (adding
    methods is separate from creating types). Interfaces are orthogonal to types too.
  prefs: []
  type: TYPE_NORMAL
- en: Governed by Google, Yet Open Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since announcing Go, all development has been done in [open source](https://oreil.ly/ZeKm6),
    with public mailing lists and bug trackers. Changes go to the public, authoritative
    source code, held under the [BSD style license](https://oreil.ly/XBDEK). The Go
    team reviews all contributions. The process is the same if the change or idea
    is coming from Google or not. The project road maps and proposals are developed
    in public too.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the sad truth is that there are many open source projects, but
    some projects are less open than others. Google is still the only company stewarding
    Go and has the last decisive control over it. Even if anyone can modify, use,
    and contribute, projects coordinated by a single vendor risk selfish and damaging
    decisions like relicensing or blocking certain features. While there were some
    controversial cases where the Go team decision surprised the community,^([6](ch02.html#idm45606843127920))
    overall the project is very reasonably well governed. Countless changes came from
    outside of Google, and the Go 2.0 draft proposal process has been well respected
    and community driven. In the end, I believe consistent decision-making and stewarding
    from the Go team bring many benefits too. Conflicts and different views are inevitable,
    and having one consistent overview, even if not perfect, might be better than
    no decision or many ways of doing the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: So far, this project setup has proven to work well for adoption and language
    stability. For our software efficiency goals, such alignment couldn’t be better
    too. We have a big company invested in ensuring each release doesn’t bring any
    performance regressions. Some internal Google software depends on Go, e.g., [Google
    Cloud Platform](https://oreil.ly/vjyOc). And many people rely on the Google Cloud
    Platform to be reliable. On the other hand, we have a vast Go community that gives
    feedback, finds bugs, and contributes ideas and optimizations. And if that’s not
    enough, we have open source code, allowing us, mere mortal developers, to dive
    into the actual Go libraries, runtime (see [“Go Runtime”](#ch-go-runtime)), etc.,
    to understand the performance characteristics of the particular code.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity, Safety, and Readability Are Paramount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Robert Griesemer [mentioned in GopherCon 2015](https://oreil.ly/s3ZZ5) that
    first of all, they knew when they first started building Go what things NOT to
    do. The main guiding principle was simplicity, safety, and readability. In other
    words, Go follows the pattern of “less is more.” This is a potent idiom that spans
    many areas. In Go, there is only one *idiomatic* coding style,^([7](ch02.html#idm45606843118368))
    and a tool called `gofmt` ensures most of it. In particular, code formatting (next
    to naming) is an element that is rarely settled among programmers. We spend time
    arguing about it and tuning it to our specific needs and beliefs. Thanks to a
    single style enforced by tooling, we save enormous time. As one of the [Go proverbs](https://oreil.ly/ua2G8)
    goes, “Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite.”
    Overall, the Go authors planned the language to be minimal so that there is essentially
    one way to write a particular construct. This takes away a lot of decision-making
    when you are writing a program. There is one way of handling errors, one way of
    writing objects, one way of running things concurrently, etc.
  prefs: []
  type: TYPE_NORMAL
- en: A huge number of features might be “missing” from Go, yet [one could say it
    is more expressive than C or C++](https://oreil.ly/CPkvV). Such minimalism allows
    for maintaining the simplicity and readability of the Go code, which improves
    software reliability, safety, and overall higher velocity toward application goals.
  prefs: []
  type: TYPE_NORMAL
- en: Is My Code Idiomatic?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *idiomatic* is heavily overused in the Go community. Usually, it means
    Go patterns that are “often” used. Since Go adoption has grown a lot, people have
    improved the initial “idiomatic” style in many creative ways. Nowadays, it’s not
    always clear what’s idiomatic and what’s not.
  prefs: []
  type: TYPE_NORMAL
- en: It’s like the “This is the way” saying from the *Mandalorian* series. It makes
    us feel more confident when we say, “This code is idiomatic.” So the conclusion
    is to use this word with care and [avoid it unless you can elaborate the reasoning
    why some pattern is better](https://oreil.ly/dAAKz).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the “less is more” idiom can help our efficiency efforts for
    this book’s purpose. As we learned in [Chapter 1](ch01.html#ch-efficiency-matters),
    if you do less work at runtime, it usually means faster, lean execution and less
    complex code. In this book, we will try to maintain this aspect while improving
    our code performance.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging and Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go source code is organized into directories representing either packages
    or modules. A package is a collection of source files (with the *.go* suffix)
    in the same directory. The package name is specified with the `package` statement
    at the top of each source file, as seen in [Example 2-1](#code-basic). All files
    in the same directory must the same package name^([8](ch02.html#idm45606843101632))
    (the package name can be different from the directory name). Multiple packages
    can be part of a single Go module. A module is a directory with a *go.mod* file
    that states all dependent modules with their versions required to build the Go
    application. This file is then used by the dependency management tool [Go Modules](https://oreil.ly/z5GqG).
    Each source file in a module can import packages from the same or external modules.
    Some packages can also be “executable.” For example, if a package is called `main`
    and has `func main()` in some file, we can execute it. Sometimes such a package
    is placed in the cmd directory for easier discovery. Note that you cannot import
    the executable package. You can only build or run it.
  prefs: []
  type: TYPE_NORMAL
- en: Within the package, you can decide what functions, types, interfaces, and methods
    are exported to package users and which are accessible only in the package scope.
    This is important because exporting the minimal amount of API possible for readability,
    reusability, and reliability is better. Go does not have any `private` or `public`
    keywords for this. Instead, it takes a slightly new approach. As [Example 2-2](#code-export)
    shows, if the construct name starts with an uppercase letter, any code outside
    the package can use it. If the element name begins with a lowercase letter, it’s
    private. It’s worth noting that this pattern works for all constructs equally,
    e.g., functions, types, interfaces, variables, etc. (orthogonality).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Construct accessibility control using naming case
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Careful readers might notice tricky cases of exported fields or methods on private
    type or `interface`. Can someone outside the package use them if the `struct`
    or `interface` is private? This is quite rarely used, but the answer is yes, you
    can return a private `interface` or type in a public function, e.g., `func New()
    privateStruct { return privateStruct{}}`. Despite the `privateStruct` being private,
    all its public fields and methods are accessible to package users.
  prefs: []
  type: TYPE_NORMAL
- en: Internal Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can name and structure your code directories as you want to form packages,
    but one directory name is reserved for special meaning. If you want to ensure
    that only the given package can import other packages, you can create a package
    subdirectory named internal. Any package under the internal directory can’t be
    imported by any package other than the ancestor (and other packages in internal).
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies Transparency by Default
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In my experience, it is common to import precompiled libraries, such as in
    C++, C#, or Java, and use exported functions and classes defined in some header
    files. However, importing compiled code has some benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It relieves engineers from making an effort to compile particular code, i.e.,
    find and download correct versions of dependencies, special compilation tooling,
    or extra resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might be easier to sell such a prebuilt library without exposing the source
    code and worrying about the client copying the business value-providing code.^([9](ch02.html#idm45606842831664))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In principle, this is meant to work well. Developers of the library maintain
    specific programmatic contracts (APIs), and users of such libraries do not need
    to worry about implementation complexities.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in practice, this is rarely that perfect. Implementation can
    be broken or inefficient, the interfaces can mislead, and documentation can be
    missing. In such cases, access to the source code is invaluable, allowing us to
    more deeply understand implementation. We can find issues based on specific source
    code, not by guessing. We can even propose a fix to the library or fork the package
    and use it immediately. We can extract the required pieces and use them to build
    something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go assumes this imperfection by requiring each library’s parts (in Go: module’s
    packages) to be explicitly imported using a package URI called “import path.”
    Such import is also strictly controlled, i.e., unused imports or cyclic dependencies
    cause a compilation error. Let’s see different ways to declare these imports in
    [Example 2-3](#code-imports).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Portion of `import` statements from `github.com/prometheus/​prome⁠theus`
    module, main.go file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If the import declaration does not have a domain with a path structure, it means
    the package from the “standard”^([10](ch02.html#idm45606842772304)) library is
    imported. This particular import allows us to use code from the `$(go env GOROOT)/src/context/`
    directory with `context` reference, e.g., `context.Background()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The package can be imported explicitly without any identifier. We don’t want
    to reference any construct from this package, but we want to have some global
    variables initialized. In this case, the `pprof` package will add debugging endpoints
    to the global HTTP server router. While allowed, in practice we should avoid reusing
    global, modifiable variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Nonstandard packages can be imported using an import path in the form of an
    internet domain name and an optional path to the package in a certain module.
    For example, the Go tooling integrates well with `https://github.com`, so if you
    host your Go code in a Git repository, it will find a specified package. In this
    case, it’s the `https://github.com/oklog/run` Git repository with the `run` package
    in the `github.com/oklog/run` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If the package is taken from the current module (in this case, our module is
    `github.com/prometheus/prometheus`), packages will be resolved from your local
    directory. In our example, `<module root>/config`.
  prefs: []
  type: TYPE_NORMAL
- en: This model focuses on open and clearly defined dependencies. It works exceptionally
    well with the open source distribution model, where the community can collaborate
    on robust packages in the public Git repositories. Of course, a module or package
    can also be hidden using standard version control authentication protocols. Furthermore,
    the official tooling [does not support distributing packages in binary form](https://oreil.ly/EnkBT),
    so the dependency source is highly encouraged to be present for compilation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The challenges of software dependency are not easy to solve. Go learned from
    the mistakes of C++ and others, and takes a careful approach to avoid long compilation
    times, and an effect commonly called “dependency hell.”
  prefs: []
  type: TYPE_NORMAL
- en: Through the design of the standard library, great effort was spent on controlling
    dependencies. It can be better to copy a little code than to pull in a big library
    for one function. (A test in the system build complains if new core dependencies
    arise.) Dependency hygiene trumps code reuse. One example of this in practice
    is that the (low-level) net package has its own integer-to-decimal conversion
    routine to avoid depending on the bigger and dependency-heavy formatted I/O package.
    Another is that the string conversion package strconv has a private implementation
    of the definition of “printable” characters rather than pull in the large Unicode
    character class tables; that strconv honors the Unicode standard is verified by
    the package’s tests.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Rob Pike, [“Go at Google: Language Design in the Service of Software Engineering”](https://oreil.ly/wqKGT)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Again, with efficiency in mind, potential minimalism in dependencies and transparency
    brings enormous value. Fewer unknowns means we can quickly detect main bottlenecks
    and focus on the most significant value optimizations first. We don’t need to
    work around it if we notice potential room for optimization in our dependency.
    Instead, we are usually welcome to contribute the fix directly to the upstream,
    which helps both sides!
  prefs: []
  type: TYPE_NORMAL
- en: Consistent Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the beginning, Go had a powerful and consistent set of tools as part of
    its command-line interface tool, called `go`. Let’s enumerate a few utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go bug` opens a new browser tab with the correct place where you can file
    an official bug report (Go repository on GitHub).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go build -o <output path> <packages>` builds given Go packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go env` shows all Go-related environment variables currently set in your terminal
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go fmt <file, packages or directories>` formats given artifacts to the desired
    style, cleans whitespaces, fixes wrong indentations, etc. Note that the source
    code does not need to be even valid and compilable Go code. You can also install
    an extended official formatter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`goimports`](https://oreil.ly/6fDcy) also cleans and formats your `import`
    statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the best experience, set your programming IDE to run `goimports -w $FILE`
    on every file to not worry about the manual indentation anymore!
  prefs: []
  type: TYPE_NORMAL
- en: '`go get <package@version>` allows you to install the desired dependency with
    the expected version. Use the `@latest` suffix to get the latest version of `@none`
    to uninstall the dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go help <command/topic>` prints documentation about the command or given topic.
    For example, `go help environment` tells you all about the possible environment
    variables Go uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go install <package>` is similar to `go get` and installs the binary if the
    given package is “executable.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go list` lists Go packages and modules. It allows flexible output formatting
    using Go templates (explained later), e.g., `go list -mod=readonly -m -f ''{{
    if and (not .Indirect) (not .Main)}}{{.Path}}{{end}}'' all` lists all direct nonexecutable
    dependent modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go mod` allows managing dependent modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go test` allows running unit tests, fuzz tests, and benchmarks. We will discuss
    the latter in detail in [Chapter 8](ch08.html#ch-benchmarking).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go tool` hosts a dozen more advanced CLI tools. We will especially take a
    close look at `go tool pprof` in [“pprof Format”](ch09.html#ch-obs-pprof) for
    performance optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go vet` runs basic static analysis checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the Go CLI is all you need for effective Go programming.^([11](ch02.html#idm45606842681408))
  prefs: []
  type: TYPE_NORMAL
- en: Single Way of Handling Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Errors are an inevitable part of every running software. Especially in distributed
    systems, they are expected by design, with advanced research and algorithms for
    handling different types of failures.^([12](ch02.html#idm45606842674272)) Despite
    the need for errors, most programming languages do not recommend or enforce a
    particular way of failure handling. For example, in C++ you see programmers using
    all means possible to return an error from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer return codes (if the returned value is nonzero, it means error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit status codes^([13](ch02.html#idm45606842670048))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other sentinel values (if the returned value is `null`, then it’s an error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning potential error by argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads^([14](ch02.html#idm45606842664160))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each option has its pros and cons, but just the fact that there are so many
    ways of handling errors can cause severe issues. It causes surprises by potentially
    hiding that some statements can return an error, introduces complexity and, as
    a result, makes our software unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly, the intention for so many options was good. It gives a developer
    choices. Maybe the software you create is noncritical, or is the first iteration,
    so you want to make a “happy path” crystal clear. In such cases, masking some
    “bad paths” sounds like a good short-term idea, right? Unfortunately, as with
    many shortcuts, it poses numerous dangers. Software complexity and demand for
    functionalities cause the code to never go out of the “first iteration,” and noncritical
    code quickly becomes a dependency for something critical. This is one of the most
    important causes of unreliability or hard-to-debug software.
  prefs: []
  type: TYPE_NORMAL
- en: Go takes a unique path by treating the error as a first-citizen language feature.
    It assumes we want to write reliable software, making error handling explicit,
    easy, and uniform across libraries and interfaces. Let’s see some examples in
    [Example 2-4](#code-errors).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Multiple function signatures with different return arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The critical aspect here is that functions and methods define the error flow
    as part of their signature. In this case, the `noErrCanHappen` function states
    that there is no way any error can happen during its invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the `doOrErr` function signature, we know some errors can happen.
    We don’t know what type of error yet; we only know it is implementing a built-in
    `error` interface. We also know that there was no error if the error is nil.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that Go functions can return multiple arguments is leveraged when calculating
    some result in a “happy path.” If the error can happen, it should be the last
    return argument (always). From the caller side, we should only touch the result
    if the error is nil.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that Go has an exception mechanism called `panics`, which
    are recoverable using the `recover()` built-in function. While useful or necessary
    for certain cases (e.g., initialization), you should never use `panics` for conventional
    error handling in your production code in practice. They are less efficient, hide
    failures, and overall surprise the programmers. Having errors as part of invocation
    allows the compilator and programmer to be prepared for error cases in the normal
    execution path. [Example 2-5](#code-handling) shows how we can handle errors if
    they occur in our function execution path.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Checking and handling errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we did not import the built-in `errors` package, but instead used
    the open source drop-in replacement `github.com/efficientgo/core/errors`. `core`
    module. This is my recommended replacement for the `errors` package and the popular,
    but archived, `github.com/pkg/errors`. It allows a bit more advanced logic, like
    wrapping errors you will see in step three.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: To tell if an error happened, we need to check if the `err` variable is nil
    or not. Then, if an error occurs, we can follow with error handling. Usually,
    it means logging it, exiting the program, incrementing metrics, or even explicitly
    ignoring it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it’s appropriate to delegate error handling to the caller. For example,
    if the function can fail from many errors, consider wrapping it with a `errors.Wrap`
    function to add a short context of what is wrong. For example, with `github.com/efficientgo/core/errors`,
    we will have context and stack trace, which will be rendered if `%+v` is used
    later.
  prefs: []
  type: TYPE_NORMAL
- en: How to Wrap Errors?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that I recommended `errors.Wrap` (or `errors.Wrapf`) instead of the built-in
    way of wrapping errors. Go defines the `%w` identifier for the `fmt.Errors` type
    of function that allows passing an error. Currently, I would not recommend `%w`
    because it’s not type safe and as explicit as `Wrap`, causing nontrivial bugs
    in the past.
  prefs: []
  type: TYPE_NORMAL
- en: The one way of defining errors and handling them is one of Go’s best features.
    Interestingly, it is one of the language disadvantages due to verbosity and certain
    boilerplate involved. It sometimes might feel repetitive, but tools allow you
    to mitigate the boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Some Go IDEs define code templates. For example, in JetBrain’s GoLand product,
    typing **`err`** and pressing the Tab key will generate a valid `if err != nil`
    statement. You can also collapse or expand error handling blocks for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Another common complaint is that writing Go can feel very “pessimistic,” because
    the errors that may never occur are visible in plain sight. The programmer has
    to decide what to do with them at every step, which takes mental energy and time.
    Yet, in my experience it’s worth the work and makes programs much more predictable
    and easier to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Never Ignore Errors!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the verbosity of error handling, it’s tempting to skip `err != nil` checks.
    Consider not doing it unless you know a function will never return an error (and
    in future versions!). If you don’t know what to do with the error, consider passing
    it to the caller by default. If you must ignore the error, consider doing it explicitly
    with the `_ =` syntax. Also, always use linters, which will warn you about some
    portion of unchecked errors.
  prefs: []
  type: TYPE_NORMAL
- en: Are there any implications of the error handling for general Go code runtime
    efficiency? Yes! Unfortunately, it’s much more significant than developers usually
    anticipate. In my experience, error paths are frequently an order of magnitude
    slower and more expensive to execute than happy paths. One of the reasons is we
    tend not to ignore error flows during our monitoring or benchmarking steps (mentioned
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow)).
  prefs: []
  type: TYPE_NORMAL
- en: Another common reason is that the construction of errors often involves heavy
    string manipulation for creating human-readable messages. As a result, it can
    be costly, especially with lengthy debugging tags, which are touched on later
    in this book. Understanding these implications and ensuring consistent and efficient
    error handling are essential in any software, and we will take a detailed look
    at that in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A commonly stated strong point of Go is that its ecosystem is exceptionally
    mature for such a “young” language. While items listed in this section are not
    mandatory for solid programming dialects, they improve the whole development experience.
    This is also why the Go community is so large and still growing.
  prefs: []
  type: TYPE_NORMAL
- en: First, Go allows the programmer to focus on business logic without necessarily
    reimplementing or importing third-party libraries for basic functionalities like
    YAML decoding or cryptographic hashing algorithms. Go standard libraries are high
    quality, robust, ultra-backward compatible, and rich in features. They are well
    benchmarked, have solid APIs, and have good documentation. As a result, you can
    achieve most things without importing external packages. For example, running
    an HTTP server is dead simple, as visualized in [Example 2-6](#code-basicserver).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Minimal code for serving HTTP requests^([15](ch02.html#idm45606839042576))
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, the efficiency of standard libraries is good enough or even better
    than third-party alternatives. For example, especially lower-level elements of
    packages, `net/http` for HTTP client and server code, or `crypto`, `math`, and
    `sort` parts (and more!), have a good amount of optimizations to serve most of
    the use cases. This allows developers to build more complex code on top while
    not worrying about the basics like `sorting` performance. Yet that’s not always
    the case. Some libraries are meant for specific usage, and misusing them may result
    in significant resource waste. We will look at all the things you need to be aware
    of in [Chapter 11](ch11.html#ch-opt2).
  prefs: []
  type: TYPE_NORMAL
- en: Another highlight of the mature ecosystem is a basic, official in-browser Go
    editor called [Go Playground](https://oreil.ly/9Os3y). It’s a fantastic tool if
    you want to test something out quickly or share an interactive code example. It’s
    also straightforward to extend, so the community often publishes variations of
    the Go Playground to try and share previously experimental language features like
    [generics](https://oreil.ly/f0qpm) (which are now part of the primary language
    and explained in [“Generics”](#ch-go-generics)).
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the Go project defines its templating language, called [Go
    templates](https://oreil.ly/FdEZ8). In some way, it’s similar to Python’s [Jinja2
    language](https://oreil.ly/U6Em1). While it sounds like a side feature of Go,
    it’s beneficial in any dynamic text or HTML generation. It is also often used
    in popular tools like [Helm](https://helm.sh) or [Hugo](https://gohugo.io).
  prefs: []
  type: TYPE_NORMAL
- en: Unused Import or Variable Causes Build Error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compilation will fail if you define a variable in Go but never read any
    value from it or don’t pass it to another function. Similarly, it will fail if
    you added a package to the `import` statement but don’t use that package in your
    file.
  prefs: []
  type: TYPE_NORMAL
- en: I see that Go developers have gotten used to this feature and love it, but it
    is surprising for newcomers. Failing on unused constructs can be frustrating if
    you want to play with the language quickly, e.g., create some variable without
    using it for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, ways to handle these cases explicitly! You can see a few
    examples of dealing with these usage checks in [Example 2-7](#code-unused).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Various examples of unused and used variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Variables `a`, `b`, and `c` are not used, so they cause a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `e` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `f` is technically used for an explicit no identifier (`_`). Such an
    approach is useful if you explicitly want to tell the reader (and compiler) that
    you want to ignore the value.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, unused imports will fail the compilation process, so tools like `goimports`
    (mentioned in [“Consistent Tooling”](#ch-go-tooling)) automatically remove unused
    ones. Failing on unused variables and imports effectively ensures that code stays
    clear and relevant. Note that only internal function variables are checked. Elements
    like unused `struct` fields, methods, or types are not checked.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing and Table Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tests are a mandatory part of every application, small or big. In Go, tests
    are a natural part of the development process—easy to write, and focused on simplicity
    and readability. If we want to talk about efficient code, we need to have solid
    testing in place, allowing us to iterate over the program without worrying about
    regressions. Add a file with the *_test.go* suffix to introduce a unit test to
    your code within a package. You can write any Go code within that file, which
    won’t be reachable from the production code. There are, however, four types of
    functions you can add that will be invoked for different testing parts. A certain
    signature distinguishes these types, notably function name prefixes: `Test`, `Fuzz`,
    `Example`, or `Benchmark`, and specific arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the unit test type in [Example 2-8](#code-test). To make
    it more interesting, it’s a table test. Examples and benchmarks are explained
    in [“Code Documentation as a First Citizen”](#ch-go-godoc) and [“Microbenchmarks”](ch08.html#ch-obs-micro).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Example unit table test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If the function inside the *_test.go* file is named with the `Test` word and
    takes exactly `t *testing.T`, it is considered a “unit test.” You can run them
    through the `go test` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we want to test a specific function using multiple test cases (often
    edge cases) that define different input and expected output. This is where I would
    suggest using table tests. First, define your input and output, then run the same
    function in an easy-to-read loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can invoke `t.Run`, which allows you to specify a subtest. Defining
    those on dynamic test cases like table tests is a good practice. It will enable
    you to navigate to the failing case quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The Go `testing.T` type gives useful methods like `Fail` or `Fatal` to abort
    and fail the unit test, or `Error` to continue running and check other potential
    errors. In our example, I propose using a simple helper called `testutil.Equals`
    from our [open source core library](https://oreil.ly/yAit9), giving you a nice
    diff.^([16](ch02.html#idm45606838437664))
  prefs: []
  type: TYPE_NORMAL
- en: Write tests often. It might surprise you, but writing unit tests for critical
    parts up front will help you implement desired features much faster. This is why
    I recommend following some reasonable form of test-driven development, covered
    in [“Efficiency-Aware Development Flow”](ch03.html#ch-conq-eff-flow).
  prefs: []
  type: TYPE_NORMAL
- en: This information should give you a good overview of the language goals, strengths,
    and features before moving to more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Language Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now discuss the more advanced features of Go. Similar to the basics mentioned
    in the previous section, it’s crucial to overview core language capabilities before
    discussing efficiency improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Code Documentation as a First Citizen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every project, at some point, needs solid API documentation. For library-type
    projects, the programmatic APIs are the main entry point. Robust interfaces with
    good descriptions allow developers to hide complexity, bring value, and avoid
    surprises. A code interface overview is essential for applications, too, allowing
    anyone to understand the codebase quickly. Reusing an application’s Go packages
    in other projects is also not uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of relying on the community to create many potentially fragmented and
    incompatible solutions, the Go project developed a tool called [`godoc`](https://oreil.ly/TQXxv)
    from the start. It behaves similarly to Python’s [Docstring](https://oreil.ly/UdkzS)
    and Java’s [Javadoc](https://oreil.ly/wlWGT). `godoc` generates a consistent documentation
    HTML website directly from the code and its comments.
  prefs: []
  type: TYPE_NORMAL
- en: The amazing part is that you don’t have many special conventions that would
    directly make the code comments less readable from the source code. To use this
    tool effectively, you need to remember five things. Let’s go through them using
    Examples [2-9](#code-godoc) and [2-10](#code-godoc2). The resulting HTML page,
    when [`godoc` is invoked](https://oreil.ly/EYJlx), can be seen in [Figure 2-1](#img-godoc).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. Example snippet of block.go file with `godoc` compatible documentation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: The optional package-level description must be placed on top of the
    `package` entry with no intervening blank line and start with the `Package <name>`
    prefix. If any source files have these entries, `godoc` will collect them all.
    If you have many files, the convention is to have the *doc.go* file with just
    the package-level documentation, package statement, and no other code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2: Any public construct should have a full sentence commentary, starting
    with the name of the construct (it’s important!), right before its definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 3: Known bugs can be mentioned with `// BUG(who)` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Private constructs can have comments, but they will never be exposed in the
    documentation since they are private. Be consistent and start them with a construct
    name, too, for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Example snippet of block_test.go file with `godoc` compatible
    documentation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 4: If you write a function named `Example<ConstructName>` in the test
    file, e.g., `block_test.go`, the `godoc` will generate an interactive code block
    with the desired examples. Note that the package name must have a *_test* suffix,
    too, representing a local testing package that tests the package without access
    to private fields. Since examples are part of the unit test, they will be actively
    run and compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 5: If the example has the last comment starting with `// Output:`, the
    string after it will be asserted with the standard output after the example, allowing
    the example to stay reliable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![efgo 0201](assets/efgo_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. `godoc` output of Examples [2-9](#code-godoc) and [2-10](#code-godoc2)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I highly recommend sticking to those five simple rules. Not only because you
    can manually run `godoc` and generate your documentation web page, but the additional
    benefit is that these rules make your Go code comments structured and consistent.
    Everyone knows how to read them and where to find them.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using complete English sentences in all comments, even if the will
    not appear in `godoc`. It will help you keep your code commentary self-explanatory
    and explicit. After all, comments are for humans to read.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the Go team maintains a [public documentation website](https://pkg.go.dev)
    that scrapes all requested public repositories for free. Thus, if your public
    code repository is compatible with `godoc`, it will be rendered correctly, and
    users can read the autogenerated documentation for every module or package version.
  prefs: []
  type: TYPE_NORMAL
- en: Backward Compatibility and Portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has a strong take on backward compatibility guarantees. This means that core
    APIs, libraries, and language specifications should never break old code created
    for [Go 1.0](https://oreil.ly/YOKfu). This was proven to be well executed. There
    is a lot of trust in upgrading Go to the latest minor or patch versions. Upgrades
    are, in most cases, smooth and without significant bugs and surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding efficiency compatibility, it’s hard to discuss any guarantees. There
    is (usually) no guarantee that the function that does two memory allocations now
    will not use hundreds in the next version of the Go project and any library. There
    have been surprises between versions in efficiency and speed characteristics.
    The community is working hard on improving the compilation and language runtime
    (more in [“Go Runtime”](#ch-go-runtime) and [Chapter 4](ch04.html#ch-hardware)).
    Since the hardware and operating systems are also developed, the Go team is experimenting
    with different optimizations and features to allow everyone to execute more efficiently.
    Of course, we don’t speak about major performance regression here, as that is
    usually noticed and fixed in the release candidate period. Yet if we want our
    software to be deliberately fast and efficient, we need to be more vigilant and
    aware of the changes Go introduces.
  prefs: []
  type: TYPE_NORMAL
- en: Source code is compiled into binary code that is targeted to each platform.
    Yet Go tooling allows cross-platform compilation, so you can build binaries to
    almost all architectures and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute the Go binary, which was compiled for a different operating
    system (OS) or architecture, it can return cryptic error messages. For example,
    a common error is an Exec format error when you try running binary for Darwin
    (macOS) on Linux. You must recompile the code source for the correct architecture
    and OS if you see this.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding portability, we can’t skip mentioning the Go runtime and its characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Go Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many languages decided to solve portability across different hardware and operating
    systems by using virtual machines. Typical examples are [Java Virtual Machine
    (JVM)](https://oreil.ly/fhOmL) for Java bytecode compatible languages (e.g., Java
    or Scala), and [Common Language Runtime (CLR)](https://oreil.ly/StGbU) for .NET
    code, e.g., C#. Such a virtual machine allows for building languages without worrying
    about complex memory management logic (allocation and releasing), differences
    between hardware and operating systems, etc. JVM or CLR interprets the intermediate
    bytecode and transfers program instructions to the host. Unfortunately, while
    making it easier to create a programming language, they also introduce some overhead
    and many unknowns.^([17](ch02.html#idm45606838184304)) To mitigate the overhead,
    virtual machines often use complex optimizations like [just-in-time (JIT) compilation](https://oreil.ly/XXARz)
    to process chunks of specific virtual machine bytecode to machine code on the
    fly.
  prefs: []
  type: TYPE_NORMAL
- en: Go does not need any “virtual machine.” Our code and used libraries compile
    fully to machine code during compilation time. Thanks to standard library support
    of large operating systems and hardware, our code, if compiled against particular
    architecture, will run there with no issues.
  prefs: []
  type: TYPE_NORMAL
- en: Yet something is running in the background (concurrently) when our program starts.
    It’s the [Go runtime](https://oreil.ly/mywcZ) logic that, among other minor features
    of Go, is responsible for memory and concurrency management.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Undoubtedly, object-oriented programming (OOP) got enormous traction over the
    last decades. It was invented around 1967 by Alan Kay, and it’s still the most
    popular paradigm in programming.^([18](ch02.html#idm45606838174512)) OOP allows
    us to leverage advanced concepts like [encapsulation, abstraction, polymorphisms,
    and inheritance](https://oreil.ly/8hA0u). In principle, it allows us to think
    about code as some objects with attributes (in Go fields) and behaviors (methods)
    telling each other what to do. Most OOP examples talk about high-level abstractions
    like an animal that exposes the `Walk()` method or a car that allows to `Ride()`,
    but in practice, objects are usually less abstract yet still helpful, encapsulated,
    and described by a class. There are no classes in Go, but there are `struct` types
    equivalents. [Example 2-11](#code-oop) shows how we can write OOP code in Go to
    compact multiple block objects into one.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. Example of the OOP in Go with `Group` that can behave like `Block`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In Go, there is no separation between structures and classes, like in C++. In
    Go, on top of basic types like `integer`, `string`, etc., there is a `struct`
    type that can have methods (behaviors) and fields (attributes). We can use structures
    as a `class` equivalent to *encapsulate* more complex logic under a more straightforward
    interface. For example, the `Duration()` method on `Block` tells us the duration
    of the time range covered by the block.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If we add some struct, e.g., `Block`, into another struct, e.g., `Group`, without
    any name, such a `Block` `struct` is considered embedded instead of being a field.
    Embedding allows Go developers to get the most valuable part of *inheritance*,
    borrowing the embedded structure fields and methods. In this case, `Group` will
    have `Block`’s fields and `Duration` method. This way, we can reuse a significant
    amount of code in our production codebases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of methods you can define in Go: using the “value receiver”
    (e.g., as in the `Duration()` method) or using the “pointer receiver” (with `*`).
    The so-called receiver is the variable after `func`, which represents the type
    we are adding a method to, in our case `Group`. We will mention this in [“Values,
    Pointers, and Memory Blocks”](ch05.html#ch-hw-allocations), but the rule regarding
    which one to use is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the value receiver (no `func (g Group) SomeMethod()`) if your method does
    not modify the `Group` state. For the value receiver, every time we invoke it,
    the `g` will create a local copy of the `Group` object. It is equivalent to `func
    SomeMethod(g Group)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the pointer receiver (e.g., `func (g *Group) SomeMethod()`) if your method
    is meant to modify the local receiver state or if any other method does that.
    It is equivalent to `func SomeMethod(g *Group)`. In our example, if the `Group.Merge()`
    method would be a value receiver, we will not persist `g.childen` changes or potentially
    inject `g.start` and `g.end` values. Additionally, for consistency, it’s always
    recommended to have a type with all pointer receiver methods if at least one requires
    a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: To compact multiple blocks together, our algorithm requires a sorted list of
    blocks. We can use the standard library [`sort.Sort`](https://oreil.ly/N6ZWS),
    which expects the `sort.Interface` interface. The `[]Block` slice does not implement
    this interface, so we convert it to our temporary `sortable` type, explained in
    [Example 2-13](#code-oop-sortable).
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_efficient_introduction_to_go_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the only missing element for true inheritance. Go does not allow casting
    specific types into another type unless it’s an alias or strict single-struct
    embedding (shown in [Example 2-13](#code-oop-sortable)). After that, you can only
    cast the interface into some type. That’s why we need to specify embedded `struct`
    and `Block` explicitly. As a result, Go is often considered a language that does
    not support full inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: What does [Example 2-11](#code-oop) give us? First, the `Group` type can reuse
    `Block` functionality, and if done correctly, we can use `Group` as any other
    `Block`.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Multiple Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can embed as many unique structures as you want within one `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: There is no priority for these—the compilation will fail if the compilator can’t
    tell which method to use because two embedded types have the same `SomeMethod()`
    method. In such cases, use the type name to explicitly tell the compilator what
    should be used.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [Example 2-11](#code-oop), Go also allows defining interfaces
    that tell what methods `struct` has to implement to match it. Note that there
    is no need to mark a specific `struct` explicitly that implements a particular
    interface, as in other languages like Java. It’s enough just to implement the
    required methods. Let’s see an example of sorting interface exposed by the standard
    library in [Example 2-12](#code-oop-sort).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. Sorting interface from the standard `sort` Go library
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To use our type in the `sort.Sort` function, it has to implement all `sort.Interface`
    methods. [Example 2-13](#code-oop-sortable) shows how `sortable` type does it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Example of the type that can be sorted using `sort.Slice`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We can embed another type (e.g., a slice of `Block` elements) as the only thing
    in our `sortable` struct. This allows easy (but explicit) casting between `[]Block`
    and `sortable`, as we used in the `Compact` method in [Example 2-11](#code-oop).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can sort by increasing the `start` time using the [`time.Time.Before(...)`](https://oreil.ly/GQ2Ru)
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We can assert our `sortable` type implements `sort.Interface` using this single-line
    statement, which fails compilation otherwise. I recommend using such statements
    whenever you want to ensure your type stays compatible with a particular interface
    in the future!
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, `struct` methods, fields, and interfaces are an excellent yet simple
    way of writing both procedural composable and object-oriented code. In my experience,
    eventually it satisfies both low-level and high-level programming needs during
    our software development. While Go does not support all inheritance aspects (type
    to type casting), it provides enough to satisfy almost all OOP cases.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since version 1.18, Go supports [generics](https://oreil.ly/qYyuQ), one of the
    community’s most desired features. Generics, also called [parametric polymorphism](https://oreil.ly/UIUAg),
    allow type-safe implementations of the functionalities we want to reuse across
    different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The demand for generics in Go started quite big discussions in the Go team
    and community because of two main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Two ways of doing the same thing
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning, Go already supported type-safe reusable code via interfaces.
    You could see that in the preceding OOP example—the [`sort.Sort`](https://oreil.ly/X2NxR)
    can be reusable by all types that implement a `sort.Interface` presented in [Example 2-12](#code-oop-sort).
    We can sort our custom `Block` type by implementing those methods in [Example 2-13](#code-oop-sortable).
    Adding generics means we have [two ways of doing a thing](https://oreil.ly/dL8uE)
    in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: However, `interfaces` can be more troublesome for users of our code and slow
    at times due to [some runtime overhead](https://oreil.ly/8tSVf).
  prefs: []
  type: TYPE_NORMAL
- en: Overhead
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing generics can have many negative consequences for the language.
    Depending on the implementation, it can impact different things. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: We can just skip implementing them like in C, which slows programmers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use [monomorphization](https://oreil.ly/B062N), which essentially copies
    the code for each type that will be used. This impacts compile time and binary
    size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use boxing like in Java, which is quite similar to the Go interface implementation.
    In this case, we impact execution time or memory usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generic dilemma is this: do you want slow programmers, slow compilers and
    bloated binaries, or slow execution times?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Russ Cox, [“The Generic Dilemma”](https://oreil.ly/WjjV4)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After many proposals and debates, the final (extremely detailed!) [design](https://oreil.ly/k9cCR)
    was accepted. Initially, I was very skeptical, but the accepted generic use turned
    out to be clear and reasonable. So far, the community also didn’t jump ahead and
    abuse these mechanics as was feared. We tend to see generics used very rarely—only
    when needed, as it makes the code more complex to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could write a generic sort for all basic types like `int`, `float64`,
    or even `strings`, as presented in [Example 2-14](#code-generics).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Example implementation of the generic sort for basic types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to generics (also called type parameters), we can implement a single
    type that will implement `sort.Interface` (see [Example 2-13](#code-oop-sortable))
    for all basic types. We can provide custom constraints that look mostly like interfaces
    to limit the types that can be used as a type parameter. Here we use a type that
    represents `Integer | Float | ~string` constraints, so any type that supports
    comparison operators. We can put any other interface, like `any` to match all
    types. We can also use a special `comparable` keyword that will allow us to use
    the object of `T comparable` as a `map` key.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Any element of `s` slice is now expected to be of type `T` with `Ordered` constraints,
    so the compiler will allow us to compare them for `Less` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We can now implement a sort function for any basic type that will leverage `sort.Sort`
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to implement type-specific functions like `sort.Ints`. We can
    do `genericSortBasic[<type>]([]<type>)` as long as the slice is of the types that
    can be ordered!
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it only works for basic types. Unfortunately, we cannot override
    operators like `<` in Go (yet), so to implement generic sort for more complex
    types, we have to do a bit more work. For example, we could design our sort to
    expect each type to implement the `func <typeA> Compare(<typeA>) int` method.^([19](ch02.html#idm45606837116448))
    If we add this method to the `Block` in [Example 2-11](#code-oop), we can sort
    it easily, as presented in [Example 2-15](#code-generics2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. Example implementation of the generic sort for certain types
    of objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_efficient_introduction_to_go_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s design our constraint. We expect every type to have a `Compare` method
    that accepts the same type. Because constraints and interfaces can also have type
    parameters, we can implement such requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_efficient_introduction_to_go_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We can now provide a type that implements a `sort.Interface` interface for such
    kinds of objects. Notice the nested `T` in `Comparable[T]`, as our interface also
    is generic!
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_efficient_introduction_to_go_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can implement `Compare` for our `Block` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_efficient_introduction_to_go_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this, we don’t need to implement a `sortable` type for every custom
    type we want to sort. As long as the type has the `Compare` method, we can use
    `genericSort`!
  prefs: []
  type: TYPE_NORMAL
- en: The accepted design shows advantages in cases where the user interface alone
    would be cumbersome. But what about the generics dilemma problem? The design allows
    any [implementation](https://oreil.ly/rZBtz), so what trade-off was chosen at
    the end? We won’t go into the details in this book, but Go uses the [dictionaries
    and stenciling](https://oreil.ly/poLls) algorithm, which is between monomorphization
    and boxing.^([20](ch02.html#idm45606836849296))
  prefs: []
  type: TYPE_NORMAL
- en: Generic Code Will Be Faster?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specific implementation of generics in Go (which can change over time) means
    that the generic implementation, in theory, should be faster than interfaces but
    slower than implementing certain functionality for a specific type by hand. In
    practice, however, the potential difference is, in most cases, negligible, so
    use the most readable and easy-to-maintain option first.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, the difference might matter in the efficiency-critical code,
    but the results do not always follow the theory. For example, sometimes [generic
    implementation is faster](https://oreil.ly/9cEIb), and sometimes [using interfaces
    might be more efficient](https://oreil.ly/tiOhS). Conclusion? Always perform benchmarks
    ([Chapter 8](ch08.html#ch-benchmarking)) to be sure!
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, these facts are what I found crucial when teaching others programming
    in Go, based on my own experience with the language. Moreover, it will be helpful
    when diving deeper into the runtime performance of Go later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have never programmed in Go before, it’s worth going through
    other materials like the [tour of Go](https://oreil.ly/J3HE3) before jumping to
    the subsequent sections and chapters of this book. Make sure you try writing your
    own basic Go program, write a unit test, and use loops, switches, and concurrency
    mechanisms like channels and routines. Learn common types and standard library
    abstraction. As a person coming to a new language, you need to produce a program
    returning valid results before ensuring that it executes quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about some basic and advanced characteristics of Go, so it’s time
    to unwrap the efficiency aspects of the language. How easy is it to write good
    enough or high-performance code in Go?
  prefs: []
  type: TYPE_NORMAL
- en: Is Go “Fast”?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently, many companies have rewritten their products (e.g., from Ruby, Python,
    and Java) to Go.^([21](ch02.html#idm45606836733504)) Two repeatedly stated reasons
    for moving to Go or starting a new project in Go were readability and excellent
    performance. Readability comes from simplicity and consistency (e.g., single way
    of error handling as you remember from [“Single Way of Handling Errors”](#ch-go-errs)),
    and it’s where Go excels, but what about performance? Is Go fast compared to other
    languages like Python, Java, or C++?
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, this question is badly formed. Given time and room for complexities,
    any language can be as fast as your machine and operating system allow. That’s
    because, in the end, the code we write is compiled into machine code that uses
    the exact CPU instructions. Also, most languages allow delegating execution to
    other processes, e.g., written in optimized Assembly. Unfortunately, sometimes
    all we use to decide if a language is “fast” are raw, semi-optimized short program
    benchmarks that compare execution time and memory usage across languages. While
    it tells us something, it effectively does not show practical aspects, e.g., how
    complex the programming for efficiency was.^([22](ch02.html#idm45606836729648))
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we should look at a programming language in terms of how hard and practical
    it is to write efficient code (not just fast), and how much readability and reliability
    such a process sacrifices. I believe the Go language has a superior balance between
    those elements while keeping it fast and trivial to write basic, functional code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons for being able to write efficient code more easily is the
    hermetic compilation stage, the relatively small amount of unknowns in the Go
    runtime (see [“Go Runtime”](#ch-go-runtime)), the easy-to-use concurrency framework,
    and the maturity of the debugging, benchmarking, and profiling tools (discussed
    in Chapters [8](ch08.html#ch-benchmarking) and [9](ch09.html#ch-observability3)).
    Those Go characteristics did not appear from thin air. Not many know, but Go was
    designed on the shoulders of giants: C, Pascal, and CSP.'
  prefs: []
  type: TYPE_NORMAL
- en: In 1960, language experts from America and Europe teamed up to create Algol
    60\. In 1970, the Algol tree split into the C and the Pascal branch. ~40 years
    later, the two branches join again in Go.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robert Griesemer, [“The Evolution of Go”](https://oreil.ly/a4V1e)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we can see in [Figure 2-2](#img-go-roots), many of the names mentioned in
    [Chapter 1](ch01.html#ch-efficiency-matters) are grandfathers of Go. The great
    concurrency language CSP created by Sir Hoare, Pascal declarations and packages
    created by Wirth, and C basic syntax all contributed to how Go looks today.
  prefs: []
  type: TYPE_NORMAL
- en: '![efgo 0202](assets/efgo_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Go genealogy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But not everything can be perfect. In terms of efficiency, Go has its own Achilles’
    heel. As you will learn in [“Go Memory Management”](ch05.html#ch-hw-go-mem), memory
    usage can sometimes be hard to control. Allocations in our program can be surprising
    (especially for new users), and the garbage collections automatic memory release
    process has some overhead and eventual behavior. Especially for data-intensive
    applications, it takes effort to ensure memory or CPU efficiency, similar to machines
    with strictly limited RAM capacities (e.g., IoT).
  prefs: []
  type: TYPE_NORMAL
- en: Yet the decision to automate this process is highly beneficial, allowing the
    programmer to not worry about memory cleanup, which has proven to be even worse
    and sometimes catastrophic (e.g., deallocating memory twice). An excellent example
    of alternative mechanisms that other languages use is Rust. It implements a unique
    memory ownership model that replaces automatic global garbage collection. Unfortunately,
    while more efficient, it turns out that writing code in Rust is much more complicated
    than in Go. That’s why we see higher adoption of Go. This reflects the Go team’s
    ease-of-use trade-off in this element.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are ways to mitigate the negative performance consequences
    of the garbage collection mechanism in Go and keep our software lean and efficient.
    We will go through those in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, Go is an incredibly elegant and consistent language. Moreover,
    it offers many modern and innovative features that make programming more effective
    and reliable. Plus, the code is readable and maintainable by design.
  prefs: []
  type: TYPE_NORMAL
- en: This is a critical foundation for the efficiency improvements we will discuss
    later in this book. Like any other feature, optimizations always add complexity,
    so it’s easier to modify simple code than to complicate already complex code.
    Simplicity, safety, and readability are paramount, even for efficient code. Make
    sure you know how to achieve that without thinking about efficiency first!
  prefs: []
  type: TYPE_NORMAL
- en: 'Many resources go into more details for elements I could spend only a subchapter
    on. If you are interested to learn more, there is nothing better than practice.
    If you need more experience with Go before we jump into optimizations, here is
    a short list of excellent resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“Effective Go”](https://oreil.ly/9auky)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Write Go Code”](https://oreil.ly/uS51g)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“A Tour of Go”](https://oreil.ly/LpGBN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Practical Go Lessons”](https://oreil.ly/VnFms) by Maximilien Andile, available
    for free in the digital version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributing to any open source project in Go, for example, through the [CNCF
    mentoring initiatives](https://oreil.ly/Y3D2Q) we offer four or more times a year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The true power of the Go optimizations, benchmarking, and efficiency practices
    comes when used in practice, in everyday programming. Therefore, I want to empower
    you to marry efficiency with other good techniques around reliability or abstractions
    for practical use. While fully tailored logic sometimes has to be built for a
    critical path (as you will see in [Chapter 10](ch10.html#ch-opt)), the basic,
    often good enough, efficiency comes from understanding simple rules and language
    capabilities. That’s why I focused on giving you a better overview of Go and its
    features in this chapter. With this knowledge, we can now move to [Chapter 3](ch03.html#ch-efficiency),
    where we will learn how to start the journey to improve the efficiency and overall
    performance of our program’s execution when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45606843247856-marker)) New frameworks on tools for writing
    Go on small devices are emerging, e.g., [GoBot](https://gobot.io) and [TinyGo](https://tinygo.org).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45606843245632-marker)) It’s a controversial topic. There
    is quite a battle in the infrastructure industry for the superior language for
    configuration as code. For example, among HCL, Terraform, Go templates (Helm),
    Jsonnet, Starlark, and Cue. In 2018, we even open sourced a tool for writing configuration
    in Go, called [“mimic”](https://oreil.ly/FNjYD). Arguably, the loudest arguments
    against writing configuration in Go are that it feels too much like “programming”
    and requires programming skills from system administrators.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm45606843243616-marker)) WebAssembly is meant to change this,
    though, but [not soon](https://oreil.ly/rZqtp).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm45606843188400-marker)) CSP is a formal language that allows
    describing interactions in concurrent systems. Introduced by C.A.R. Hoare in *Communications
    of the ACM* (1978), it was an inspiration for the Go language concurrency system.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#idm45606843146464-marker)) Similar frustrations triggered another
    part of Google to create yet another language—[Carbon](https://oreil.ly/ijFPA)
    in 2022\. Carbon looks very promising, but it has different goals than Go. It
    is, by design, more efficiency aware and focused on familiarity with C++ concepts
    and interoperability. So let’s see how adoption will catch up for Carbon!
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#idm45606843127920-marker)) One notable example is [the controversy
    behind dependency management work](https://oreil.ly/3gB9m).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.html#idm45606843118368-marker)) Of course, there are some inconsistencies
    here and there; that’s why the community created more [strict formatters](https://oreil.ly/RKUme),
    [linters](https://oreil.ly/VnQSC), or [style guides](https://oreil.ly/ETWSq).
    Yet the standard tools are good enough to feel comfortable in every Go codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch02.html#idm45606843101632-marker)) There is one exception: unit test
    files that have to end with *_test.go*. These files can have either the same package
    name or the `<package_name>_test` name allowing to mimic external users of the
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch02.html#idm45606842831664-marker)) In practice, you can quickly obtain
    the C++ or Go code (even when obfuscated) from the compiled binary anyway, especially
    if you don’t strip the binary from the debugging symbols.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch02.html#idm45606842772304-marker)) Standard library means packages
    that are shipped together with the Go language tooling and runtime code. Usually,
    only mature and core functionalities are provided, as Go has strong compatibility
    guarantees. Go also maintains an experimental [`golang.org/x/exp`](https://oreil.ly/KBTwn)
    module that contains useful code that must be proven to graduate to the standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch02.html#idm45606842681408-marker)) While Go is improving every day,
    sometimes you can add more advanced tools like [`goimports`](https://oreil.ly/pS9MI)
    or [`bingo`](https://oreil.ly/mkjO2) to improve the development experience further.
    In some areas, Go can’t be opinionated and is limited by stability guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch02.html#idm45606842674272-marker)) [The CAP Theorem](https://oreil.ly/HyBdB)
    mentions an excellent example of treating failures seriously. It states that you
    can only choose two from three system characteristics: consistency, availability,
    and partition. As soon as you distribute your system, you must deal with network
    partition (communication failure). As an error-handling mechanism, you can either
    design your system to wait (lose availability) or operate on partial data (lose
    consistency).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch02.html#idm45606842670048-marker)) [`bash` has many methods for error
    handling](https://oreil.ly/Tij9n), but the default one is implicit. The programmer
    can optionally print or check `${?}` that holds the exit code of the last command
    executed before any given line. An exit code of 0 means the command is executed
    without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch02.html#idm45606842664160-marker)) In principle, a monad is an object
    that holds some value optionally, for example, some object `Option<Type>` with
    methods `Get()` and `IsEmpty()`. Furthermore, an “error monad” is an `Option`
    object that holds an error if the value is not set (sometimes referred to as `Result<Type>`).
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch02.html#idm45606839042576-marker)) Such code is not recommended for
    production, but the only things that would need to change are avoiding using global
    variables and checking all errors.
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch02.html#idm45606838437664-marker)) This assertion pattern is also typical
    in other third-party libraries like the popular [`testify` package](https://oreil.ly/I47fD).
    However, I am not a fan of the `testify` package, because there are too many ways
    of doing the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch02.html#idm45606838184304-marker)) Since programs, e.g., in Java, compile
    to Java bytecode, many things happen before the code is translated to actual machine-understandable
    code. The complexity of this process is too great to be understood by a mere mortal,
    so [machine learning “AI” tools were created](https://oreil.ly/baNvh) to auto-tune
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch02.html#idm45606838174512-marker)) [A survey in 2020](https://oreil.ly/WrtCH)
    shows that among the top 10 used programming languages, 2 mandates object-oriented
    programming (Java, C#), 6 encourage it, and 2 do not implement OOP. I personally
    almost always favor object-oriented programming for algorithms that have to hold
    some context larger than three variables between data structures or functions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch02.html#idm45606837116448-marker)) I prefer [functions to methods](https://oreil.ly/Et9CE),
    as they’re easier to use in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch02.html#idm45606836849296-marker)) The summary was well explained on
    the [*PlanetScale* blog post](https://oreil.ly/ksqO0).
  prefs: []
  type: TYPE_NORMAL
- en: ^([21](ch02.html#idm45606836733504-marker)) To name a few public changes, we’ve
    seen the [Salesforce case](https://oreil.ly/H3WsC), [AppsFlyer](https://oreil.ly/iazde),
    and [Stream](https://oreil.ly/NSJLD).
  prefs: []
  type: TYPE_NORMAL
- en: ^([22](ch02.html#idm45606836729648-marker)) For example, when we look at some
    [benchmarks](https://oreil.ly/s7qTj), we see Go as sometimes faster, sometimes
    slower than Java. Yet if we look at CPU loads, every time Go or Java is faster,
    it’s simply faster because, for example, the implementation allowed fewer CPU
    cycles to be wasted on memory access. You can achieve that in any programming
    language. The question is, how hard was it to achieve this? We don’t usually measure
    how much time we spend to optimize code in each particular language, how easy
    it is to read or extend such code after optimizations, etc. Only those metrics
    might tell us which programming language is “faster.”
  prefs: []
  type: TYPE_NORMAL
