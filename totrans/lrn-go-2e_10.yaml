- en: Chapter 10\. Modules, Packages, and Imports
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。模块、包和导入
- en: Most modern programming languages have a system for organizing code into namespaces
    and libraries, and Go is no exception. As you’ve seen while exploring other features,
    Go introduces some new approaches to this old idea. In this chapter, you’ll learn
    how to organize code with packages and modules, how to import them, how to work
    with third-party libraries, and how to create libraries of your own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言都有一个将代码组织成命名空间和库的系统，Go 也不例外。正如你在探索其他特性时所见，Go 引入了一些新的方法来实现这一古老的理念。在这一章中，你将学习如何使用包和模块组织代码，如何导入它们，如何使用第三方库，以及如何创建自己的库。
- en: Repositories, Modules, and Packages
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库、模块和包
- en: 'Library management in Go is based around three concepts: repositories, modules,
    and packages. A *repository* is familiar to all developers. It is a place in a
    version control system where the source code for a project is stored. A *module*
    is a bundle of Go source code that’s distributed and versioned as a single unit.
    Modules are stored in a repository. Modules consist of one or more *packages*,
    which are directories of source code. Packages give a module organization and
    structure.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的库管理基于三个概念：仓库、模块和包。*仓库* 对所有开发者来说都很熟悉。它是版本控制系统中存储项目源代码的地方。*模块* 是一组作为单个单元分发和版本化的
    Go 源代码。模块存储在仓库中。模块由一个或多个 *包* 组成，包是源代码的目录。包给模块提供了组织和结构。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While you can store more than one module in a repository, it is discouraged.
    Everything within a module is versioned together. Maintaining two modules in one
    repository requires you to track separate versions for two different modules in
    a single repository.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在一个仓库中存储多个模块，但并不鼓励这样做。每个模块内的所有内容都是一起进行版本管理的。在一个仓库中维护两个模块需要你在单个仓库中跟踪两个不同模块的版本。
- en: 'Unfortunately, different programming languages use these words to represent
    different concepts. While packages in Java and Go are similar, a Java repository
    is a centralized place to store multiple *artifacts* (the analogue of a Go module).
    Node.js and Go swap the meanings of the terms: a Node.js package is similar to
    what Go calls a module, and a Go package is similar to a Node.js module. The terminology
    certainly can be confusing at first, but as you get more comfortable with Go,
    the terms will seem more familiar.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不同的编程语言使用这些术语来表示不同的概念。虽然 Java 和 Go 中的包是相似的，但 Java 仓库是存储多个 *构件*（类似于 Go 模块的东西）的集中地点。Node.js
    和 Go 交换了这些术语的含义：Node.js 包类似于 Go 所称的模块，而 Go 包类似于 Node.js 模块。起初这些术语可能会令人困惑，但当你对
    Go 越来越熟悉时，这些术语会变得更加熟悉。
- en: Before using code from packages outside the standard library, you need to make
    sure that you have a properly created module. Every module has a globally unique
    identifier. This is not unique to Go. Java defines globally unique package declarations
    by using the reverse domain name convention (`com.*companyname*.*projectname*.library`).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用来自标准库之外的包的代码之前，你需要确保你有一个正确创建的模块。每个模块都有一个全局唯一的标识符。这不仅仅是 Go 的特性。Java 使用反向域名约定
    (`com.*companyname*.*projectname*.library`) 定义全局唯一的包声明。
- en: In Go, this name is called a *module path*. It is usually based on the repository
    where the module is stored. For example, you can find Proteus, a module I wrote
    to simplify relational database access in Go, at [*https://github.com/jonbodner/proteus*](https://github.com/jonbodner/proteus).
    It has a module path of *github.com/jonbodner/proteus*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，这个名字被称为 *模块路径*。通常基于存储模块的仓库。例如，你可以在 [*https://github.com/jonbodner/proteus*](https://github.com/jonbodner/proteus)
    找到 Proteus，这是我编写的一个简化 Go 中关系型数据库访问的模块。它的模块路径是 *github.com/jonbodner/proteus*。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Back in [“Your First Go Program”](ch01.html#first_program), you created a module
    whose name was `hello_world`, which is obviously not globally unique. This is
    fine if you are creating a module for local use only. If you put a module with
    a nonunique name into a source code repository, it cannot be imported by another
    module.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [“你的第一个 Go 程序”](ch01.html#first_program)，你创建了一个名为 `hello_world` 的模块，显然这不是全局唯一的。如果你只是为本地使用创建一个模块，那么这没问题。但是如果你将一个具有非唯一名称的模块放入源代码仓库中，那么其他模块将无法导入它。
- en: Using go.mod
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 go.mod
- en: A directory tree of Go source code becomes a module when there’s a valid *go.mod*
    file in it. Rather than create this file manually, use the subcommands of the
    `go mod` command to manage modules. The command `go mod init` *`MODULE_PATH`*
    creates the *go.mod* file that makes the current directory the root of a module.
    The *`MODULE_PATH`* is the globally unique name that identifies your module. The
    module path is case-sensitive. To reduce confusion, do not use uppercase letters
    within it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当目录树中的 Go 源代码包含有效的 *go.mod* 文件时，它变成一个模块。不要手动创建此文件，使用 `go mod` 命令的子命令来管理模块。命令
    `go mod init *MODULE_PATH*` 创建使当前目录成为模块根的 *go.mod* 文件。*MODULE_PATH* 是唯一标识您的模块的全局唯一名称。模块路径区分大小写。为避免混淆，不要在其中使用大写字母。
- en: 'Take a look at the contents of a *go.mod* file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *go.mod* 文件的内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every *go.mod* file starts with a `module` directive that consists of the word
    `module` and the module’s unique path. Next, the *go.mod* file specifies the minimum
    compatible version of Go with the `go` directive. All source code within the module
    must be compatible with the specified version. For example, if you specify the
    (rather old) version `1.12`, the compiler will not let you use underscores within
    numeric literals, because that feature was added in Go 1.13.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *go.mod* 文件都以一个 `module` 指令开始，包含 `module` 一词和模块的唯一路径。接下来，*go.mod* 文件使用 `go`
    指令指定 Go 的最低兼容版本。模块中的所有源代码必须与指定版本兼容。例如，如果指定了（相当旧的）版本 `1.12`，则编译器不允许在数字文字中使用下划线，因为该功能是在
    Go 1.13 中添加的。
- en: Use the go Directive to Manage Go Build Versions
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `go` 指令管理 Go 构建版本
- en: 'What happens if the `go` directive specifies a version of Go that’s newer than
    what’s installed? If you have Go 1.20 or earlier installed, the newer Go version
    is ignored and you get the features of the installed version. If you have Go 1.21
    or newer installed, the default behavior is to download the newer version of Go
    and use it to build your code. You can control this behavior in Go 1.21 and newer
    with the `toolchain` directive and the `GOTOOLCHAIN` environment variable. You
    can assign them the following values:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `go` 指令指定的 Go 版本比已安装的版本更新，会发生什么？如果安装的是 Go 1.20 或更早版本，则会忽略更新的 Go 版本，并使用已安装版本的功能。如果安装的是
    Go 1.21 或更新版本，则默认行为是下载更新的 Go 版本并用其构建您的代码。您可以在 Go 1.21 及更新版本中通过 `toolchain` 指令和
    `GOTOOLCHAIN` 环境变量来控制此行为。可以为它们分配以下值：
- en: '`auto`, which downloads newer versions of Go. (This is the default behavior
    of Go 1.21 and later.)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`，会下载更新的 Go 版本。（这是 Go 1.21 及更高版本的默认行为。）'
- en: '`local`, which restores the behavior of Go releases before 1.21.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`，恢复 Go 1.21 之前发布的行为。'
- en: A specific Go version (such as `go1.20.4`), which means that specific version
    will be downloaded and used to build the program.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的 Go 版本（例如 `go1.20.4`），这意味着将下载并使用特定的版本来构建程序。
- en: For example, the command line `GOTOOLCHAIN=go1.18 go build` will build your
    Go program with Go 1.18, downloading it if necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令行 `GOTOOLCHAIN=go1.18 go build` 将使用 Go 1.18 构建您的 Go 程序，必要时进行下载。
- en: If both the `GOTOOLCHAIN` environment variable and the `toolchain` directive
    are set, the value assigned to `GOTOOLCHAIN` is used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时设置了 `GOTOOLCHAIN` 环境变量和 `toolchain` 指令，则使用分配给 `GOTOOLCHAIN` 的值。
- en: Complete details on the `go` directive, the `toolchain` directive, and the `GOTOOLCHAIN`
    environment variable are found in the [official Go toolchain documentation](https://oreil.ly/hv3Mg).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `go` 指令、`toolchain` 指令和 `GOTOOLCHAIN` 环境变量的详细信息，请参阅[官方 Go 工具链文档](https://oreil.ly/hv3Mg)。
- en: As discussed in [“The for-range value is a copy”](ch04.html#for_range_copy),
    Go 1.22 introduces the first backward-breaking change to the language. When using
    Go 1.22 or later, if the `go` directive is set to `1.22` or higher, a `for` loop
    creates a new index and value variable on each iteration. This behavior is applied
    per module. The value of the `go` directive in each imported module determines
    the language level for that module. ([“Importing Third-Party Code”](#import_third_party)
    describes how to use and manage multiple modules in your programs.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如[《for-range 值是一个副本》](ch04.html#for_range_copy)中所讨论的，Go 1.22 引入了语言的首个向后不兼容的更改。当使用
    Go 1.22 或更高版本时，如果 `go` 指令设置为 `1.22` 或更高，则 `for` 循环在每次迭代时创建新的索引和值变量。此行为适用于每个模块。每个导入模块中
    `go` 指令的值确定该模块的语言级别。([《导入第三方代码》](#import_third_party)介绍了如何在程序中使用和管理多个模块。)
- en: You can see this difference with a short example. You can find the code in the
    *sample_code/loop_test* directory in the [Chapter 10 repository](https://oreil.ly/eCRCH).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过一个简短的示例看到这种差异。您可以在 [第 10 章存储库](https://oreil.ly/eCRCH) 中的 *sample_code/loop_test*
    目录中找到代码。
- en: 'The code in *loop.go* is simple:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*loop.go* 文件中的代码很简单：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you haven’t seen it before, the `%p` verb in the `fmt` formatting language
    returns the memory location of a pointer. The repository has the `go` directive
    in its *go.mod* file set to `1.21`. Building and running the program gives the
    following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有见过，在 `fmt` 格式化语言中 `%p` 动词返回指针的内存位置。存储库的 *go.mod* 文件中的 `go` 指令设置为 `1.21`。构建和运行程序将产生以下输出：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When built using older versions of Go, the program prints out the same memory
    address five times. (The memory addresses might differ from what’s shown here,
    but all will be the same value.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用较早版本的 Go 构建时，程序会五次打印相同的内存地址。（这里显示的内存地址可能会有所不同，但所有地址都是相同的值。）
- en: 'Change the value of the `go` directive in *go.mod* to `1.22` and rebuild and
    rerun the program. You will now get this output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *go.mod* 中的 `go` 指令值更改为 `1.22`，然后重新构建和运行程序。您现在将得到如下输出：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that every memory address value is different, indicating that a new variable
    was created on each iteration. (The memory addresses might differ from what’s
    shown here, but each one will be a different value.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个内存地址值都不同，表明在每次迭代中创建了一个新变量。（这里显示的内存地址可能会有所不同，但每个地址都是不同的值。）
- en: The require Directive
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: require 指令
- en: The next sections in a *go.mod* file are the `require` directives. The `require`
    directives are present only if your module has dependencies. They list the modules
    that your module depends on and the minimum version required for each one. The
    first `require` section lists the direct dependencies of your module. The second
    one lists the dependencies of the dependencies of your module. Each line in this
    section ends with an `// indirect` comment. There’s no functional difference between
    modules marked as indirect and those that aren’t; it’s just documentation for
    people when they look at the *go.mod* file. Direct dependencies are marked as
    indirect in one situation, and I will discuss it when I talk about the ways to
    use `go get`. In [“Importing Third-Party Code”](#import_third_party), you’ll learn
    more about adding and managing the dependencies of your module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.mod* 文件中的下一节是 `require` 指令。`require` 指令仅在您的模块具有依赖项时才存在。它们列出了您的模块依赖的模块及其所需的最低版本。第一个
    `require` 部分列出了您的模块的直接依赖项。第二个部分列出了您模块依赖的依赖项。此部分中的每行都以 `// indirect` 注释结尾。标记为间接依赖项和未标记的模块之间没有功能上的区别；这只是在查看
    *go.mod* 文件时为人们提供的文档。在使用 `go get` 的方式时，有一种情况下会标记直接依赖项为间接依赖项，我将在讨论 `go get` 的方式时进行说明。在
    [“导入第三方代码”](#import_third_party) 中，您将学习如何添加和管理模块的依赖项。'
- en: While the `module`, `go`, and `require` directives are the ones most commonly
    used in a *go.mod* file, there are three others directives as well. I will cover
    the `replace` and `exclude` directives in [“Overriding Dependencies”](#replace_exclude),
    and I’ll cover the `retract` directive in [“Retracting a Version of Your Module”](#retract_module).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `module`、`go` 和 `require` 指令是 *go.mod* 文件中最常用的指令，但还有其他三个指令。我将在 [“覆盖依赖项”](#replace_exclude)
    中介绍 `replace` 和 `exclude` 指令，并在 [“撤回模块的版本”](#retract_module) 中介绍 `retract` 指令。
- en: Building Packages
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建包
- en: Now that you’ve learned how to make your directory of code into a module, it’s
    time to start using packages to organize your code. You’ll start by seeing how
    `import` works, move on to creating and organizing packages, and then look at
    some of the features of Go’s packages, both good and bad.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会将您的代码目录变成一个模块，是时候开始使用包来组织您的代码了。您将从了解 `import` 的工作原理开始，然后转向创建和组织包，然后再看看
    Go 包的一些特性，包括好的和坏的。
- en: Importing and Exporting
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入和导出
- en: The example programs have been using the `import` statement in Go even though
    I haven’t discussed what it does and how importing in Go differs from other languages.
    Go’s `import` statement allows you to access exported constants, variables, functions,
    and types in another package. A package’s exported identifiers (an *identifier*
    is the name of a variable, constant, type, function, method, or a field in a struct)
    cannot be accessed from another current package without an `import` statement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我还没有讨论它的功能及其在 Go 中与其他语言的不同之处，示例程序一直在使用 `import` 语句。Go 的 `import` 语句允许您访问另一个包中导出的常量、变量、函数和类型。包的导出标识符（标识符是变量、常量、类型、函数、方法或结构体中的字段的名称）在没有
    `import` 语句的情况下无法从当前包的另一个包中访问。
- en: This leads to the question, how do you export an identifier in Go? Rather than
    use a special keyword, Go uses *capitalization* to determine whether a package-level
    identifier is visible outside the package where it is declared. An identifier
    whose name starts with an uppercase letter is *exported*. Conversely, an identifier
    whose name starts with a lowercase letter or underscore can be accessed only from
    within the package where it is declared. (Identifiers in Go can’t start with a
    digit but can contain them.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题，如何在 Go 中导出标识符？Go 使用 *大写字母* 来确定包级别标识符是否对外部可见，而不是使用特殊的关键字。以大写字母开头的标识符被称为
    *导出的* 标识符。相反，以小写字母或下划线开头的标识符只能从声明它的包内部访问。在 Go 中，标识符不能以数字开头，但可以包含数字。
- en: Anything you export is part of your package’s API. Before you export an identifier,
    be sure that you intend to expose it to clients. Document all exported identifiers
    and keep them backward compatible unless you are intentionally making a major
    version change (see [“Versioning Your Module”](#versioning) for more information).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何您导出的内容都是包的 API 的一部分。在导出标识符之前，请确保您打算将其暴露给客户端。记录所有导出的标识符，并保持向后兼容，除非您有意进行主要版本更改（有关更多信息，请参阅[“模块版本化”](#versioning)）。
- en: Creating and Accessing a Package
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和访问包
- en: 'Making packages in Go is easy. Let’s look at a small program to demonstrate
    this. You can find it in the [*package_example* directory for this book](https://oreil.ly/E1st2).
    Inside *package_example*, you’ll see two additional directories, *math* and *do-format*.
    In *math*, there’s a file called *math.go* with the following contents:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建包很容易。让我们看一个小程序来演示这一点。您可以在[*package_example* 本书目录](https://oreil.ly/E1st2)中找到它。在
    *package_example* 中，您会看到两个额外的目录，*math* 和 *do-format*。在 *math* 中，有一个名为 *math.go*
    的文件，内容如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line of the file is called the *package clause*. It consists of the
    keyword `package` and the name for the package. The package clause is always the
    first nonblank, noncomment line in a Go source file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行称为 *包声明*。它由关键字 `package` 和包的名称组成。包声明始终是 Go 源文件中的第一行，且不能为空且非注释。
- en: 'In the *do-format* directory is a file called *formatter.go* with the following
    contents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *do-format* 目录中有一个名为 *formatter.go* 的文件，内容如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the package name is `format` in the package clause, but it’s in the
    *do-format* directory. How to interact with this package will be covered very
    shortly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，包声明中的包名是 `format`，但它位于 *do-format* 目录中。很快将介绍如何与此包交互。
- en: 'Finally, the following contents are in the file *main.go* in the root directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在根目录中的文件 *main.go* 中包含以下内容：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first line of this file is familiar. All the programs before this chapter
    have put `package main` as the first line in the code. I’ll talk more about what
    this means in a bit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件的第一行很熟悉。在本章之前的所有程序中，代码的第一行都是`package main`。稍后我会详细讨论这意味着什么。
- en: Next is the import section. It imports three packages. The first is `fmt`, which
    is in the standard library. You’ve done this in previous chapters. The next two
    imports refer to the packages within the program. You must specify an *import
    path* when importing from anywhere besides the standard library. The import path
    consists of the module path followed by the path to the package within the module.
    For example, the import `"github.com/learning-go-book-2e/package_example/math"`
    has the module path `github.com/learning-go-book-2e/package_example`, while `/math`
    is the path to the package within the module.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是导入部分。它导入了三个包。第一个是标准库中的 `fmt` 包。您在之前的章节中已经做过这个操作。接下来的两个导入引用程序内部的包。除了标准库之外，当从任何地方导入时，您必须指定
    *导入路径*。导入路径由模块路径和模块内包路径组成。例如，导入 `"github.com/learning-go-book-2e/package_example/math"`
    其中模块路径为 `github.com/learning-go-book-2e/package_example`，而 `/math` 是模块内包路径。
- en: It is a compile-time error to import a package but not use any of the identifiers
    exported by the package. This ensures that the binary produced by the Go compiler
    includes only code that’s actually used in the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包但未使用包导出的任何标识符是编译时错误。这确保了由Go编译器生成的二进制文件仅包含程序中实际使用的代码。
- en: Warning
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You might come across obsolete documentation on the web that mentions relative
    path import paths. They do not work with modules. (And were a bad idea, anyway.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在网络上遇到关于相对路径导入路径的过时文档。它们不适用于模块。（而且本来就不是一个好主意。）
- en: 'When you run this program, you’ll see the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序时，您将看到以下输出：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `main` function called the `Double` function in the `math` package by prefixing
    the function name with the package name. You’ve seen this in previous chapters
    when calling functions in the standard library. You also call the `Number` function
    in the `format` package. You might wonder where this `format` package came from,
    since the import says `github.com/learning-go-book-2e/package_example/do-format`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数通过在函数名前加上包名调用了 `math` 包中的 `Double` 函数。在之前的章节中调用标准库中的函数时，您也调用了 `format`
    包中的 `Number` 函数。您可能会想知道这个 `format` 包是从哪里来的，因为导入中写的是 `github.com/learning-go-book-2e/package_example/do-format`。'
- en: Every Go file in a directory must have an identical package clause. (You’ll
    see one tiny exception to this rule in [“Testing Your Public API”](ch15.html#public_api_test).)
    You imported the `format` package with the import path *github.com/learning-go-book-2e/package_example/do-format*.
    That’s because *the name of a package is determined by its package clause, not
    its import path*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的每个Go文件必须具有相同的包子句。（在[“测试您的公共API”](ch15.html#public_api_test)中，您会看到一个微小的例外。）您使用
    *github.com/learning-go-book-2e/package_example/do-format* 导入了 `format` 包。这是因为
    *包的名称由其包子句确定，而不是其导入路径*。
- en: As a general rule, you should make the name of the package match the name of
    the directory that contains the package. It is hard to discover a package’s name
    if it does not match the containing directory. However, in a few situations you’ll
    use a different name for the package than for the directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，应使包名与包含包的目录名相匹配。如果包名与包含它的目录名不匹配，则很难发现包的名称。但在少数情况下，您将为包使用与目录不同的名称。
- en: The first is something you have been doing all along without realizing it. You
    declare a package to be a starting point for a Go application by using the special
    package name `main`. Since you cannot import the `main` package, this doesn’t
    produce confusing import statements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是您一直在做的事情，但没有意识到。通过使用特殊包名 `main`，您声明了一个Go应用程序的起始点。由于无法导入 `main` 包，这不会产生混淆的导入语句。
- en: The other reasons for having a package name not match your directory name are
    less common. If your directory name contains a character that’s not valid in a
    Go identifier, then you must choose a package name that’s different from your
    directory name. In your case, `do-format` is not a valid identifier name, so it’s
    replaced with `format`. It’s better to avoid this by never creating a directory
    with a name that’s not a valid identifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 包名与目录名不匹配的其他原因较少见。如果您的目录名包含Go标识符中不合法的字符，则必须选择与目录名不同的包名。在您的情况下，`do-format` 不是有效的标识符名称，因此它被替换为
    `format`。最好通过永远不创建名称不是有效标识符的目录来避免这种情况。
- en: The final reason for creating a directory whose name doesn’t match the package
    name is to support versioning using directories. I’ll talk about this more in
    [“Versioning Your Module”](#versioning).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名称与包名不匹配的目录的最终原因是使用目录支持版本控制。我将在[“版本化您的模块”](#versioning)中更详细地讨论这一点。
- en: As was discussed in [“Blocks”](ch04.html#blocks), package names in `import`
    statements are in the *file block*. If you use exported symbols from one package
    in two different files in another package, you must import the first package in
    both files in the second package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[“块”](ch04.html#blocks)中讨论的那样，`import`语句中的包名位于*文件块*中。如果您在另一个包的两个不同文件中使用一个包中的导出符号，则必须在第二个包的两个文件中都导入第一个包。
- en: Naming Packages
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包命名
- en: 'Package names should be descriptive. Rather than have a package called `util`,
    create a package name that describes the functionality provided by the package.
    For example, say you have two helper functions: one to extract all names from
    a string and another to format names properly. Don’t create two functions in a
    `util` package called `ExtractNames` and `FormatNames`. If you do, every time
    you use these functions, they will be referred to as `util.ExtractNames` and `util.FormatNames`,
    and that `util` package tells you nothing about what the functions do.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 包名应具有描述性。而不是称为`util`的包，应创建一个描述包功能的包名。例如，假设您有两个辅助函数：一个从字符串中提取所有名称，另一个正确格式化名称。不要在名为`util`的包中创建名为`ExtractNames`和`FormatNames`的两个函数。如果这样做，每次使用这些函数时，它们将被称为`util.ExtractNames`和`util.FormatNames`，而`util`包并未告诉您这些函数的实际功能。
- en: One option is to create one function called `Names` in a package called `extract`
    and a second function called `Names` in a package called `format`. It’s OK for
    these two functions to have the same name, because they will always be disambiguated
    by their package names. The first will be referred to as `extract.Names` when
    imported, and the second will be referred to as `format.Names`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是在称为`extract`的包中创建一个名为`Names`的函数，以及在称为`format`的包中创建一个名为`Names`的第二个函数。这两个函数具有相同的名称是可以接受的，因为它们始终会通过其包名称加以区分。第一个将在导入时被称为`extract.Names`，第二个将被称为`format.Names`。
- en: An even better option is to think about parts of speech. A function or method
    does something, so it should be a verb or action word. A package would be a noun,
    a name for the kind of item that is created or modified by the functions in the
    package. By following these rules, you would create a package called `names` with
    two functions, `Extract` and `Format`. The first would then be referred to as
    `names.Extract` and the second would be `names.Format`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是考虑语法成分。函数或方法执行某些操作，因此它应该是一个动词或动作词。包将是一个名词，用来描述由包中的函数创建或修改的项目类型。遵循这些规则，您将创建一个名为`names`的包，其中包含两个函数，`Extract`和`Format`。第一个将被称为`names.Extract`，第二个将被称为`names.Format`。
- en: You should also avoid repeating the name of the package in the names of functions
    and types within the package. Don’t name your function `ExtractNames` when it
    is in the `names` package. The exception to this rule occurs when the name of
    the identifier is the same as the name of the package. For example, the package
    `sort` in the standard library has a function called `Sort`, and the `context`
    package defines the `Context` interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应避免在包内函数和类型的名称中重复包的名称。当标识符的名称与包的名称相同时，此规则的例外情况会发生。例如，标准库中的`sort`包具有名为`Sort`的函数，而`context`包定义了`Context`接口。
- en: Overriding a Package’s Name
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖包的名称
- en: 'Sometimes you’ll find yourself importing two packages whose names collide.
    For example, the standard library includes two packages for generating random
    numbers; one is cryptographically secure (`crypto/rand`), and the other is not
    (`math/rand`). The regular generator is fine when you aren’t generating random
    numbers for encryption, but you need to seed it with an unpredictable value. A
    common pattern is to seed a regular random number generator with a value from
    a cryptographic generator. In Go, both packages have the same name (`rand`). When
    that happens, you provide an alternate name for one package within the current
    file. Try out this code on [The Go Playground](https://oreil.ly/YVwkm) or in the
    *sample_code/package_name_override* directory in the [Chapter 10 repository](https://oreil.ly/eCRCH).
    First, look at the import section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会发现自己导入了两个包名冲突的包。例如，标准库包括两个生成随机数的包；一个是加密安全的（`crypto/rand`），另一个则不是（`math/rand`）。在不需要为加密生成随机数时，可以使用常规生成器，但需要用不可预测的值对其进行种子化。常见模式是使用加密生成器的值来初始化常规随机数生成器。在
    Go 中，这两个包都有相同的名称（`rand`）。当发生这种情况时，在当前文件中为其中一个包提供替代名称。在[Go Playground](https://oreil.ly/YVwkm)或[第10章库中的*sample_code/package_name_override*目录](https://oreil.ly/eCRCH)中尝试这段代码。首先，查看导入部分：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You import `crypto/rand` with the name `crand`. This overrides the name `rand`
    that’s declared within the package. You then import `math/rand` normally. When
    you look at the `seedRand` function, you see that you access identifiers in `math/rand`
    with the `rand` prefix, and use the `crand` prefix with the `crypto/rand` package:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你用名称`crand`导入了`crypto/rand`。这样会覆盖包内声明的`rand`名称。然后你正常地导入了`math/rand`。当你查看`seedRand`函数时，你会看到你使用`rand`前缀访问`math/rand`中的标识符，并使用`crand`前缀访问`crypto/rand`包中的标识符：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can use two other symbols as a package name. The package name `.` (dot)
    places all the exported identifiers in the imported package into the current package’s
    namespace; you don’t need a prefix to refer to them. This is discouraged because
    it makes your source code less clear. You can no longer tell whether something
    is defined in the current package or whether it was imported by simply looking
    at its name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用另外两个符号作为包名。包名`.`（点）将所有导出的标识符放入当前包的命名空间中；你不需要前缀来引用它们。这是不鼓励的，因为它会使你的源代码不够清晰。你不能仅仅通过看它的名称就知道某些东西是在当前包中定义的还是被导入的。
- en: You can also use `_` (underscore) as the package name. You’ll explore what this
    does when I talk about `init` in [“Avoiding the init Function if Possible”](#pkg_init).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`_`（下划线）作为包名。当我讨论[“尽量避免使用 init 函数”](#pkg_init)时，你将了解它的作用。
- en: As I discussed in [“Shadowing Variables”](ch04.html#shadowing), package names
    can be shadowed. Declaring variables, types, or functions with the same name as
    a package makes the package inaccessible within the block with that declaration.
    If this is unavoidable (for example, a newly imported package has a name that
    conflicts with an existing identifier), override the package’s name to resolve
    the conflict.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“变量遮蔽”](ch04.html#shadowing)中讨论的那样，包名可以被遮蔽。声明与包相同名称的变量、类型或函数会使得该包在声明的区块内无法访问。如果这是不可避免的（例如，新导入的包与现有标识符冲突），请修改包名以解决冲突。
- en: Documenting Your Code with Go Doc Comments
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go Doc 注释文档化您的代码
- en: 'An important part of creating a module for others to use is documenting it
    properly. Go has its own format for writing comments that are automatically converted
    into documentation. It’s called *Go Doc* format, and it’s very simple. Here are
    the rules:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建供他人使用的模块的一个重要部分是正确地进行文档化。Go 有自己的写入注释的格式，这些注释会自动转换为文档。它称为*Go Doc*格式，非常简单。以下是规则：
- en: Place the comment directly before the item being documented, with no blank lines
    between the comment and the declaration of the item.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将注释直接放在要文档化的项之前，注释与项的声明之间不要留空行。
- en: Start each line of the comment with double slashes (//), followed by a space.
    While it’s legal to use /* and */ to mark your comment block, it is idiomatic
    to use double slashes.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每行注释以双斜杠（//）开始，后跟一个空格。虽然使用/*和*/标记注释块是合法的，但习惯上使用双斜杠更为惯用。
- en: The first word in the comment for a symbol (a function, type, constant, variable,
    or method) should be the name of the symbol. You can also use “A” or “An” before
    the symbol name to help make the comment text grammatically correct.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于符号的注释（函数、类型、常量、变量或方法），注释中的第一个词应该是符号的名称。您也可以在符号名称前使用“A”或“An”来帮助使注释文本在语法上正确。
- en: Use a blank comment line (double slashes and a newline) to break your comment
    into multiple paragraphs.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空白注释行（双斜杠和一个换行符）将您的注释分成多个段落。
- en: 'As I’ll talk about in [“Using pkg.go.dev”](#pkg_go_dev), you can view public
    documentation online in HTML format. If you want to make your documents look a
    little snazzier, there are a couple of ways to format it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我将在[“使用`pkg.go.dev`”](#pkg_go_dev)中讨论的那样，您可以在线查看以 HTML 格式发布的公共文档。如果您想让您的文档看起来更加漂亮，有几种格式化方式：
- en: If you want your comment to contain some preformatted content (such as a table
    or source code), put an additional space after the double slashes to indent the
    lines with the content.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望您的注释包含一些预格式化的内容（如表格或源代码），请在双斜杠后面加一个额外的空格，以使内容的行缩进。
- en: If you want a header in your comment, put a `#` and a space after the double
    slashes. Unlike with Markdown, you cannot use multiple `#` characters to make
    different levels of headers.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在注释中添加标题，请在双斜杠后面放置 `#` 和一个空格。与 Markdown 不同，您不能使用多个 `#` 字符来创建不同级别的标题。
- en: To make a link to another package (whether or not it is in the current module),
    put the package path within brackets (`[` and `]`).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建指向另一个包的链接（无论该包是否在当前模块中），请将包路径放在方括号内（`[` 和 `]`）。
- en: To link to an exported symbol, place its name in brackets. If the symbol is
    in another package, use `[pkgName.SymbolName]`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要链接到导出的符号，请将其名称放在方括号中。如果该符号在另一个包中，请使用`[pkgName.SymbolName]`。
- en: If you include a raw URL in your comment, it will be converted into a link.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在注释中包含原始 URL，它将被转换为链接。
- en: 'If you want to include text that links to a web page, put the text within brackets
    (`[` and `]`). At the end of the comment block, declare the mappings between your
    text and their URLs with the format `// [*TEXT*]: *URL*`. You’ll see a sample
    of this in a moment.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果您想要包含指向网页的文本，请将文本放在方括号内（`[` 和 `]`）。在注释块的末尾，使用格式 `// [*TEXT*]: *URL*` 声明您的文本与其
    URL 之间的映射。您将很快看到一个示例。'
- en: Comments before the package declaration create package-level comments. If you
    have lengthy comments for the package (such as the extensive formatting documentation
    in the `fmt` package), the convention is to put the comments in a file in your
    package called *doc.go*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在包声明之前的注释创建包级别的注释。如果您对包有详尽的注释（例如`fmt`包中的广泛格式化文档），惯例是将注释放在名为 *doc.go* 的文件中。
- en: Let’s go through a well-commented file, starting with the package-level comment
    in [Example 10-1](#EX91).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一个有详细注释的文件，从[示例 10-1](#EX91)中的包级别注释开始。
- en: Example 10-1\. A package-level comment
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. 一个包级别的注释
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, place a comment on an exported struct (see [Example 10-2](#EX92)). Notice
    that it starts with the name of the struct.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个导出的结构体上放置一个注释（参见[示例 10-2](#EX92)）。注意它以结构体的名称开头。
- en: Example 10-2\. A struct comment
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-2\. 一个结构体的注释
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, there is a comment on a function (see [Example 10-3](#EX93)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个函数的注释（参见[示例 10-3](#EX93)）。
- en: Example 10-3\. A well-commented function
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 一个有详细注释的函数
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Go includes a command-line tool called `go doc` that displays godocs. The command
    `go doc` *`PACKAGE_NAME`* displays the documentation for the specified package
    and a list of the identifiers in the package. Use `go doc` *`PACKAGE_NAME.IDENTIFIER_NAME`*
    to display the documentation for a specific identifier in the package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包含一个名为`go doc`的命令行工具，用于显示 godoc 文档。命令`go doc` *`PACKAGE_NAME`* 会显示指定包的文档以及包中标识符的列表。使用`go
    doc` *`PACKAGE_NAME.IDENTIFIER_NAME`* 可以显示包中特定标识符的文档。
- en: 'If you want to preview your documentation’s HTML formatting before it is published
    on the web, use `pkgsite`. This is the same program that powers `pkg.go.dev` (which
    I will talk about later in the chapter). To install `pkgsite`, use this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在文档发布到 Web 之前预览其 HTML 格式化，请使用`pkgsite`。这是与`pkg.go.dev`相同的程序（稍后在本章中将详细讨论）。要安装`pkgsite`，请使用以下命令：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (I will talk more about `go install` in [“Adding Third-Party Tools with go install”](ch11.html#go_install)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: （我将在[“使用`go install`添加第三方工具”](ch11.html#go_install)中详细讨论`go install`。）
- en: 'To view your source code’s comments rendered as HTML, go to the root of your
    module and run this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看源代码的注释以 HTML 格式呈现，请转到您模块的根目录并运行以下命令：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then go to [*http://localhost:8080*](http://localhost:8080) to view your project
    and its source code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后去[*http://localhost:8080*](http://localhost:8080)查看您的项目及其源代码。
- en: You can find even more details about comments and potential pitfalls by reading
    through the official [Go Doc Comments documentation](https://oreil.ly/cakQm).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读官方的[Go Doc Comments文档](https://oreil.ly/cakQm)找到有关注释和潜在陷阱的更多详细信息。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you comment your code properly. At the very least, any exported identifier
    should have a comment. In [“Using Code-Quality Scanners”](ch11.html#code_quality),
    you will look at some third-party tools that can report missing comments on exported
    identifiers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 确保适当地注释您的代码。至少，任何导出的标识符都应该有注释。在[“使用代码质量扫描工具”](ch11.html#code_quality)中，您将看到一些第三方工具，它们可以报告导出标识符缺失的注释。
- en: Using the internal Package
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`internal`包
- en: Sometimes you want to share a function, type, or constant among packages in
    your module, but you don’t want to make it part of your API. Go supports this
    via the special `internal` package name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您想要在模块中的多个包之间共享函数、类型或常量，但又不希望将其作为API的一部分。Go通过特殊的`internal`包名来支持这一点。
- en: When you create a package called `internal`, the exported identifiers in that
    package and its subpackages are accessible only to the direct parent package of
    `internal` and the sibling packages of `internal`. Let’s look at an example to
    see how this works. You can find the code on [GitHub](https://oreil.ly/pJokh).
    The directory tree is shown in [Figure 10-1](#the_file_tree_for_internal_package_example).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个名为`internal`的包时，该包及其子包中的导出标识符仅对`internal`的直接父包和`internal`的同级包可访问。让我们通过一个示例来看看它是如何工作的。您可以在[GitHub](https://oreil.ly/pJokh)上找到该代码。目录树如[图 10-1](#the_file_tree_for_internal_package_example)所示。
- en: 'You’ve declared a simple function in the *internal.go* file in the `internal`
    package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您在`internal`包的*internal.go*文件中声明了一个简单的函数：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can access this function from *foo.go* in the `foo` package and from *sibling.go*
    in the `sibling` package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`foo`包中的*foo.go*和`sibling`包中的*sibling.go*访问此函数。
- en: '![A file tree to show where an internal package can be used](assets/lgo2_1001.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![显示内部包可以使用的文件树](assets/lgo2_1001.png)'
- en: Figure 10-1\. The file tree for `internal_package_example`
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1. `internal_package_example`的文件树
- en: 'Be aware that attempting to use the internal function from *bar.go* in the
    `bar` package or from *example.go* in the root package results in a compilation
    error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，试图从`bar`包的*bar.go*或根包的*example.go*中使用内部函数会导致编译错误：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Avoiding Circular Dependencies
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免循环依赖
- en: Two of the goals of Go are a fast compiler and easy-to-understand source code.
    To support this, Go does not allow you to have a *circular dependency* between
    packages. If package A imports package B, directly or indirectly, package B cannot
    import package A, directly or indirectly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的两个目标是快速编译器和易于理解的源代码。为支持这一点，Go不允许包之间存在*循环依赖*。如果包A直接或间接导入包B，那么包B就不能直接或间接导入包A。
- en: 'Let’s look at a quick example to explain the concept. You can find the code
    in the *sample_code/circular_dependency_example* directory in the [Chapter 10
    repository](https://oreil.ly/eCRCH). There are two packages, `pet` and `person`.
    In *pet.go* in the `pet` package, you have this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速示例来解释这个概念。您可以在[第10章存储库](https://oreil.ly/eCRCH)的*sample_code/circular_dependency_example*目录中找到代码。有两个包，`pet`和`person`。在`pet`包的*pet.go*中，您有以下内容：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While in *person.go* in the `person` package, you have this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而在`person`包的*person.go*中，您有以下内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you try to build this program, you’ll get an error:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试构建此程序，将会收到一个错误：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you find yourself with a circular dependency, you have a few options. In
    some cases, this is caused by splitting up packages too finely. If two packages
    depend on each other, there’s a good chance they should be merged into a single
    package. You can merge the `person` and `pet` packages into a single package,
    and that solves your problem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己处于循环依赖中，您有几个选择。在某些情况下，这是由于将包分割得过细造成的。如果两个包彼此依赖，它们应该合并为一个单独的包的可能性很高。您可以将`person`和`pet`包合并为一个包，问题就解决了。
- en: If you have a good reason to keep your packages separated, it may be possible
    to move just the items that cause the circular dependency to one of the two packages
    or to a new package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有充分的理由保持包的分离，可能可以将导致循环依赖的项仅移动到两个包中的一个或者移动到一个新包中。
- en: Organizing Your Module
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织您的模块
- en: There’s no official way to structure the Go packages in your module, but several
    patterns have emerged over the years. They are guided by the principle that you
    should focus on making your code easy to understand and maintain.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 没有官方的方式来组织Go模块中的包，但是多年来出现了几种模式。它们的指导原则是你应该专注于使你的代码易于理解和维护。
- en: When your module is small, keep all your code in a single package. As long as
    no other modules depend on your module, there is no harm in delaying organization.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的模块很小的时候，将所有代码放在一个包中。只要没有其他模块依赖于你的模块，延迟组织是没有害处的。
- en: 'As your module grows, you’ll want to impose some order to make your code more
    readable. The first question to ask is what type of module you are creating. You
    can group modules into two broad categories: those that are intended as a single
    application and those that are primarily intended as libraries. If you are sure
    that your module is intended to be used only as an application, make the root
    of the project the `main` package. The code in the `main` package should be minimal;
    place all your logic in an *internal* directory, and the code in the `main` function
    will simply invoke code within *internal*. This way, you can ensure that no one
    is going to create a module that depends on your application’s implementation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的模块逐渐增大时，你会希望进行一些整理，以使你的代码更易读。首先要问的问题是你正在创建什么类型的模块。你可以将模块分为两大类：那些用作单个应用程序的模块和主要用作库的模块。如果你确定你的模块只用作应用程序，那么将项目的根目录命名为`main`包。`main`包中的代码应该尽量精简；将所有逻辑放在一个*internal*目录中，而`main`函数中的代码仅需调用*internal*中的代码。这样，你可以确保没有人会创建依赖于你应用程序实现的模块。
- en: If you want your module to be used as a library, the root of your module should
    have a package name that matches the repository name. This makes sure that the
    import name matches the package name. To make this work, you must ensure that
    your repository name is a valid Go identifier. In particular, you cannot use a
    hyphen as a word separator in your repository name, because a hyphen is not a
    valid character in a package name.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的模块作为库被使用，那么你的模块根目录应该有一个与存储库名称匹配的包名。这确保了导入名称与包名匹配。为使其工作，你必须确保你的存储库名称是有效的Go标识符。特别地，你不能在存储库名称中使用连字符作为单词分隔符，因为连字符在包名中不是有效的字符。
- en: It’s not uncommon for library modules to have one or more applications included
    with them as utilities. In this case, create a directory called *cmd* at the root
    of your module. Within *cmd*, create one directory for each binary built from
    your module. For example, you might have a module that contains both a web application
    and a command-line tool that analyzes data in the web application’s database.
    Use `main` as the package name within each of these directories.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于库模块而言，包含一个或多个与其一起作为实用工具的应用程序是很常见的。在这种情况下，在你的模块根目录下创建一个名为*cmd*的目录。在*cmd*中，为从你的模块构建的每个二进制文件创建一个目录。例如，你可能有一个模块，其中既包含一个Web应用程序，又包含一个分析Web应用程序数据库中数据的命令行工具。在这些目录中，使用`main`作为包名。
- en: For more detailed information, this [blog post by Eli Bendersky](https://oreil.ly/faMHH)
    provides good advice on how you should structure a simple Go module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的信息，请参考Eli Bendersky的[这篇博文](https://oreil.ly/faMHH)，它提供了关于如何组织一个简单Go模块的良好建议。
- en: As projects get more complicated, you’ll be tempted to break up your packages.
    Make sure to organize your code to limit the dependencies among packages. One
    common pattern is to organize your code by slices of functionality. For example,
    if you wrote a shopping site in Go, you might place all the code for customer
    management in one package and all the code for inventory management in another.
    This style limits the dependencies among packages, which makes it easier to later
    refactor a single web application into multiple microservices. This style is in
    contrast to the way that many Java applications are organized, with all the business
    logic in one package, all the database logic in another package, and the data
    transfer objects in a third.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目变得更加复杂，你会有将包拆分的冲动。确保组织你的代码以限制包之间的依赖关系。一个常见的模式是按功能划分代码。例如，如果你在Go语言中编写了一个购物网站，你可以将所有客户管理的代码放在一个包中，将所有库存管理的代码放在另一个包中。这种风格限制了包之间的依赖关系，使得以后将单个Web应用程序重构为多个微服务变得更容易。这种风格与许多Java应用程序的组织方式相反，后者将所有业务逻辑放在一个包中，所有数据库逻辑放在另一个包中，将数据传输对象放在第三个包中。
- en: 'When developing a library, take advantage of the `internal` package. If you
    create multiple packages within a module and they are outside an `internal` package,
    exporting a symbol so it can be used by another package in your module means it
    can also be used by *anyone* who imports your module. There’s a principle in software
    engineering called [Hyrum’s law](https://oreil.ly/820xv): “With a sufficient number
    of users of an API, it does not matter what you promise in the contract: all observable
    behaviors of your system will be depended on by somebody.” Once something is part
    of your API, you have a responsibility to continue supporting it until you decide
    to make a new version that’s not backward compatible. You will learn how to do
    this in [“Updating to Incompatible Versions”](#incompatible_version). If you have
    some symbols that you want to share only within your module, put them in `internal`.
    If you change your mind, you can always move the package out of `internal` later.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发库时，请利用 `internal` 包。如果在模块中创建多个包，并且它们不在 `internal` 包中，则导出符号以便其他包在您的模块中使用，这意味着*任何人*都可以使用它。在软件工程中有一个原则叫做
    [Hyrum’s law](https://oreil.ly/820xv)：“只要 API 有足够多的用户，那么您在合同中承诺的内容就无关紧要：系统的所有可观察行为都会被某人依赖。”一旦某物成为您的
    API 的一部分，您有责任继续支持它，直到决定发布一个不向后兼容的新版本。您将在 [“更新到不兼容版本”](#incompatible_version) 中学习如何做到这一点。如果您有一些符号希望仅在模块内共享，请将它们放在
    `internal` 中。如果您改变主意，随时可以稍后将包移出 `internal`。
- en: For a good overview of Go project structure advice, watch Kat Zien’s talk from
    GopherCon 2018, [“How Do You Structure Your Go Apps”](https://oreil.ly/0zHY4).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关 Go 项目结构建议的概述，请观看 Kat Zien 在 GopherCon 2018 的演讲[“你如何组织你的 Go 应用程序”](https://oreil.ly/0zHY4)。
- en: Warning
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The “golang-standards” GitHub repository claims to be the “standard” module
    layout. Russ Cox, the development lead for Go, has [publicly stated](https://oreil.ly/PAhWS)
    that it is not endorsed by the Go team and that the structure it recommends is
    in fact an antipattern. Please do not cite this repository as a way to organize
    your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的 “golang-standards” 仓库声称是 “标准” 模块布局。Go 的开发主管 Russ Cox 已经[公开表示](https://oreil.ly/PAhWS)这不被
    Go 团队认可，并且它推荐的结构实际上是反模式。请不要将此仓库作为组织代码的方法。
- en: Gracefully Renaming and Reorganizing Your API
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地重命名和重新组织您的 API
- en: After using a module for a while, you might realize that its API is not ideal.
    You might want to rename some of the exported identifiers or move them to another
    package within your module. To avoid a backward-breaking change, don’t remove
    the original identifiers; provide an alternate name instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块一段时间后，您可能会意识到其 API 不理想。您可能想要重命名一些导出标识符或将它们移动到模块中的另一个包中。为避免破坏向后兼容性的变更，请勿移除原始标识符；而是提供替代名称。
- en: This is easy with a function or method. You declare a function or method that
    calls the original. For a constant, simply declare a new constant with the same
    type and value, but a different name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数或方法，这很容易。您声明一个调用原始函数或方法的函数或方法。对于常量，只需声明一个新常量，类型和值相同，但名称不同。
- en: 'If you want to rename or move an exported type, you use an alias. Quite simply,
    an *alias* is a new name for a type. You saw in [Chapter 7](ch07.html#unique_chapter_id_07)
    how to use the `type` keyword to declare a new type based on an existing one.
    You also use the `type` keyword to declare an alias. Let’s say you have a type
    called `Foo`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想重命名或移动一个导出类型，可以使用别名。简单地说，*别名* 是类型的新名称。您在[第 7 章](ch07.html#unique_chapter_id_07)
    中看到如何使用 `type` 关键字基于现有类型声明一个新类型。您也可以使用 `type` 关键字声明一个别名。假设您有一个名为 `Foo` 的类型：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to allow users to access `Foo` by the name `Bar`, all you need
    to do is this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让用户通过名称 `Bar` 访问 `Foo`，您所需做的只是这样：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To create an alias, use the `type` keyword, the name of the alias, an equals
    sign, and the name of the original type. The alias has the same fields and methods
    as the original type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建别名，请使用 `type` 关键字、别名的名称、一个等号以及原始类型的名称。别名具有与原始类型相同的字段和方法。
- en: 'The alias can even be assigned to a variable of the original type without a
    type conversion:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 别名甚至可以分配给原始类型的变量，而无需进行类型转换：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One important point to remember: an alias is just another name for a type.
    If you want to add new methods or change the fields in an aliased struct, you
    must add them to the original type.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点要记住：别名只是类型的另一个名称。如果您想要添加新的方法或更改别名结构中的字段，必须将它们添加到原始类型中。
- en: 'You can alias a type that’s defined in the same package as the original type
    or in a different package. You can even alias a type from another module. There
    is one drawback to an alias in another package: you cannot use an alias to refer
    to the unexported methods and fields of the original type. This limitation makes
    sense, as aliases exist to allow a gradual change to a package’s API, and the
    API consists only of the exported parts of the package. To work around this limitation,
    call code in the type’s original package to manipulate unexported fields and methods.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为在同一个包中定义的原始类型或在不同包中定义的类型设置别名。甚至可以为另一个模块中的类型设置别名。在另一个包中设置别名的一个缺点是：你不能使用别名来引用原始类型的未导出方法和字段。这种限制是有道理的，因为别名存在的目的是允许逐步更改包的
    API，并且 API 只包括包的导出部分。为了解决这个限制，调用类型的原始包中的代码来操作未导出的字段和方法。
- en: Two kinds of exported identifiers can’t have alternate names. The first is a
    package-level variable. The second is a field in a struct. Once you choose a name
    for an exported struct field, there’s no way to create an alternate name.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的导出标识符不能有备用名称。第一种是包级变量。第二种是结构体中的字段。一旦为导出的结构体字段选择了名称，就没有办法创建备用名称。
- en: Avoiding the init Function if Possible
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 `init` 函数
- en: 'When you read Go code, it is usually clear which methods and functions are
    called. One of the reasons Go doesn’t have method overriding or function overloading
    is to make it easier to understand what code is running. However, there is a way
    to set up state in a package without explicitly calling anything: the `init` function.
    When you declare a function named `init` that takes no parameters and returns
    no values, it runs the first time the package is referenced by another package.
    Since `init` functions do not have any inputs or outputs, they can work only by
    side effect, interacting with package-level functions and variables.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读 Go 代码时，通常清楚哪些方法和函数被调用。Go 没有方法重写或函数重载的一个原因是为了更容易理解哪些代码正在运行。然而，有一种方法可以在不显式调用任何内容的情况下设置包中的状态：`init`
    函数。当你声明一个名为 `init` 的函数，它不带参数并且不返回任何值时，它会在另一个包首次引用该包时运行。由于 `init` 函数没有任何输入或输出，它们只能通过副作用工作，与包级别的函数和变量进行交互。
- en: The `init` function has another unique feature. Go allows you to declare multiple
    `init` functions in a single package, or even in a single file in a package. There’s
    a documented order for running multiple `init` functions in a single package,
    but rather than remembering it, it’s better to simply avoid them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数还有另一个独特的特性。Go 允许在单个包中或甚至在包中的单个文件中声明多个 `init` 函数。有一个记录的顺序来运行单个包中的多个
    `init` 函数，但与其记住它，不如简单地避免使用它们。'
- en: 'Some packages, like database drivers, use `init` functions to register the
    database driver. However, you don’t use any of the identifiers in the package.
    As mentioned earlier, Go doesn’t allow you to have unused imports. To work around
    this, Go allows *blank imports*, where the name assigned to an import is the underscore
    (`_`). Just as an underscore allows you to skip an unused return value from a
    function, a blank import triggers the `init` function in a package but doesn’t
    give you access to any of the exported identifiers in the package:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有些包，比如数据库驱动程序，使用 `init` 函数来注册数据库驱动程序。然而，你并不使用包中的任何标识符。正如前面提到的，Go 不允许你有未使用的导入。为了解决这个问题，Go
    允许*空白导入*，其中分配给导入的名称是下划线 (`_`)。正如下划线允许你跳过从函数返回的未使用值一样，空白导入触发包中的 `init` 函数，但不允许你访问包中的任何导出标识符：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This pattern is considered obsolete because it’s unclear that a registration
    operation is being performed. Go’s compatibility guarantee for its standard library
    means that you are stuck using it to register database drivers and image formats,
    but if you have a registry pattern in your own code, register your plug-ins explicitly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被认为是过时的，因为不清楚是否正在执行注册操作。Go 对其标准库的兼容性保证意味着你被限制使用它来注册数据库驱动程序和图像格式，但如果你在自己的代码中有一个注册模式，要显式地注册你的插件。
- en: The primary use of `init` functions today is to initialize package-level variables
    that can’t be configured in a single assignment. It’s a bad idea to have mutable
    state at the top level of a package, since it makes it harder to understand how
    data flows through your application. That means that any package-level variables
    configured via `init` should be *effectively immutable*. While Go doesn’t provide
    a way to enforce that their value does not change, you should make sure that your
    code does not change them. If you have package-level variables that need to be
    modified while your program is running, see if you can refactor your code to put
    that state into a struct that’s initialized and returned by a function in the
    package.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 今天`init`函数的主要用途是初始化不能在单个赋值中配置的包级变量。在包的顶层有可变状态是个坏主意，因为这会使得理解数据在你的应用程序中的流动变得更加困难。这意味着通过`init`配置的任何包级变量都应该是*有效不可变的*。虽然Go没有提供强制确保它们的值不会改变的方法，但你应确保你的代码不会改变它们。如果你有需要在程序运行时修改的包级变量，看看是否可以重构你的代码，将该状态放入一个由包中的函数初始化并返回的结构体中。
- en: The nonexplicit invocation of `init` functions means that you should document
    their behavior. For example, a package with an `init` function that loads files
    or accesses the network should call this out in a package-level comment so that
    security-conscious users of your code aren’t surprised by unexpected I/O.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式调用`init`函数意味着你应该记录它们的行为。例如，一个包含`init`函数的包，用于加载文件或访问网络，应该在包级别的注释中说明，以便对代码安全性敏感的用户不会因意外的I/O而感到惊讶。
- en: Working with Modules
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块
- en: 'You’ve seen how to work with packages within a single module, and now it’s
    time to see how to integrate with third-party modules and the packages within
    them. After that, you’ll learn about publishing and versioning your own modules
    and Go’s centralized services: pkg.go.dev, the module proxy, and the checksum
    database.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了如何在单个模块内使用包，现在是时候学习如何与第三方模块及其内部的包集成了。接下来，你将学习如何发布和版本化你自己的模块，以及Go的集中服务：pkg.go.dev、模块代理和校验和数据库。
- en: Importing Third-Party Code
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入第三方代码
- en: So far, you’ve imported packages from the standard library like `fmt`, `errors`,
    `os`, and `math`. Go uses the same import system to integrate packages from third
    parties. Unlike many other compiled languages, Go always builds applications from
    source code into a single binary file. This includes the source code of your module
    and the source code of all the modules on which your module depends. (The Go compiler
    is smart enough to not include unreferenced packages in the binary it produces.)
    Just as you saw when you imported a package from within your own module, when
    you import a third-party package, you specify the location in the source code
    repository where the package is located.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经从标准库中导入了`fmt`、`errors`、`os`和`math`等包。Go使用相同的导入系统来集成来自第三方的包。与许多其他编译语言不同，Go总是将应用程序从源代码构建成单个二进制文件。这包括你的模块的源代码以及你的模块依赖的所有模块的源代码。（Go编译器足够智能，不会在生成的二进制文件中包含未引用的包。）正如你从自己的模块内导入包时看到的那样，当你导入第三方包时，你需要指定源代码仓库中包的位置。
- en: Let’s look at an example. I mentioned back in [Chapter 2](ch02.html#unique_chapter_id_02)
    that you should never use floating-point numbers when you need an exact representation
    of a decimal number. If you do need an exact representation, one good option is
    the `decimal` module from [ShopSpring](https://oreil.ly/UZfMN). You are also going
    to look at a simple [formatting module](https://oreil.ly/q-Ce5) that I’ve written
    for this book. Both of these modules are used in a small program in the [money
    repository](https://oreil.ly/vSiNr) for the book. This program calculates the
    price of an item with the tax included and prints the output in a neat format.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我在[第2章](ch02.html#unique_chapter_id_02)中提到，当你需要准确表示小数时，永远不要使用浮点数。如果确实需要准确的表示，一个好的选择是来自[ShopSpring](https://oreil.ly/UZfMN)的`decimal`模块。你还将看到我为本书编写的一个简单的[格式化模块](https://oreil.ly/q-Ce5)。这两个模块都在本书的[money
    repository](https://oreil.ly/vSiNr)中的一个小程序中使用。该程序计算包含税款的商品价格，并以整洁的格式输出。
- en: 'The following code is in *main.go*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码在*main.go*中：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The two imports `github.com/learning-go-book-2e/formatter` and `git⁠hub.​com/shopspring/decimal`
    specify third-party imports. Note that they include the location of the package
    in the repository. Once they’re imported, you access the exported items in these
    packages just like any other imported package.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 两个导入`github.com/learning-go-book-2e/formatter`和`github.com/shopspring/decimal`指定了第三方导入。请注意，它们包含包在存储库中的位置。一旦导入，您可以像任何其他导入的包一样访问这些包中的导出项。
- en: 'Before building the application, look at the *go.mod* file. Its contents should
    be as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序之前，请查看*go.mod*文件。其内容应如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you try to do a build, you get the following message:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试构建，会收到以下消息：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As the errors indicate, you cannot build the program until you add references
    to the third-party modules to your *go.mod* file. The `go get` command downloads
    modules and updates the *go.mod* file. You have two options when using `go get`.
    The simplest option is to tell `go get` to scan your module’s source code and
    add any modules that are found in `import` statements to *go.mod*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误所指出的，直到您向*go.mod*文件添加对第三方模块的引用，才能构建程序。`go get`命令下载模块并更新*go.mod*文件。在使用`go
    get`时有两个选项。最简单的选项是告诉`go get`扫描您模块的源代码，并添加任何在`import`语句中找到的模块到*go.mod*中：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because the location of the package is in the source code, `go get` is able
    to get the package’s module and download it. If you look in the *go.mod* file
    now, you’ll see this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包的位置在源代码中，`go get`能够获取包的模块并下载它。如果现在查看*go.mod*文件，您将看到这个内容：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first `require` section of the *go.mod* file lists the modules that you’ve
    imported into your module. After the module name is a version number. In the case
    of the `formatter` module, it doesn’t have a version tag, so Go makes up a *pseudoversion*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.mod*文件的第一个`require`部分列出了导入到您模块的模块。模块名后面是版本号。对于`formatter`模块来说，它没有版本标签，因此Go会生成一个*伪版本*。'
- en: You also see a second `require` directive section that has modules with an *indirect*
    comment. One of these modules (`github.com/fatih/color`) is directly used by `formatter`.
    It, in turn, depends on the other three modules in the second `require` directive
    section. All the modules used by all your module’s dependencies (and your dependencies’
    dependencies, and so on) are included in the *go.mod* file for your module. The
    ones that are used only in dependencies are marked as indirect.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会看到第二个`require`指令部分，其中的模块带有*indirect*注释。这些模块中的一个（`github.com/fatih/color`）直接被`formatter`使用。而`formatter`又依赖于第二个`require`指令部分的其他三个模块。您模块的所有依赖（及其依赖的依赖等等）使用的所有模块都包含在您模块的*go.mod*文件中。只在依赖中使用的模块标记为间接。
- en: 'In addition to updating *go.mod*, a *go.sum* file is created. For each module
    in the dependency tree of your project, the *go.sum* file has one or two entries:
    one with the module, its version, and a hash of the module; the other with the
    hash of the *go.mod* file for the module. Here’s what the *go.sum* file looks
    like:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更新*go.mod*文件外，还创建了一个*go.sum*文件。您项目的依赖树中每个模块在*go.sum*文件中都有一到两个条目：一个是模块及其版本及模块哈希的条目；另一个是模块的*go.mod*文件的哈希条目。下面是*go.sum*文件的示例：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’ll see what these hashes are used for in [“Module Proxy Servers”](#proxy_server).
    You might also notice that there are multiple versions of some of the dependencies.
    I’ll talk about that in [“Minimal Version Selection”](#minimal_selection).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到这些哈希用途在[“模块代理服务器”](#proxy_server)中。您可能还注意到某些依赖项有多个版本。我将在[“最小版本选择”](#minimal_selection)中讨论这一点。
- en: 'Let’s validate that your modules are now set up correctly. Run `go build` again,
    and then run the `money` binary and pass it some arguments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下您的模块现在是否设置正确。再次运行`go build`，然后运行`money`二进制文件并传递一些参数：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This sample program was checked in without *go.sum* and with an incomplete *go.mod*.
    This was done so you could see what happens when these files are populated. When
    committing your own modules to source control, always include up-to-date *go.mod*
    and *go.sum* files. Doing so specifies exactly what versions of your dependencies
    are being used. This enables *repeatable builds*; when anyone else (including
    your future self) builds this module, they will get the exact same binary.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例程序已经检入，但没有*go.sum*文件，并且*go.mod*文件不完整。这样做是为了让您看到这些文件填充后的效果。在提交自己的模块到源代码控制时，请务必包含最新的*go.mod*和*go.sum*文件。这样做可以明确指定正在使用的依赖项的确切版本。这样可以实现*可重复构建*；当其他人（包括未来的您自己）构建此模块时，他们将获得完全相同的二进制文件。
- en: 'As I mentioned, there’s another way to use `go get`. Instead of telling it
    to scan your source code to discover modules, you can pass the module paths to
    `go get`. To see this work, roll back the changes to your *go.mod* file and remove
    the *go.sum* file. On Unix-like systems, the following commands will do this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，还有另一种使用 `go get` 的方式。而不是让它扫描你的源代码来发现模块，你可以直接传递模块路径给 `go get`。要看到这一点的效果，请回滚对
    *go.mod* 文件的更改并删除 *go.sum* 文件。在类 Unix 系统上，以下命令将执行此操作：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, pass the module paths to `go get` directly:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直接将模块路径传递给 `go get`：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sharp-eyed readers might have noticed that when we used `go get` a second time,
    the `go: downloading` messages weren’t displayed. The reason is that Go maintains
    a *module cache* on your local computer. Once a version of a module is downloaded,
    a copy is kept in the cache. Source code is pretty compact, and drives are pretty
    large, so this isn’t usually a concern. However, if you want to delete the module
    cache, use the command `go clean -modcache`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '一些眼尖的读者可能已经注意到，当我们第二次使用 `go get` 时，并没有显示 `go: downloading` 的消息。原因是 Go 在你的本地计算机上维护了一个
    *模块缓存*。一旦下载了模块的某个版本，就会在缓存中保留一个副本。源代码非常紧凑，而驱动器非常大，所以通常不会引起关注。然而，如果你想删除模块缓存，可以使用命令
    `go clean -modcache`。'
- en: 'Take a look at the contents of *go.mod*, and they’ll look a little different
    than before:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *go.mod* 的内容，它们会与之前略有不同：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that all the imports are marked as *indirect*, not just the ones that
    came from `formatter`. When you run `go get` and pass it a module name, it doesn’t
    check your source code to see whether the module you specified is used within
    your main module. Just to be safe, it adds an indirect comment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的导入都标记为 *indirect*，而不仅仅是来自 `formatter` 的导入。当你运行 `go get` 并传递一个模块名时，它不会检查你的源代码以确定你指定的模块是否在你的主模块中使用。为了安全起见，它添加了一个间接注释。
- en: If you want to fix this label automatically, use the command `go mod tidy`.
    It scans your source code and synchronizes the *go.mod* and *go.sum* files with
    your module’s source code, adding and removing module references. It also makes
    sure that the indirect comments are correct.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自动修复这个标签，请使用命令 `go mod tidy`。它会扫描你的源代码，并与你模块的源代码同步 *go.mod* 和 *go.sum* 文件，添加和删除模块引用。它还确保间接注释是正确的。
- en: You might be wondering why you would want to bother using `go get` with a module
    name. The reason is that it allows you to update the version of an individual
    module.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你想知道为什么要费心使用 `go get` 来管理模块名称。原因在于它允许你更新单个模块的版本。
- en: Working with Versions
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本管理
- en: 'Let’s see how Go’s module system uses versions. I’ve written a [simple module](https://oreil.ly/zx0GR)
    that you’re going to use in another [tax-collection program](https://oreil.ly/AyAz_).
    In *main.go*, there are the following third-party imports:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Go 的模块系统如何使用版本。我写了一个[简单的模块](https://oreil.ly/zx0GR)，你将在另一个[税收程序](https://oreil.ly/AyAz_)中使用它。在
    *main.go* 中，有以下第三方导入：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As before, the sample program wasn’t checked in with *go.mod*, and *go.sum*
    updated, so you could see what happens. When the program is built, you see the
    following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，示例程序没有与 *go.mod* 和 *go.sum* 一起检入，因此你可以看到发生了什么。当构建程序时，你会看到以下内容：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The *go.mod* file has been updated:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.mod* 文件已更新：'
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is also a *go.sum* file with hashes for your dependencies. Run the code
    and see whether it’s working:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你的依赖关系还有一个 *go.sum* 文件，其中包含哈希值。运行代码，看看是否工作正常：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That looks like an unexpected answer. The latest version of the module might
    have a bug. By default, Go picks the latest version of a dependency when you add
    it to your module. However, one of the things that makes versioning useful is
    that you can specify an earlier version of a module. First, you can see what versions
    of the module are available with the `go list` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个答案有些出乎意料。模块的最新版本可能存在 bug。默认情况下，当你将一个依赖项添加到你的模块时，Go 会选择其最新版本。然而，版本控制的一个有用之处在于，你可以指定一个较早的模块版本。首先，你可以用
    `go list` 命令查看模块的所有版本：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By default, the `go list` command lists the packages that are used in your
    module. The `-m` flag changes the output to list the modules instead, and the
    `-versions` flag changes `go list` to report on the available versions for the
    specified module. In this case, you see that there are two versions, v1.0.0 and
    v1.1.0\. Let’s downgrade to version v1.0.0 and see if that fixes your problem.
    You do that with the `go get` command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`go list` 命令列出你模块中使用的包。使用 `-m` 标志可以改变输出，列出模块而非包；`-versions` 标志则改变 `go
    list` 的输出，报告指定模块的可用版本。在这种情况下，你会看到有两个版本，v1.0.0 和 v1.1.0\. 让我们降级到版本 v1.0.0，看看是否能解决你的问题。你可以使用
    `go get` 命令来做到这一点：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `go get` command lets you work with modules, updating the versions of your
    dependencies.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get` 命令允许你使用模块，更新你的依赖项版本。'
- en: 'Now if you look at *go.mod*, you’ll see that the version has been changed:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你查看 *go.mod*，你会看到版本已经更改了：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You also see in *go.sum* that it contains both versions of `simpletax`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 *go.sum* 中看到 `simpletax` 包含两个版本：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is fine; if you change a module’s version or even remove a module from
    your module, an entry for it might still remain in *go.sum*. This doesn’t cause
    problems.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题；如果你更改模块的版本，甚至从你的模块中删除一个模块，它的条目可能仍然会留在 *go.sum* 中。这不会引起问题。
- en: 'When you build and run the code again, the bug is fixed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次构建和运行代码时，问题已经解决了：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Minimal Version Selection
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小版本选择
- en: At some point, your module will depend on two or more modules that all depend
    on the same module. As often happens, these modules declare that they depend on
    different minor or patch versions of that module. How does Go resolve this?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你的模块将依赖于两个或更多依赖于同一模块的模块。通常情况下，这些模块声明依赖于该模块的不同次要或修订版本。Go 如何解决这个问题？
- en: 'The module system uses the principle of *minimal version selection*: you will
    always get the lowest version of a dependency that is declared to work in all
    the *go.mod* files across all your dependencies. Let’s say that your module directly
    depends on modules A, B, and C. All three of these modules depend on module D.
    The *go.mod* file for module A declares that it depends on v1.1.0, module B declares
    that it depends on v1.2.0, and module C declares that it depends on v1.2.3\. Go
    will import module D only once, and it will choose version v1.2.3, as that, in
    the words of the [Go Modules Reference](https://oreil.ly/6YRBy), is the minimum
    version that satisfies all requirements.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统使用*最小版本选择*原则：你总是会获得在所有依赖项的 *go.mod* 文件中都声明可以工作的最低版本的依赖项。假设你的模块直接依赖于模块 A、B
    和 C。这三个模块都依赖于模块 D。模块 A 的 *go.mod* 文件声明依赖于 v1.1.0，模块 B 声明依赖于 v1.2.0，模块 C 声明依赖于
    v1.2.3\. Go 只会导入模块 D 一次，并且它会选择 v1.2.3 版本，因为这是满足所有要求的最低版本，如 [Go 模块参考](https://oreil.ly/6YRBy)
    所述。
- en: 'You can see this in action with your sample program from [“Importing Third-Party
    Code”](#import_third_party). The command `go mod graph` shows the dependency graph
    of your module and all its dependencies. Here are a few lines of its output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [“导入第三方代码”](#import_third_party) 中的示例程序中看到这个操作。命令 `go mod graph` 显示了你模块及其所有依赖项的依赖图。以下是部分输出：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each line lists two modules, the first being the parent and the second being
    the dependency and its version. You’ll notice the `github.com/fatih/color` module
    is declared to depend on version v0.0.14 of `github.com/mattn/go-isatty`, while
    `github.com/mattn/go-colorable` depends on v0.0.12\. The Go compiler selects version
    v0.0.14 to use, because it is the minimal version that meets all requirements.
    This occurs even though, as of this writing, the latest version of `github.com/mattn/go-isatty`
    is v0.0.16\. Your minimal version requirement is met with v0.0.14, so that’s what
    is used.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行列出两个模块，第一个是父模块，第二个是依赖及其版本。你会注意到 `github.com/fatih/color` 模块依赖于 `github.com/mattn/go-isatty`
    的 v0.0.14 版本，而 `github.com/mattn/go-colorable` 则依赖于 v0.0.12\. Go 编译器选择使用版本 v0.0.14，因为它是满足所有要求的最低版本。尽管截至撰写本文时，`github.com/mattn/go-isatty`
    的最新版本是 v0.0.16，但你的最低版本要求满足了 v0.0.14，所以就使用了这个版本。
- en: This system isn’t perfect. You might find that while module A works with version
    v1.1.0 of module D, it does not work with version v1.2.3\. What do you do then?
    Go’s answer is that you need to contact the module authors to fix their incompatibilities.
    The *import compatibility rule* says, “If an old package and a new package have
    the same import path, the new package must be backward compatible with the old
    package.” All minor and patch versions of a module must be backward compatible.
    If they aren’t, it’s a bug. In our hypothetical example, either module D needs
    to be fixed because it broke backward compatibility, or module A needs to be fixed
    because it made a faulty assumption about the behavior of module D.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统并不完美。您可能会发现，虽然模块A与模块D的版本v1.1.0兼容，但却无法与版本v1.2.3兼容。那么该怎么办呢？Go的答案是，您需要联系模块作者修复其不兼容性。*导入兼容性规则*说，“如果旧包和新包具有相同的导入路径，则新包必须向后兼容旧包。”一个模块的所有次要和补丁版本必须向后兼容。如果不兼容，则是一个bug。在我们的假设示例中，要么模块D需要修复因为它打破了向后兼容性，要么模块A需要修复因为它对模块D行为的假设是错误的。
- en: You might not find this answer satisfying, but it’s honest. Some build systems,
    like npm, will include multiple versions of the same package. This can introduce
    its own set of bugs, especially when there is package-level state. It also increases
    the size of your application. In the end, some things are better solved by community
    than code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会觉得这个答案令人满意，但它是诚实的。一些构建系统，如npm，将包含同一包的多个版本。这可能会引入一系列自己的bug，尤其是在存在包级状态时。它还会增加应用程序的大小。最终，有些问题最好由社区而不是代码来解决。
- en: Updating to Compatible Versions
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新到兼容版本
- en: What if you explicitly want to upgrade a dependency? Let’s assume that after
    writing the initial program, there are three more versions of `simpletax`. The
    first fixes problems in the initial v1.1.0 release. Since it’s a bug patch release
    with no new functionality, it would be released as v1.1.1\. The second keeps the
    current functionality but also adds a new function. It would get the version number
    v1.2.0\. Finally, the third fixes a bug that was found in version v1.2.0\. It
    has the version number v1.2.1.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您明确希望升级依赖关系怎么办？假设在编写初始程序后，`simpletax` 还有三个版本。第一个修复了初始v1.1.0版本中的问题。由于这是一个修复bug的补丁发布，没有新功能，它将发布为v1.1.1。第二个保留当前功能，但还添加了一个新功能。它将版本号为v1.2.0。最后一个修复了在版本v1.2.0中发现的bug。它的版本号是v1.2.1。
- en: To upgrade to the bug patch release for the current minor version, use the command
    `go get -u=patch github.com/learning-go-book-2e/simpletax`. Since you had downgraded
    to v1.0.0, you would remain on that version, because there is no patch version
    with the same minor version.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级到当前次要版本的错误修复版本，请使用命令 `go get -u=patch github.com/learning-go-book-2e/simpletax`。由于您已降级到v1.0.0，因此将保持在该版本，因为没有具有相同次要版本的修补版本。
- en: Upgrade to version v1.1.0 by using `go get github.com/learning-go-book-2e/simpletax@v1.1.0`
    and then run `go get -u=patch github.com/learning-go-book-2e/​sim⁠pletax`. This
    upgrades the version to v1.1.1.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go get github.com/learning-go-book-2e/simpletax@v1.1.0` 升级到版本v1.1.0，然后运行
    `go get -u=patch github.com/learning-go-book-2e/​sim⁠pletax`。这将升级版本至v1.1.1。
- en: Finally, use the command `go get -u github.com/learning-go-book-2e/simpletax`
    to get the most recent version of `simpletax`. That upgrades you to version v1.2.1.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用命令 `go get -u github.com/learning-go-book-2e/simpletax` 来获取 `simpletax`
    的最新版本。这将使您升级到版本v1.2.1。
- en: Updating to Incompatible Versions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新到不兼容的版本
- en: Let’s go back to the program. You’re expanding to Canada, and luckily, a version
    of the `simpletax` module handles both the US and Canada. However, this version
    has a slightly different API than the previous one, so its version is v2.0.0.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到程序。你们正在扩展到加拿大，幸运的是，`simpletax` 模块的一个版本同时处理美国和加拿大。然而，这个版本与之前的版本有稍微不同的API，因此其版本为v2.0.0。
- en: 'To handle incompatibility, Go modules follow the *semantic import versioning*
    rule. This rule has two parts:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为处理不兼容性，Go 模块遵循*语义化导入版本规则*。该规则有两部分：
- en: The major version of the module must be incremented.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的主要版本必须递增。
- en: For all major versions besides 0 and 1, the path to the module must end in v*N*,
    where *N* is the major version.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于除了0和1之外的所有主要版本，模块的路径必须以v*N*结尾，其中*N*是主要版本号。
- en: The path changes because an import path uniquely identifies a package. By definition,
    incompatible versions of a package are not the same package. Using different paths
    means that you can import two incompatible versions of a package into different
    parts of your program, allowing you to upgrade gracefully.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 路径更改是因为导入路径唯一标识一个包。根据定义，不同版本的包不属于同一个包。使用不同的路径意味着您可以在程序的不同部分导入两个不兼容的包版本，从而实现平滑升级。
- en: 'Let’s see how this changes the program. First, change the import of `simpletax`
    to this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何改变程序。首先，将`simpletax`的导入更改为以下内容：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This changes your import to refer to the v2 module.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把您的导入改为指向 v2 模块。
- en: 'Next, change the code in `main` to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `main` 中的代码更改为以下内容：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The program is now reading a third parameter from the command line, which is
    the country code. The program also calls a different function in the `simpletax`
    package. When you run `go get ./...`, the dependency is automatically updated:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在从命令行读取第三个参数，即国家代码。程序还在`simpletax`包中调用不同的函数。当您运行`go get ./...`时，依赖项将自动更新：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Build and run the program to see the new output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行程序，查看新输出：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When you look at the *go.mod* file, you’ll see that the new version of `simpletax`
    is included:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *go.mod* 文件时，您会看到包括新版本的 `simpletax`：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And *go.sum* has been updated as well:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.sum*也已更新：'
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The old versions of `simpletax` are still referenced, even though they are no
    longer used. Use `go mod tidy` to remove those unused versions. Then you’ll see
    only v2.0.0 of `simpletax` referenced in *go.mod* and *go.sum*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不再使用，旧版本的 `simpletax` 仍然被引用。使用 `go mod tidy` 删除那些未使用的版本。然后您将只看到 *go.mod* 和
    *go.sum* 中引用的 v2.0.0 版本的 `simpletax`。
- en: Vendoring
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vendoring
- en: To ensure that a module always builds with identical dependencies, some organizations
    like to keep copies of their dependencies inside their module. This is known as
    *vendoring*. It’s enabled by running the command `go mod vendor`. This creates
    a directory called *vendor* at the top level of your module that contains all
    your module’s dependencies. These dependencies are used in place of the module
    cache stored on your computer.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保模块始终使用相同的依赖项构建，一些组织喜欢在其模块内部保留依赖项的副本。这称为 *vendoring*。通过运行命令 `go mod vendor`
    启用它。这将在您的模块顶层创建一个名为 *vendor* 的目录，其中包含所有您模块的依赖项。这些依赖项用于替代存储在您计算机上的模块缓存。
- en: If new dependencies are added to *go.mod* or versions of existing dependencies
    are upgraded with `go get`, you need to run `go mod vendor` again to update the
    *vendor* directory. If you forget to do this, `go build`, `go run`, and `go test`
    will display an error message and refuse to run.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 *go.mod* 中添加了新的依赖项，或者使用 `go get` 升级了现有依赖项的版本，您需要再次运行 `go mod vendor` 更新
    *vendor* 目录。如果忘记执行此操作，`go build`、`go run` 和 `go test` 将显示错误消息并拒绝运行。
- en: Older Go dependency management systems required vendoring, but with the advent
    of Go modules and proxy servers (see [“Module Proxy Servers”](#proxy_server) for
    details), the practice is falling out of favor. One reason you might still want
    to vendor is that it can make building your code faster and more efficient when
    working with some CI/CD (continuous integration/continuous delivery) pipelines.
    If a pipeline’s build servers are ephemeral, the module cache may not be preserved.
    Vendoring dependencies allows these pipelines to avoid making multiple network
    calls to download dependencies every time a build is triggered. The downside is
    that it dramatically increases the size of your codebase in version control.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 Go 依赖管理系统需要进行 vendoring，但随着 Go 模块和代理服务器的出现（详见[“模块代理服务器”](#proxy_server)），这一做法已不再受欢迎。您仍然可能想要进行
    vendoring 的一个原因是在某些 CI/CD（持续集成/持续交付）流水线中，这样可以加快构建代码的速度和效率。如果流水线的构建服务器是短暂存在的，模块缓存可能不会被保留。将依赖项
    vendoring 可以避免每次触发构建时都进行多次网络调用以下载依赖项。不过，其缺点是会显著增加您的代码库在版本控制中的大小。
- en: Using pkg.go.dev
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pkg.go.dev
- en: While there isn’t a single centralized repository of Go modules, there is a
    single service that gathers together documentation on Go modules. The Go team
    has created a site called [*pkg.go.dev*](https://pkg.go.dev) that automatically
    indexes open source Go modules. For each module, the package index publishes the
    godocs, the license used, the *README*, the module’s dependencies, and what open
    source modules depend on the module. You can see the info that *pkg.go.dev* has
    on your `simpletax` module in [Figure 10-2](#use_pkg_go_dev_to_find_and_learn).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有单一的Go模块集中存储库，但有一个单一的服务收集Go模块的文档信息。Go团队创建了一个名为[*pkg.go.dev*](https://pkg.go.dev)的站点，它自动索引开源Go模块。对于每个模块，包索引发布了godocs、使用的许可证、*README*、模块的依赖项以及依赖于该模块的开源模块。你可以在[图10-2](#use_pkg_go_dev_to_find_and_learn)中看到*pkg.go.dev*对你的`simpletax`模块的信息。
- en: '![Version information on https://pkg.go.dev](assets/lgo2_1002.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![https://pkg.go.dev上的版本信息](assets/lgo2_1002.png)'
- en: Figure 10-2\. Use pkg.go.dev to find and learn about third-party modules
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-2\. 使用pkg.go.dev查找并了解第三方模块
- en: Publishing Your Module
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布你的模块
- en: Making your module available to other people is as simple as putting it in a
    version control system. This is true whether you are releasing your module as
    open source on a public version control system like GitHub or a private one that’s
    hosted by you or within a company. Since Go programs build from source code and
    use a repository path to identify themselves, there’s no need to explicitly upload
    your module to a central library repository, as you do for Maven Central or npm.
    Make sure you check in both your *go.mod* file and your *go.sum* file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的模块对其他人可用就像将其放入版本控制系统一样简单。无论你是在公共版本控制系统（如GitHub）还是你自己或公司托管的私有版本控制系统上发布你的模块作为开源，都适用这一点。由于Go程序从源代码构建并使用仓库路径来标识自己，所以不需要显式地将你的模块上传到像Maven
    Central或npm这样的中央库仓库。确保同时检入你的*go.mod*文件和*go.sum*文件。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While most Go developers use Git for version control, Go also supports Subversion,
    Mercurial, Bazaar, and Fossil. By default, Git and Mercurial can be used for public
    repositories, and any of the supported version control systems can be used for
    private repositories. For details, check out the [version control system documentation](https://oreil.ly/Oz608)
    for Go modules.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Go开发者使用Git进行版本控制，但Go也支持Subversion、Mercurial、Bazaar和Fossil。默认情况下，Git和Mercurial可用于公共存储库，任何支持的版本控制系统都可用于私有存储库。有关详细信息，请查看[Go模块的版本控制系统文档](https://oreil.ly/Oz608)。
- en: When releasing an open source module, you should include a file named *LICENSE*
    in the root of your repository that specifies the open source license under which
    you are releasing your code. [It’s FOSS](https://oreil.ly/KVlrd) is a good resource
    for learning more about the various kinds of open source licenses.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布开源模块时，你应该在仓库根目录中包含一个名为*LICENSE*的文件，该文件指定了你发布代码的开源许可证。[*It’s FOSS*](https://oreil.ly/KVlrd)是一个了解各种开源许可证的好资源。
- en: 'Roughly speaking, you can divide open source licenses into two categories:
    permissive (which allows users of your code to keep their code private) and nonpermissive
    (which requires users of your code to make their code open source). While the
    license you choose is up to you, the Go community favors permissive licenses,
    such as BSD, MIT, and Apache. Since Go compiles third-party code directly into
    every application, the use of a nonpermissive license like the GPL would require
    people who use your code to release their code as open source as well. For many
    organizations, this is not acceptable.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，你可以将开源许可证分为两类：宽松许可（允许你的代码使用者保持其代码私有）和非宽松许可（要求你的代码使用者将其代码开源）。虽然你可以选择自己喜欢的许可证，但Go社区更青睐宽松许可证，例如BSD、MIT和Apache。由于Go直接将第三方代码编译到每个应用程序中，使用类似GPL的非宽松许可证将要求使用你的代码的人也将他们的代码开源化。对于许多组织来说，这是不可接受的。
- en: 'One final note: do not write your own license. Few people will trust that it
    has been properly reviewed by a lawyer, and they can’t tell what claims you are
    making on their module.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要注意：不要编写自己的许可证。很少有人会相信这种许可证已经得到律师的适当审查，他们也无法知道你在他们的模块上作出了什么声明。
- en: Versioning Your Module
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块版本控制
- en: Whether your module is public or private, you should properly version your module
    so that it works correctly with Go’s module system. As long as you are adding
    functionality or patching bugs, the process is simple. Store your changes in your
    source code repository, then apply a tag that follows the semantic versioning
    rules I discussed in [“Semantic Versioning”](#semver).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的模块是公共的还是私有的，你都应该正确地为你的模块版本化，以便它能够与Go的模块系统正确地工作。只要你在添加功能或修复错误，这个过程就很简单。将你的更改存储在你的源代码仓库中，然后应用一个遵循我在[“语义化版本控制”](#semver)中讨论的语义版本规则的标签。
- en: Go’s semantic versioning supports the concept of *pre-releases*. Let’s assume
    that the current version of your module is tagged `v1.3.4`. You are working on
    version 1.4.0, which is not quite done, but you want to try importing it into
    another module. What you should do is append a hyphen (*-*) to the end of your
    version tag, followed by an identifier for the pre-release build. In this case,
    use a tag like `v1.4.0-beta1` to indicate beta 1 of version 1.4.0 or `v1.4.0-rc2`
    to indicate release candidate 2\. If you want to depend on a pre-release candidate,
    you must specify its version explicitly in `go get`, as Go will not automatically
    select a pre-release version.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Go的语义化版本支持*预发布*的概念。假设你的模块当前版本标记为`v1.3.4`。你正在开发的版本是1.4.0，虽然还没有完成，但你想尝试将其导入另一个模块。你应该在你的版本标签的末尾添加一个连字符（*-*），然后跟上预发布构建的标识符。在这种情况下，使用如`v1.4.0-beta1`来表示版本1.4.0的beta
    1或`v1.4.0-rc2`来表示发布候选2。如果你想依赖于一个预发布候选版本，你必须在`go get`中显式地指定它的版本，因为Go不会自动选择预发布版本。
- en: If you reach a point where you need to break backward compatibility, the process
    is more complicated. As you saw when importing version 2 of the `simpletax` module,
    a backward-breaking change requires a different import path. There are a few steps
    to take.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你达到了需要破坏向后兼容性的程度，这个过程会变得更加复杂。正如你在导入`simpletax`模块的第2版时所看到的，一个向后兼容性的变化需要不同的导入路径。需要执行几个步骤。
- en: 'First you need to choose a way to store your new version. Go supports two ways
    for creating the different import paths:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要选择一种存储新版本的方式。Go支持两种方式来创建不同的导入路径：
- en: Create a subdirectory within your module named *vN*, where *N* is the major
    version of your module. For example, if you are creating version 2 of your module,
    call this directory *v2*. Copy your code into this subdirectory, including the
    *README* and *LICENSE* files.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的模块中创建一个名为*vN*的子目录，其中*N*是你的模块的主要版本。例如，如果你正在创建模块的第2版，将此目录命名为*v2*。将你的代码复制到这个子目录中，包括*README*和*LICENSE*文件。
- en: Create a branch in your version control system. You can put either the old code
    or the new code on the new branch. Name the branch *vN* if you are putting the
    new code on the branch, or *vN-1* if you are putting the old code there. For example,
    if you are creating version 2 of your module and want to put version 1 code on
    the branch, name the branch *v1*.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的版本控制系统中创建一个分支。你可以将旧代码或新代码放在新分支上。如果将新代码放在分支上，则将分支命名为*vN*；如果将旧代码放在那里，则将分支命名为*vN-1*。例如，如果你正在创建模块的第2版并希望将第1版代码放在分支上，则将分支命名为*v1*。
- en: After you decide how to store your new code, you need to change the import path
    in the code in your subdirectory or branch. The module path in your *go.mod* file
    must end with */vN*, and all the imports within your module must use */vN* as
    well. Going through all your code can be tedious, but Marwan Sulaiman has created
    a [tool that automates](https://oreil.ly/BeOAr) the work. Once the paths are fixed,
    go ahead and implement your changes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何存储你的新代码之后，你需要在子目录或分支的代码中更改导入路径。你的*go.mod*文件中的模块路径必须以*/vN*结尾，并且模块内的所有导入也必须使用*/vN*。遍历所有代码可能会很繁琐，但是Marwan
    Sulaiman已经创建了一个[自动化工具](https://oreil.ly/BeOAr)来完成这项工作。一旦路径修复好了，就可以开始实施你的更改。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, you could just change *go.mod* and your import statements, tag
    your main branch with the latest version, and not bother with a subdirectory or
    versioned branch. However, this is not a good practice, as it makes it unclear
    where to find older major versions of your module.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以只修改*go.mod*和你的导入语句，标记你的主分支为最新版本，而不必费心使用子目录或带版本的分支。然而，这并不是一个好的实践，因为它会让人不清楚在哪里找到你模块的旧主要版本。
- en: When you are ready to publish your new code, place a tag on your repository
    that looks like v*N*.0.0\. If you are using the subdirectory system or keeping
    the latest code on your main branch, tag the main branch. If you are placing your
    new code on a different branch, tag that branch instead.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备发布新代码时，在您的代码库上放置一个标签，格式如 v*N*.0.0\. 如果您使用子目录系统或将最新代码放在主分支上，请在主分支上打标签。如果您将新代码放在不同的分支上，请在该分支上打标签。
- en: 'You can find more details on updating your code to an incompatible version
    in the post [“Go Modules: v2 and Beyond”](https://oreil.ly/E-3Qo) on The Go Blog
    and in [“Developing a Major Version Update”](https://oreil.ly/_Li5v) on the Go
    developer website.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文章 [“Go 模块：v2 及更高版本”](https://oreil.ly/E-3Qo) 中和 [“开发主要版本更新”](https://oreil.ly/_Li5v)
    中找到关于将代码更新到不兼容版本的更多细节。
- en: Overriding Dependencies
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖依赖项
- en: 'Forks happen. While there’s a bias against forking in the open source community,
    sometimes a module stops being maintained or you want to experiment with changes
    that aren’t accepted by the module’s owner. A `replace` directive redirects all
    references to a module across all your module’s dependencies and replaces them
    with the specified fork of the module. It looks like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 分支会发生。虽然开源社区对分支持有偏见，但有时模块停止维护，或者您想要尝试未被模块所有者接受的更改。`replace` 指令会将所有依赖您模块的模块中的所有模块引用重定向，并用指定的模块分支替换它们。它看起来像这样：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The original module location is specified on the left side of the `=>` and the
    replacement on the right. The right side must have a version specified, but specifying
    a version is optional for the left side. If a version is specified on the left
    side, only that specific version will be replaced. If the version is not specified,
    any version of the original module will be replaced with the specific version
    of the fork.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的 `=>` 指定了原始模块的位置，右边是替换后的位置。右边必须指定一个版本，但左边的版本是可选的。如果左边指定了一个版本，那么只会替换这个特定版本的原始模块。如果没有指定版本，任何版本的原始模块都将被替换为分支的特定版本。
- en: 'A `replace` directive can also refer to a path on your local filesystem:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 指令也可以引用本地文件系统上的路径：'
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With a local `replace` directive, the module version must be omitted from the
    right side.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地的 `replace` 指令中，必须省略右边的模块版本。
- en: Warning
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid using local `replace` directives. They provided a way to modify multiple
    modules simultaneously before the invention of Go workspaces, but now they are
    a potential source of broken modules. (I will cover workspaces shortly.) If you
    share your module via version control, a module with local references in `replace`
    directives will probably not build for anyone else, since you cannot guarantee
    that other people will have the replacement modules in the same locations on their
    drive.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用本地 `replace` 指令。在 Go 工作区被发明之前，它们提供了一种同时修改多个模块的方法，但现在它们是产生破坏模块的潜在来源。如果通过版本控制共享您的模块，那么带有
    `replace` 指令本地引用的模块可能不会为其他人构建，因为您不能保证其他人在他们的驱动器上具有相同位置的替换模块。
- en: 'You also might want to block a specific version of a module from being used.
    Perhaps it has a bug or is incompatible with your module. Go provides the `exclude`
    directive to prevent a specific version of a module from being used:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能希望阻止使用模块的特定版本。也许它有一个 bug 或与您的模块不兼容。Go 提供了 `exclude` 指令来阻止使用模块的特定版本：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When a module version is excluded, any mentions of that module version in any
    dependent module are ignored. If a module version is excluded and it’s the only
    version of that module that’s required in your module’s dependencies, use `go
    get` to add an indirect import of a different version of the module to your module’s
    *go.mod* file so that your module still compiles.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块版本被排除时，任何依赖模块中对该模块版本的提及都会被忽略。如果排除了一个模块版本，并且这是您的模块依赖中唯一需要的那个模块版本，请使用 `go
    get` 将另一个版本的该模块间接导入到您模块的 *go.mod* 文件中，以便您的模块仍然可以编译。
- en: Retracting a Version of Your Module
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撤销模块的版本
- en: Sooner or later, you will accidentally publish a version of your module that
    you don’t want anyone to use. Perhaps it was released by accident before testing
    was complete. Maybe after its release, a critical vulnerability is discovered
    and no one should use it any more. No matter the reason, Go provides a way for
    you to indicate that certain versions of a module should be ignored. This is done
    by adding a `retract` directive to the *go.mod* file of your module. It consists
    of the word `retract` and the semantic version that should no longer be used.
    If a range of versions shouldn’t be used, you can exclude all versions in that
    range by placing the upper and lower bounds within brackets, separated by a comma.
    While it’s not required, you should include a comment after a version or version
    range to explain the reason for the retraction.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，你会意外发布一个你不希望任何人使用的模块版本。也许在测试完成之前不小心发布了它。也许在发布后，发现了一个关键性漏洞，不再允许任何人使用它。不管原因是什么，Go为你提供了一种方法，可以指示应忽略某些模块版本。这是通过在你的模块的*go.mod*文件中添加`retract`指令来完成的。它由单词`retract`和不应再使用的语义版本组成。如果一个版本范围不应该使用，你可以通过在方括号内放置上下界来排除该范围内的所有版本，用逗号分隔。虽然不是必需的，但你应该在版本或版本范围后面加上注释，解释撤回的原因。
- en: 'If you wish to retract multiple nonsequential versions, you can specify them
    with multiple `retract` directives. In the examples shown, version 1.5.0 is excluded,
    as are all versions from 1.7.0 to 1.8.5, inclusive:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望撤回多个非连续版本，你可以用多个`retract`指令来指定它们。在所示的示例中，版本1.5.0被排除，以及从1.7.0到1.8.5（含）的所有版本：
- en: '[PRE53]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding a `retract` directive to *go.mod* requires you to create a new version
    of your module. If the new version contains only the retraction, you should retract
    it as well.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 将`retract`指令添加到*go.mod*文件需要你创建模块的新版本。如果新版本仅包含撤回操作，则应将其撤回。
- en: When a version is retracted, existing builds that specified the version will
    continue to work, but `go get` and `go mod tidy` will not upgrade to them. They
    will no longer appear as options when you use the `go list` command. If the most
    recent version of a module is retracted, it will no longer be matched with `@latest`;
    the highest unretracted version will match instead.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当版本被撤回时，已指定该版本的现有构建将继续工作，但`go get`和`go mod tidy`将不会升级到这些版本。当你使用`go list`命令时，它们将不再显示为选项。如果模块的最新版本被撤回，它将不再与`@latest`匹配；而是将匹配最高的未撤回版本。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While `retract` can be confused with `exclude`, there’s a very important difference.
    You use `retract` to prevent others from using specific versions of *your* module.
    An `exclude` directive blocks you from using versions of another module.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`retract`可能会与`exclude`混淆，但它们之间有一个非常重要的区别。你使用`retract`来防止他人使用你的模块的特定版本。`exclude`指令则阻止你使用另一个模块的版本。
- en: Using Workspaces to Modify Modules Simultaneously
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作空间同时修改模块
- en: There’s one drawback to using your source code repository and its tags as a
    way to track your dependencies and their versions. If you want to make changes
    to two (or more) modules simultaneously, and you want to experiment with those
    changes across modules, you need a way to use a local copy of a module instead
    of the version in the source code repository.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的源代码仓库及其标签作为跟踪依赖及其版本的方法有一个缺点。如果你想同时修改两个（或更多）模块，并且希望在这些模块之间进行实验性更改，你需要一种方法来使用模块的本地副本，而不是源代码仓库中的版本。
- en: Warning
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You can find obsolete advice online to try to solve this issue with temporary
    `replace` directives in *go.mod* that point to local directories. Do not do this!
    It’s too easy to forget to undo these changes before committing and pushing your
    code. Workspaces were introduced to avoid this antipattern.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在网上找到过时的建议，尝试通过临时在*go.mod*中添加`replace`指令指向本地目录来解决这个问题。不要这样做！很容易忘记在提交和推送代码之前撤销这些更改。工作空间的引入就是为了避免这种反模式。
- en: Go uses *workspaces* to address this issue. A workspace allows you to have multiple
    modules downloaded to your computer, and references between those modules will
    automatically resolve to the local source code instead of the code hosted in your
    repository.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用*工作空间*来解决这个问题。工作空间允许你在计算机上下载多个模块，并且这些模块之间的引用将自动解析为本地源代码，而不是存储在你的仓库中的代码。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This section assumes that you have a GitHub account. If you don’t, you can still
    follow along. I’m going to use the organization name `learning-go-book-2e`, but
    you should replace it with your GitHub account name or organization.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设您拥有GitHub帐户。如果没有，您仍然可以跟着进行。我将使用组织名`learning-go-book-2e`，但您应该用您的GitHub帐户名或组织名替换它。
- en: 'Let’s start with two sample modules. Create a *my_workspace* directory and
    in that directory, create two more directories, *workspace_lib* and *workspace_app*.
    In the *workspace_lib* directory, run `go mod init github.com/learning-go-book-2e/workspace_lib`.
    Create a file called *lib.go* with the following content:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从两个示例模块开始。在*my_workspace*目录中创建一个*workspace_lib*和一个*workspace_app*目录。在*workspace_lib*目录中，运行`go
    mod init github.com/learning-go-book-2e/workspace_lib`。创建一个名为*lib.go*的文件，内容如下：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the *workspace_app* directory, run `go mod init github.com/learning-go​-⁠book-2e/workspace_app`.
    Create a file called *app.go* with the following contents:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在*workspace_app*目录中，运行`go mod init github.com/learning-go-book-2e/workspace_app`。创建一个名为*app.go*的文件，内容如下：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In previous sections, you used `go get ./...` to add `require` directives to
    *go.mod*. Let’s see what happens if you try it here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您使用了`go get ./...`来向*go.mod*添加`require`指令。让我们看看在这里尝试会发生什么：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since *workspace_lib* hasn’t been pushed to GitHub yet, you can’t pull it in.
    If you try to run `go build`, you will get a similar error:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*workspace_lib*尚未推送到GitHub，您无法将其拉入。如果尝试运行`go build`，您将收到类似的错误：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s take advantage of workspaces to allow *workplace_app* to see the local
    copy of *workspace_lib*. Go to the *my_workspace* directory and run the following
    commands:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用工作空间，使*workplace_app*能够查看*workspace_lib*的本地副本。转到*my_workspace*目录并运行以下命令：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This creates a *go.work* file in *my_workspace* with the following contents:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在*my_workspace*中创建一个*go.work*文件，内容如下：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Warning
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The *go.work* file is meant for your local computer only. Do not commit it to
    source control!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.work*文件仅适用于您的本地计算机。不要将其提交到源代码控制中！'
- en: 'Now if you build *workspace_app*, everything works:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您构建*workspace_app*，一切都正常：
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that you are sure that *workspace_lib* does the right thing, it can be
    pushed to GitHub. In GitHub, create an empty public repository called `workspace_lib`
    and then run the following commands in the *workspace_lib* directory:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您确信*workspace_lib*工作正常，可以将其推送到GitHub。在GitHub上，创建一个名为`workspace_lib`的空公共存储库，然后在*workspace_lib*目录中运行以下命令：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After running these commands, go to *[*https://github.com/learning-go-book-2e/workspace_lib/releases/new*](https://github.com/learning-go-book-2e/workspace_lib/releases/new)*
    (replacing “learning-go-book-2e” with your account or organization), and create
    a new release with the tag v0.1.0.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令后，转到[*https://github.com/learning-go-book-2e/workspace_lib/releases/new*](https://github.com/learning-go-book-2e/workspace_lib/releases/new)（用您的帐户或组织替换“learning-go-book-2e”），并创建一个带有标签v0.1.0的新发布。
- en: 'Now if you go back to the *workspace_app* directory and run `go get ./...`,
    the `require` directive is added, because there is a public module that can be
    downloaded:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您回到*workspace_app*目录并运行`go get ./...`，`require`指令将被添加，因为有一个可以下载的公共模块：
- en: '[PRE62]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can validate that your code is working with the public module by setting
    the environment variable `GOWORK=off` and building your application:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过设置环境变量`GOWORK=off`并构建您的应用程序来验证您的代码是否正常工作：
- en: '[PRE63]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Even though there is now a `require` directive referring to the public module,
    you can continue to make updates in our local workspace and they will be used
    instead. In *workspace_lib*, modify the *lib.go* file and add the following function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 即使现在有一个`require`指令指向公共模块，您仍然可以在我们的本地工作空间中继续进行更新，这些更新将被使用。在*workspace_lib*中，修改*lib.go*文件，并添加以下函数：
- en: '[PRE64]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In *workspace_app*, modify the *app.go* file and add the following line to
    the end of the `main` function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在*workspace_app*中，修改*app.go*文件，并在`main`函数的末尾添加以下行：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now run `go build` and see it use the local module instead of the public one:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`go build`，看到它使用本地模块而不是公共模块：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once you have made the edits and want to release your software, you need to
    update the version information in your modules’ *go.mod* files to refer to the
    updated code. This requires you to commit your modules to source control in dependency
    order:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行了编辑并希望发布您的软件，您需要更新模块的版本信息以引用更新的代码。这需要您按依赖顺序将模块提交到源代码控制中：
- en: Choose a modified module that has no dependencies on any of the modified modules
    in your workspace.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个修改后不依赖于工作空间中任何修改模块的修改模块。
- en: Commit this module to your source code repository.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此模块提交到您的源代码仓库。
- en: Create a new version tag on the newly committed module in your source code repository.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的源代码仓库中为新提交的模块创建一个新的版本标签。
- en: Use `go get` to update the version specified in *go.mod* in the modules that
    depend on the newly committed module.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `go get` 命令来更新依赖于新提交模块的模块在 *go.mod* 中指定的版本。
- en: Repeat the first four steps until all modified modules are committed.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前四个步骤，直到所有修改的模块都已提交。
- en: If you have to make changes to *workspace_lib* in the future and want to test
    them in *workspace_app* without pushing back to GitHub and creating lots of temporary
    versions, you can `git pull` the latest versions of the modules into your workspace
    again and make your updates.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将来必须对 *workspace_lib* 进行更改，并希望在不推回到 GitHub 并创建大量临时版本的情况下在 *workspace_app*
    中测试它们，可以再次 `git pull` 最新版本的模块到您的工作区，并进行更新。
- en: Module Proxy Servers
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块代理服务器
- en: Rather than relying on a single, central repository for libraries, Go uses a
    hybrid model. Every Go module is stored in a source code repository, like GitHub
    or GitLab. But by default, `go get` doesn’t fetch code directly from source code
    repositories. Instead, it sends requests to a [*proxy server*](https://oreil.ly/TllQM)
    run by Google. When the proxy server receives the `go get` request, it checks
    its cache to see if there has been a request for this module version before. If
    so, it returns the cached information. If a module or a version of a module isn’t
    cached on the proxy server, it downloads the module from the module’s repository,
    stores a copy, and returns the module. This allows the proxy server to keep copies
    of every version of virtually all public Go modules.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不使用单一的中央库存储库来依赖库，而是采用混合模型。每个 Go 模块都存储在源代码仓库中，如 GitHub 或 GitLab。但是，默认情况下，`go
    get` 不直接从源代码仓库获取代码。相反，它将请求发送到由 Google 运行的 [*代理服务器*](https://oreil.ly/TllQM)。当代理服务器收到
    `go get` 请求时，它检查其缓存以查看此模块版本之前是否有请求。如果有，它返回缓存的信息。如果代理服务器未缓存某个模块或某个模块的版本，则从模块的仓库下载该模块，存储一个副本，并返回该模块。这使得代理服务器可以保存几乎所有公共
    Go 模块的每个版本的副本。
- en: In addition to the proxy server, Google also maintains a *checksum database*.
    It stores information on every version of every module cached by the proxy server.
    Just as the proxy server protects you from a module or a version of a module being
    removed from the internet, the checksum database protects you against modifications
    to a version of a module. This could be malicious (someone has hijacked a module
    and slipped in malicious code), or it could be inadvertent (a module maintainer
    fixes a bug or adds a new feature and reuses an existing version tag). In either
    case, you don’t want to use a module version that has changed because you won’t
    be building the same binary and don’t know what the effects are on your application.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理服务器外，Google 还维护一个 *校验和数据库*。它存储了代理服务器缓存的每个模块的每个版本的信息。正如代理服务器保护您免受模块或模块版本被从互联网移除的影响一样，校验和数据库则保护您免受对模块版本的修改影响。这可能是恶意行为（某人劫持了一个模块并插入了恶意代码），也可能是无意的（模块维护者修复了一个错误或添加了一个新特性并重用了现有的版本标签）。无论哪种情况，您都不希望使用已更改的模块版本，因为您将无法构建相同的二进制文件，并且不知道对您的应用程序造成的影响。
- en: Every time you download a module via `go get` or `go mod tidy`, the Go tools
    calculate a hash for the module and contact the checksum database to compare the
    calculated hash to the hash stored for that module’s version. If they don’t match,
    the module isn’t installed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您通过 `go get` 或 `go mod tidy` 下载一个模块时，Go 工具都会为该模块计算一个哈希值，并联系校验和数据库以比较计算的哈希值与存储在该模块版本的哈希值是否匹配。如果不匹配，则不安装该模块。
- en: Specifying a Proxy Server
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定代理服务器
- en: 'Some people object to sending requests for third-party libraries to Google.
    There are a few options:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人反对向 Google 发送第三方库的请求。有几个选择：
- en: You can disable proxying entirely by setting the `GOPROXY` environment variable
    to `direct`. You’ll download modules directly from their repositories, but if
    you depend on a version that’s removed from the repository, you won’t be able
    to access it.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过将 `GOPROXY` 环境变量设置为 `direct` 来完全禁用代理。您将直接从它们的仓库下载模块，但如果您依赖的版本已从仓库中移除，则无法访问它。
- en: You can run your own proxy server. Both Artifactory and Sonatype have Go proxy
    server support built into their enterprise repository products. The [Athens Project](https://oreil.ly/Ud1uX)
    provides an open source proxy server. Install one of these products on your network
    and then point `GOPROXY` to the URL.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以运行自己的代理服务器。Artifactory 和 Sonatype 的企业仓库产品均支持 Go 代理服务器。[Athens 项目](https://oreil.ly/Ud1uX)提供了一个开源代理服务器。在你的网络上安装其中一个产品，然后将`GOPROXY`指向该
    URL。
- en: Using Private Repositories
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用私有仓库
- en: Most organizations keep their code in private repositories. If you want to use
    a private module in another Go module, you can’t request it from Google’s proxy
    server. Go will fall back to checking the private repository directly, but you
    might not want to leak the names of private servers and repositories to external
    services.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组织将它们的代码存储在私有仓库中。如果你想在另一个 Go 模块中使用私有模块，你不能从 Google 的代理服务器请求它。Go 将回退到直接检查私有仓库，但你可能不希望将私有服务器和仓库的名称泄露给外部服务。
- en: If you are using your own proxy server, or if you have disabled proxying, this
    isn’t an issue. Running a private proxy server has some additional benefits. First,
    it speeds up downloading of third-party modules, as they are cached in your company’s
    network. If accessing your private repositories requires authentication, using
    a private proxy server means that you don’t have to worry about exposing authentication
    information in your CI/CD pipeline. The private proxy server is configured to
    authenticate to your private repositories (see the [authentication configuration
    documentation](https://oreil.ly/Nl4hv) for Athens), while the calls to the private
    proxy server are unauthenticated.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用自己的代理服务器，或者已禁用代理，这不是问题。运行私有代理服务器有一些额外的好处。首先，它加快了第三方模块的下载速度，因为它们被缓存在公司网络中。如果访问你的私有仓库需要身份验证，使用私有代理服务器意味着你不必担心在
    CI/CD 流水线中泄露身份验证信息。私有代理服务器配置为对你的私有仓库进行身份验证（参见[Athens 的身份验证配置文档](https://oreil.ly/Nl4hv)），而对私有代理服务器的调用是未经身份验证的。
- en: 'If you are using a public proxy server, you can set the `GOPRIVATE` environment
    variable to a comma-separated list of your private repositories. For example,
    if you set `GOPRIVATE` to:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用公共代理服务器，你可以将`GOPRIVATE`环境变量设置为你的私有仓库的逗号分隔列表。例如，如果你将`GOPRIVATE`设置为：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: any module stored in a repository that’s located at any subdomain of *example.com*
    or at a URL that starts with *company.com/repo* will be downloaded directly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在*example.com*的任何子域或以*company.com/repo*开头的 URL 的仓库中的任何模块将直接下载。
- en: Additional Details
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加细节
- en: The Go Team has a complete [Go Modules Reference](https://oreil.ly/ZW-VD) available
    online. In addition to the content in this chapter, the Module Reference also
    covers topics like using version control systems besides Git, the structure and
    API of the module cache, additional environment variables for controlling module
    lookup behavior, and the REST API for the module proxy and checksum database.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Go 团队在线提供完整的[Go 模块参考](https://oreil.ly/ZW-VD)。除了本章内容外，模块参考还涵盖了其他主题，如使用除 Git
    外的版本控制系统，模块缓存的结构和 API，控制模块查找行为的其他环境变量，以及模块代理和校验和数据库的 REST API。
- en: Exercises
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Create a module in your own public repository. This module has a single function
    named `Add` with two `int` parameters and one `int` return value. This function
    adds the two parameters together and returns them. Make this version v1.0.0.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你自己的公共仓库中创建一个模块。该模块有一个名为`Add`的函数，带有两个`int`参数和一个`int`返回值。该函数将两个参数相加并返回它们。将此版本设为v1.0.0。
- en: Add godoc comments to your module that describe the package and the `Add` function.
    Be sure to include a link to *[*https://www.mathsisfun.com/numbers/addition.html*](https://www.mathsisfun.com/numbers/addition.html)*
    in your `Add` function godoc. Make this version v1.0.1.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的模块中添加 godoc 注释，描述包和`Add`函数。确保在你的`Add`函数的 godoc 中包含一个链接到[*https://www.mathsisfun.com/numbers/addition.html*](https://www.mathsisfun.com/numbers/addition.html)。将此版本设为v1.0.1。
- en: Change `Add` to make it generic. Import the `golang.org/x/exp/constraints` package.
    Combine the `Integer` and `Float` types in that package to create an interface
    called `Number`. Rewrite `Add` to take in two parameters of type `Number` and
    return a value of type `Number`. Version your module again. Because this is a
    backward-breaking change, this should be v2.0.0 of your module.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Add`改为通用的。导入`golang.org/x/exp/constraints`包。在该包中将`Integer`和`Float`类型合并，创建一个名为`Number`的接口。重写`Add`函数，接受两个`Number`类型的参数，并返回一个`Number`类型的值。再次对你的模块进行版本化。因为这是一个向后不兼容的变更，所以应该将你的模块版本设为v2.0.0。
- en: Wrapping Up
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束
- en: In this chapter, you’ve learned how to organize code and interact with the ecosystem
    of Go source code. You’ve seen how modules work, how to organize your code into
    packages, how to use third-party modules, and how to release modules of your own.
    In the next chapter, you’re going to take a look at more of the development tools
    that are included with Go, learn about some essential third-party tools, and explore
    some techniques to give you better control over your build process.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何组织代码并与Go源代码生态系统互动。你了解了模块的工作原理，如何将代码组织成包，如何使用第三方模块，以及如何发布你自己的模块。在下一章中，你将进一步了解Go附带的开发工具，学习一些必备的第三方工具，并探索一些技术，以便更好地控制你的构建过程。
