<html><head></head><body><section data-pdf-bookmark="Chapter 8. building storage: Structs" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="building_storagecolon_structs">
<h1 class="calibre17"><span class="calibre">Chapter 8. </span>building storage: Structs</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0231-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Sometimes you need to store more than one type of data.</strong></p>
<p class="calibre7">We learned about slices, which store a list of values. Then we learned about maps, which map a list of keys to a list of values. But both of these data structures can only hold values of <em class="calibre9">one</em> type. Sometimes, you need to group together values of <em class="calibre9">several</em> types. Think of mailing addresses, where you have to mix street names (strings) with postal codes (integers). Or student records, where you have to mix student names (strings) with grade point averages (floating-point numbers). You can’t mix value types in slices or maps. But you <em class="calibre9">can</em> if you use another type called a <strong class="calibre8">struct</strong>. We’ll learn all about structs in this chapter!</p>
<section data-pdf-bookmark="Slices and maps hold values of ONE type" data-type="sect1" class="preface"><div class="preface" id="slices_and_maps_hold_values_of_one_type">
<h1 class="calibre25">Slices and maps hold values of ONE type</h1>
<p class="calibre7"><a data-primary="arrays" data-secondary="about" data-type="indexterm" id="idm46062711882696" class="calibre10"/><a data-primary="maps" data-secondary="about" data-type="indexterm" id="idm46062711881288" class="calibre10"/><a data-primary="slices" data-secondary="about" data-type="indexterm" id="idm46062711880136" class="calibre10"/><a data-primary="types" data-secondary="mixing values of different" data-type="indexterm" id="idm46062711878760" class="calibre10"/><em class="calibre9">Gopher Fancy</em> is a new magazine devoted to lovable rodents. They’re currently working on a system to keep track of their subscriber base.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0232-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0232-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">It’s true: arrays, slices, and maps are no help if you need to mix values of different types. They can only be set up to hold values of a single type. But Go does have a way to solve this problem...</strong></p>
</div></section>
<section data-pdf-bookmark="Structs are built out of values of MANY types" data-type="sect1" class="preface"><div class="preface" id="structs_are_built_out_of_values_of_many">
<h1 class="calibre25">Structs are built out of values of MANY types</h1>
<p class="calibre7"><a data-primary="curly braces {}" data-secondary="structs and" data-type="indexterm" id="idm46062711871288" class="calibre10"/><a data-primary="struct keyword" data-type="indexterm" id="idm46062711869752" class="calibre10"/><a data-primary="struct literals" data-type="indexterm" id="idm46062711868360" class="calibre10"/><a data-primary="structs" data-secondary="about" data-type="indexterm" id="idm46062711867560" class="calibre10"/><a data-primary="struct types" data-secondary="declaring" data-type="indexterm" id="idm46062711866408" class="calibre10"/>A <strong class="calibre8">struct</strong> (short for “structure”) is a value that is constructed out of other values of many different types. Whereas a slice might only be able to hold <code class="calibre20">string</code> values or a map might only be able to hold <code class="calibre20">int</code> values, you can create a struct that holds <code class="calibre20">string</code> values, <code class="calibre20">int</code> values, <code class="calibre20">float64</code> values, <code class="calibre20">bool</code> values, and more—all in one convenient group.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0233-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You declare a struct type using the <code class="calibre20">struct</code> keyword, followed by curly braces. Within the braces, you can define one or more <strong class="calibre8">fields</strong>: values that the struct groups together. Each field definition appears on a separate line, and consists of a field name, followed by the type of value that field will hold.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0233-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You can use a struct type as the type of a variable you’re declaring. This code declares a variable named <code class="calibre20">myStruct</code> that holds structs that have a <code class="calibre20">float64</code> field named <code class="calibre20">number</code>, a <code class="calibre20">string</code> field named <code class="calibre20">word</code>, and a <code class="calibre20">bool</code> field named <code class="calibre20">toggle</code>:</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="calibre7">(It’s more common to use a defined type to declare struct variables, but we won’t cover type definitions for a few more pages, so we’ll write it this way for now.)</p>
</div>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0233-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">When we call <code class="calibre20">Printf</code> with the <code class="calibre20">%#v</code> verb above, it prints the value in <code class="calibre20">myStruct</code> as a struct literal. We’ll be covering struct literals later in the chapter, but for now you can see that the struct’s <code class="calibre20">number</code> field has been set to <code class="calibre20">0</code>, the <code class="calibre20">word</code> field to an empty string, and the <code class="calibre20">toggle</code> field to <code class="calibre20">false</code>. Each field has been set to the zero value for its type.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="relax_5">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/cup.png" class="calibre4"/></span> Relax</h5>
<p class="calibre7"><strong class="calibre8">Don’t worry about the number of spaces between struct field names and their types.</strong></p>
<p class="calibre7">When you write your struct fields, just insert a single space between the field name and its type. When you run the <code class="calibre20">go fmt</code> command on your files (which you should always do), it will insert extra spaces so that all the types align vertically. The alignment just makes the code easier to read; it doesn’t change its meaning at all!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0234-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Access struct fields using the dot operator" data-type="sect1" class="preface"><div class="preface" id="access_struct_fields_using_the_dot_opera">
<h1 class="calibre25">Access struct fields using the dot operator</h1>
<p class="calibre7"><a data-primary="dot operator (.)" data-secondary="accessing functions" data-type="indexterm" id="idm46062711837176" class="calibre10"/><a data-primary="dot operator (.)" data-secondary="accessing struct fields" data-type="indexterm" id="idm46062711836344" class="calibre10"/><a data-primary="functions" data-secondary="dot operator and" data-type="indexterm" id="idm46062711835160" class="calibre10"/><a data-primary="go fmt command" data-type="indexterm" id="idm46062711834120" class="calibre10"/><a data-primary="methods" data-secondary="dot operator and" data-type="indexterm" id="idm46062711833208" class="calibre10"/><a data-primary="packages" data-secondary="dot operator and" data-type="indexterm" id="idm46062711832136" class="calibre10"/><a data-primary="structs" data-secondary="accessing fields with dot operator" data-type="indexterm" id="idm46062711830952" class="calibre10"/>Now we can define a struct, but to actually use it, we need a way to store new values in the struct’s fields and retrieve them again.</p>
<p class="calibre7">All along, we’ve been using the dot operator to indicate functions that “belong to” another package, or methods that “belong to” a value:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0234-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Similarly, we can use a dot operator to indicate fields that “belong to” a struct. This works for both assigning values and retrieving them.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0234-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We can use dot operators to assign values to all the fields of <code class="calibre20">myStruct</code> and then print them back out:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0234-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Storing subscriber data in a struct" data-type="sect1" class="preface"><div class="preface" id="storing_subscriber_data_in_a_struct">
<h1 class="calibre25">Storing subscriber data in a struct</h1>
<p class="calibre7"><a data-primary="structs" data-secondary="storing subscriber data in" data-type="indexterm" id="idm46062711820328" class="calibre10"/><a data-primary="struct types" data-secondary="assigning values to fields" data-type="indexterm" id="idm46062711818840" class="calibre10"/><a data-primary="subscriber data, storing in structs" data-type="indexterm" id="idm46062711817656" class="calibre10"/>Now that we know how to declare a variable that holds a struct and assign values to its fields, we can create a struct to hold magazine subscriber data.</p>
<p class="calibre7">First, we’ll define a variable named <code class="calibre20">subscriber</code>. We’ll give <code class="calibre20">subscriber</code> a <code class="calibre20">struct</code> type with <code class="calibre20">name</code> (<code class="calibre20">string</code>), <code class="calibre20">rate</code> (<code class="calibre20">float64</code>), and <code class="calibre20">active</code> (<code class="calibre20">bool</code>) fields.</p>
<p class="calibre7">With the variable and its type declared, we can then use dot operators to access the struct’s fields. We assign values of the appropriate type to each field, and then print the values back out again.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0235-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Even though the data we have for a subscriber is stored using a variety of types, structs let us keep it all in one convenient package!</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_13">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">At the right is a program that creates a struct variable to hold a pet’s name (a <code class="calibre20">string</code>) and age (an <code class="calibre20">int</code>). Fill in the blanks so that the code will produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0235-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#exercise_solution_13" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Defined types and structs" data-type="sect1" class="preface"><div class="preface" id="defined_types_and_structs">
<h1 class="calibre25">Defined types and structs</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0236-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="curly braces {}" data-secondary="structs and" data-type="indexterm" id="idm46062711797000" class="calibre10"/><a data-primary="defined types" data-secondary="about" data-type="indexterm" id="idm46062711795784" class="calibre10"/><a data-primary="struct keyword" data-type="indexterm" id="idm46062711794712" class="calibre10"/><a data-primary="struct types" data-secondary="creating" data-type="indexterm" id="idm46062711793880" class="calibre10"/><a data-primary="type keyword" data-type="indexterm" id="idm46062711792696" class="calibre10"/><a data-primary="types" data-secondary="creating" data-type="indexterm" id="idm46062711791896" class="calibre10"/>Throughout this book, you’ve used a variety of types, like <code class="calibre20">int</code>, <code class="calibre20">string</code>, <code class="calibre20">bool</code>, slices, maps, and now structs. But you haven’t been able to create completely <em class="calibre9">new</em> types.</p>
<p class="calibre7"><strong class="calibre8">Type definitions</strong> allow you to create types of your own. They let you create a new <strong class="calibre8">defined type</strong> that’s based on an <strong class="calibre8">underlying type</strong>.</p>
<p class="calibre7">Although you can use any type as an underlying type, such as <code class="calibre20">float64</code>, <code class="calibre20">string</code>, or even slices or maps, in this chapter we’re going to focus on using struct types as underlying types. We’ll try using other underlying types when we take a deeper look at defined types in the next chapter.</p>
<p class="calibre7">To write a type definition, use the <code class="calibre20">type</code> keyword, followed by the name for your new defined type, and then the underlying type you want to base it on. If you’re using a struct type as your underlying type, you’ll use the <code class="calibre20">struct</code> keyword followed by a list of field definitions in curly braces, just as you did when declaring struct variables.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0236-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="functions" data-secondary="type definitions and" data-type="indexterm" id="idm46062711782984" class="calibre10"/><a data-primary="packages" data-secondary="type definitions and" data-type="indexterm" id="idm46062711780552" class="calibre10"/><a data-primary="scope" data-secondary="type definitions and" data-type="indexterm" id="idm46062711779464" class="calibre10"/>Just like variables, type definitions <em class="calibre9">can</em> be written within a function. But that will limit its scope to that function’s block, meaning you won’t be able to use it outside that function. So types are usually defined outside of any functions, at the package level.</p>
<p class="calibre7">As a quick demonstration, the code below defines two types: <code class="calibre20">part</code> and <code class="calibre20">car</code>. Each defined type uses a struct as its underlying type.</p>
<p class="calibre7">Then, within the <code class="calibre20">main</code> function, we declare a <code class="calibre20">porsche</code> variable of the <code class="calibre20">car</code> type, and a <code class="calibre20">bolts</code> variable of the <code class="calibre20">part</code> type. There’s no need to rewrite the lengthy struct definitions when declaring the variables; we just use the names of the defined types.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0237-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">With the variables declared, we can set the values of their struct fields and get the values back out, just as we did in previous programs.</p>
</div></section>
<section data-pdf-bookmark="Using a defined type for magazine subscribers" data-type="sect1" class="preface"><div class="preface" id="using_a_defined_type_for_magazine_subscr">
<h1 class="calibre25">Using a defined type for magazine subscribers</h1>
<p class="calibre7"><a data-primary="defined types" data-secondary="using to store data" data-type="indexterm" id="idm46062711769944" class="calibre10"/><a data-primary="types" data-secondary="using to store data" data-type="indexterm" id="idm46062711767960" class="calibre10"/>Previously, to create more than one variable that stored magazine subscriber data in a struct, we had to write out the full struct type (including all its fields) for each variable.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0238-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">But now, we can simply define a <code class="calibre20">subscriber</code> type at the package level. We write the struct type just once, as the underlying type for the defined type. When we’re ready to declare variables, we don’t have to write the struct type again; we simply use <code class="calibre20">subscriber</code> as their type. No more need to repeat the entire struct definition!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0238-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Using defined types with functions" data-type="sect1" class="preface"><div class="preface" id="using_defined_types_with_functions">
<h1 class="calibre25">Using defined types with functions</h1>
<p class="calibre7"><a data-primary="defined types" data-secondary="using with functions" data-type="indexterm" id="idm46062711759576" class="calibre10"/><a data-primary="functions" data-secondary="defined types and" data-type="indexterm" id="idm46062711758088" class="calibre10"/><a data-primary="functions" data-secondary="type definitions and" data-type="indexterm" id="idm46062711757000" class="calibre10"/><a data-primary="struct types" data-secondary="functions and" data-type="indexterm" id="idm46062711755864" class="calibre10"/><a data-primary="types" data-secondary="using with functions" data-type="indexterm" id="idm46062711754760" class="calibre10"/>Defined types can be used for more than just variable types. They also work for function parameters and return values.</p>
<p class="calibre7">Here’s our <code class="calibre20">part</code> type again, together with a new <code class="calibre20">showInfo</code> function that prints a part’s fields. The function takes a single parameter, with <code class="calibre20">part</code> as its type. Within <code class="calibre20">showInfo</code>, we access the fields via the parameter variable just like any other struct variable’s.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0239-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">And here’s a <code class="calibre20">minimumOrder</code> function that creates a <code class="calibre20">part</code> with a specified description and a predefined value for the <code class="calibre20">count</code> field. We declare <code class="calibre20">minimumOrder</code>’s return type to be <code class="calibre20">part</code> so it can return the new struct.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0239-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Let’s go over a couple functions that work with the magazine’s <code class="calibre20">subscriber</code> type...</p>
<p class="calibre7">The <code class="calibre20">printInfo</code> function takes a <code class="calibre20">subscriber</code> as a parameter, and prints the values of its fields.</p>
<p class="calibre7">We also have a <code class="calibre20">defaultSubscriber</code> function that sets up a new <code class="calibre20">subscriber</code> struct with some default values. It takes a string parameter called <code class="calibre20">name</code>, and uses that to set a new <code class="calibre20">subscriber</code> value’s <code class="calibre20">name</code> field. Then it sets the <code class="calibre20">rate</code> and <code class="calibre20">active</code> fields to default values. Finally, it returns the completed <code class="calibre20">subscriber</code> struct to its caller.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0240-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In our <code class="calibre20">main</code> function, we can pass a subscriber name to <code class="calibre20">defaultSubscriber</code> to get a new <code class="calibre20">subscriber</code> struct. One subscriber gets a discounted <code class="calibre20">rate</code>, so we reset that struct field directly. We can pass filled-out <code class="calibre20">subscriber</code> structs to <code class="calibre20">printInfo</code> to print out their contents.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="watch_it_4">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/watch-it.png" class="calibre4"/></span> Watch it!</h5>
<p class="calibre7"><strong class="calibre8">Don’t use an existing type name as a variable name!</strong></p>
<p class="calibre7"><em class="calibre9">If you’ve defined a type named</em> <code class="calibre20">car</code> <em class="calibre9">in the current package, and you declare a variable that’s also named</em> <code class="calibre20">car</code><em class="calibre9">, the variable name will shadow the type name, making it inaccessible.</em></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0241-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><em class="calibre9">This isn’t a common problem in practice, because defined types are often exported from their packages (and their names are therefore capitalized), and variables often are not (and their names are therefore lowercase).</em> <code class="calibre20">Car</code> <em class="calibre9">(an exported type name) can’t conflict with</em> <code class="calibre20">car</code> <em class="calibre9">(an unexported variable name). We’ll see more about exporting defined types later in the chapter. Still, shadowing is a confusing problem when it occurs, so it’s good to be aware that it can happen.</em></p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Code Magnets" data-type="sect1" class="preface"><div class="preface" id="code_magnets_6">
<h1 class="calibre25">Code Magnets</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0241-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="defined types" data-secondary="naming rules for" data-type="indexterm" id="idm46062711718696" class="calibre10"/><a data-primary="exporting from packages" data-secondary="defined types" data-type="indexterm" id="idm46062711717576" class="calibre10"/><a data-primary="naming rules" data-secondary="defined types" data-type="indexterm" id="idm46062711716504" class="calibre10"/><a data-primary="naming rules" data-secondary="types" data-type="indexterm" id="idm46062711715464" class="calibre10"/><a data-primary="naming rules" data-secondary="variables" data-type="indexterm" id="idm46062711714360" class="calibre10"/><a data-primary="packages" data-secondary="defined type names and" data-type="indexterm" id="idm46062711713256" class="calibre10"/><a data-primary="types" data-secondary="naming rules for" data-type="indexterm" id="idm46062711712152" class="calibre10"/><a data-primary="unexported fields" data-secondary="types and" data-type="indexterm" id="idm46062711711048" class="calibre10"/><a data-primary="unexported fields" data-secondary="variables and" data-type="indexterm" id="idm46062711709944" class="calibre10"/><a data-primary="variables" data-secondary="naming rules for" data-type="indexterm" id="idm46062711708840" class="calibre10"/><a data-primary="variables" data-secondary="unexported" data-type="indexterm" id="idm46062711707736" class="calibre10"/>A Go program is scrambled up on the fridge. Can you reconstruct the code snippets to make a working program that will produce the given output? The finished program will have a defined struct type named <code class="calibre20">student</code>, and a <code class="calibre20">printInfo</code> function that accepts a <code class="calibre20">student</code> value as a parameter.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0241-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#code_magnets_solution_6" class="calibre10">“Code Magnets Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="Modifying a struct using a function" data-type="sect1" class="preface"><div class="preface" id="modifying_a_struct_using_a_function">
<h1 class="calibre25">Modifying a struct using a function</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0242-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0242-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="functions" data-secondary="modifying structs using" data-type="indexterm" id="idm46062711695816" class="calibre10"/><a data-primary="pass-by-value languages" data-type="indexterm" id="idm46062711694200" class="calibre10"/><a data-primary="structs" data-secondary="modifying using functions" data-type="indexterm" id="idm46062711693368" class="calibre10"/>Our friends at <em class="calibre9">Gopher Fancy</em> are trying to write a function that takes a struct as a parameter and updates one of the fields in that struct.</p>
<p class="calibre7">Remember way back in <a data-type="xref" href="ch03.html#call_mecolon_functions" class="calibre10">Chapter 3</a>, when we were trying to write a <code class="calibre20">double</code> function that took a number and doubled it? After <code class="calibre20">double</code> returned, the number was back to its original value!</p>
<p class="calibre7">That’s when we learned that Go is a “pass-by-value” language, meaning that function parameters receive a <em class="calibre9">copy</em> of the arguments the function was called with. If a function changes a parameter value, it’s changing the <em class="calibre9">copy</em>, not the <em class="calibre9">original</em>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0242-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The same thing is true for structs. When we pass a <code class="calibre20">subscriber</code> struct to <code class="calibre20">applyDiscount</code>, the function receives a <em class="calibre9">copy</em> of the struct. So when we set the <code class="calibre20">rate</code> field on the struct, we’re modifying the <em class="calibre9">copied</em> struct, not the original.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0242-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="&amp; address-of operator" data-type="indexterm" id="idm46062711680440" class="calibre10"/><a data-primary="address-of operator (&amp;)" data-type="indexterm" id="idm46062711679320" class="calibre10"/><a data-primary="asterisk (*)" data-secondary="as pointer type prefix" data-type="indexterm" id="idm46062711678472" class="calibre10"/><a data-primary="dot operator (.)" data-secondary="accessing struct fields" data-type="indexterm" id="idm46062711677288" class="calibre10"/><a data-primary="functions" data-secondary="pointers and" data-type="indexterm" id="idm46062711676216" class="calibre10"/><a data-primary="pointers and pointer types" data-secondary="functions and" data-type="indexterm" id="idm46062711675032" class="calibre10"/><a data-primary="pointers and pointer types" data-secondary="getting/changing values at pointers" data-type="indexterm" id="idm46062711673992" class="calibre10"/><a data-primary="structs" data-secondary="accessing fields with dot operator" data-type="indexterm" id="idm46062711672872" class="calibre10"/>Back in <a data-type="xref" href="ch03.html#call_mecolon_functions" class="calibre10">Chapter 3</a>, our solution was to update the function parameter to accept a <em class="calibre9">pointer</em> to a value, instead of accepting a value directly. When calling the function, we used the address-of operator (<code class="calibre20">&amp;</code>) to pass a pointer to the value we wanted to update. Then, within the function, we used the <code class="calibre20">*</code> operator to update the value at that pointer.</p>
<p class="calibre7">As a result, the updated value was still visible after the function returned.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0243-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We can use pointers to allow a function to update a struct as well.</p>
<p class="calibre7">Here’s an updated version of the <code class="calibre20">applyDiscount</code> function that should work correctly. We update the <code class="calibre20">s</code> parameter to accept a pointer to a <code class="calibre20">subscriber</code> struct, rather than the struct itself. Then we update the value in the struct’s <code class="calibre20">rate</code> field.</p>
<p class="calibre7">In <code class="calibre20">main</code>, we call <code class="calibre20">applyDiscount</code> with a pointer to a <code class="calibre20">subscriber</code> struct. When we print the value in the struct’s <code class="calibre20">rate</code> field, we can see that it’s been updated successfully!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0243-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0243-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Actually, no! The dot notation to access fields works on struct pointers as well as the structs themselves.</strong></p>
</div></section>
<section data-pdf-bookmark="Accessing struct fields through a pointer" data-type="sect1" class="preface"><div class="preface" id="accessing_struct_fields_through_a_pointe">
<h1 class="calibre25">Accessing struct fields through a pointer</h1>
<p class="calibre7"><a data-primary="* (asterisk)" data-see="asterisk (*)" data-type="indexterm" id="idm46062711656040" class="calibre10"/><a data-primary="() (parentheses)" data-see="parentheses ()" data-type="indexterm" id="idm46062711654168" class="calibre10"/><a data-primary="asterisk (*)" data-type="indexterm" id="idm46062711653016" class="calibre10"/><a data-primary="asterisk (*)" data-secondary="accessing struct fields through pointers" data-type="indexterm" id="idm46062711652184" class="calibre10"/><a data-primary="parentheses ()" data-type="indexterm" id="idm46062711651080" class="calibre10"/><a data-primary="parentheses ()" data-secondary="accessing struct fields through pointers" data-type="indexterm" id="idm46062711650200" class="calibre10"/><a data-primary="pointers and pointer types" data-secondary="accessing struct fields through" data-type="indexterm" id="idm46062711649096" class="calibre10"/><a data-primary="structs" data-secondary="accessing fields through pointers" data-type="indexterm" id="idm46062711647944" class="calibre10"/>If you try to print a pointer variable, what you’ll see is the memory address it points to. This is generally not what you want.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0244-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Instead, you need to use the <code class="calibre20">*</code> operator (what we like to call the “value-at operator”) to get the value at the pointer.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0244-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">So you might think you’d need to use the <code class="calibre20">*</code> operator with pointers to structs as well. But just putting a <code class="calibre20">*</code> before the struct pointer won’t work:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0244-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If you write <code class="calibre20">*pointer.myField</code>, Go thinks that <code class="calibre20"><span class="calibre21">myField</span></code> must contain a pointer. It doesn’t, though, so an error results. To get this to work, you need to wrap <code class="calibre20">*pointer</code> in parentheses. That will cause the <code class="calibre20">myStruct</code> value to be retrieved, after which you can access the struct field.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0244-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Having to write <code class="calibre20">(*pointer).myField</code> all the time would get tedious quickly, though. For this reason, the dot operator lets you access fields via <em class="calibre9">pointers</em> to structs, just as you can access fields directly from struct values. You can leave off the parentheses and the <code class="calibre20">*</code> operator.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0245-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">This works for assigning to struct fields through a pointer as well:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0245-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">And that’s how the <code class="calibre20">applyDiscount</code> function is able to update the struct field without using the <code class="calibre20">*</code> operator. It assigns to the <code class="calibre20">rate</code> field <em class="calibre9">through</em> the struct pointer.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0245-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="there are no Dumb Questions" data-type="sect1" class="preface"><div class="preface" id="there_are_no_dumb_questions_4">
<h1 class="calibre25">there are no Dumb Questions</h1>
<p class="calibre7"><strong class="calibre8">Q: You showed a <code class="calibre40">defaultSubscriber</code> function before that set a struct’s fields, but it didn’t need to use any pointers! Why not?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> The <code class="calibre20">defaultSubscriber</code> function <em class="calibre9">returned</em> a struct value. If a caller stores the returned value, then the values in its fields will be preserved. Only functions that <em class="calibre9">modify existing</em> structs without returning them have to use pointers for those changes to be preserved.</p>
<p class="calibre7">But <code class="calibre20">defaultSubscriber</code> <em class="calibre9">could</em> have returned a pointer to a struct, if we had wanted it to. In fact, we make just that change in the next section!</p>
</div></section>
<section data-pdf-bookmark="Pass large structs using pointers" data-type="sect1" class="preface"><div class="preface" id="pass_large_structs_using_pointers">
<h1 class="calibre25">Pass large structs using pointers</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0246-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Yes, it will. It has to make room for the original struct <span class="calibre21">and</span> the copy.</strong></p>
<p class="calibre7"><a data-primary="arguments to functions" data-secondary="structs and" data-type="indexterm" id="idm46062711613016" class="calibre10"/><a data-primary="pointers and pointer types" data-secondary="passing large structs using" data-type="indexterm" id="idm46062711611272" class="calibre10"/><a data-primary="structs" data-secondary="passing using pointers" data-type="indexterm" id="idm46062711610200" class="calibre10"/>Functions receive a copy of the arguments they’re called with, even if they’re a big value like a struct.</p>
<p class="calibre7">That’s why, unless your struct has only a couple small fields, it’s often a good idea to pass functions a <em class="calibre9">pointer</em> to a struct, rather than the struct itself. (This is true even if the function doesn’t need to modify the struct.) When you pass a struct pointer, only one copy of the original struct exists in memory. The function just receives the memory address of that single struct, and can read the struct, modify it, or whatever else it needs to do, all without making an extra copy.</p>
<p class="calibre7">Here’s our <code class="calibre20">defaultSubscriber</code> function, updated to return a pointer, and our <code class="calibre20">printInfo</code> function, updated to receive a pointer. Neither of these functions needs to change an existing struct like <code class="calibre20">applyDiscount</code> does. But using pointers ensures that only one copy of each struct needs to be kept in memory, while still allowing the program to work as normal.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0246-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_14">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">The two programs below aren’t working quite right. The <code class="calibre20">nitroBoost</code> function in the lefthand program is supposed to add <code class="calibre20">50</code> kilometers/hour to a <code class="calibre20">car</code>’s top speed, but it’s not. And the <code class="calibre20">doublePack</code> function in the righthand program is supposed to double a <code class="calibre20">part</code> value’s <code class="calibre20">count</code> field, but it’s not, either.</p>
<p class="calibre7">See if you can fix the programs. Only minimal changes will be necessary; we’ve left a little extra space in the code so you can make the necessary updates.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0247-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#exercise_solution_14" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Moving our struct type to a different package" data-type="sect1" class="preface"><div class="preface" id="moving_our_struct_type_to_a_different_pa">
<h1 class="calibre25">Moving our struct type to a different package</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0248-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="packages" data-secondary="moving struct types to different" data-type="indexterm" id="idm46062711588968" class="calibre10"/><a data-primary="structs" data-secondary="moving types to different packages" data-type="indexterm" id="idm46062711587752" class="calibre10"/><a data-primary="struct types" data-secondary="moving to different packages" data-type="indexterm" id="idm46062711586712" class="calibre10"/><a data-primary="types" data-secondary="moving to different packages" data-type="indexterm" id="idm46062711585560" class="calibre10"/>That should be easy to do. Find the <em class="calibre9">headfirstgo</em> directory within your Go workspace, and create a new directory in there to hold a package named <code class="calibre20">magazine</code>. Within <em class="calibre9">magazine</em>, create a file named <em class="calibre9">magazine.go</em>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0248-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Be sure to add a <code class="calibre20">package magazine</code> declaration at the top of <em class="calibre9">magazine.go</em>. Then, copy the <code class="calibre20">subscriber</code> struct definition from your existing code and paste it into <em class="calibre9">magazine.go</em>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0248-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Next, let’s create a program to try out the new package. Since we’re just experimenting for now, let’s not create a separate package folder for this code; we’ll just run it using the <code class="calibre20">go run</code> command. Create a file named <em class="calibre9">main.go</em>. You can save it in any directory you want, but make sure you save it <em class="calibre9">outside</em> your Go workspace, so it doesn’t interfere with any other packages.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0248-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="calibre7">(You can move this code into your Go workspace later, if you want, as long as you create a separate package directory for it.)</p>
</div>
<p class="calibre7">Within <em class="calibre9">main.go</em>, save this code, which simply creates a new <code class="calibre20">subscriber</code> struct and accesses one of its fields.</p>
<p class="calibre7">There are two differences from the previous examples. First, we need to import the <code class="calibre20">magazine</code> package at the top of the file. Second, we need to use <code class="calibre20">magazine.subscriber</code> as the type name, since it belongs to another package now.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0248-05.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="A defined type’s name must be capitalized to be exported" data-type="sect1" class="preface"><div class="preface" id="a_defined_typersquos_name_must_be_capita">
<h1 class="calibre25">A defined type’s name must be capitalized to be exported</h1>
<p class="calibre7"><a data-primary="defined types" data-secondary="naming rules for" data-type="indexterm" id="idm46062711564616" class="calibre10"/><a data-primary="exporting from packages" data-secondary="defined types" data-type="indexterm" id="idm46062711563224" class="calibre10"/><a data-primary="exporting from packages" data-secondary="struct types" data-type="indexterm" id="idm46062711562104" class="calibre10"/><a data-primary="naming rules" data-secondary="defined types" data-type="indexterm" id="idm46062711560952" class="calibre10"/><a data-primary="naming rules" data-secondary="struct types" data-type="indexterm" id="idm46062711559816" class="calibre10"/><a data-primary="naming rules" data-secondary="types" data-type="indexterm" id="idm46062711558744" class="calibre10"/><a data-primary="packages" data-secondary="defined type names and" data-type="indexterm" id="idm46062711557608" class="calibre10"/><a data-primary="struct types" data-secondary="naming rules for" data-type="indexterm" id="idm46062711556536" class="calibre10"/><a data-primary="types" data-secondary="naming rules for" data-type="indexterm" id="idm46062711555400" class="calibre10"/><a data-primary="unexported fields" data-secondary="types and" data-type="indexterm" id="idm46062711554328" class="calibre10"/>Let’s see if our experimental code can still access the <code class="calibre20">subscriber</code> struct type in its new package. In your terminal, change into the directory where you saved <em class="calibre9">main.go</em>, then enter <code class="calibre20"><strong class="calibre39">go run main.go</strong></code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0249-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We get a couple errors, but here’s the important one: <code class="calibre20">cannot refer to unexported name magazine.subscriber</code>.</p>
<p class="calibre7">Go type names follow the same rule as variable and function names: if the name of a variable, function, or type begins with a capital letter, it is considered <em class="calibre9">exported</em> and can be accessed from outside the package it’s declared in. But our <code class="calibre20">subscriber</code> type name begins with a lowercase letter. That means it can only be used within the <code class="calibre20">magazine</code> package.</p>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">For a type to be accessed outside the package it’s defined in, it must be exported: its name must begin with a capital letter.</strong></p>
</blockquote>
<p class="calibre7">Well, that seems like an easy fix. We’ll just open our <em class="calibre9">magazine.go</em> file and capitalize the name of the defined type. Then, we’ll open <em class="calibre9">main.go</em> and capitalize the names of any references to that type. (There’s just one right now.)</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0249-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If we try running the updated code with <code class="calibre20">go run main.go</code>, we no longer get the error saying that the <code class="calibre20">magazine.subscriber</code> type is unexported. So that seems to be fixed. But we get a couple new errors in its place...</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0249-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Struct field names must be capitalized to be exported" data-type="sect1" class="preface"><div class="preface" id="struct_field_names_must_be">
<h1 class="calibre25">Struct field names must be capitalized to be exported</h1>
<p class="calibre7">With the <code class="calibre20">Subscriber</code> type name capitalized, we seem to be able to access it from the <code class="calibre20">main</code> package. But now we’re getting an error saying that we can’t refer to the <code class="calibre20">rate</code> <em class="calibre9">field</em>, because <em class="calibre9">that</em> is unexported.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0250-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Even if a struct type is exported from a package, its fields will be <em class="calibre9">unexported</em> if their names don’t begin with a capital letter. Let’s try capitalizing <code class="calibre20">Rate</code> (in both <em class="calibre9">magazine.go</em> and <em class="calibre9">main.go</em>)...</p>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">Struct field names must <span class="calibre21">also</span> be capitalized if you want to export them from their package.</strong></p>
</blockquote>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0250-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Run <em class="calibre9">main.go</em> again, and you’ll see that everything works this time. Now that they’re exported, we can access the <code class="calibre20">Subscriber</code> type <em class="calibre9">and</em> its <code class="calibre20">Rate</code> field from the <code class="calibre20">main</code> package.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0250-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Notice that the code worked even though the <code class="calibre20">name</code> and <code class="calibre20">active</code> fields were still unexported. You can have a mixture of exported and unexported fields within a single struct type, if you want.</p>
<p class="calibre7">That’s probably not advisable in the case of the <code class="calibre20">Subscriber</code> type, though. It wouldn’t make sense to be able to access the subscription rate from other packages, but not the name or address. So let’s go back into <em class="calibre9">magazine.go</em> and export the other fields as well. Simply capitalize their names: <code class="calibre20">Name</code> and <code class="calibre20">Active</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0250-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Struct literals" data-type="sect1" class="preface"><div class="preface" id="struct_literals">
<h1 class="calibre25">Struct literals</h1>
<p class="calibre7"><a data-primary="curly braces {}" data-secondary="structs and" data-type="indexterm" id="idm46062711514520" class="calibre10"/><a data-primary="literals" data-secondary="struct" data-type="indexterm" id="idm46062711513032" class="calibre10"/><a data-primary="map literals" data-type="indexterm" id="idm46062711511960" class="calibre10"/><a data-primary="short variable declaration (:=)" data-secondary="for structs" data-type="indexterm" id="idm46062711511096" class="calibre10"/><a data-primary="struct literals" data-type="indexterm" id="idm46062711510024" class="calibre10"/><a data-primary="structs" data-secondary="about" data-type="indexterm" id="idm46062711509192" class="calibre10"/><a data-primary="structs" data-secondary="zero value for" data-type="indexterm" id="idm46062711508056" class="calibre10"/><a data-primary="struct types" data-secondary="in struct literals" data-type="indexterm" id="idm46062711506984" class="calibre10"/><a data-primary="zero values" data-secondary="for structs" data-type="indexterm" id="idm46062711505848" class="calibre10"/>The code to define a struct and then assign values to its fields one by one can get a bit tedious:</p>
<pre data-type="programlisting" class="calibre32">var subscriber magazine.Subscriber
subscriber.Name = "Aman Singh"
subscriber.Rate = 4.99
subscriber.Active = true</pre>
<p class="calibre7">So, just as with slices and maps, Go offers <strong class="calibre8">struct literals</strong> to let you create a struct and set its fields at the same time.</p>
<p class="calibre7">The syntax looks similar to a map literal. The type is listed first, followed by curly braces. Within the braces, you can specify values for some or all of the struct fields, using the field name, a colon, and then the value. If you specify multiple fields, separate them with commas.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0251-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Above, we showed some code that creates a <code class="calibre20">Subscriber</code> struct and sets its fields, one by one. This code does the same thing in a single line, using a struct literal:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0251-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You may have noticed that for most of the chapter, we’ve had to use long-form declarations for struct variables (unless the struct was being returned from a function). Struct literals allow us to use short variable declarations for a struct we’ve just created.</p>
<p class="calibre7">You can omit some or even all of the fields from the curly braces. Omitted fields will be set to the zero value for their type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0251-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Pool Puzzle" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_7">
<h1 class="calibre25">Pool Puzzle</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0252-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Your <strong class="calibre8">job</strong> is to take code snippets from the pool and place them into the blank lines in this code. <strong class="calibre8">Don’t</strong> use the same snippet more than once, and you won’t need to use all the snippets. Your <strong class="calibre8">goal</strong> is to make a program that will run and produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0252-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0252-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Note: each snippet from the pool can only be used once!</strong></p>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#pool_puzzle_solution_5" class="calibre10">“Pool Puzzle Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="Creating an Employee struct type" data-type="sect1" class="preface"><div class="preface" id="creating_an_employee_struct_type">
<h1 class="calibre25">Creating an Employee struct type</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0253-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="struct types" data-secondary="creating" data-type="indexterm" id="idm46062711478344" class="calibre10"/>Adding an <code class="calibre20">Employee</code> struct type should be pretty easy. We’ll just add it to the <code class="calibre20">magazine</code> package, alongside the <code class="calibre20">Subscriber</code> type. In <em class="calibre9">magazine.go</em>, define a new <code class="calibre20">Employee</code> type, with a <code class="calibre20">struct</code> underlying type. Give the struct type a <code class="calibre20">Name</code> field with a type of <code class="calibre20">string</code>, and a <code class="calibre20">Salary</code> field with a type of <code class="calibre20">float64</code>. Be sure to capitalize the type name <em class="calibre9">and</em> all the fields, so that they’re exported from the <code class="calibre20">magazine</code> package.</p>
<p class="calibre7">We can update the <code class="calibre20">main</code> function in <em class="calibre9">main.go</em> to try the new type out. First, declare a variable with the type <code class="calibre20">magazine.Employee</code>. Then assign values of the appropriate type to each of the fields. Finally, print those values out.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0253-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If you execute <code class="calibre20">go run main.go</code> from your terminal, it should run, create a new <code class="calibre20">magazine.Employee</code> struct, set its field values, and then print those values out.</p>
</div></section>
<section data-pdf-bookmark="Creating an Address struct type" data-type="sect1" class="preface"><div class="preface" id="creating_an_address_struct_type">
<h1 class="calibre25">Creating an Address struct type</h1>
<p class="calibre7">Next, we need to track mailing addresses for both the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types. We’re going to need fields for the street address, city, state, and postal code (zip code).</p>
<p class="calibre7">We <em class="calibre9">could</em> add separate fields to both the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types, like this:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0254-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">But mailing addresses are going to have the same format, no matter what type they belong to. It’s a pain to have to repeat all those fields between multiple types.</p>
<p class="calibre7">Struct fields can hold values of any type, <em class="calibre9">including other structs</em>. So, instead, let’s try building an <code class="calibre20">Address</code> struct type, and then adding an <code class="calibre20">Address</code> field on the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types. That will save us some effort now, and ensure consistency between the types later if we have to change the address format.</p>
<p class="calibre7">We’ll create just the <code class="calibre20">Address</code> type first, so we can ensure it’s working correctly. Place it in the <code class="calibre20">magazine</code> package, alongside the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types. Then, replace the code in <em class="calibre9">main.go</em> with a few lines to create an <code class="calibre20">Address</code> and ensure its fields are accessible.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0254-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Type <code class="calibre20"><strong class="calibre39">go run main.go</strong></code> in your terminal, and it should create an <code class="calibre20">Address</code> struct, populate its fields, and then print the whole struct out.</p>
</div></section>
<section data-pdf-bookmark="Adding a struct as a field on another type" data-type="sect1" class="preface"><div class="preface" id="adding_a_struct_as_a_field_on_another_ty">
<h1 class="calibre25">Adding a struct as a field on another type</h1>
<p class="calibre7"><a data-primary="structs" data-secondary="setting up within other structs" data-type="indexterm" id="idm46062711447880" class="calibre10"/><a data-primary="struct types" data-secondary="adding fields to" data-type="indexterm" id="idm46062711446488" class="calibre10"/>Now that we’re sure the <code class="calibre20">Address</code> struct type works by itself, let’s add <code class="calibre20">HomeAddress</code> fields to the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types.</p>
<p class="calibre7">Adding a struct field that is itself a struct type is no different than adding a field of any other type. You provide a name for the field, followed by the field’s type (which in this case will be a struct type).</p>
<p class="calibre7">Add a field named <code class="calibre20">HomeAddress</code> to the <code class="calibre20">Subscriber</code> struct. Make sure to capitalize the field name, so that it’s accessible from outside the <code class="calibre20">magazine</code> package. Then specify the field type, which is <code class="calibre20">Address</code>.</p>
<p class="calibre7">Add a <code class="calibre20">HomeAddress</code> field to the <code class="calibre20">Employee</code> type as well.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0255-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Setting up a struct within another struct" data-type="sect1" class="preface"><div class="preface" id="setting_up_a_struct_within_another_struc">
<h1 class="calibre25">Setting up a struct within another struct</h1>
<p class="calibre7">Now let’s see if we can populate the fields of the <code class="calibre20">Address</code> struct <em class="calibre9">within</em> the <code class="calibre20">Subscriber</code> struct. There are a couple ways to go about this.</p>
<p class="calibre7">The first approach is to create an entirely separate <code class="calibre20">Address</code> struct and then use it to set the entire <code class="calibre20">Address</code> field of the <code class="calibre20">Subscriber</code> struct. Here’s an update to <em class="calibre9">main.go</em> that follows this approach.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0255-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Type <code class="calibre20"><strong class="calibre39">go run main.go</strong></code> in your terminal, and you’ll see the subscriber’s <code class="calibre20">HomeAddress</code> field has been set to the struct you built.</p>
<p class="calibre7"><a data-primary="dot operator (.)" data-secondary="chaining together" data-type="indexterm" id="idm46062711428296" class="calibre10"/>Another approach is to set the fields of the inner struct <em class="calibre9">through</em> the outer struct.</p>
<p class="calibre7">When a <code class="calibre20">Subscriber</code> struct is created, its <code class="calibre20">HomeAddress</code> field is already set: it’s an <code class="calibre20">Address</code> struct with all its fields set to their zero values. If we print <code class="calibre20">HomeAddress</code> using the <code class="calibre20">"%#v"</code> verb for <code class="calibre20">fmt.Printf</code>, it will print the struct as it would appear in Go code — that is, as a struct literal. We’ll see that each of the <code class="calibre20">Address</code> fields is set to an empty string, which is the zero value for the <code class="calibre20">string</code> type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0256-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If <code class="calibre20">subscriber</code> is a variable that contains a <code class="calibre20">Subscriber</code> struct, then when you type <code class="calibre20">subscriber.HomeAddress</code>, you’ll get an <code class="calibre20">Address</code> struct, even if you haven’t explicitly set <code class="calibre20">HomeAddress</code>.</p>
<p class="calibre7">You can use this fact to “chain” dot operators together so you can access the fields of the <code class="calibre20">Address</code> struct. Simply type <code class="calibre20"><strong class="calibre39">subscriber.HomeAddress</strong></code> to access the <code class="calibre20">Address</code> struct, followed by <em class="calibre9">another</em> dot operator and the name of the field you want to access on that <code class="calibre20">Address</code> struct.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0256-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">This works both for assigning values to the inner struct’s fields...</p>
<pre data-type="programlisting" class="calibre32">subscriber.HomeAddress.PostalCode = "68111"</pre>
<p class="calibre7">...and for retrieving those values again later.</p>
<pre data-type="programlisting" class="calibre32">fmt.Println("Postal Code:", subscriber.HomeAddress.PostalCode)</pre>
<p class="calibre7">Here’s an update to <em class="calibre9">main.go</em> that uses dot operator chaining. First we store a <code class="calibre20">Subscriber</code> struct in the <code class="calibre20">subscriber</code> variable. That will automatically create an <code class="calibre20">Address</code> struct in <code class="calibre20">subscriber</code>’s <code class="calibre20">HomeAddress</code> field. We set values for <code class="calibre20">subscriber.HomeAddress.Street</code>, <code class="calibre20">subscriber.HomeAddress.City</code>, and so on, and then print those values out again.</p>
<p class="calibre7">Then we store an <code class="calibre20">Employee</code> struct in the <code class="calibre20">employee</code> variable, and do the same for its <code class="calibre20">HomeAddress</code> struct.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0257-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Type <code class="calibre20"><strong class="calibre39">go run main.go</strong></code> in your terminal, and the program will print out the completed fields of both <code class="calibre20">subscriber.HomeAddress</code> and <code class="calibre20">employee.HomeAddress</code>.</p>
</div></section>
<section data-pdf-bookmark="Anonymous struct fields" data-type="sect1" class="preface"><div class="preface" id="anonymous_struct_fields">
<h1 class="calibre25">Anonymous struct fields</h1>
<p class="calibre7"><a data-primary="anonymous struct fields" data-type="indexterm" id="idm46062711398280" class="calibre10"/><a data-primary="embedding" data-secondary="struct types and" data-type="indexterm" id="idm46062711397032" class="calibre10"/><a data-primary="structs" data-secondary="anonymous fields" data-type="indexterm" id="idm46062711395944" class="calibre10"/><a data-primary="structs" data-secondary="embedding" data-type="indexterm" id="idm46062711394808" class="calibre10"/><a data-primary="struct types" data-secondary="embedding" data-type="indexterm" id="idm46062711393704" class="calibre10"/>The code to access the fields of an inner struct through its outer struct can be a bit tedious, though. You have to write the field name of the inner struct (<code class="calibre20">HomeAddress</code>) each time you want to access any of the fields it contains.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0258-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Go allows you to define <strong class="calibre8">anonymous fields</strong>: struct fields that have no name of their own, just a type. We can use an anonymous field to make our inner struct easier to access.</p>
<p class="calibre7">Here’s an update to the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> types to convert their <code class="calibre20">HomeAddress</code> fields to an anonymous field. To do this, we simply remove the field name, leaving only the type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0258-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">When you declare an anonymous field, you can use the field’s type name as if it were the name of the field. So <code class="calibre20">subscriber.Address</code> and <code class="calibre20">employee.Address</code> in the code below still access the <code class="calibre20">Address</code> structs:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0258-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Embedding structs" data-type="sect1" class="preface"><div class="preface" id="embedding_structs">
<h1 class="calibre25">Embedding structs</h1>
<p class="calibre7">But anonymous fields offer much more than just the ability to skip providing a name for a field in a struct definition.</p>
<p class="calibre7">An inner struct that is stored within an outer struct using an anonymous field is said to be <strong class="calibre8">embedded</strong> within the outer struct. Fields for an embedded struct are <strong class="calibre8">promoted</strong> to the outer struct, meaning you can access them as if they belong to the outer struct.</p>
<p class="calibre7">So now that the <code class="calibre20">Address</code> struct type is embedded within the <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> struct types, you don’t have to write out <code class="calibre20">subscriber.Address.City</code> to get at the <code class="calibre20">City</code> field; you can just write <code class="calibre20">subscriber.City</code>. You don’t need to write <code class="calibre20">employee.Address.State</code>; you can just write <code class="calibre20">employee.State</code>.</p>
<p class="calibre7">Here’s one last version of <em class="calibre9">main.go</em>, updated to treat <code class="calibre20">Address</code> as an embedded type. You can write the code as if there were no <code class="calibre20">Address</code> type at all; it’s like the <code class="calibre20">Address</code> fields belong to the struct type they’re embedded within.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0259-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Keep in mind that you don’t <em class="calibre9">have</em> to embed inner structs. You don’t have to use inner structs at all. Sometimes adding new fields on the outer struct leads to the clearest code. Consider your current situation, and go with the solution that works best for you and your users.</p>
</div></section>
<section data-pdf-bookmark="Our defined types are complete!" data-type="sect1" class="preface"><div class="preface" id="our_defined_types_are_completeexcl">
<h1 class="calibre25">Our defined types are complete!</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0260-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Nice work! You’ve defined <code class="calibre20">Subscriber</code> and <code class="calibre20">Employee</code> struct types, and embedded an <code class="calibre20">Address</code> struct in each of them. You’ve found a way to represent all the data the magazine needed!</p>
<p class="calibre7">You’re still missing an important aspect to defined types, though. In previous chapters, you’ve used types like <code class="calibre20">time.Time</code> and <code class="calibre20">strings.Replacer</code> that have <em class="calibre9">methods</em>: functions that you can call <em class="calibre9">on</em> their values. But you haven’t learned how to define methods for your own types yet. Don’t worry; we’ll learn all about it in the next chapter!</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_15">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">Here’s a source file from the <code class="calibre20">geo</code> package, which we saw in a previous exercise. Your goal is to make the code in <em class="calibre9">main.go</em> work correctly. But here’s the catch: you need to do it by adding just <em class="calibre9">two</em> fields to the <code class="calibre20">Landmark</code> struct type within <em class="calibre9">geo.go</em>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0260-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#exercise_solution_15" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Your Go Toolbox" data-type="sect1" class="preface"><div class="preface" id="your_go_toolbox_8">
<h1 class="calibre25">Your Go Toolbox</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0261-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">That’s it for <a data-type="xref" href="#building_storagecolon_structs" class="calibre10">Chapter 8</a>! You’ve added structs and defined types to your toolbox.</strong></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0261-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="bullet_points_8">
<h5 class="calibre31">Bullet Points</h5>
<ul class="list_style_type_none">
<li class="calibre18"><p class="calibre7">You can declare a variable with a struct type. To specify a struct type, use the <code class="calibre20">struct</code> keyword, followed by a list of field names and types within curly braces.</p>
<pre data-type="programlisting" class="calibre32">var myStruct struct {
   field1 string
   field2 int
}</pre>
</li>
<li class="calibre18"><p class="calibre7">Writing struct types repeatedly can get tedious, so it’s usually best to define a type with an underlying struct type. Then the defined type can be used for variables, function parameters or return values, and so on.</p>
<pre data-type="programlisting" class="calibre32">type myType struct {
   field1 string
}
var myVar myType</pre>
</li>
<li class="calibre18"><p class="calibre7">Struct fields are accessed via the dot operator.</p>
<pre data-type="programlisting" class="calibre32">myVar.field1 = "value"
fmt.Println(myVar.field1)</pre></li>
<li class="calibre18"><p class="calibre7">If a function needs to modify a struct or if a struct is large, it should be passed to the function as a pointer.</p></li>
<li class="calibre18"><p class="calibre7">Types will only be exported from the package they’re defined in if their name begins with a capital letter.</p></li>
<li class="calibre18"><p class="calibre7">Likewise, struct fields will not be accessible outside their package unless their name is capitalized.</p></li>
<li class="calibre18"><p class="calibre7">Struct literals let you create a struct and set its fields at the same time.</p>
<pre data-type="programlisting" class="calibre32">myVar := myType{field1: "value"}</pre></li>
<li class="calibre18"><p class="calibre7">Adding a struct field with no name, only a type, defines an anonymous field.</p></li>
<li class="calibre18"><p class="calibre7">An inner struct that is added as part of an outer struct using an anonymous field is said to be <strong class="calibre8">embedded</strong> within the outer struct.</p></li>
<li class="calibre18"><p class="calibre7">You can access the fields of an embedded struct as if they belong to the outer struct.</p></li>
</ul>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_13">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">At the right is a program that creates a struct variable to hold a pet’s name (a <code class="calibre20">string</code>) and age (an <code class="calibre20">int</code>). Fill in the blanks so that the code will produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0262-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Code Magnets Solution" data-type="sect1" class="preface"><div class="preface" id="code_magnets_solution_6">
<h1 class="calibre25">Code Magnets Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0262-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_14">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">The two programs below weren’t working quite right. The <code class="calibre20">nitroBoost</code> function in the lefthand program was supposed to add <code class="calibre20">50</code> kilometers/hour to a <code class="calibre20">car</code>’s top speed, but it wasn’t. And the <code class="calibre20">doublePack</code> function in the righthand program was supposed to double a <code class="calibre20">part</code> value’s <code class="calibre20">count</code> field, but it wasn’t, either.</p>
<p class="calibre7">Fixing both programs was simply a matter of updating the functions to accept pointers, and updating the function calls to pass pointers. The code within the functions that updates the struct fields doesn’t need to be changed; the code to access a field through a pointer to a struct is the same as the code to access a field on the struct directly.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0263-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Pool Puzzle Solution" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_solution_5">
<h1 class="calibre25">Pool Puzzle Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0264-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_15">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">The <em class="calibre9">geo.go</em> source file is from the <code class="calibre20">geo</code> package, which we saw in a previous exercise. Your goal was to make the code in <em class="calibre9">main.go</em> work correctly, by adding just <em class="calibre9">two</em> fields to the <code class="calibre20">Landmark</code> struct type within <em class="calibre9">geo.go</em>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0264-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
</div></section></body></html>