- en: Chapter 5\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。函数
- en: So far, your programs have been limited to a few lines in the `main` function.
    It’s time to get bigger. In this chapter, you’re going to learn how to write functions
    in Go and see all the interesting things you can do with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的程序在`main`函数中被限制在几行代码中。现在是时候扩展一下了。在本章中，你将学习如何在Go语言中编写函数，并看到你可以用它们做的所有有趣的事情。
- en: Declaring and Calling Functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和调用函数
- en: The basics of Go functions are familiar to anyone who has programmed in other
    languages with first-class functions, like C, Python, Ruby, or JavaScript. (Go
    also has methods, which I’ll cover in [Chapter 7](ch07.html#unique_chapter_id_07).)
    Just as with control structures, Go adds its own twist on function features. Some
    are improvements, and others are experiments that should be avoided. I’ll cover
    both in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数的基础对于任何已经在其他具有一级函数的语言（如C、Python、Ruby或JavaScript）中编程过的人来说都是熟悉的。（Go也有方法，我会在[第7章](ch07.html#unique_chapter_id_07)中讨论。）就像控制结构一样，Go在函数特性上添加了自己的风格。有些是改进，而其他一些则是应该避免的实验。我会在本章中都覆盖到。
- en: 'You’ve already seen functions being declared and used. Every Go program starts
    from a `main` function, and you’ve been calling the `fmt.Println` function to
    print to the screen. Since a `main` function doesn’t take in parameters or return
    values, let’s see what it looks like when a function does:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了函数的声明和使用。每个Go程序都从一个`main`函数开始，并且你一直在调用`fmt.Println`函数来打印到屏幕上。由于`main`函数不接受参数或返回值，让我们看看当一个函数有参数时会是什么样子：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s look at all the new things in this code sample. A function declaration
    has four parts: the keyword `func`, the name of the function, the input parameters,
    and the return type. The input parameters are listed in parentheses, separated
    by commas, with the parameter name first and the type second. Go is a typed language,
    so you must specify the types of the parameters. The return type is written between
    the input parameter’s closing parenthesis and the opening brace for the function
    body.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码样本中的所有新内容。函数声明由四部分组成：关键字`func`、函数名称、输入参数和返回类型。输入参数在括号内列出，用逗号分隔，参数名在前，类型在后。Go是一种类型化语言，因此必须指定参数的类型。返回类型写在输入参数的右括号和函数体的左大括号之间。
- en: Just like other languages, Go has a `return` keyword for returning values from
    a function. If a function returns a value, you *must* supply a `return`. If a
    function returns nothing, a `return` statement is not needed at the end of the
    function. The `return` keyword is needed in a function that returns nothing only
    if you are exiting from the function before the last line.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他语言一样，Go语言有一个`return`关键字用于从函数中返回值。如果一个函数返回一个值，你*必须*提供一个`return`。如果一个函数不返回任何东西，则不需要在函数末尾写上`return`语句。只有在你在函数的最后一行之前退出函数时，才需要`return`关键字。
- en: 'The `main` function has no input parameters or return values. When a function
    has no input parameters, use empty parentheses (`()`). When a function returns
    nothing, you write nothing between the input parameter’s closing parenthesis and
    the opening brace for the function body:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数没有输入参数或返回值。当一个函数没有输入参数时，使用空括号（`()`）。当一个函数不返回任何东西时，在输入参数的右括号和函数体的左大括号之间什么也不写：'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for this simple program is in the *sample_code/simple_div* directory
    in the [Chapter 5 repository](https://oreil.ly/EzU8N).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单程序的代码在[第5章仓库](https://oreil.ly/EzU8N)的*sample_code/simple_div*目录中。
- en: Calling a function should be familiar to experienced developers. On the right
    side of the `:=`, you call the `div` function with the values 5 and 2\. On the
    left side, you assign the returned value to the variable `result`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数对于有经验的开发者来说应该是很熟悉的。在`:=`的右侧，你用值5和2调用`div`函数。在左侧，你将返回的值赋给变量`result`。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'When you have two or more consecutive input parameters of the same type, you
    can specify the type once for all of them like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个或更多连续的相同类型的输入参数时，你可以像这样一次性指定类型：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Simulating Named and Optional Parameters
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟命名和可选参数
- en: 'Before getting to the unique function features that Go has, I’ll mention two
    that Go *doesn’t* have: named and optional input parameters. With one exception
    that I will cover in the next section, you must supply all the parameters for
    a function. If you want to emulate named and optional parameters, define a struct
    that has fields that match the desired parameters, and pass the struct to your
    function. [Example 5-1](#EX5_1) shows a snippet of code that demonstrates this
    pattern.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 Go 的独特函数特性之前，我将提到 Go *没有*的两个功能：命名和可选输入参数。除了下一节将要讲解的一个例外，你必须为函数提供所有参数。如果你想模仿命名和可选参数，定义一个结构体，其中包含与所需参数匹配的字段，并将结构体传递给函数。[示例 5-1](#EX5_1)
    展示了演示此模式的代码片段。
- en: Example 5-1\. Using a struct to simulate named parameters
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 使用结构体模拟命名参数
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code for this program is in the *sample_code/named_optional_parameters*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序的代码位于 *sample_code/named_optional_parameters* 目录中的 [第 5 章存储库](https://oreil.ly/EzU8N)。
- en: In practice, not having named and optional parameters isn’t a limitation. A
    function shouldn’t have more than a few parameters, and named and optional parameters
    are mostly useful when a function has many inputs. If you find yourself in that
    situation, your function is quite possibly too complicated.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，没有命名和可选参数并不是限制。一个函数不应该有太多参数，并且当函数有很多输入时，命名和可选参数才有用。如果你发现自己处于这种情况中，你的函数可能太复杂了。
- en: Variadic Input Parameters and Slices
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变参输入参数和切片
- en: 'You’ve been using `fmt.Println` to print results to the screen and you’ve probably
    noticed that it allows any number of input parameters. How does it do that? Like
    many languages, Go supports *variadic parameters*. The variadic parameter *must*
    be the last (or only) parameter in the input parameter list. You indicate it with
    three dots (`...`) *before* the type. The variable that’s created within the function
    is a slice of the specified type. You use it just like any other slice. Let’s
    see how they work by writing a program that adds a base number to a variable number
    of parameters and returns the result as a slice of `int`. You can run this program
    on [The Go Playground](https://oreil.ly/nSad4) or in the *sample_code/variadic*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N). First, write
    the variadic function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在使用 `fmt.Println` 将结果打印到屏幕上，你可能已经注意到它允许任意数量的输入参数。它是如何做到的呢？与许多语言一样，Go 支持*变参参数*。变参参数*必须*是输入参数列表中的最后一个（或仅有的）参数。你用三个点（`...`）*在*类型前指示它。在函数内部创建的变量是指定类型的切片。你可以像使用任何其他切片一样使用它。我们通过编写一个程序来看看它们是如何工作的，该程序将一个基础数添加到可变数量的参数中，并将结果作为
    `int` 类型的切片返回。你可以在 [The Go Playground](https://oreil.ly/nSad4) 或 [第 5 章存储库](https://oreil.ly/EzU8N)
    的 *sample_code/variadic* 目录中运行此程序。首先，编写变参函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now call it in a few ways:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以几种方式调用它：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, you can supply however many values you want for the variadic
    parameter or no values at all. Since the variadic parameter is converted to a
    slice, you can supply a slice as the input. However, you must put three dots (`...`)
    *after* the variable or slice literal. If you do not, it is a compile-time error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以为变参参数提供任意多的值，也可以完全不提供值。由于变参参数被转换为切片，因此你可以将切片作为输入。然而，你必须在变量或切片文字后面加上三个点（`...`）。如果不这样做，将导致编译时错误。
- en: 'When you build and run this program, you get this output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建并运行此程序时，会得到以下输出：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Multiple Return Values
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多返回值
- en: 'The first difference that you’ll see between Go and other languages is that
    Go allows for multiple return values. Let’s add a small feature to the previous
    division program. You’re going to return both the dividend and the remainder from
    the function. Here’s the updated function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 Go 和其他语言之间的第一个区别是 Go 允许多返回值。让我们向前面的除法程序添加一个小功能。你将从函数中返回被除数和余数。下面是更新后的函数：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are a few changes to support multiple return values. When a Go function
    returns multiple values, the types of the return values are listed in parentheses,
    separated by commas. Also, if a function returns multiple values, you must return
    all of them, separated by commas. Don’t put parentheses around the returned values;
    that’s a compile-time error.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多返回值的几个更改。当一个 Go 函数返回多个值时，返回值的类型将以逗号分隔放在括号内。此外，如果一个函数返回多个值，你必须用逗号分隔它们全部返回。不要在返回值周围加括号；这会导致编译时错误。
- en: 'There’s something else that you haven’t seen yet: creating and returning an
    `error`. If you want to learn more about errors, skip ahead to [Chapter 9](ch09.html#unique_chapter_id_09).
    For now, you need to know only that you use Go’s multiple return value support
    to return an `error` if something goes wrong in a function. If the function completes
    successfully, you return `nil` for the error’s value. By convention, the `error`
    is always the last (or only) value returned from a function.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些您尚未看到的内容：创建并返回`error`。如果您想了解更多关于错误的信息，请跳转到[第9章](ch09.html#unique_chapter_id_09)。目前，您只需知道可以使用Go的多返回值支持在函数出现问题时返回一个`error`。如果函数成功完成，将为错误的值返回`nil`。按照惯例，`error`始终是函数返回的最后一个（或唯一的）值。
- en: 'Calling the updated function looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调用更新后的函数如下：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code for this program is in the *sample_code/updated_div* directory in the
    [Chapter 5 repository](https://oreil.ly/EzU8N).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的代码位于[第5章存储库](https://oreil.ly/EzU8N)中的*sample_code/updated_div*目录中。
- en: I talked about assigning multiple values at once in [“var Versus :=”](ch02.html#var_declarations).
    Here you are using that feature to assign the results of a function call to three
    variables. On the right side of the `:=`, you call the `divAndRemainder` function
    with the values 5 and 2\. On the left side, you assign the returned values to
    the variables `result`, `remainder`, and `err`. You check to see if there was
    an error by comparing `err` to `nil`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“var Versus :=”](ch02.html#var_declarations)中讨论了一次性分配多个值的问题。在这里，您正在使用该功能将函数调用的结果分配给三个变量。在`:=`的右侧，您使用值5和2调用`divAndRemainder`函数。在左侧，您将返回的值分配给变量`result`、`remainder`和`err`。通过将`err`与`nil`进行比较来检查是否发生了错误。
- en: Multiple Return Values Are Multiple Values
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多返回值是多个值
- en: If you are familiar with Python, you might think that multiple return values
    are like Python functions returning a tuple that’s optionally destructured if
    the tuple’s values are assigned to multiple variables. [Example 5-2](#EX5_2) shows
    some sample code run in the Python interpreter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Python，可能会认为多返回值与Python函数返回的元组类似，如果将元组的值分配给多个变量，则可以选择进行解构。[示例5-2](#EX5_2)展示了在Python解释器中运行的一些示例代码。
- en: Example 5-2\. Multiple return values in Python are destructured tuples
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-2\. Python中的多返回值是解构的元组
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Python, you can assign all the values returned to a single variable or to
    multiple variables. That’s not how Go works. You must assign each value returned
    from a function. If you try to assign multiple return values to one variable,
    you get a compile-time error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以将所有返回的值分配给单个变量或多个变量。但是，Go不是这样工作的。您必须为函数返回的每个值分配一个变量。如果尝试将多个返回值分配给一个变量，则会收到编译时错误。
- en: Ignoring Returned Values
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略返回值
- en: What if you call a function and don’t want to use all the returned values? As
    covered in [“Unused Variables”](ch02.html#unused_vars_section), Go does not allow
    unused variables. If a function returns multiple values, but you don’t need to
    read one or more of the values, assign the unused values to the name `_`. For
    example, if you weren’t going to read `remainder`, you would write the assignment
    as `result, _, err :=` `divAndRemainder(5, 2)`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用函数时不想使用所有返回的值怎么办？正如[“Unused Variables”](ch02.html#unused_vars_section)中所述，Go不允许未使用的变量。如果函数返回多个值，但您不需要读取一个或多个值，则将未使用的值分配给名称`_`。例如，如果您不打算读取`remainder`，则可以将赋值写为`result,
    _, err := divAndRemainder(5, 2)`。
- en: 'Surprisingly, Go does let you implicitly ignore *all* of the return values
    for a function. You can write `divAndRemainder(5,2)`, and the returned values
    are dropped. You have actually been doing this since the earliest examples: `fmt.Println`
    returns two values, but it is idiomatic to ignore them. In almost all other cases,
    you should make it explicit that you are ignoring return values by using underscores.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，Go确实允许您隐式地忽略*所有*函数的返回值。您可以写`divAndRemainder(5,2)`，返回的值会被丢弃。实际上，自最早的示例以来，您一直在这样做：`fmt.Println`返回两个值，但习惯上会忽略它们。在几乎所有其他情况下，您应该明确地使用下划线来表示您正在忽略返回值。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use `_` whenever you don’t need to read a value that’s returned by a function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不需要读取函数返回的值时，请使用`_`。
- en: Named Return Values
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名返回值
- en: 'In addition to letting you return more than one value from a function, Go allows
    you to specify *names* for your return values. Rewrite the `divAndRemainder` function
    one more time, this time using named return values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许从函数返回多个值外，Go还允许为返回的值指定*名称*。再次重写`divAndRemainder`函数，这次使用命名返回值：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you supply names to your return values, what you are doing is predeclaring
    variables that you use within the function to hold the return values. They are
    written as a comma-separated list within parentheses. *You must surround named
    return values with parentheses, even if there is only a single return value*.
    Named return values are initialized to their zero values when created. This means
    that you can return them before any explicit use or assignment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为返回值提供名称时，你所做的是预先声明在函数中用于保存返回值的变量。它们被写成括号内的逗号分隔列表。*即使只有单个返回值，你也必须用括号括起命名的返回值*。命名返回值在创建时被初始化为它们的零值。这意味着你可以在任何显式使用或分配之前返回它们。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to name only *some* of the return values, you can do so by using
    `_` as the name for any return values you want to remain nameless.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想为*一些*返回值命名，可以使用`_`作为任何你希望匿名的返回值的名称。
- en: 'One important thing to note: the name that’s used for a named returned value
    is local to the function; it doesn’t enforce any name outside of the function.
    It is perfectly legal to assign the return values to variables of different names:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：用于命名返回值的名称仅在函数内部有效；它不会强制外部使用任何名称。将返回值分配给不同名称的变量是完全合法的：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While named return values can sometimes help clarify your code, they do have
    some potential corner cases. First is the problem of shadowing. Just as with any
    other variable, you can shadow a named return value. Be sure that you are assigning
    to the return value and not to a shadow of it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命名返回值有时可以帮助澄清代码，但它们确实存在一些潜在的特例情况。首先是阴影问题。与任何其他变量一样，你可以遮蔽一个命名返回值。确保你正在将值分配给返回值而不是其阴影。
- en: 'The other problem with named return values is that you don’t have to return
    them. Let’s take a look at another variation on `divAndRemainder`. You can run
    it on [The Go Playground](https://oreil.ly/FzUkw) or in the `divAndRemainderConfusing`
    function in *main.go* in the *sample_code/named_div* directory in the [Chapter
    5 repository](https://oreil.ly/EzU8N):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名返回值的另一个问题是你不一定要返回它们。让我们看看`divAndRemainder`的另一个变体。你可以在[The Go Playground](https://oreil.ly/FzUkw)上运行它，或者在[第5章存储库](https://oreil.ly/EzU8N)的*sample_code/named_div*目录中的*main.go*中的`divAndRemainderConfusing`函数中运行它：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that you assigned values to `result` and `remainder` and then returned
    different values directly. Before running this code, try to guess what happens
    when 5 and 2 are passed to this function. The result might surprise you:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你分配了`result`和`remainder`的值，然后直接返回了不同的值。在运行这段代码之前，试着猜测当传递5和2到这个函数时会发生什么。结果可能会让你惊讶：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The values from the `return` statement were returned even though they were never
    assigned to the named return parameters. That’s because the Go compiler inserts
    code that assigns whatever is returned to the return parameters. The named return
    parameters give a way to declare an *intent* to use variables to hold the return
    values, but don’t *require* you to use them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从`return`语句返回的值从未分配给命名返回参数，它们也会被返回。这是因为Go编译器插入了将返回的任何内容分配给返回参数的代码。命名返回参数提供了一种声明*意图*使用变量来保存返回值的方法，但不*要求*你使用它们。
- en: Some developers like to use named return parameters because they provide additional
    documentation. However, I find them of limited value. Shadowing makes them confusing,
    as does simply ignoring them. Named return parameters are essential in one situation.
    I will talk about that when I cover `defer` later in the chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员喜欢使用命名返回参数，因为它们提供了额外的文档。然而，我发现它们的价值有限。阴影使它们变得混乱，忽略它们也一样。命名返回参数在一个情况下是必不可少的。我将在本章稍后讨论`defer`时谈到这一点。
- en: Blank Returns—Never Use These!
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白返回——永远不要使用这些！
- en: 'If you use named return values, you need to be aware of one severe misfeature
    in Go: blank (sometimes called *naked*) returns. If you have named return values,
    you can just write `return` without specifying the values that are returned. This
    returns the last values assigned to the named return values. Rewrite the `divAndRemainder`
    function one last time, this time using blank returns:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用命名返回值，你需要注意Go语言中一个严重的设计缺陷：空白（有时称为*naked*）返回。如果你有命名的返回值，你可以只写`return`而不指定返回的值。这将返回分配给命名返回值的最后值。最后一次，用空白返回重写`divAndRemainder`函数：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using blank returns makes a few additional changes to the function. When there’s
    invalid input, the function returns immediately. Since no values were assigned
    to `result` and `remainder`, their zero values are returned. If you are returning
    the zero values for your named return values, be sure they make sense. Also note
    that you still have to put a `return` at the end of the function. Even though
    the function is using blank returns, this function returns values. Leaving out
    `return` is a compile-time error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空返回会对函数做一些额外的更改。当输入无效时，函数会立即返回。由于未给`result`和`remainder`赋值，它们的零值会被返回。如果您正在返回命名返回值的零值，请确保它们是有意义的。还要注意，您仍然必须在函数末尾放置一个`return`。即使函数使用空返回，该函数也会返回值。省略`return`将导致编译时错误。
- en: At first, you might find blank returns handy since they allow you to avoid some
    typing. However, most experienced Go developers consider blank returns a bad idea
    because they make it harder to understand data flow. Good software is clear and
    readable; it’s obvious what is happening. When you use a blank return, the reader
    of your code needs to scan back through the program to find the last value assigned
    to the return parameters to see what is actually being returned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，您可能会发现空返回很方便，因为它们允许您避免一些输入。然而，大多数经验丰富的Go开发人员认为空返回是一个坏主意，因为它们会使数据流变得更难理解。优秀的软件应该清晰易读；它的运行过程应该是显而易见的。当您使用空返回时，代码的读者需要通过程序回溯查找最后一次给返回参数赋值的值，才能看到实际返回的内容。
- en: Warning
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If your function returns values, *never* use a blank return. It can make it
    very confusing to figure out what value is actually returned.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数返回值，*永远不要*使用空返回。这会让弄清楚实际返回的值变得非常混乱。
- en: Functions Are Values
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是值
- en: Just as in many other languages, functions in Go are values. The type of a function
    is built out of the keyword `func` and the types of the parameters and return
    values. This combination is called the *signature* of the function. Any function
    that has the exact same number and types of parameters and return values meets
    the type signature.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在许多其他语言中一样，Go语言中的函数也是值。函数的类型由关键字`func`、参数类型和返回值类型组成。这种组合称为函数的*签名*。具有完全相同数量和类型的参数和返回值的任何函数都符合该类型的签名。
- en: 'Since functions are values, you can declare a function variable:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是值，因此可以声明一个函数变量：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`myFuncVariable` can be assigned any function that has a single parameter of
    type `string` and returns a single value of type `int`. Here’s a longer example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`myFuncVariable`可以被分配任何具有单一`string`类型参数和单一`int`类型返回值的函数。以下是一个更长的示例：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can run this program on [The Go Playground](https://oreil.ly/lPj9X) or
    in the *sample_code/func_value* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
    The output is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[The Go Playground](https://oreil.ly/lPj9X)或[第5章代码库的sample_code/func_value目录](https://oreil.ly/EzU8N)上运行此程序。输出结果为：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default zero value for a function variable is `nil`. Attempting to run a
    function variable with a `nil` value results in a panic (which is covered in [“panic
    and recover”](ch09.html#panic_recover)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数变量的默认零值为`nil`。尝试使用具有`nil`值的函数变量会导致恐慌（这在[“panic和recover”](ch09.html#panic_recover)中有涵盖）。
- en: 'Having functions as values allows you to do some clever things, such as build
    a simple calculator using functions as values in a map. Let’s see how this works.
    The following code is available on [The Go Playground](https://oreil.ly/L59VY)
    or in the *sample_code/calculator* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
    First, create a set of functions that all have the same signature:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为值可以让您做一些聪明的事情，例如使用函数作为映射中的值来构建一个简单的计算器。让我们看看这是如何工作的。以下代码可在[The Go Playground](https://oreil.ly/L59VY)或[第5章代码库的sample_code/calculator目录](https://oreil.ly/EzU8N)中找到。首先，创建一组具有相同签名的函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a map to associate a math operator with each function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个映射，将数学运算符与每个函数关联起来：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, try out the calculator with a few expressions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试使用几个表达式来测试计算器：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’re using the `strconv.Atoi` function in the standard library to convert
    a `string` to an `int`. The second value returned by this function is an `error`.
    Just as before, you check for errors that are returned by functions and handle
    error conditions properly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库中的`strconv.Atoi`函数将`string`转换为`int`时，第二个返回值是`error`。和以往一样，您需要检查函数返回的错误并正确处理错误条件。
- en: You use `op` as the key to the `opMap` map, and assign the value associated
    with the key to the variable `opFunc`. The type of `opFunc` is `func(int, int)
    int`. If there wasn’t a function in the map associated with the provided key,
    you print an error message and skip the rest of the loop. You then call the function
    assigned to the `opFunc` variable with the `p1` and `p2` variables that you decoded
    earlier. Calling a function in a variable looks just like calling a function directly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`op`作为`opMap`映射中的键，并将与该键关联的值分配给变量`opFunc`。`opFunc`的类型是`func(int, int) int`。如果映射中没有与提供的键关联的函数，你会打印错误消息并跳过循环的其余部分。然后，你使用之前解码的`p1`和`p2`变量调用分配给`opFunc`变量的函数。在变量中调用函数的方式与直接调用函数的方式完全相同。
- en: 'When you run this program, you can see the simple calculator at work:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你可以看到简单计算器的工作：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t write fragile programs. The core logic for this example is relatively
    short. Of the 22 lines inside the `for` loop, 6 of them implement the actual algorithm,
    and the other 16 are for error checking and data validation. You might be tempted
    to not validate incoming data or check errors, but doing so produces unstable,
    unmaintainable code. Error handling is what separates the professionals from the
    amateurs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不要编写脆弱的程序。这个示例的核心逻辑相对简短。在`for`循环内的22行代码中，有6行用于实现实际算法，另外16行用于错误检查和数据验证。你可能会被诱惑不验证输入数据或检查错误，但这样做会产生不稳定、难以维护的代码。错误处理是区分专业人员和业余人员的关键。
- en: Function Type Declarations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型声明
- en: 'Just as you can use the `type` keyword to define a `struct`, you can use it
    to define a function type too (I’ll go into more details on type declarations
    in [Chapter 7](ch07.html#unique_chapter_id_07)):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用`type`关键字定义`struct`一样，你也可以用它来定义函数类型（我将在[第7章](ch07.html#unique_chapter_id_07)详细介绍类型声明）：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can then rewrite the `opMap` declaration to look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以将`opMap`的声明重写为这样：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You don’t have to modify the functions at all. Any function that has two input
    parameters of type `int` and a single return value of type `int` automatically
    meets the type and can be assigned as a value in the map.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要修改这些函数。任何具有两个`int`类型输入参数和单个`int`类型返回值的函数都会自动满足该类型，并可以被分配为映射中的值。
- en: What’s the advantage of declaring a function type? One use is documentation.
    It’s useful to give something a name if you are going to refer to it multiple
    times. You will see another use in [“Function Types Are a Bridge to Interfaces”](ch07.html#function_type_interface).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数类型的优点是什么？一个用途是文档化。如果你要多次引用某个东西，给它起个名字是很有用的。在[“函数类型是接口的桥梁”](ch07.html#function_type_interface)中，你会看到另一个用途。
- en: Anonymous Functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'You can not only assign functions to variables, but also define new functions
    within a function and assign them to variables. Here’s a program to demonstrate
    this, which you can run on [The Go Playground](https://oreil.ly/WPI6w). The code
    is also available in the *sample_code/anon_func* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以将函数分配给变量，还可以在函数内部定义新函数并将其分配给变量。这里有一个演示程序，你可以在[Go Playground](https://oreil.ly/WPI6w)上运行它。该代码也可以在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/anon_func*目录中找到：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inner functions are *anonymous*; they don’t have a name. You declare an anonymous
    function with the keyword `func` immediately followed by the input parameters,
    the return values, and the opening brace. It is a compile-time error to try to
    put a function name between `func` and the input parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数是*匿名*的；它们没有名称。你可以使用关键字`func`紧跟输入参数、返回值和开括号来声明匿名函数。试图在`func`和输入参数之间放置函数名是编译时错误。
- en: Just like any other function, an anonymous function is called by using parentheses.
    In this example, you are passing the `i` variable from the `for` loop in here.
    It is assigned to the `j` input parameter of the anonymous function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他函数一样，通过使用括号来调用匿名函数。在这个例子中，你将`for`循环中的`i`变量传递到这里。它被分配给匿名函数的`j`输入参数。
- en: 'The program gives the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序输出如下：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You don’t have to assign an anonymous function to a variable. You can write
    them inline and call them immediately. The previous program can be rewritten into
    this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将匿名函数分配给变量。你可以直接编写内联函数并立即调用它们。前面的程序可以重写为这样：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can run this example on [The Go Playground](https://oreil.ly/EnkN6) or in
    the *sample_code/anon_func* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[The Go Playground](https://oreil.ly/EnkN6)上运行这个示例，或者在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/anon_func*目录中运行。
- en: 'Now, this is not something that you would normally do. If you are declaring
    and executing an anonymous function immediately, you might as well get rid of
    the anonymous function and just call the code. However, declaring anonymous functions
    without assigning them to variables is useful in two situations: `defer` statements
    and launching goroutines. I’ll talk about `defer` statements in a bit. Goroutines
    are covered in [Chapter 12](ch12.html#unique_chapter_id_12).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这不是你通常会做的事情。如果你正在声明并立即执行一个匿名函数，那么你可能会摆脱匿名函数，直接调用代码。然而，在不将匿名函数赋给变量的情况下声明它们，在两种情况下是有用的：`defer`语句和启动goroutines。稍后我会讲解`defer`语句。Goroutines在[第12章](ch12.html#unique_chapter_id_12)中有详细介绍。
- en: 'Since you can declare variables at the package scope, you can also declare
    package scope variables that are assigned anonymous functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以在包范围内声明变量，你也可以声明分配给匿名函数的包范围变量：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unlike a normal function definition, you can assign a new value to a package-level
    anonymous function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通函数定义不同，你可以给包级别的匿名函数分配一个新值：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running this code gives the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将得到以下输出：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can try this sample on [The Go Playground](https://oreil.ly/nK6Z9). The
    code is also in the *sample_code/package_level_anon* directory in the [Chapter
    5 repository](https://oreil.ly/EzU8N).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[The Go Playground](https://oreil.ly/nK6Z9)上尝试这个示例。这段代码也在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/package_level_anon*目录中。
- en: Before using a package-level anonymous function, be very sure you need this
    capability. Package-level state should be immutable to make data flow easier to
    understand. If a function’s meaning changes while a program is running, it becomes
    difficult to understand not just how data flows, but how it is processed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用包级别的匿名函数之前，请务必确定你确实需要这种能力。包级别的状态应该是不可变的，以便更容易理解数据流。如果一个函数的含义在程序运行时发生变化，不仅数据流变得难以理解，处理数据也变得困难。
- en: Closures
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Functions declared inside functions are special; they are *closures*. This
    is a computer science word that means that functions declared inside functions
    are able to access and modify variables declared in the outer function. Let’s
    look at a quick example to see how this works. You can find the code on [The Go
    Playground](https://oreil.ly/6aILJ). The code is also in the *sample_code/closure*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部声明的函数是特殊的；它们是*closures*。这是一个计算机科学术语，意味着在函数内部声明的函数能够访问和修改在外部函数中声明的变量。让我们看一个快速的示例，看看这是如何工作的。你可以在[The
    Go Playground](https://oreil.ly/6aILJ)上找到这段代码。这段代码也在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/closure*目录中：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running this program gives the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序将得到以下输出：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The anonymous function assigned to `f` can read and write `a`, even though `a`
    is not passed in to the function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`f`的匿名函数可以读取和写入`a`，即使`a`没有传递给函数。
- en: 'Just as with any inner scope, you can shadow a variable inside a closure. If
    you change the code to:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何内部作用域一样，你可以在闭包内部遮蔽一个变量。如果你改变代码为：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'this will print out the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会打印出以下内容：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using `:=` instead of `=` inside the closure creates a new `a` that ceases to
    exist when the closure exits. When working with inner functions, be careful to
    use the correct assignment operator, especially when multiple variables are on
    the lefthand side. You can try this code on [The Go Playground](https://oreil.ly/JXn8P).
    The code is also in the *sample_code/closure_shadow* directory in the [Chapter
    5 repository](https://oreil.ly/EzU8N).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包中使用`:=`而不是`=`会创建一个新的`a`，当闭包退出时它将不复存在。在处理内部函数时，务必使用正确的赋值操作符，特别是当左手边有多个变量时。你可以在[The
    Go Playground](https://oreil.ly/JXn8P)上尝试这段代码。这段代码也在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/closure_shadow*目录中。
- en: This inner function and closure stuff might not seem all that useful at first.
    What benefit do you get from making mini-functions within a larger function? Why
    does Go have this feature?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内部函数和闭包的东西起初可能看起来并不那么有用。在一个更大的函数内部创建微型函数有什么好处呢？为什么Go语言具有这个特性？
- en: One thing that closures allow you to do is to limit a function’s scope. If a
    function is going to be called from only one other function, but it’s called multiple
    times, you can use an inner function to “hide” the called function. This reduces
    the number of declarations at the package level, which can make it easier to find
    an unused name.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包允许您限制函数的作用域。如果一个函数只会从另一个函数调用，但会被多次调用，可以使用内部函数来“隐藏”调用函数。这样可以减少包级别的声明数量，从而更容易找到未使用的名称。
- en: If you have a piece of logic that is repeated multiple times within a function,
    a closure can be used to remove that repetition. I wrote a simple Lisp interpreter
    with a `Scan` function that processes an input string to find the parts of a Lisp
    program. It relies on two closures, `buildCurToken` and `update`, to make the
    code shorter and easier to understand. You can see it on [GitHub](https://oreil.ly/qanW3).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数内部多次重复使用某个逻辑片段，可以使用闭包来消除这种重复。我编写了一个简单的Lisp解释器，其中有一个`Scan`函数，用于处理输入字符串以查找Lisp程序的各个部分。它依赖于两个闭包，`buildCurToken`
    和 `update`，以使代码更简洁、更易于理解。您可以在 [GitHub](https://oreil.ly/qanW3) 上查看它。
- en: Closures really become interesting when they are passed to other functions or
    returned from a function. They allow you to take the variables within your function
    and use those values *outside* of your function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包被传递给其他函数或从函数中返回时，它们确实变得非常有趣。它们允许您获取函数内部的变量并在函数外部使用这些值。
- en: Passing Functions as Parameters
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: Since functions are values and you can specify the type of a function using
    its parameter and return types, you can pass functions as parameters into functions.
    If you aren’t used to treating functions like data, you might need a moment to
    think about the implications of creating a closure that references local variables
    and then passing that closure to another function. It’s a very useful pattern
    that appears several times in the standard library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数是值，您可以使用其参数和返回类型指定函数的类型，因此可以将函数作为参数传递给其他函数。如果您不习惯将函数视为数据来处理，您可能需要一些时间来考虑创建引用局部变量的闭包并将其传递给另一个函数的后果。这是一个非常有用的模式，在标准库中多次出现。
- en: One example is sorting slices. The `sort` package in the standard library has
    a function called `sort.Slice`. It takes in any slice and a function that is used
    to sort the slice that’s passed in. Let’s see how it works by sorting a slice
    of a struct using two different fields.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是对切片进行排序。标准库中的`sort`包含一个名为`sort.Slice`的函数。它接受任何切片以及一个用于对传入切片排序的函数。我们来看看如何通过使用不同的字段对结构体切片进行排序。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `sort.Slice` function predates the addition of generics to Go, so it does
    some internal magic to make it work with any kind of slice. I’ll talk about this
    magic more in [Chapter 16](ch16.html#unique_chapter_id_16).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort.Slice` 函数在Go语言引入泛型之前就存在了，因此它会执行一些内部魔法来使其与任何类型的切片一起工作。我将在 [第16章](ch16.html#unique_chapter_id_16)
    中更详细地讨论这些魔法。'
- en: 'Let’s see how to use closures to sort the same data different ways. You can
    run this code on [The Go Playground](https://oreil.ly/deOHW). The code is also
    in the *sample_code/sort_sample* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
    First, define a simple type, a slice of values of that type, and print out the
    slice:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用闭包以不同方式对相同数据进行排序。您可以在 [The Go Playground](https://oreil.ly/deOHW) 上运行此代码。该代码也位于
    [第5章代码库](https://oreil.ly/EzU8N) 的 *sample_code/sort_sample* 目录中。首先，定义一个简单的类型，一个该类型值的切片，并打印出该切片：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, sort the slice by last name and print out the results:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按姓氏对切片进行排序并打印出结果：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The closure that’s passed to `sort.Slice` has two parameters, `i` and `j`,
    but within the closure, `people` is used, so you can sort it by the `LastName`
    field. In computer science terms, `people` is *captured* by the closure. Next
    you do the same, sorting by the `Age` field:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `sort.Slice` 的闭包有两个参数，`i` 和 `j`，但在闭包内部使用了 `people`，因此可以按 `LastName` 字段对其进行排序。在计算机科学术语中，`people`
    被 *闭包捕获*。接下来，您可以按 `Age` 字段进行相同的操作：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running this code gives the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将得到以下输出：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `people` slice is changed by the call to `sort.Slice`. I talk about this
    briefly in [“Go Is Call by Value”](#call_value) and in more detail in the next
    chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`sort.Slice`会改变`people`切片。我在 [“Go Is Call by Value”](#call_value) 中简要讨论了这一点，并在下一章节中详细介绍。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Passing functions as parameters to other functions is often useful for performing
    different operations on the same kind of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给其他函数对于在同一类型数据上执行不同操作非常有用。
- en: Returning Functions from Functions
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数中返回函数
- en: 'In addition to using a closure to pass some function state to another function,
    you can also return a closure from a function. Let’s demonstrate this by writing
    a function that returns a multiplier function. You can run this program on [The
    Go Playground](https://oreil.ly/8tpbN). The code is also in the *sample_code/makeMult*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N). Here is a function
    that returns a closure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用闭包将一些函数状态传递给另一个函数外，你还可以从函数中返回一个闭包。让我们通过编写一个返回乘法器函数的函数来演示这一点。你可以在[The Go
    Playground](https://oreil.ly/8tpbN)上运行这个程序。代码也在[第5章仓库](https://oreil.ly/EzU8N)的*sample_code/makeMult*目录中。这是一个返回闭包的函数：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here is how the function is used:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是函数的使用方法：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running this program gives the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序将得到以下输出：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that you’ve seen closures in action, you might wonder how often they are
    used by Go developers. It turns out that they are surprisingly useful. You saw
    how they are used to sort slices. A closure is also used to efficiently search
    a sorted slice with `sort.Search`. As for returning closures, you will see this
    pattern used when you build middleware for a web server in [“Middleware”](ch13.html#middleware).
    Go also uses closures to implement resource cleanup, via the `defer` keyword.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到闭包的实际应用，你可能想知道Go开发者经常使用它们多少。事实证明，它们非常有用。你看到它们如何用于对切片进行排序。闭包还用于使用`sort.Search`高效地搜索排序的切片。至于返回闭包，当你为Web服务器构建中间件时，你会在[“中间件”](ch13.html#middleware)中看到这种模式。Go还使用闭包实现资源清理，通过`defer`关键字。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you spend any time with programmers who use functional programming languages
    like Haskell, you might hear the term *higher-order functions*. That’s a fancy
    way to say that a function has a function for an input parameter or a return value.
    As a Go developer, you are as cool as they are!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间与使用像Haskell这样的函数式编程语言的程序员在一起，你可能会听到*高阶函数*这个术语。这是一种说法，即一个函数的输入参数或返回值是一个函数。作为Go开发者，你与他们一样酷！
- en: defer
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defer
- en: Programs often create temporary resources, like files or network connections,
    that need to be cleaned up. This cleanup has to happen, no matter how many exit
    points a function has, or whether a function completed successfully or not. In
    Go, the cleanup code is attached to the function with the `defer` keyword.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 程序经常创建临时资源，如文件或网络连接，需要进行清理。无论一个函数有多少个退出点，或者函数是否成功完成，都必须进行清理。在Go中，清理代码使用`defer`关键字附加到函数中。
- en: 'Let’s take a look at how to use `defer` to release resources. You’ll do this
    by writing a simple version of `cat`, the Unix utility for printing the contents
    of a file. You can’t pass in arguments on The Go Playground, but you can find
    the code for this example in the *sample_code/simple_cat* directory in the [Chapter
    5 repository](https://oreil.ly/EzU8N):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`defer`来释放资源。通过编写一个简单版本的`cat`，Unix的用于打印文件内容的实用程序。你不能在The Go Playground上传入参数，但是你可以在[第5章仓库](https://oreil.ly/EzU8N)的*sample_code/simple_cat*目录中找到这个示例的代码：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This example introduces a few new features that I cover in more detail in later
    chapters. Feel free to read ahead to learn more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了我在后续章节中更详细介绍的一些新功能。随时阅读以获取更多信息。
- en: First, you make sure that a filename was specified on the command line by checking
    the length of `os.Args`, a slice in the `os` package. The first value in `os.Args`
    is the name of the program. The remaining values are the arguments passed to the
    program. You check that the length of `os.Args` is at least 2 to determine whether
    the argument to the program was provided. If it wasn’t, use the `Fatal` function
    in the `log` package to print a message and exit the program. Next, you acquire
    a read-only file handle with the `Open` function in the `os` package. The second
    value that’s returned by `Open` is an error. If there’s a problem opening the
    file, you print the error message and exit the program. As mentioned earlier,
    I’ll talk about errors in [Chapter 9](ch09.html#unique_chapter_id_09).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过检查`os.Args`（在`os`包中的切片）的长度来确保命令行中指定了文件名。`os.Args`的第一个值是程序的名称。剩余的值是传递给程序的参数。检查`os.Args`的长度至少为2来确定是否提供了程序的参数。如果没有，使用`log`包中的`Fatal`函数打印一条消息并退出程序。接下来，使用`os`包中的`Open`函数获取一个只读文件句柄。`Open`函数返回的第二个值是一个错误。如果打开文件时出现问题，打印错误消息并退出程序。正如前面提到的，我会在[第9章](ch09.html#unique_chapter_id_09)讨论错误。
- en: Once you know there is a valid file handle, you need to close it after you use
    it, no matter how you exit the function. To ensure that the cleanup code runs,
    you use the `defer` keyword, followed by a function or method call. In this case,
    you use the `Close` method on the file variable. (I cover `at` methods in Go in
    [Chapter 7](ch07.html#unique_chapter_id_07).) Normally, a function call runs immediately,
    but `defer` delays the invocation until the surrounding function exits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定存在有效的文件句柄，你需要在使用后关闭它，无论如何退出函数。为了确保清理代码运行，你使用`defer`关键字，后跟函数或方法调用。在这种情况下，你使用文件变量的`Close`方法。（我在[第7章](ch07.html#unique_chapter_id_07)中详细介绍了Go中的`at`方法。）通常情况下，函数调用会立即运行，但`defer`延迟调用直到周围函数退出。
- en: You read from a file handle by passing a slice of bytes into the `Read` method
    on a file variable. I’ll cover how to use this method in detail in [“io and Friends”](ch13.html#io_friends),
    but `Read` returns the number of bytes that were read into the slice and an error.
    If an error occurs, you check whether it’s an end-of-file marker. If you are at
    the end of the file, you use `break` to exit the `for` loop. For all other errors,
    you report it and exit immediately, using `log.Fatal`. I’ll talk a little more
    about slices and function parameters in [“Go Is Call by Value”](#call_value) and
    go into details on this pattern when I discuss pointers in the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字节片段传递给文件变量的`Read`方法，你可以从文件句柄读取。我将在[“io and Friends”](ch13.html#io_friends)中详细讨论如何使用这个方法，但`Read`会返回已读入片段的字节数和一个错误。如果发生错误，你需要检查是否是文件结束标记。如果已到文件末尾，使用`break`退出`for`循环。对于所有其他错误，使用`log.Fatal`报告并立即退出。我将在[“Go
    Is Call by Value”](#call_value)中稍作介绍切片和函数参数，并在下一章节中详细讨论这种模式时，详细讨论指针。
- en: 'Building and running the program from within the *simple_cat* directory produces
    the following result:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从*simple_cat*目录内构建并运行程序会产生以下结果：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You should know a few more things about `defer`. First, you can use a function,
    method, or closure with `defer`. (When I mention functions with `defer`, mentally
    expand that to “functions, methods, or closures.”)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解关于`defer`的更多事项。首先，你可以在`defer`中使用函数、方法或闭包。（当我提到带有`defer`的函数时，心理上扩展为“函数、方法或闭包”。）
- en: You can `defer` multiple functions in a Go function. They run in last-in, first-out
    (LIFO) order; the last `defer` registered runs first.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Go函数中`defer`多个函数。它们按照后进先出（LIFO）的顺序运行；最后注册的`defer`首先运行。
- en: The code within `defer` functions runs *after* the return statement. As I mentioned,
    you can supply a function with input parameters to a `defer`. The input parameters
    are evaluated immediately and their values are stored until the function runs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回语句之后，`defer`函数内的代码会运行。正如我提到的，你可以向`defer`提供带有输入参数的函数。输入参数会立即评估，并且它们的值会存储，直到函数运行。
- en: 'Here’s a quick example that demonstrates both of these features of `defer`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速示例，演示了`defer`的这两个特性：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running this code gives the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can run this on [The Go Playground](https://oreil.ly/SgAcq). It is also
    available in the *sam⁠ple​_code/defer_example* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Go Playground](https://oreil.ly/SgAcq)上运行此代码。它还可以在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/defer_example*目录中找到。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can supply a function that returns values to a `defer`, but there’s no
    way to read those values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`defer`提供返回值的函数，但没有办法读取这些值：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You might be wondering whether there’s a way for a deferred function to examine
    or modify the return values of its surrounding function. There is, and it’s the
    best reason to use named return values. It allows your code to take actions based
    on an error. When I talk about errors in [Chapter 9](ch09.html#unique_chapter_id_09),
    I will discuss a pattern that uses `defer` to add contextual information to an
    error returned from a function. Let’s look at a way to handle database transaction
    cleanup using named return values and `defer`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想是否有一种方法让延迟函数检查或修改其周围函数的返回值。确实有一种方法，这也是使用命名返回值的最佳理由。它允许你的代码根据错误采取行动。当我在[第9章](ch09.html#unique_chapter_id_09)讨论错误时，我将讨论一种使用`defer`向从函数返回的错误添加上下文信息的模式。让我们看一种使用命名返回值和`defer`处理数据库事务清理的方法：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I’m not going to cover Go’s database support in this book, but the standard
    library includes extensive support for databases in the `database/sql` package.
    In the example function, you create a transaction to do a series of database inserts.
    If any of them fails, you want to roll back (not modify the database). If all
    of them succeed, you want to commit (store the database changes). You use a closure
    with `defer` to check whether `err` has been assigned a value. If it hasn’t, you
    run `tx.Commit`, which could also return an error. If it does, the value `err`
    is modified. If any database interaction returned an error, you call `tx.Rollback`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在本书中涵盖Go的数据库支持，但标准库在`database/sql`包中提供了广泛的数据库支持。在示例函数中，您创建一个事务来执行一系列数据库插入操作。如果其中任何一个失败，您希望回滚（不修改数据库）。如果它们全部成功，您希望提交（保存数据库更改）。您使用`defer`和闭包来检查是否已给`err`赋值。如果没有，您运行`tx.Commit`，这也可能返回一个错误。如果返回了错误，变量`err`将被修改。如果任何数据库交互返回错误，您会调用`tx.Rollback`。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: New Go developers tend to forget the set of parentheses after the braces when
    specifying a function for `defer`. It is a compile-time error to leave them out,
    and eventually the habit sets in. It helps to remember that supplying parentheses
    allows you to specify values that will be passed into the function when it runs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Go开发者往往会忘记在指定`defer`函数时的大括号后面加上括号。如果省略它们，这是一个编译时错误，最终会形成习惯。记住提供括号可以让您指定在运行函数时传递的值。
- en: 'A common pattern in Go is for a function that allocates a resource to also
    return a closure that cleans up the resource. In the *sample_code/simple_cat_cancel*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N), there is a rewrite
    of the simple `cat` program that does this. First you write a helper function
    that opens a file and returns a closure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的常见模式是，分配资源的函数还会返回一个清理资源的闭包。在[第5章的示例代码/simple_cat_cancel目录](https://oreil.ly/EzU8N)中，有一个重写的简单`cat`程序。首先，您编写一个打开文件并返回一个闭包的辅助函数：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The helper function returns a file, a function, and an error. That `*` means
    that a file reference in Go is a pointer. I’ll talk more about that in the next
    chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数返回一个文件、一个函数和一个错误。`*`表示在Go中，文件引用是一个指针。我将在下一章中详细讨论这一点。
- en: 'Now in `main`, you use the `getFile` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`main`中，您使用`getFile`函数：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because Go doesn’t allow unused variables, returning the `closer` from the function
    means that the program will not compile if the function is not called. That reminds
    the user to use `defer`. As covered earlier, you put parentheses after `closer`
    when you `defer` it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Go不允许未使用的变量，从函数返回`closer`意味着如果函数未被调用，则程序将无法编译。这提醒用户使用`defer`。正如前面所述，当您`defer`时，在`closer`后面加上括号。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using `defer` can feel strange if you are used to a language that uses a block
    within a function to control when a resource is cleaned up, like the `try/catch/finally`
    blocks in Java, JavaScript, and Python or the `begin/rescue/ensure` blocks in
    Ruby.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于使用语言中的块在函数内部控制资源清理（例如Java、JavaScript和Python中的`try/catch/finally`块或Ruby中的`begin/rescue/ensure`块），使用`defer`可能会感觉奇怪。
- en: 'The downside to these resource-cleanup blocks is that they create another level
    of indentation in your function, and that makes the code harder to read. It’s
    not just my opinion that nested code is harder to follow. In research described
    in a [2017 paper in *Empirical Software Engineering*](https://oreil.ly/VcYrR),
    Vard Antinyan et al. discovered that “Of…​eleven proposed code characteristics,
    only two markedly influence complexity growth: the nesting depth and the lack
    of structure.”'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源清理块的缺点是它们会在函数中创建另一个缩进级别，这使得代码更难阅读。嵌套代码难以跟踪不仅仅是我的观点。在一项发表于[2017年的*Empirical
    Software Engineering*论文](https://oreil.ly/VcYrR)中，Vard Antinyan等人发现，“在提出的十一种代码特征中，只有两种明显影响复杂性增长：嵌套深度和缺乏结构。”
- en: Research on what makes a program easier to read and understand isn’t new. You
    can find papers that are many decades old, including a [paper from 1983](https://oreil.ly/s0xcq)
    by Richard Miara et al. that tries to figure out the right amount of indentation
    to use (according to their results, two to four spaces).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使程序更易于阅读和理解的研究并不新鲜。您可以找到许多几十年前的论文，包括Richard Miara等人在1983年的[一篇论文](https://oreil.ly/s0xcq)，尝试找出适合使用的正确缩进量（根据他们的结果，是两到四个空格）。
- en: Go Is Call by Value
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go是按值调用的
- en: 'You might hear people say that Go is a *call-by-value* language and wonder
    what that means. It means that when you supply a variable for a parameter to a
    function, Go *always* makes a copy of the value of the variable. Let’s take a
    look. You can run this code on [The Go Playground](https://oreil.ly/yo_rY). It
    is also in the *sample_code/pass_value_type* directory in the [Chapter 5 repository](https://oreil.ly/EzU8N).
    First, you define a simple struct:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听人说 Go 是一个*按值传递*的语言，想知道这是什么意思。这意味着当你把一个变量作为参数传递给函数时，Go 总是会复制变量的值。我们来看看。你可以在[Go
    Playground](https://oreil.ly/yo_rY)上运行这段代码。它还在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/pass_value_type*目录中。首先，你定义一个简单的结构体：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, you write a function that takes in an `int`, a `string`, and a `person`,
    and modifies their values:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将编写一个函数，接收一个`int`、一个`string`和一个`person`，并修改它们的值：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You then call this function from `main` and see whether the modifications stick:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你从`main`中调用这个函数，看看修改是否生效：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As the name of the function indicates, running this code shows that a function
    won’t change the values of the parameters passed into it:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如函数名称所示，运行此代码将显示函数不会更改传递给它的参数的值：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I included the `person` struct to show that this isn’t true just for primitive
    types. If you have programming experience in Java, JavaScript, Python, or Ruby,
    you might find the struct behavior strange. After all, those languages let you
    modify the fields in an object when you pass an object as a parameter to a function.
    The reason for the difference is something I will cover when I talk about pointers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我包含了`person`结构体，以表明这不仅适用于基本类型。如果你有 Java、JavaScript、Python 或 Ruby 的编程经验，可能会觉得结构体的行为很奇怪。毕竟，这些语言在将对象作为参数传递给函数时允许修改对象的字段。这种差异的原因是我在讨论指针时会解释的。
- en: 'The behavior is a little different for maps and slices. Let’s see what happens
    when you try to modify them within a function. You can run this code on [The Go
    Playground](https://oreil.ly/kKL4R). It is also in the *sample_code/pass_map_slice*
    directory in the [Chapter 5 repository](https://oreil.ly/EzU8N). You’re going
    to write a function to modify a map parameter and a function to modify a slice
    parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射和切片的行为有所不同。让我们看看在函数内部尝试修改它们时会发生什么。你可以在[Go Playground](https://oreil.ly/kKL4R)上运行这段代码。它还在[第5章代码库](https://oreil.ly/EzU8N)的*sample_code/pass_map_slice*目录中。你将编写一个修改映射参数的函数和一个修改切片参数的函数：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You then call these functions from `main`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你从`main`中调用这些函数：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When you run this code, you’ll see something interesting:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，会看到一些有趣的事情：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For the map, it’s easy to explain what happens: any changes made to a map parameter
    are reflected in the variable passed into the function. For a slice, it’s more
    complicated. You can modify any element in the slice, but you can’t lengthen the
    slice. This is true for maps and slices that are passed directly into functions
    as well as map and slice fields in structs.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射来说，解释发生的事情很容易：对映射参数的任何更改都会反映在传递到函数中的变量中。对于切片来说，情况就更复杂了。你可以修改切片中的任何元素，但不能扩展切片的长度。这对直接传递给函数的映射和切片以及结构体中的映射和切片字段都适用。
- en: 'This program leads to the question: why do maps and slices behave differently
    than other types? It’s because maps and slices are both implemented with pointers.
    I’ll go into more detail in the next chapter.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序引出了一个问题：为什么映射和切片的行为与其他类型不同？这是因为映射和切片都是用指针实现的。我将在下一章节详细介绍。
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every type in Go is a value type. It’s just that sometimes the value is a pointer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的每种类型都是值类型。只是有时候这个值是一个指针。
- en: Call by value is one reason that Go’s limited support for constants is only
    a minor handicap. Since variables are passed by value, you can be sure that calling
    a function doesn’t modify the variable whose value was passed in (unless the variable
    is a slice or map). In general, this is a good thing. It makes it easier to understand
    the flow of data through your program when functions don’t modify their input
    parameters and instead return newly computed values.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递是 Go 对常量支持有限的一个原因。由于变量是按值传递的，你可以确保调用函数不会修改传递进去的变量的值（除非变量是切片或映射）。总的来说，这是件好事。当函数不修改其输入参数，而是返回新计算的值时，它使得理解程序中数据流动的过程变得更容易。
- en: While this approach is easy to understand, at times you need to pass something
    mutable to a function. What do you do then? That’s when you need a pointer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法很容易理解，但有时你需要将可变的东西传递给一个函数。那么你该怎么办？这时你就需要一个指针。
- en: Exercises
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: These exercises test your knowledge of functions in Go and how to use them.
    Solutions are available in the *exercise_solutions* directory in the [Chapter
    5 repository](https://oreil.ly/EzU8N).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习测试你对Go语言中函数的理解以及如何使用它们的知识。解决方案可在[第5章仓库](https://oreil.ly/EzU8N)的*exercise_solutions*目录中找到。
- en: 'The simple calculator program doesn’t handle one error case: division by zero.
    Change the function signature for the math operations to return both an `int`
    and an `error`. In the `div` function, if the divisor is `0`, return `errors.New("division
    by zero")` for the error. In all other cases, return `nil`. Adjust the `main`
    function to check for this error.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个简单的计算器程序没有处理一个错误情况：除以零。更改数学操作的函数签名，以返回一个`int`和一个`error`。在`div`函数中，如果除数是`0`，则返回`errors.New("division
    by zero")`作为错误。在所有其他情况下，返回`nil`。调整`main`函数以检查此错误。
- en: Write a function called `fileLen` that has an input parameter of type `string`
    and returns an `int` and an `error`. The function takes in a filename and returns
    the number of bytes in the file. If there is an error reading the file, return
    the error. Use `defer` to make sure the file is closed properly.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`fileLen`的函数，该函数具有`string`类型的输入参数，并返回一个`int`和一个`error`。该函数接受一个文件名，并返回文件的字节数。如果读取文件时出错，返回错误。使用`defer`确保文件正确关闭。
- en: 'Write a function called `prefixer` that has an input parameter of type `string`
    and returns a function that has an input parameter of type `string` and returns
    a `string`. The returned function should prefix its input with the string passed
    into `prefixer`. Use the following `main` function to test `prefixer`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`prefixer`的函数，该函数具有`string`类型的输入参数，并返回一个函数，该函数具有`string`类型的输入参数并返回一个`string`类型的返回值。返回的函数应该将其输入以`prefixer`传入的字符串作为前缀。使用以下`main`函数来测试`prefixer`：
- en: '[PRE56]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Wrapping Up
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: In this chapter, you’ve looked at functions in Go, how they are similar to functions
    in other languages, and their unique features. In the next chapter, you’re going
    to look at pointers, find out that they aren’t nearly as scary as many new Go
    developers expect them to be, and learn how to take advantage of them to write
    efficient programs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了Go语言中的函数，它们与其他语言中的函数相似之处以及它们的独特特性。在下一章中，你将学习指针，了解它们并不像许多新的Go开发者期望的那样可怕，并学习如何利用它们编写高效的程序。
