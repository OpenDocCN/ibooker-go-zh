- en: Chapter 2\. Predeclared Types and Declarations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。预声明类型和声明
- en: 'Now that you have your development environment set up, it’s time to start looking
    at Go’s language features and how to best use them. When trying to figure out
    what “best” means, there is one overriding principle: write your programs in a
    way that makes your intentions clear. As I go through features and discuss the
    options, I’ll explain why I find that a particular approach produces clearer code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经设置好开发环境，是时候开始了解Go语言的语言特性以及如何最佳地使用它们了。当试图弄清楚“最佳”意味着什么时，有一个主要的原则：以一种使您的意图清晰的方式编写您的程序。在我介绍功能并讨论选项时，我将解释为什么我认为特定的方法会产生更清晰的代码。
- en: I’ll start by looking at the types that are built into Go and how to declare
    variables of those types. While every programmer has experience with these concepts,
    Go does some things differently, and subtle differences exist between Go and other
    languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先查看内置于Go中的类型以及如何声明这些类型的变量。尽管每位程序员对这些概念都有经验，但Go在某些方面有所不同，并且与其他语言之间存在微妙的差异。
- en: The Predeclared Types
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预声明类型
- en: 'Go has many types built into the language. These are called *predeclared* types.
    They are similar to types that are found in other languages: booleans, integers,
    floats, and strings. Using these types idiomatically is sometimes a challenge
    for developers who are transitioning from another language. You’ll look at these
    types and see how they work best in Go. Before I review the types, let’s cover
    some of the concepts that apply to all types.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言内置了许多类型。这些被称为*预声明*类型。它们类似于其他语言中的类型：布尔型、整数型、浮点型和字符串型。对于那些从其他语言过渡的开发人员来说，习惯地使用这些类型有时是一个挑战。你将看到这些类型如何在Go中发挥最佳作用。在我回顾这些类型之前，让我们先了解一些适用于所有类型的概念。
- en: The Zero Value
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零值
- en: Go, like most modern languages, assigns a default *zero value* to any variable
    that is declared but not assigned a value. Having an explicit zero value makes
    code clearer and removes a source of bugs found in C and C++ programs. As I talk
    about each type, I will also cover the zero value for the type. You can find details
    on the zero value in [The Go Programming Language Specification](https://oreil.ly/3d3e6).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数现代语言一样，Go会为声明但未赋值的变量分配一个默认的*零值*。显式的零值使得代码更清晰，并消除了在C和C++程序中发现的错误源。当我讨论每种类型时，我还将涵盖该类型的零值。您可以在[《Go编程语言规范》](https://oreil.ly/3d3e6)中找到有关零值的详细信息。
- en: Literals
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量
- en: A Go *literal* is an explicitly specified number, character, or string. Go programs
    have four common kinds of literals. (I’ll cover a rare fifth kind of literal when
    discussing complex numbers.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的*字面量*是明确指定的数字、字符或字符串。Go程序有四种常见的字面量类型。（在讨论复数时，我将涵盖一种罕见的第五种字面量类型。）
- en: 'An *integer literal* is a sequence of numbers. Integer literals are base 10
    by default, but different prefixes are used to indicate other bases: 0b for binary
    (base 2), 0o for octal (base 8), or 0x for hexadecimal (base 16). You can use
    either upper- or lowercase letters for the prefix. A leading 0 with no letter
    after it is another way to represent an octal literal. Do not use it, as it is
    very confusing.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数字面量*是一系列数字。整数字面量默认为十进制，但使用不同的前缀表示其他进制：0b表示二进制（基数为2），0o表示八进制（基数为8），0x表示十六进制（基数为16）。前缀的字母可以是大写或小写。在一个前导的0后没有字母的情况下，是另一种表示八进制字面量的方式。不要使用这种表示法，因为它会非常令人困惑。'
- en: To make it easier to read longer integer literals, Go allows you to put underscores
    in the middle of your literal. This allows you to, for example, group by thousands
    in base 10 (1_234). These underscores have no effect on the value of the number.
    The only limitations on underscores are that they can’t be at the beginning or
    end of numbers, and you can’t have them next to each other. You could put an underscore
    between every digit in your literal (1_2_3_4), but don’t. Use them to improve
    readability by breaking up base 10 numbers at the thousands place or to break
    up binary, octal, or hexadecimal numbers at 1-, 2-, or 4-byte boundaries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易阅读更长的整数字面量，Go允许您在字面量的中间放置下划线。这使您可以例如在十进制数中按千位组织（1_234）。这些下划线对数字的值没有影响。下划线的唯一限制是它们不能出现在数字的开头或结尾，并且不能相互挨着。您可以在字面量中的每个数字之间放置下划线（1_2_3_4），但是不要这样做。通过在千位处分隔十进制数或在1字节、2字节或4字节边界处分隔二进制、八进制或十六进制数来提高可读性。
- en: A *floating-point literal* has a decimal point to indicate the fractional portion
    of the value. They can also have an exponent specified with the letter `e` and
    a positive or negative number (such as 6.03e23). You also have the option to write
    them in hexadecimal by using the 0x prefix and the letter `p` for indicating any
    exponent (0x12.34p5, which is equal to 582.5 in base 10). As integer literals,
    you can use underscores to format your floating-point literals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮点文字* 有一个小数点来表示值的小数部分。它们也可以使用字母 `e` 和正负数来指定指数（例如 6.03e23）。您还可以选择使用 0x 前缀以及字母
    `p` 来以十六进制编写它们，指示任何指数（0x12.34p5，相当于十进制中的 582.5）。与整数文字一样，您可以使用下划线来格式化您的浮点文字。'
- en: A *rune literal* represents a character and is surrounded by single quotes.
    Unlike many other languages, in Go single quotes and double quotes are *not* interchangeable.
    Rune literals can be written as single Unicode characters (`'a'`), 8-bit octal
    numbers (`'\141'`), 8-bit hexadecimal numbers (`'\x61'`), 16-bit hexadecimal numbers
    (`'\u0061'`), or 32-bit Unicode numbers (`'\U00000061'`). There are also several
    backslash-escaped rune literals, with the most useful ones being newline (`'\n'`),
    tab (`'\t'`), single quote (`'\''`), and backslash (`'\\'`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*rune 文字* 表示一个字符，用单引号括起来。与许多其他语言不同，在 Go 中，单引号和双引号*不能*互换使用。rune 文字可以写成单个 Unicode
    字符（`''a''`）、8 位八进制数字（`''\141''`）、8 位十六进制数字（`''\x61''`）、16 位十六进制数字（`''\u0061''`）或
    32 位 Unicode 数字（`''\U00000061''`）。还有几个反斜杠转义的 rune 文字，其中最有用的是换行符（`''\n''`）、制表符（`''\t''`）、单引号（`''\''''`）和反斜杠（`''\\''`）。'
- en: Practically speaking, use base 10 to represent your integer and floating-point
    literals. Octal representations are rare, mostly used to represent POSIX permission
    flag values (such as 0o777 for rwxrwxrwx). Hexadecimal and binary are sometimes
    used for bit filters or networking and infrastructure applications. Avoid using
    any of the numeric escapes for rune literals, unless the context makes your code
    clearer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用十进制来表示整数和浮点数文字。八进制表示很少见，主要用于表示 POSIX 权限标志值（例如 0o777 表示 rwxrwxrwx）。十六进制和二进制有时用于位过滤器或网络和基础设施应用程序。除非上下文使代码更清晰，否则避免使用任何
    rune 文字的数值转义。
- en: There are two ways to indicate *string literals*. Most of the time, you should
    use double quotes to create an *interpreted string literal* (e.g., type **`"Greetings
    and`** **`Salutations"`**). These contain zero or more rune literals. They are
    called “interpreted” because they interpret rune literals (both numeric and backslash
    escaped) into single characters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式表示*字符串文字*。大多数情况下，您应该使用双引号创建*解释字符串文字*（例如，类型 **`"问候和`** **`致意"`**）。这些包含零个或多个
    rune 文字。它们被称为“解释性”的原因是它们将 rune 文字（数值和反斜杠转义的）解释为单个字符。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'One rune literal backslash escape is not legal in a string literal: the single
    quote escape. It is replaced by a backslash escape for double quotes.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 rune 文字的反斜杠转义在字符串文字中不合法：单引号转义。它被双引号的反斜杠转义替换。
- en: The only characters that cannot appear in an interpreted string literal are
    unescaped backslashes, unescaped newlines, and unescaped double quotes. If you
    use an interpreted string literal and want your greetings on a different line
    from your salutations and want “Salutations” to appear in quotes, you need to
    type **`"Greetings and\n\"Salutations\""`**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不能出现在解释字符串文字中的唯一字符是未转义的反斜杠、未转义的换行符和未转义的双引号。如果您使用解释字符串文字，并希望问候语在不同行与致意语，并且希望“致意”出现在引号中，则需要输入
    **`"问候和\n\"致意\""`**。
- en: 'If you need to include backslashes, double quotes, or newlines in your string,
    using a *raw string literal* is easier. These are delimited with backquotes (``
    ` ``) and can contain any character except a backquote. There’s no escape character
    in a raw string literal; all characters are included as is. When using a raw string
    literal, you write a multiline greeting like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在字符串中包含反斜杠、双引号或换行符，使用*原始字符串文字*更容易。这些用反引号（`` ` ``）界定，并且可以包含除反引号以外的任何字符。原始字符串文字中没有转义字符；所有字符均按原样包含。使用原始字符串文字时，您可以这样写一个多行问候语：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Literals are considered *untyped*. I’ll explore this concept more in [“Literals
    Are Untyped”](#literal_untyped). As you will see in [“var Versus :=”](#var_declarations),
    there are situations in Go where the type isn’t explicitly declared. In those
    cases, Go uses the *default type* for a literal; if there’s nothing in the expression
    that makes clear what the type of the literal is, the literal defaults to a type.
    I will mention the default type for literals when discussing the different predeclared
    types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量被视为 *无类型的*。我将在 [“字面量是无类型的”](#literal_untyped) 中更详细地探讨这一概念。正如你在 [“var Versus
    :=”](#var_declarations) 中所看到的，Go 中有些情况下类型并没有显式声明。在这些情况下，Go 使用字面量的 *默认类型*；如果表达式中没有明确表明字面量的类型，字面量将默认为某一类型。在讨论不同的预声明类型时，我将提到字面量的默认类型。
- en: Booleans
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'The `bool` type represents Boolean variables. Variables of `bool` type can
    have one of two values: `true` or `false`. The zero value for a `bool` is `false`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 类型表示布尔变量。`bool` 类型的变量可以有两个值：`true` 或 `false`。`bool` 的零值是 `false`：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s hard to talk about variable types without showing a variable declaration,
    and vice versa. I’ll use variable declarations first and describe them in [“var
    Versus :=”](#var_declarations).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论变量类型而不展示变量声明，或者反之，都是很难的。我将先使用变量声明并在 [“var Versus :=”](#var_declarations) 中对其进行描述。
- en: Numeric Types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'Go has a large number of numeric types: 12 types (and a few special names)
    that are grouped into three categories. If you are coming from a language like
    JavaScript that gets along with only a single numeric type, this might seem like
    a lot. And in fact, some types are used frequently while others are more esoteric.
    I’ll start by looking at integer types before moving on to floating-point types
    and the very unusual complex type.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言拥有大量的数值类型：12 种类型（以及一些特殊名称），分为三类。如果你来自像 JavaScript 这样只使用单一数值类型的语言，可能会觉得这很多。实际上，一些类型经常被使用，而其他一些则更为奇特。我将从整数类型开始讨论，然后再转向浮点类型和非常不寻常的复数类型。
- en: Integer types
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型
- en: Go provides both signed and unsigned integers in a variety of sizes, from one
    to eight bytes. They are shown in [Table 2-1](#table2_1).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言提供了带有各种大小的有符号和无符号整数，从一到八字节不等。它们在 [表 2-1](#table2_1) 中展示。
- en: Table 2-1\. The integer types in Go
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. Go 语言中的整数类型
- en: '| Type name | Value range |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 类型名称 | 取值范围 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int8` | –128 to 127 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | -128 到 127 |'
- en: '| `int16` | –32768 to 32767 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | -32768 到 32767 |'
- en: '| `int32` | –2147483648 to 2147483647 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | -2147483648 到 2147483647 |'
- en: '| `int64` | –9223372036854775808 to 9223372036854775807 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | -9223372036854775808 到 9223372036854775807 |'
- en: '| `uint8` | 0 to 255 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 0 到 255 |'
- en: '| `uint16` | 0 to 65535 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 0 到 65535 |'
- en: '| `uint32` | 0 to 4294967295 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 0 到 4294967295 |'
- en: '| `uint64` | 0 to 18446744073709551615 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 0 到 18446744073709551615 |'
- en: It might be obvious from the name, but the zero value for all of the integer
    types is `0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称就能看出，所有整数类型的零值都是 `0`。
- en: The special integer types
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊的整数类型
- en: Go does have some special names for integer types. A `byte` is an alias for
    `uint8`; it is legal to assign, compare, or perform mathematical operations between
    a `byte` and a `uint8`. However, you rarely see `uint8` used in Go code; just
    call it a `byte`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言确实有一些特殊的整数类型名称。`byte` 是 `uint8` 的别名；在 Go 代码中可以合法地在 `byte` 和 `uint8` 之间进行赋值、比较或执行数学运算。然而，在
    Go 代码中很少看到 `uint8`，通常直接称之为 `byte`。
- en: The second special name is `int`. On a 32-bit CPU, `int` is a 32-bit signed
    integer like an `int32`. On most 64-bit CPUs, `int` is a 64-bit signed integer,
    just like an `int64`. Because `int` isn’t consistent from platform to platform,
    it is a compile-time error to assign, compare, or perform mathematical operations
    between an `int` and an `int32` or `int64` without a type conversion (see [“Explicit
    Type Conversion”](#type_conversion) for more details). Integer literals default
    to being of `int` type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特殊名称是 `int`。在32位 CPU 上，`int` 是一个32位有符号整数，类似于 `int32`。在大多数64位 CPU 上，`int`
    是一个64位有符号整数，就像 `int64` 一样。因为 `int` 在平台间不一致，如果在没有类型转换的情况下在 `int` 和 `int32` 或 `int64`
    之间赋值、比较或执行数学运算，会导致编译时错误（详见 [“显式类型转换”](#type_conversion)）。整数字面量默认为 `int` 类型。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some uncommon 64-bit CPU architectures use a 32-bit signed integer for the
    `int` type. Go supports three of them: `amd64p32`, `mips64p32`, and `mips64p32le`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些不常见的64位 CPU 架构使用32位有符号整数作为 `int` 类型。Go 支持其中的三种：`amd64p32`、`mips64p32` 和 `mips64p32le`。
- en: The third special name is `uint`. It follows the same rules as `int`, only it
    is unsigned (the values are always 0 or positive).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个特殊名称是 `uint`。它遵循与 `int` 相同的规则，只是无符号的（值始终为 0 或正数）。
- en: There are two other special names for integer types, `rune` and `uintptr`. You
    looked at rune literals earlier and I’ll discuss the `rune` type in [“A Taste
    of Strings and Runes”](#string_rune) and `uintptr` in [Chapter 16](ch16.html#unique_chapter_id_16).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个特殊的整数类型名称，`rune`和`uintptr`。你之前已经看过rune字面量，我将在[“字符串和rune的味道”](#string_rune)中讨论`rune`类型，以及在[第16章](ch16.html#unique_chapter_id_16)中讨论`uintptr`。
- en: Choosing which integer to use
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何选择使用哪种整数类型
- en: 'Go provides more integer types than some other languages. Given all these choices,
    you might wonder when you should use each of them. You should follow three simple
    rules:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供的整数类型比一些其他语言更多。考虑到这些选择，你可能会想知道何时应该使用每种类型。你应该遵循三个简单的规则：
- en: If you are working with a binary file format or network protocol that has an
    integer of a specific size or sign, use the corresponding integer type.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在处理具有特定大小或符号的整数的二进制文件格式或网络协议，请使用相应的整数类型。
- en: If you are writing a library function that should work with any integer type,
    take advantage of Go’s generics support and use a generic type parameter to represent
    any integer type (I talk more about functions and their parameters in [Chapter 5](ch05.html#unique_chapter_id_05)
    and more about generics in [Chapter 8](ch08.html#unique_chapter_id_08).)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在编写一个应该适用于任何整数类型的库函数，可以利用Go的泛型支持，并使用泛型类型参数来表示任何整数类型（我在[第5章](ch05.html#unique_chapter_id_05)中更详细地讨论函数及其参数，以及在[第8章](ch08.html#unique_chapter_id_08)中更详细地讨论泛型）。
- en: In all other cases, just use `int`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有其他情况下，只需使用`int`。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll likely find legacy code where there’s a pair of functions that do the
    same thing, but one has `int64` for the parameters and variables and the other
    has `uint64`. The reason is that the API was created before generics were added
    to Go. Without generics, you needed to write functions with slightly different
    names to implement the same algorithm with different types. Using `int64` and
    `uint64` meant that you could write the code once and let callers use type conversions
    to pass values in and convert data that’s returned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到遗留代码，其中有一对函数完成相同的任务，但一个使用`int64`作为参数和变量的类型，另一个使用`uint64`。原因是API在Go添加泛型之前创建的。没有泛型，你需要编写带有稍微不同名称的函数来使用不同类型实现相同的算法。使用`int64`和`uint64`意味着你可以编写一次代码，让调用者使用类型转换来传递值并转换返回的数据。
- en: You can see this pattern in the Go standard library within the functions `FormatInt`
    and `FormatUint` in the `strconv` package.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`strconv`包中的函数`FormatInt`和`FormatUint`中看到这种模式，它们在Go标准库中。
- en: Integer operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数运算符
- en: 'Go integers support the usual arithmetic operators: +, `-`, `*`, `/`, with
    `%` for modulus. The result of an integer division is an integer; if you want
    to get a floating-point result, you need to use a type conversion to make your
    integers into floating-point numbers. Also, be careful not to divide an integer
    by 0; this causes a panic (I talk more about panics in [“panic and recover”](ch09.html#panic_recover)).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go整数支持通常的算术运算符：+、`-`、`*`、`/`，使用`%`进行模运算。整数除法的结果是整数；如果要获得浮点结果，需要使用类型转换将整数转换为浮点数。另外，要小心不要将整数除以0；这会导致恐慌（我在[“panic和recover”](ch09.html#panic_recover)中更详细地讨论恐慌）。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Integer division in Go follows truncation toward zero; see the Go spec’s section
    on [arithmetic operators](https://oreil.ly/zp3OJ) for the full details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的整数除法向零截断；详细信息请参见Go规范中关于[算术运算符](https://oreil.ly/zp3OJ)的部分。
- en: 'You can combine any of the arithmetic operators with `=` to modify a variable:
    `+=`, `-=`, `*=`, `/=`, and `%=`. For example, the following code results in `x`
    having the value 20:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何算术运算符与`=`结合使用来修改变量：`+=`、`-=`、`*=`、`/=`和`%=`。例如，以下代码的结果是变量`x`的值为20：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You compare integers with `==`, `!=`, `>`, `>=`, `<`, and `<=`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`==`、`!=`、`>`、`>=`、`<`和`<=`比较整数。
- en: 'Go also has bit-manipulation operators for integers. You can bit shift left
    and right with `<<` and `>>`, or do bit masks with `&` (bitwise AND), `|` (bitwise
    OR), `^` (bitwise XOR), and `&^` (bitwise AND NOT). As with the arithmetic operators,
    you can also combine all the bitwise operators with `=` to modify a variable:
    `&=`, `|=`, `^=`, `&^=`, `<<=`, and `>>=`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go还为整数提供了位操作运算符。你可以使用`<<`和`>>`进行位左移和右移，或者使用`&`（按位与）、`|`（按位或）、`^`（按位异或）和`&^`（按位与非）进行位掩码操作。与算术运算符一样，你也可以将所有位操作符与`=`结合使用来修改变量：`&=`、`|=`、`^=`、`&^=`、`<<=`和`>>=`。
- en: Floating-point types
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型
- en: Go has two floating-point types, as shown in [Table 2-2](#table2_2).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种浮点类型，如[表2-2](#table2_2)所示。
- en: Table 2-2\. The floating-point types in Go
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. Go中的浮点类型
- en: '| Type name | Largest absolute value | Smallest (nonzero) absolute value |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 类型名称 | 最大绝对值 | 最小（非零）绝对值 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `float32` | 3.40282346638528859811704183484516925440e+38 | 1.401298464324817070923729583289916131280e-45
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 3.40282346638528859811704183484516925440e+38 | 1.401298464324817070923729583289916131280e-45
    |'
- en: '| `float64` | 1.797693134862315708145274237317043567981e+308 | 4.940656458412465441765687928682213723651e-324
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | 1.797693134862315708145274237317043567981e+308 | 4.940656458412465441765687928682213723651e-324
    |'
- en: Like the integer types, the zero value for the floating-point types is 0.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像整数类型一样，浮点类型的零值是0。
- en: 'Floating point in Go is similar to floating-point math in other languages.
    Go uses the IEEE 754 specification, giving a large range and limited precision.
    Picking which floating-point type to use is straightforward: unless you have to
    be compatible with an existing format, use `float64`. Floating-point literals
    have a default type of `float64`, so always using `float64` is the simplest option.
    It also helps mitigate floating-point accuracy issues since a `float32` has only
    six- or seven-decimal digits of precision. Don’t worry about the difference in
    memory size unless you have used the profiler to determine that it is a significant
    source of problems. (Testing and profiling are covered in [Chapter 15](ch15.html#unique_chapter_id_15).)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的浮点数与其他语言的浮点数类似。Go语言使用IEEE 754规范，提供了大范围和有限精度。选择使用哪种浮点类型很简单：除非必须与现有格式兼容，否则使用`float64`。浮点数字面量的默认类型是`float64`，因此始终使用`float64`是最简单的选项。它还有助于减少浮点数精度问题，因为`float32`只有六到七位小数的精度。除非已使用分析器确定它是问题的重要来源，否则不必担心内存大小的差异（测试和分析详见[第15章](ch15.html#unique_chapter_id_15)）。
- en: The bigger question is whether you should be using a floating-point number at
    all. In many cases, the answer is no. Just like other languages, Go floating-point
    numbers have a huge range, but they cannot store every value in that range; they
    store the nearest approximation. Because floats aren’t exact, they can be used
    only in situations where inexact values are acceptable or the rules of floating
    point are well understood. That limits them to things like graphics, statistics,
    and scientific operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的问题是是否应该完全使用浮点数。在许多情况下，答案是否定的。就像其他语言一样，Go语言的浮点数有很大的范围，但不能存储该范围内的每个值；它们存储最接近的近似值。由于浮点数不是精确的，它们只能在可以接受不精确值或者浮点数规则已充分理解的情况下使用。这限制了它们的使用范围，例如图形、统计和科学操作。
- en: Warning
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A floating-point number cannot represent a decimal value exactly. Do not use
    them to represent money or any other value that must have an exact decimal representation!
    You’ll look at a third-party module for handling exact decimal values in [“Importing
    Third-Party Code”](ch10.html#import_third_party).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数不能精确表示小数值。不要用它们来表示货币或任何其他必须有精确小数表示的值！在[“导入第三方代码”](ch10.html#import_third_party)中，您将查看一个处理精确小数值的第三方模块。
- en: You can use all the standard mathematical and comparison operators with floats,
    except `%`. Floating-point division has a couple of interesting properties. Dividing
    a nonzero floating-point variable by 0 returns `+Inf` or `-Inf` (positive or negative
    infinity), depending on the sign of the number. Dividing a floating-point variable
    set to 0 by 0 returns `NaN` (Not a Number).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用所有标准的数学和比较运算符处理浮点数，除了 `%`。浮点数除法有一些有趣的特性。将非零浮点变量除以0会返回`+Inf`或`-Inf`（正无穷或负无穷），取决于数字的符号。将设置为0的浮点变量除以0会返回`NaN`（非数值）。
- en: While Go lets you use `==` and `!=` to compare floats, don’t do it. Because
    of the inexact nature of floats, two floating-point values might not be equal
    when you think they should be. Instead, define a maximum allowed variance and
    see if the difference between two floats is less than that. This value (sometimes
    called *epsilon*) depends on your accuracy needs; I can’t give you a simple rule.
    If you aren’t sure, consult your friendly local mathematician for advice. If you
    can’t find one, [The Floating Point Guide has a “Comparison” page](https://oreil.ly/n9ws3)
    that can help you out (or possibly convince you to avoid floating-point numbers
    unless absolutely necessary).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go允许你使用`==`和`!=`来比较浮点数，但最好不要这样做。由于浮点数的不精确性，两个浮点数可能在你认为它们应该相等时不相等。相反，定义一个允许的最大差异，并查看两个浮点数之间的差异是否小于该值。这个值（有时称为*epsilon*）取决于你的精度需求；我无法给你一个简单的规则。如果不确定，建议咨询你附近友好的数学家。如果找不到，请参考[The
    Floating Point Guide 的“Comparison”页面](https://oreil.ly/n9ws3)，它可以帮助你（或可能说服你除非绝对必要，否则避免使用浮点数）。
- en: Complex types (you’re probably not going to use these)
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂类型（你可能不会使用这些）
- en: There is one more numeric type and it is pretty unusual. Go has first-class
    support for complex numbers. If you don’t know what complex numbers are, you are
    not the target audience for this feature; feel free to skip ahead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种数值类型，非常不寻常。Go对复数有一流支持。如果你不知道复数是什么，那你不是这个特性的目标用户；可以跳过这部分。
- en: 'There isn’t a lot to the complex number support in Go. Go defines two complex
    number types. `complex64` uses `float32` values to represent the real and imaginary
    part, and `complex128` uses `float64` values. Both are declared with the `complex`
    built-in function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，复数支持并不复杂。Go定义了两种复数类型。`complex64`使用`float32`值表示实部和虚部，而`complex128`使用`float64`值。两者都可以使用内置函数`complex`进行声明：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go uses a few rules to determine the type of the value returned by `complex`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用几条规则来确定`complex`函数返回值的类型：
- en: If you use untyped constants or literals for both function parameters, you’ll
    create an untyped complex literal, which has a default type of `complex128`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对函数参数同时使用未类型化的常量或字面量，将创建一个未类型化的复数字面量，默认类型为`complex128`。
- en: If both values passed into `complex` are of `float32` type, you’ll create a
    `complex64`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`complex`函数的两个值都是`float32`类型，将创建一个`complex64`。
- en: If one value is a `float32` and the other value is an untyped constant or literal
    that can fit within a `float32`, you’ll create a `complex64`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个值是`float32`，另一个值是可以适应`float32`的未类型化常量或字面量，则将创建一个`complex64`。
- en: Otherwise, you’ll create a `complex128`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将创建一个`complex128`。
- en: All the standard floating-point arithmetic operators work on complex numbers.
    Just as with floats, you can use `==` or `!=` to compare them, but they have the
    same precision limitations, so it’s best to use the epsilon technique. You can
    extract the real and imaginary portions of a complex number with the `real` and
    `imag` built-in functions, respectively. The `math/cmplx` package has additional
    functions for manipulating `complex128` values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准的浮点运算符都可以用于复数。与浮点数一样，你可以使用`==`或`!=`进行比较，但它们有相同的精度限制，因此最好使用 epsilon 技术。你可以使用内置函数`real`和`imag`分别提取复数的实部和虚部。`math/cmplx`包提供了额外的函数来操作`complex128`值。
- en: The zero value for both types of complex numbers has 0 assigned to both the
    real and imaginary portions of the number.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两种复数类型的零值都将实部和虚部分别赋值为0。
- en: '[Example 2-1](#EX2_4) shows a simple program that demonstrates how complex
    numbers work. You can run it for yourself on [The Go Playground](https://oreil.ly/fuyIu)
    or in the *sample_code/complex_numbers* directory in the [Chapter 2 repository](https://oreil.ly/zXZqI).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-1](#EX2_4) 展示了一个简单的程序，演示了复数的工作原理。你可以在[The Go Playground](https://oreil.ly/fuyIu)上自行运行它，或者在[第2章存储库](https://oreil.ly/zXZqI)的*sample_code/complex_numbers*目录中查看它。'
- en: Example 2-1\. Complex numbers
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 2-1\. 复数
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this code gives you the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会得到以下结果：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see floating-point imprecision on display here too.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到浮点数不精确性在这里展示出来。
- en: In case you were wondering what the fifth kind of primitive literal was, Go
    supports imaginary literals to represent the imaginary portion of a complex number.
    They look just like floating-point literals, but they have an `i` for a suffix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道第五种原始字面量是什么，Go支持虚数字面量来表示复数的虚部。它们看起来像浮点字面量，但后缀为`i`。
- en: Despite having complex numbers as a predeclared type, Go is not a popular language
    for numerical computing. Adoption has been limited because other features (like
    matrix support) are not part of the language and libraries have to use inefficient
    replacements, like slices of slices. (You’ll look at slices in [Chapter 3](ch03.html#unique_chapter_id_03)
    and how they are implemented in [Chapter 6](ch06.html#unique_chapter_id_06).)
    But if you need to calculate a Mandelbrot set as part of a larger program, or
    implement a quadratic equation solver, complex number support is there for you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go语言作为预声明类型拥有复数，但并不是流行的数值计算语言。采用受限，因为其他特性（如矩阵支持）不是语言的一部分，而库必须使用效率低下的替代品，比如切片的切片。
    （您将在[第3章](ch03.html#unique_chapter_id_03)中查看切片及其在[第6章](ch06.html#unique_chapter_id_06)中的实现。）但是，如果您需要在较大程序的一部分中计算Mandelbrot集，或者实现二次方程求解器，复数支持在这里为您提供帮助。
- en: 'You might be wondering why Go includes complex numbers. The answer is simple:
    Ken Thompson, one of the creators of Go (and Unix), thought they would be [interesting](https://oreil.ly/eBmkq).
    There has been discussion about [removing complex numbers](https://oreil.ly/Q76EV)
    from a future version of Go, but it’s easier to just ignore the feature.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么Go语言包括复数。答案很简单：Ken Thompson，Go语言（和Unix）的创造者之一，认为它们会很[有趣](https://oreil.ly/eBmkq)。有关从Go的未来版本中[移除复数](https://oreil.ly/Q76EV)的讨论，但忽略这一功能会更容易。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you do want to write numerical computing applications in Go, you can use
    the third-party [Gonum](https://www.gonum.org) package. It takes advantage of
    complex numbers and provides useful libraries for things like linear algebra,
    matrices, integration, and statistics. But you should consider other languages
    first.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实希望在Go中编写数值计算应用程序，可以使用第三方[Gonum](https://www.gonum.org)包。它利用复数，并为线性代数、矩阵、积分和统计等提供有用的库。但您应该首先考虑其他语言。
- en: A Taste of Strings and Runes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串和符文的味道
- en: This brings us to strings. Like most modern languages, Go includes strings as
    a built-in type. The zero value for a string is the empty string. Go supports
    Unicode; as I showed [“Literals”](#goliterals), you can put any Unicode character
    into a string. Like integers and floats, strings are compared for equality using
    `==`, difference with `!=`, or ordering with `>`, `>=`, `<`, or `<=`. They are
    concatenated by using the `+` operator.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来谈谈字符串。像大多数现代语言一样，Go语言将字符串作为内置类型。字符串的零值是空字符串。Go支持Unicode；正如我展示的[“文字”](#goliterals)，你可以在字符串中放入任何Unicode字符。像整数和浮点数一样，字符串使用`==`比较是否相等，使用`!=`比较是否不等，使用`>`、`>=`、`<`或`<=`进行排序。它们通过`+`运算符进行连接。
- en: Strings in Go are immutable; you can reassign the value of a string variable,
    but you cannot change the value of the string that is assigned to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的字符串是不可变的；您可以重新分配字符串变量的值，但不能更改分配给它的字符串的值。
- en: Go also has a type that represents a single code point. The *rune* type is an
    alias for the `int32` type, just as `byte` is an alias for `uint8`. As you could
    probably guess, a rune literal’s default type is a rune, and a string literal’s
    default type is a string.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go还有一种表示单个代码点的类型。*符文*类型是`int32`类型的别名，就像`byte`是`uint8`的别名一样。正如您可能猜到的那样，符文文字的默认类型是符文，字符串文字的默认类型是字符串。
- en: 'If you are referring to a character, use the rune type, not the `int32` type.
    They might be the same to the compiler, but you want to use the type that clarifies
    the intent of your code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您引用字符，请使用rune类型，而不是`int32`类型。它们可能对编译器来说是相同的，但您应该使用能够澄清代码意图的类型：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I am going to talk a lot more about strings in the next chapter, covering some
    implementation details, relationships with bytes and runes, as well as advanced
    features and pitfalls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一章节中详细讨论字符串，涵盖一些实现细节、与字节和符文的关系，以及高级功能和陷阱。
- en: Explicit Type Conversion
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式类型转换
- en: Most languages that have multiple numeric types automatically convert from one
    to another when needed. This is called *automatic type promotion*, and while it
    seems very convenient, it turns out that the rules to properly convert one type
    to another can get complicated and produce unexpected results. As a language that
    values clarity of intent and readability, Go doesn’t allow automatic type promotion
    between variables. You must use a *type conversion* when variable types do not
    match. Even different-sized integers and floats must be converted to the same
    type to interact. This makes it clear exactly what type you want without having
    to memorize any type conversion rules (see [Example 2-2](#EX2_1)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数具有多个数字类型的语言在需要时会自动从一个类型转换为另一个类型。这称为*自动类型提升*，虽然它看起来非常方便，但事实证明，正确转换一个类型到另一个类型的规则可能会变得复杂并产生意外结果。作为一种重视意图清晰性和可读性的语言，Go
    不允许在变量之间进行自动类型提升。当变量类型不匹配时，必须使用*类型转换*。即使是不同大小的整数和浮点数也必须转换为相同类型以进行交互。这清楚地表明您需要的确切类型，而无需记住任何类型转换规则（见
    [示例 2-2](#EX2_1)）。
- en: Example 2-2\. Type conversions
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 类型转换
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this sample code, you define four variables. `x` is an `int` with the value
    10, and `y` is a `float64` with the value 30.2\. Since these are not identical
    types, you need to convert them to add them together. For `sum1`, you convert
    `x` to a `float64` using a `float64` type conversion, and for `sum2`, you convert
    `y` to an `int` using an `int` type conversion. When you run this code, it prints
    out 40.2 40.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，您定义了四个变量。`x` 是一个值为 10 的 `int`，`y` 是一个值为 30.2 的 `float64`。由于它们不是相同的类型，您需要将它们转换为同一类型以进行相加。对于
    `sum1`，您使用 `float64` 类型转换将 `x` 转换为 `float64`，对于 `sum2`，您使用 `int` 类型转换将 `y` 转换为
    `int`。当您运行此代码时，它会打印出 40.2 40。
- en: The same behavior applies with different-sized integer types (see [Example 2-3](#EX2_1a)).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同一行为适用于不同大小的整数类型（见 [示例 2-3](#EX2_1a)）。
- en: Example 2-3\. Integer type conversions
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. 整数类型转换
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can run these examples on [The Go Playground](https://oreil.ly/VoE7H) or
    in the *sample_code/type_conversion* directory in the [Chapter 2 repository](https://oreil.ly/dGtos).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [Go Playground](https://oreil.ly/VoE7H) 上运行这些示例，或者在 [第2章存储库](https://oreil.ly/dGtos)
    中的 *sample_code/type_conversion* 目录中运行。
- en: This strictness around types has other implications. Since all type conversions
    in Go are explicit, you cannot treat another Go type as a boolean. In many languages,
    a nonzero number or a nonempty string can be interpreted as a boolean `true`.
    Just like automatic type promotion, the rules for “truthy” values vary from language
    to language and can be confusing. Unsurprisingly, Go doesn’t allow truthiness.
    In fact, *no other type can be converted to a bool, implicitly or explicitly*.
    If you want to convert from another data type to boolean, you must use one of
    the comparison operators (`==`, `!=`, `>`, `<`, `<=`, or `>=`). For example, to
    check if variable `x` is equal to 0, the code would be `x == 0`. If you want to
    check if string `s` is empty, use `s == ""`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕类型的严格性还有其他影响。由于 Go 中的所有类型转换都是显式的，您不能将另一种 Go 类型视为布尔值。在许多语言中，非零数字或非空字符串可以解释为布尔值
    `true`。就像自动类型提升一样，“真值”值得从语言到语言的规则有所不同，这可能会令人困惑。不足为奇，Go 不允许真值。事实上，*没有其他类型可以被隐式或显式地转换为布尔型*。如果要将另一种数据类型转换为布尔型，必须使用其中一个比较运算符（`==`、`!=`、`>`、`<`、`<=`
    或 `>=`）。例如，要检查变量 `x` 是否等于 0，代码将是 `x == 0`。如果要检查字符串 `s` 是否为空，请使用 `s == ""`。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Type conversions are one of the places where Go chooses to add a little verbosity
    in exchange for a great deal of simplicity and clarity. You’ll see this trade-off
    multiple times. Idiomatic Go values comprehensibility over conciseness.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是 Go 中选择在一定程度上增加冗余性以换取简洁性和清晰度的地方之一。您会多次看到这种权衡。惯用的 Go 更看重可理解性而不是简洁性。
- en: Literals Are Untyped
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字量没有类型
- en: 'While you can’t add two integer variables together if they are declared to
    be of different types of integers, Go lets you use an integer literal in floating-point
    expressions or even assign an integer literal to a floating-point variable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您不能将两个声明为不同类型整数的整数变量相加，但是 Go 允许您在浮点表达式中使用整数字面量，甚至将整数字面量赋值给浮点变量：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is because, as I mentioned earlier, literals in Go are untyped. Go is a
    practical language, and it makes sense to avoid forcing a type until the developer
    specifies one. This means they can be used with any variable whose type is compatible
    with the literal. When you look at user-defined types in [Chapter 7](ch07.html#unique_chapter_id_07),
    you’ll see that you can even use literals with user-defined types based on predefined
    types. Being untyped goes only so far; you can’t assign a literal string to a
    variable with a numeric type or a literal number to a string variable, nor can
    you assign a float literal to an `int`. These are all flagged by the compiler
    as errors. Size limitations also exist; while you can write numeric literals that
    are larger than any integer can hold, it is a compile-time error to try to assign
    a literal whose value overflows the specified variable, such as trying to assign
    the literal 1000 to a variable of type `byte`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，正如我之前提到的，Go中的文字都是无类型的。Go是一门实用的语言，推迟类型指定是有意义的。这意味着它们可以与任何类型兼容的变量一起使用。当你在[第7章](ch07.html#unique_chapter_id_07)看到用户定义的类型时，你会发现甚至可以在预定义类型的基础上使用文字。无类型的能力有限；你不能将文字串赋给数字类型的变量，或将文字数字赋给字符串变量，也不能将浮点文字赋给`int`。这些都会被编译器标记为错误。还存在大小限制；虽然你可以写比任何整数都大的数字文字，但如果试图将其分配给超出指定变量的值的文字，例如将文字1000分配给`byte`类型的变量，编译时会出错。
- en: var Versus :=
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`var`与`:=`的比较：'
- en: 'For a small language, Go has a lot of ways to declare variables. There’s a
    reason for this: each declaration style communicates something about how the variable
    is used. Let’s go through the ways you can declare a variable in Go and see when
    each is appropriate.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一门小语言来说，Go有很多声明变量的方法。这背后有一个原因：每种声明风格都传达了关于变量如何使用的信息。让我们逐一介绍在Go中声明变量的方法，并看看每种方法何时适用。
- en: 'The most verbose way to declare a variable in Go uses the `var` keyword, an
    explicit type, and an assignment. It looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中声明变量的最冗长方式使用`var`关键字，显式类型和赋值。它看起来像这样：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the type on the righthand side of the `=` is the expected type of your variable,
    you can leave off the type from the left side of the `=`. Since the default type
    of an integer literal is `int`, the following declares `x` to be a variable of
    type `int`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`=`右侧的类型是你变量的预期类型，你可以在`=`左侧省略类型。由于整数文字的默认类型是`int`，以下声明`x`为类型为`int`的变量：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Conversely, if you want to declare a variable and assign it the zero value,
    you can keep the type and drop the `=` on the righthand side:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你想声明一个变量并将其赋值为零值，可以保留类型并在右侧省略`=`：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can declare multiple variables at once with `var`, and they can be of the
    same type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`var`一次声明多个变量，它们可以是相同类型的：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can declare all zero values of the same type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明同一类型的所有零值：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'or of different types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者不同类型的：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There’s one more way to use `var`. If you are declaring multiple variables
    at once, you can wrap them in a *declaration list*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种使用`var`的方法。如果你一次声明多个变量，可以将它们包装在*声明列表*中：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Go also supports a short declaration and assignment format. When you are within
    a function, you can use the `:=` operator to replace a `var` declaration that
    uses type inference. The following two statements do exactly the same thing—they
    declare `x` to be an `int` with the value of 10:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持一种短声明和赋值格式。当你在函数内部时，可以使用`:=`运算符来替代使用类型推断的`var`声明。以下两个语句完全相同——它们声明`x`为`int`，其值为10：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As with `var`, you can declare multiple variables at once using `:=`. These
    two lines both assign 10 to `x` and “hello” to `y`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 像`var`一样，你可以使用`:=`一次声明多个变量。以下两行都将10赋给`x`，将“hello”赋给`y`：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `:=` operator can do one trick that you cannot do with `var`: it allows
    you to assign values to existing variables too. As long as at least one new variable
    is on the lefthand side of the `:=`, any of the other variables can already exist:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`:=`运算符可以做一件`var`做不到的事情：它允许你对已存在的变量赋值。只要`:=`的左侧至少有一个新变量，其他任何变量都可以已经存在：'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using `:=` has one limitation. If you are declaring a variable at the package
    level, you must use `var` because `:=` is not legal outside of functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:=`有一个限制。如果你在包级别声明一个变量，你必须使用`var`，因为在函数外部使用`:=`是不合法的。
- en: How do you know which style to use? As always, choose what makes your intent
    clearest. The most common declaration style within functions is `:=`. Outside
    of a function, use declaration lists on the rare occasions when you are declaring
    multiple package-level variables.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道使用哪种风格？一如既往，选择能最清晰表达你意图的方式。在函数内部最常见的声明风格是 `:=`。在函数外部，仅在罕见情况下声明多个包级变量时才使用声明列表。
- en: 'In some situations within functions, you should avoid `:=`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些函数内部的情况下，应避免使用 `:=`：
- en: When initializing a variable to its zero value, use `var x int`. This makes
    it clear that the zero value is intended.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将变量初始化为其零值时，请使用 `var x int`。这样可以明确表明零值是有意为之的。
- en: When assigning an untyped constant or a literal to a variable and the default
    type for the constant or literal isn’t the type you want for the variable, use
    the long `var` form with the type specified. While it is legal to use a type conversion
    to specify the type of the value and use `:=` to write `x := byte(20)`, it is
    idiomatic to write `var x byte = 20`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将无类型常量或文本分配给变量时，如果默认类型不是你想要的变量类型，请使用带有指定类型的长形式 `var`。虽然使用类型转换来指定值的类型并使用 `:=`
    来写 `x := byte(20)` 是合法的，但习惯上写成 `var x byte = 20`。
- en: Because `:=` allows you to assign to both new and existing variables, it sometimes
    creates new variables when you think you are reusing existing ones (see [“Shadowing
    Variables”](ch04.html#shadowing) for details). In those situations, explicitly
    declare all your new variables with `var` to make it clear which variables are
    new, and then use the assignment operator (`=`) to assign values to both new and
    old variables.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `:=` 允许你对新变量和现有变量进行赋值，有时当你认为在重用现有变量时它会创建新变量（详见[“变量屏蔽”](ch04.html#shadowing)）。在这些情况下，使用
    `var` 显式声明所有新变量，以明确表明哪些变量是新的，然后使用赋值运算符 (`=`) 为新变量和旧变量赋值。
- en: While `var` and `:=` allow you to declare multiple variables on the same line,
    use this style only when assigning multiple values returned from a function or
    the comma ok idiom (see [Chapter 5](ch05.html#unique_chapter_id_05) and [“The
    comma ok Idiom”](ch03.html#comma_ok_section)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `var` 和 `:=` 允许在同一行上声明多个变量，但仅在从函数返回多个值或使用逗号 ok 惯用法时使用这种风格（参见[第 5 章](ch05.html#unique_chapter_id_05)
    和 [“逗号 ok 惯用法”](ch03.html#comma_ok_section)）。
- en: You should rarely declare variables outside of functions, in what’s called the
    *package block* (see [“Blocks”](ch04.html#blocks)). Package-level variables whose
    values change are a bad idea. When you have a variable outside of a function,
    it can be difficult to track the changes made to it, which makes it hard to understand
    how data is flowing through your program. This can lead to subtle bugs. As a general
    rule, you should only declare variables in the package block that are effectively
    immutable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很少在函数外部声明变量，即所谓的*包块*（参见[“块”](ch04.html#blocks)）。值会改变的包级变量是一个坏主意。当你在函数外部有一个变量时，很难追踪其所做的更改，这使得理解数据如何在程序中流动变得困难。这可能导致隐含的错误。一般规则是，只在包块中声明那些实际上是不可变的变量。
- en: Tip
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid declaring variables outside of functions because they complicate data
    flow analysis.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在函数外部声明变量，因为它们会使数据流分析变得复杂。
- en: 'You might be wondering: does Go provide a way to *ensure* that a value is immutable?
    It does, but it is a bit different from what you may have seen in other programming
    languages. It’s time to learn about `const`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道：Go 是否提供了确保值不可变的方法？答案是肯定的，但它与你在其他编程语言中见过的方式有些不同。现在是学习 `const` 的时候了。
- en: Using const
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `const`
- en: Many languages have a way to declare a value as immutable. In Go, this is done
    with the `const` keyword. At first glance, it seems to work exactly as it would
    in other languages. Try out the code in [Example 2-4](#EX2_7) on [The Go Playground](https://oreil.ly/FdG-W)
    or in the *sample_code/const_declaration* directory in the [Chapter 2 repository](https://oreil.ly/QxTTT).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言都有一种声明值为不可变的方法。在 Go 中，可以使用 `const` 关键字实现。乍一看，它似乎与其他语言中的方式完全相同。尝试在[示例 2-4](#EX2_7)中的代码中使用
    [Go Playground](https://oreil.ly/FdG-W) 或 [第 2 章存储库](https://oreil.ly/QxTTT) 中的
    *sample_code/const_declaration* 目录。
- en: Example 2-4\. `const` declarations
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. `const` 声明
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run this code, compilation fails with the following error messages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，编译会失败，并显示以下错误消息：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you see, you declare a constant at the package level or within a function.
    Just as with `var`, you can (and should) declare a group of related constants
    within a set of parentheses.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以在包级别或函数内部声明一个常量。与 `var` 类似，你可以（也应该）在一组括号中声明一组相关的常量。
- en: 'Be aware that `const` in Go is very limited. Constants in Go are a way to give
    names to literals. They can only hold values that the compiler can figure out
    at compile time. This means that they can be assigned:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Go 中，`const` 的功能非常有限。Go 中的常量是将文字值命名的一种方式。它们只能保存编译器在编译时能够确定的值。这意味着它们可以被分配：
- en: Numeric literals
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字文字值
- en: '`true` and `false`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true` 和 `false`'
- en: Strings
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Runes
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Runes
- en: The values returned by the built-in functions `complex`, `real`, `imag`, `len`,
    and `cap`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内建函数 `complex`、`real`、`imag`、`len` 和 `cap` 返回的值
- en: Expressions that consist of operators and the preceding values
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由操作符和前置值组成的表达式
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I’ll cover the `len` and `cap` functions in the next chapter. Another value
    that can be used with `const` is called `iota`. I’ll talk about `iota` when I
    discuss creating your own types in [Chapter 7](ch07.html#unique_chapter_id_07).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一章中介绍 `len` 和 `cap` 函数。可以与 `const` 一起使用的另一个值称为 `iota`。在讨论在 [Chapter 7](ch07.html#unique_chapter_id_07)
    中创建自己的类型时，我会谈到 `iota`。
- en: 'Go doesn’t provide a way to specify that a value calculated at runtime is immutable.
    For example, the following code will fail to compile with the error `x + y (value
    of type int) is not constant`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不提供在运行时指定计算出的值为不可变的方法。例如，以下代码将无法编译，错误信息为 `x + y (value of type int) is not
    constant`：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you’ll see in the next chapter, there are no immutable arrays, slices, maps,
    or structs, and there’s no way to declare that a field in a struct is immutable.
    This is less limiting than it sounds. Within a function, it is clear if a variable
    is being modified, so immutability is less important. In [“Go Is Call by Value”](ch05.html#call_value),
    you’ll see how Go prevents modifications to variables that are passed as parameters
    to functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章中看到的那样，Go 中没有不可变的数组、切片、映射或结构体，也无法声明结构体中的字段为不可变。这比听起来的限制要少。在函数内部，如果变量被修改，这是明确的，因此不可变性不那么重要。在
    [“Go Is Call by Value”](ch05.html#call_value) 中，你将看到 Go 如何防止对作为参数传递给函数的变量进行修改。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Constants in Go are a way to give names to literals. There is *no* way in Go
    to declare that a variable is immutable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，常量是将文字值命名的一种方式。在 Go 中，没有方法可以声明一个变量是不可变的。
- en: Typed and Untyped Constants
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化和非类型化常量
- en: Constants can be typed or untyped. An untyped constant works exactly like a
    literal; it has no type of its own but does have a default type that is used when
    no other type can be inferred. A typed constant can be directly assigned only
    to a variable of that type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 常量可以是类型化的或非类型化的。非类型化的常量与文字值完全相同；它没有自己的类型，但在无法推断出其他类型时使用默认类型。类型化常量只能直接分配给该类型的变量。
- en: Whether to make a constant typed depends on why the constant was declared. If
    you are giving a name to a mathematical constant that could be used with multiple
    numeric types, keep the constant untyped. In general, leaving a constant untyped
    gives you more flexibility. In certain situations, you’ll want a constant to enforce
    a type. You’ll see a use for typed constants when I cover enumerations with `iota`
    in [“iota Is for Enumerations—Sometimes”](ch07.html#iota_section).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使常量类型化取决于常量声明的原因。如果你为一个可能与多种数值类型一起使用的数学常量命名，保持常量为非类型化是合适的。通常情况下，保持常量为非类型化可以提供更大的灵活性。在某些情况下，你会希望常量强制类型化。当我在
    [“iota Is for Enumerations—Sometimes”](ch07.html#iota_section) 中讨论使用 `iota` 进行枚举时，你将看到一种对类型化常量的用法。
- en: 'Here’s what an untyped constant declaration looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是非类型化常量声明的样子：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All of the following assignments are legal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有的赋值都是合法的：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s what a typed constant declaration looks like:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是类型化常量声明的样子：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This constant can be assigned directly only to an `int`. Assigning it to any
    other type produces a compile-time error like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常量只能直接分配给一个 `int`。将其分配给任何其他类型会产生编译时错误，如下所示：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unused Variables
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未使用的变量
- en: One of the goals for Go is to make it easier for large teams to collaborate
    on programs. To do so, Go has some rules that are unique among programming languages.
    In [Chapter 1](ch01.html#unique_chapter_id_01), you saw that Go programs need
    to be formatted in a specific way with `go fmt` to make it easier to write code-manipulation
    tools and to provide coding standards. Another Go requirement is that *every declared
    local variable must be read*. It is a *compile-time error* to declare a local
    variable and to not read its value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Go的一个目标是使大型团队更容易协作开发程序。为此，Go有一些编程语言中独特的规则。在[第一章](ch01.html#unique_chapter_id_01)中，你看到Go程序需要使用`go
    fmt`按照特定方式格式化，以便更轻松地编写代码操作工具并提供编码标准。另一个Go的要求是*每个声明的局部变量都必须被读取*。声明局部变量但不读取其值是*编译时错误*。
- en: 'The compiler’s unused variable check is not exhaustive. As long as a variable
    is read once, the compiler won’t complain, even if there are writes to the variable
    that are never read. The following is a valid Go program that you can run on [The
    Go Playground](https://oreil.ly/8JLA6) or in the *sample_code/assignments_not_read*
    directory in the [Chapter 2 repository](https://oreil.ly/FqALl):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器对未使用的变量检查并不彻底。只要变量被读取一次，编译器就不会抱怨，即使有写入变量而从未被读取的情况。你可以在[Go Playground](https://oreil.ly/8JLA6)上或[第二章存储库](https://oreil.ly/FqALl)的*sample_code/assignments_not_read*目录中运行以下有效的Go程序：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While the compiler and `go vet` do not catch the unused assignments of 10 and
    30 to `x`, third-party tools can detect them. I’ll talk about these tools in [“Using
    Code-Quality Scanners”](ch11.html#code_quality).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编译器和`go vet`不能捕获对`x`分配值为10和30的未使用情况，但第三方工具可以检测到它们。我会在[“使用代码质量扫描工具”](ch11.html#code_quality)中讨论这些工具。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Go compiler won’t stop you from creating unread package-level variables.
    This is one more reason you should avoid creating package-level variables.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go编译器不会阻止你创建未读的包级别变量。这是你应该避免创建包级别变量的另一个理由。
- en: Naming Variables and Constants
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名变量和常量
- en: There is a difference between Go’s rules for naming variables and the patterns
    that Go developers follow when naming their variables and constants. Like most
    languages, Go requires identifier names to start with a letter or underscore,
    and the name can contain numbers, underscores, and letters. Go’s definition of
    “letter” and “number” is a bit broader than many languages. Any Unicode character
    considered a letter or digit is allowed. This makes all the variable definitions
    in [Example 2-5](#EX1) perfectly valid Go.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Go对命名变量的规则与Go开发者在命名变量和常量时遵循的模式之间存在差异。与大多数语言一样，Go要求标识符名称以字母或下划线开头，名称可以包含数字、下划线和字母。Go对“字母”和“数字”的定义比许多语言宽泛一些。任何被认为是字母或数字的Unicode字符都是允许的。这使得[示例 2-5](#EX1)中所有变量定义都是完全有效的Go代码。
- en: Example 2-5\. Variable names you should never use
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 绝对不应该使用的变量名
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can test out this awful code on [The Go Playground](https://oreil.ly/VIYOk).
    While it works, *do not* use variable names like this. These names are considered
    nonidiomatic because they break the fundamental rule of making sure that your
    code communicates what it is doing. These names are confusing or difficult to
    type on many keyboards. Look-alike Unicode code points are the most insidious,
    because even if they appear to be the same character, they represent entirely
    different variables. You can run the code shown in [Example 2-6](#EX2_10) on [The
    Go Playground](https://oreil.ly/hrvb6) or in the *sample_code/look_alike_code_points*
    directory in the [Chapter 2 repository](https://oreil.ly/7nLfx).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Go Playground](https://oreil.ly/VIYOk)上测试这段糟糕的代码。虽然它可以工作，但*不要*使用这样的变量名。这些名称被认为不符合习惯，因为它们违反了确保代码传达其功能的基本规则。这些名称令人困惑，或在许多键盘上难以输入。类似的Unicode代码点是最阴险的，因为即使它们看起来是相同的字符，它们代表的是完全不同的变量。你可以在[Go
    Playground](https://oreil.ly/hrvb6)上或[第二章存储库](https://oreil.ly/7nLfx)的*sample_code/look_alike_code_points*目录中运行所示代码。
- en: Example 2-6\. Using look-alike code points for variable names
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 使用类似代码点作为变量名
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you run this program, you get:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though the underscore is a valid character in a variable name, it is rarely
    used, because idiomatic Go doesn’t use snake case (names like `index_counter`
    or `number_tries`). Instead, idiomatic Go uses camel case (names like `indexCounter`
    or `numberTries`) when an identifier name consists of multiple words.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使下划线在变量名中是有效的字符，但它很少被使用，因为 Go 语言习惯不使用蛇形命名法（例如 `index_counter` 或 `number_tries`）。相反，Go
    语言习惯使用驼峰命名法（例如 `indexCounter` 或 `numberTries`），当标识符名称由多个单词组成时。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An underscore by itself (`_`) is a special identifier name in Go; I’ll talk
    more about it when I cover functions in [Chapter 5](ch05.html#unique_chapter_id_05).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，下划线本身 (`_`) 是一个特殊的标识符名称；在讲解第 5 章（[Chapter 5](ch05.html#unique_chapter_id_05)）中函数时，我会更详细地讨论它。
- en: In many languages, constants are always written in all uppercase letters, with
    words separated by underscores (names like `INDEX_COUNTER` or `NUMBER_TRIES`).
    Go does not follow this pattern. This is because Go uses the case of the first
    letter in the name of a package-level declaration to determine if the item is
    accessible outside the package. I will revisit this when I talk about packages
    in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，常量总是使用全部大写字母编写，用下划线分隔单词（例如 `INDEX_COUNTER` 或 `NUMBER_TRIES`）。但 Go 语言不遵循此模式。这是因为
    Go 使用包级声明名称的首字母大小写来确定该项是否可以在包外部访问。在讲解第 10 章（[Chapter 10](ch10.html#unique_chapter_id_10)）时，我会重新讨论这一点。
- en: Within a function, favor short variable names. *The smaller the scope for a
    variable, the shorter the name that’s used for it*. It is common in Go to see
    single-letter variable names used with `for` loops. For example, the names `k`
    and `v` (short for *key* and *value*) are used as the variable names in a `for-range`
    loop. If you are using a standard `for` loop, `i` and `j` are common names for
    the index variable. There are other idiomatic ways to name variables of common
    types; I will mention them as I cover more parts of the standard library.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，更倾向于使用短变量名。*变量的作用域越小，其名称就越短*。在 Go 语言中，常见于 `for` 循环中使用单个字母作为变量名。例如，在 `for-range`
    循环中，变量名 `k` 和 `v`（分别代表*键*和*值*）被用作变量名。如果使用标准的 `for` 循环，`i` 和 `j` 是常见的索引变量名。对于常见类型的变量，还有其他习惯用法来命名；随着我讲解标准库的更多部分，我会提到它们。
- en: Some languages with weaker type systems encourage developers to include the
    expected type of the variable in the variable’s name. Since Go is strongly typed,
    you don’t need to do this to keep track of the underlying type. However, you may
    see Go code where the first letter of a type is used as the variable name (for
    example, `i` for integers or `f` for floats). When you define your own types,
    similar patterns apply, especially when naming receiver variables (which are covered
    in [“Methods”](ch07.html#methods)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型系统较弱的语言鼓励开发者在变量名中包含变量的预期类型。由于 Go 语言是强类型的，你不需要这样做来跟踪底层类型。然而，你可能会看到 Go 代码中使用类型的首字母作为变量名（例如
    `i` 表示整数或 `f` 表示浮点数）。当你定义自己的类型时，类似的模式同样适用，特别是在命名接收器变量时（这在[“方法”](ch07.html#methods)中讨论）。
- en: These short names serve two purposes. The first is that they eliminate repetitive
    typing, keeping your code shorter. Second, they serve as a check on how complicated
    your code is. If you find it hard to keep track of your short-named variables,
    your block of code is likely doing too much.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些短名称有两个目的。首先，它们消除了重复输入，使你的代码更简洁。其次，它们作为检查代码复杂性的一种方式。如果你发现很难跟踪你的短命名变量，那么你的代码块可能做得太多了。
- en: When naming variables and constants in the package block, use more descriptive
    names. The type should still be excluded from the name, but since the scope is
    wider, you need a more complete name to clarify what the value represents.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在包块中命名变量和常量时，使用更具描述性的名称。名称仍然应该不包含类型，但由于作用域更广，你需要一个更完整的名称来澄清值代表的含义。
- en: For more discussion of Go naming recommendations, read the [Naming section of
    Google’s Go Style Decisions](https://oreil.ly/6AUc_).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 Go 命名建议的讨论，请阅读[Google Go 风格决策的命名部分](https://oreil.ly/6AUc_)。
- en: Exercises
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: These exercises demonstrate the concepts discussed in the chapter. Solutions
    to these exercises, along with the programs in this chapter, are in the [Chapter
    2 repository](https://oreil.ly/nGUVd).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习演示了本章讨论的概念。这些练习的解答以及本章的程序位于[第 2 章的存储库](https://oreil.ly/nGUVd)中。
- en: Write a program that declares an integer variable called `i` with the value
    20\. Assign `i` to a floating-point variable named `f`. Print out `i` and `f`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，声明一个名为`i`且值为20的整数变量。将`i`赋给名为`f`的浮点变量。打印出`i`和`f`。
- en: Write a program that declares a constant called `value` that can be assigned
    to both an integer and a floating-point variable. Assign it to an integer called
    `i` and a floating-point variable called `f`. Print out `i` and `f`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，声明一个名为`value`的常量，它可以分配给整数和浮点变量。将其分配给一个名为`i`的整数和一个名为`f`的浮点变量。打印出`i`和`f`。
- en: Write a program with three variables, one named `b` of type `byte`, one named
    `smallI` of type `int32`, and one named `bigI` of type `uint64`. Assign each variable
    the maximum legal value for its type; then add `1` to each variable. Print out
    their values.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个具有三个变量的程序，一个名为`b`且类型为`byte`，一个名为`smallI`且类型为`int32`，一个名为`bigI`且类型为`uint64`。为每种类型的变量分配其类型的最大合法值；然后将每个变量加`1`。打印出它们的值。
- en: Wrapping Up
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'You’ve covered a lot of ground here, understanding how to use the predeclared
    types, declare variables, and work with assignments and operators. In the next
    chapter, we will look at the composite types in Go: arrays, slices, maps, and
    structs. We will also take another look at strings and runes and how they interact
    with character encodings.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经涵盖了很多内容，理解了如何使用预声明类型，声明变量以及如何使用赋值和运算符。在下一章中，我们将看看Go语言中的复合类型：数组、切片、映射和结构体。我们还将再次查看字符串和符文以及它们与字符编码的交互。
