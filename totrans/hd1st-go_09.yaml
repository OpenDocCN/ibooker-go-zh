- en: 'Chapter 8\. building storage: Structs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。构建存储：结构体
- en: '![image](assets/f0231-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0231-01.png)'
- en: '**Sometimes you need to store more than one type of data.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时您需要存储多种类型的数据。**'
- en: We learned about slices, which store a list of values. Then we learned about
    maps, which map a list of keys to a list of values. But both of these data structures
    can only hold values of *one* type. Sometimes, you need to group together values
    of *several* types. Think of mailing addresses, where you have to mix street names
    (strings) with postal codes (integers). Or student records, where you have to
    mix student names (strings) with grade point averages (floating-point numbers).
    You can’t mix value types in slices or maps. But you *can* if you use another
    type called a **struct**. We’ll learn all about structs in this chapter!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了关于切片的知识，它们可以存储值列表。然后我们学习了关于映射的知识，它们将键列表映射到值列表。但是这两种数据结构只能保存*一种*类型的值。有时，您需要将*多种*类型的值组合在一起。例如邮寄地址，您需要将街道名称（字符串）与邮政编码（整数）混合在一起。或者学生记录，您需要将学生姓名（字符串）与平均绩点（浮点数）混合在一起。您不能在切片或映射中混合值类型。但是如果使用另一种称为**结构体**的类型，那么*可以*。我们将在本章中详细了解结构体！
- en: Slices and maps hold values of ONE type
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片和映射只能保存一种类型的值。
- en: '*Gopher Fancy* is a new magazine devoted to lovable rodents. They’re currently
    working on a system to keep track of their subscriber base.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gopher Fancy*是一本专门致力于可爱啮齿动物的新杂志。他们目前正在开发一个系统来跟踪他们的订阅者群体。'
- en: '![image](assets/f0232-01.png)![image](assets/f0232-02.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0232-01.png)![image](assets/f0232-02.png)'
- en: '**It’s true: arrays, slices, and maps are no help if you need to mix values
    of different types. They can only be set up to hold values of a single type. But
    Go does have a way to solve this problem...**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**确实如此：数组、切片和映射无法帮助您混合不同类型的值。它们只能设置为保存单一类型的值。但Go确实有一种方法来解决这个问题……**'
- en: Structs are built out of values of MANY types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体由多种类型的值构成
- en: A **struct** (short for “structure”) is a value that is constructed out of other
    values of many different types. Whereas a slice might only be able to hold `string`
    values or a map might only be able to hold `int` values, you can create a struct
    that holds `string` values, `int` values, `float64` values, `bool` values, and
    more—all in one convenient group.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**（简称“结构”）是由许多不同类型的其他值构成的值。虽然切片可能只能保存`string`值，或者映射可能只能保存`int`值，但是您可以创建一个结构体，其中既可以保存`string`值，也可以保存`int`值、`float64`值、`bool`值等等——所有这些都放在一个方便的组合中。'
- en: '![image](assets/f0233-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0233-01.png)'
- en: 'You declare a struct type using the `struct` keyword, followed by curly braces.
    Within the braces, you can define one or more **fields**: values that the struct
    groups together. Each field definition appears on a separate line, and consists
    of a field name, followed by the type of value that field will hold.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`struct`关键字声明结构体类型，后跟花括号。在花括号内部，您可以定义一个或多个**字段**：结构体组合在一起的值。每个字段定义都显示在单独的行上，并包含字段名，后跟该字段将保存的值类型。
- en: '![image](assets/f0233-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0233-02.png)'
- en: 'You can use a struct type as the type of a variable you’re declaring. This
    code declares a variable named `myStruct` that holds structs that have a `float64`
    field named `number`, a `string` field named `word`, and a `bool` field named
    `toggle`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将结构体类型用作正在声明的变量的类型。此代码声明了一个名为`myStruct`的变量，该变量保存具有`float64`字段`number`、`string`字段`word`和`bool`字段`toggle`的结构体：
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: (It’s more common to use a defined type to declare struct variables, but we
    won’t cover type definitions for a few more pages, so we’ll write it this way
    for now.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （通常使用定义的类型来声明结构体变量更常见，但我们将在几页后再详细讨论类型定义，所以现在我们将按照这种方式编写。）
- en: '![image](assets/f0233-03.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0233-03.png)'
- en: When we call `Printf` with the `%#v` verb above, it prints the value in `myStruct`
    as a struct literal. We’ll be covering struct literals later in the chapter, but
    for now you can see that the struct’s `number` field has been set to `0`, the
    `word` field to an empty string, and the `toggle` field to `false`. Each field
    has been set to the zero value for its type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上面使用`Printf`和`%#v`动词调用时，它将结构体`myStruct`的值打印为结构体字面量。我们稍后将介绍结构体字面量，但现在您可以看到结构体的`number`字段已设置为`0`，`word`字段为空字符串，`toggle`字段设置为`false`。每个字段都设置为其类型的零值。
- en: Access struct fields using the dot operator
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用点运算符访问结构体字段
- en: Now we can define a struct, but to actually use it, we need a way to store new
    values in the struct’s fields and retrieve them again.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义一个结构体，但实际使用它时，我们需要一种方法来存储结构体字段的新值并再次检索它们。
- en: 'All along, we’ve been using the dot operator to indicate functions that “belong
    to” another package, or methods that “belong to” a value:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们一直在使用点运算符来指示“属于”另一个包的函数，或者“属于”一个值的方法：
- en: '![image](assets/f0234-02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0234-02.png)'
- en: Similarly, we can use a dot operator to indicate fields that “belong to” a struct.
    This works for both assigning values and retrieving them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用点运算符来指示“属于”结构体的字段。这对于分配值和检索值都适用。
- en: '![image](assets/f0234-03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0234-03.png)'
- en: 'We can use dot operators to assign values to all the fields of `myStruct` and
    then print them back out:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点运算符为`myStruct`的所有字段赋值，然后将它们打印出来：
- en: '![image](assets/f0234-04.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0234-04.png)'
- en: Storing subscriber data in a struct
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将订阅者数据存储在结构体中
- en: Now that we know how to declare a variable that holds a struct and assign values
    to its fields, we can create a struct to hold magazine subscriber data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何声明一个变量来保存结构体并为其字段赋值，我们可以创建一个用于保存杂志订阅者数据的结构体。
- en: First, we’ll define a variable named `subscriber`. We’ll give `subscriber` a
    `struct` type with `name` (`string`), `rate` (`float64`), and `active` (`bool`)
    fields.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为`subscriber`的变量。我们将给`subscriber`一个结构体类型，其中包含`name`（`string`）、`rate`（`float64`）和`active`（`bool`）字段。
- en: With the variable and its type declared, we can then use dot operators to access
    the struct’s fields. We assign values of the appropriate type to each field, and
    then print the values back out again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量及其类型后，我们可以使用点运算符访问结构体的字段。我们为每个字段分配适当类型的值，然后再次将这些值打印出来。
- en: '![image](assets/f0235-01.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0235-01.png)'
- en: Even though the data we have for a subscriber is stored using a variety of types,
    structs let us keep it all in one convenient package!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为订阅者存储的数据使用了各种类型，结构体也让我们能够将它们都放在一个便捷的包中！
- en: Defined types and structs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类型和结构体
- en: '![image](assets/f0236-01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0236-01.png)'
- en: Throughout this book, you’ve used a variety of types, like `int`, `string`,
    `bool`, slices, maps, and now structs. But you haven’t been able to create completely
    *new* types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，您已经使用了多种类型，比如`int`，`string`，`bool`，切片，映射，现在又是结构体。但是，您还没有能够创建完全*新*的类型。
- en: '**Type definitions** allow you to create types of your own. They let you create
    a new **defined type** that’s based on an **underlying type**.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型定义**允许您创建自己的类型。它们让您创建一个基于**基础类型**的新的**定义类型**。'
- en: Although you can use any type as an underlying type, such as `float64`, `string`,
    or even slices or maps, in this chapter we’re going to focus on using struct types
    as underlying types. We’ll try using other underlying types when we take a deeper
    look at defined types in the next chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用任何类型作为基础类型，比如`float64`，`string`，甚至是切片或映射，但在本章中，我们将专注于使用结构类型作为基础类型。在下一章中，当我们深入研究定义类型时，我们将尝试使用其他基础类型。
- en: To write a type definition, use the `type` keyword, followed by the name for
    your new defined type, and then the underlying type you want to base it on. If
    you’re using a struct type as your underlying type, you’ll use the `struct` keyword
    followed by a list of field definitions in curly braces, just as you did when
    declaring struct variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写类型定义，请使用`type`关键字，后跟您的新定义类型的名称，然后是要基于的基础类型。如果您使用结构体类型作为基础类型，您将使用`struct`关键字，后跟花括号中的字段定义列表，就像在声明结构体变量时所做的那样。
- en: '![image](assets/f0236-02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0236-02.png)'
- en: Just like variables, type definitions *can* be written within a function. But
    that will limit its scope to that function’s block, meaning you won’t be able
    to use it outside that function. So types are usually defined outside of any functions,
    at the package level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量一样，类型定义可以写在函数内部。但这将限制其范围仅在该函数的块内，意味着您不能在该函数外部使用它。因此，类型通常是在包级别的任何函数外定义的。
- en: 'As a quick demonstration, the code below defines two types: `part` and `car`.
    Each defined type uses a struct as its underlying type.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速演示，下面的代码定义了两种类型：`part`和`car`。每个定义类型都使用结构体作为其基础类型。
- en: Then, within the `main` function, we declare a `porsche` variable of the `car`
    type, and a `bolts` variable of the `part` type. There’s no need to rewrite the
    lengthy struct definitions when declaring the variables; we just use the names
    of the defined types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`函数内部，我们声明了一个`porsche`变量，类型为`car`，以及一个`bolts`变量，类型为`part`。在声明变量时，无需重新编写冗长的结构体定义；我们只需使用定义类型的名称即可。
- en: '![image](assets/f0237-01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0237-01.png)'
- en: With the variables declared, we can set the values of their struct fields and
    get the values back out, just as we did in previous programs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量后，我们可以设置其结构体字段的值，并像以前的程序一样获取这些值。
- en: Using a defined type for magazine subscribers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义类型处理杂志订阅者
- en: Previously, to create more than one variable that stored magazine subscriber
    data in a struct, we had to write out the full struct type (including all its
    fields) for each variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，要创建多个存储杂志订阅者数据的变量，我们必须为每个变量写出完整的结构体类型（包括所有字段）。
- en: '![image](assets/f0238-01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0238-01.png)'
- en: But now, we can simply define a `subscriber` type at the package level. We write
    the struct type just once, as the underlying type for the defined type. When we’re
    ready to declare variables, we don’t have to write the struct type again; we simply
    use `subscriber` as their type. No more need to repeat the entire struct definition!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们可以简单地在包级别定义一个`subscriber`类型。我们只需一次编写结构体类型，作为定义类型的基础类型。当我们准备声明变量时，我们不必再次编写结构体类型；我们只需将`subscriber`用作它们的类型。不再需要重复整个结构体定义！
- en: '![image](assets/f0238-02.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0238-02.png)'
- en: Using defined types with functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定义类型处理函数
- en: Defined types can be used for more than just variable types. They also work
    for function parameters and return values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型不仅可以用于变量类型，还可以用于函数参数和返回值。
- en: Here’s our `part` type again, together with a new `showInfo` function that prints
    a part’s fields. The function takes a single parameter, with `part` as its type.
    Within `showInfo`, we access the fields via the parameter variable just like any
    other struct variable’s.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`part`类型，还有一个新的`showInfo`函数，它打印部件的字段。该函数接受一个参数，其类型为`part`。在`showInfo`中，我们像处理任何其他结构体变量一样通过参数变量访问字段。
- en: '![image](assets/f0239-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0239-01.png)'
- en: And here’s a `minimumOrder` function that creates a `part` with a specified
    description and a predefined value for the `count` field. We declare `minimumOrder`’s
    return type to be `part` so it can return the new struct.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`minimumOrder`函数，它创建一个带有指定描述和`count`字段预定义值的`part`。我们将`minimumOrder`的返回类型声明为`part`，以便它可以返回新的结构体。
- en: '![image](assets/f0239-02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0239-02.png)'
- en: Let’s go over a couple functions that work with the magazine’s `subscriber`
    type...
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看几个与杂志的`subscriber`类型一起使用的函数……
- en: The `printInfo` function takes a `subscriber` as a parameter, and prints the
    values of its fields.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`printInfo`函数接受一个`subscriber`作为参数，并打印其字段的值。'
- en: We also have a `defaultSubscriber` function that sets up a new `subscriber`
    struct with some default values. It takes a string parameter called `name`, and
    uses that to set a new `subscriber` value’s `name` field. Then it sets the `rate`
    and `active` fields to default values. Finally, it returns the completed `subscriber`
    struct to its caller.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`defaultSubscriber`函数，它用一些默认值设置一个新的`subscriber`结构体。它接受一个名为`name`的字符串参数，并使用它来设置新的`subscriber`值的`name`字段。然后它将`rate`和`active`字段设置为默认值。最后，它将完成的`subscriber`结构体返回给其调用者。
- en: '![image](assets/f0240-01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0240-01.png)'
- en: In our `main` function, we can pass a subscriber name to `defaultSubscriber`
    to get a new `subscriber` struct. One subscriber gets a discounted `rate`, so
    we reset that struct field directly. We can pass filled-out `subscriber` structs
    to `printInfo` to print out their contents.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们可以将订阅者名称传递给`defaultSubscriber`以获取一个新的`subscriber`结构体。一个订阅者获得了折扣`rate`，因此我们直接重置该结构体字段。我们可以将填写好的`subscriber`结构体传递给`printInfo`以打印它们的内容。
- en: Code Magnets
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/f0241-01.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0241-01.png)'
- en: A Go program is scrambled up on the fridge. Can you reconstruct the code snippets
    to make a working program that will produce the given output? The finished program
    will have a defined struct type named `student`, and a `printInfo` function that
    accepts a `student` value as a parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Go 程序被分散在冰箱上。你能重组代码片段，使之成为一个能够产生指定输出的工作程序吗？最终程序将具有名为`student`的定义结构体类型，以及一个接受`student`值作为参数的`printInfo`函数。
- en: '![image](assets/f0241-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0241-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_6).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在[“代码磁铁解决方案”](#code_magnets_solution_6)中。'
- en: Modifying a struct using a function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数修改结构体
- en: '![image](assets/f0242-01.png)![image](assets/f0242-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0242-01.png)![image](assets/f0242-02.png)'
- en: Our friends at *Gopher Fancy* are trying to write a function that takes a struct
    as a parameter and updates one of the fields in that struct.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*Gopher Fancy*的朋友们正试图编写一个函数，该函数接受一个结构体作为参数，并更新该结构体中的一个字段。
- en: Remember way back in [Chapter 3](ch03.html#call_mecolon_functions), when we
    were trying to write a `double` function that took a number and doubled it? After
    `double` returned, the number was back to its original value!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得很久以前的[第3章](ch03.html#call_mecolon_functions)吗？当时我们试图编写一个`double`函数，它接受一个数字并使其加倍？在`double`返回后，数字回到了原始值！
- en: That’s when we learned that Go is a “pass-by-value” language, meaning that function
    parameters receive a *copy* of the arguments the function was called with. If
    a function changes a parameter value, it’s changing the *copy*, not the *original*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那时我们了解到，Go语言是一种“传值”语言，这意味着函数参数接收的是调用函数时传入的参数的副本。如果函数修改参数的值，它修改的是这个*副本*，而不是*原始值*。
- en: '![image](assets/f0242-03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0242-03.png)'
- en: The same thing is true for structs. When we pass a `subscriber` struct to `applyDiscount`,
    the function receives a *copy* of the struct. So when we set the `rate` field
    on the struct, we’re modifying the *copied* struct, not the original.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对结构也是如此。当我们将`subscriber`结构体传递给`applyDiscount`时，函数接收的是结构体的*副本*。因此，当我们设置结构体的`rate`字段时，我们修改的是*复制*的结构体，而不是原始结构体。
- en: '![image](assets/f0242-04.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0242-04.png)'
- en: Back in [Chapter 3](ch03.html#call_mecolon_functions), our solution was to update
    the function parameter to accept a *pointer* to a value, instead of accepting
    a value directly. When calling the function, we used the address-of operator (`&`)
    to pass a pointer to the value we wanted to update. Then, within the function,
    we used the `*` operator to update the value at that pointer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第3章](ch03.html#call_mecolon_functions)，我们的解决方案是更新函数参数以接受值的*指针*，而不是直接接受值。在调用函数时，我们使用取地址操作符（`&`）传递要更新的值的指针。然后，在函数内部，我们使用`*`操作符来更新该指针指向的值。
- en: As a result, the updated value was still visible after the function returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在函数返回后，更新后的值仍然可见。
- en: '![image](assets/f0243-01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0243-01.png)'
- en: We can use pointers to allow a function to update a struct as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用指针允许函数更新结构体。
- en: Here’s an updated version of the `applyDiscount` function that should work correctly.
    We update the `s` parameter to accept a pointer to a `subscriber` struct, rather
    than the struct itself. Then we update the value in the struct’s `rate` field.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更新后的`applyDiscount`函数的版本，应该可以正常工作。我们更新`s`参数以接受指向`subscriber`结构体的指针，而不是结构体本身。然后我们更新结构体的`rate`字段的值。
- en: In `main`, we call `applyDiscount` with a pointer to a `subscriber` struct.
    When we print the value in the struct’s `rate` field, we can see that it’s been
    updated successfully!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们使用指向`subscriber`结构体的指针调用`applyDiscount`。当我们打印结构体中的`rate`字段时，我们可以看到它已成功更新！
- en: '![image](assets/f0243-02.png)![image](assets/f0243-03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0243-02.png)![图片](assets/f0243-03.png)'
- en: '**Actually, no! The dot notation to access fields works on struct pointers
    as well as the structs themselves.**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**事实上，不是这样！点符号访问字段的方法对结构指针以及结构本身都适用。**'
- en: Accessing struct fields through a pointer
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过指针访问结构字段
- en: If you try to print a pointer variable, what you’ll see is the memory address
    it points to. This is generally not what you want.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试打印指针变量，你会看到它指向的内存地址。这通常不是你想要的。
- en: '![image](assets/f0244-01.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0244-01.png)'
- en: Instead, you need to use the `*` operator (what we like to call the “value-at
    operator”) to get the value at the pointer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你需要使用`*`操作符（我们喜欢称之为“值在操作符”）来获取指针指向的值。
- en: '![image](assets/f0244-02.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0244-02.png)'
- en: 'So you might think you’d need to use the `*` operator with pointers to structs
    as well. But just putting a `*` before the struct pointer won’t work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能认为你需要对结构体指针使用`*`操作符。但仅仅在结构体指针前加上`*`并不能起作用：
- en: '![image](assets/f0244-03.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0244-03.png)'
- en: If you write `*pointer.myField`, Go thinks that `myField` must contain a pointer.
    It doesn’t, though, so an error results. To get this to work, you need to wrap
    `*pointer` in parentheses. That will cause the `myStruct` value to be retrieved,
    after which you can access the struct field.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写`*pointer.myField`，Go认为`myField`必须包含一个指针。但实际上并非如此，这会导致错误。要使其工作，你需要在`*pointer`周围加上括号。这将导致检索`myStruct`值，然后可以访问结构字段。
- en: '![image](assets/f0244-04.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0244-04.png)'
- en: Having to write `(*pointer).myField` all the time would get tedious quickly,
    though. For this reason, the dot operator lets you access fields via *pointers*
    to structs, just as you can access fields directly from struct values. You can
    leave off the parentheses and the `*` operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然必须经常写`(*pointer).myField`会很快变得乏味。因此，点操作符允许您通过指向结构体的*指针*访问字段，就像您可以直接从结构体值访问字段一样。您可以省略括号和`*`操作符。
- en: '![image](assets/f0245-01.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0245-01.png)'
- en: 'This works for assigning to struct fields through a pointer as well:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这对通过指针分配结构体字段同样适用：
- en: '![image](assets/f0245-02.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0245-02.png)'
- en: And that’s how the `applyDiscount` function is able to update the struct field
    without using the `*` operator. It assigns to the `rate` field *through* the struct
    pointer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`applyDiscount`函数如何能够在不使用`*`操作符的情况下更新结构体字段的方式。
- en: '![image](assets/f0245-03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0245-03.png)'
- en: there are no Dumb Questions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: You showed a `defaultSubscriber` function before that set a struct’s fields,
    but it didn’t need to use any pointers! Why not?**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 你之前展示了一个`defaultSubscriber`函数来设置结构体的字段，但它不需要使用任何指针！为什么不需要？**'
- en: '**A:** The `defaultSubscriber` function *returned* a struct value. If a caller
    stores the returned value, then the values in its fields will be preserved. Only
    functions that *modify existing* structs without returning them have to use pointers
    for those changes to be preserved.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** `defaultSubscriber`函数*返回*了一个结构体值。如果调用者存储了返回的值，那么其字段中的值将会被保留。只有那些*修改现有*结构体而不返回它们的函数才需要使用指针，以便这些更改能够被保留。'
- en: But `defaultSubscriber` *could* have returned a pointer to a struct, if we had
    wanted it to. In fact, we make just that change in the next section!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们希望的话，`defaultSubscriber`*可以*返回一个指向结构体的指针。事实上，在下一部分我们就做了这个改变！
- en: Pass large structs using pointers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过指针传递大型结构体
- en: '![image](assets/f0246-01.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0246-01.png)'
- en: '**Yes, it will. It has to make room for the original struct and the copy.**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**是的，会。它必须为原始结构体和副本腾出空间。**'
- en: Functions receive a copy of the arguments they’re called with, even if they’re
    a big value like a struct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收的是调用时传入的参数的副本，即使是像结构体这样的大值。
- en: That’s why, unless your struct has only a couple small fields, it’s often a
    good idea to pass functions a *pointer* to a struct, rather than the struct itself.
    (This is true even if the function doesn’t need to modify the struct.) When you
    pass a struct pointer, only one copy of the original struct exists in memory.
    The function just receives the memory address of that single struct, and can read
    the struct, modify it, or whatever else it needs to do, all without making an
    extra copy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，除非你的结构体只有一两个小字段，通常最好是传递一个指向结构体的*指针*，而不是结构体本身。当你传递结构体指针时，内存中只存在原始结构体的一个副本。函数只是接收到单个结构体的内存地址，并可以读取结构体，修改它，或者进行其他任何操作，而无需制作额外的副本。
- en: Here’s our `defaultSubscriber` function, updated to return a pointer, and our
    `printInfo` function, updated to receive a pointer. Neither of these functions
    needs to change an existing struct like `applyDiscount` does. But using pointers
    ensures that only one copy of each struct needs to be kept in memory, while still
    allowing the program to work as normal.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们更新过的`defaultSubscriber`函数，现在返回一个指针，并且我们更新了`printInfo`函数，使其接收一个指针。像`applyDiscount`一样，这两个函数都不需要改变现有的结构体。但使用指针确保只需在内存中保留每个结构体的一个副本，同时仍然允许程序正常工作。
- en: '![image](assets/f0246-02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0246-02.png)'
- en: Moving our struct type to a different package
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的结构类型移到不同的包中
- en: '![image](assets/f0248-01.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0248-01.png)'
- en: That should be easy to do. Find the *headfirstgo* directory within your Go workspace,
    and create a new directory in there to hold a package named `magazine`. Within
    *magazine*, create a file named *magazine.go*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很容易做到。在你的Go工作空间中找到*headfirstgo*目录，并在其中创建一个新目录来保存名为`magazine`的包。在*magazine*中，创建一个名为*magazine.go*的文件。
- en: '![image](assets/f0248-02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0248-02.png)'
- en: Be sure to add a `package magazine` declaration at the top of *magazine.go*.
    Then, copy the `subscriber` struct definition from your existing code and paste
    it into *magazine.go*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在*magazine.go*文件顶部添加`package magazine`声明。接着，从你现有的代码中复制`subscriber`结构体定义，并粘贴到*magazine.go*中。
- en: '![image](assets/f0248-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0248-03.png)'
- en: Next, let’s create a program to try out the new package. Since we’re just experimenting
    for now, let’s not create a separate package folder for this code; we’ll just
    run it using the `go run` command. Create a file named *main.go*. You can save
    it in any directory you want, but make sure you save it *outside* your Go workspace,
    so it doesn’t interfere with any other packages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个程序来尝试新的包。由于我们现在只是做实验，所以暂时不要为这段代码创建一个单独的包目录；我们将使用`go run`命令来运行它。创建一个名为*main.go*的文件。你可以将它保存在任何目录中，但要确保它保存在你的
    Go 工作空间之外，以免与其他包发生冲突。
- en: '![image](assets/f0248-04.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0248-04.png)'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: (You can move this code into your Go workspace later, if you want, as long as
    you create a separate package directory for it.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (如果需要的话，稍后可以将此代码移动到你的 Go 工作空间，只要为其创建一个单独的包目录即可。)
- en: Within *main.go*, save this code, which simply creates a new `subscriber` struct
    and accesses one of its fields.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*main.go*中，保存这段代码，它简单地创建了一个新的`subscriber`结构体并访问了其中的一个字段。
- en: There are two differences from the previous examples. First, we need to import
    the `magazine` package at the top of the file. Second, we need to use `magazine.subscriber`
    as the type name, since it belongs to another package now.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前示例有两个不同之处。首先，我们需要在文件顶部导入`magazine`包。其次，我们需要使用`magazine.subscriber`作为类型名称，因为它现在属于另一个包。
- en: '![image](assets/f0248-05.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0248-05.png)'
- en: A defined type’s name must be capitalized to be exported
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类型的名称必须大写才能被导出
- en: Let’s see if our experimental code can still access the `subscriber` struct
    type in its new package. In your terminal, change into the directory where you
    saved *main.go*, then enter `**go run main.go**`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的实验性代码是否仍然可以访问其新包中的`subscriber`结构体类型。在终端中，切换到保存*main.go*的目录，然后输入`**go run
    main.go**`。
- en: '![image](assets/f0249-01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0249-01.png)'
- en: 'We get a couple errors, but here’s the important one: `cannot refer to unexported
    name magazine.subscriber`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们出现了一些错误，但重要的是：`cannot refer to unexported name magazine.subscriber`。
- en: 'Go type names follow the same rule as variable and function names: if the name
    of a variable, function, or type begins with a capital letter, it is considered
    *exported* and can be accessed from outside the package it’s declared in. But
    our `subscriber` type name begins with a lowercase letter. That means it can only
    be used within the `magazine` package.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Go 类型名称遵循与变量和函数名称相同的规则：如果变量、函数或类型的名称以大写字母开头，则被视为*导出*的，可以从声明它的包外访问。但是我们的`subscriber`类型名称以小写字母开头。这意味着它只能在`magazine`包内部使用。
- en: '**For a type to be accessed outside the package it’s defined in, it must be
    exported: its name must begin with a capital letter.**'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**要使类型能够从其定义的包外访问，必须将其导出：其名称必须以大写字母开头。**'
- en: Well, that seems like an easy fix. We’ll just open our *magazine.go* file and
    capitalize the name of the defined type. Then, we’ll open *main.go* and capitalize
    the names of any references to that type. (There’s just one right now.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这是一个简单的修复方法。我们只需打开我们的*magazine.go*文件，并将定义类型的名称大写化。然后，我们打开*main.go*并将对该类型的任何引用也大写化。（现在只有一个引用。）
- en: '![image](assets/f0249-02.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0249-02.png)'
- en: If we try running the updated code with `go run main.go`, we no longer get the
    error saying that the `magazine.subscriber` type is unexported. So that seems
    to be fixed. But we get a couple new errors in its place...
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用`go run main.go`运行更新后的代码，就不再会出现`magazine.subscriber`类型未导出的错误了。所以这个问题看起来已经解决了。但是，我们却得到了一些新的错误...
- en: '![image](assets/f0249-03.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0249-03.png)'
- en: Struct field names must be capitalized to be exported
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体字段名必须大写才能被导出
- en: With the `Subscriber` type name capitalized, we seem to be able to access it
    from the `main` package. But now we’re getting an error saying that we can’t refer
    to the `rate` *field*, because *that* is unexported.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Subscriber`类型名称大写时，似乎可以从`main`包中访问它。但是现在我们得到一个错误，说我们不能引用`rate`字段，因为它是未导出的。
- en: '![image](assets/f0250-01.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0250-01.png)'
- en: Even if a struct type is exported from a package, its fields will be *unexported*
    if their names don’t begin with a capital letter. Let’s try capitalizing `Rate`
    (in both *magazine.go* and *main.go*)...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个结构体类型从一个包中导出，如果它们的字段名称不以大写字母开头，它们将会是*未导出*的。让我们尝试在*magazine.go*和*main.go*中将`Rate`大写化...
- en: '**Struct field names must also be capitalized if you want to export them from
    their package.**'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**如果想要从其包中导出结构体字段名称也必须大写。**'
- en: '![image](assets/f0250-02.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0250-02.png)'
- en: Run *main.go* again, and you’ll see that everything works this time. Now that
    they’re exported, we can access the `Subscriber` type *and* its `Rate` field from
    the `main` package.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行*main.go*，你会发现这次一切都正常工作了。现在它们已经被导出，我们可以从`main`包中访问`Subscriber`类型以及其`Rate`字段。
- en: '![image](assets/f0250-03.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0250-03.png)'
- en: Notice that the code worked even though the `name` and `active` fields were
    still unexported. You can have a mixture of exported and unexported fields within
    a single struct type, if you want.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意尽管`name`和`active`字段仍未导出，代码仍然有效。如果需要的话，你可以在单个结构类型中混合使用导出和未导出的字段。
- en: 'That’s probably not advisable in the case of the `Subscriber` type, though.
    It wouldn’t make sense to be able to access the subscription rate from other packages,
    but not the name or address. So let’s go back into *magazine.go* and export the
    other fields as well. Simply capitalize their names: `Name` and `Active`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Subscriber`类型的情况下可能不明智。能够从其他包中访问订阅率，但不能访问名称或地址是没有意义的。因此，让我们返回*magazine.go*并将其他字段也导出。只需将它们的名称大写：`Name`和`Active`。
- en: '![image](assets/f0250-04.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0250-04.png)'
- en: Struct literals
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体字面量
- en: 'The code to define a struct and then assign values to its fields one by one
    can get a bit tedious:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个结构体并逐个为其字段赋值的代码可能有些繁琐：
- en: '[PRE0]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, just as with slices and maps, Go offers **struct literals** to let you create
    a struct and set its fields at the same time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与切片和映射一样，Go语言提供了**结构体字面量**，让你可以创建一个结构体并同时设置其字段。
- en: The syntax looks similar to a map literal. The type is listed first, followed
    by curly braces. Within the braces, you can specify values for some or all of
    the struct fields, using the field name, a colon, and then the value. If you specify
    multiple fields, separate them with commas.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 语法看起来类似于映射字面量。首先列出类型，然后是花括号。在花括号内，你可以为一些或所有的结构字段指定值，使用字段名、冒号，然后是值。如果指定多个字段，用逗号分隔。
- en: '![image](assets/f0251-02.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0251-02.png)'
- en: 'Above, we showed some code that creates a `Subscriber` struct and sets its
    fields, one by one. This code does the same thing in a single line, using a struct
    literal:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们展示了一些创建`Subscriber`结构体并逐个设置其字段的代码。这段代码使用结构体字面量在一行中完成相同的操作：
- en: '![image](assets/f0251-03.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0251-03.png)'
- en: You may have noticed that for most of the chapter, we’ve had to use long-form
    declarations for struct variables (unless the struct was being returned from a
    function). Struct literals allow us to use short variable declarations for a struct
    we’ve just created.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在大部分章节中，我们不得不对结构体变量使用长形式声明（除非结构体是从函数中返回的）。结构体字面量允许我们对刚刚创建的结构体使用短变量声明。
- en: You can omit some or even all of the fields from the curly braces. Omitted fields
    will be set to the zero value for their type.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略一些甚至所有的字段。省略的字段将会被设置为它们类型的零值。
- en: '![image](assets/f0251-04.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0251-04.png)'
- en: Pool Puzzle
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](assets/f0252-01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0252-01.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从池中取出代码片段，并将它们放入这段代码的空白行中。**不要**重复使用相同的片段，你不需要使用所有的片段。你的**目标**是创建一个能够运行并产生所示输出的程序。
- en: '![image](assets/f0252-02.png)![image](assets/f0252-03.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0252-02.png)![image](assets/f0252-03.png)'
- en: '**Note: each snippet from the pool can only be used once!**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个池中的片段只能使用一次！**'
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_5).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案见[“Pool Puzzle Solution”](#pool_puzzle_solution_5)。'
- en: Creating an Employee struct type
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Employee结构类型
- en: '![image](assets/f0253-01.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0253-01.png)'
- en: Adding an `Employee` struct type should be pretty easy. We’ll just add it to
    the `magazine` package, alongside the `Subscriber` type. In *magazine.go*, define
    a new `Employee` type, with a `struct` underlying type. Give the struct type a
    `Name` field with a type of `string`, and a `Salary` field with a type of `float64`.
    Be sure to capitalize the type name *and* all the fields, so that they’re exported
    from the `magazine` package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Employee`结构类型应该很简单。我们只需将其添加到`magazine`包中，与`Subscriber`类型并列。在*magazine.go*中，定义一个新的`Employee`类型，其基础类型为`struct`。为该结构类型添加一个`Name`字段，类型为`string`，并添加一个`Salary`字段，类型为`float64`。确保将类型名和所有字段都大写，以便从`magazine`包中导出它们。
- en: We can update the `main` function in *main.go* to try the new type out. First,
    declare a variable with the type `magazine.Employee`. Then assign values of the
    appropriate type to each of the fields. Finally, print those values out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新*main.go*中的`main`函数以尝试新类型。首先，声明一个类型为`magazine.Employee`的变量。然后为每个字段分配适当类型的值。最后，打印这些值。
- en: '![image](assets/f0253-02.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0253-02.png)'
- en: If you execute `go run main.go` from your terminal, it should run, create a
    new `magazine.Employee` struct, set its field values, and then print those values
    out.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从终端执行`go run main.go`，它应该运行，创建一个新的`magazine.Employee`结构体，设置其字段值，然后打印这些值。
- en: Creating an Address struct type
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Address结构体类型
- en: Next, we need to track mailing addresses for both the `Subscriber` and `Employee`
    types. We’re going to need fields for the street address, city, state, and postal
    code (zip code).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`Subscriber`和`Employee`类型跟踪邮寄地址。我们将需要街道地址、城市、州和邮政编码（邮政编码）的字段。
- en: 'We *could* add separate fields to both the `Subscriber` and `Employee` types,
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*向`Subscriber`和`Employee`类型分别添加单独的字段，如下所示：
- en: '![image](assets/f0254-01.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0254-01.png)'
- en: But mailing addresses are going to have the same format, no matter what type
    they belong to. It’s a pain to have to repeat all those fields between multiple
    types.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论属于哪种类型，邮寄地址的格式都是相同的。重复多个类型之间所有这些字段是很麻烦的。
- en: Struct fields can hold values of any type, *including other structs*. So, instead,
    let’s try building an `Address` struct type, and then adding an `Address` field
    on the `Subscriber` and `Employee` types. That will save us some effort now, and
    ensure consistency between the types later if we have to change the address format.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结构字段可以容纳任何类型的值，*包括其他结构体*。因此，我们试试构建一个`Address`结构体类型，然后在`Subscriber`和`Employee`类型上添加一个`Address`字段。这样现在会为我们节省一些工作量，并且如果需要更改地址格式，稍后可以确保类型之间的一致性。
- en: We’ll create just the `Address` type first, so we can ensure it’s working correctly.
    Place it in the `magazine` package, alongside the `Subscriber` and `Employee`
    types. Then, replace the code in *main.go* with a few lines to create an `Address`
    and ensure its fields are accessible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将创建`Address`类型，以确保其正常工作。将其放置在`magazine`包中，与`Subscriber`和`Employee`类型并列。然后，用几行代码替换*main.go*中的代码，创建一个`Address`并确保其字段可访问。
- en: '![image](assets/f0254-02.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0254-02.png)'
- en: Type `**go run main.go**` in your terminal, and it should create an `Address`
    struct, populate its fields, and then print the whole struct out.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中键入`**go run main.go**`，它应该创建一个`Address`结构体，填充其字段，然后打印整个结构体。
- en: Adding a struct as a field on another type
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在另一种类型上添加一个结构体作为字段
- en: Now that we’re sure the `Address` struct type works by itself, let’s add `HomeAddress`
    fields to the `Subscriber` and `Employee` types.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信`Address`结构体类型可以单独使用，让我们将`HomeAddress`字段添加到`Subscriber`和`Employee`类型中。
- en: Adding a struct field that is itself a struct type is no different than adding
    a field of any other type. You provide a name for the field, followed by the field’s
    type (which in this case will be a struct type).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个字段，该字段本身是一个结构体类型，与添加任何其他类型的字段没有区别。你为字段提供一个名称，然后是字段的类型（在本例中将是一个结构体类型）。
- en: Add a field named `HomeAddress` to the `Subscriber` struct. Make sure to capitalize
    the field name, so that it’s accessible from outside the `magazine` package. Then
    specify the field type, which is `Address`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Subscriber`结构体中添加一个名为`HomeAddress`的字段。确保将字段名称大写，这样可以从`magazine`包的外部访问它。然后指定字段类型为`Address`。
- en: Add a `HomeAddress` field to the `Employee` type as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将`HomeAddress`字段添加到`Employee`类型中。
- en: '![image](assets/f0255-01.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0255-01.png)'
- en: Setting up a struct within another struct
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在另一个结构体内设置结构体
- en: Now let’s see if we can populate the fields of the `Address` struct *within*
    the `Subscriber` struct. There are a couple ways to go about this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看是否可以在`Subscriber`结构体*内部*填充`Address`结构体的字段。有几种方法可以做到这一点。
- en: The first approach is to create an entirely separate `Address` struct and then
    use it to set the entire `Address` field of the `Subscriber` struct. Here’s an
    update to *main.go* that follows this approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是创建一个完全独立的`Address`结构体，然后使用它来设置`Subscriber`结构体的整个`Address`字段。以下是遵循此方法更新*main.go*的代码。
- en: '![image](assets/f0255-02.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0255-02.png)'
- en: Type `**go run main.go**` in your terminal, and you’ll see the subscriber’s
    `HomeAddress` field has been set to the struct you built.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中键入`**go run main.go**`，你会看到订阅者的`HomeAddress`字段已经设置为你构建的结构体。
- en: Another approach is to set the fields of the inner struct *through* the outer
    struct.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过外部结构为内部结构的字段*赋值*。
- en: 'When a `Subscriber` struct is created, its `HomeAddress` field is already set:
    it’s an `Address` struct with all its fields set to their zero values. If we print
    `HomeAddress` using the `"%#v"` verb for `fmt.Printf`, it will print the struct
    as it would appear in Go code — that is, as a struct literal. We’ll see that each
    of the `Address` fields is set to an empty string, which is the zero value for
    the `string` type.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`Subscriber`结构时，其`HomeAddress`字段已经设置：它是一个`Address`结构，其中所有字段均设置为它们的零值。如果我们使用`fmt.Printf`的`"%#v"`动词打印`HomeAddress`，它将打印出结构体，就像在Go代码中看到的一样
    — 即，作为结构体文字。我们将看到`Address`的每个字段都设置为空字符串，这是`string`类型的零值。
- en: '![image](assets/f0256-01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0256-01.png)'
- en: If `subscriber` is a variable that contains a `Subscriber` struct, then when
    you type `subscriber.HomeAddress`, you’ll get an `Address` struct, even if you
    haven’t explicitly set `HomeAddress`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`subscriber`是包含`Subscriber`结构的变量，那么当您键入`subscriber.HomeAddress`时，即使您尚未明确设置`HomeAddress`，也将获得一个`Address`结构。
- en: You can use this fact to “chain” dot operators together so you can access the
    fields of the `Address` struct. Simply type `**subscriber.HomeAddress**` to access
    the `Address` struct, followed by *another* dot operator and the name of the field
    you want to access on that `Address` struct.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用这一事实“链”点运算符在一起，以便访问`Address`结构的字段。只需键入`**subscriber.HomeAddress**`来访问`Address`结构，然后*再*跟随另一个点运算符和您想要在该`Address`结构上访问的字段名称。
- en: '![image](assets/f0256-02.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0256-02.png)'
- en: This works both for assigning values to the inner struct’s fields...
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于给内部结构的字段赋值都适用...
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '...and for retrieving those values again later.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '...以及稍后检索这些值。'
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here’s an update to *main.go* that uses dot operator chaining. First we store
    a `Subscriber` struct in the `subscriber` variable. That will automatically create
    an `Address` struct in `subscriber`’s `HomeAddress` field. We set values for `subscriber.HomeAddress.Street`,
    `subscriber.HomeAddress.City`, and so on, and then print those values out again.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新的*main.go*，它使用点运算符链。首先，我们将`Subscriber`结构存储在`subscriber`变量中。这将自动在`subscriber`的`HomeAddress`字段中创建一个`Address`结构。我们为`subscriber.HomeAddress.Street`、`subscriber.HomeAddress.City`等设置值，然后再次打印这些值。
- en: Then we store an `Employee` struct in the `employee` variable, and do the same
    for its `HomeAddress` struct.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`Employee`结构存储在`employee`变量中，并对其`HomeAddress`结构执行相同操作。
- en: '![image](assets/f0257-01.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0257-01.png)'
- en: Type `**go run main.go**` in your terminal, and the program will print out the
    completed fields of both `subscriber.HomeAddress` and `employee.HomeAddress`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中输入`**go run main.go**`，程序将打印出`subscriber.HomeAddress`和`employee.HomeAddress`的完成字段。
- en: Anonymous struct fields
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名结构字段
- en: The code to access the fields of an inner struct through its outer struct can
    be a bit tedious, though. You have to write the field name of the inner struct
    (`HomeAddress`) each time you want to access any of the fields it contains.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过外部结构访问内部结构的字段的代码有点繁琐。每次想要访问它包含的任何字段时，都必须编写内部结构（`HomeAddress`）的字段名称。
- en: '![image](assets/f0258-01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0258-01.png)'
- en: 'Go allows you to define **anonymous fields**: struct fields that have no name
    of their own, just a type. We can use an anonymous field to make our inner struct
    easier to access.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许您定义**匿名字段**：没有自己名称的结构字段，只有类型。我们可以使用匿名字段使我们的内部结构更容易访问。
- en: Here’s an update to the `Subscriber` and `Employee` types to convert their `HomeAddress`
    fields to an anonymous field. To do this, we simply remove the field name, leaving
    only the type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里更新了`Subscriber`和`Employee`类型，将它们的`HomeAddress`字段转换为匿名字段。为此，我们只需删除字段名称，只留下类型。
- en: '![image](assets/f0258-02.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0258-02.png)'
- en: 'When you declare an anonymous field, you can use the field’s type name as if
    it were the name of the field. So `subscriber.Address` and `employee.Address`
    in the code below still access the `Address` structs:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明匿名字段时，您可以像使用字段类型名称一样使用它，好像它是字段的名称一样。因此，下面代码中的`subscriber.Address`和`employee.Address`仍然访问`Address`结构：
- en: '![image](assets/f0258-03.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0258-03.png)'
- en: Embedding structs
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入结构体
- en: But anonymous fields offer much more than just the ability to skip providing
    a name for a field in a struct definition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但匿名字段提供的不仅仅是在结构定义中省略字段名称的能力。
- en: An inner struct that is stored within an outer struct using an anonymous field
    is said to be **embedded** within the outer struct. Fields for an embedded struct
    are **promoted** to the outer struct, meaning you can access them as if they belong
    to the outer struct.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个嵌入在外部结构体中的内部结构体，使用匿名字段存储，被称为**嵌入**在外部结构体中。嵌入结构体的字段被**提升**到外部结构体，这意味着你可以像访问外部结构体的字段一样访问它们。
- en: So now that the `Address` struct type is embedded within the `Subscriber` and
    `Employee` struct types, you don’t have to write out `subscriber.Address.City`
    to get at the `City` field; you can just write `subscriber.City`. You don’t need
    to write `employee.Address.State`; you can just write `employee.State`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在`Address`结构类型已经嵌入到`Subscriber`和`Employee`结构类型中，你不必写出`subscriber.Address.City`来获取`City`字段；你可以直接写`subscriber.City`。你不需要写`employee.Address.State`；你可以直接写`employee.State`。
- en: Here’s one last version of *main.go*, updated to treat `Address` as an embedded
    type. You can write the code as if there were no `Address` type at all; it’s like
    the `Address` fields belong to the struct type they’re embedded within.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*main.go*的最后一个版本，更新为将`Address`作为嵌入类型处理。你可以将代码编写得好像根本没有`Address`类型；就像`Address`字段属于它们所嵌入的结构体类型一样。
- en: '![image](assets/f0259-01.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0259-01.png)'
- en: Keep in mind that you don’t *have* to embed inner structs. You don’t have to
    use inner structs at all. Sometimes adding new fields on the outer struct leads
    to the clearest code. Consider your current situation, and go with the solution
    that works best for you and your users.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你并不*必须*嵌入内部结构体。你根本不需要使用内部结构体。有时，在外部结构体上添加新字段会导致最清晰的代码。考虑你当前的情况，并选择最适合你和你的用户的解决方案。
- en: Our defined types are complete!
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的定义类型已经完成了！
- en: '![image](assets/f0260-01.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0260-01.png)'
- en: Nice work! You’ve defined `Subscriber` and `Employee` struct types, and embedded
    an `Address` struct in each of them. You’ve found a way to represent all the data
    the magazine needed!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！你已经定义了`Subscriber`和`Employee`结构类型，并在每个结构中嵌入了一个`Address`结构。你找到了一种方式来表示杂志所需的所有数据！
- en: 'You’re still missing an important aspect to defined types, though. In previous
    chapters, you’ve used types like `time.Time` and `strings.Replacer` that have
    *methods*: functions that you can call *on* their values. But you haven’t learned
    how to define methods for your own types yet. Don’t worry; we’ll learn all about
    it in the next chapter!'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在定义类型时仍然缺少一个重要的方面。在之前的章节中，你使用了像`time.Time`和`strings.Replacer`这样的类型，它们有*方法*：你可以在它们的值上调用的函数。但是你还没有学会如何为自己的类型定义方法。不用担心；我们将在下一章节详细学习！
- en: Your Go Toolbox
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的Go工具箱
- en: '![image](assets/f0261-01.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0261-01.png)'
- en: '**That’s it for [Chapter 8](#building_storagecolon_structs)! You’ve added structs
    and defined types to your toolbox.**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是[第8章](#building_storagecolon_structs)的全部内容！你已经为你的工具箱添加了结构体和定义类型。**'
- en: '![image](assets/f0261-02.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0261-02.png)'
- en: Code Magnets Solution
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁解决方案
- en: '![image](assets/f0262-02.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0262-02.png)'
- en: Pool Puzzle Solution
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解决方案
- en: '![image](assets/f0264-01.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0264-01.png)'
