- en: 'Chapter 8\. building storage: Structs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0231-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Sometimes you need to store more than one type of data.**'
  prefs: []
  type: TYPE_NORMAL
- en: We learned about slices, which store a list of values. Then we learned about
    maps, which map a list of keys to a list of values. But both of these data structures
    can only hold values of *one* type. Sometimes, you need to group together values
    of *several* types. Think of mailing addresses, where you have to mix street names
    (strings) with postal codes (integers). Or student records, where you have to
    mix student names (strings) with grade point averages (floating-point numbers).
    You can’t mix value types in slices or maps. But you *can* if you use another
    type called a **struct**. We’ll learn all about structs in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Slices and maps hold values of ONE type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Gopher Fancy* is a new magazine devoted to lovable rodents. They’re currently
    working on a system to keep track of their subscriber base.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0232-01.png)![image](assets/f0232-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**It’s true: arrays, slices, and maps are no help if you need to mix values
    of different types. They can only be set up to hold values of a single type. But
    Go does have a way to solve this problem...**'
  prefs: []
  type: TYPE_NORMAL
- en: Structs are built out of values of MANY types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **struct** (short for “structure”) is a value that is constructed out of other
    values of many different types. Whereas a slice might only be able to hold `string`
    values or a map might only be able to hold `int` values, you can create a struct
    that holds `string` values, `int` values, `float64` values, `bool` values, and
    more—all in one convenient group.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0233-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You declare a struct type using the `struct` keyword, followed by curly braces.
    Within the braces, you can define one or more **fields**: values that the struct
    groups together. Each field definition appears on a separate line, and consists
    of a field name, followed by the type of value that field will hold.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0233-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use a struct type as the type of a variable you’re declaring. This
    code declares a variable named `myStruct` that holds structs that have a `float64`
    field named `number`, a `string` field named `word`, and a `bool` field named
    `toggle`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (It’s more common to use a defined type to declare struct variables, but we
    won’t cover type definitions for a few more pages, so we’ll write it this way
    for now.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0233-03.png)'
  prefs: []
  type: TYPE_IMG
- en: When we call `Printf` with the `%#v` verb above, it prints the value in `myStruct`
    as a struct literal. We’ll be covering struct literals later in the chapter, but
    for now you can see that the struct’s `number` field has been set to `0`, the
    `word` field to an empty string, and the `toggle` field to `false`. Each field
    has been set to the zero value for its type.
  prefs: []
  type: TYPE_NORMAL
- en: Access struct fields using the dot operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can define a struct, but to actually use it, we need a way to store new
    values in the struct’s fields and retrieve them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'All along, we’ve been using the dot operator to indicate functions that “belong
    to” another package, or methods that “belong to” a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0234-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can use a dot operator to indicate fields that “belong to” a struct.
    This works for both assigning values and retrieving them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0234-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use dot operators to assign values to all the fields of `myStruct` and
    then print them back out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0234-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Storing subscriber data in a struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to declare a variable that holds a struct and assign values
    to its fields, we can create a struct to hold magazine subscriber data.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll define a variable named `subscriber`. We’ll give `subscriber` a
    `struct` type with `name` (`string`), `rate` (`float64`), and `active` (`bool`)
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: With the variable and its type declared, we can then use dot operators to access
    the struct’s fields. We assign values of the appropriate type to each field, and
    then print the values back out again.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0235-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though the data we have for a subscriber is stored using a variety of types,
    structs let us keep it all in one convenient package!
  prefs: []
  type: TYPE_NORMAL
- en: Defined types and structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0236-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, you’ve used a variety of types, like `int`, `string`,
    `bool`, slices, maps, and now structs. But you haven’t been able to create completely
    *new* types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type definitions** allow you to create types of your own. They let you create
    a new **defined type** that’s based on an **underlying type**.'
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use any type as an underlying type, such as `float64`, `string`,
    or even slices or maps, in this chapter we’re going to focus on using struct types
    as underlying types. We’ll try using other underlying types when we take a deeper
    look at defined types in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To write a type definition, use the `type` keyword, followed by the name for
    your new defined type, and then the underlying type you want to base it on. If
    you’re using a struct type as your underlying type, you’ll use the `struct` keyword
    followed by a list of field definitions in curly braces, just as you did when
    declaring struct variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0236-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like variables, type definitions *can* be written within a function. But
    that will limit its scope to that function’s block, meaning you won’t be able
    to use it outside that function. So types are usually defined outside of any functions,
    at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick demonstration, the code below defines two types: `part` and `car`.
    Each defined type uses a struct as its underlying type.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, within the `main` function, we declare a `porsche` variable of the `car`
    type, and a `bolts` variable of the `part` type. There’s no need to rewrite the
    lengthy struct definitions when declaring the variables; we just use the names
    of the defined types.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0237-01.png)'
  prefs: []
  type: TYPE_IMG
- en: With the variables declared, we can set the values of their struct fields and
    get the values back out, just as we did in previous programs.
  prefs: []
  type: TYPE_NORMAL
- en: Using a defined type for magazine subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, to create more than one variable that stored magazine subscriber
    data in a struct, we had to write out the full struct type (including all its
    fields) for each variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0238-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But now, we can simply define a `subscriber` type at the package level. We write
    the struct type just once, as the underlying type for the defined type. When we’re
    ready to declare variables, we don’t have to write the struct type again; we simply
    use `subscriber` as their type. No more need to repeat the entire struct definition!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0238-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using defined types with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defined types can be used for more than just variable types. They also work
    for function parameters and return values.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s our `part` type again, together with a new `showInfo` function that prints
    a part’s fields. The function takes a single parameter, with `part` as its type.
    Within `showInfo`, we access the fields via the parameter variable just like any
    other struct variable’s.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0239-01.png)'
  prefs: []
  type: TYPE_IMG
- en: And here’s a `minimumOrder` function that creates a `part` with a specified
    description and a predefined value for the `count` field. We declare `minimumOrder`’s
    return type to be `part` so it can return the new struct.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0239-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s go over a couple functions that work with the magazine’s `subscriber`
    type...
  prefs: []
  type: TYPE_NORMAL
- en: The `printInfo` function takes a `subscriber` as a parameter, and prints the
    values of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a `defaultSubscriber` function that sets up a new `subscriber`
    struct with some default values. It takes a string parameter called `name`, and
    uses that to set a new `subscriber` value’s `name` field. Then it sets the `rate`
    and `active` fields to default values. Finally, it returns the completed `subscriber`
    struct to its caller.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0240-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In our `main` function, we can pass a subscriber name to `defaultSubscriber`
    to get a new `subscriber` struct. One subscriber gets a discounted `rate`, so
    we reset that struct field directly. We can pass filled-out `subscriber` structs
    to `printInfo` to print out their contents.
  prefs: []
  type: TYPE_NORMAL
- en: Code Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0241-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go program is scrambled up on the fridge. Can you reconstruct the code snippets
    to make a working program that will produce the given output? The finished program
    will have a defined struct type named `student`, and a `printInfo` function that
    accepts a `student` value as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0241-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_6).'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a struct using a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0242-01.png)![image](assets/f0242-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Our friends at *Gopher Fancy* are trying to write a function that takes a struct
    as a parameter and updates one of the fields in that struct.
  prefs: []
  type: TYPE_NORMAL
- en: Remember way back in [Chapter 3](ch03.html#call_mecolon_functions), when we
    were trying to write a `double` function that took a number and doubled it? After
    `double` returned, the number was back to its original value!
  prefs: []
  type: TYPE_NORMAL
- en: That’s when we learned that Go is a “pass-by-value” language, meaning that function
    parameters receive a *copy* of the arguments the function was called with. If
    a function changes a parameter value, it’s changing the *copy*, not the *original*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0242-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The same thing is true for structs. When we pass a `subscriber` struct to `applyDiscount`,
    the function receives a *copy* of the struct. So when we set the `rate` field
    on the struct, we’re modifying the *copied* struct, not the original.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0242-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Back in [Chapter 3](ch03.html#call_mecolon_functions), our solution was to update
    the function parameter to accept a *pointer* to a value, instead of accepting
    a value directly. When calling the function, we used the address-of operator (`&`)
    to pass a pointer to the value we wanted to update. Then, within the function,
    we used the `*` operator to update the value at that pointer.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the updated value was still visible after the function returned.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0243-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use pointers to allow a function to update a struct as well.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an updated version of the `applyDiscount` function that should work correctly.
    We update the `s` parameter to accept a pointer to a `subscriber` struct, rather
    than the struct itself. Then we update the value in the struct’s `rate` field.
  prefs: []
  type: TYPE_NORMAL
- en: In `main`, we call `applyDiscount` with a pointer to a `subscriber` struct.
    When we print the value in the struct’s `rate` field, we can see that it’s been
    updated successfully!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0243-02.png)![image](assets/f0243-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Actually, no! The dot notation to access fields works on struct pointers
    as well as the structs themselves.**'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing struct fields through a pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try to print a pointer variable, what you’ll see is the memory address
    it points to. This is generally not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0244-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead, you need to use the `*` operator (what we like to call the “value-at
    operator”) to get the value at the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0244-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So you might think you’d need to use the `*` operator with pointers to structs
    as well. But just putting a `*` before the struct pointer won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0244-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If you write `*pointer.myField`, Go thinks that `myField` must contain a pointer.
    It doesn’t, though, so an error results. To get this to work, you need to wrap
    `*pointer` in parentheses. That will cause the `myStruct` value to be retrieved,
    after which you can access the struct field.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0244-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Having to write `(*pointer).myField` all the time would get tedious quickly,
    though. For this reason, the dot operator lets you access fields via *pointers*
    to structs, just as you can access fields directly from struct values. You can
    leave off the parentheses and the `*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0245-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This works for assigning to struct fields through a pointer as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0245-02.png)'
  prefs: []
  type: TYPE_IMG
- en: And that’s how the `applyDiscount` function is able to update the struct field
    without using the `*` operator. It assigns to the `rate` field *through* the struct
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0245-03.png)'
  prefs: []
  type: TYPE_IMG
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: You showed a `defaultSubscriber` function before that set a struct’s fields,
    but it didn’t need to use any pointers! Why not?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** The `defaultSubscriber` function *returned* a struct value. If a caller
    stores the returned value, then the values in its fields will be preserved. Only
    functions that *modify existing* structs without returning them have to use pointers
    for those changes to be preserved.'
  prefs: []
  type: TYPE_NORMAL
- en: But `defaultSubscriber` *could* have returned a pointer to a struct, if we had
    wanted it to. In fact, we make just that change in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Pass large structs using pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0246-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Yes, it will. It has to make room for the original struct and the copy.**'
  prefs: []
  type: TYPE_NORMAL
- en: Functions receive a copy of the arguments they’re called with, even if they’re
    a big value like a struct.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why, unless your struct has only a couple small fields, it’s often a
    good idea to pass functions a *pointer* to a struct, rather than the struct itself.
    (This is true even if the function doesn’t need to modify the struct.) When you
    pass a struct pointer, only one copy of the original struct exists in memory.
    The function just receives the memory address of that single struct, and can read
    the struct, modify it, or whatever else it needs to do, all without making an
    extra copy.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s our `defaultSubscriber` function, updated to return a pointer, and our
    `printInfo` function, updated to receive a pointer. Neither of these functions
    needs to change an existing struct like `applyDiscount` does. But using pointers
    ensures that only one copy of each struct needs to be kept in memory, while still
    allowing the program to work as normal.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0246-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving our struct type to a different package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0248-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That should be easy to do. Find the *headfirstgo* directory within your Go workspace,
    and create a new directory in there to hold a package named `magazine`. Within
    *magazine*, create a file named *magazine.go*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0248-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to add a `package magazine` declaration at the top of *magazine.go*.
    Then, copy the `subscriber` struct definition from your existing code and paste
    it into *magazine.go*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0248-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, let’s create a program to try out the new package. Since we’re just experimenting
    for now, let’s not create a separate package folder for this code; we’ll just
    run it using the `go run` command. Create a file named *main.go*. You can save
    it in any directory you want, but make sure you save it *outside* your Go workspace,
    so it doesn’t interfere with any other packages.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0248-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (You can move this code into your Go workspace later, if you want, as long as
    you create a separate package directory for it.)
  prefs: []
  type: TYPE_NORMAL
- en: Within *main.go*, save this code, which simply creates a new `subscriber` struct
    and accesses one of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: There are two differences from the previous examples. First, we need to import
    the `magazine` package at the top of the file. Second, we need to use `magazine.subscriber`
    as the type name, since it belongs to another package now.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0248-05.png)'
  prefs: []
  type: TYPE_IMG
- en: A defined type’s name must be capitalized to be exported
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see if our experimental code can still access the `subscriber` struct
    type in its new package. In your terminal, change into the directory where you
    saved *main.go*, then enter `**go run main.go**`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0249-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get a couple errors, but here’s the important one: `cannot refer to unexported
    name magazine.subscriber`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go type names follow the same rule as variable and function names: if the name
    of a variable, function, or type begins with a capital letter, it is considered
    *exported* and can be accessed from outside the package it’s declared in. But
    our `subscriber` type name begins with a lowercase letter. That means it can only
    be used within the `magazine` package.'
  prefs: []
  type: TYPE_NORMAL
- en: '**For a type to be accessed outside the package it’s defined in, it must be
    exported: its name must begin with a capital letter.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Well, that seems like an easy fix. We’ll just open our *magazine.go* file and
    capitalize the name of the defined type. Then, we’ll open *main.go* and capitalize
    the names of any references to that type. (There’s just one right now.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0249-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If we try running the updated code with `go run main.go`, we no longer get the
    error saying that the `magazine.subscriber` type is unexported. So that seems
    to be fixed. But we get a couple new errors in its place...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0249-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Struct field names must be capitalized to be exported
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `Subscriber` type name capitalized, we seem to be able to access it
    from the `main` package. But now we’re getting an error saying that we can’t refer
    to the `rate` *field*, because *that* is unexported.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0250-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Even if a struct type is exported from a package, its fields will be *unexported*
    if their names don’t begin with a capital letter. Let’s try capitalizing `Rate`
    (in both *magazine.go* and *main.go*)...
  prefs: []
  type: TYPE_NORMAL
- en: '**Struct field names must also be capitalized if you want to export them from
    their package.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](assets/f0250-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Run *main.go* again, and you’ll see that everything works this time. Now that
    they’re exported, we can access the `Subscriber` type *and* its `Rate` field from
    the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0250-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the code worked even though the `name` and `active` fields were
    still unexported. You can have a mixture of exported and unexported fields within
    a single struct type, if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s probably not advisable in the case of the `Subscriber` type, though.
    It wouldn’t make sense to be able to access the subscription rate from other packages,
    but not the name or address. So let’s go back into *magazine.go* and export the
    other fields as well. Simply capitalize their names: `Name` and `Active`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0250-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Struct literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to define a struct and then assign values to its fields one by one
    can get a bit tedious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, just as with slices and maps, Go offers **struct literals** to let you create
    a struct and set its fields at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax looks similar to a map literal. The type is listed first, followed
    by curly braces. Within the braces, you can specify values for some or all of
    the struct fields, using the field name, a colon, and then the value. If you specify
    multiple fields, separate them with commas.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0251-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Above, we showed some code that creates a `Subscriber` struct and sets its
    fields, one by one. This code does the same thing in a single line, using a struct
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0251-03.png)'
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that for most of the chapter, we’ve had to use long-form
    declarations for struct variables (unless the struct was being returned from a
    function). Struct literals allow us to use short variable declarations for a struct
    we’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: You can omit some or even all of the fields from the curly braces. Omitted fields
    will be set to the zero value for their type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0251-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0252-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0252-02.png)![image](assets/f0252-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: each snippet from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_5).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Employee struct type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0253-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding an `Employee` struct type should be pretty easy. We’ll just add it to
    the `magazine` package, alongside the `Subscriber` type. In *magazine.go*, define
    a new `Employee` type, with a `struct` underlying type. Give the struct type a
    `Name` field with a type of `string`, and a `Salary` field with a type of `float64`.
    Be sure to capitalize the type name *and* all the fields, so that they’re exported
    from the `magazine` package.
  prefs: []
  type: TYPE_NORMAL
- en: We can update the `main` function in *main.go* to try the new type out. First,
    declare a variable with the type `magazine.Employee`. Then assign values of the
    appropriate type to each of the fields. Finally, print those values out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0253-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you execute `go run main.go` from your terminal, it should run, create a
    new `magazine.Employee` struct, set its field values, and then print those values
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Address struct type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to track mailing addresses for both the `Subscriber` and `Employee`
    types. We’re going to need fields for the street address, city, state, and postal
    code (zip code).
  prefs: []
  type: TYPE_NORMAL
- en: 'We *could* add separate fields to both the `Subscriber` and `Employee` types,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0254-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But mailing addresses are going to have the same format, no matter what type
    they belong to. It’s a pain to have to repeat all those fields between multiple
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Struct fields can hold values of any type, *including other structs*. So, instead,
    let’s try building an `Address` struct type, and then adding an `Address` field
    on the `Subscriber` and `Employee` types. That will save us some effort now, and
    ensure consistency between the types later if we have to change the address format.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create just the `Address` type first, so we can ensure it’s working correctly.
    Place it in the `magazine` package, alongside the `Subscriber` and `Employee`
    types. Then, replace the code in *main.go* with a few lines to create an `Address`
    and ensure its fields are accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0254-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Type `**go run main.go**` in your terminal, and it should create an `Address`
    struct, populate its fields, and then print the whole struct out.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a struct as a field on another type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’re sure the `Address` struct type works by itself, let’s add `HomeAddress`
    fields to the `Subscriber` and `Employee` types.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a struct field that is itself a struct type is no different than adding
    a field of any other type. You provide a name for the field, followed by the field’s
    type (which in this case will be a struct type).
  prefs: []
  type: TYPE_NORMAL
- en: Add a field named `HomeAddress` to the `Subscriber` struct. Make sure to capitalize
    the field name, so that it’s accessible from outside the `magazine` package. Then
    specify the field type, which is `Address`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `HomeAddress` field to the `Employee` type as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0255-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up a struct within another struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s see if we can populate the fields of the `Address` struct *within*
    the `Subscriber` struct. There are a couple ways to go about this.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is to create an entirely separate `Address` struct and then
    use it to set the entire `Address` field of the `Subscriber` struct. Here’s an
    update to *main.go* that follows this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0255-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Type `**go run main.go**` in your terminal, and you’ll see the subscriber’s
    `HomeAddress` field has been set to the struct you built.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to set the fields of the inner struct *through* the outer
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a `Subscriber` struct is created, its `HomeAddress` field is already set:
    it’s an `Address` struct with all its fields set to their zero values. If we print
    `HomeAddress` using the `"%#v"` verb for `fmt.Printf`, it will print the struct
    as it would appear in Go code — that is, as a struct literal. We’ll see that each
    of the `Address` fields is set to an empty string, which is the zero value for
    the `string` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0256-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If `subscriber` is a variable that contains a `Subscriber` struct, then when
    you type `subscriber.HomeAddress`, you’ll get an `Address` struct, even if you
    haven’t explicitly set `HomeAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this fact to “chain” dot operators together so you can access the
    fields of the `Address` struct. Simply type `**subscriber.HomeAddress**` to access
    the `Address` struct, followed by *another* dot operator and the name of the field
    you want to access on that `Address` struct.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0256-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This works both for assigning values to the inner struct’s fields...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '...and for retrieving those values again later.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an update to *main.go* that uses dot operator chaining. First we store
    a `Subscriber` struct in the `subscriber` variable. That will automatically create
    an `Address` struct in `subscriber`’s `HomeAddress` field. We set values for `subscriber.HomeAddress.Street`,
    `subscriber.HomeAddress.City`, and so on, and then print those values out again.
  prefs: []
  type: TYPE_NORMAL
- en: Then we store an `Employee` struct in the `employee` variable, and do the same
    for its `HomeAddress` struct.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0257-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Type `**go run main.go**` in your terminal, and the program will print out the
    completed fields of both `subscriber.HomeAddress` and `employee.HomeAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous struct fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code to access the fields of an inner struct through its outer struct can
    be a bit tedious, though. You have to write the field name of the inner struct
    (`HomeAddress`) each time you want to access any of the fields it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0258-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go allows you to define **anonymous fields**: struct fields that have no name
    of their own, just a type. We can use an anonymous field to make our inner struct
    easier to access.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an update to the `Subscriber` and `Employee` types to convert their `HomeAddress`
    fields to an anonymous field. To do this, we simply remove the field name, leaving
    only the type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0258-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you declare an anonymous field, you can use the field’s type name as if
    it were the name of the field. So `subscriber.Address` and `employee.Address`
    in the code below still access the `Address` structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0258-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Embedding structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But anonymous fields offer much more than just the ability to skip providing
    a name for a field in a struct definition.
  prefs: []
  type: TYPE_NORMAL
- en: An inner struct that is stored within an outer struct using an anonymous field
    is said to be **embedded** within the outer struct. Fields for an embedded struct
    are **promoted** to the outer struct, meaning you can access them as if they belong
    to the outer struct.
  prefs: []
  type: TYPE_NORMAL
- en: So now that the `Address` struct type is embedded within the `Subscriber` and
    `Employee` struct types, you don’t have to write out `subscriber.Address.City`
    to get at the `City` field; you can just write `subscriber.City`. You don’t need
    to write `employee.Address.State`; you can just write `employee.State`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s one last version of *main.go*, updated to treat `Address` as an embedded
    type. You can write the code as if there were no `Address` type at all; it’s like
    the `Address` fields belong to the struct type they’re embedded within.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0259-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that you don’t *have* to embed inner structs. You don’t have to
    use inner structs at all. Sometimes adding new fields on the outer struct leads
    to the clearest code. Consider your current situation, and go with the solution
    that works best for you and your users.
  prefs: []
  type: TYPE_NORMAL
- en: Our defined types are complete!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0260-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Nice work! You’ve defined `Subscriber` and `Employee` struct types, and embedded
    an `Address` struct in each of them. You’ve found a way to represent all the data
    the magazine needed!
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re still missing an important aspect to defined types, though. In previous
    chapters, you’ve used types like `time.Time` and `strings.Replacer` that have
    *methods*: functions that you can call *on* their values. But you haven’t learned
    how to define methods for your own types yet. Don’t worry; we’ll learn all about
    it in the next chapter!'
  prefs: []
  type: TYPE_NORMAL
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0261-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 8](#building_storagecolon_structs)! You’ve added structs
    and defined types to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0261-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0262-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0264-01.png)'
  prefs: []
  type: TYPE_IMG
