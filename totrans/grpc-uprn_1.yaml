- en: Chapter 1\. Introduction to gRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。gRPC 简介
- en: Modern software applications rarely operate in isolation. Rather, they are connected
    with each other through computer networks and communicate and coordinate their
    actions by passing messages to one another. Therefore, a modern software system
    is a collection of distributed software applications that are running at different
    network locations and communicate with each other with message passing using different
    communication protocols. For example, an online retail software system comprises
    multiple distributed applications such as an order management application, catalog
    application, databases, and so on. To implement the business functionalities of
    an online retail system, it is required to have interconnectivity between those
    distributed applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件应用很少独立运行。相反，它们通过计算机网络相互连接，并通过传递消息来通信和协调它们的操作。因此，现代软件系统是运行在不同网络位置的分布式软件应用集合，并使用不同的通信协议通过消息传递来彼此通信。例如，一个在线零售软件系统包括多个分布式应用程序，如订单管理应用程序、目录应用程序、数据库等等。为了实现在线零售系统的业务功能，需要这些分布式应用程序之间的互联互通。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Microservices Architecture**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**'
- en: Microservices architecture is about building a software application as a collection
    of independent, autonomous (developed, deployed, and scaled independently), business
    capability–oriented, and loosely coupled services.^([1](ch01.html#idm46536655629784))
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是将软件应用程序构建为独立、自治（独立开发、部署和扩展）、面向业务能力的松散耦合服务集合的过程。^([1](ch01.html#idm46536655629784))
- en: With the advent of [microservices architecture](https://oreil.ly/q6N1P) and
    [cloud native architecture](https://oreil.ly/8Ow2T), conventional software applications
    that are built for multiple business capabilities are further segregated into
    a collection of fine-grained, autonomous, and business capability–oriented entities
    known as microservices. Therefore, a microservices-based software system also
    requires the microservices to be connected through the network using inter-process
    (or inter-service or inter-application) communication techniques. As an example,
    if we consider the same online retail system implemented using microservices architecture,
    you will find multiple interconnected microservices such as order management,
    search, checkout, shipping, and so on. Unlike conventional applications, the number
    of network communication links proliferates because of the fine-grained nature
    of microservices. Therefore, no matter the architectural style (conventional or
    microservices architecture) you use, inter-process communication techniques are
    one of the most important aspects of modern distributed software applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着[微服务架构](https://oreil.ly/q6N1P)和[云原生架构](https://oreil.ly/8Ow2T)的出现，为多个业务能力构建的传统软件应用程序进一步分割成一组细粒度、自治和业务能力导向的实体，称为微服务。因此，基于微服务的软件系统也要求微服务通过网络使用进程间（或服务间或应用间）通信技术进行连接。例如，如果我们考虑使用微服务架构实现的同一在线零售系统，您会发现多个相互连接的微服务，如订单管理、搜索、结账、运输等等。与传统应用程序不同，由于微服务的细粒度特性，网络通信链接的数量大大增加。因此，无论您使用的是传统架构还是微服务架构，进程间通信技术都是现代分布式软件应用程序中最重要的方面之一。
- en: Inter-process communications are usually implemented using message passing with
    a synchronous request-response style or asynchronous event-driven styles. In the
    synchronous communication style, the client process sends a request message to
    the server process over the network and waits for a response message. In asynchronous
    event-driven messaging, processes communicate with asynchronous message passing
    by using an intermediary known as an *event broker*. Depending on your business
    use case, you can select the communication pattern that you want to implement.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 进程间通信通常采用同步请求-响应风格或异步事件驱动风格进行实现。在同步通信风格中，客户端进程通过网络向服务器进程发送请求消息，并等待响应消息。在异步事件驱动消息传递中，进程通过使用称为*事件代理*的中介进行异步消息传递进行通信。根据您的业务用例，可以选择要实现的通信模式。
- en: When it comes to building synchronous request-response style communication for
    modern cloud native applications and microservices, the most common and conventional
    approach is to build them as RESTful services, where you model your application
    or service as a collection of resources that can be accessed and have their state
    changed via network calls that take place over the HTTP protocol. However, for
    most use cases RESTful services are quite bulky, inefficient, and error-prone
    for building inter-process communication. It is often required to have a highly
    scalable, loosely coupled inter-process communication technology that is more
    efficient than RESTful services. This is where gRPC, a modern inter-process communication
    style for building distributed applications and microservices, comes into the
    picture (we’ll compare and contrast gRPC with RESTful communication later in this
    chapter). gRPC primarily uses a synchronous request-response style for communication
    but can operate in fully asynchronous or streaming mode once the initial communication
    is established.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及构建现代云原生应用程序和微服务的同步请求-响应式通信时，最常见和传统的方法是将它们构建为 RESTful 服务，其中您将应用程序或服务建模为可以通过网络调用访问并通过
    HTTP 协议改变其状态的资源集合。然而，对于大多数用例来说，RESTful 服务相当笨重、效率低下，并且易于出错，用于构建进程间通信。通常需要一种高度可扩展、松耦合的进程间通信技术，其效率比
    RESTful 服务更高。这就是现代进程间通信样式 gRPC 出现的地方（我们将在本章后期将 gRPC 与 RESTful 通信进行比较）。gRPC 主要使用同步请求-响应式样式进行通信，但一旦建立了初始通信，它也可以以完全异步或流模式运行。
- en: In this chapter, we’ll explore what gRPC is and the key motivations behind inventing
    such an inter-process communication protocol. We dive into the key building blocks
    of the gRPC protocol with the help of some real-world use cases. Also, it’s important
    to have a solid understanding of inter-process communication techniques and how
    they have evolved over time so that you can understand the key problems that gRPC
    is trying to solve. So, we’ll walk through those techniques and compare and contrast
    each of them. Let’s begin our discussion on gRPC by looking at what gRPC is.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 gRPC 是什么，以及发明这种进程间通信协议背后的主要动机。我们将通过一些真实的用例来深入了解 gRPC 协议的关键构建块。此外，了解进程间通信技术的基本原理及其随时间演变的过程非常重要，这样您就可以理解
    gRPC 试图解决的关键问题。因此，我们将详细介绍这些技术，并对比每一种。让我们从 gRPC 是什么开始讨论。
- en: What Is gRPC?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 是什么？
- en: gRPC (the “g” stands for something different in [every gRPC release](https://oreil.ly/IKCi3))
    is an inter-process communication technology that allows you to connect, invoke,
    operate, and debug distributed heterogeneous applications as easily as making
    a local function call.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC（“g”在[每个 gRPC 发布版本中都有不同的含义](https://oreil.ly/IKCi3)）是一种进程间通信技术，允许您像调用本地函数一样连接、调用、操作和调试分布式异构应用程序。
- en: When you develop a gRPC application the first thing that you do is define a
    service interface. The service interface definition contains information on how
    your service can be consumed by consumers, what methods you allow the consumers
    to call remotely, what method parameters and message formats to use when invoking
    those methods, and so on. The language that we specify in the service definition
    is known as an *interface definition language* (IDL).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发 gRPC 应用程序时，首先要做的是定义一个服务接口。服务接口定义包含了有关你的服务如何被消费者消费的信息，允许消费者远程调用哪些方法，调用这些方法时使用的方法参数和消息格式等信息。我们在服务定义中指定的语言被称为*接口定义语言*（IDL）。
- en: Using that service definition, you can generate the server-side code known as
    a *server skeleton*, which simplifies the server-side logic by providing low-level
    communication abstractions. Also, you can generate the client-side code, known
    as a *client stub*, which simplifies the client-side communication with abstractions
    to hide low-level communication for different programming languages. The methods
    that you specify in the service interface definition can be remotely invoked by
    the client side as easily as making a local function invocation. The underlying
    gRPC framework handles all the complexities that are normally associated with
    enforcing strict service contracts, data serialization, network communication,
    authentication, access control, observability, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该服务定义，您可以生成称为*服务器骨架*的服务器端代码，它通过提供低级通信抽象简化了服务器端逻辑。同时，您还可以生成客户端代码，称为*客户端存根*，它通过抽象隐藏不同编程语言的低级通信，简化了客户端通信。在服务接口定义中指定的方法可以被客户端远程调用，就像调用本地函数一样简单。底层的
    gRPC 框架处理了通常与强制执行严格服务合同、数据序列化、网络通信、身份验证、访问控制、可观测性等相关的所有复杂性。
- en: To understand the fundamental concepts of gRPC, let’s take a look at a real-world
    use case of a microservice implemented with gRPC. Suppose we are building an online
    retail application comprised of multiple microservices. As illustrated in [Figure 1-1](#a_microservice_and_a_consumer_based_on_grpc),
    suppose that we want to build a microservice that gives the details of the products
    that are available in our online retail application (we will implement this use
    case from the ground up in [Chapter 2](ch02.html#ch_02)). The `ProductInfo` service
    is modeled in such a way that it is exposed over the network as a gRPC service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 gRPC 的基本概念，让我们看一个使用 gRPC 实现的微服务的真实用例。假设我们正在构建一个由多个微服务组成的在线零售应用程序。如 [图 1-1](#a_microservice_and_a_consumer_based_on_grpc)
    所示，假设我们想要构建一个微服务，提供在线零售应用程序中可用产品的详细信息（我们将在 [第 2 章](ch02.html#ch_02) 中从头开始实现此用例）。`ProductInfo`
    服务被建模为以 gRPC 服务形式通过网络公开。
- en: '![A microservice and a consumer based on gRPC](assets/grpc_0101.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![基于 gRPC 的微服务和消费者](assets/grpc_0101.png)'
- en: Figure 1-1\. A microservice and a consumer based on gRPC
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 基于 gRPC 的微服务和消费者
- en: The service definition is specified in the *ProductInfo.proto* file, which is
    used by both the server and client sides to generate the code. In this example,
    we have assumed that the service is implemented using the Go language and that
    the consumer is implemented using Java. The network communication between the
    service and consumer takes place over HTTP/2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义在*ProductInfo.proto*文件中指定，该文件被服务器和客户端使用以生成代码。在本例中，我们假设服务使用 Go 语言实现，消费者使用
    Java 实现。服务和消费者之间的网络通信通过 HTTP/2 进行。
- en: Now let’s delve into the details of this gRPC communication. The first step
    of building a gRPC service is to create the service interface definition with
    the methods that are exposed by that service along with input parameters and return
    types. Let’s move on to the details of the service definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解这种 gRPC 通信的详细信息。构建 gRPC 服务的第一步是创建服务接口定义，包括该服务暴露的方法以及输入参数和返回类型。让我们继续详细了解服务定义的内容。
- en: Service Definition
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务定义
- en: gRPC uses [protocol buffers](https://oreil.ly/iFi-b) as the IDL to define the
    service interface. Protocol buffers are a language-agnostic, platform-neutral,
    extensible mechanism to serializing structured data (we’ll cover some of the fundamentals
    of protocol buffers in detail in [Chapter 4](ch04.html#ch_04), but for now you
    can think of it as a data serialization mechanism). The service interface definition
    is specified in a proto file—an ordinary text file with a *.proto* extension.
    You define gRPC services in ordinary protocol buffer format, with RPC method parameters
    and return types specified as protocol buffer messages. Since the service definition
    is an extension to the protocol buffer specification, a special gRPC plug-in is
    used to generate code from your proto file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 [协议缓冲区](https://oreil.ly/iFi-b) 作为接口定义语言（IDL）来定义服务接口。协议缓冲区是一种语言无关、平台中立、可扩展的机制，用于序列化结构化数据（我们将在
    [第 4 章](ch04.html#ch_04) 中详细介绍协议缓冲区的一些基础知识，但目前您可以将其视为一种数据序列化机制）。服务接口定义以 *.proto*
    扩展名的普通文本文件的形式指定。您以普通的协议缓冲区格式定义 gRPC 服务，包括指定 RPC 方法参数和返回类型作为协议缓冲区消息。由于服务定义是协议缓冲区规范的扩展，需要使用特殊的
    gRPC 插件从您的 proto 文件生成代码。
- en: In our example use case, the `ProductInfo` service’s interface can be defined
    using protocol buffers as shown in [Example 1-1](#EX1-1). The service definition
    of `ProductInfo` is comprised of a service interface definition where we specify
    the remote methods, their input and output parameters, and the type definition
    (or message formats) of those parameters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例用例中，可以使用协议缓冲定义 `ProductInfo` 服务的接口，如 [示例 1-1](#EX1-1) 所示。`ProductInfo`
    的服务定义由服务接口定义组成，我们在其中指定远程方法、它们的输入和输出参数以及这些参数的类型定义（或消息格式）。
- en: Example 1-1\. gRPC service definition of ProductInfo service using protocol
    buffers
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. 使用协议缓冲定义 ProductInfo 服务的 gRPC 服务定义
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_introduction_to_grpc_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_introduction_to_grpc_CO1-1)'
- en: The service definition begins with specifying the protocol buffer version (proto3)
    that we use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义以指定我们使用的协议缓冲版本（proto3）开始。
- en: '[![2](assets/2.png)](#co_introduction_to_grpc_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_introduction_to_grpc_CO1-2)'
- en: Package names are used to prevent name clashes between protocol message types
    and also will be used to generate code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称用于防止协议消息类型之间的名称冲突，也将用于生成代码。
- en: '[![3](assets/3.png)](#co_introduction_to_grpc_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_introduction_to_grpc_CO1-3)'
- en: Defining the service interface of a gRPC service.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 gRPC 服务的服务接口。
- en: '[![4](assets/4.png)](#co_introduction_to_grpc_CO1-4)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_introduction_to_grpc_CO1-4)'
- en: Remote method to add a product that returns the product ID as the response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用于添加产品并返回产品ID作为响应的远程方法。
- en: '[![5](assets/5.png)](#co_introduction_to_grpc_CO1-5)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_introduction_to_grpc_CO1-5)'
- en: Remote method to get a product based on the product ID.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于根据产品ID获取产品的远程方法。
- en: '[![6](assets/6.png)](#co_introduction_to_grpc_CO1-6)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_introduction_to_grpc_CO1-6)'
- en: Definition of the message format/type of `Product`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `Product` 的消息格式/类型。
- en: '[![7](assets/7.png)](#co_introduction_to_grpc_CO1-7)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_introduction_to_grpc_CO1-7)'
- en: Field (name-value pair) that holds the product ID with unique field numbers
    that are used to identify your fields in the message binary format.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 字段（名称-值对），用于保存具有唯一字段号的产品ID，在消息二进制格式中用于标识您的字段。
- en: '[![8](assets/8.png)](#co_introduction_to_grpc_CO1-8)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_introduction_to_grpc_CO1-8)'
- en: User-defined type for product identification number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 产品识别号的用户定义类型。
- en: A service is thus a collection of methods (e.g., `addProduct` and `getProduct`)
    that can be remotely invoked. Each method has input parameters and return types
    that we define as either part of the service or that can be imported into the
    protocol buffer definition.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一组可以远程调用的方法（例如，`addProduct` 和 `getProduct`）的集合。每个方法都有我们定义的输入参数和返回类型，可以作为服务的一部分定义，或者可以导入到协议缓冲定义中。
- en: The input and return parameters can be a user-defined type (e.g., `Product`
    and `ProductID` types) or a protocol buffer [well-known type](https://oreil.ly/0Uc3A)
    defined in the service definition. Those types are structured as messages, where
    each message is a small logical record of information containing a series of name-value
    pairs called fields. These fields are name-value pairs with unique field numbers
    (e.g., `string id = 1`) that are used to identify your fields in the message binary
    format.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和返回参数可以是用户定义的类型（例如 `Product` 和 `ProductID` 类型）或在服务定义中定义的协议缓冲器[知名类型](https://oreil.ly/0Uc3A)。这些类型被结构化为消息，其中每个消息是包含一系列名称-值对字段的小逻辑记录。这些字段是具有唯一字段号的名称-值对（例如
    `string id = 1`），用于在消息二进制格式中标识您的字段。
- en: This service definition is used to build the server and client side of your
    gRPC application. In the next section, we’ll go into the details of gRPC server
    implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务定义用于构建您的 gRPC 应用程序的服务器和客户端。在下一节中，我们将详细介绍 gRPC 服务器的实现。
- en: gRPC Server
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 服务器
- en: Once you have a service definition in place, you can use it to generate the
    server- or client-side code using the protocol buffer compiler *protoc*. With
    the gRPC plug-in for protocol buffers, you can generate gRPC server-side and client-side
    code, as well as the regular protocol buffer code for populating, serializing,
    and retrieving your message types.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了服务定义，您可以使用协议缓冲编译器 *protoc* 生成服务器端或客户端代码。使用协议缓冲器的 gRPC 插件，您可以生成 gRPC 服务器端和客户端代码，以及用于填充、序列化和检索消息类型的常规协议缓冲器代码。
- en: 'On the server side, the server implements that service definition and runs
    a gRPC server to handle client calls. Therefore, on the server side, to make the
    `ProductInfo` service do its job you need to do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，服务器实现该服务定义并运行 gRPC 服务器来处理客户端调用。因此，在服务器端，要使`ProductInfo`服务发挥作用，您需要做以下几点：
- en: Implement the service logic of the generated service skeleton by overriding
    the service base class.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过覆盖服务基类实现生成的服务框架的服务逻辑。
- en: Run a gRPC server to listen for requests from clients and return the service
    responses.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 gRPC 服务器以监听来自客户端的请求并返回服务响应。
- en: When implementing service logic, the first thing to do is generate the service
    skeleton from the service definition. For example, in the code snippet in [Example 1-2](#EX1-2),
    you can find the generated remote functions for the `ProductInfo` service built
    with Go. Inside the body of these remote functions you can implement the logic
    of each function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现服务逻辑时，首先要做的是从服务定义生成服务框架。例如，在 [示例 1-2](#EX1-2) 的代码片段中，您可以找到使用 Go 构建的`ProductInfo`服务的生成远程函数。在这些远程函数的主体中，您可以实现每个函数的逻辑。
- en: Example 1-2\. gRPC server-side implementation of ProductInfo service with Go
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 使用 Go 实现 ProductInfo 服务的 gRPC 服务器端
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have the service implementation ready, you need to run a gRPC server
    to listen for requests from clients, dispatch those requests to the service implementation,
    and return the service responses back to the client. The code snippet in [Example 1-3](#EX1-3)
    shows a gRPC server implementation with Go for the `ProductInfo` service use case.
    Here we open up a TCP port, start the gRPC server, and register the `ProductInfo`
    service with that server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好服务实现，您需要运行 gRPC 服务器来监听来自客户端的请求，将这些请求分派给服务实现，并将服务响应返回给客户端。在 [示例 1-3](#EX1-3)
    中的代码片段中，显示了使用 Go 为`ProductInfo`服务用例实现的 gRPC 服务器。在此，我们打开一个 TCP 端口，启动 gRPC 服务器，并在该服务器上注册`ProductInfo`服务。
- en: Example 1-3\. Running a gRPC server for ProductInfo service with Go
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-3\. 使用 Go 运行 ProductInfo 服务的 gRPC 服务器
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s all you have to do on the server side. Let’s move on to the gRPC client-side
    implementation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在服务器端需要做的全部。现在让我们转向 gRPC 客户端实现。
- en: gRPC Client
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 客户端
- en: Similar to the server side, we can generate the client-side stub using the service
    definition. The client stub provides the same methods as the server, which your
    client code can invoke; the client stub translates them to remote function invocation
    network calls that go to the server side. Since gRPC service definitions are language-agnostic,
    you can generate clients and servers for any supported language (via the [third-party
    implementations](https://oreil.ly/psi72)) of your choice. So for the `ProductInfo`
    service use case, we can generate the client stub for Java while our server side
    is implemented with Go. In the code snippet in [Example 1-4](#EX1-4), you find
    the code for Java. Despite the programming language we use, the simple steps involved
    in a client-side implementation involve setting up a connection with the remote
    server, attaching the client stub with that connection, and invoking the remote
    method using the client stub.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于服务器端，我们可以使用服务定义生成客户端存根。客户端存根提供与服务器相同的方法，您的客户端代码可以调用这些方法；客户端存根将它们转换为远程函数调用网络调用，这些调用转到服务器端。由于
    gRPC 服务定义是与语言无关的，您可以为您选择的任何支持的语言生成客户端和服务器（通过您选择的语言的 [第三方实现](https://oreil.ly/psi72)）。因此，对于`ProductInfo`服务用例，我们可以为
    Java 生成客户端存根，而我们的服务器端使用 Go 实现。在 [示例 1-4](#EX1-4) 中的代码片段中，您可以找到 Java 的代码。尽管我们使用的编程语言不同，但客户端实现涉及的简单步骤包括建立与远程服务器的连接、将客户端存根附加到该连接，并使用客户端存根调用远程方法。
- en: Example 1-4\. gRPC client to invoke a remote method of service
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-4\. gRPC 客户端调用服务的远程方法
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you now have a good sense of the key concepts of gRPC, let’s try to understand
    the gRPC client–server message flow in detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对 gRPC 的关键概念有了很好的了解，让我们详细了解 gRPC 客户端与服务器之间的消息流程。
- en: Client–Server Message Flow
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器消息流
- en: When a gRPC client invokes a gRPC service, the client-side gRPC library uses
    the protocol buffer and marshals the remote procedure call protocol buffer format,
    which is then sent over HTTP/2\. On the server side, the request is unmarshaled
    and the respective procedure invocation is executed using protocol buffers. The
    response follows a similar execution flow from the server to the client. As the
    wire transport protocol, gRPC uses HTTP/2, which is a high-performance binary
    message protocol with support for bidirectional messaging. We will further discuss
    the low-level details of the message flow between gRPC clients and servers along
    with protocol buffers and how gRPC uses HTTP/2 in [Chapter 4](ch04.html#ch_04).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当 gRPC 客户端调用 gRPC 服务时，客户端 gRPC 库使用协议缓冲区并封装远程过程调用协议缓冲区格式，然后通过 HTTP/2 发送。在服务器端，请求被解封装，并使用协议缓冲区执行相应的过程调用。响应从服务器到客户端的执行流程类似。作为传输协议，gRPC
    使用 HTTP/2，这是一种高性能的二进制消息协议，支持双向消息传递。我们将进一步讨论 gRPC 客户端和服务器之间的消息流低级细节，以及协议缓冲区以及 gRPC
    如何在 [第四章](ch04.html#ch_04) 中使用 HTTP/2。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Marshaling* is the process of packing parameters and a remote function into
    a message packet that is sent over the network, while unmarshaling unpacks the
    message packet into the respective method invocation.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装* 是将参数和远程函数打包到消息数据包中，然后通过网络发送的过程，而 *解封装* 则将消息数据包解包到相应的方法调用中。'
- en: Before we go further into the gRPC protocol, it’s important to have a broad
    understanding of different inter-process communication technologies and how they
    have evolved with time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论 gRPC 协议之前，了解不同的进程间通信技术及其随时间演变的重要性尤为重要。
- en: Evolution of Inter-Process Communication
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信的演变
- en: Inter-process communication techniques have been drastically evolving over time.
    There are various such techniques emerging to address modern needs and to provide
    a better and more efficient development experience. So, it’s important to have
    a good understanding of how inter-process communication techniques have evolved
    and how they made their way to gRPC. Let’s look at some of the most commonly used
    inter-process communication techniques and try to compare and contrast them with
    gRPC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，进程间通信技术发生了显著的演变。出现了各种这样的技术，以解决现代需求并提供更好、更高效的开发体验。因此，了解进程间通信技术的演变以及它们如何走向
    gRPC 是非常重要的。让我们看一些最常用的进程间通信技术，并尝试与 gRPC 进行比较和对比。
- en: Conventional RPC
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统 RPC
- en: RPC was a popular inter-process communication technique for building client-service
    applications. With RPC a client can remotely invoke a function of a method just
    like calling a local method. There were popular RPC implementations in the early
    days such as the Common Object Request Broker Architecture (CORBA) and Java Remote
    Method Invocation (RMI), which were used for building and connecting services
    or applications. However, most such conventional RPC implementations are overwhelmingly
    complex, as they are built on top of communication protocols such as TCP, which
    hinders interoperability, and are based on bloated specifications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种流行的进程间通信技术，用于构建客户端-服务端应用程序。使用 RPC，客户端可以远程调用方法或函数，就像调用本地方法一样。早期有一些流行的
    RPC 实现，如公共对象请求代理体系结构（CORBA）和Java 远程方法调用（RMI），用于构建和连接服务或应用程序。然而，大多数传统的 RPC 实现非常复杂，因为它们建立在诸如
    TCP 等通信协议之上，这些协议阻碍了互操作性，并且基于臃肿的规范。
- en: SOAP
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOAP
- en: Owing to the limitations of conventional RPC implementations such as CORBA,
    Simple Object Access Protocol (SOAP) was designed and heavily promoted by large-scale
    enterprises such as Microsoft, IBM, etc. SOAP is the standard communication technique
    in a service-oriented architecture (SOA) to exchange XML-based structured data
    between services (usually called web services in the context of SOA) and communicates
    over any underlying communication protocol such as HTTP (most commonly used).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于诸如 CORBA 等传统 RPC 实现的局限性，简单对象访问协议（SOAP）被设计出来，并得到微软、IBM 等大型企业的大力推广。SOAP 是服务导向架构（SOA）中的标准通信技术，用于在服务之间交换基于
    XML 结构化数据（通常在 SOA 上下文中称为 Web 服务），并可以通过任何底层通信协议（如 HTTP，最常用）进行通信。
- en: With SOAP you can define the service interface, operations of that service,
    and an associated XML message format to be used to invoke those operations. SOAP
    was quite a popular technology but the complexity of message format, as well as
    the complexities of specifications built around SOAP, hinders the agility of building
    distributed applications. Therefore, in the context of modern distributed application
    development, SOAP web services are considered a legacy technology. Rather than
    using SOAP, most of the existing distributed applications are now being developed
    using the REST architecture style.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SOAP   使用 SOAP 可以定义服务接口、该服务的操作以及用于调用这些操作的关联 XML 消息格式。SOAP 曾经是一项相当流行的技术，但消息格式的复杂性以及围绕
    SOAP 构建的规范的复杂性阻碍了构建分布式应用程序的灵活性。因此，在现代分布式应用程序开发的背景下，SOAP Web 服务被视为一项传统技术。现在，大多数现有的分布式应用程序都是使用
    REST 架构风格进行开发，而不是使用 SOAP。
- en: REST
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: Representational State Transfer (REST) is an architectural style that originated
    from Roy Fielding’s PhD [dissertation](https://oreil.ly/6tRrt). Fielding is one
    of the principal authors of the HTTP specification and the originator of the REST
    architectural style. REST is the foundation of the resource-oriented architecture
    (ROA), where you model distributed applications as a collection of resources and
    the clients that access those resources can change the state (create, read, update,
    or delete) of those resources.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表述性状态转移（REST）是一种架构风格，起源于罗伊·菲尔丁（Roy Fielding）的博士论文。菲尔丁是 HTTP 规范的主要作者之一，也是 REST
    架构风格的创始人。REST 是资源导向架构（ROA）的基础，其中你将分布式应用程序建模为一组资源，访问这些资源的客户端可以更改这些资源的状态（创建、读取、更新或删除）。
- en: The de facto implementation of REST is HTTP, and in HTTP you can model a RESTful
    web application as a collection of resources accessible using a unique identifier
    (URL). The state-changing operations are applied on top of those resources in
    the form of the HTTP verbs (GET, POST, PUT, DELETE, PATCH, and so on). The resource
    state is represented in textual formats such as JSON, XML, HTML, YAML, and so
    on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: REST 的事实实现是 HTTP，在 HTTP 中，你可以将 RESTful Web 应用程序建模为一组使用唯一标识符（URL）可访问的资源集合。状态更改操作以
    HTTP 动词（GET、POST、PUT、DELETE、PATCH 等）的形式应用于这些资源之上。资源状态以文本格式表示，例如 JSON、XML、HTML、YAML
    等等。
- en: Building applications using the REST architectural style with HTTP and JSON
    has become the de facto method of building microservices. However, with the proliferation
    of the number of microservices and their network interactions RESTful services
    have not been able to meet the expected modern requirements. There are a couple
    of key limitations of RESTful services that hinder the ability to use them as
    the messaging protocol for modern microservices-based applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 REST 架构风格和 HTTP、JSON 构建应用程序已成为构建微服务的事实标准方法。然而，随着微服务数量的增加以及它们的网络交互，RESTful
    服务无法满足预期的现代要求。RESTful 服务存在几个关键限制，阻碍了将它们用作现代基于微服务的应用程序的消息传递协议。
- en: Inefficient text-based message protocols
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低效的基于文本的消息协议
- en: Inherently, RESTful services are built on top of text-based transport protocols
    such as HTTP 1.x and leverage human-readable textual formats such as JSON. When
    it comes to service-to-service communication, it is quite inefficient to use a
    textual format such as JSON because both parties to that communication do not
    need to use such human-readable textual formats.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，RESTful 服务是建立在诸如 HTTP 1.x 之类的基于文本的传输协议之上的，并利用 JSON 等人类可读的文本格式。当涉及到服务之间的通信时，使用
    JSON 等文本格式非常低效，因为通信的双方都不需要使用这种人类可读的文本格式。
- en: The client application (source) produces binary content to be sent to the server,
    then it converts the binary structure into text (because with HTTP 1.x you have
    to send textual messages) and sends it over the network in text (over HTTP) to
    a machine that parses and turns it back into a binary structure on the service
    (target) side. Rather, we could have easily sent a binary format that can be mapped
    to a service’s and consumer’s business logic. One popular argument for using JSON
    is that it is easier to use because it’s “human-readable.” This is more a tooling
    problem than a problem with the binary protocols.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序（源）生成要发送到服务器的二进制内容，然后将二进制结构转换为文本（因为在HTTP 1.x中必须发送文本消息），并通过网络以文本形式（通过HTTP）发送到解析并将其转换回服务（目标）端的机器。而实际上，我们本可以轻松地发送一种可以映射到服务和消费者业务逻辑的二进制格式。使用JSON的一个流行论点是它更易于使用，因为它是“人类可读的”。这更多是一个工具问题，而不是二进制协议的问题。
- en: Lacks strongly typed interfaces between apps
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺乏应用程序之间的强类型接口
- en: With the increasing number of services interacting over the network that are
    built with disparate polyglot technologies, the lack of well-defined and strongly
    typed service definitions was a major setback. Most of the existing service definition
    technologies that we have in RESTful services, such as OpenAPI/Swagger, are afterthoughts
    and not tightly integrated with the underlying architectural style or messaging
    protocols.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着使用不同多语言技术构建的服务在网络上交互的数量增加，缺乏明确定义和强类型服务定义是一个重大挫折。我们在RESTful服务中拥有的大多数现有服务定义技术，如OpenAPI/Swagger，都是事后想法，与底层架构风格或消息协议的紧密集成不强。
- en: This leads to many incompatibilities, runtime errors, and interoperability issues
    in building such decentralized applications. For instance, when you develop RESTful
    services, it is not required to have a service definition and type definition
    of the information that is shared between the applications. Rather, you develop
    your RESTful applications either looking at the textual format on the wire or
    third-party API definition technologies such as OpenAPI. Therefore, having a modern
    strongly typed service definition technology and a framework that generates the
    core of the server- and client-side code for polyglot technologies is a key necessity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致在构建这种分散式应用程序时出现许多不兼容性、运行时错误和互操作性问题。例如，当您开发RESTful服务时，无需拥有服务定义和信息类型定义，这些信息在应用程序之间共享。相反，您可以根据线上的文本格式或第三方API定义技术（如OpenAPI）开发您的RESTful应用程序。因此，拥有现代强类型服务定义技术以及为多语言技术生成服务器和客户端核心代码的框架是至关重要的。
- en: REST architectural style is hard to enforce
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST 架构风格难以强制执行
- en: As an architectural style, REST has a lot of “good practices” that you need
    to follow to make a real RESTful service. But they are not enforced as part of
    the implementation protocols (such as HTTP), which makes it hard to enforce them
    at the implementation phase. Therefore, in practice, most of the services that
    claim to be RESTful are not properly following the foundations of the REST style.
    So, most of the so-called RESTful services are merely HTTP services exposed over
    the network. Therefore, development teams have to spend a lot of time maintaining
    the consistency and purity of a RESTful service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种架构风格，REST有许多“良好实践”需要遵循才能创建真正的RESTful服务。但是，它们并不作为实现协议（如HTTP）的一部分强制执行，这使得在实施阶段强制执行它们变得困难。因此，在实践中，大多数声称为RESTful的服务并未正确遵循REST风格的基础。因此，大多数所谓的RESTful服务只是通过网络公开的HTTP服务。因此，开发团队必须花费大量时间维护RESTful服务的一致性和纯度。
- en: With all these limitations of inter-process communication techniques in building
    modern cloud native applications, the quest for inventing a better message protocol
    began.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代云原生应用程序构建中进程间通信技术的所有这些限制，追求发明一种更好的消息协议的旅程开始了。
- en: Inception of gRPC
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 的创世
- en: Google had been using a general-purpose RPC framework called [*Stubby*](https://oreil.ly/vat5r)
    to connect thousands of microservices that are running across multiple data centers
    and built with disparate technologies. Its core RPC layer was designed to handle
    an internet scale of tens of billions of requests per second. Stubby has many
    great features, but it is not standardized to be used as a generic framework as
    it is too tightly coupled to Google’s internal infrastructure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Google 一直在使用名为 [*Stubby*](https://oreil.ly/vat5r) 的通用 RPC 框架来连接跨多个数据中心运行的数千个微服务，并构建具有不同技术的微服务。其核心
    RPC 层设计用于处理每秒数十亿次请求的互联网规模。Stubby 具有许多出色的特性，但由于过于紧密耦合到 Google 的内部基础设施，因此不能标准化用作通用框架。
- en: In 2015, Google [released](https://oreil.ly/cUZSG) gRPC as an open source RPC
    framework; it is a standardized, general-purpose, and cross-platform RPC infrastructure.
    gRPC was intended to provide the same scalability, performance, and functionality
    that Stubby offered, but to the community at large.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，Google [发布了](https://oreil.ly/cUZSG) gRPC 作为开源的 RPC 框架；它是一个标准化的、通用的、跨平台的
    RPC 基础设施。gRPC 旨在为社区提供与 Stubby 提供的相同的可扩展性、性能和功能。
- en: Since then, the popularity of gRPC has grown dramatically over the past few
    years with large-scale adoption from major companies such as Netflix, Square,
    Lyft, Docker, Cisco, and CoreOS. Later, gRPC [joined](https://oreil.ly/GFffo)
    the Cloud Native Computing Foundation (CNCF), one of the most popular open source
    software foundations dedicated to making cloud native computing universal and
    sustainable; gRPC gained a lot of traction from CNCF ecosystem projects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，gRPC 在过去几年中以及来自Netflix、Square、Lyft、Docker、Cisco 和 CoreOS 等主要公司的大规模采用下急剧增长。后来，gRPC
    [加入了](https://oreil.ly/GFffo) 云原生计算基金会（CNCF），这是致力于使云原生计算普遍和可持续的最流行的开源软件基金会之一；gRPC
    从 CNCF 生态系统项目中获得了很多推动力。
- en: Now let’s look at some of the key reasons for using gRPC over the conventional
    inter-process communication protocols.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用 gRPC 而不是传统进程间通信协议的一些关键原因。
- en: Why gRPC?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 gRPC？
- en: gRPC is designed to be an internet-scale, inter-process communication technology
    that can overcome most of the shortcomings of conventional inter-process communication
    technologies. Owing to the benefits of gRPC, most modern applications and servers
    are increasingly converting their inter-process communication protocol to gRPC.
    So, why would somebody select gRPC as a communication protocol when there are
    so many other options available? Let’s look more closely at some of the key advantages
    that gRPC brings to the table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 设计为一种可以克服传统进程间通信技术大部分缺点的互联网规模的技术。由于 gRPC 的优势，大多数现代应用程序和服务器正越来越将其进程间通信协议转换为
    gRPC。那么，在有这么多其他选择可用时，为什么会有人选择 gRPC 作为通信协议呢？让我们更仔细地看看 gRPC 带来的一些关键优势。
- en: Advantages of gRPC
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC 的优势
- en: 'The advantages that gRPC brings are key to the increasing adoption of gRPC.
    These advantages include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 带来的优势是 gRPC 日益增长的原因。这些优势包括以下内容：
- en: It’s efficient for inter-process communication
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它对进程间通信非常高效。
- en: Rather than using a textual format such as JSON or XML, gRPC uses a protocol
    buffer–based binary protocol to communicate with gRPC services and clients. Also,
    gRPC implements protocol buffers on top of HTTP/2, which makes it even faster
    for inter-process communication. This makes gRPC one of the most efficient inter-process
    communication technologies out there.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 不像使用 JSON 或 XML 等文本格式，而是使用基于协议缓冲区的二进制协议与 gRPC 服务和客户端通信。此外，gRPC 在 HTTP/2
    之上实现了协议缓冲区，使其成为更快的进程间通信技术。这使得 gRPC 成为最高效的进程间通信技术之一。
- en: It has simple, well-defined service interfaces and schema
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有简单明确的服务接口和模式。
- en: gRPC fosters a contract-first approach for developing applications. You first
    define the service interfaces and then work on the implementation details afterward.
    So, unlike OpenAPI/Swagger for RESTful service definition and WSDL for SOAP web
    services, gRPC offers a simple but consistent, reliable, and scalable application
    development experience.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 促进了一种基于契约的应用程序开发方法。您首先定义服务接口，然后再处理实现细节。因此，与 RESTful 服务定义的 OpenAPI/Swagger
    和 SOAP web 服务的 WSDL 不同，gRPC 提供了一种简单而一致、可靠和可扩展的应用程序开发体验。
- en: It’s strongly typed
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它是强类型的。
- en: Since we use protocol buffers to define gRPC services, gRPC service contracts
    clearly define the types that you will be using for communication between the
    applications. This makes distributed application development much more stable,
    as static typing helps to overcome most of the runtime and interoperability errors
    that you would encounter when you build cloud native applications that span across
    multiple teams and technologies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用协议缓冲区来定义 gRPC 服务，因此 gRPC 服务契约清晰地定义了在应用程序之间进行通信时将使用的类型。这使得分布式应用程序开发更加稳定，因为静态类型有助于克服在构建跨多个团队和技术的云原生应用程序时可能遇到的大多数运行时和互操作性错误。
- en: It’s polyglot
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它是多语言的。
- en: gRPC is designed to work with multiple programming languages. A gRPC service
    definition with protocol buffers is language-agnostic. Hence, you can pick the
    language of your choice but can interoperate with any existing gRPC service or
    client.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 设计用于与多种编程语言一起工作。使用协议缓冲区定义的 gRPC 服务是与语言无关的。因此，您可以选择您喜欢的语言，但可以与任何现有的 gRPC
    服务或客户端进行互操作。
- en: It has duplex streaming
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有双工流功能。
- en: gRPC has native support for client- or server-side streaming, which is baked
    into the service definition itself. This makes it much easier to develop streaming
    services or streaming clients. And the ability to build conventional request–response
    style messaging and client- and server-side streaming is a key advantage over
    the conventional RESTful messaging style.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 原生支持客户端或服务器端流，这一特性已经融入到服务定义中。这使得开发流式服务或流式客户端变得更加容易。而且，能够构建传统的请求-响应式消息传递以及客户端和服务器端流式传输是传统
    RESTful 消息传递风格的重要优势之一。
- en: It has built-in commodity features
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有内建的通用功能。
- en: gRPC offers built-in support for commodity features such as authentication,
    encryption, resiliency (deadlines and timeouts), metadata exchange, compression,
    load balancing, service discovery, and so on (we’ll explore these in [Chapter 5](ch05.html#ch_05)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 提供了内建的支持，如身份验证、加密、弹性（截止日期和超时）、元数据交换、压缩、负载平衡、服务发现等功能（我们将在 [第五章](ch05.html#ch_05)
    中探讨这些功能）。
- en: It’s integrated with cloud native ecosystems
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它与云原生生态系统集成。
- en: gRPC is part of the CNCF and most of the modern frameworks and technologies
    offer native support for gRPC out of the box. For instance, many projects under
    CNCF such as [Envoy](https://oreil.ly/vGQsj) support gRPC as a communication protocol;
    for cross-cutting features such as metrics and monitoring, gRPC is supported by
    most such tools (e.g., using [Prometheus](https://oreil.ly/AU3-7) to monitor gRPC
    applications).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是 CNCF 的一部分，大多数现代框架和技术都原生支持 gRPC。例如，CNCF 下的许多项目，如 [Envoy](https://oreil.ly/vGQsj)，支持
    gRPC 作为通信协议；对于跨切面功能，如度量和监视，大多数这类工具（例如使用 [Prometheus](https://oreil.ly/AU3-7) 监视
    gRPC 应用程序）都支持 gRPC。
- en: It’s mature and has been widely adopted
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它是成熟的，并且已被广泛采用。
- en: gRPC has been matured by its heavy battle-testing at Google, and many other
    major tech companies such as Square, Lyft, Netflix, Docker, Cisco, and CoreOS
    have adopted it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 经过 Google 等公司的大量战斗测试，已经成熟，许多其他主要技术公司如 Square、Lyft、Netflix、Docker、Cisco
    和 CoreOS 也采用了它。
- en: As with any technology, gRPC comes with a certain set of drawbacks as well.
    Knowing those drawbacks during application development is quite useful. So, let’s
    take a look at some of the limitations of gRPC.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何技术一样，gRPC 也有一定的缺点。在应用程序开发过程中了解这些缺点非常有用。因此，让我们来看看 gRPC 的一些局限性。
- en: Disadvantages of gRPC
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gRPC 的缺点
- en: 'Here are some of the disadvantages of gRPC that you need to be mindful of when
    you select it for building applications. These include the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 gRPC 构建应用程序时，需要注意一些缺点。这些包括以下内容：
- en: It may not be suitable for external-facing services
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能不适用于面向外部服务。
- en: When you want to expose the application or services to an external client over
    the internet, gRPC may not be the most suitable protocol as most of the external
    consumers are quite newly about gRPC and REST/HTTP. The contract-driven, strongly
    typed nature of gRPC services may hinder the flexibility of the services that
    you expose to the external parties, and consumers get far less control (unlike
    protocols such as GraphQL, which is explained in the next section). The gRPC gateway
    is designed as a workaround to overcome this issue. We’ll discuss it in detail
    in [Chapter 8](ch08.html#ch_08).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望通过互联网向外部客户公开应用程序或服务时，gRPC 可能不是最合适的协议，因为大多数外部消费者对 gRPC 和 REST/HTTP 都比较陌生。gRPC
    服务的合同驱动、强类型的特性可能会限制您向外部方公开服务的灵活性，并且消费者会获得较少的控制权（不像 GraphQL 等协议那样）。gRPC 网关被设计为解决这个问题的一种方法。我们将在[第8章](ch08.html#ch_08)中详细讨论。
- en: Drastic service definition changes are a complicated development process
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重大服务定义变更是一个复杂的开发过程。
- en: Schema modifications are quite common in modern inter-service communication
    use cases. When there are drastic gRPC service definition changes, usually we
    need to regenerate code for both client and server. This needs to be incorporated
    into the existing continuous integration process and may complicate the overall
    development life cycle. However, most gRPC service definition changes can be accommodated
    without breaking the service contract, and gRPC will happily interoperate with
    clients and servers using different versions of a proto, as long as no breaking
    changes are introduced. So code regeneration is not required in most cases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现代服务间通信中，模式修改非常普遍。当 gRPC 服务定义发生重大变化时，通常需要重新生成客户端和服务器端的代码。这需要融入现有的持续集成流程中，并可能使整体开发生命周期变得复杂。然而，大多数
    gRPC 服务定义的变更可以在不破坏服务合同的情况下进行，只要没有引入破坏性变更，gRPC 就能与使用不同版本 proto 的客户端和服务器愉快地互操作。因此，在大多数情况下并不需要重新生成代码。
- en: The ecosystem is relatively small
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 生态系统相对较小。
- en: The gRPC ecosystem is still relatively small compared to the conventional REST/HTTP
    protocol. The support for gRPC in browser and mobile applications is still in
    the primitive stages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 REST/HTTP 协议相比，gRPC 生态系统仍然相对较小。在浏览器和移动应用程序中支持 gRPC 的情况仍处于初级阶段。
- en: You must be mindful about these limitations when it comes to the development
    of applications. So, obviously, gRPC is not a technique that you should use for
    all your inter-process communication requirements. Rather, you need to evaluate
    the business use case and requirements and pick the appropriate messaging protocol.
    We’ll explore some of these guidelines in [Chapter 8](ch08.html#ch_08).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，你必须注意这些限制。显然，gRPC 并不是你应该用于所有进程间通信需求的技术。相反，你需要评估业务用例和需求，并选择适合的消息传递协议。我们将在[第8章](ch08.html#ch_08)中探讨一些指南。
- en: As we discussed in previous sections, there are many existing and emerging inter-process
    communication techniques out there. It’s important to have a good understanding
    of how we can compare gRPC with other similar technologies that have gained popularity
    in the modern application development landscape, as this will help you in finding
    the most appropriate protocol for your services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中讨论的那样，市场上存在许多现有和新兴的进程间通信技术。了解我们如何比较 gRPC 与其他类似的技术，这将帮助您找到最适合您服务的协议，这一点非常重要。
- en: 'gRPC Versus Other Protocols: GraphQL and Thrift'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 与其他协议的比较：GraphQL 和 Thrift
- en: We have discussed in detail some of the key limitations of REST, which laid
    the foundation to the inception of gRPC. Similarly, there are quite a few inter-process
    communication technologies emerging to fulfill the same needs. So, let’s look
    at some of the popular technologies and compare them with gRPC.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了 REST 的一些关键限制，这为 gRPC 的诞生奠定了基础。同样，有许多正在出现的进程间通信技术来满足相同的需求。因此，让我们看看一些流行的技术，并将它们与
    gRPC 进行比较。
- en: Apache Thrift
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Apache Thrift
- en: '[Apache Thrift](https://thrift.apache.org) is an RPC framework (initially developed
    at Facebook and later donated to Apache) similar to gRPC. It uses its own interface
    definition language and offers support for a wide range of programming languages.
    Thrift allows you to define data types and service interfaces in a definition
    file. By taking the service definition as the input, the Thrift compiler generates
    code for the client and server sides. The Thrift transport layer provides abstractions
    for network I/O and decouples Thrift from the rest of the system, which means
    it can run on any transport implementation such as TCP, HTTP, and so on.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[Apache Thrift](https://thrift.apache.org)是一个RPC框架（最初在Facebook开发，后来捐赠给Apache），类似于gRPC。它使用自己的接口定义语言，并支持广泛的编程语言。Thrift允许您在定义文件中定义数据类型和服务接口。通过将服务定义作为输入，Thrift编译器生成客户端和服务器端的代码。Thrift传输层提供了网络I/O的抽象，并将Thrift与系统的其余部分解耦，这意味着它可以在任何传输实现（如TCP、HTTP等）上运行。'
- en: 'If you compare Thrift with gRPC, you will find both pretty much follow the
    same design and usage goals. However, there are several important differentiators
    between the two:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Thrift与gRPC进行比较，你会发现它们基本上遵循相同的设计和使用目标。然而，两者之间有几个重要的区别：
- en: Transport
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Transport
- en: gRPC is more opinionated than Thrift and offers first-class support for HTTP/2\.
    Its implementations on HTTP/2 leverage the protocol’s capabilities to achieve
    efficiency and support for messaging patterns such as streaming.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC比Thrift更具有见解，并为HTTP/2提供了一流的支持。它在HTTP/2上的实现利用协议的能力实现效率，并支持诸如流式传输等消息模式。
- en: Streaming
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Streaming
- en: gRPC service definitions natively support bidirectional streaming (client and
    server) as part of the service definition itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC服务定义本身原生支持双向流式传输（客户端和服务器）作为服务定义的一部分。
- en: Adoption and community
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 采纳和社区
- en: When it comes to adoption gRPC seems to have a pretty good momentum and has
    managed to build a good ecosystem around CNCF projects. Also, community resources
    such as good documentation, external presentations, and sample use cases are quite
    common for gRPC, which makes the adoption process smooth compared to Thrift.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到采纳时，gRPC似乎具有相当好的动力，并成功地在CNCF项目周围建立了一个良好的生态系统。此外，诸如良好的文档、外部演示和示例用例等社区资源在gRPC中非常普遍，这使得采纳过程与Thrift相比更加顺畅。
- en: Performance
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Performance
- en: While there are no official results comparing gRPC versus Thrift, there are
    a few online resources with performance comparisons between the two that show
    better numbers for Thrift. However, gRPC is also being heavily benchmarked for
    performance in almost all [releases](https://oreil.ly/Hy3mJ). So performance is
    unlikely to be a deciding factor when it comes to selecting Thrift over gRPC.
    Also, there are other RPC frameworks that offer similar capabilities but gRPC
    is currently leading the way as the most standardized, interoperable, and widely
    adopted RPC technology.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有官方结果比较gRPC与Thrift，但有一些在线资源进行了性能比较，显示Thrift的数据更好。然而，几乎每个发布版本都对gRPC进行了大量性能基准测试。因此，在选择Thrift或gRPC时，性能不太可能成为决定性因素。此外，还有其他RPC框架提供类似的功能，但gRPC目前作为最标准化、可互操作性和广泛采用的RPC技术领先一步。
- en: GraphQL
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL
- en: '[GraphQL](https://graphql.org) is another technology (invented by Facebook
    and standardized as an open technology) that is becoming quite popular for building
    inter-process communication. It is a query language for APIs and a runtime for
    fulfilling those queries with your existing data. GraphQL offers a fundamentally
    different approach for conventional client–server communication by allowing clients
    to determine what data they want, how they want it, and in what format they want
    it. gRPC, on the other hand, has a fixed contract for the remote methods that
    enable communication between the client and the server.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[GraphQL](https://graphql.org)是另一种技术（由Facebook发明并作为开放技术标准化），用于构建进程间通信，正在变得越来越流行。它是一个API的查询语言，以及用现有数据满足这些查询的运行时。GraphQL通过允许客户端确定他们想要什么数据、以什么方式和以什么格式来提供对传统客户端-服务器通信的基本不同方法。另一方面，gRPC通过具有固定契约的远程方法来使客户端和服务器之间的通信成为可能。'
- en: GraphQL is more suitable for external-facing services or APIs that are exposed
    to consumers directly where the clients need more control over the data that consume
    from the server. For example, in our online retail application scenario, suppose
    that the consumers of the `ProductInfo` service need only specific information
    about the products but not the entire set of attributes of a product, and the
    consumers also need a way to specify the information they want. With GraphQL you
    can model a service so that it allows consumers to query the service using the
    GraphQL query language and obtain the required information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 更适合于面向直接暴露给消费者的外部服务或 API，在这些服务中，客户端需要更多控制所消费的数据。例如，在我们的在线零售应用场景中，假设“ProductInfo”服务的消费者仅需要产品的特定信息，而不需要产品的所有属性集，并且消费者还需要一种指定所需信息的方法。使用
    GraphQL，您可以建模一个服务，使消费者能够使用 GraphQL 查询语言查询服务并获取所需的信息。
- en: In most of the pragmatic use cases of GraphQL and gRPC, GraphQL is being used
    for external-facing services/APIs while internal services that are backing the
    APIs are implemented using gRPC.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际的 GraphQL 和 gRPC 用例中，GraphQL 用于面向外部的服务/API，而支持 API 的内部服务则使用 gRPC 实现。
- en: Now let’s have a look at some of the real-world adopters of gRPC and their use
    cases.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些实际采用 gRPC 的公司及其使用案例。
- en: gRPC in the Real World
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 在现实世界中的应用
- en: The success of any inter-process communication protocol is largely dependent
    on industry-wide adoption and the user and developer community behind that project.
    gRPC has been widely adopted for building microservices and cloud native applications.
    Let’s look at some of the key success stories of gRPC.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程间通信协议的成功在很大程度上取决于行业广泛的采纳以及该项目背后的用户和开发者社区。gRPC 已被广泛采用于构建微服务和云原生应用程序。让我们看看
    gRPC 的一些关键成功案例。
- en: Netflix
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Netflix
- en: '[Netflix](https://oreil.ly/xK3Ds), a subscription-based video streaming company,
    is one of the pioneers in practicing microservices architecture at scale. All
    of its video streaming capabilities are offered to consumers through an external-facing
    managed service (or APIs) and there are hundreds of backend services that are
    backing its APIs. Therefore, inter-process (or inter-service) communication is
    one of the most important aspects of its use case. During the initial stage of
    microservices implementation, Netflix developed its own technology stack for inter-service
    communication using RESTful services on HTTP/1.1, which backs almost 98% of the
    business use cases of the Netflix product.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Netflix](https://oreil.ly/xK3Ds)，一个基于订阅的视频流媒体公司，是在大规模实践微服务架构中的先驱之一。它的所有视频流媒体能力都通过面向外部的托管服务（或
    API）提供给消费者，并且有数百个后端服务支持其 API。因此，进程间（或服务间）通信是其用例的最重要方面之一。在微服务实施的初始阶段，Netflix 开发了自己的技术堆栈，使用基于
    HTTP/1.1 的 RESTful 服务进行服务间通信，这支持了 Netflix 产品几乎 98% 的业务用例。'
- en: However, Netflix has observed several limitations of the RESTful services–based
    approach when they operate at internet scale. The consumers of RESTful microservices
    were often written from scratch by inspecting the resources and required message
    formats of the RESTful services. This was very time-consuming, hindered developer
    productivity, and also increased the risk for more error-prone code. Service implementation
    and consumption was also challenging because of the lack of technologies for a
    comprehensive definition of a service interface. So, it initially tried to overcome
    most of these limitations by building an internal RPC framework, but after evaluating
    available technology stacks, it chose gRPC as its inter-service communication
    technology. During its evaluation, Netflix found that gRPC was comfortably at
    the top in terms of encapsulating all the required responsibilities together in
    one easy-to-consume package.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Netflix 在运营互联网规模时观察到 RESTful 服务方法的几个限制。RESTful 微服务的消费者经常通过检查资源和所需消息格式来自行编写，这非常耗时，阻碍了开发者的生产力，并增加了编码出错的风险。由于缺乏全面定义服务接口的技术，服务的实施和消费也变得具有挑战性。因此，Netflix
    最初尝试通过构建内部 RPC 框架来克服大部分这些限制，但在评估了可用的技术堆栈后，选择了 gRPC 作为其服务间通信技术。在评估过程中，Netflix 发现
    gRPC 在封装所有必需的责任方面表现出色，并提供了一个易于消费的整体解决方案。
- en: With the adoption of gRPC, Netflix has seen a massive boost in developer productivity.
    For example, for each client, hundreds of lines of custom code are replaced by
    just two to three lines of configuration in the proto. Creating a client, which
    could take up to two to three weeks, takes a matter of minutes with gRPC. The
    overall stability of the platform has also improved a lot because handwritten
    code for most of the commodity features is no longer needed and there is a comprehensive
    and safe way of defining service interfaces. Owing to the performance boost that
    gRPC provides, the overall latency of Netflix’s entire platform has reduced. Since
    it has adopted gRPC for most of its inter-process communication use cases, it
    seems that Netflix has put some of its homegrown projects (for example, [Ribbon](https://oreil.ly/qKgv4))
    that are built for inter-process communication using REST and HTTP protocols into
    maintenance mode (not in active development) and are using gRPC instead.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 gRPC 后，Netflix 的开发人员生产力大幅提升。例如，对于每个客户端，数百行自定义代码被 proto 中的两到三行配置所替代。使用 gRPC
    可以在几分钟内创建客户端，而这可能需要两到三周的时间。平台的整体稳定性也有了显著改善，因为不再需要大多数常见功能的手写代码，并且有了一种全面且安全的定义服务接口的方式。由于
    gRPC 提供的性能提升，Netflix 整个平台的总体延迟也减少了。由于其已经在大多数进程间通信用例中采用了 gRPC，因此 Netflix 似乎已经将一些使用
    REST 和 HTTP 协议进行进程间通信的自制项目（例如 [Ribbon](https://oreil.ly/qKgv4)）置于维护模式（不再积极开发），并改用了
    gRPC。
- en: etcd
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[etcd](https://oreil.ly/wo4gM) 是一个分布式可靠的键值存储，用于分布式系统的最关键数据。它是 CNCF 中最受欢迎的开源项目之一，并且被许多其他开源项目（如
    Kubernetes）广泛采用。'
- en: '[etcd](https://oreil.ly/wo4gM) is a distributed reliable key-value store for
    the most critical data of a distributed system. It’s one of the most popular open
    source projects in CNCF and heavily adopted by many other open source projects
    such as Kubernetes. One key factor in gRPC’s success is that it has a simple,
    well-defined, easy-to-consume, user-facing API. etcd uses a gRPC [user-facing
    API](https://oreil.ly/v-H-K) to leverage the full power of gRPC.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[etcd](https://oreil.ly/wo4gM) 使用 gRPC [用户面向 API](https://oreil.ly/v-H-K) 来充分利用
    gRPC 的全部功能。'
- en: Dropbox
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dropbox
- en: Dropbox is a file-hosting service that offers cloud storage, file synchronization,
    personal cloud, and client software. Dropbox runs hundreds of polyglot microservices,
    which exchange millions of requests per second. It was using multiple RPC frameworks
    initially, including a homegrown RPC framework with a custom protocol for manual
    serialization and deserialization, Apache Thrift, and a legacy RPC framework that
    was an HTTP/1.1-based protocol with protobuf-encoded messages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox 是一个文件托管服务，提供云存储、文件同步、个人云和客户端软件。Dropbox 运行数百个多语言微服务，每秒交换数百万个请求。最初它使用了多个
    RPC 框架，包括一个使用自定义协议进行手动序列化和反序列化的自制 RPC 框架，Apache Thrift，以及一个基于 HTTP/1.1 的传统 RPC
    框架，使用 protobuf 编码的消息。
- en: Rather than using any of those, Dropbox has switched to gRPC (which also allows
    it to reuse some of the existing protocol buffer definitions of its message formats).
    It has created [Courier](https://oreil.ly/msjcZ), a gRPC-based RPC framework.
    Courier is not a new RPC protocol but a project that integrates gRPC with Dropbox’s
    existing infrastructure. Dropbox has augmented gRPC to cater to its specific requirements
    related to authentication, authorization, service discovery, service statistics,
    event logging, and tracing tools.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Dropbox 不再使用上述任何框架，而是转向了 gRPC（这也允许其重用一些现有的协议缓冲区定义其消息格式）。它创建了 [Courier](https://oreil.ly/msjcZ)，一个基于
    gRPC 的 RPC 框架。Courier 不是一个新的 RPC 协议，而是一个将 gRPC 与 Dropbox 现有基础设施集成的项目。Dropbox 已经扩展了
    gRPC，以满足其与认证、授权、服务发现、服务统计、事件日志记录和跟踪工具相关的特定要求。
- en: These success stories of gRPC tell us that it’s an inter-process messaging protocol
    that is simple, boosts productivity and reliability, and scales and operates at
    the internet scale. These are some of the well-known early adopters of gRPC, but
    the use cases and adoption of gRPC are increasingly growing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 的成功案例告诉我们，它是一个简单、提高生产力和可靠性的进程间通信协议，并且在互联网规模上进行扩展和操作。这些都是 gRPC 的早期知名早期采用者，但
    gRPC 的用例和采用情况正在日益增长。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Modern software applications or services rarely live in isolation and the inter-process
    communication techniques that connect them are one of the most important aspects
    of modern distributed software applications. gRPC is a scalable, loosely coupled,
    and type-safe solution that allows for more efficient inter-process communication
    than conventional REST/HTTP-based communication. It allows you to connect, invoke,
    operate, and debug distributed heterogeneous applications as easy as making a
    local method call via network transport protocols such as HTTP/2.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件应用或服务很少独立存在，连接它们的进程间通信技术是现代分布式软件应用中最重要的方面之一。gRPC 是一种可扩展、松耦合和类型安全的解决方案，比传统的
    REST/HTTP 基础通信更高效。它使您能够像调用本地方法一样简单地连接、调用、操作和调试分布式异构应用，使用的网络传输协议如 HTTP/2。
- en: gRPC can also be considered as an evolution of conventional RPCs and has managed
    to overcome their limitations. gRPC is being widely adopted by various internet-scale
    companies for their inter-process communication requirements and is most commonly
    used for building internal service-to-service communications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 也可以被视为传统 RPC 的进化，并成功地克服了它们的局限性。gRPC 正被各种互联网规模的公司广泛采用，用于它们的进程间通信需求，并且最常用于构建内部服务到服务的通信。
- en: The knowledge you gain from this chapter will be a good entry point for the
    rest of the chapters, where you will dive deep into different aspects of gRPC
    communication. This knowledge will be put into practice in the next chapter where
    we build a real-world gRPC application from the ground up.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章节获得的知识将是后续章节的良好入门点，您将深入研究 gRPC 通信的不同方面。这些知识将在下一章中得以实践，我们将从零开始构建一个真实的 gRPC
    应用程序。
- en: ^([1](ch01.html#idm46536655629784-marker)) K. Indrasiri and P. Siriwardena,
    *Microservices for the Enterprise* (Apress, 2018).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm46536655629784-marker)) K. Indrasiri 和 P. Siriwardena，《企业微服务》（Apress，2018）。
