<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Go Language Foundations"><div class="chapter" id="chapter_3">&#13;
<h1><span class="label">Chapter 3. </span>Go Language Foundations</h1>&#13;
&#13;
<blockquote>&#13;
<p>A language that doesn’t affect the way you think about programming is not worth knowing.<sup><a data-type="noteref" id="idm45983647379672-marker" href="ch03.xhtml#idm45983647379672">1</a></sup></p>&#13;
<p data-type="attribution">Alan Perlis, <cite>ACM SIGPLAN Notices (September 1982)</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>No programming book would be complete without at least a brief refresher of its language of choice, so here we are!</p>&#13;
&#13;
<p>This chapter will differ slightly from the ones in more introductory level books, however, in that we’re assuming that you’re at least familiar with common coding paradigms but may or may not be a little rusty with the finer points of Go syntax. As such, this chapter will focus as much on Go’s nuances and subtleties as its fundamentals. For a deeper dive into the latter, I recommend either <a href="https://oreil.ly/9Ht4R" class="orm:hideurl"><em>Introducing Go</em></a> by Caleb Doxsey (O’Reilly) or <em>The Go Programming Language</em> by Alan A. A. Donovan and Brian W. Kernighan (Addison-Wesley Professional)</p>&#13;
&#13;
<p>If you’re relatively new to the language, you’ll definitely want to read on. Even if you’re somewhat comfortable with Go, you might want to skim this chapter: there will be a gem or two in here for you. If you’re a seasoned veteran of the language, you can go ahead and move on to the next chapter (or read it ironically and judge me).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Basic Data Types"><div class="sect1" id="idm45983647340504">&#13;
<h1>Basic Data Types</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" id="ch03_term1"/>Go’s basic data types, the fundamental building blocks from which more complex types are constructed, can be divided into three subcategories:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Booleans that contain only one bit of information—<code>true</code> or <code>false</code>—representing some logical conclusion or state.<a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="Booleans" id="idm45983647335400"/><a data-type="indexterm" data-primary="types" data-secondary="Booleans" id="idm45983647334152"/><a data-type="indexterm" data-primary="Booleans" id="idm45983647333208"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Numeric types that represent simple—variously sized floating point and signed and unsigned integers—or complex numbers.<a data-type="indexterm" data-primary="numeric types" data-seealso="complex numbers, simple numbers" id="idm45983647331560"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Strings that represent an immutable sequence of Unicode code points.<a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="strings" id="idm45983647329784"/><a data-type="indexterm" data-primary="types" data-secondary="strings" id="idm45983647328536"/><a data-type="indexterm" data-primary="strings" id="idm45983647327592"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Booleans"><div class="sect2" id="idm45983647326536">&#13;
<h2>Booleans</h2>&#13;
&#13;
<p>The Boolean data type, representing the two logical truth values, exists in some form<sup><a data-type="noteref" id="idm45983647325000-marker" href="ch03.xhtml#idm45983647325000">2</a></sup> in every programming language ever devised. It’s represented by the <code>bool</code> type, a &#13;
<span class="keep-together">special</span> 1-bit integer type that has two possible values:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>true</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>false</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Go supports all of the typical logical operations:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">and</code> <code class="o">:=</code> <code class="kc">true</code> <code class="o">&amp;&amp;</code> <code class="kc">false</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">and</code><code class="p">)</code>        <code class="c1">// "false"</code>&#13;
&#13;
<code class="nx">or</code> <code class="o">:=</code> <code class="kc">true</code> <code class="o">||</code> <code class="kc">false</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">or</code><code class="p">)</code>         <code class="c1">// "true"</code>&#13;
&#13;
<code class="nx">not</code> <code class="o">:=</code> <code class="p">!</code><code class="kc">true</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">not</code><code class="p">)</code>        <code class="c1">// "false"</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Curiously, Go doesn’t include a logical XOR operator. There <em>is</em> a <code>^</code> operator, but it’s reserved for bitwise XOR operations.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Simple Numbers"><div class="sect2" id="idm45983647283944">&#13;
<h2>Simple Numbers</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="simple numbers" id="idm45983647282264"/><a data-type="indexterm" data-primary="simple numbers" id="idm45983647281016"/>Go has a small menagerie of systematically named, floating point, and signed and unsigned integer numbers:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="signed integer" id="idm45983647279288"/><a data-type="indexterm" data-primary="signed integer" id="idm45983647278312"/>Signed integer</dt>&#13;
<dd>&#13;
<p><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code></p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="unsigned integer" id="idm45983647274856"/><a data-type="indexterm" data-primary="unsigned integer" id="idm45983647273880"/>Unsigned integer</dt>&#13;
<dd>&#13;
<p><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="floating point" id="idm45983647270424"/><a data-type="indexterm" data-primary="floating point" id="idm45983647269448"/>Floating point</dt>&#13;
<dd>&#13;
<p><code>float32</code>, <code>float64</code></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Systematic naming is nice, but code is written by humans with squishy human brains, so the Go designers provided two lovely conveniences.</p>&#13;
&#13;
<p>First, there are two “machine dependent” types, simply called <code>int</code> and <code>uint</code>, whose size is determined based on available hardware. These are convenient if the specific size of your numbers isn’t critical. Sadly, there’s no machine-dependent floating-point number type.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="byte" id="idm45983647264824"/><a data-type="indexterm" data-primary="byte" id="idm45983647263624"/><a data-type="indexterm" data-primary="types" data-secondary="rune" id="idm45983647262952"/><a data-type="indexterm" data-primary="rune" id="idm45983647262008"/><a data-type="indexterm" data-primary="integer types" id="idm45983647261336"/>Second, two integer types have mnemonic aliases: <code>byte</code>, which is an alias for <code>uint8</code>; and <code>rune</code>, which is an alias for <code>uint32</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For most uses, it generally makes sense to just use <code>int</code> and <code>float64</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Complex Numbers"><div class="sect2" id="idm45983647256840">&#13;
<h2>Complex Numbers</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="complex numbers" id="idm45983647255608"/><a data-type="indexterm" data-primary="complex numbers" id="idm45983647254136"/><a data-type="indexterm" data-primary="imaginary literal" id="idm45983647253464"/>Go offers two sizes of <em>complex numbers</em>, if you’re feeling a little imaginative:<sup><a data-type="noteref" id="idm45983647252184-marker" href="ch03.xhtml#idm45983647252184">3</a></sup> &#13;
<span class="keep-together"><code>complex64</code></span> and <code>complex128</code>. These can be expressed as an <em>imaginary literal</em> by a floating point immediately followed by an <code>i</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">x</code> <code class="kt">complex64</code> <code class="p">=</code> <code class="m">3.1415i</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>                  <code class="c1">// "(0+3.1415i)"</code></pre>&#13;
&#13;
<p>Complex numbers are very neat but don’t come into play all that often, so I won’t drill down into them here. If you’re as fascinated by them as I hope you are, <em>The Go Programming Language</em> by Donovan and Kernighan gives them the full treatment they deserve.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Strings"><div class="sect2" id="idm45983647208472">&#13;
<h2>Strings</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="strings" id="idm45983647207192"/><a data-type="indexterm" data-primary="types" data-secondary="strings" id="idm45983647205944"/><a data-type="indexterm" data-primary="strings" id="idm45983647200280"/>A <em>string</em> represents a sequence of Unicode code points. Strings in Go are immutable: once created, it’s not possible to change a string’s contents.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="string literals" data-seealso="double-quote style string literals, interpreted string literals" id="idm45983647198616"/><a data-type="indexterm" data-primary="double-quote style string literals" id="idm45983647197672"/><a data-type="indexterm" data-primary="interpreted string literals" id="idm45983647197032"/>Go supports two styles of string literals, the double-quote style (or interpreted literals) and the back-quote style (or raw string literals). For example, the following two string literals are equivalent:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// The interpreted form</code>&#13;
<code class="s">"Hello\nworld!\n"</code>&#13;
&#13;
<code class="c1">// The raw form</code>&#13;
<code class="s">`Hello</code>&#13;
<code class="s">world!`</code></pre>&#13;
&#13;
<p>In this interpreted string literal, each <code>\n</code> character pair will be escaped as one newline character, and each <code>\"</code> character pair will be escaped as one double-quote character.</p>&#13;
&#13;
<p>Behind the scenes, a string is actually just a wrapper around a slice of UTF-8 encoded <code>byte</code> values, so any operation that can be applied to slices and arrays can also be applied to strings. If you aren’t clear on slices yet, you can take this moment to read ahead to <a data-type="xref" href="#section_ch03_slices">“Slices”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Variables"><div class="sect1" id="idm45983647189720">&#13;
<h1>Variables</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="variables" id="idm45983647188120"/><a data-type="indexterm" data-primary="variables" id="idm45983647186872"/>Variables can be declared by using the <code>var</code> keyword to pair an identifier with some typed value, and may be updated at any time, with the general form:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">name</code> <code class="kd">type</code> <code class="p">=</code> <code class="nx">expression</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="variable declaration" id="ch03_term23"/>However, there is considerable flexibility in variable declaration:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>With initialization: <code>var foo int = 42</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Of multiple variables: <code>var foo, bar int = 42, 1302</code></p>&#13;
</li>&#13;
<li>&#13;
<p>With type inference: <code>var foo = 42</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Of mixed multiple types: <code>var b, f, s = true, 2.3, "four"</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Without initialization (see <a data-type="xref" href="#section_ch03_zero_values">“Zero Values”</a>): <code>var s string</code></p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Go is very opinionated about clutter: it <em>hates</em> it. If you declare a variable in a function but don’t use it, your program will refuse to compile.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Short Variable Declarations"><div class="sect2" id="idm45983647121960">&#13;
<h2>Short Variable Declarations</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="short variable declarations" id="idm45983647120552"/><a data-type="indexterm" data-primary="short variable declarations" id="idm45983647119288"/>Go provides a bit of syntactic sugar that allows variables within functions to be simultaneously declared and assigned by using the <code>:=</code> operator in place of a <code>var</code> declaration with an implicit type.</p>&#13;
&#13;
<p>Short variable declarations have the general form:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">name</code> <code class="o">:=</code> <code class="nx">expression</code></pre>&#13;
&#13;
<p>These can be used to declare both single and multiple assignments:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>With initialization: <code>percent := rand.Float64() * 100.0</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Multiple variables at once: <code>x, y := 0, 2</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In practice, short variable declarations are the most common way that variables are declared and initialized in Go; <code>var</code> is usually only used either for local variables that need an explicit type, or to declare a variable that will be assigned a value later.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Remember that <code>:=</code> is a declaration, and <code>=</code> is an assignment. A <code>:=</code> operator that only attempts to redeclare existing variables will fail at compile time.</p>&#13;
&#13;
<p>Interestingly (and sometimes confusingly), if a short variable declaration has a mix of new and existing variables on its left-hand side, the short variable declaration acts like an assignment to the existing variables.<a data-type="indexterm" data-primary="variable declaration" data-startref="ch03_term23" id="idm45983647073592"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Zero Values"><div class="sect2" id="section_ch03_zero_values">&#13;
<h2>Zero Values</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="zero values" id="idm45983647114680"/><a data-type="indexterm" data-primary="zero values" id="idm45983647113432"/>When a variable is declared without an explicit value, it’s assigned to the <em>zero value</em> for its type:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Integers: <code>0</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Floats: <code>0.0</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Booleans: <code>false</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Strings: <code>""</code> (the empty string)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To illustrate, let’s define four variables of various types, without explicit initialization:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">i</code> <code class="kt">int</code>&#13;
<code class="kd">var</code> <code class="nx">f</code> <code class="kt">float64</code>&#13;
<code class="kd">var</code> <code class="nx">b</code> <code class="kt">bool</code>&#13;
<code class="kd">var</code> <code class="nx">s</code> <code class="kt">string</code></pre>&#13;
&#13;
<p class="pagebreak-before less_space">Now, if we were to use these variables we’d find that they were, in fact, already initialized to their zero values:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"integer: %d\n"</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code>   <code class="c1">// integer: 0</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"float: %f\n"</code><code class="p">,</code> <code class="nx">f</code><code class="p">)</code>     <code class="c1">// float: 0.000000</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"boolean: %t\n"</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code>   <code class="c1">// boolean: false</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"string: %q\n"</code><code class="p">,</code> <code class="nx">s</code><code class="p">)</code>    <code class="c1">// string: ""</code></pre>&#13;
&#13;
<p>You’ll notice the use of the <code>fmt.Printf</code> function, which allows greater control over output format. If you’re not familiar with this function, or with Go’s format strings, see the following sidebar.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch03_printf">&#13;
<h5>Formatting I/O in Go</h5>&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="formatting" id="idm45983646971016"/>Go’s <code>fmt</code> package implements several functions for formatting input and output. The most commonly used of these are (probably) <code>fmt.Printf</code> and <code>fmt.Scanf</code>, which can be used to write to standard output and read from standard input, respectively:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Printf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">a</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code> <code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">Scanf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">a</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code> <code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="format string" id="idm45983646966952"/>You’ll notice that each requires a <code>format</code> parameter. This is its <em>format string</em>: a string embedded with one or more <em>verbs</em> that direct how its parameters should be interpreted. For output functions like <code>fmt.Printf</code>, the formation of these verbs specifies the format with which the arguments will be printed.</p>&#13;
&#13;
<p>Each function also has a parameter <code>a</code>. The <code>...</code> (<em>variadic</em>) operator indicates that the function accepts zero or more parameters in this place; <code>interface{}</code> indicates that the parameter’s type is unspecified. Variadic functions will be covered in  <a data-type="xref" href="#section_ch03_variadic_functions">“Variadic Functions”</a>; the <code>interface{}</code> type in <a data-type="xref" href="#section_ch03_interfaces">“Interfaces”</a>.</p>&#13;
&#13;
<p>Some of the common verb flags used in format strings include:</p>&#13;
&#13;
<pre data-type="programlisting">%v   The value in a default format&#13;
%T   A representation of the type of the value&#13;
%%   A literal percent sign; consumes no value&#13;
%t   Boolean: the word true or false&#13;
%b   Integer: base 2&#13;
%d   Integer: base 10&#13;
%f   Floating point: decimal point but no exponent, e.g. 123.456&#13;
%s   String: the uninterpreted bytes of the string or slice&#13;
%q   String: a double-quoted string (safely escaped with Go syntax)</pre>&#13;
&#13;
<p>If you’re familiar with C, you may recognize these as somewhat simplified derivations of the flags used in the <code>printf</code> and <code>scanf</code> functions. A far more complete listing can be found in <a href="https://oreil.ly/Qajzp">Go’s documentation for the <code>fmt</code> package</a>.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The Blank Identifier"><div class="sect2" id="idm45983647116056">&#13;
<h2>The Blank Identifier</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="underscore operator" data-seealso="blank identifier" id="idm45983646898968"/><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="blank identifier" id="idm45983646897992"/><a data-type="indexterm" data-primary="blank identifier" id="idm45983646896776"/>The <em>blank identifier</em>, represented by the <code>_</code> (underscore) operator, acts as an anonymous placeholder. It may be used like any other identifier in a declaration, except it doesn’t introduce a binding.</p>&#13;
&#13;
<p>It’s most commonly used as a way to selectively ignore unneeded values in an assignment, which can be useful in a language that both supports multiple returns and demands there be no unused variables. For example, if you wanted to handle any potential errors returned by <code>fmt.Printf</code>, but don’t care about the number of bytes it writes,<sup><a data-type="noteref" id="idm45983646893816-marker" href="ch03.xhtml#idm45983646893816">4</a></sup> you could do the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">str</code> <code class="o">:=</code> <code class="s">"world"</code>&#13;
&#13;
<code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Hello %s\n"</code><code class="p">,</code> <code class="nx">str</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="c1">// Do something</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The blank identifier can also be used to import a package solely for its side effects:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="nx">_</code> <code class="s">"github.com/lib/pq"</code></pre>&#13;
&#13;
<p>Packages imported in this way are loaded and initialized as normal, including triggering any of its <code>init</code> functions, but are otherwise ignored and need not be referenced or otherwise directly used.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Constants"><div class="sect2" id="idm45983646795784">&#13;
<h2>Constants</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="constants" id="idm45983646794472"/><a data-type="indexterm" data-primary="constants" id="idm45983646793224"/>Constants are very similar to variables, using the <code>const</code> keyword to associate an identifier with some typed value. However, constants differ from variables in some important ways. First, and most obviously, attempting to modify a constant will generate an error at compile time. Second, constants <em>must</em> be assigned a value at declaration: they have no zero value.</p>&#13;
&#13;
<p>Both <code>var</code> and <code>const</code> may be used at both the package and function level, as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code> <code class="nx">language</code> <code class="kt">string</code> <code class="p">=</code> <code class="s">"Go"</code>&#13;
&#13;
<code class="kd">var</code> <code class="nx">favorite</code> <code class="kt">bool</code> <code class="p">=</code> <code class="kc">true</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kd">const</code> <code class="nx">text</code> <code class="p">=</code> <code class="s">"Does %s rule? %t!"</code>&#13;
    <code class="kd">var</code> <code class="nx">output</code> <code class="p">=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="nx">text</code><code class="p">,</code> <code class="nx">language</code><code class="p">,</code> <code class="nx">favorite</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">output</code><code class="p">)</code>   <code class="c1">// "Does Go rule? true!"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To demonstrate their behavioral similarity, the previous snippet arbitrarily mixes explicit type definitions with type inference for both the constants and variables.<a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-startref="ch03_term1" id="idm45983646831960"/></p>&#13;
&#13;
<p>Finally, the choice of <code>fmt.Sprintf</code> is inconsequential to this example, but if you’re unclear about Go’s format strings you can look back to <a data-type="xref" href="#sidebar_ch03_printf">“Formatting I/O in Go”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Container Types: Arrays, Slices, and Maps"><div class="sect1" id="section_ch03_container_types">&#13;
<h1>Container Types: Arrays, Slices, and Maps</h1>&#13;
&#13;
<p>Go<a data-type="indexterm" data-primary="Go" data-secondary="container types" data-seealso="arrays, maps, slices" id="ch03_term6"/><a data-type="indexterm" data-primary="types" data-secondary="containers" id="ch03_containers_2"/><a data-type="indexterm" data-primary="containers" id="ch03_containers"/> has three first-class container types that can be used to store collections of &#13;
<span class="keep-together">element</span> values:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="arrays" id="ch03_term7_2"/>Array<a data-type="indexterm" data-primary="arrays" id="ch03_term7"/>Array</dt>&#13;
<dd>&#13;
<p>A fixed-length sequence of zero or more elements of a particular type.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="slices" id="idm45983646738104"/><a data-type="indexterm" data-primary="slices" id="idm45983646737128"/>Slice</dt>&#13;
<dd>&#13;
<p>An abstraction around an array that can be resized at runtime.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="types" data-secondary="maps" id="idm45983646735176"/><a data-type="indexterm" data-primary="maps" id="idm45983646734200"/>Map</dt>&#13;
<dd>&#13;
<p>An associative data structure that allows distinct keys to be arbitrarily paired with, or “mapped to,” values.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="len built-in function" id="built-in-len"/><a data-type="indexterm" data-primary="len built-in function" id="ch03_term35"/>As container types, all of these have a <code>length</code> property that reflects how many elements are stored in that container. The <code>len</code> built-in function can be used to find the length of any array, slice (including strings), or map.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Arrays"><div class="sect2" id="section_ch03_arrays">&#13;
<h2>Arrays</h2>&#13;
&#13;
<p>In Go, as in most other mainstream languages, an <em>array</em> is a fixed-length sequence of zero or more elements of a particular type.</p>&#13;
&#13;
<p>Arrays can be declared by including a length declaration. The zero value of an array is an array of the specified length containing zero-valued elements. Individual array &#13;
<span class="keep-together">elements</span> are indexed from <code>0</code> to <code>N-1</code>, and can be accessed using the familiar bracket &#13;
<span class="keep-together">notation</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">a</code> <code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code>                    <code class="c1">// Zero-value array of type [3]int</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>                  <code class="c1">// "[0 0 0]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>               <code class="c1">// "0"</code>&#13;
&#13;
<code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="p">=</code> <code class="mi">42</code>                       <code class="c1">// Update second index</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>                  <code class="c1">// "[0 42 0]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>               <code class="c1">// "42"</code>&#13;
&#13;
<code class="nx">i</code> <code class="o">:=</code> <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>                  <code class="c1">// "42"</code></pre>&#13;
&#13;
<p class="pagebreak-before less_space">Arrays can be initialized using array literals, as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">b</code> <code class="o">:=</code> <code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">}</code></pre>&#13;
&#13;
<p>You can also have the compiler count the array elements for you:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">b</code> <code class="o">:=</code> <code class="p">[</code><code class="o">...</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">}</code></pre>&#13;
&#13;
<p>In both cases, the type of <code>b</code> is <code>[3]int</code>.</p>&#13;
&#13;
<p>As with all container types, the <code>len</code> built-in function can be used to discover the length of an array:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">))</code>             <code class="c1">// "3"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">b</code><code class="p">[</code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">])</code>        <code class="c1">// "6"</code></pre>&#13;
&#13;
<p>In practice, arrays aren’t actually used directly very often. Instead, it’s much more common to use <em>slices</em>, an array abstraction type that behaves (for all practical purposes) like a resizable array.<a data-type="indexterm" data-primary="types" data-secondary="arrays" data-startref="ch03_term7_2" id="idm45983646526792"/><a data-type="indexterm" data-primary="arrays" data-startref="ch03_term7" id="idm45983646525672"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Slices"><div class="sect2" id="section_ch03_slices">&#13;
<h2>Slices</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="slices" id="ch03_term8_2"/><a data-type="indexterm" data-primary="slices" id="ch03_term8"/>Slices are a data type in Go that provide a powerful abstraction around a traditional array, such that working with slices looks and feels to the programmer very much like working with arrays. Like arrays, slices provide access to a sequence of elements of a particular type via the familiar bracket notation, indexed from <code>0</code> to <code>N-1</code>. However, where arrays are fixed-length, slices can be resized at runtime.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#img_ch03_slice">Figure 3-1</a>, a slice is actually a lightweight data structure with three &#13;
<span class="keep-together">components</span>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A pointer to some element of a backing array that represents the first element of the slice (not necessarily the first element of the array)</p>&#13;
</li>&#13;
<li>&#13;
<p>A length, representing the number of elements in the slice</p>&#13;
</li>&#13;
<li>&#13;
<p>A capacity, which represents the upper value of the length</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="cap built-in function" id="idm45983646493016"/><a data-type="indexterm" data-primary="cap built-in function" id="idm45983646492040"/>If not otherwise specified, the capacity value equals the number of elements between the start of the slice and the end of the backing array. The built-in <code>len</code> and <code>cap</code> functions will provide the length and capacity of a slice, respectively.</p>&#13;
&#13;
<figure><div id="img_ch03_slice" class="figure">&#13;
<img src="Images/cngo_0301.png" alt="cngo 0301" width="1393" height="1176"/>&#13;
<h6><span class="label">Figure 3-1. </span>Two slices backed by the same array</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with slices"><div class="sect3" id="idm45983646488136">&#13;
<h3>Working with slices</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="make built-in function" id="idm45983646486536"/><a data-type="indexterm" data-primary="make built-in function" id="idm45983646485560"/>Creating a slice is somewhat different from creating an array: slices are typed only according to the type of their elements, not their number. The <code>make</code> built-in function can be used to create a slice with a nonzero length as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">n</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>         <code class="c1">// Create an int slice with 3 elements</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>              <code class="c1">// "[0 0 0]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">n</code><code class="p">))</code>         <code class="c1">// "3"; len works for slices and arrays</code>&#13;
&#13;
<code class="nx">n</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="p">=</code> <code class="mi">8</code>&#13;
<code class="nx">n</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="p">=</code> <code class="mi">16</code>&#13;
<code class="nx">n</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="p">=</code> <code class="mi">32</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>              <code class="c1">// "[8 16 32]"</code></pre>&#13;
&#13;
<p>As you can see, working with slices feels a lot like working with arrays. Like arrays, the zero value of a slice is a slice of the specified length containing zero-valued &#13;
<span class="keep-together">elements</span>, and elements in a slice are indexed and accessed exactly like they are in an array.</p>&#13;
&#13;
<p>A slice literal is declared just like an array literal, except that you omit the element count:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="o">:=</code> <code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">}</code>               <code class="c1">// A literal []int declaration</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>              <code class="c1">// "[1]"</code></pre>&#13;
&#13;
<p>Slices can be extended using the <code>append</code> built-in, which returns an extended slice containing one or more new values appended to the original one:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>            <code class="c1">// Append 2 to m</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>              <code class="c1">// "[1 2]"</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="append built-in function" id="idm45983646384984"/><a data-type="indexterm" data-primary="append built-in function" id="idm45983646384136"/><a data-type="indexterm" data-primary="functions" data-secondary="variadic functions" id="idm45983646383528"/><a data-type="indexterm" data-primary="variadic functions" id="idm45983646382648"/>The <code>append</code> built-in function also happens to be <em>variadic</em>, which means it can accept a variable number of arguments in addition to the slice to be appended. Variadic functions will be covered in more detail in <a data-type="xref" href="#section_ch03_variadic_functions">“Variadic Functions”</a>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>            <code class="c1">// Append to m from the previous snippet</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>              <code class="c1">// "[1 2]"</code>&#13;
&#13;
<code class="nx">m</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>              <code class="c1">// "[1 2 3 4]"</code>&#13;
&#13;
<code class="nx">m</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code> <code class="nx">m</code><code class="o">...</code><code class="p">)</code>         <code class="c1">// Append m to itself</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>              <code class="c1">// "[1 2 3 4 1 2 3 4]"</code></pre>&#13;
&#13;
<p>Note that the <code>append</code> built-in function returns the appended slice rather than modifying the slice in place. The reason for this is that behind the scenes, if the destination has sufficient capacity to accommodate the new elements, then a new slice is constructed from the original underlying array. If not, a new underlying array is automatically allocated.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Note that <code>append</code> <em>returns</em> the appended slice. Failing to store it is a common error.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The slice operator"><div class="sect3" id="idm45983646487512">&#13;
<h3>The slice operator</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="slice operator" id="ch03_term9"/>Arrays and slices (including strings) support the <em>slice operator</em>, which has the syntax <code>s[i:j]</code>, where <code>i</code> and <code>j</code> are in the range <code>0 ≤ i ≤ j ≤ cap(s)</code>.</p>&#13;
&#13;
<p>For example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s0</code> <code class="o">:=</code> <code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">}</code>    <code class="c1">// A slice literal</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s0</code><code class="p">)</code>                     <code class="c1">// "[0 1 2 3 4 5 6]"</code></pre>&#13;
&#13;
<p>In the previous snippet, we define a slice literal. Recall that it closely resembles an array literal, except that it doesn’t indicate a size.</p>&#13;
&#13;
<p>If the values of <code>i</code> or <code>j</code> are omitted from a slice operator, they’ll default to <code>0</code> and <code>len(s)</code>, respectively:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s1</code> <code class="o">:=</code> <code class="nx">s0</code><code class="p">[:</code><code class="mi">4</code><code class="p">]</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s1</code><code class="p">)</code>                     <code class="c1">// "[0 1 2 3]"</code>&#13;
&#13;
<code class="nx">s2</code> <code class="o">:=</code> <code class="nx">s0</code><code class="p">[</code><code class="mi">3</code><code class="p">:]</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s2</code><code class="p">)</code>                     <code class="c1">// "[3 4 5 6]"</code></pre>&#13;
&#13;
<p>A slice operator will produce a new slice backed by the same array with a length of &#13;
<span class="keep-together"><code>j - i</code>.</span> Changes made to this slice will be reflected in the underlying array, and subsequently in all slices derived from that same array:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s0</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="p">=</code> <code class="mi">42</code>                          <code class="c1">// Change reflected in all 3 slices</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s0</code><code class="p">)</code>                     <code class="c1">// "[0 1 2 42 4 5 6]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s1</code><code class="p">)</code>                     <code class="c1">// "[0 1 2 42]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s2</code><code class="p">)</code>                     <code class="c1">// "[42 4 5 6]"</code></pre>&#13;
&#13;
<p>This effect is illustrated in more detail in <a data-type="xref" href="#img_ch03_slice">Figure 3-1</a>.<a data-type="indexterm" data-primary="slice operator" data-startref="ch03_term9" id="idm45983646062520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Strings as slices"><div class="sect3" id="idm45983646232040">&#13;
<h3>Strings as slices</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="strings" id="ch03_term10_2"/><a data-type="indexterm" data-primary="types" data-secondary="strings" id="ch03_term10_3"/><a data-type="indexterm" data-primary="strings" id="ch03_term10"/><a data-type="indexterm" data-primary="string literals" id="ch03_term11"/>The subject of how Go implements strings under the hood is actually quite a bit more complex than you might expect, involving lots of details like the differences between bytes, characters, and runes; Unicode versus UTF-8 encoding; and the differences between a string and a string literal.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="rune" id="ch03_term12_2"/><a data-type="indexterm" data-primary="rune" id="ch03_term12"/><a data-type="indexterm" data-primary="types" data-secondary="byte" id="ch03_term13_2"/><a data-type="indexterm" data-primary="byte" id="ch03_term13"/>For now it’s sufficient to know that Go strings are essentially just read-only slices of bytes that typically (but aren’t <em>required</em> to) contain a series of UTF-8 sequences representing Unicode code points, called <code>runes</code>. Go even allows you to cast your strings into <code>byte</code> or <code>rune</code> arrays:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code> <code class="o">:=</code> <code class="s">"foö"</code>          <code class="c1">// Unicode: f=0x66 o=0x6F ö=0xC3B6</code>&#13;
<code class="nx">r</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">rune</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code>&#13;
<code class="nx">b</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code></pre>&#13;
&#13;
<p>By casting the string <code>s</code> in this way, we’re able to uncover its identity as either a slice of bytes or a slice of runes. We can illustrate this by using <code>fmt.Printf</code> with the <code>%T</code> (type) and <code>%v</code> (value) flags (which we presented in <a data-type="xref" href="#sidebar_ch03_printf">“Formatting I/O in Go”</a>) to output the results:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%7T %v\n"</code><code class="p">,</code> <code class="nx">s</code><code class="p">,</code> <code class="nx">s</code><code class="p">)</code>    <code class="c1">// "string foö"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%7T %v\n"</code><code class="p">,</code> <code class="nx">r</code><code class="p">,</code> <code class="nx">r</code><code class="p">)</code>    <code class="c1">// "[]int32 [102 111 246]"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%7T %v\n"</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code>    <code class="c1">// "[]uint8 [102 111 195 182]"</code></pre>&#13;
&#13;
<p>Note that the value of the string literal, <code>foö</code>, contains a mix of characters whose encoding can be contained in a single byte (<code>f</code> and <code>o</code>, encoded as <code>102</code> and <code>111</code>, respectively) and one character that cannot (<code>ö</code>, encoded as <code>195 182</code>).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that the <code>byte</code> and <code>rune</code> types are mnemonic aliases for <code>uint8</code> and <code>int32</code>, respectively.</p>&#13;
</div>&#13;
&#13;
<p>Each of these lines print the type and value of the variables passed to it. As expected, the string value, <code>foö</code>, is printed literally. The next two lines are interesting, however. The <code>uint8</code> (byte) slice contains four bytes, which represent the string’s UTF-8 encoding (two 1-byte code points, and one 2-byte code point). The <code>int32</code> (rune) slice contains three values that represent the code points of the individual characters.</p>&#13;
&#13;
<p>There’s far, far more to string encoding in Go, but we only have so much space. If you’re interested in learning more, take a look at Rob Pike’s “Strings, Bytes, Runes and Characters in Go” on <a href="https://oreil.ly/mgku7"><em>The Go Blog</em></a> for a deep dive into the subject.<a data-type="indexterm" data-primary="types" data-secondary="slices" data-startref="ch03_term8_2" id="idm45983645931688"/><a data-type="indexterm" data-primary="slices" data-startref="ch03_term8" id="idm45983645930472"/><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="strings" data-startref="ch03_term10_2" id="idm45983645929528"/><a data-type="indexterm" data-primary="types" data-secondary="strings" data-startref="ch03_term10_3" id="idm45983645928040"/><a data-type="indexterm" data-primary="strings" data-startref="ch03_term10" id="idm45983645926824"/><a data-type="indexterm" data-primary="string literals" data-startref="ch03_term11" id="idm45983645925880"/><a data-type="indexterm" data-primary="types" data-secondary="rune" data-startref="ch03_term12_2" id="idm45983645924936"/><a data-type="indexterm" data-primary="rune" data-startref="ch03_term12" id="idm45983645923720"/><a data-type="indexterm" data-primary="types" data-secondary="byte" data-startref="ch03_term13_2" id="idm45983645922776"/><a data-type="indexterm" data-primary="byte" data-startref="ch03_term13" id="idm45983645921560"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Maps"><div class="sect2" id="idm45983646524424">&#13;
<h2>Maps</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="hash table" id="idm45983645919512"/><a data-type="indexterm" data-primary="Python" id="idm45983645918584"/><a data-type="indexterm" data-primary="Ruby" id="idm45983645917912"/><a data-type="indexterm" data-primary="Java" id="idm45983645917240"/><a data-type="indexterm" data-primary="types" data-secondary="maps" id="ch03_term14_2"/><a data-type="indexterm" data-primary="maps" id="ch03_term14"/>Go’s <em>map</em> data type references a <em>hash table</em>: an incredibly useful associative data structure that allows distinct keys to be arbitrarily “mapped” to values as key-value pairs. This data structure is common among today’s mainstream languages: if you’re coming to Go from one of these then you probably already use them, perhaps in the form of Python’s <code>dict</code>, Ruby’s <code>Hash</code>, or Java’s <code>HashMap</code>.</p>&#13;
&#13;
<p>Map types in Go are written <code>map[K]V</code>, where <code>K</code> and <code>V</code> are the types of its keys and values, respectively. Any type that is comparable using the <code>==</code> operator may be used as a key, and <code>K</code> and <code>V</code> need not be of the same type. For example, <code>string</code> keys may be mapped to <code>float32</code> values.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="delete built-in function" id="idm45983645907432"/><a data-type="indexterm" data-primary="delete built-in function" id="idm45983645906264"/><a data-type="indexterm" data-primary="built-in functions" data-secondary="len built-in function" data-startref="built-in-len" id="idm45983645905576"/><a data-type="indexterm" data-primary="len built-in function" data-startref="ch03_term35" id="idm45983645904360"/><a data-type="indexterm" data-primary="built-in functions" data-secondary="make built-in function" id="idm45983645903416"/><a data-type="indexterm" data-primary="make built-in function" id="idm45983645902472"/>A map can be initialized using the built-in <code>make</code> function, and its values can be referenced using the usual <code>name[key]</code> syntax. Our old friend <code>len</code> will return the number of key/value pairs in a map; the <code>delete</code> built-in can remove key/value pairs:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">freezing</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">float32</code><code class="p">)</code>    <code class="c1">// Empty map of string to float32</code>&#13;
&#13;
<code class="nx">freezing</code><code class="p">[</code><code class="s">"celsius"</code><code class="p">]</code> <code class="p">=</code> <code class="mf">0.0</code>&#13;
<code class="nx">freezing</code><code class="p">[</code><code class="s">"fahrenheit"</code><code class="p">]</code> <code class="p">=</code> <code class="mf">32.0</code>&#13;
<code class="nx">freezing</code><code class="p">[</code><code class="s">"kelvin"</code><code class="p">]</code> <code class="p">=</code> <code class="mf">273.2</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">freezing</code><code class="p">[</code><code class="s">"kelvin"</code><code class="p">])</code>         <code class="c1">// "273.2"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">freezing</code><code class="p">))</code>              <code class="c1">// "3"</code>&#13;
&#13;
<code class="nb">delete</code><code class="p">(</code><code class="nx">freezing</code><code class="p">,</code> <code class="s">"kelvin"</code><code class="p">)</code>              <code class="c1">// Delete "kelvin"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">freezing</code><code class="p">))</code>              <code class="c1">// "2"</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="map literals" id="idm45983644756168"/>Maps may also be initialized and populated as <em>map literals</em>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">freezing</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">float32</code><code class="p">{</code>&#13;
    <code class="s">"celsius"</code><code class="p">:</code>    <code class="mf">0.0</code><code class="p">,</code>&#13;
    <code class="s">"fahrenheit"</code><code class="p">:</code> <code class="mf">32.0</code><code class="p">,</code>&#13;
    <code class="s">"kelvin"</code><code class="p">:</code>     <code class="mf">273.2</code><code class="p">,</code>                <code class="c1">// The trailing comma is required!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note the trailing comma on the last line. This is not optional: the code will refuse to compile if it’s missing.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Map membership testing"><div class="sect3" id="idm45983644662424">&#13;
<h3>Map membership testing</h3>&#13;
&#13;
<p>Requesting the value of a key that’s not present in a map won’t cause an exception to be thrown (those don’t exist in Go anyway) or return some kind of <code>null</code> value. Rather, it returns the zero value for the map’s value type:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">foo</code> <code class="o">:=</code> <code class="nx">freezing</code><code class="p">[</code><code class="s">"no-such-key"</code><code class="p">]</code>          <code class="c1">// Get non-existent key</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">foo</code><code class="p">)</code>                        <code class="c1">// "0" (float32 zero value)</code></pre>&#13;
&#13;
<p>This can be a very useful feature because it reduces a lot of boilerplate membership testing when working with maps, but it can be a little tricky when your map happens to actually contain zero-valued values. Fortunately, accessing a map can also return a second optional <code>bool</code> that indicates whether the key is present in the map:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">newton</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="nx">freezing</code><code class="p">[</code><code class="s">"newton"</code><code class="p">]</code>        <code class="c1">// What about the Newton scale?</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">newton</code><code class="p">)</code>                     <code class="c1">// "0"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ok</code><code class="p">)</code>                         <code class="c1">// "false"</code></pre>&#13;
&#13;
<p>In this snippet, the value of <code>newton</code> is <code>0.0</code>. But is that really the correct value,<sup><a data-type="noteref" id="idm45983644570440-marker" href="ch03.xhtml#idm45983644570440">5</a></sup> or was there just no matching key? Fortunately, since <code>ok</code> is also <code>false</code>, we know the latter to be the case.<a data-type="indexterm" data-primary="Go" data-secondary="container types" data-startref="ch03_term6" id="idm45983644568776"/><a data-type="indexterm" data-primary="types" data-secondary="maps" data-startref="ch03_term14_2" id="idm45983644545448"/><a data-type="indexterm" data-primary="maps" data-startref="ch03_term14" id="idm45983644544232"/><a data-type="indexterm" data-primary="types" data-secondary="containers" data-startref="ch03_containers_2" id="idm45983644543288"/><a data-type="indexterm" data-primary="containers" data-startref="ch03_containers" id="idm45983644542072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Pointers"><div class="sect1" id="section_ch03_pointers">&#13;
<h1>Pointers</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="pointers" id="ch03_term15"/>Okay. Pointers. The bane and undoing of undergraduates the world over. If you’re coming from a dynamically typed language, the idea of the pointer may seem alien to you. While we’re not going to drill down <em>too</em> deeply into the subject, we’ll do our best to cover it well enough to provide some clarity on the subject.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="variables" id="ch03_term16_2"/><a data-type="indexterm" data-primary="variables" id="ch03_term16"/>Going back to first principles, a “variable” is a piece of storage in memory that contains some value. Typically, when you refer to a variable by its name (<code>foo = 10</code>) or by an expression (<code>s[i] = "foo"</code>), you’re directly reading or updating the value of the variable.</p>&#13;
&#13;
<p>A <em>pointer</em> stores the <em>address</em> of a variable: the location in memory where the value is stored. Every variable has an address, and using pointers allows us to indirectly read or update the value of their variables (illustrated in <a data-type="xref" href="#img_ch03_pointers">Figure 3-2</a>):</p>&#13;
<dl>&#13;
<dt>Retrieving the address of a variable</dt>&#13;
<dd>&#13;
<p>The address of a named variable can be retrieved by using the <code>&amp;</code> operator. For example, the expression <code>p := &amp;a</code> will obtain the address of <code>a</code> and assign it to <code>p</code>.</p>&#13;
</dd>&#13;
<dt>Pointer types</dt>&#13;
<dd>&#13;
<p>The variable <code>p</code>, which you can say “points to” <code>a</code>, has a type of <code>*int</code>, where the <code>*</code> indicates that it’s a pointer type that points to an <code>int</code>.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="dereferencing" id="idm45983644523736"/>Dereferencing a pointer</dt>&#13;
<dd>&#13;
<p>To retrieve the value of the value <code>a</code> from <code>p</code>, you can <em>dereference</em> it using a <code>*</code> before the pointer variable name, allowing us to indirectly read or update <code>a</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div id="img_ch03_pointers" class="figure">&#13;
<img src="Images/cngo_0302.png" alt="cngo 0302" width="1019" height="686"/>&#13;
<h6><span class="label">Figure 3-2. </span>The expression <code>p := &amp;a</code> gets the address of <code>a</code> and assigns it to <code>p</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, to put everything in one place, take a look at the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">a</code> <code class="kt">int</code> <code class="p">=</code> <code class="mi">10</code>&#13;
&#13;
<code class="kd">var</code> <code class="nx">p</code> <code class="o">*</code><code class="kt">int</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">a</code>         <code class="c1">// p of type *int points to a</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code>          <code class="c1">// "0x0001"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">*</code><code class="nx">p</code><code class="p">)</code>         <code class="c1">// "10"</code>&#13;
&#13;
<code class="o">*</code><code class="nx">p</code> <code class="p">=</code> <code class="mi">20</code>                 <code class="c1">// indirectly update a</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>          <code class="c1">// "20"</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="variables" data-startref="ch03_term16_2" id="idm45983644405192"/><a data-type="indexterm" data-primary="variables" data-startref="ch03_term16" id="idm45983644448248"/>Pointers can be declared like any other variable, with a zero value of <code>nil</code> if not explicitly initialized. They’re also comparable, being equal only if they contain the same address (that is, they point to the same variable) or if they are both <code>nil</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">n</code> <code class="o">*</code><code class="kt">int</code>&#13;
<code class="kd">var</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="kt">int</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>              <code class="c1">// "&lt;nil&gt;"</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">n</code> <code class="o">==</code> <code class="kc">nil</code><code class="p">)</code>       <code class="c1">// "true" (n is nil)</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code> <code class="o">==</code> <code class="nx">y</code><code class="p">)</code>         <code class="c1">// "true" (x and y are both zero)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code> <code class="o">==</code> <code class="o">&amp;</code><code class="nx">x</code><code class="p">)</code>       <code class="c1">// "true" (*x is equal to itself)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code> <code class="o">==</code> <code class="o">&amp;</code><code class="nx">y</code><code class="p">)</code>       <code class="c1">// "false" (different vars)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code> <code class="o">==</code> <code class="kc">nil</code><code class="p">)</code>      <code class="c1">// "false" (*x is not nil)</code></pre>&#13;
&#13;
<p>Because <code>n</code> is never initialized, its value is <code>nil</code>, and comparing it to <code>nil</code> returns <code>true</code>. The integers <code>x</code> and <code>y</code> both have a value of <code>0</code>, so comparing their values yields <code>true</code>, but they are still distinct variables, and comparing pointers to them still evaluates to <code>false</code>.<a data-type="indexterm" data-primary="pointers" data-startref="ch03_term15" id="idm45983644335496"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Control Structures"><div class="sect1" id="idm45983644540536">&#13;
<h1>Control Structures</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="control structures" id="ch03_term17"/>Any programmer coming to Go from another language will find its suite of control structures to be generally familiar, even comfortable (at first) for those coming from a language heavily influenced by C. However, there are some pretty important deviations in their implementation and usages that might seem odd at first.</p>&#13;
&#13;
<p>For example, control structure statements don’t require lots of parentheses. Okay. Less clutter. That’s fine.</p>&#13;
&#13;
<p>There’s also only one loop type. There is no <code>while</code>; only <code>for</code>. Seriously! It’s actually pretty cool, though. Read on, and you’ll see what I mean.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Fun with for"><div class="sect2" id="idm45983644329464">&#13;
<h2>Fun with for</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="loops" id="ch03_term18"/><a data-type="indexterm" data-primary="for statement" data-see="loops" id="idm45983644327048"/>The <code>for</code> statement is Go’s one and only loop construct, and while there’s no explicit <code>while</code> loop, Go’s <code>for</code> can provide all of its functionality, effectively unifying all of the entry control loop types to which you’ve become accustomed.</p>&#13;
&#13;
<p>Go has no <code>do-while</code> equivalent.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The general for statement"><div class="sect3" id="idm45983644323560">&#13;
<h3>The general for statement</h3>&#13;
&#13;
<p>The general form of <code>for</code> loops in Go is nearly identical to that of other C-family languages, in which three statements—the init statement, the continuation condition, and the post statement—are separated by semicolons in the traditional style. Any variables declared in the init statement will be scoped only to the <code>for</code> statement:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">sum</code> <code class="o">:=</code> <code class="mi">0</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
    <code class="nx">sum</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code>        <code class="c1">// "10"</code></pre>&#13;
&#13;
<p>In this example, <code>i</code> is initialized to 0. At the end of each iteration <code>i</code> is incremented by 1, and if it’s still less than 10, the process repeats.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unlike most C-family languages, <code>for</code> statements don’t require parentheses around their clauses, and braces are required.</p>&#13;
</div>&#13;
&#13;
<p>In a break from traditional C-style languages, Go’s <code>for</code> statement’s init and post statements are entirely optional. As shown in the code that follows, this makes it considerably more flexible:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">sum</code><code class="p">,</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="mi">10</code> <code class="p">{</code>            <code class="c1">// Equivalent to: for ; i &lt; 10;</code>&#13;
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">i</code>&#13;
    <code class="nx">i</code><code class="o">++</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code> <code class="nx">sum</code><code class="p">)</code>     <code class="c1">// "10 45"</code></pre>&#13;
&#13;
<p>The <code>for</code> statement in the previous example has no init or post statements, only a bare condition. This is actually a big deal, because it means that <code>for</code> is able to fill the role traditionally occupied by the <code>while</code> loop.</p>&#13;
&#13;
<p>Finally, omitting all three clauses from a <code>for</code> statement creates a block that loops infinitely, just like a traditional <code>while (true)</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"For ever..."</code><code class="p">)</code>&#13;
&#13;
<code class="k">for</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"...and ever"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because it lacks any terminating condition, the loop in the previous snippet will iterate forever. On purpose.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Looping over arrays and slices"><div class="sect3" id="idm45983644322904">&#13;
<h3>Looping over arrays and slices</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="range keyword" id="ch03_term19"/>Go provides a useful keyword, <code>range</code>, that simplifies looping over a variety of data types.</p>&#13;
&#13;
<p>In the case of arrays and slices, <code>range</code> can be used with a <code>for</code> statement to retrieve the index and the value of each element as it iterates:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code> <code class="o">:=</code> <code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">32</code><code class="p">}</code>     <code class="c1">// A slice of ints</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">v</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">s</code> <code class="p">{</code>           <code class="c1">// range gets each index/value</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code> <code class="s">"-&gt;"</code><code class="p">,</code> <code class="nx">v</code><code class="p">)</code>     <code class="c1">// Output index and its value</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the previous example, the values of <code>i</code> and <code>v</code> will update each iteration to contain the index and value, respectively, of each element in the slice <code>s</code>. So the output will look something like the following:</p>&#13;
&#13;
<pre data-type="programlisting">0 -&gt; 2&#13;
1 -&gt; 4&#13;
2 -&gt; 8&#13;
3 -&gt; 16&#13;
4 -&gt; 32</pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="basic data types" data-tertiary="blank identifier" id="idm45983644077848"/><a data-type="indexterm" data-primary="blank identifier" id="idm45983644076600"/>But what if you don’t need both of these values? After all, the Go compiler will demand that you use them if you declare them. Fortunately, as elsewhere in Go, the unneeded values can be discarded by using the “blank identifier,” signified by the underscore operator:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">a</code> <code class="o">:=</code> <code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">0</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">8</code><code class="p">}</code>&#13;
<code class="nx">sum</code> <code class="o">:=</code> <code class="mi">0</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">v</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">a</code> <code class="p">{</code>&#13;
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">v</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code>    <code class="c1">// "20"</code></pre>&#13;
&#13;
<p>As in the last example, the value <code>v</code> will update each iteration to contain the value of each element in the slice <code>a</code>. This time, however, the index value is conveniently ignored and discarded, and the Go compiler stays content.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Looping over maps"><div class="sect3" id="idm45983644016632">&#13;
<h3>Looping over maps</h3>&#13;
&#13;
<p>The <code>range</code> keyword may be also be used with a <code>for</code> statement to loop over maps, with each iteration returning the current key and value:<a data-type="indexterm" data-primary="loops" data-startref="ch03_term18" id="idm45983644014296"/><a data-type="indexterm" data-primary="range keyword" data-startref="ch03_term19" id="idm45983644013320"/></p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">int</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code>&#13;
    <code class="mi">1</code><code class="p">:</code> <code class="s">"January"</code><code class="p">,</code>&#13;
    <code class="mi">2</code><code class="p">:</code> <code class="s">"February"</code><code class="p">,</code>&#13;
    <code class="mi">3</code><code class="p">:</code> <code class="s">"March"</code><code class="p">,</code>&#13;
    <code class="mi">4</code><code class="p">:</code> <code class="s">"April"</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">k</code><code class="p">,</code> <code class="nx">v</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">m</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="s">"-&gt;"</code><code class="p">,</code> <code class="nx">v</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that Go maps aren’t ordered, so the output won’t be either:</p>&#13;
&#13;
<pre data-type="programlisting">3 -&gt; March&#13;
4 -&gt; April&#13;
1 -&gt; January&#13;
2 -&gt; February</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The if Statement"><div class="sect2" id="idm45983643931640">&#13;
<h2>The if Statement</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="if Statement" id="idm45983643930328"/>The typical application of the <code>if</code> statement in Go is consistent with other C-style languages, except for the lack of parentheses around the clause and the fact that braces are required:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">if</code> <code class="mi">7</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"7 is even"</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"7 is odd"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unlike most C-family languages, <code>if</code> statements don’t require parentheses around their clauses, and braces are required.</p>&#13;
</div>&#13;
&#13;
<p>Interestingly, Go allows an initialization statement to precede the condition clause in an <code>if</code> statement, allowing for a particularly useful idiom. For example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">if</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="s">"foo.ext"</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"All is fine."</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note how the <code>err</code> variable is being initialized prior to a check for its definition, making it somewhat similar to the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="s">"foo.go"</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"All is fine."</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The two constructs aren’t exactly equivalent however: in the first example <code>err</code> is scoped only to the <code>if</code> statement; in the second example <code>err</code> is visible to the entire containing function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The switch Statement"><div class="sect2" id="idm45983643760984">&#13;
<h2>The switch Statement</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="switch Statement" id="ch03_term20"/>As in other languages, Go provides a <code>switch</code> statement that provides a way to more concisely express a series of <code>if-then-else</code> conditionals. However, it differs from &#13;
<span class="keep-together">the traditional</span> implementation in a number of ways that make it considerably more &#13;
<span class="keep-together">flexible</span>.</p>&#13;
&#13;
<p>Perhaps the most obvious difference to folks coming from C-family languages is that there’s no fallthrough between the cases by default; this behavior can be explicitly added by using the <code>fallthrough</code> keyword:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code>&#13;
&#13;
<code class="k">switch</code> <code class="nx">i</code> <code class="o">%</code> <code class="mi">3</code> <code class="p">{</code>&#13;
<code class="k">case</code> <code class="mi">0</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Zero"</code><code class="p">)</code>&#13;
    <code class="k">fallthrough</code>&#13;
<code class="k">case</code> <code class="mi">1</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"One"</code><code class="p">)</code>&#13;
<code class="k">case</code> <code class="mi">2</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Two"</code><code class="p">)</code>&#13;
<code class="k">default</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Huh?"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the value of <code>i % 3</code> is <code>0</code>, which matches the first case, causing it to output to word <code>Zero</code>. In Go, <code>switch</code> cases don’t fall through by default, but the existence of an explicit <code>fallthrough</code> statement means that the subsequent case is also executed and <code>One</code> is printed. Finally, the absence of a <code>fallthrough</code> on that case causes the resolution of the <code>switch</code> to complete. All told, the following is printed:</p>&#13;
&#13;
<pre data-type="programlisting">Zero&#13;
One</pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="case expressions" id="idm45983643666424"/>Switches in Go have two interesting properties. First, <code>case</code> expressions don’t need to be integers, or even constants: the cases will be evaluated from top to bottom, running the first case whose value is equal to the condition expression. Second, if the switch expression is left empty it’ll be interpreted as <code>true</code>, and will match the first case whose guarding condition evaluates to <code>true</code>. Both of these properties are demonstrated in the following example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">hour</code> <code class="o">:=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Hour</code><code class="p">()</code>&#13;
&#13;
<code class="k">switch</code> <code class="p">{</code>&#13;
<code class="k">case</code> <code class="nx">hour</code> <code class="o">&gt;=</code> <code class="mi">5</code> <code class="o">&amp;&amp;</code> <code class="nx">hour</code> <code class="p">&lt;</code> <code class="mi">9</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm writing"</code><code class="p">)</code>&#13;
<code class="k">case</code> <code class="nx">hour</code> <code class="o">&gt;=</code> <code class="mi">9</code> <code class="o">&amp;&amp;</code> <code class="nx">hour</code> <code class="p">&lt;</code> <code class="mi">18</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm working"</code><code class="p">)</code>&#13;
<code class="k">default</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm sleeping"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>switch</code> has no condition, so it’s exactly equivalent to using <code>switch true</code>. As such, it matches the first statement whose condition also evaluates to <code>true</code>. In my case, <code>hour</code> is 23, so the output is “I’m sleeping.”<sup><a data-type="noteref" id="idm45983643598696-marker" href="ch03.xhtml#idm45983643598696">6</a></sup></p>&#13;
&#13;
<p>Finally, just as with <code>if</code>, a statement can precede the condition expression of a <code>switch</code>, in which case any defined values are scoped to the <code>switch</code>. For example, the previous example can be rewritten as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">switch</code> <code class="nx">hour</code> <code class="o">:=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Hour</code><code class="p">();</code> <code class="p">{</code>  <code class="c1">// Empty expression means "true"</code>&#13;
<code class="k">case</code> <code class="nx">hour</code> <code class="o">&gt;=</code> <code class="mi">5</code> <code class="o">&amp;&amp;</code> <code class="nx">hour</code> <code class="p">&lt;</code> <code class="mi">9</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm writing"</code><code class="p">)</code>&#13;
<code class="k">case</code> <code class="nx">hour</code> <code class="o">&gt;=</code> <code class="mi">9</code> <code class="o">&amp;&amp;</code> <code class="nx">hour</code> <code class="p">&lt;</code> <code class="mi">18</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm working"</code><code class="p">)</code>&#13;
<code class="k">default</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"I'm sleeping"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note the trailing semicolon: this empty expression implies <code>true</code>, so that this expression is equivalent to <code>switch hour := time.Now().Hour(); true</code> and matches the first true case condition.<a data-type="indexterm" data-primary="Go" data-secondary="control structures" data-startref="ch03_term17" id="idm45983643506168"/><a data-type="indexterm" data-primary="switch Statement" data-startref="ch03_term20" id="idm45983643505048"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Error Handling"><div class="sect1" id="idm45983643760360">&#13;
<h1>Error Handling</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="errors" id="idm45983643502696"/><a data-type="indexterm" data-primary="errors" data-seealso="error handling" id="idm45983643501496"/><a data-type="indexterm" data-primary="error handling" id="ch03_term21"/>Errors in Go are treated as just another value, represented by the built-in <code>error</code> type. This makes error handling straightforward: idiomatic Go functions may include an <code>error</code>-typed value in its list of returns, which if not <code>nil</code> indicates an error state that may be handled via the primary execution path. For example, the <code>os.Open</code> function returns a non-<code>nil</code> error value when it fails to open a file:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">file</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="s">"somefile.ext"</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nx">err</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The actual implementation of the <code>error</code> type is actually incredibly simple: it’s just a universally visible interface that declares a single method:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="kt">error</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Error</code><code class="p">()</code> <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is very different from the exceptions that are used in many languages, which necessitate a dedicated system for exception catching and handling that can lead to confusing and unintuitive flow control.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Creating an Error"><div class="sect2" id="idm45983643419944">&#13;
<h2>Creating an Error</h2>&#13;
&#13;
<p>There are two simple ways to create error values, and a more complicated way. The simple ways are to use either the <code>errors.New</code> or <code>fmt.Errorf</code> functions; the latter is handy because it provides string formatting too:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">e1</code> <code class="o">:=</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"error 42"</code><code class="p">)</code>&#13;
<code class="nx">e2</code> <code class="o">:=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"error %d"</code><code class="p">,</code> <code class="mi">42</code><code class="p">)</code></pre>&#13;
&#13;
<p>However, the fact that <code>error</code> is an interface allows you to implement your own error types, if you need to. For example, a common pattern is to allow errors to be nested within other errors:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">NestedError</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Message</code> <code class="kt">string</code>&#13;
    <code class="nx">Err</code>     <code class="kt">error</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">e</code> <code class="o">*</code><code class="nx">NestedError</code><code class="p">)</code> <code class="nx">Error</code><code class="p">()</code> <code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%s\n  contains: %s"</code><code class="p">,</code> <code class="nx">e</code><code class="p">.</code><code class="nx">Message</code><code class="p">,</code> <code class="nx">e</code><code class="p">.</code><code class="nx">Err</code><code class="p">.</code><code class="nx">Error</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For more information about errors, and some good advice on error handling in Go, take a look at Andrew Gerrand’s “Error Handling and Go” on <a href="https://oreil.ly/YQ6if"><em>The Go Blog</em></a>.<a data-type="indexterm" data-primary="error handling" data-startref="ch03_term21" id="idm45983643297800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Putting the Fun in Functions: Variadics and Closures"><div class="sect1" id="idm45983643296760">&#13;
<h1>Putting the Fun in Functions: Variadics and Closures</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="functions" data-secondary="variadic functions" id="ch03_term22_2"/><a data-type="indexterm" data-primary="variadic functions" id="ch03_term22"/>Functions in Go work a lot like they do in other languages: they receive parameters, do some work, and (optionally) return something.</p>&#13;
&#13;
<p>But Go functions are built for a level of flexibility not found in many mainstream languages, and can also do a lot of things that many other languages can’t, such as returning or accepting multiple values, or being used as first-class types or anonymous functions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Functions"><div class="sect2" id="idm45983643292120">&#13;
<h2>Functions</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="functions" id="ch03_term23_2"/>Declaring a function in Go is similar to most other languages: they have a name, a list of typed parameters, an optional list of return types, and a body. However, Go function declaration differs somewhat from other C-family languages, in that it uses a dedicated <code>func</code> keyword; the type for each parameter follows its name; and return types are placed at the end of the function definition header and may be omitted entirely (there’s no <code>void</code> type).</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="return statement" id="idm45983643287544"/><a data-type="indexterm" data-primary="built-in functions" data-secondary="panic built-in function" id="idm45983643286840"/><a data-type="indexterm" data-primary="panic built-in function" id="idm45983643285896"/>A function with a return type list must end with a <code>return</code> statement, except when execution can’t reach the end of the function due to the presence of an infinite loop or a terminal <code>panic</code> before the function exits:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">add</code><code class="p">(</code><code class="nx">x</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">y</code> <code class="kt">int</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">sum</code> <code class="o">:=</code> <code class="nx">add</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code>        <code class="c1">// "15"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Additionally, a bit of syntactic sugar allows the type for a sequence of parameters or returns of the same type to be written only once. For example, the following definitions of <code>func foo</code> are equivalent:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">i</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">j</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">a</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">b</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kd">func</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code> <code class="nx">j</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="kt">string</code><code class="p">)</code>            <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Multiple return values"><div class="sect3" id="idm45983643213896">&#13;
<h3>Multiple return values</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="swap function" id="idm45983643141064"/><a data-type="indexterm" data-primary="multiple returns" id="idm45983643140360"/>Functions can return any number of values. For example, the following <code>swap</code> function accepts two strings, and returns two strings. The list of return types for multiple returns must be enclosed in parentheses:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">swap</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">x</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To accept multiple values from a function with multiple returns, you can use multiple assignment:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="o">:=</code> <code class="nx">swap</code><code class="p">(</code><code class="s">"foo"</code><code class="p">,</code> <code class="s">"bar"</code><code class="p">)</code></pre>&#13;
&#13;
<p>When run, the value of <code>a</code> will be “bar,” and <code>b</code> will be “foo.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Recursion"><div class="sect3" id="idm45983643068648">&#13;
<h3>Recursion</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="functions" data-secondary="recursive functions" id="idm45983643067448"/><a data-type="indexterm" data-primary="recursive functions" id="idm45983643066472"/>Go allows <em>recursive</em> function calls, in which functions call themselves. Used properly, recursion can be a very powerful tool that can be applied to many types of problems. The canonical example is the calculation of the factorial of a positive integer, the product of all positive integers less than or equal to <code>n</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">n</code> <code class="p">&lt;</code> <code class="mi">1</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="mi">1</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">factorial</code><code class="p">(</code><code class="mi">11</code><code class="p">))</code>      <code class="c1">// "39916800"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For any integer <code>n</code> greater than one, <code>factorial</code> will call itself with a parameter of &#13;
<span class="keep-together"><code>n - 1</code>.</span> This can add up very quickly!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Defer"><div class="sect3" id="idm45983642980296">&#13;
<h3>Defer</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="defer keyword" id="ch03_term24"/>Go’s <code>defer</code> keyword can be used to schedule the execution of a function call for immediately before the surrounding function returns, and is commonly used to guarantee that resources are released or otherwise cleaned up.</p>&#13;
&#13;
<p>For example, to defer printing the text “cruel world” to the end of a function call, we insert the <code>defer</code> keyword immediately before it:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">defer</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"cruel world"</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"goodbye"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When the previous snippet is run, it produces the following output, with the deferred output printed last:</p>&#13;
&#13;
<pre data-type="programlisting">goodbye&#13;
cruel world</pre>&#13;
&#13;
<p>For a less trivial example, we’ll create an empty file and attempt to write to it. A <code>closeFile</code> function is provided to close the file when we’re done with it. However, if we simply call it at the end of <code>main</code>, an error could result in <code>closeFile</code> never being called and the file being left in an open state. Therefore, we use a <code>defer</code> to ensure that the <code>closeFile</code> function is called before the function returns, however it returns:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">file</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Create</code><code class="p">(</code><code class="s">"/tmp/foo.txt"</code><code class="p">)</code>  <code class="c1">// Create an empty file</code>&#13;
    <code class="k">defer</code> <code class="nx">closeFile</code><code class="p">(</code><code class="nx">file</code><code class="p">)</code>                   <code class="c1">// Ensure closeFile(file) is called</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintln</code><code class="p">(</code><code class="nx">file</code><code class="p">,</code> <code class="s">"Your mother was a hamster"</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"File written to successfully"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">closeFile</code><code class="p">(</code><code class="nx">f</code> <code class="o">*</code><code class="nx">os</code><code class="p">.</code><code class="nx">File</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Error closing file:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">())</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"File closed successfully"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you run this code, you should get the following output:</p>&#13;
&#13;
<pre data-type="programlisting">File written to successfully&#13;
File closed successfully</pre>&#13;
&#13;
<p>If multiple defer calls are used in a function, each is pushed onto a stack. When the surrounding function returns, the deferred calls are executed in last-in-first-out order. For example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">defer</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"world"</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"cruel"</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"goodbye"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This function, when run, will output the following:</p>&#13;
&#13;
<pre data-type="programlisting">goodbye&#13;
cruel&#13;
world</pre>&#13;
&#13;
<p>Defers are a very useful feature for ensuring that resources are cleaned up. If you’re working with external resources, you’ll want to make liberal use of them.<a data-type="indexterm" data-primary="defer keyword" data-startref="ch03_term24" id="idm45983642775544"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Pointers as parameters"><div class="sect3" id="idm45983642979672">&#13;
<h3>Pointers as parameters</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="pointers" id="ch03_term25"/>Much of the power of pointers becomes evident when they’re combined with functions. Typically, function parameters are <em>passed</em> <em>by value</em>: when a function is called it receives a copy of each parameter, and changes made to the copy by the function don’t affect the caller. However, pointers contain a <em>reference</em> to a value, rather than the value itself, and can be used by a receiving function to indirectly modify the value passed to the function in a way that can affect the function caller.</p>&#13;
&#13;
<p>The follow function demonstrates both scenarios:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">x</code> <code class="o">:=</code> <code class="mi">5</code>&#13;
&#13;
    <code class="nx">zeroByValue</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>              <code class="c1">// "5"</code>&#13;
&#13;
    <code class="nx">zeroByReference</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>              <code class="c1">// "0"</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">zeroByValue</code><code class="p">(</code><code class="nx">x</code> <code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">x</code> <code class="p">=</code> <code class="mi">0</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">zeroByReference</code><code class="p">(</code><code class="nx">x</code> <code class="o">*</code><code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="o">*</code><code class="nx">x</code> <code class="p">=</code> <code class="mi">0</code>                      <code class="c1">// Dereference x and set it to 0</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="reference types" id="idm45983642676792"/>This behavior isn’t unique to pointers. In fact, under the hood, several data types are actually references to memory locations, including slices, maps, functions, and channels. Changes made to such <em>reference types</em> in a function can affect the caller, without needing to explicitly dereference them:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">update</code><code class="p">(</code><code class="nx">m</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">m</code><code class="p">[</code><code class="s">"c"</code><code class="p">]</code> <code class="p">=</code> <code class="mi">2</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">m</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code> <code class="s">"a"</code> <code class="p">:</code> <code class="mi">0</code><code class="p">,</code> <code class="s">"b"</code> <code class="p">:</code> <code class="mi">1</code><code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>                  <code class="c1">// "map[a:0 b:1]"</code>&#13;
&#13;
    <code class="nx">update</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>                  <code class="c1">// "map[a:0 b:1 c:2]"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the map <code>m</code> has a length of two when it’s passed to the <code>update</code> function, which adds the pair <code>{ "c" : 2 }</code>. Because <code>m</code> is a reference type, it’s passed to <code>update</code> as a reference to an underlying data structure instead of a copy of one, so the insertion is reflected in <code>m</code> in <code>main</code> after the <code>update</code> function returns.<a data-type="indexterm" data-primary="pointers" data-startref="ch03_term25" id="idm45983642552328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Variadic Functions"><div class="sect2" id="section_ch03_variadic_functions">&#13;
<h2>Variadic Functions</h2>&#13;
&#13;
<p>A <em>variadic function</em> is one that may be called with zero or more trailing arguments. The most familiar example is the members of the <code>fmt.Printf</code> family of functions, which accept a single format specifier string and an arbitrary number of additional arguments.</p>&#13;
&#13;
<p>This is the signature for the standard <code>fmt.Printf</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Printf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">a</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code> <code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="variadic operator" id="idm45983642464392"/>Note that it accepts a string, and zero or more <code>interface{}</code> values. If you’re rusty on the <code>interface{}</code> syntax, we’ll review it in <a data-type="xref" href="#section_ch03_interfaces">“Interfaces”</a>, but you can interpret <code>interface{}</code> to mean “some arbitrarily typed thing.” What’s most interesting here, however, is that the final argument contains an ellipsis (<code>...</code>). This is the <em>variadic operator</em>, which indicates that the function may be called with any number of arguments of this type. For example, you can call <code>fmt.Printf</code> with a format and two differently typed parameters:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">age</code> <code class="p">=</code> <code class="s">"Kim"</code><code class="p">,</code> <code class="mi">22</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%s is %d years old.\n"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">age</code><code class="p">)</code></pre>&#13;
&#13;
<p>Within the variadic function, the variadic argument is a slice of the argument type. In the following example, the variadic <code>factors</code> parameter of the <code>product</code> method is of type <code>[]int</code> and may be ranged over accordingly:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">product</code><code class="p">(</code><code class="nx">factors</code> <code class="o">...</code><code class="kt">int</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">p</code> <code class="o">:=</code> <code class="mi">1</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">n</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">factors</code> <code class="p">{</code>&#13;
        <code class="nx">p</code> <code class="o">*=</code> <code class="nx">n</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">p</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">product</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>   <code class="c1">// "8"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the call to <code>product</code> from <code>main</code> uses three parameters (though it could use any number of parameters it likes). In the <code>product</code> function, these are translated into an <code>[]int</code> slice with the value <code>{2, 2, 2}</code> that are iteratively multiplied to construct the final return value of <code>8</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Passing slices as variadic values"><div class="sect3" id="idm45983642377928">&#13;
<h3>Passing slices as variadic values</h3>&#13;
&#13;
<p>What if your value is already in slice form, and you still want to pass it to a variadic function? Do you need to split it into multiple individual parameters? Goodness no.</p>&#13;
&#13;
<p>In this case, you can apply the variadic operator after the variable name when calling the variadic function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="o">:=</code> <code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">}</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">product</code><code class="p">(</code><code class="nx">m</code><code class="o">...</code><code class="p">))</code>   <code class="c1">// "27"</code></pre>&#13;
&#13;
<p>Here, you have a variable <code>m</code> with the type <code>[]int</code>, which you want to pass to the variadic function <code>product</code>. Using the variadic operator when calling <code>product(m...)</code> makes this possible.<a data-type="indexterm" data-primary="functions" data-secondary="variadic functions" data-startref="ch03_term22_2" id="idm45983642362584"/><a data-type="indexterm" data-primary="variadic functions" data-startref="ch03_term22" id="idm45983642300728"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Anonymous Functions and Closures"><div class="sect2" id="section_ch03_anonymous_functions_and_closures">&#13;
<h2>Anonymous Functions and Closures</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="first-class values" id="idm45983642298072"/>In Go, functions are <em>first-class values</em> that can be operated upon in the same way as any other entity in the language: they have types, may be assigned to variables, and may even be passed to and returned by other functions.</p>&#13;
&#13;
<p>The zero value of a function type is <code>nil</code>; calling a <code>nil</code> function value will cause a panic:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="kt">int</code><code class="p">)</code> <code class="kt">int</code>     <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="p">}</code>&#13;
<code class="kd">func</code> <code class="nx">product</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="kt">int</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">f</code> <code class="kd">func</code><code class="p">(</code><code class="kt">int</code><code class="p">,</code> <code class="kt">int</code><code class="p">)</code> <code class="kt">int</code>    <code class="c1">// Function variables have types</code>&#13;
&#13;
    <code class="nx">f</code> <code class="p">=</code> <code class="nx">sum</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">))</code>        <code class="c1">// "8"</code>&#13;
&#13;
    <code class="nx">f</code> <code class="p">=</code> <code class="nx">product</code>                 <code class="c1">// Legal: product has same type as sum</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">))</code>        <code class="c1">// "15"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="functions" data-secondary="anonymous functions" id="idm45983642294072"/><a data-type="indexterm" data-primary="anonymous functions" id="idm45983642293224"/>Functions may be created within other functions as <em>anonymous functions</em>, which may be called, passed, or otherwise treated like any other functions. A particularly powerful feature of Go is that anonymous functions have access to the state of their parent, and retain that access <em>even after</em> the parent function has executed. This is, in fact, the definition of a <em>closure</em>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><a data-type="indexterm" data-primary="closure" id="idm45983642202280"/>A <em>closure</em> is a nested function that has access to the variables of its parent function, even after the parent has executed.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="indexterm" data-primary="incrementor function" id="idm45983642200488"/>Take, for example, the following <code>incrementor</code> function. This function has state, in the form of the variable <code>i</code>, and returns an anonymous function that increments that value before returning it. The returned function can be said to <em>close over</em> the variable <code>i</code>, making it a true (if trivial) closure:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">incrementer</code><code class="p">()</code> <code class="kd">func</code><code class="p">()</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code>&#13;
&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">()</code> <code class="kt">int</code> <code class="p">{</code>    <code class="c1">// Return an anonymous function</code>&#13;
        <code class="nx">i</code><code class="o">++</code>                <code class="c1">// "Closes over" parent function's i</code>&#13;
        <code class="k">return</code> <code class="nx">i</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When we call <code>incrementor</code>, it creates its own new, local value of <code>i</code>, and returns a &#13;
<span class="keep-together">new anonymous</span> function of type that will increment that value. Subsequent calls to &#13;
<span class="keep-together"><code>incrementor</code></span> will each receive their own copy of <code>i</code>. We can demonstrate that in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">increment</code> <code class="o">:=</code> <code class="nx">incrementer</code><code class="p">()</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">increment</code><code class="p">())</code>       <code class="c1">// "1"</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">increment</code><code class="p">())</code>       <code class="c1">// "2"</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">increment</code><code class="p">())</code>       <code class="c1">// "3"</code>&#13;
&#13;
    <code class="nx">newIncrement</code> <code class="o">:=</code> <code class="nx">incrementer</code><code class="p">()</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">newIncrement</code><code class="p">())</code>    <code class="c1">// "1"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the <code>incrementer</code> provides a new function <code>increment</code>; each call to <code>increment</code> increments its internal counter by one. When <code>incrementer</code> is called again, though, it creates and returns an entirely new function, with its own brand new counter. Neither of these functions can influence the other.<a data-type="indexterm" data-primary="Go" data-secondary="functions" data-startref="ch03_term23_2" id="idm45983642061480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Structs, Methods, and Interfaces"><div class="sect1" id="idm45983642299320">&#13;
<h1>Structs, Methods, and Interfaces</h1>&#13;
&#13;
<p>One of the biggest mental switches that people sometimes have to make when first coming to the Go language is that Go isn’t a traditional object-oriented language. Not really. Sure, Go has types with methods, which kind of look like objects, but they don’t have a prescribed inheritance hierarchy. Instead Go allows components to be assembled into a whole using <em>composition</em>.</p>&#13;
&#13;
<p>For example, where a more strictly object-oriented language might have a <code>Car</code> class that extends an abstract <code>Vehicle</code> class; perhaps it would implement <code>Wheels</code> and <code>Engine</code>. This sounds fine in theory, but these relationships can grow to become convoluted and hard to manage.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="composition approach" id="ch03_term26"/>Go’s composition approach, on the other hand, allows components to be “put together” without having to define their ontological relationships. Extending the previous example, Go could have a <code>Car</code> struct, which could be have its various parts, such as <code>Wheels</code> and <code>Engine</code>, embedded within it. Furthermore, methods in Go can be defined for any sort of data; they’re not just for structs anymore.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Structs"><div class="sect2" id="idm45983642052392">&#13;
<h2>Structs</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="structs" id="ch03_term27_2"/><a data-type="indexterm" data-primary="structs" id="ch03_term27"/>In Go, a <em>struct</em> is nothing more than an aggregation of zero or more fields as a single entity, where each field is a named value of an arbitrary type. A struct can be defined using the following <code>type Name struct</code> syntax. A struct is never <code>nil</code>: rather, the zero value of a struct is the zero value of all of its fields:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Vertex</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code> <code class="kt">float64</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">v</code> <code class="nx">Vertex</code>            <code class="c1">// Structs are never nil</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>          <code class="c1">// "{0 0}"</code>&#13;
&#13;
    <code class="nx">v</code> <code class="p">=</code> <code class="nx">Vertex</code><code class="p">{}</code>            <code class="c1">// Explicitly define an empty struct</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>          <code class="c1">// "{0 0}"</code>&#13;
&#13;
    <code class="nx">v</code> <code class="p">=</code> <code class="nx">Vertex</code><code class="p">{</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">2.0</code><code class="p">}</code>    <code class="c1">// Defining fields, in order</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>          <code class="c1">// "{1 2}"</code>&#13;
&#13;
    <code class="nx">v</code> <code class="p">=</code> <code class="nx">Vertex</code><code class="p">{</code><code class="nx">Y</code><code class="p">:</code><code class="mf">2.5</code><code class="p">}</code>       <code class="c1">// Defining specific fields, by label</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>          <code class="c1">// "{0 2.5}"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Struct fields can be accessed using the standard dot notation:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">v</code> <code class="o">:=</code> <code class="nx">Vertex</code><code class="p">{</code><code class="nx">X</code><code class="p">:</code> <code class="mf">1.0</code><code class="p">,</code> <code class="nx">Y</code><code class="p">:</code> <code class="mf">3.0</code><code class="p">}</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>                  <code class="c1">// "{1 3}"</code>&#13;
&#13;
    <code class="nx">v</code><code class="p">.</code><code class="nx">X</code> <code class="o">*=</code> <code class="mf">1.5</code>&#13;
    <code class="nx">v</code><code class="p">.</code><code class="nx">Y</code> <code class="o">*=</code> <code class="mf">2.5</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>                  <code class="c1">// "{1.5 7.5}"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Structs are commonly created and manipulated by reference, so Go provides a little bit of syntactic sugar: members of structs can be accessed from a pointer to the struct using dot notation; the pointers are automatically dereferenced:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">v</code> <code class="o">*</code><code class="nx">Vertex</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">Vertex</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code> <code class="mi">3</code><code class="p">}</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>                  <code class="c1">// &amp;{1 3}</code>&#13;
&#13;
    <code class="nx">v</code><code class="p">.</code><code class="nx">X</code><code class="p">,</code> <code class="nx">v</code><code class="p">.</code><code class="nx">Y</code> <code class="p">=</code> <code class="nx">v</code><code class="p">.</code><code class="nx">Y</code><code class="p">,</code> <code class="nx">v</code><code class="p">.</code><code class="nx">X</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>                  <code class="c1">// &amp;{3 1}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, <code>v</code> is a pointer to a <code>Vertex</code> whose <code>X</code> and <code>Y</code> member values you want to swap. If you had to dereference the pointer to do this, you’d have to do something like <code>(*v).X, (*v).Y = (*v).Y, (*v).X</code>, which is clearly terrible. Instead, automatic pointer dereferencing lets you do <code>v.X, v.Y = v.Y, v.X</code>, which is far less terrible.<a data-type="indexterm" data-primary="types" data-secondary="structs" data-startref="ch03_term27_2" id="idm45983641782296"/><a data-type="indexterm" data-primary="structs" data-startref="ch03_term27" id="idm45983641781048"/><a data-type="indexterm" data-primary="dereferencing" id="idm45983641780104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Methods"><div class="sect2" id="section_ch03_methods">&#13;
<h2>Methods</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="methods" id="ch03_term28"/><a data-type="indexterm" data-primary="receiver argument" id="idm45983641776776"/>In Go, <em>methods</em> are functions that are attached to types, including but not limited to structs. The declaration syntax for a method is very similar to that of a function, except that it includes an extra <em>receiver argument</em> before the function name that specifies the type that the method is attached to. When the method is called, the instance is accessible by the name specified in the receiver.</p>&#13;
&#13;
<p>For example, our earlier <code>Vertex</code> type can be extended by attaching a <code>Square</code> method with a receiver named <code>v</code> of type <code>*Vertex</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go" class="pagebreak-before less_space"><code class="kd">func</code> <code class="p">(</code><code class="nx">v</code> <code class="o">*</code><code class="nx">Vertex</code><code class="p">)</code> <code class="nx">Square</code><code class="p">()</code> <code class="p">{</code>    <code class="c1">// Attach method to the *Vertex type</code>&#13;
    <code class="nx">v</code><code class="p">.</code><code class="nx">X</code> <code class="o">*=</code> <code class="nx">v</code><code class="p">.</code><code class="nx">X</code>&#13;
    <code class="nx">v</code><code class="p">.</code><code class="nx">Y</code> <code class="o">*=</code> <code class="nx">v</code><code class="p">.</code><code class="nx">Y</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">vert</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">Vertex</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">}</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">vert</code><code class="p">)</code>          <code class="c1">// "&amp;{3 4}"</code>&#13;
&#13;
    <code class="nx">vert</code><code class="p">.</code><code class="nx">Square</code><code class="p">()</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">vert</code><code class="p">)</code>          <code class="c1">// "&amp;{9 16}"</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><a data-type="indexterm" data-primary="receivers" id="idm45983641770360"/>Receivers are type specific: methods attached to a pointer type can only be called on a pointer to that type.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="extending standard composite types" id="idm45983641684152"/><a data-type="indexterm" data-primary="extending standard composite types" id="idm45983641683240"/>In addition to structs, you can also claim standard composite types—structs, slices, or maps—as your own, and attach methods to them. For example, we declare a new type, <code>MyMap</code>, which is just a standard <code>map[string]int</code>, and attach a <code>Length</code> method &#13;
<span class="keep-together">to it:</span></p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">MyMap</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">MyMap</code><code class="p">)</code> <code class="nx">Length</code><code class="p">()</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nb">len</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">mm</code> <code class="o">:=</code> <code class="nx">MyMap</code><code class="p">{</code><code class="s">"A"</code><code class="p">:</code><code class="mi">1</code><code class="p">,</code> <code class="s">"B"</code><code class="p">:</code> <code class="mi">2</code><code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">mm</code><code class="p">)</code>             <code class="c1">// "map[A:1 B:2]"</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">mm</code><code class="p">[</code><code class="s">"A"</code><code class="p">])</code>        <code class="c1">// "1"</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">mm</code><code class="p">.</code><code class="nx">Length</code><code class="p">())</code>    <code class="c1">// "2"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The result is a new type, <code>MyMap</code>, which is (and can be used as) a map of strings to integers, <code>map[string]int</code>, but which also has a <code>Length</code> method that returns the map’s length.<a data-type="indexterm" data-primary="methods" data-startref="ch03_term28" id="idm45983641570344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Interfaces"><div class="sect2" id="section_ch03_interfaces">&#13;
<h2>Interfaces</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="interfaces" id="ch03_term29_2"/><a data-type="indexterm" data-primary="interfaces" id="ch03_term29"/>In Go, an <em>interface</em> is just a set of method signatures. As in other languages with a concept of an interface, they are used to describe the general behaviors of other types without being coupled to implementation details. An interface can thus be viewed &#13;
<span class="keep-together">as a <em>contract</em></span> that a type may satisfy, opening the door to powerful abstraction &#13;
<span class="keep-together">techniques</span>.</p>&#13;
&#13;
<p>For example, a <code>Shape</code> interface can be defined that includes an <code>Area</code> method signature. Any type that wants to be a <code>Shape</code> must have an <code>Area</code> method that returns a <code>float64</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Shape</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Area</code><code class="p">()</code> <code class="kt">float64</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we’ll define two shapes, <code>Circle</code> and <code>Rectangle</code>, that satisfy the <code>Shape</code> interface by attaching an <code>Area</code> method to each one. Note that we don’t have to explicitly declare that they satisfy the interface: if a type possesses all of its methods, it can <em>implicitly satisfy</em> an interface. This is particularly useful when you want to design interfaces that are satisfied by types that you don’t own or control:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Circle</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Radius</code> <code class="kt">float64</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">c</code> <code class="nx">Circle</code><code class="p">)</code> <code class="nx">Area</code><code class="p">()</code> <code class="kt">float64</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">math</code><code class="p">.</code><code class="nx">Pi</code> <code class="o">*</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Radius</code> <code class="o">*</code> <code class="nx">c</code><code class="p">.</code><code class="nx">Radius</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">Rectangle</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Width</code><code class="p">,</code> <code class="nx">Height</code> <code class="kt">float64</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">r</code> <code class="nx">Rectangle</code><code class="p">)</code> <code class="nx">Area</code><code class="p">()</code> <code class="kt">float64</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">r</code><code class="p">.</code><code class="nx">Width</code> <code class="o">*</code> <code class="nx">r</code><code class="p">.</code><code class="nx">Height</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because both <code>Circle</code> and <code>Rectangle</code> implicitly satisfy the <code>Shape</code> interface, we can pass them to any function that expects a <code>Shape</code>:<a data-type="indexterm" data-primary="types" data-secondary="interfaces" data-startref="ch03_term29_2" id="idm45983641422808"/><a data-type="indexterm" data-primary="interfaces" data-startref="ch03_term29" id="idm45983641421528"/></p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">PrintArea</code><code class="p">(</code><code class="nx">s</code> <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%T's area is %0.2f\n"</code><code class="p">,</code> <code class="nx">s</code><code class="p">,</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Area</code><code class="p">())</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">r</code> <code class="o">:=</code> <code class="nx">Rectangle</code><code class="p">{</code><code class="nx">Width</code><code class="p">:</code><code class="mi">5</code><code class="p">,</code> <code class="nx">Height</code><code class="p">:</code><code class="mi">10</code><code class="p">}</code>&#13;
    <code class="nx">PrintArea</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>                         <code class="c1">// "main.Rectangle's area is 50.00"</code>&#13;
&#13;
    <code class="nx">c</code> <code class="o">:=</code> <code class="nx">Circle</code><code class="p">{</code><code class="nx">Radius</code><code class="p">:</code><code class="mi">5</code><code class="p">}</code>&#13;
    <code class="nx">PrintArea</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code>                         <code class="c1">// "main.Circle's area is 78.54"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Type assertions"><div class="sect3" id="idm45983641400376">&#13;
<h3>Type assertions</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="type assertion" id="idm45983641349784"/>A <em>type assertion</em> can be applied to an interface value to “assert” its identity as a concrete type. The syntax takes the general form of <code>x.(T)</code>, where <code>x</code> is an expression of an interface, and <code>T</code> is the asserted type.</p>&#13;
&#13;
<p>Referring to the <code>Shape</code> interface and <code>Circle</code> struct we used previously:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">s</code> <code class="nx">Shape</code>&#13;
<code class="nx">s</code> <code class="p">=</code> <code class="nx">Circle</code><code class="p">{}</code>                <code class="c1">// s is an expression of Shape</code>&#13;
<code class="nx">c</code> <code class="o">:=</code> <code class="nx">s</code><code class="p">.(</code><code class="nx">Circle</code><code class="p">)</code>             <code class="c1">// Assert that s is a Circle</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%T\n"</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code>       <code class="c1">// "main.Circle"</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The empty interface"><div class="sect3" id="idm45983641261272">&#13;
<h3>The empty interface</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="empty interface" id="idm45983641254712"/>One curious construct is the <em>empty interface</em>: <code>interface{}</code>. The empty interface specifies no methods. It carries no information; it says nothing.<sup><a data-type="noteref" id="idm45983641253048-marker" href="ch03.xhtml#idm45983641253048">7</a></sup></p>&#13;
&#13;
<p>A variable of type <code>interface{}</code> can hold values of any type, which can be very useful when your code needs to handle values of any type. The <code>fmt.Println</code> method is a good example of a function using this strategy.</p>&#13;
&#13;
<p>There are downsides, however. Working with the empty interface requires certain assumptions to be made, which have to be checked at runtime and result in code that’s more fragile and less efficient.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Composition with Type Embedding"><div class="sect2" id="idm45983641568680">&#13;
<h2>Composition with Type Embedding</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="type embedding" data-seealso="interface embedding, struct embedding" id="ch03_term30"/>Go doesn’t allow subclassing or inheritance in the traditional object-oriented sense. Instead it allows types to be <em>embedded</em> within one another, extending the functionalities of the embedded types into the embedding type.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="composition" id="idm45983641319992"/>This is a particularly useful feature of Go that allows functionalities to be reused via <em>composition</em>—combining the features of existing types to create new types—instead of inheritance, removing the need for the kinds of elaborate type hierarchies that can saddle traditional object-oriented programming projects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Interface embedding"><div class="sect3" id="idm45983641318296">&#13;
<h3>Interface embedding</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="interface embedding" id="ch03_term31"/>A popular example of embedding interfaces comes to us by way of the <code>io</code> package. Specifically, the widely used <code>io.Reader</code> and <code>io.Writer</code> interfaces, which are defined as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Reader</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Read</code><code class="p">(</code><code class="nx">p</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">)</code> <code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">Writer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Write</code><code class="p">(</code><code class="nx">p</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">)</code> <code class="p">(</code><code class="nx">n</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But what if you want an interface with the methods of both an <code>io.Reader</code> and <code>io.Writer</code>? Well, you <em>could</em> implement a third interface that copies the methods of both, but then you have to keep all of them in agreement. That doesn’t just add unnecessary maintenance overhead: it’s also a good way to accidentally introduce errors.</p>&#13;
&#13;
<p>Rather than go the copy–paste route, Go allows you to embed the two existing interfaces into a third one that takes on the features of both. Syntactically, this is done by adding the embedded interfaces as anonymous fields, as demonstrated by the standard <code>io.ReadWriter</code> interface, shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">ReadWriter</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Reader</code>&#13;
    <code class="nx">Writer</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The result of this composition is a new interface that has all of the methods of the interfaces embedded within it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Only interfaces can be embedded within interfaces.<a data-type="indexterm" data-primary="interface embedding" data-startref="ch03_term31" id="idm45983641195976"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Struct embedding"><div class="sect3" id="idm45983641193912">&#13;
<h3>Struct embedding</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="struct embedding" id="idm45983641192504"/>Embedding isn’t limited to interfaces: structs can also be embedded into other structs.</p>&#13;
&#13;
<p>The struct equivalent to the <code>io.Reader</code> and <code>io.Writer</code> example in the previous section comes from the <code>bufio</code> package. Specifically, <code>bufio.Reader</code> (which implements <code>io.Reader</code>) and <code>bufio.Writer</code> (which implements <code>io.Writer</code>). Similarly, <code>bufio</code> also provides an implementation of <code>io.ReadWriter</code>, which is just a composition of the existing <code>bufio.Reader</code> and <code>bufio.Writer</code> types:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">ReadWriter</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">*</code><code class="nx">Reader</code>&#13;
    <code class="o">*</code><code class="nx">Writer</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the syntax for embedding structs is identical to that of interfaces: adding the embedded types as unnamed fields. In the preceding case, the &#13;
<span class="keep-together"><code>bufio.ReadWriter</code></span> embeds <code>bufio.Reader</code> and <code>bufio.Writer</code> as pointer types.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Just like any pointers, embedded pointers to structs have a zero value of <code>nil</code>, and must be initialized to point to valid structs before they can be used.<a data-type="indexterm" data-primary="type embedding" data-startref="ch03_term30" id="idm45983641180808"/><a data-type="indexterm" data-primary="types" data-secondary="embedded pointers" id="idm45983641179832"/><a data-type="indexterm" data-primary="embedded pointers" id="idm45983641178888"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Promotion"><div class="sect3" id="idm45983641112680">&#13;
<h3>Promotion</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="promotion" id="idm45983641111624"/>So, why would you use composition instead of just adding a struct field? The answer is that when a type is embedded, its exported properties and methods are <em>promoted</em> &#13;
<span class="keep-together">to the</span> embedding type, allowing them to be directly invoked. For example, the &#13;
<span class="keep-together"><code>Read</code> method</span> of a <code>bufio.Reader</code> is accessible directly from an instance of &#13;
<span class="keep-together"><code>bufio.ReadWriter</code></span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">rw</code> <code class="o">*</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">ReadWriter</code> <code class="p">=</code> <code class="nx">GetReadWriter</code><code class="p">()</code>&#13;
<code class="kd">var</code> <code class="nx">bytes</code> <code class="p">[]</code><code class="kt">byte</code> <code class="p">=</code> <code class="nb">make</code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code> <code class="mi">1024</code><code class="p">)</code>&#13;
&#13;
<code class="nx">n</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rw</code><code class="p">.</code><code class="nx">Read</code><code class="p">(</code><code class="nx">bytes</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Do something</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You don’t have to know or care that the <code>Read</code> method is actually attached to the embedded <code>*bufio.Reader</code>. It’s important to know, though, that when a promoted method is invoked the method’s receiver is still the embedded type, so the receiver of <code>rw.Read</code> is the <code>ReadWriter</code>’s <code>Reader</code> field, not the <code>ReadWriter</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Directly accessing embedded fields"><div class="sect3" id="idm45983641054120">&#13;
<h3>Directly accessing embedded fields</h3>&#13;
&#13;
<p>Occasionally, you’ll need to refer to an embedded field directly. To do this, you use the type name of the field as a field name. In the following (somewhat contrived) example, the <code>UseReader</code> function requires a <code>*bufio.Reader</code>, but what you have is a <code>*bufio.ReadWriter</code> instance:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">UseReader</code><code class="p">(</code><code class="nx">r</code> <code class="o">*</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"We got a %T\n"</code><code class="p">,</code> <code class="nx">r</code><code class="p">)</code>      <code class="c1">// "We got a *bufio.Reader"</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">rw</code> <code class="o">*</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">ReadWriter</code> <code class="p">=</code> <code class="nx">GetReadWriter</code><code class="p">()</code>&#13;
    <code class="nx">UseReader</code><code class="p">(</code><code class="nx">rw</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, this snippet uses the type name of the field you want to access (<code>Reader</code>) as the field name (<code>rw.Reader</code>) to retrieve the <code>*bufio.Reader</code> from <code>rw</code>. This can be handy for initialization as well:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">rw</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">ReadWriter</code><code class="p">{</code><code class="nx">Reader</code><code class="p">:</code> <code class="o">&amp;</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">Reader</code><code class="p">{},</code> <code class="nx">Writer</code><code class="p">:</code> <code class="o">&amp;</code><code class="nx">bufio</code><code class="p">.</code><code class="nx">Writer</code><code class="p">{}}</code></pre>&#13;
&#13;
<p>If we’d just created <code>rw</code> as <code>&amp;bufio.ReadWriter{}</code>, its embedded fields would be <code>nil</code>, but the snippet produces a <code>*bufio.ReadWriter</code> with fully defined <code>*bufio.Reader</code> and <code>*bufio.Writer</code> fields. While you wouldn’t typically do this with a <code>&amp;bufio.ReadWriter</code>, this approach could be used to provide a useful mock in a pinch.<a data-type="indexterm" data-primary="Go" data-secondary="composition approach" data-startref="ch03_term26" id="idm45983640950968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="The Good Stuff: Concurrency"><div class="sect1" id="section_ch03_concurrency">&#13;
<h1>The Good Stuff: Concurrency</h1>&#13;
&#13;
<p>The intricacies of concurrent programming are many, and are well beyond the scope of this work. However, you can say that reasoning about concurrency is hard, and that the way concurrency is generally done makes it harder. In most languages, the usual approach to processes orchestration is to create some shared bit of memory, which is then wrapped in locks to restrict access to one process at a time, often introducing maddeningly difficult-to-debug errors such as race conditions or deadlocks.</p>&#13;
&#13;
<p>Go, on the other hand, favors another strategy: it provides two concurrency primitives—goroutines and channels—that can be used together to elegantly structure concurrent software, that don’t depend quite so much on locking. It encourages developers to limit sharing memory, and to instead allow processes to interact with one other entirely by passing messages.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Goroutines"><div class="sect2" id="section_ch03_goroutines">&#13;
<h2>Goroutines</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="features of" id="idm45983640944824"/><a data-type="indexterm" data-primary="go keyword" id="idm45983640943848"/><a data-type="indexterm" data-primary="goroutine" id="idm45983640943176"/>One of Go’s most powerful features is the <code>go</code> keyword. Any function call prepended with the <code>go</code> keyword will run as usual, but the caller can proceed uninterrupted rather than wait for the function to return. Under the hood, the function is executed as a lightweight, concurrently executing process called a <em>goroutine</em>.</p>&#13;
&#13;
<p>The syntax is strikingly simple: a function <code>foo</code>, which may be executed sequentially as <code>foo()</code>, may be executed as a concurrent goroutine simply by adding the <code>go</code> keyword: <code>go foo()</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">foo</code><code class="p">()</code>       <code class="c1">// Call foo() and wait for it to return</code>&#13;
<code class="k">go</code> <code class="nx">foo</code><code class="p">()</code>    <code class="c1">// Spawn a new goroutine that calls foo() concurrently</code></pre>&#13;
&#13;
<p>Goroutines can also be used to invoke a function literal:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Log</code><code class="p">(</code><code class="nx">w</code> <code class="nx">io</code><code class="p">.</code><code class="nx">Writer</code><code class="p">,</code> <code class="nx">message</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintln</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="nx">message</code><code class="p">)</code>&#13;
    <code class="p">}()</code> <code class="c1">// Don't forget the trailing parentheses!</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Channels"><div class="sect2" id="section_ch03_channels">&#13;
<h2>Channels</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="channels" id="ch03_term32"/>In Go, <em>channels</em> are typed primitives that allow communication between two &#13;
<span class="keep-together">goroutines</span>. They act as pipes into which a value can be sent and then received by a &#13;
<span class="keep-together">goroutine</span> on the other end.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="make function" id="idm45983640814200"/><a data-type="indexterm" data-primary="element type" id="idm45983640813272"/><a data-type="indexterm" data-primary="chan keyword" id="idm45983640812600"/>Channels may be created using the <code>make</code> function. Each channel can transmit values of a specific type, called its <em>element type</em>. Channel types are written using the <code>chan</code> keyword followed by their element type.&#13;
The following example declares and allocates an <code>int</code> channel:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">ch</code> <code class="kd">chan</code> <code class="kt">int</code> <code class="p">=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code></pre>&#13;
&#13;
<p>The two primary operations supported by channels are <em>send</em> and <em>receive</em>, both of which use the <code>&lt;-</code> operator, where the arrow indicates the direction of the data flow as demonstrated in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code> <code class="o">&lt;-</code> <code class="nx">val</code>     <code class="c1">// Sending on a channel</code>&#13;
<code class="nx">val</code> <code class="p">=</code> <code class="o">&lt;-</code><code class="nx">ch</code>    <code class="c1">// Receiving on a channel and assigning it to val</code>&#13;
<code class="o">&lt;-</code><code class="nx">ch</code>          <code class="c1">// Receiving on a channel and discarding the result</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Channel blocking"><div class="sect3" id="idm45983640768376">&#13;
<h3>Channel blocking</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="channels" data-secondary="unbuffered" id="idm45983640776040"/><a data-type="indexterm" data-primary="goroutine" id="idm45983640775064"/>By default, a channel is <em>unbuffered</em>. Unbuffered channels have a very useful property: sends on them block until another goroutine receives on the channel, and receives block until another goroutine sends on the channel. This behavior can be exploited to synchronize two goroutines, as demonstrated in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">)</code>    <code class="c1">// Allocate a string channel</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
       <code class="nx">message</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">ch</code>         <code class="c1">// Blocking receive; assigns to message</code>&#13;
       <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code>    <code class="c1">// "ping"</code>&#13;
       <code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"pong"</code>            <code class="c1">// Blocking send</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"ping"</code>               <code class="c1">// Send "ping"</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">)</code>          <code class="c1">// "pong"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Although <code>main</code> and the anonymous <code>goroutine</code> run concurrently and could in theory run in any order, the blocking behavior of unbuffered channels guarantees that the output will always be “ping” followed by “pong.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Channel buffering"><div class="sect3" id="section_ch03_channel_buffering">&#13;
<h3>Channel buffering</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="channels" data-secondary="buffered" id="idm45983640649784"/>Go channels may be <em>buffered</em>, in which case they contain an internal value queue with a fixed <em>capacity</em> that’s specified when the buffer is initialized. Sends to a buffered channel only block when the buffer is full; receives from a channel only block when the buffer is empty. Any other time, send and receive operations write to or read from the buffer, respectively, and exit immediately.</p>&#13;
&#13;
<p class="pagebreak-before less_space">A buffered channel can be created by providing a second argument to the <code>make</code> function to indicate its capacity:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>    <code class="c1">// Buffered channel with capacity 2</code>&#13;
&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"foo"</code>                   <code class="c1">// Two non-blocking sends</code>&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"bar"</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">)</code>             <code class="c1">// Two non-blocking receives</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">)</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">)</code>             <code class="c1">// The third receive will block</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Closing channels"><div class="sect3" id="idm45983640613368">&#13;
<h3>Closing channels</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="built-in functions" data-secondary="close built-in function" id="idm45983640619032"/><a data-type="indexterm" data-primary="close built-in function" id="idm45983640618056"/><a data-type="indexterm" data-primary="channels" data-secondary="close operation" id="idm45983640617384"/>The third available channel operation is <em>close</em>, which sets a flag to indicate that no more values will be sent on it. The built-in <code>close</code> function can be used to close a channel: <code>close(ch)</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The channel close operation is just a flag to tell the receiver not to expect any more values. You don’t <em>have to</em> explicitly close channels.</p>&#13;
</div>&#13;
&#13;
<p>Trying to send on a closed channel will cause a <code>panic</code>. Receiving from a closed channel will retrieve any values sent on the channel prior to its closure; any subsequent receive operations will immediately yield the zero value of the channel’s element type. Receivers may also test whether a channel has been closed (and its buffer is empty) by assigning a second <code>bool</code> parameter to the receive expression:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code>&#13;
&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"foo"</code>&#13;
&#13;
<code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code>                          <code class="c1">// One value left in the buffer</code>&#13;
&#13;
<code class="nx">msg</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">ch</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q, %v\n"</code><code class="p">,</code> <code class="nx">msg</code><code class="p">,</code> <code class="nx">ok</code><code class="p">)</code>    <code class="c1">// "foo", true</code>&#13;
&#13;
<code class="nx">msg</code><code class="p">,</code> <code class="nx">ok</code> <code class="p">=</code> <code class="o">&lt;-</code><code class="nx">ch</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q, %v\n"</code><code class="p">,</code> <code class="nx">msg</code><code class="p">,</code> <code class="nx">ok</code><code class="p">)</code>    <code class="c1">// "", false</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>While either party may close a channel, in practice only the sender should do so. Inadvertently sending on a closed channel will cause a panic.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Looping over channels"><div class="sect3" id="idm45983640492024">&#13;
<h3>Looping over channels</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="channels" data-secondary="looping" id="idm45983640490680"/><a data-type="indexterm" data-primary="range keyword" id="idm45983640489704"/>The <code>range</code> keyword may be used to loop over channels that are open or contain &#13;
<span class="keep-together">buffered</span> values. The loop will block until a value is available to be read or until the &#13;
<span class="keep-together">channel</span> is closed. You can see how this works in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>&#13;
&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"foo"</code>                 <code class="c1">// Send three (buffered) values to the channel</code>&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"bar"</code>&#13;
<code class="nx">ch</code> <code class="o">&lt;-</code> <code class="s">"baz"</code>&#13;
&#13;
<code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code>                   <code class="c1">// Close the channel</code>&#13;
&#13;
<code class="k">for</code> <code class="nx">s</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">ch</code> <code class="p">{</code>         <code class="c1">// Range will continue to the "closed" flag</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="channels" data-secondary="buffered" id="idm45983640485880"/>In this example, the buffered channel <code>ch</code> is created, and three values are sent before being closed. Because the three values were sent to the channel before it was closed, looping over this channel will output all three lines before terminating.</p>&#13;
&#13;
<p>Had the channel not been closed, the loop would stop and wait for the next value to be sent along the channel, potentially indefinitely.<a data-type="indexterm" data-primary="Go" data-secondary="channels" data-startref="ch03_term32" id="idm45983640411160"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Select"><div class="sect2" id="idm45983640818728">&#13;
<h2>Select</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="select statements" id="ch03_term34"/><a data-type="indexterm" data-primary="switch Statement" id="idm45983640407032"/>Go’s <code>select</code> statements are a little like <code>switch</code> statements that provide a convenient mechanism for multiplexing communications with multiple channels. The syntax for <code>select</code> is very similar to <code>switch</code>, with some number of <code>case</code> statements that specify code to be executed upon a successful send or receive operation:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">select</code> <code class="p">{</code>&#13;
<code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ch1</code><code class="p">:</code>                         <code class="c1">// Discard received value</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Got something"</code><code class="p">)</code>&#13;
&#13;
<code class="k">case</code> <code class="nx">x</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">ch2</code><code class="p">:</code>                    <code class="c1">// Assign received value to x</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>&#13;
&#13;
<code class="k">case</code> <code class="nx">ch3</code> <code class="o">&lt;-</code> <code class="nx">y</code><code class="p">:</code>                      <code class="c1">// Send y to channel</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code>&#13;
&#13;
<code class="k">default</code><code class="p">:</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"None of the above"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding snippet, there are three primary cases specified with three different conditions. If the channel <code>ch1</code> is ready to be read, then its value will be read (and discarded) and the text “Got something” will be printed. If <code>ch2</code> is ready to be read, then its value will be read and assigned to the variable <code>x</code> before printing the value of <code>x</code>. Finally, if <code>ch3</code> is ready to be sent to, then the value <code>y</code> is sent to it before printing the value of <code>y</code>.</p>&#13;
&#13;
<p>Finally, if no cases are ready, the <code>default</code> statements will be executed. If there’s no <code>default</code>, then the <code>select</code> will block until one of its cases is ready, at which point it performs the associated communication and executes the associated statements. If multiple cases are ready, <code>select</code> will execute one at random.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Gotcha!</h1>&#13;
<p>When using <code>select</code>, keep in mind that a closed channel never blocks and is always readable.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementing channel timeouts"><div class="sect3" id="section_ch03_implementing_channel_timeouts">&#13;
<h3>Implementing channel timeouts</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="channels" data-secondary="timeouts" id="idm45983640322408"/>The ability to use <code>select</code> to multiplex on channels can be very powerful, and can make otherwise very difficult or tedious tasks trivial. Take, for example, the implementation of a timeout on an arbitrary channel. In some languages this might require some awkward thread work, but a <code>select</code> with a call to <code>time.After</code>, which returns a channel that sends a message after a specified duration, makes short work of it:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">ch</code> <code class="kd">chan</code> <code class="kt">int</code>&#13;
&#13;
<code class="k">select</code> <code class="p">{</code>&#13;
<code class="k">case</code> <code class="nx">m</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code>                        <code class="c1">// Read from ch; blocks forever</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>&#13;
&#13;
<code class="k">case</code> <code class="o">&lt;-</code><code class="nx">time</code><code class="p">.</code><code class="nx">After</code><code class="p">(</code><code class="mi">10</code> <code class="o">*</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">):</code>   <code class="c1">// time.After returns a channel</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Timed out"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since there’s no <code>default</code> statement, this <code>select</code> will block until one if its case conditions becomes true. If <code>ch</code> doesn’t become available to read before the channel returned by <code>time.After</code> emits a message, then the second case will activate and the statement will time out.<a data-type="indexterm" data-primary="Go" data-secondary="select statements" data-startref="ch03_term34" id="idm45983640291800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983640290424">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>What I covered in this chapter could easily have consumed an entire book, if I’d been able to drill down into the level of detail the subject really deserves. But space and time are limited (and that book’s already been written<sup><a data-type="noteref" id="idm45983640288648-marker" href="ch03.xhtml#idm45983640288648">8</a></sup>) so I have to remain content to have only this one chapter as a broad and shallow survey of the Go language (at least until the second edition comes out).</p>&#13;
&#13;
<p>But learning Go’s syntax and grammar will only get you so far. In <a data-type="xref" href="ch04.xhtml#chapter_4">Chapter 4</a> I’ll be presenting a variety of Go programming patterns that I see come up pretty regularly in the “cloud native” context. So, if you thought this chapter was interesting, you’re going to love the next one.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983647379672"><sup><a href="ch03.xhtml#idm45983647379672-marker">1</a></sup> Perlis, Alan. <em>ACM SIGPLAN Notices</em> 17(9), September 1982, pp. 7–13.</p><p data-type="footnote" id="idm45983647325000"><sup><a href="ch03.xhtml#idm45983647325000-marker">2</a></sup> Earlier versions of C, C++, and Python lacked a native Boolean type, instead representing them using the integers <code>0</code> (for <code>false</code>) or <code>1</code> (for <code>true</code>). Some languages like Perl, Lua, and Tcl still use a similar strategy.</p><p data-type="footnote" id="idm45983647252184"><sup><a href="ch03.xhtml#idm45983647252184-marker">3</a></sup> See what I did there?</p><p data-type="footnote" id="idm45983646893816"><sup><a href="ch03.xhtml#idm45983646893816-marker">4</a></sup> Why would you?</p><p data-type="footnote" id="idm45983644570440"><sup><a href="ch03.xhtml#idm45983644570440-marker">5</a></sup> In fact, the freezing point of water on the Newton scale actually is 0.0, but that’s not important.</p><p data-type="footnote" id="idm45983643598696"><sup><a href="ch03.xhtml#idm45983643598696-marker">6</a></sup> Clearly this code needs to be recalibrated.</p><p data-type="footnote" id="idm45983641253048"><sup><a href="ch03.xhtml#idm45983641253048-marker">7</a></sup> Pike, Rob. “Go Proverbs.” YouTube. 1 Dec. 2015. <a href="https://oreil.ly/g8Rid"><em class="hyperlink">https://oreil.ly/g8Rid</em></a>.</p><p data-type="footnote" id="idm45983640288648"><sup><a href="ch03.xhtml#idm45983640288648-marker">8</a></sup> One last time, if you haven’t read it yet, go read <em>The Go Programming Language</em> by Donovan and Kernighan (Addison-Wesley Professional).</p></div></div></section></div></body></html>