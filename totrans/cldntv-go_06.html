<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Cloud Native Patterns"><div class="chapter" id="chapter_4">&#13;
<h1><span class="label">Chapter 4. </span>Cloud Native Patterns</h1>&#13;
&#13;
<blockquote>&#13;
<p>Progress is possible only if we train ourselves to think about programs without thinking of them as pieces of executable code.<sup><a data-type="noteref" id="idm45983640248920-marker" href="ch04.xhtml#idm45983640248920">1</a></sup></p>&#13;
<p data-type="attribution">Edsger W. Dijkstra, <cite>August 1979</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>In 1991, while still at Sun Microsystems, L Peter Deutsch<sup><a data-type="noteref" id="idm45983640246616-marker" href="ch04.xhtml#idm45983640246616">2</a></sup> formulated the <em>Fallacies of Distributed Computing</em>, which lists some of the false assumptions that programmers new (and not so new) to distributed applications often make:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>The network is reliable</em>: switches fail, routers get misconfigured</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Latency is zero</em>: it takes time to move data across a network</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Bandwidth is infinite</em>: a network can only handle so much data at a time</p>&#13;
</li>&#13;
<li>&#13;
<p><em>The network is secure</em>: don’t share secrets in plain text; encrypt everything</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Topology doesn’t change</em>:  servers and services come and go</p>&#13;
</li>&#13;
<li>&#13;
<p><em>There is one administrator</em>: multiple admins lead to heterogeneous solutions</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Transport cost is zero</em>: moving data around costs time and money</p>&#13;
</li>&#13;
<li>&#13;
<p><em>The network is homogeneous</em>: every network is (sometimes very) different</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If I might be so audacious, I’d like to add a ninth one as well:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Services are reliable</em>: services that you depend on can fail at any time</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In this chapter, I’ll present a selection of idiomatic patterns—tested, proven development paradigms—designed to address one or more of the conditions described in Deutsch’s Fallacies, and demonstrate how to implement them in Go. None of the patterns discussed in this book are original to this book—some have been around for as long as distributed applications have existed—but most haven’t been previously published together in a single work. Many of them are unique to Go or have novel implementations in Go relative to other languages.</p>&#13;
&#13;
<p>Unfortunately, this book won’t cover infrastructure-level patterns like the <a href="https://oreil.ly/0hxmU">Bulkhead</a> or <a href="https://oreil.ly/0v5Jc">Gatekeeper</a> patterns. Largely, this is because our focus is on application-layer development in Go, and those patterns, while indispensable, function at an entirely different abstraction level. If you’re interested in learning more, I recommend <em>Cloud Native Infrastructure</em> by Justin Garrison and Kris Nova (O’Reilly) and <em>Designing Distributed Systems</em> by Brendan Burns (O’Reilly).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="The Context Package"><div class="sect1" id="section_ch04_context">&#13;
<h1>The Context Package</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="context package" id="ch04_term1"/>Most of the code examples in this chapter make use of the <code>context</code> package, which was introduced in Go 1.7 to provide an idiomatic means of carrying deadlines, cancellation signals, and request-scoped values between processes. It contains a single interface, <code>context.Context</code>, whose methods are listed in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Context</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="c1">// Done returns a channel that's closed when this Context is cancelled.</code>&#13;
    <code class="nx">Done</code><code class="p">()</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kd">struct</code><code class="p">{}</code>&#13;
&#13;
    <code class="c1">// Err indicates why this context was cancelled after the Done channel is</code>&#13;
    <code class="c1">// closed. If Done is not yet closed, Err returns nil.</code>&#13;
    <code class="nx">Err</code><code class="p">()</code> <code class="kt">error</code>&#13;
&#13;
    <code class="c1">// Deadline returns the time when this Context should be cancelled; it</code>&#13;
    <code class="c1">// returns ok==false if no deadline is set.</code>&#13;
    <code class="nx">Deadline</code><code class="p">()</code> <code class="p">(</code><code class="nx">deadline</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Time</code><code class="p">,</code> <code class="nx">ok</code> <code class="kt">bool</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Value returns the value associated with this context for key, or nil</code>&#13;
    <code class="c1">// if no value is associated with key. Use with care.</code>&#13;
    <code class="nx">Value</code><code class="p">(</code><code class="nx">key</code> <code class="kd">interface</code><code class="p">{})</code> <code class="kd">interface</code><code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Three of these methods can be used to learn something about a <code>Context</code> value’s cancellation status or behavior. The fourth, <code>Value</code>, can be used to retrieve a value associated with an arbitrary key. <code>Context</code>’s <code>Value</code> method is the focus of some controversy in the Go world, and will be discussed more in <a data-type="xref" href="#section_ch04_context_request_scoped_values">“Defining Request-Scoped Values”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="What Context Can Do for You"><div class="sect2" id="idm45983640138456">&#13;
<h2>What Context Can Do for You</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="functions" id="ch04_term23"/>A <code>context.Context</code> value is used by passing it directly to a service request, which may in turn pass it to one or more subrequests. What makes this useful is that when the <code>Context</code> is cancelled, all functions holding it (or a derived <code>Context</code>; more on this in Figures&#13;
<a data-xrefstyle="select:labelnumber" data-type="xref" href="#img_ch04_context1">4-1</a>,&#13;
<a data-xrefstyle="select:labelnumber" data-type="xref" href="#img_ch04_context2">4-2</a>, and&#13;
<a data-xrefstyle="select:labelnumber" data-type="xref" href="#img_ch04_context3">4-3</a>)&#13;
will receive the signal, allowing them to coordinate their cancellation and reduce the amount of wasted effort.</p>&#13;
&#13;
<p>Take, for example, a request from a user to a service, which in turn makes a request to a database. In an ideal scenario, the user, application, and database requests can be diagrammed as in <a data-type="xref" href="#img_ch04_context1">Figure 4-1</a>.</p>&#13;
&#13;
<figure><div id="img_ch04_context1" class="figure">&#13;
<img src="Images/cngo_0401.png" alt="cngo 0401" width="1358" height="260"/>&#13;
<h6><span class="label">Figure 4-1. </span>A successful request from a user, to a service, to a database</h6>&#13;
</div></figure>&#13;
&#13;
<p>But what if the user terminates their request before it’s fully completed? In most cases, oblivious to the overall context of the request, the processes will continue to live on anyway (<a data-type="xref" href="#img_ch04_context2">Figure 4-2</a>), consuming resources in order to provide a result that’ll never be used.</p>&#13;
&#13;
<figure><div id="img_ch04_context2" class="figure">&#13;
<img src="Images/cngo_0402.png" alt="cngo 0402" width="1358" height="259"/>&#13;
<h6><span class="label">Figure 4-2. </span>Subprocesses, unaware of a cancelled user request, will continue anyway</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, by sharing a <code>Context</code> to each subsequent request, all long-running processes can be sent a simultaneous “done” signal, allowing the cancellation signal to be coordinated among each of the processes (<a data-type="xref" href="#img_ch04_context3">Figure 4-3</a>).</p>&#13;
&#13;
<figure><div id="img_ch04_context3" class="figure">&#13;
<img src="Images/cngo_0403.png" alt="cngo 0403" width="1329" height="256"/>&#13;
<h6><span class="label">Figure 4-3. </span>By sharing context, cancellation signals can be coordinated among processes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Importantly, <code>Context</code> values are also thread safe, i.e., they can be safely used by multiple concurrently executing goroutines without fear of unexpected behaviors.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Creating Context"><div class="sect2" id="idm45983640118712">&#13;
<h2>Creating Context</h2>&#13;
&#13;
<p>A brand-new <code>context.Context</code> can be obtained using one of two functions:</p>&#13;
<dl>&#13;
<dt><code>func Background() Context</code></dt>&#13;
<dd>&#13;
<p>Returns an empty <code>Context</code> that’s never cancelled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level <code>Context</code> for incoming requests.</p>&#13;
</dd>&#13;
<dt><code>func TODO() Context</code></dt>&#13;
<dd>&#13;
<p>Also provides an empty <code>Context</code>, but it’s intended to be used as a placeholder when it’s unclear which <code>Context</code> to use or when a parent <code>Context</code> is not yet available.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Defining Context Deadlines and Timeouts"><div class="sect2" id="idm45983640110888">&#13;
<h2>Defining Context Deadlines and Timeouts</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="derived context" id="idm45983640109448"/><a data-type="indexterm" data-primary="context deadlines" id="idm45983640108744"/><a data-type="indexterm" data-primary="context timeouts" id="idm45983640108072"/>The <code>context</code> package also includes a number of methods for creating <em>derived</em> <code>Context</code> values that allow you to direct cancellation behavior, either by applying a timeout or by a function hook that can explicitly trigger a cancellation.</p>&#13;
<dl>&#13;
<dt><code>func WithDeadline(Context, time.Time) (Context, CancelFunc)</code></dt>&#13;
<dd>&#13;
<p>Accepts a specific time at which the <code>Context</code> will be cancelled and the <code>Done</code> channel will be closed.</p>&#13;
</dd>&#13;
<dt><code>func WithTimeout(Context, time.Duration) (Context, CancelFunc)</code></dt>&#13;
<dd>&#13;
<p>Accepts a duration after which the <code>Context</code> will be cancelled and the <code>Done</code> channel will be closed.</p>&#13;
</dd>&#13;
<dt><code>func WithCancel(Context) (Context, CancelFunc)</code></dt>&#13;
<dd>&#13;
<p>Unlike the previous functions, <code>WithCancel</code> accepts nothing, and only returns a function that can be called to explicitly cancel the <code>Context</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>All three of these functions return a derived <code>Context</code> that includes any requested decoration, and a <code>context.CancelFunc</code>, a zero-parameter function that can be called to explicitly cancel the <code>Context</code> and all of its derived values.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>When a <code>Context</code> is cancelled, all <code>Context</code>s that are <em>derived from it</em> are also cancelled. <code>Context</code>s that <em>it was derived from</em> are not.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Defining Request-Scoped Values"><div class="sect2" id="section_ch04_context_request_scoped_values">&#13;
<h2>Defining Request-Scoped Values</h2>&#13;
&#13;
<p>Finally, the <code>context</code> package includes a function that can be used to define an arbitrary <em>request-scoped</em> key-value pair that can be accessed from the returned <code>Context</code>—and all <code>Context</code> values derived from it—via the <code>Value</code> method.</p>&#13;
<dl>&#13;
<dt><code>func WithValue(parent Context, key, val interface{}) Context</code></dt>&#13;
<dd>&#13;
<p><code>WithValue</code> returns a derivation of <code>parent</code> in which <code>key</code> is associated with the value <code>val</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983640055432">&#13;
<h5>On Context Values</h5>&#13;
<p><a data-type="indexterm" data-primary="context values" id="idm45983640054200"/>The <code>context.WithValue</code> and <code>context.Value</code> functions provide convenient mechanisms for setting and getting arbitrary key-value pairs that can be used by consuming processes and APIs. However, it has been argued that this functionality is orthogonal to <code>Context</code>’s function of orchestrating the cancellation of long-lived requests, obscures your program’s flow, and can easily break compile-time coupling. For a more in-depth discussion, please see Dave Cheney’s blog post <a href="https://oreil.ly/DaGN1"><em>Context Is for Cancelation</em></a>.</p>&#13;
&#13;
<p>This functionality isn’t used in any of the examples in this chapter (or this book). If you choose to make use of it, please take care to ensure that all of your values are scoped only to the request, don’t alter the functioning of any processes, and don’t break your processes if they happen to be absent.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Using a Context"><div class="sect2" id="idm45983640049752">&#13;
<h2>Using a Context</h2>&#13;
&#13;
<p>When a service request is initiated, either by an incoming request or triggered by the <code>main</code> function, the top-level process will use the <code>Background</code> function to create a new <code>Context</code> value, possibly decorating it with one or more of the <code>context.With*</code> functions, before passing it along to any subrequests. Those subrequests then need only watch the <code>Done</code> channel for cancellation signals.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Stream function" id="ch04_term2"/>For example, take a look at the following <code>Stream</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Stream</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">out</code> <code class="kd">chan</code><code class="o">&lt;-</code> <code class="nx">Value</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// Create a derived Context with a 10s timeout; dctx</code>&#13;
    <code class="c1">// will be cancelled upon timeout, but ctx will not.</code>&#13;
    <code class="c1">// cancel is a function that will explicitly cancel dctx.</code>&#13;
    <code class="nx">dctx</code><code class="p">,</code> <code class="nx">cancel</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Release resources if SlowOperation completes before timeout</code>&#13;
    <code class="k">defer</code> <code class="nx">cancel</code><code class="p">()</code>&#13;
&#13;
    <code class="nx">res</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">SlowOperation</code><code class="p">(</code><code class="nx">dctx</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>                     <code class="c1">// True if dctx times out</code>&#13;
        <code class="k">return</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">{</code>&#13;
        <code class="k">select</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="nx">out</code> <code class="o">&lt;-</code> <code class="nx">res</code><code class="p">:</code>                <code class="c1">// Read from res; send to out</code>&#13;
&#13;
        <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>              <code class="c1">// Triggered if ctx is cancelled</code>&#13;
            <code class="k">return</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>Stream</code> receives a <code>ctx Context</code> as an input parameter, which it sends to <code>WithTimeout</code> to create <code>dctx</code>, a derived <code>Context</code> with a 10-second timeout. Because of this decoration, the <code>SlowOperation(dctx)</code> call could possibly time out after ten seconds and return an error. Functions using the original <code>ctx</code>, however, will not have this timeout decoration, and will not time out.<a data-type="indexterm" data-primary="Stream function" data-startref="ch04_term2" id="idm45983639957448"/></p>&#13;
&#13;
<p>Further down, the original <code>ctx</code> value is used in a <code>for</code> loop around a <code>select</code> statement to retrieve values from the <code>res</code> channel provided by the <code>SlowOperation</code> function. Note the <code>case &lt;-ctx.Done()</code> statement, which is executed when the <code>ctx.Done</code> channel closes to return an appropriate error value.<a data-type="indexterm" data-primary="context package" data-startref="ch04_term1" id="idm45983639952920"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Layout of this Chapter"><div class="sect1" id="idm45983640228600">&#13;
<h1>Layout of this Chapter</h1>&#13;
&#13;
<p>The general presentation of each pattern in this chapter is loosely based on the one used in the famous “Gang of Four” <em>Design Patterns</em> book,<sup><a data-type="noteref" id="idm45983639950216-marker" href="ch04.xhtml#idm45983639950216">3</a></sup> but simpler and less formal. Each pattern opens with a very brief description of its purpose and the reasons for using it, and is followed by the following sections:</p>&#13;
<dl>&#13;
<dt>Applicability</dt>&#13;
<dd>&#13;
<p>Context and descriptions of where this pattern may be applied.</p>&#13;
</dd>&#13;
<dt>Participants</dt>&#13;
<dd>&#13;
<p>A listing of the components of the pattern and their roles.</p>&#13;
</dd>&#13;
<dt>Implementation</dt>&#13;
<dd>&#13;
<p>A discussion of the solution and its implementation.</p>&#13;
</dd>&#13;
<dt>Sample code</dt>&#13;
<dd>&#13;
<p>A demonstration of how the code may be implemented in Go.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Stability Patterns"><div class="sect1" id="section_ch04_stability_patterns">&#13;
<h1>Stability Patterns</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="stability patterns" id="ch04_term3_2"/><a data-type="indexterm" data-primary="stability patterns" data-seealso="circuit breaker pattern, debounce pattern, throttle pattern, timeout" id="ch04_term3"/>The stability patterns presented here address one or more of the assumptions called out by the Fallacies of Distributed Computing. They’re generally intended to be applied by distributed applications to improve their own stability and the stability of the larger system they’re a part of.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Circuit Breaker"><div class="sect2" id="section_ch04_circuit_breaker">&#13;
<h2>Circuit Breaker</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="circuit breaker pattern" id="ch04_term4_2"/><a data-type="indexterm" data-primary="circuit breaker pattern" id="ch04_term4"/>Circuit Breaker automatically degrades service functions in response to a likely fault, preventing larger or cascading failures by eliminating recurring errors and providing reasonable error responses.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983639933720">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>If the <em>Fallacies of Distributed Computing</em> were to be distilled to one point, it would be that errors and failures are an undeniable fact of life for distributed, cloud native systems. Services become misconfigured, databases crash, networks partition. We can’t prevent it; we can only accept and account for it.</p>&#13;
&#13;
<p>Failing to do so can have some rather unpleasant consequences. We’ve all seen them, and they aren’t pretty. Some services might keep futilely trying to do their job and returning nonsense to their client; others might fail catastrophically and maybe even fall into a crash/restart death spiral. It doesn’t matter, because in the end they’re all wasting resources, obscuring the source of original failure, and making cascading failures even more likely.</p>&#13;
&#13;
<p>On the other hand, a service that’s designed with the assumption that its dependencies can fail at any time can respond reasonably when they do. The Circuit Breaker allows a service to detect such failures and to “open the circuit” by temporarily ceasing to execute requests, instead providing clients with an error message consistent with the service’s communication contract.</p>&#13;
&#13;
<p>For example, imagine a service that (ideally) receives a request from a client, executes a database query, and returns a response. What if the database fails? The service might continue futilely trying to query it anyway, flooding the logs with error messages and eventually timing out or returning useless errors. Such a service can use a Circuit Breaker to “open the circuit” when the database fails, preventing the service from making any more doomed database requests (at least for a while), and allowing it to respond to the client immediately with a meaningful notification.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" class="pagebreak-before less_space" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983639928616">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Circuit</dt>&#13;
<dd>&#13;
<p>The function that interacts with the service.</p>&#13;
</dd>&#13;
<dt>Breaker</dt>&#13;
<dd>&#13;
<p>A closure with the same function signature as <em>Circuit</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983639923256">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="adapter pattern" id="idm45983639921784"/>Essentially, the Circuit Breaker is just a specialized <a href="https://oreil.ly/bEeru">Adapter</a> pattern, with <code>Breaker</code> wrapping <code>Circuit</code> to add some additional error handling logic.</p>&#13;
&#13;
<p>Like the electrical switch from which this pattern derives its name, <code>Breaker</code> has two possible states: <em>closed</em> and <em>open</em>. In the closed state everything is functioning normally. All requests received from the client by <code>Breaker</code> are forwarded unchanged to <code>Circuit</code>, and all responses from <code>Circuit</code> are forwarded back to the client. In the open state, <code>Breaker</code> doesn’t forward requests to <code>Circuit</code>. Instead it “fails fast” by responding with an informative error message.</p>&#13;
&#13;
<p><code>Breaker</code> internally tracks the errors returned by <code>Circuit</code>; if the number of consecutive errors returned by <code>Circuit</code> returns exceeds a defined threshold, <code>Breaker</code> <em>trips</em> and its state switches to <em>open</em>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="backoff" data-seealso="exponential backoff" id="idm45983639911752"/>Most implementations of Circuit Breaker include some logic to automatically close the circuit after some period of time. Keep in mind, though, that hammering an already malfunctioning service with lots of retries can cause its own problems, so it’s standard to include some kind of <em>backoff</em>, logic that reduces the rate of retries over time. The subject of backoff is actually fairly nuanced, but it will be covered in detail in in <a data-type="xref" href="ch09.xhtml#section_ch09_retries">“Play It Again: Retrying Requests”</a>.</p>&#13;
&#13;
<p>In a multinode service, this implementation may be extended to include some shared storage mechanism, such as a Memcached or Redis network cache, to track the circuit state.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983639908232">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>We begin by creating a <code>Circuit</code> type that specifies the signature of the function that’s interacting with your database or other upstream service. In practice, this can take whatever form is appropriate for your functionality. It should include an <code>error</code> in its return list, however:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Circuit</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>In this example, <code>Circuit</code> is a function that accepts a <code>Context</code> value, which was described in depth in <a data-type="xref" href="#section_ch04_context">“The Context Package”</a>. Your implementation may vary.</p>&#13;
&#13;
<p>The <code>Breaker</code> function accepts any function that conforms to the <code>Circuit</code> type definition, and an unsigned integer representing the number of consecutive failures allowed before the circuit automatically opens. In return it provides another function, which also conforms to the <code>Circuit</code> type definition:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Breaker</code><code class="p">(</code><code class="nx">circuit</code> <code class="nx">Circuit</code><code class="p">,</code> <code class="nx">failureThreshold</code> <code class="kt">uint</code><code class="p">)</code> <code class="nx">Circuit</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">consecutiveFailures</code> <code class="kt">int</code> <code class="p">=</code> <code class="mi">0</code>&#13;
    <code class="kd">var</code> <code class="nx">lastAttempt</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code>&#13;
    <code class="kd">var</code> <code class="nx">m</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">RWMutex</code>&#13;
&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">m</code><code class="p">.</code><code class="nx">RLock</code><code class="p">()</code>                       <code class="c1">// Establish a "read lock"</code>&#13;
&#13;
        <code class="nx">d</code> <code class="o">:=</code> <code class="nx">consecutiveFailures</code> <code class="o">-</code> <code class="nb">int</code><code class="p">(</code><code class="nx">failureThreshold</code><code class="p">)</code>&#13;
&#13;
        <code class="k">if</code> <code class="nx">d</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="p">{</code>&#13;
            <code class="nx">shouldRetryAt</code> <code class="o">:=</code> <code class="nx">lastAttempt</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">&lt;&lt;</code> <code class="nx">d</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="p">!</code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">After</code><code class="p">(</code><code class="nx">shouldRetryAt</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="nx">m</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code>&#13;
                <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"service unreachable"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">m</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code>                     <code class="c1">// Release read lock</code>&#13;
&#13;
        <code class="nx">response</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">circuit</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>   <code class="c1">// Issue request proper</code>&#13;
&#13;
        <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>                        <code class="c1">// Lock around shared resources</code>&#13;
        <code class="k">defer</code> <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
&#13;
        <code class="nx">lastAttempt</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code>        <code class="c1">// Record time of attempt</code>&#13;
&#13;
        <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>                 <code class="c1">// Circuit returned an error,</code>&#13;
            <code class="nx">consecutiveFailures</code><code class="o">++</code>       <code class="c1">// so we count the failure</code>&#13;
            <code class="k">return</code> <code class="nx">response</code><code class="p">,</code> <code class="nx">err</code>        <code class="c1">// and return</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">consecutiveFailures</code> <code class="p">=</code> <code class="mi">0</code>         <code class="c1">// Reset failures counter</code>&#13;
&#13;
        <code class="k">return</code> <code class="nx">response</code><code class="p">,</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>Breaker</code> function constructs another function, also of type <code>Circuit</code>, which wraps <code>circuit</code> to provide the desired functionality. You may recognize this from <a data-type="xref" href="ch03.xhtml#section_ch03_anonymous_functions_and_closures">“Anonymous Functions and Closures”</a> as a closure: a nested function with access to the variables of its parent function. As you will see, all of the “stability” functions implemented for this chapter work this way.</p>&#13;
&#13;
<p>The closure works by counting the number of consecutive errors returned by &#13;
<span class="keep-together"><code>circuit</code></span>. If that value meets the failure threshold, then it returns the error “service unreachable” without actually calling <code>circuit</code>. Any successful calls to <code>circuit</code> cause <code>consecutiveFailures</code> to reset to 0, and the cycle begins again.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="exponential backoff" id="idm45983639620440"/>The closure even includes an automatic reset mechanism that allows requests to call <code>circuit</code> again after several seconds, with an <em>exponential backoff</em> in which the durations of the delays between retries roughly doubles with each attempt. Though simple and quite common, this actually isn’t the ideal backoff algorithm. We’ll review exactly why in <a data-type="xref" href="ch09.xhtml#section_ch09_backoff_algorithms">“Backoff Algorithms”</a>.<a data-type="indexterm" data-primary="patterns" data-secondary="circuit breaker pattern" data-startref="ch04_term4_2" id="idm45983639617640"/><a data-type="indexterm" data-primary="circuit breaker pattern" data-startref="ch04_term4" id="idm45983639616392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Debounce"><div class="sect2" id="idm45983639615320">&#13;
<h2>Debounce</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="debounce pattern" id="ch04_term5_2"/><a data-type="indexterm" data-primary="debounce pattern" id="ch04_term5"/>Debounce limits the frequency of a function invocation so that only the first or last in a cluster of calls is actually performed.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983639611320">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>Debounce is the second of our patterns to be labeled with an electrical circuit theme. Specifically, it’s named after a phenomenon in which a switch’s contacts “bounce” when they’re opened or closed, causing the circuit to fluctuate a bit before settling down. It’s usually no big deal, but this “contact bounce” can be a real problem in logic circuits where a series of on/off pulses can be interpreted as a data stream. The practice of eliminating contact bounce so that only one signal is transmitted by an opening or closing contact is called “debouncing.”</p>&#13;
&#13;
<p>In the world of services, we sometimes find ourselves performing a cluster of potentially slow or costly operations where only one would do. Using the Debounce pattern, a series of similar calls that are tightly clustered in time are restricted to only one call, typically the first or last in a batch.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="JavaScript" id="idm45983639608168"/>This technique has been used in the JavaScript world for years to limit the number of operations that could slow the browser by taking only the first in a series of user events or to delay a call until a user is ready. You’ve probably seen an application of this technique in practice before. We’re all familiar with the experience of using a search bar whose autocomplete pop-up doesn’t display until after you pause typing, or spam-clicking a button only to see the clicks after the first ignored.</p>&#13;
&#13;
<p>Those of us who specialize in backend services can learn a lot from our frontend brethren, who have been working for years to account for the reliability, latency, and bandwidth issues inherent to distributed systems. For example, this approach could be used to retrieve some slowly updating remote resource without bogging down, wasting both client and server time with wasteful requests.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="throttle pattern" id="idm45983639605736"/><a data-type="indexterm" data-primary="throttle pattern" id="idm45983639604760"/>This pattern is similar to <a data-type="xref" href="#section_ch04_throttle">“Throttle”</a>, in that it limits how often a function can be called. But where Debounce restricts clusters of invocations, Throttle simply limits according to time period. For more on the difference between the Debounce and Throttle patterns, see <a data-type="xref" href="#sidebar_ch04_debounce_vs_throttle">“What’s the Difference Between Throttle and Debounce?”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983639602008">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Circuit</dt>&#13;
<dd>&#13;
<p>The function to regulate.</p>&#13;
</dd>&#13;
<dt>Debounce</dt>&#13;
<dd>&#13;
<p>A closure with the same function signature as <em>Circuit</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983639596984">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="circuit breaker pattern" id="idm45983639595752"/><a data-type="indexterm" data-primary="circuit breaker pattern" id="idm45983639594776"/><a data-type="indexterm" data-primary="function-first implementation" id="ch04_term6"/>The Debounce implementation is actually very similar to the one for Circuit Breaker in that it wraps <em>Circuit</em> to provide the rate-limiting logic. That logic is actually quite straightforward: on each call of the outer function—regardless of its outcome—a time interval is set. Any subsequent call made before that time interval expires is ignored; any call made afterwards is passed along to the inner function. This implementation, in which the inner function is called once and subsequent calls are ignored, is called <em>function-first</em>, and is useful because it allows the initial response from the inner function to be cached and returned.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="function-last implementation" id="ch04_term7"/><a data-type="indexterm" data-primary="JavaScript" id="idm45983639590216"/>A <em>function-last</em> implementation will wait for a pause after a series of calls before calling the inner function. This variant is common in the JavaScript world when a programmer wants a certain amount of input before making a function call, such as when a search bar waits for a pause in typing before autocompleting. Function-last tends to be less common in backend services because it doesn’t provide an immediate response, but it can be useful if your function doesn’t need results right away.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983639588248">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>Just like in the Circuit Breaker implementation, we start by defining a function type with the signature of the function we want to limit. Also like Circuit Breaker, we call it <code>Circuit</code>; it’s identical to the one declared in that example. Again, <code>Circuit</code> can take whatever form is appropriate for your functionality, but it should include an <code>error</code> in its returns:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Circuit</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p class="pagebreak-before less_space">The similarity with the Circuit Breaker implementation is quite intentional: their compatibility makes them “chainable,” as demonstrated in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">myFunction</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
&#13;
<code class="nx">wrapped</code> <code class="o">:=</code> <code class="nx">Breaker</code><code class="p">(</code><code class="nx">Debounce</code><code class="p">(</code><code class="nx">myFunction</code><code class="p">))</code>&#13;
<code class="nx">response</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">wrapped</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="function-first implementation" data-startref="ch04_term6" id="idm45983639448664"/>The function-first implementation of Debounce—<code>DebounceFirst</code>—is very straightforward compared to function-last because it only needs to track the last time it was called and return a cached result if it’s called again less than <code>d</code> duration after:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">DebounceFirst</code><code class="p">(</code><code class="nx">circuit</code> <code class="nx">Circuit</code><code class="p">,</code> <code class="nx">d</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code> <code class="nx">Circuit</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">threshold</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Time</code>&#13;
    <code class="kd">var</code> <code class="nx">result</code> <code class="kt">string</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
    <code class="kd">var</code> <code class="nx">m</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Mutex</code>&#13;
&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
&#13;
        <code class="k">defer</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="nx">threshold</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Add</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>&#13;
            <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
        <code class="p">}()</code>&#13;
&#13;
        <code class="k">if</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Before</code><code class="p">(</code><code class="nx">threshold</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">circuit</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
&#13;
        <code class="k">return</code> <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This implementation of <code>DebounceFirst</code> takes pains to ensure thread safety by wrapping the entire function in a mutex. While this will force overlapping calls at the start of a cluster to have to wait until the result is cached, it also guarantees that <code>circuit</code> is called exactly once, at the very beginning of a cluster. A <code>defer</code> ensures that the value of <code>threshold</code>, representing the time when a cluster ends (if there are no further calls), is reset with every call.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="function-last implementation" data-startref="ch04_term7" id="idm45983639333144"/>Our function-last implementation is a bit more awkward because it involves the use of a <code>time.Ticker</code> to determine whether enough time has passed since the function was last called, and to call <code>circuit</code> when it has. Alternatively, we could create a new <code>time.Ticker</code> with every call, but that can get quite expensive if it’s called frequently:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go" class="pagebreak-before less_space"><code class="kd">type</code> <code class="nx">Circuit</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">DebounceLast</code><code class="p">(</code><code class="nx">circuit</code> <code class="nx">Circuit</code><code class="p">,</code> <code class="nx">d</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code> <code class="nx">Circuit</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">threshold</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Time</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code>&#13;
    <code class="kd">var</code> <code class="nx">ticker</code> <code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Ticker</code>&#13;
    <code class="kd">var</code> <code class="nx">result</code> <code class="kt">string</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
    <code class="kd">var</code> <code class="nx">once</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Once</code>&#13;
    <code class="kd">var</code> <code class="nx">m</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Mutex</code>&#13;
&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
        <code class="k">defer</code> <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
&#13;
        <code class="nx">threshold</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Add</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>&#13;
&#13;
        <code class="nx">once</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="nx">ticker</code> <code class="p">=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">NewTicker</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Millisecond</code> <code class="o">*</code> <code class="mi">100</code><code class="p">)</code>&#13;
&#13;
            <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
                <code class="k">defer</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
                    <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
                    <code class="nx">ticker</code><code class="p">.</code><code class="nx">Stop</code><code class="p">()</code>&#13;
                    <code class="nx">once</code> <code class="p">=</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Once</code><code class="p">{}</code>&#13;
                    <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
                <code class="p">}()</code>&#13;
&#13;
                <code class="k">for</code> <code class="p">{</code>&#13;
                    <code class="k">select</code> <code class="p">{</code>&#13;
                    <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ticker</code><code class="p">.</code><code class="nx">C</code><code class="p">:</code>&#13;
                        <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
                        <code class="k">if</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">After</code><code class="p">(</code><code class="nx">threshold</code><code class="p">)</code> <code class="p">{</code>&#13;
                            <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">circuit</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
                            <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
                            <code class="k">return</code>&#13;
                        <code class="p">}</code>&#13;
                        <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
                    <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>&#13;
                        <code class="nx">m</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
                        <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="s">""</code><code class="p">,</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
                        <code class="nx">m</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
                        <code class="k">return</code>&#13;
                    <code class="p">}</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">}()</code>&#13;
        <code class="p">})</code>&#13;
&#13;
        <code class="k">return</code> <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Like <code>DebounceFirst</code>, <code>DebounceLast</code> uses a value called <code>threshold</code> to indicate the end of a cluster of calls (assuming there are no additional calls). The similarity largely ends there however.</p>&#13;
&#13;
<p>You’ll notice that almost the entire function is run inside of the <code>Do</code> method of a <code>sync.Once</code> value, which ensures that (as its name suggests) the contained function is run <em>exactly</em> once. Inside this block, a <code>time.Ticker</code> is used to check whether &#13;
<span class="keep-together"><code>threshold</code></span> has been passed and to call <code>circuit</code> if it has. Finally, the <code>time.Ticker</code> is stopped, the <code>sync.Once</code> is reset, and the cycle is primed to repeat.<a data-type="indexterm" data-primary="patterns" data-secondary="debounce pattern" data-startref="ch04_term5_2" id="idm45983639089576"/><a data-type="indexterm" data-primary="debounce pattern" data-startref="ch04_term5" id="idm45983639088328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Retry"><div class="sect2" id="section_ch04_retry">&#13;
<h2>Retry</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="Retry function" id="ch04_term8_2"/><a data-type="indexterm" data-primary="Retry function" id="ch04_term8"/>Retry accounts for a possible transient fault in a distributed system by transparently retrying a failed operation.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983639083256">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>Transient errors are a fact of life when working with complex distributed systems. These can be caused by any number of (hopefully) temporary conditions, especially if the downstream service or network resource has protective strategies in place, such as throttling that temporarily rejects requests under high workload, or adaptive strategies like autoscaling that can add capacity when needed.</p>&#13;
&#13;
<p>These faults typically resolve themselves after a bit of time, so repeating the request after a reasonable delay is likely (but not guaranteed) to be successful. Failing to account for transient faults can lead to a system that’s unnecessarily brittle. On the other hand, implementing an automatic retry strategy can considerably improve the stability of the service that can benefit both it and its upstream consumers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983639080440">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Effector</dt>&#13;
<dd>&#13;
<p>The function that interacts with the service.</p>&#13;
</dd>&#13;
<dt>Retry</dt>&#13;
<dd>&#13;
<p>A function that accepts <em>Effector</em> and returns a closure with the same function signature as <em>Effector</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983639074888">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Effector function" id="idm45983639073656"/>This pattern works similarly to Circuit Breaker or Debounce in that there is a type, <em>Effector</em>, that defines a function signature. This signature can take whatever form is appropriate for your implementation, but when the function executing the potentially-failing operation is implemented, it must match the signature defined by <em>Effector</em>.</p>&#13;
&#13;
<p>The <em>Retry</em> function accepts the user-defined <em>Effector</em> function and returns an <em>Effector</em> function that wraps the user-defined function to provide the retry logic. Along with the user-defined function, <em>Retry</em> also accepts an integer describing the maximum number of retry attempts that it will make, and a <code>time.Duration</code> that describes how long it’ll wait between each retry attempt. If the <code>retries</code> parameter is 0, then the retry logic will effectively become a no-op.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Although not included here, retry logic will typically include some kind of a backoff algorithm.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983639066952">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>The signature for function argument of the <code>Retry</code> function is <code>Effector</code>. It looks exactly like the function types for the previous patterns:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Effector</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <code>Retry</code> function itself is relatively straightforward, at least when compared to the functions we’ve seen so far:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Retry</code><code class="p">(</code><code class="nx">effector</code> <code class="nx">Effector</code><code class="p">,</code> <code class="nx">retries</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">delay</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code> <code class="nx">Effector</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">for</code> <code class="nx">r</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="p">;</code> <code class="nx">r</code><code class="o">++</code> <code class="p">{</code>&#13;
            <code class="nx">response</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">effector</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">==</code> <code class="kc">nil</code> <code class="o">||</code> <code class="nx">r</code> <code class="o">&gt;=</code> <code class="nx">retries</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="nx">response</code><code class="p">,</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Attempt %d failed; retrying in %v"</code><code class="p">,</code> <code class="nx">r</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">delay</code><code class="p">)</code>&#13;
&#13;
            <code class="k">select</code> <code class="p">{</code>&#13;
            <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">time</code><code class="p">.</code><code class="nx">After</code><code class="p">(</code><code class="nx">delay</code><code class="p">):</code>&#13;
            <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>&#13;
                <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You may have already noticed what it is that keeps the <code>Retry</code> function so slender: although it returns a function, that function doesn’t have any external state. This means we don’t need any elaborate mechanisms to support concurrency.</p>&#13;
&#13;
<p>To use <code>Retry</code>, we can implement the function that executes the potentially-failing operation and whose signature matches the <code>Effector</code> type; this role is played by &#13;
<span class="keep-together"><code>EmulateTransientError</code></span> in the following example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">count</code> <code class="kt">int</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">EmulateTransientError</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">count</code><code class="o">++</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">count</code> <code class="o">&lt;=</code> <code class="mi">3</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s">"intentional fail"</code><code class="p">,</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"error"</code><code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s">"success"</code><code class="p">,</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">r</code> <code class="o">:=</code> <code class="nx">Retry</code><code class="p">(</code><code class="nx">EmulateTransientError</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">2</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">res</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">r</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">())</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the <code>main</code> function, the <code>EmulateTransientError</code> function is passed to <code>Retry</code>, providing the function variable <code>r</code>. When <code>r</code> is called, <code>EmulateTransientError</code> is called, and called again after a delay if it returns an error, according to the retry logic shown previously. Finally, after the fourth attempt, <code>EmulateTransientError</code> returns a <code>nil</code> error and exits.<a data-type="indexterm" data-primary="patterns" data-secondary="Retry function" data-startref="ch04_term8" id="idm45983638701528"/><a data-type="indexterm" data-primary="Retry function" data-startref="ch04_term8" id="idm45983638700360"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Throttle"><div class="sect2" id="section_ch04_throttle">&#13;
<h2>Throttle</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="throttle pattern" id="ch04_term10_2"/><a data-type="indexterm" data-primary="throttle pattern" id="ch04_term10"/>Throttle limits the frequency of a function call to some maximum number of invocations per unit of time.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983638695160">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>The Throttle pattern is named after a device used to manage the flow of a fluid, such as the amount of fuel going into a car engine. Like its namesake mechanism, Throttle restricts the number of times that a function can be called during over a period of time. For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A user may only be allowed 10 service requests per second.</p>&#13;
</li>&#13;
<li>&#13;
<p>A client may restrict itself to call a particular function once every 500 milliseconds.</p>&#13;
</li>&#13;
<li>&#13;
<p>An account may only be allowed three failed login attempts in a 24-hour period.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Perhaps the most common reason to apply a Throttle is to account for sharp activity spikes that could saturate the system with a possibly unreasonable number of requests that may be expensive to satisfy, or lead to service degradation and eventually failure. While it may be possible for a system to scale up to add sufficient capacity to meet user demand, this takes time, and the system may not be able to react quickly enough.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch04_debounce_vs_throttle">&#13;
<h5>What’s the Difference Between Throttle and Debounce?</h5>&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="debounce pattern" id="idm45983638687720"/><a data-type="indexterm" data-primary="debounce pattern" id="idm45983638686744"/>Conceptually, Debounce and Throttle seem fairly similar. After all, they’re both about reducing the number of calls per unit of time. However, as illustrated in <a data-type="xref" href="#img_ch04_debounce_vs_throttle">Figure 4-4</a>, the precise timing of each differs quite a bit:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Throttle</em> works like the throttle in a car, limiting the amount of fuel going into the engine by capping the flow of fuel to some maximum rate. This is illustrated in <a data-type="xref" href="#img_ch04_debounce_vs_throttle">Figure 4-4</a>: no matter how many times the input function is called, Throttle only allows a fixed number of calls to proceed per unit of time.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Debounce</em> focuses on clusters of activity, making sure that a function is called only once during a cluster of requests, either at the start or the end of the cluster. A function-first debounce implementation is illustrated in <a data-type="xref" href="#img_ch04_debounce_vs_throttle">Figure 4-4</a>: for each of the two clusters of calls to the input function, Debounce only allows one call to proceed at the beginning of each cluster.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div id="img_ch04_debounce_vs_throttle" class="figure">&#13;
<img src="Images/cngo_0404.png" alt="cngo 0404" width="1441" height="506"/>&#13;
<h6><span class="label">Figure 4-4. </span>Throttle limits the event rate; debounce allows only one event in a cluster</h6>&#13;
</div></figure>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" class="pagebreak-before less_space" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983638677912">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Effector</dt>&#13;
<dd>&#13;
<p>The function to regulate.</p>&#13;
</dd>&#13;
<dt>Throttle</dt>&#13;
<dd>&#13;
<p>A function that accepts <em>Effector</em> and returns a closure with the same function signature as <em>Effector</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983638671992">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>The Throttle pattern is similar to many of the other patterns described in this chapter: it’s implemented as a function that accepts an effector function, and returns a <code>Throttle</code> closure with the same signature that provides the rate-limiting logic.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="token bucket" id="ch04_term12"/>The most common algorithm for implementing rate-limiting behavior is the <a href="https://oreil.ly/5A5aP"><em>token bucket</em></a>, which uses the analogy of a bucket that can hold some maximum number of tokens. When a function is called, a token is taken from the bucket, which then refills at some fixed rate.</p>&#13;
&#13;
<p>The way that a <code>Throttle</code> treats requests when there are insufficient tokens in the bucket to pay for it can vary depending according to the needs of the developer. Some common strategies are:</p>&#13;
<dl>&#13;
<dt>Return an error</dt>&#13;
<dd>&#13;
<p>This is the most basic strategy and is common when you’re only trying to restrict unreasonable or potentially abusive numbers of client requests. A RESTful service adopting this strategy might respond with a status <code>429 (Too Many Requests)</code>.</p>&#13;
</dd>&#13;
<dt>Replay the response of the last successful function call</dt>&#13;
<dd>&#13;
<p>This strategy can be useful when a service or expensive function call is likely &#13;
<span class="keep-together">to provide</span> an identical result if called too soon. It’s commonly used in the &#13;
<span class="keep-together">JavaScript</span> world.</p>&#13;
</dd>&#13;
<dt>Enqueue the request for execution when sufficient tokens are available</dt>&#13;
<dd>&#13;
<p>This approach can be useful when you want to eventually handle all requests, but it’s also more complex and may require care to be taken to ensure that memory isn’t exhausted.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983638659544">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>The following example implements a very basic “token bucket” algorithm that uses the “error” strategy:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Effector</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">Throttle</code><code class="p">(</code><code class="nx">e</code> <code class="nx">Effector</code><code class="p">,</code> <code class="nx">max</code> <code class="kt">uint</code><code class="p">,</code> <code class="nx">refill</code> <code class="kt">uint</code><code class="p">,</code> <code class="nx">d</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code> <code class="nx">Effector</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">tokens</code> <code class="p">=</code> <code class="nx">max</code>&#13;
    <code class="kd">var</code> <code class="nx">once</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Once</code>&#13;
&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">once</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="nx">ticker</code> <code class="o">:=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">NewTicker</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>&#13;
&#13;
            <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
                <code class="k">defer</code> <code class="nx">ticker</code><code class="p">.</code><code class="nx">Stop</code><code class="p">()</code>&#13;
&#13;
                <code class="k">for</code> <code class="p">{</code>&#13;
                    <code class="k">select</code> <code class="p">{</code>&#13;
                    <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>&#13;
                        <code class="k">return</code>&#13;
&#13;
                    <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ticker</code><code class="p">.</code><code class="nx">C</code><code class="p">:</code>&#13;
                        <code class="nx">t</code> <code class="o">:=</code> <code class="nx">tokens</code> <code class="o">+</code> <code class="nx">refill</code>&#13;
                        <code class="k">if</code> <code class="nx">t</code> <code class="p">&gt;</code> <code class="nx">max</code> <code class="p">{</code>&#13;
                            <code class="nx">t</code> <code class="p">=</code> <code class="nx">max</code>&#13;
                        <code class="p">}</code>&#13;
                        <code class="nx">tokens</code> <code class="p">=</code> <code class="nx">t</code>&#13;
                    <code class="p">}</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">}()</code>&#13;
        <code class="p">})</code>&#13;
&#13;
        <code class="k">if</code> <code class="nx">tokens</code> <code class="o">&lt;=</code> <code class="mi">0</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"too many calls"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">tokens</code><code class="o">--</code>&#13;
&#13;
        <code class="k">return</code> <code class="nx">e</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <code>Throttle</code> implementation is similar to our other examples in that it wraps an effector function <code>e</code> with a closure that contains the rate-limiting logic. The bucket is initially allocated <code>max</code> tokens; each time the closure is triggered it checks whether it has any remaining tokens. If tokens are available, it decrements the token count by one and triggers the effector function. If not, an error is returned. Tokens are added at a rate of <code>refill</code> tokens every duration <code>d</code>.<a data-type="indexterm" data-primary="patterns" data-secondary="throttle pattern" data-startref="ch04_term10_2" id="idm45983638417608"/><a data-type="indexterm" data-primary="throttle pattern" data-startref="ch04_term10" id="idm45983638416328"/><a data-type="indexterm" data-primary="token bucket" data-startref="ch04_term12" id="idm45983638415384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Timeout"><div class="sect2" id="section_ch04_timeout">&#13;
<h2>Timeout</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="timeout" id="ch04_term13_2"/><a data-type="indexterm" data-primary="timeout" id="ch04_term13"/>Timeout allows a process to stop waiting for an answer once it’s clear that an answer may not be coming.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983638410056">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Fallacies of Distributed Computing" id="idm45983638408888"/>The first of the Fallacies of Distributed Computing is that “the network is reliable,” and it’s first for a reason. Switches fail, routers and firewalls get misconfigured; packets get blackholed. Even if your network is working perfectly, not every service is thoughtful enough to guarantee a meaningful and timely response—or any response at all—if and when it malfunctions.</p>&#13;
&#13;
<p>Timeout represents a common solution to this dilemma, and is so beautifully simple that it barely even qualifies as a pattern at all: given a service request or function call that’s running for a longer-than-expected time, the caller simply…stops waiting.</p>&#13;
&#13;
<p>However, don’t mistake “simple” or “common” for “useless.” On the contrary, the ubiquity of the timeout strategy is a testament to its usefulness. The judicious use &#13;
<span class="keep-together">of timeouts</span> can provide a degree of fault isolation, preventing cascading failures &#13;
<span class="keep-together">and reducing</span> the chance that a problem in a downstream resource becomes <em>your</em> &#13;
<span class="keep-together">problem</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983638403656">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Client</dt>&#13;
<dd>&#13;
<p>The client who wants to execute <em>SlowFunction</em>.</p>&#13;
</dd>&#13;
<dt>SlowFunction</dt>&#13;
<dd>&#13;
<p>The long-running function that implements the functionality desired by <em>Client</em>.</p>&#13;
</dd>&#13;
<dt>Timeout</dt>&#13;
<dd>&#13;
<p>A wrapper function around <em>SlowFunction</em> that implements the timeout logic.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983638396248">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>There are several ways to implement a timeout in Go, but the idiomatic way is to use the functionality provided by the <code>context</code> package. See <a data-type="xref" href="#section_ch04_context">“The Context Package”</a> for more information.</p>&#13;
&#13;
<p>In an ideal world, any possibly long-running function will accept a <code>context.Context</code> parameter directly. If so, your work is fairly straightforward: you need only pass it a <code>Context</code> value decorated with the <code>context.WithTimeout</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go" class="pagebreak-before less_space"><code class="nx">ctx</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">()</code>&#13;
<code class="nx">ctxt</code><code class="p">,</code> <code class="nx">cancel</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="mi">10</code> <code class="o">*</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
<code class="k">defer</code> <code class="nx">cancel</code><code class="p">()</code>&#13;
&#13;
<code class="nx">result</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">SomeFunction</code><code class="p">(</code><code class="nx">ctxt</code><code class="p">)</code></pre>&#13;
&#13;
<p>However, this isn’t always the case, and with third party libraries you don’t always have the option of refactoring to accept a <code>Context</code> value. In these cases, the best course &#13;
<span class="keep-together">of action</span> may be to wrap the function call in such a way that it <em>does</em> respect your &#13;
<span class="keep-together"><code>Context</code>.</span></p>&#13;
&#13;
<p>For example, imagine you have a potentially long-running function that not only doesn’t accept a <code>Context</code> value, but comes from a package you don’t control. If <em>Client</em> were to call <em>SlowFunction</em> directly it would be forced to wait until the function completes, if indeed it ever does. Now what?</p>&#13;
&#13;
<p>Instead of calling <em>SlowFunction</em> directly, you can call it in a goroutine. In this way, you can capture the results it returns, if it returns them in an acceptable period of time. However, this also allows you to move on if it doesn’t.</p>&#13;
&#13;
<p>To do this, we can leverage a few tools that we’ve seen before: <code>context.Context</code> for timeouts, channels for communicating results, and <code>select</code> to catch whichever one acts first.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983638356120">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>The following example imagines the existence of the fictional function, <code>Slow</code>, whose execution may or may not complete in some reasonable amount of time, and whose signature conforms with the following type definition:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">SlowFunction</code> <code class="kd">func</code><code class="p">(</code><code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>Rather than calling <code>Slow</code> directly, we instead provide a <code>Timeout</code> function, which wraps a provided <code>SlowFunction</code> in a closure and returns a <code>WithContext</code> function, which adds a <code>context.Context</code> to the <code>SlowFunction</code>’s parameter list:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">WithContext</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">Timeout</code><code class="p">(</code><code class="nx">f</code> <code class="nx">SlowFunction</code><code class="p">)</code> <code class="nx">WithContext</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kd">func</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">arg</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">chres</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">)</code>&#13;
        <code class="nx">cherr</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="nx">res</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">f</code><code class="p">(</code><code class="nx">arg</code><code class="p">)</code>&#13;
            <code class="nx">chres</code> <code class="o">&lt;-</code> <code class="nx">res</code>&#13;
            <code class="nx">cherr</code> <code class="o">&lt;-</code> <code class="nx">err</code>&#13;
        <code class="p">}()</code>&#13;
&#13;
        <code class="k">select</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="nx">res</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">chres</code><code class="p">:</code>&#13;
            <code class="k">return</code> <code class="nx">res</code><code class="p">,</code> <code class="o">&lt;-</code><code class="nx">cherr</code>&#13;
        <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>&#13;
            <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="goroutine" id="idm45983638334648"/>Within the function that <code>Timeout</code> constructs, <code>Slow</code> is run in a goroutine, with its return values being sent into channels constructed for that purpose, if and when it ever completes.</p>&#13;
&#13;
<p>The following goroutine statement is a <code>select</code> block on two channels: the first of the <code>Slow</code> function response channels, and the <code>Context</code> value’s <code>Done</code> channel. If the former completes first, the closure will return the <code>Slow</code> function’s return values; otherwise it returns the error provided by the <code>Context</code>.</p>&#13;
&#13;
<p>Using the <code>Timeout</code> function isn’t much more complicated than consuming <code>Slow</code> directly, except that instead of one function call, we have two: the call to <code>Timeout</code> to retrieve the closure, and the call to the closure itself:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">ctx</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">()</code>&#13;
    <code class="nx">ctxt</code><code class="p">,</code> <code class="nx">cancel</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="mi">1</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">cancel</code><code class="p">()</code>&#13;
&#13;
    <code class="nx">timeout</code> <code class="o">:=</code> <code class="nx">Timeout</code><code class="p">(</code><code class="nx">Slow</code><code class="p">)</code>&#13;
    <code class="nx">res</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">timeout</code><code class="p">(</code><code class="nx">ctxt</code><code class="p">,</code> <code class="s">"some input"</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">res</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, although it’s usually preferred to implement service timeouts using &#13;
<span class="keep-together"><code>context.Context</code></span>, channel timeouts <em>can</em> also be implemented using the channel provided by the <code>time.After</code> function. See <a data-type="xref" href="ch03.xhtml#section_ch03_implementing_channel_timeouts">“Implementing channel timeouts”</a> for an example of how this is done.<a data-type="indexterm" data-primary="patterns" data-secondary="stability patterns" data-startref="ch04_term3_2" id="idm45983638000680"/><a data-type="indexterm" data-primary="stability patterns" data-startref="ch04_term3" id="idm45983637999464"/><a data-type="indexterm" data-primary="patterns" data-secondary="timeout" data-startref="ch04_term13_2" id="idm45983637998520"/>&#13;
<a data-type="indexterm" data-primary="timeout" data-startref="ch04_term13" id="idm45983637997176"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Concurrency Patterns"><div class="sect1" id="section_ch04_concurrency_patterns">&#13;
<h1>Concurrency Patterns</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="patterns" data-seealso="fan-in pattern, fan-out pattern, future pattern, sharding" id="idm45983637994680"/>A cloud native service will often be called upon to efficiently juggle multiple processes and handle high (and highly variable) levels of load, ideally without having to suffer the trouble and expense of scaling up. As such, it needs to be highly concurrent and able to manage multiple simultaneous requests from multiple clients. While Go is known for its concurrency support, bottlenecks can and do happen. Some of the patterns that have been developed to prevent them are presented here.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Fan-In"><div class="sect2" id="idm45983637992696">&#13;
<h2>Fan-In</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="fan-in pattern" id="ch04_term15_2"/><a data-type="indexterm" data-primary="fan-in pattern" id="ch04_term15"/>Fan-in multiplexes multiple input channels onto one output channel.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983637988840">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>Services that have some number of workers that all generate output may find it useful to combine all of the workers’ outputs to be processed as a single unified stream. For these scenarios we use the fan-in pattern, which can read from multiple input channels by multiplexing them onto a single destination channel.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983637986952">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Sources</dt>&#13;
<dd>&#13;
<p>A set of one or more input channels with the same type. Accepted by <em>Funnel</em>.</p>&#13;
</dd>&#13;
<dt>Destination</dt>&#13;
<dd>&#13;
<p>An output channel of the same type as <em>Sources</em>. Created and provided by <em>Funnel</em>.</p>&#13;
</dd>&#13;
<dt>Funnel</dt>&#13;
<dd>&#13;
<p>Accepts <em>Sources</em> and immediately returns <em>Destination</em>. Any input from any <em>Sources</em> will be output by <em>Destination</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983638077944">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p><em>Funnel</em> is implemented as a function that receives zero to N input channels (<em>Sources</em>). For each input channel in <em>Sources</em>, the <em>Funnel</em> function starts a separate goroutine to read values from its assigned channel and forward them to a single output channel shared by all of the goroutines (<em>Destination</em>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983638074168">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>The <code>Funnel</code> function is a variadic function that receives <code>sources</code>: zero to N channels of some type (<code>int</code> in the following example):</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Funnel</code><code class="p">(</code><code class="nx">sources</code> <code class="o">...&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">dest</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code>                  <code class="c1">// The shared output channel</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">wg</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code>                   <code class="c1">// Used to automatically close dest</code>&#13;
                                            <code class="c1">// when all sources are closed</code>&#13;
&#13;
    <code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">sources</code><code class="p">))</code>                    <code class="c1">// Set size of the WaitGroup</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">ch</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">sources</code> <code class="p">{</code>            <code class="c1">// Start a goroutine for each source</code>&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">(</code><code class="nx">c</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">defer</code> <code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code>                 <code class="c1">// Notify WaitGroup when c closes</code>&#13;
&#13;
            <code class="k">for</code> <code class="nx">n</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">c</code> <code class="p">{</code>&#13;
                <code class="nx">dest</code> <code class="o">&lt;-</code> <code class="nx">n</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}(</code><code class="nx">ch</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>                             <code class="c1">// Start a goroutine to close dest</code>&#13;
        <code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code>                           <code class="c1">// after all sources close</code>&#13;
        <code class="nb">close</code><code class="p">(</code><code class="nx">dest</code><code class="p">)</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">dest</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For each channel in the list of <code>sources</code>, <code>Funnel</code> starts a dedicated goroutine that reads values from its assigned channel and forwards them to <code>dest</code>, a single-output channel shared by all of the goroutines.</p>&#13;
&#13;
<p>Note the use of a <code>sync.WaitGroup</code> to ensure that the destination channel is closed appropriately. Initially, a <code>WaitGroup</code> is created and set to the total number of source channels. If a channel is closed, its associated goroutine exits, calling <code>wg.Done</code>. When all of the channels are closed, the WaitGroup’s counter reaches zero, the lock imposed by <code>wg.Wait</code> is released, and the <code>dest</code> channel is closed.</p>&#13;
&#13;
<p>Using <code>Funnel</code> is reasonably straightforward: given N source channels (or a slice of N channels), pass the channels to <code>Funnel</code>. The returned destination channel may be read in the usual way, and will close when all source channels close:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">sources</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">([]</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>        <code class="c1">// Create an empty channel slice</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
        <code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code>&#13;
        <code class="nx">sources</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">sources</code><code class="p">,</code> <code class="nx">ch</code><code class="p">)</code>       <code class="c1">// Create a channel; add to sources</code>&#13;
&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>                         <code class="c1">// Run a toy goroutine for each</code>&#13;
            <code class="k">defer</code> <code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code>                 <code class="c1">// Close ch when the routine ends</code>&#13;
&#13;
            <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="mi">5</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
                <code class="nx">ch</code> <code class="o">&lt;-</code> <code class="nx">i</code>&#13;
                <code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">dest</code> <code class="o">:=</code> <code class="nx">Funnel</code><code class="p">(</code><code class="nx">sources</code><code class="o">...</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="nx">d</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">dest</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This example creates a slice of three <code>int</code> channels, into which the values from 1 to 5 are sent before being closed. In a separate goroutine, the outputs of the single <code>dest</code> channel are printed. Running this will result in the appropriate 15 lines being printed before <code>dest</code> closes and the function ends.<a data-type="indexterm" data-primary="patterns" data-secondary="fan-in pattern" data-startref="ch04_term15_2" id="idm45983637863784"/><a data-type="indexterm" data-primary="fan-in pattern" data-startref="ch04_term15" id="idm45983637713064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Fan-Out"><div class="sect2" id="idm45983637711992">&#13;
<h2>Fan-Out</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="fan-out pattern" id="ch04_term16_2"/><a data-type="indexterm" data-primary="fan-out pattern" id="ch04_term16"/>Fan-out evenly distributes messages from an input channel to multiple output &#13;
<span class="keep-together">channels</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983637707480">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p>Fan-out receives messages from an input channel, distributing them evenly among output channels, and is a useful pattern for parallelizing CPU and I/O utilization.</p>&#13;
&#13;
<p>For example, imagine that you have an input source, such as a <code>Reader</code> on an input stream, or a listener on a message broker, that provides the inputs for some resource-intensive unit of work. Rather than coupling the input and computation processes, which would confine the effort to a single serial process, you might prefer to parallelize the workload by distributing it among some number of concurrent worker &#13;
<span class="keep-together">processes</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983637703800">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Source</dt>&#13;
<dd>&#13;
<p>An input channel. Accepted by <em>Split</em>.</p>&#13;
</dd>&#13;
<dt>Destinations</dt>&#13;
<dd>&#13;
<p>An output channel of the same type as <em>Source</em>. Created and provided by <em>Split</em>.</p>&#13;
</dd>&#13;
<dt>Split</dt>&#13;
<dd>&#13;
<p>A function that accepts <em>Source</em> and immediately returns <em>Destinations</em>. Any input from <em>Source</em> will be output to a <em>Destination</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983637694568">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>Fan-out may be relatively conceptually straightforward, but the devil is in the details.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Split function" id="ch04_term17"/>Typically, fan-out is implemented as a <em>Split</em> function, which accepts a single <em>Source</em> channel and integer representing the desired number of <em>Destination</em> channels. The <em>Split</em> function creates the <em>Destination</em> channels and executes some background &#13;
<span class="keep-together">process</span> that retrieves values from <em>Source</em> channel and forwards them to one of the &#13;
<span class="keep-together"><em>Destinations</em>.</span></p>&#13;
&#13;
<p class="pagebreak-before less_space">The implementation of the forwarding logic can be done in one of two ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-type="indexterm" data-primary="goroutine" id="idm45983637685624"/>Using a single goroutine that reads values from <em>Source</em> and forwards them to the <em>Destinations</em> in a round-robin fashion. This has the virtue of requiring only one master goroutine, but if the next channel isn’t ready to read yet, it’ll slow the entire process.</p>&#13;
</li>&#13;
<li>&#13;
<p>Using separate goroutines for each <em>Destination</em> that compete to read the next value from <em>Source</em> and forward it to their respective <em>Destination</em>. This requires slightly more resources, but is less likely to get bogged down by a single slow-running worker.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next example uses the latter approach.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983637680536">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>In this example, the <code>Split</code> function accepts a single receive-only channel, <code>source</code>, and an integer describing the number of channels to split the input into, <code>n</code>. It returns a slice of <code>n</code> send-only channels with the same type as <code>source</code>.</p>&#13;
&#13;
<p>Internally, <code>Split</code> creates the destination channels. For each channel created, it executes a goroutine that retrieves values from <code>source</code> in a <code>for</code> loop and forwards them to their assigned output channel. Effectively, each goroutine competes for reads from <code>source</code>; if several are trying to read, the “winner” will be randomly determined. If <code>source</code> is closed, all goroutines terminate and all of the destination channels are closed:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Split</code><code class="p">(</code><code class="nx">source</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">n</code> <code class="kt">int</code><code class="p">)</code> <code class="p">[]</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">dests</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">([]</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>          <code class="c1">// Create the dests slice</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>                <code class="c1">// Create n destination channels</code>&#13;
        <code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code>&#13;
        <code class="nx">dests</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">dests</code><code class="p">,</code> <code class="nx">ch</code><code class="p">)</code>&#13;
&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>                         <code class="c1">// Each channel gets a dedicated</code>&#13;
            <code class="k">defer</code> <code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code>                 <code class="c1">// goroutine that competes for reads</code>&#13;
&#13;
            <code class="k">for</code> <code class="nx">val</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">source</code> <code class="p">{</code>&#13;
                <code class="nx">ch</code> <code class="o">&lt;-</code> <code class="nx">val</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">dests</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Split function" data-startref="ch04_term17" id="idm45983637671368"/>Given a channel of some specific type, the <code>Split</code> function will return a number of destination channels. Typically, each will be passed to a separate goroutine, as demonstrated in the following example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">source</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code>                <code class="c1">// The input channel</code>&#13;
    <code class="nx">dests</code> <code class="o">:=</code> <code class="nx">Split</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>               <code class="c1">// Retrieve 5 output channels</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>                             <code class="c1">// Send the number 1..10 to source</code>&#13;
        <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>          <code class="c1">// and close it when we're done</code>&#13;
            <code class="nx">source</code> <code class="o">&lt;-</code> <code class="nx">i</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nb">close</code><code class="p">(</code><code class="nx">source</code><code class="p">)</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">wg</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code>                   <code class="c1">// Use WaitGroup to wait until</code>&#13;
    <code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">dests</code><code class="p">))</code>                      <code class="c1">// the output channels all close</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">ch</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">dests</code> <code class="p">{</code>&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">(</code><code class="nx">i</code> <code class="kt">int</code><code class="p">,</code> <code class="nx">d</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">defer</code> <code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code>&#13;
&#13;
            <code class="k">for</code> <code class="nx">val</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">d</code> <code class="p">{</code>&#13;
                <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"#%d got %d\n"</code><code class="p">,</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">val</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}(</code><code class="nx">i</code><code class="p">,</code> <code class="nx">ch</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This example creates an input channel, <code>source</code>, which it passes to <code>Split</code> to receive its output channels. Concurrently it passes the values 1 to 10 into <code>source</code> in a goroutine, while receiving values from <code>dests</code> in five others. When the inputs are complete, the <code>source</code> channel is closed, which triggers closures in the output channels, which ends the read loops, which causes <code>wg.Done</code> to be called by each of the read goroutines, which releases the lock on <code>wg.Wait</code>, and allows the function to end.<a data-type="indexterm" data-primary="patterns" data-secondary="fan-out pattern" data-startref="ch04_term16_2" id="idm45983637379528"/><a data-type="indexterm" data-primary="fan-out pattern" data-startref="ch04_term16" id="idm45983637378280"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Future"><div class="sect2" id="idm45983637377336">&#13;
<h2>Future</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="future pattern" id="ch04_term18_2"/><a data-type="indexterm" data-primary="future pattern" id="ch04_term18"/>Future provides a placeholder for a value that’s not yet known.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983637373480">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Promises" data-see="future pattern" id="idm45983637372200"/><a data-type="indexterm" data-primary="Delays" data-see="future pattern" id="idm45983637371224"/>Futures (also known as Promises or Delays<sup><a data-type="noteref" id="idm45983637370152-marker" href="ch04.xhtml#idm45983637370152">4</a></sup>) are a synchronization construct that provide a placeholder for a value that’s still being generated by an asynchronous &#13;
<span class="keep-together">process</span>.</p>&#13;
&#13;
<p>This pattern isn’t used as frequently in Go as in some other languages because channels can be often used in a similar way. For example, the long-running blocking function <code>BlockingInverse</code> (not shown) can be executed in a goroutine that returns the result (when it arrives) along a channel. The <code>ConcurrentInverse</code> function does exactly that, returning a channel that can be read when a result is available:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">ConcurrentInverse</code><code class="p">(</code><code class="nx">m</code> <code class="nx">Matrix</code><code class="p">)</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="nx">Matrix</code> <code class="p">{</code>&#13;
    <code class="nx">out</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="nx">Matrix</code><code class="p">)</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">out</code> <code class="o">&lt;-</code> <code class="nx">BlockingInverse</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>&#13;
        <code class="nb">close</code><code class="p">(</code><code class="nx">out</code><code class="p">)</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">out</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using <code>ConcurrentInverse</code>, one could then build a function to calculate the inverse product of two matrices:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">InverseProduct</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="nx">Matrix</code><code class="p">)</code> <code class="nx">Matrix</code> <code class="p">{</code>&#13;
    <code class="nx">inva</code> <code class="o">:=</code> <code class="nx">ConcurrentInverse</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>&#13;
    <code class="nx">invb</code> <code class="o">:=</code> <code class="nx">ConcurrentInverse</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">Product</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">inva</code><code class="p">,</code> <code class="o">&lt;-</code><code class="nx">invb</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This doesn’t seem so bad, but it comes with some baggage that makes it undesirable for something like a public API. First, the caller has be careful to call &#13;
<span class="keep-together"><code>ConcurrentInverse</code></span> with the correct timing. To see what I mean, take a close look at the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">return</code> <code class="nx">Product</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ConcurrentInverse</code><code class="p">(</code><code class="nx">a</code><code class="p">),</code> <code class="o">&lt;-</code><code class="nx">ConcurrentInverse</code><code class="p">(</code><code class="nx">b</code><code class="p">))</code></pre>&#13;
&#13;
<p>See the problem? Since the computation isn’t started until <code>ConcurrentInverse</code> is actually called, this construct would be effectively executed serially, requiring twice the runtime.</p>&#13;
&#13;
<p>What’s more, when using channels in this way, functions with more than one return value will usually assign a dedicated channel to each member of the return list, which can become awkward as the return list grows or when the values need to be read by more than one goroutine.</p>&#13;
&#13;
<p>The Future pattern contains this complexity by encapsulating it in an API that provides the consumer with a simple interface whose method can be called normally, blocking all calling routines until all of its results are resolved. The interface that the value satisfies doesn’t even have to be constructed specially for that purpose; any interface that’s convenient for the consumer can be used.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983637372888">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>Future</dt>&#13;
<dd>&#13;
<p>The interface that is received by the consumer to retrieve the eventual result.</p>&#13;
</dd>&#13;
<dt>SlowFunction</dt>&#13;
<dd>&#13;
<p>A wrapper function around some function to be asynchronously executed; provides <em>Future</em>.</p>&#13;
</dd>&#13;
<dt>InnerFuture</dt>&#13;
<dd>&#13;
<p>Satisfies the <em>Future</em> interface; includes an attached method that contains the result access logic.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983637168152">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>The API presented to the consumer is fairly straightforward: the programmer calls <em>SlowFunction</em>, which returns a value that satisfies the <em>Future</em> interface. <em>Future</em> may be a bespoke interface, as in the following example, or it may be something more like an <code>io.Reader</code> that can be passed to its own functions.</p>&#13;
&#13;
<p>In actuality, when <em>SlowFunction</em> is called, it executes the core function of interest as a goroutine. In doing so, it defines channels to capture the core function’s output, which it wraps in <em>InnerFuture</em>.</p>&#13;
&#13;
<p><em>InnerFuture</em> has one or more methods that satisfy the <em>Future</em> interface, which retrieve the values returned by the core function from the channels, cache them, and return them. If the values aren’t available on the channel, the request blocks. If they have already been retrieved, the cached values are returned.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983637161752">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p>In this example, we use a <code>Future</code> interface that the <code>InnerFuture</code> will satisfy:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Future</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Result</code><code class="p">()</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>InnerFuture</code> struct is used internally to provide the concurrent functionality. In this example, it satisfies the <code>Future</code> interface, but could just as easily choose to satisfy something like <code>io.Reader</code> by attaching a <code>Read</code> method, for example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">InnerFuture</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">once</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Once</code>&#13;
    <code class="nx">wg</code>   <code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code>&#13;
&#13;
    <code class="nx">res</code>   <code class="kt">string</code>&#13;
    <code class="nx">err</code>   <code class="kt">error</code>&#13;
    <code class="nx">resCh</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">string</code>&#13;
    <code class="nx">errCh</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">error</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">f</code> <code class="o">*</code><code class="nx">InnerFuture</code><code class="p">)</code> <code class="nx">Result</code><code class="p">()</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">f</code><code class="p">.</code><code class="nx">once</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">f</code><code class="p">.</code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
        <code class="k">defer</code> <code class="nx">f</code><code class="p">.</code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code>&#13;
        <code class="nx">f</code><code class="p">.</code><code class="nx">res</code> <code class="p">=</code> <code class="o">&lt;-</code><code class="nx">f</code><code class="p">.</code><code class="nx">resCh</code>&#13;
        <code class="nx">f</code><code class="p">.</code><code class="nx">err</code> <code class="p">=</code> <code class="o">&lt;-</code><code class="nx">f</code><code class="p">.</code><code class="nx">errCh</code>&#13;
    <code class="p">})</code>&#13;
&#13;
    <code class="nx">f</code><code class="p">.</code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">f</code><code class="p">.</code><code class="nx">res</code><code class="p">,</code> <code class="nx">f</code><code class="p">.</code><code class="nx">err</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this implementation, the struct itself contains a channel and a variable for each value returned by the <code>Result</code> method. When <code>Result</code> is first called, it attempts to read the results from the channels and send them back to the <code>InnerFuture</code> struct so that subsequent calls to <code>Result</code> can immediately return the cached values.</p>&#13;
&#13;
<p>Note the use of <code>sync.Once</code> and <code>sync.WaitGroup</code>. The former does what it says on the tin: it ensures that the function that’s passed to it is called exactly once. The <code>WaitGroup</code> is used to make this function call thread safe: any calls after the first will be blocked at <code>wg.Wait</code> until the channel reads are complete.</p>&#13;
&#13;
<p><code>SlowFunction</code> is a wrapper around the core functionality that you want to run concurrently. It has the job of creating the results channels, running the core function in a goroutine, and creating and returning the <code>Future</code> implementation (<code>InnerFuture</code>, in this example):</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">SlowFunction</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="nx">Future</code> <code class="p">{</code>&#13;
    <code class="nx">resCh</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">)</code>&#13;
    <code class="nx">errCh</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">select</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">time</code><code class="p">.</code><code class="nx">After</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code> <code class="o">*</code> <code class="mi">2</code><code class="p">):</code>&#13;
            <code class="nx">resCh</code> <code class="o">&lt;-</code> <code class="s">"I slept for 2 seconds"</code>&#13;
            <code class="nx">errCh</code> <code class="o">&lt;-</code> <code class="kc">nil</code>&#13;
        <code class="k">case</code> <code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code>&#13;
            <code class="nx">resCh</code> <code class="o">&lt;-</code> <code class="s">""</code>&#13;
            <code class="nx">errCh</code> <code class="o">&lt;-</code> <code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">InnerFuture</code><code class="p">{</code><code class="nx">resCh</code><code class="p">:</code> <code class="nx">resCh</code><code class="p">,</code> <code class="nx">errCh</code><code class="p">:</code> <code class="nx">errCh</code><code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before less_space">To make use of this pattern, you need only call the <code>SlowFunction</code> and use the returned <code>Future</code> as you would any other value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">ctx</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">()</code>&#13;
    <code class="nx">future</code> <code class="o">:=</code> <code class="nx">SlowFunction</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">res</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">future</code><code class="p">.</code><code class="nx">Result</code><code class="p">()</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">res</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This approach provides a reasonably good user experience. The programmer can create a <code>Future</code> and access it as they wish, and can even apply timeouts or deadlines with a <code>Context</code>.<a data-type="indexterm" data-primary="patterns" data-secondary="future pattern" data-startref="ch04_term18_2" id="idm45983636718536"/><a data-type="indexterm" data-primary="future pattern" data-startref="ch04_term18" id="idm45983636717320"/><a data-type="indexterm" data-primary="functions" data-startref="ch04_term23" id="idm45983636716376"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Sharding"><div class="sect2" id="section_ch04_sharding">&#13;
<h2>Sharding</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="patterns" data-secondary="sharding" id="ch04_term20_2"/><a data-type="indexterm" data-primary="sharding" id="ch04_term20"/><em>Sharding</em> splits a large data structure into multiple partitions to localize the effects of read/write locks.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Applicability"><div class="sect3" id="idm45983636808744">&#13;
<h3>Applicability</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="horizontal sharding" id="idm45983636807304"/>The term <em>sharding</em> is typically used in the context of distributed state to describe data that is partitioned between server instances. This kind of <em>horizontal sharding</em> is &#13;
<span class="keep-together">commonly</span> used by databases and other data stores to distribute load and provide &#13;
<span class="keep-together">redundancy</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="lock contention" id="idm45983636803768"/>A slightly different issue can sometimes affect highly concurrent services that have a shared data structure with a locking mechanism to protect it from conflicting writes. In this scenario, the locks that serve to ensure the fidelity of the data can also create a bottleneck when processes start to spend more time waiting for locks than they do doing their jobs. This unfortunate phenomenon is called <em>lock contention</em>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="vertical sharding" id="ch04_term21"/>While this might be resolved in some cases by scaling the number of instances, this also increases complexity and latency, because distributed locks need to be established, and writes need to establish consistency. An alternative strategy for reducing lock contention around shared data structures within an instance of a service is <em>vertical sharding</em>, in which a large data structure is partitioned into two or more structures, each representing a part of the whole. Using this strategy, only a portion of the overall structure needs to be locked at a time, decreasing overall lock contention.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before less_space"><div class="sidebar" id="idm45983636799592">&#13;
<h5>Horizontal vs. Vertical Sharding</h5>&#13;
<p>Large data structures can be sharded, or partitioned, in two different ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Horizontal sharding</em> is the partitioning of data across service instances. This can provide data redundancy and allow load to be balanced between instances, but also adds the latency and complexity that comes with distributed data.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Vertical sharding</em> is the partitioning of data within a single instance. This can reduce read/write contention between concurrent processes, but also doesn’t scale or provide any redundancy.</p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Participants"><div class="sect3" id="idm45983636794344">&#13;
<h3>Participants</h3>&#13;
&#13;
<p>This pattern includes the following participants:</p>&#13;
<dl>&#13;
<dt>ShardedMap</dt>&#13;
<dd>&#13;
<p>An abstraction around one or more <em>Shards</em> providing read and write access as if the <em>Shards</em> were a single map.</p>&#13;
</dd>&#13;
<dt>Shard</dt>&#13;
<dd>&#13;
<p>An individually lockable collection representing a single data partition.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementation"><div class="sect3" id="idm45983636788872">&#13;
<h3>Implementation</h3>&#13;
&#13;
<p>While idiomatic Go strongly prefers the use of <a href="https://oreil.ly/BipeP">memory sharing via channels</a> over using locks to protect shared resources,<sup><a data-type="noteref" id="idm45983636786552-marker" href="ch04.xhtml#idm45983636786552">5</a></sup> this isn’t always possible. Maps are particularly unsafe for concurrent use, making the use of locks as a synchronization mechanism a necessary evil. Fortunately, Go provides <code>sync.RWMutex</code> for precisely this purpose.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="locks" id="idm45983636784584"/><code>RWMutex</code> provides methods to establish both read and write locks, as demonstrated in the following. Using this method, any number of processes can establish simultaneous read locks as long as there are no open write locks; a process can establish a write lock only when there are no existing read or write locks. Attempts to establish additional locks will block until any locks ahead of it are released:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">items</code> <code class="p">=</code> <code class="kd">struct</code><code class="p">{</code>                                 <code class="c1">// Struct with a map and a</code>&#13;
    <code class="nx">sync</code><code class="p">.</code><code class="nx">RWMutex</code>                                    <code class="c1">// composed sync.RWMutex</code>&#13;
    <code class="nx">m</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code>&#13;
<code class="p">}{</code><code class="nx">m</code><code class="p">:</code> <code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">ThreadSafeRead</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">items</code><code class="p">.</code><code class="nx">RLock</code><code class="p">()</code>                                   <code class="c1">// Establish read lock</code>&#13;
    <code class="nx">value</code> <code class="o">:=</code> <code class="nx">items</code><code class="p">.</code><code class="nx">m</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>&#13;
    <code class="nx">items</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code>                                 <code class="c1">// Release read lock</code>&#13;
    <code class="k">return</code> <code class="nx">value</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">ThreadSafeWrite</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code> <code class="kt">int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">items</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>                                    <code class="c1">// Establish write lock</code>&#13;
    <code class="nx">items</code><code class="p">.</code><code class="nx">m</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="p">=</code> <code class="nx">value</code>&#13;
    <code class="nx">items</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>                                  <code class="c1">// Release write lock</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This strategy generally works perfectly fine. However, because locks allow access to only one process at a time, the average amount of time spent waiting for locks to clear in a read/write intensive application can increase dramatically with the number of concurrent processes acting on the resource. The resulting lock contention can potentially bottleneck key functionality.</p>&#13;
&#13;
<p>Vertical sharding reduces lock contention by splitting the underlying data structure—usually a map—into several individually lockable maps. An abstraction layer provides access to the underlying shards as if they were a single structure (see <a data-type="xref" href="#vertical-sharding-a-map">Figure 4-5</a>).<a data-type="indexterm" data-primary="vertical sharding" data-startref="ch04_term21" id="idm45983636609880"/></p>&#13;
&#13;
<figure><div id="vertical-sharding-a-map" class="figure">&#13;
<img src="Images/cngo_0405.png" alt="cngo 0405" width="1357" height="923"/>&#13;
<h6><span class="label">Figure 4-5. </span>Vertically sharding a map by key hash</h6>&#13;
</div></figure>&#13;
&#13;
<p>Internally, this is accomplished by creating an abstraction layer around what is essentially a map of maps. Whenever a value is read or written to the map abstraction, a hash value is calculated for the key, which is then modded by the number of shards to generate a shard index. This allows the map abstraction to isolate the necessary locking to only the shard at that index.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Sample code"><div class="sect3" id="idm45983636606088">&#13;
<h3>Sample code</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="ShardedMap" id="ch04_term22"/>In the following example, we use the standard <code>sync</code> and <code>crypto/sha1</code> packages to implement a basic sharded map: <code>ShardedMap</code>.</p>&#13;
&#13;
<p>Internally, <code>ShardedMap</code> is just a slice of pointers to some number of <code>Shard</code> values, but we define it as a type so we can attach methods to it. Each <code>Shard</code> includes &#13;
<span class="keep-together">a <code>map[string]interface{}</code></span> that contains that shard’s data, and a composed &#13;
<span class="keep-together"><code>sync.RWMutex</code></span> so that it can be individually locked:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Shard</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">sync</code><code class="p">.</code><code class="nx">RWMutex</code>                            <code class="c1">// Compose from sync.RWMutex</code>&#13;
    <code class="nx">m</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{}</code>                <code class="c1">// m contains the shard's data</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">ShardedMap</code> <code class="p">[]</code><code class="o">*</code><code class="nx">Shard</code>                    <code class="c1">// ShardedMap is a *Shards slice</code></pre>&#13;
&#13;
<p>Go doesn’t have any concept of constructors, so we provide a <code>NewShardedMap</code> function to retrieve a new <code>ShardedMap</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">NewShardedMap</code><code class="p">(</code><code class="nx">nshards</code> <code class="kt">int</code><code class="p">)</code> <code class="nx">ShardedMap</code> <code class="p">{</code>&#13;
    <code class="nx">shards</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">([]</code><code class="o">*</code><code class="nx">Shard</code><code class="p">,</code> <code class="nx">nshards</code><code class="p">)</code>       <code class="c1">// Initialize a *Shards slice</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="nx">nshards</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
        <code class="nx">shard</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{})</code>&#13;
        <code class="nx">shards</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">Shard</code><code class="p">{</code><code class="nx">m</code><code class="p">:</code> <code class="nx">shard</code><code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">shards</code>                           <code class="c1">// A ShardedMap IS a *Shards slice!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>ShardedMap</code> has two unexported methods, <code>getShardIndex</code> and <code>getShard</code>, which are used to calculate a key’s shard index and retrieve a key’s correct shard, respectively. These could be easily combined into a single method, but slitting them this way makes them easier to test:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">ShardedMap</code><code class="p">)</code> <code class="nx">getShardIndex</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">checksum</code> <code class="o">:=</code> <code class="nx">sha1</code><code class="p">.</code><code class="nx">Sum</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code>   <code class="c1">// Use Sum from "crypto/sha1"</code>&#13;
    <code class="nx">hash</code> <code class="o">:=</code> <code class="nb">int</code><code class="p">(</code><code class="nx">checksum</code><code class="p">[</code><code class="mi">17</code><code class="p">])</code>           <code class="c1">// Pick an arbitrary byte as the hash</code>&#13;
    <code class="k">return</code> <code class="nx">hash</code> <code class="o">%</code> <code class="nb">len</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code>                <code class="c1">// Mod by len(m) to get index</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">ShardedMap</code><code class="p">)</code> <code class="nx">getShard</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code> <code class="o">*</code><code class="nx">Shard</code> <code class="p">{</code>&#13;
    <code class="nx">index</code> <code class="o">:=</code> <code class="nx">m</code><code class="p">.</code><code class="nx">getShardIndex</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nx">m</code><code class="p">[</code><code class="nx">index</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that the previous example has an obvious weakness: because it’s effectively using a <code>byte</code>-sized value as the hash value, it can only handle up to 255 shards. If for some reason you want more than that, you can sprinkle some binary arithmetic on it: <code>hash := int(sum[13]) &lt;&lt; 8 | int(sum[17])</code>.</p>&#13;
&#13;
<p>Finally, we add methods to <code>ShardedMap</code> to allow a user to read and write values. Obviously these don’t demonstrate all of the functionality a map might need. The source for this example is in the GitHub repository associated with this book, however, so please feel free to implement them as an exercise. A <code>Delete</code> and a <code>Contains</code> method would be nice:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">ShardedMap</code><code class="p">)</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code> <code class="kd">interface</code><code class="p">{}</code> <code class="p">{</code>&#13;
    <code class="nx">shard</code> <code class="o">:=</code> <code class="nx">m</code><code class="p">.</code><code class="nx">getShard</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="nx">shard</code><code class="p">.</code><code class="nx">RLock</code><code class="p">()</code>&#13;
    <code class="k">defer</code> <code class="nx">shard</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">shard</code><code class="p">.</code><code class="nx">m</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">ShardedMap</code><code class="p">)</code> <code class="nx">Set</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">{</code>&#13;
    <code class="nx">shard</code> <code class="o">:=</code> <code class="nx">m</code><code class="p">.</code><code class="nx">getShard</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="nx">shard</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
    <code class="k">defer</code> <code class="nx">shard</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
&#13;
    <code class="nx">shard</code><code class="p">.</code><code class="nx">m</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="p">=</code> <code class="nx">value</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you do need to establish locks on all of the tables, it’s generally best to do so concurrently. In the following, we implement a <code>Keys</code> function using goroutines and our old friend <code>sync.WaitGroup</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">ShardedMap</code><code class="p">)</code> <code class="nx">Keys</code><code class="p">()</code> <code class="p">[]</code><code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="nx">keys</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">([]</code><code class="kt">string</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>               <code class="c1">// Create an empty keys slice</code>&#13;
&#13;
    <code class="nx">mutex</code> <code class="o">:=</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">Mutex</code><code class="p">{}</code>                   <code class="c1">// Mutex for write safety to keys</code>&#13;
&#13;
    <code class="nx">wg</code> <code class="o">:=</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="p">{}</code>                  <code class="c1">// Create a wait group and add a</code>&#13;
    <code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">m</code><code class="p">))</code>                          <code class="c1">// wait value for each slice</code>&#13;
&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">shard</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">m</code> <code class="p">{</code>               <code class="c1">// Run a goroutine for each slice</code>&#13;
        <code class="k">go</code> <code class="kd">func</code><code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">Shard</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nx">s</code><code class="p">.</code><code class="nx">RLock</code><code class="p">()</code>                       <code class="c1">// Establish a read lock on s</code>&#13;
&#13;
            <code class="k">for</code> <code class="nx">key</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">s</code><code class="p">.</code><code class="nx">m</code> <code class="p">{</code>          <code class="c1">// Get the slice's keys</code>&#13;
                <code class="nx">mutex</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
                <code class="nx">keys</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">keys</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
                <code class="nx">mutex</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="nx">s</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code>                     <code class="c1">// Release the read lock</code>&#13;
            <code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code>                       <code class="c1">// Tell the WaitGroup it's done</code>&#13;
        <code class="p">}(</code><code class="nx">shard</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code>                               <code class="c1">// Block until all reads are done</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">keys</code>                             <code class="c1">// Return combined keys slice</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using <code>ShardedMap</code> isn’t quite like using a standard map unfortunately, but while it’s different, it’s no more complicated:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">shardedMap</code> <code class="o">:=</code> <code class="nx">NewShardedMap</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="s">"alpha"</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>&#13;
    <code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="s">"beta"</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>&#13;
    <code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="s">"gamma"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"alpha"</code><code class="p">))</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"beta"</code><code class="p">))</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"gamma"</code><code class="p">))</code>&#13;
&#13;
    <code class="nx">keys</code> <code class="o">:=</code> <code class="nx">shardedMap</code><code class="p">.</code><code class="nx">Keys</code><code class="p">()</code>&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">k</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">keys</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">k</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Perhaps the greatest downside of the <code>ShardedMap</code> (besides its complexity, of course) is the loss of type safety associated with the use of <code>interface{}</code>, and the subsequent requirement of type assertions. Hopefully, with the impending release of generics for Go, this will soon be (or perhaps already is, depending on when you read this) a problem of the past!<a data-type="indexterm" data-primary="patterns" data-secondary="sharding" data-startref="ch04_term20_2" id="idm45983636071544"/><a data-type="indexterm" data-primary="sharding" data-startref="ch04_term20" id="idm45983635911848"/><a data-type="indexterm" data-primary="ShardedMap" data-startref="ch04_term22" id="idm45983635910904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983636605464">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter covered quite a few very interesting—and useful—idioms. There are probably many more,<sup><a data-type="noteref" id="idm45983635908552-marker" href="ch04.xhtml#idm45983635908552">6</a></sup> but these are the ones I felt were most important, either because they’re somehow practical in a directly applicable way, or because they showcase some interesting feature of the Go language. Often both.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a> we’ll move on to the next level, taking some of the things we discussed in Chapters <a data-xrefstyle="select:labelnumber" data-type="xref" href="ch03.xhtml#chapter_3">3</a> and <a data-xrefstyle="select:labelnumber" data-type="xref" href="#chapter_4">4</a>, and putting them into practice by building a simple key-value store from scratch!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983640248920"><sup><a href="ch04.xhtml#idm45983640248920-marker">1</a></sup> Spoken August 1979. Attested to by Vicki Almstrum, Tony Hoare, Niklaus Wirth, Wim Feijen, and Rajeev Joshi. In Pursuit of Simplicity: A Symposium Honoring Professor Edsger Wybe Dijkstra, 12–13 May 2000.</p><p data-type="footnote" id="idm45983640246616"><sup><a href="ch04.xhtml#idm45983640246616-marker">2</a></sup> L (yes, his legal name is L) is a brilliant and fascinating human being. Look him up some time.</p><p data-type="footnote" id="idm45983639950216"><sup><a href="ch04.xhtml#idm45983639950216-marker">3</a></sup> Erich Gamma et al. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>, 1st edition. Addison-Wesley Professional, 1994).</p><p data-type="footnote" id="idm45983637370152"><sup><a href="ch04.xhtml#idm45983637370152-marker">4</a></sup> While these terms are often used interchangeably, they can also have shades of meaning depending on their context. I know. Please don’t write me any angry letters about this.</p><p data-type="footnote" id="idm45983636786552"><sup><a href="ch04.xhtml#idm45983636786552-marker">5</a></sup> See the article, “Share Memory By Communicating,” on <em>The Go Blog</em>.</p><p data-type="footnote" id="idm45983635908552"><sup><a href="ch04.xhtml#idm45983635908552-marker">6</a></sup> Did I leave out your favorite? Let me know, and I’ll try to include it in the next edition!</p></div></div></section></div></body></html>