- en: Chapter 11\. Go Tooling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. Go 工具
- en: A programming language doesn’t exist in isolation. For it to be useful, tools
    must help the developer turn source code into an executable. Since Go is intended
    to address the problems that software engineers face today and to help them build
    quality software, careful thought has been put into tooling that simplifies tasks
    that are often difficult with other development platforms. This includes improvements
    in how you build, format, update, validate, and distribute, and even how your
    users will install your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言不是孤立存在的。为了有用，工具必须帮助开发者将源代码转化为可执行文件。由于 Go 旨在解决今天软件工程师面临的问题，并帮助他们构建高质量的软件，因此对简化通常在其他开发平台中困难的任务的工具进行了精心设计。这包括改进构建、格式化、更新、验证和分发的方式，甚至还包括用户如何安装您的代码。
- en: 'I have already covered many of the bundled Go tools: `go vet`, `go fmt`, `go
    mod`, `go get`, `go list`, `go work`, `go doc`, and `go build`. The testing support
    provided by the `go test` tool is so extensive, it is covered by itself in [Chapter 15](ch15.html#unique_chapter_id_15).
    In this chapter, you will explore additional tools that make Go development great,
    both from the Go team and from third parties.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经涵盖了许多捆绑的 Go 工具：`go vet`、`go fmt`、`go mod`、`go get`、`go list`、`go work`、`go
    doc`和`go build`。由`go test`工具提供的测试支持非常广泛，它在[第15章](ch15.html#unique_chapter_id_15)中单独进行了介绍。在本章中，您将探索使
    Go 开发变得出色的其他工具，无论是来自 Go 团队还是第三方。
- en: Using go run to Try Out Small Programs
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`go run`来尝试小程序
- en: 'Go is a compiled language, which means that before Go code is run, it must
    be converted into an executable file. This is in contrast to interpreted languages
    like Python or JavaScript, which allow you to write a quick script to test an
    idea and execute it immediately. Having that rapid feedback cycle is important,
    so Go provides similar functionality via the `go run` command. It builds and executes
    a program in one step. Let’s go back to the first program from [Chapter 1](ch01.html#unique_chapter_id_01).
    Put it in a file called *hello.go*:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种编译语言，这意味着在运行 Go 代码之前，它必须被转换成可执行文件。这与像 Python 或 JavaScript 这样的解释语言形成对比，后者允许您编写一个快速脚本来测试一个想法并立即执行它。拥有快速反馈循环非常重要，因此
    Go 通过`go run`命令提供类似的功能。它一步构建和执行程序。让我们回到[第1章](ch01.html#unique_chapter_id_01)的第一个程序。把它放在名为*hello.go*的文件中：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (You can also find this code in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)
    in the *sample_code/gorun* directory.)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: (你也可以在[第11章的代码库](https://oreil.ly/Z_Fpg)的*sample_code/gorun*目录中找到这段代码。)
- en: 'Once the file is saved, use the `go run` command to build and execute it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件保存，使用`go run`命令构建并执行它：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you look inside the directory after running the `go run` command, you see
    that no binary has been saved there; the only file in the directory is the *hello.go*
    file you just created. Where did the executable go (no pun intended)?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`go run`命令后，查看目录中，你会发现没有保存任何二进制文件；目录中唯一的文件是你刚创建的*hello.go*文件。可执行文件去哪了（无意冒犯）？
- en: The `go run` command does, in fact, compile your code into a binary. However,
    the binary is built in a temporary directory. The `go run` command builds the
    binary, executes the binary from that temporary directory, and then deletes the
    binary after your program finishes. This makes the `go run` command useful for
    testing out small programs or using Go like a scripting language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run`命令实际上确实将您的代码编译成一个二进制文件。但是，该二进制文件是在临时目录中构建的。`go run`命令会构建该二进制文件，从该临时目录执行该二进制文件，然后在程序完成后删除该二进制文件。这使得`go
    run`命令非常适合测试小程序或像使用脚本语言一样使用 Go。'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `go run` when you want to treat a Go program like a script and run the source
    code immediately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望像运行脚本一样运行 Go 程序并立即执行源代码时，请使用`go run`。
- en: Adding Third-Party Tools with go install
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`go install`添加第三方工具
- en: While some people choose to distribute their Go programs as precompiled binaries,
    tools written in Go can also be built from source and installed on your computer
    via the `go install` command.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人选择将他们的 Go 程序作为预编译的二进制文件分发，但是用 Go 编写的工具也可以从源代码构建并通过`go install`命令安装到您的计算机上。
- en: As you saw in [“Publishing Your Module”](ch10.html#publish_module), Go modules
    are identified via their source code repositories. The `go install` command takes
    an argument, which is the path to the main package in a module’s source code repository,
    followed by an `@` and the version of the tool you want (if you just want to get
    the latest version, use `@latest`). It then downloads, compiles, and installs
    the tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[“发布您的模块”](ch10.html#publish_module)中看到的，Go模块通过其源代码存储库进行标识。`go install`命令接受一个参数，即模块源代码存储库中主包的路径，后跟`@`及您想要的工具版本（如果只想获取最新版本，请使用`@latest`）。然后它会下载、编译并安装该工具。
- en: Warning
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Always be sure to include the `@version` or `@latest` after the name of the
    package that you are installing! If you don’t, it triggers a variety of confusing
    behaviors and is almost certainly not what you want to do. You either get an error
    message (if the current directory is not in a module, or if the current directory
    is a module, but the package isn’t referenced in the module’s *go.mod* file),
    or it installs the package version mentioned in *go.mod*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必在包名后面包含`@version`或`@latest`！如果不这样做，将触发各种令人困惑的行为，几乎肯定不是您想要的结果。如果当前目录不在模块中，或者当前目录是模块但模块的*go.mod*文件中没有引用该包，您会收到错误消息，或者安装*go.mod*文件中提到的包版本。
- en: By default, `go install` places binaries into the *go/bin* directory within
    your home directory. Set the *GOBIN* environment variable to change this location.
    It is strongly recommended that you add the `go install` directory to your executable
    search path (this is done by modifying the *PATH* environment variable on both
    Unix and Windows). For simplicity, all the examples in this chapter assume that
    you’ve added this directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`go install`将二进制文件放置在您的主目录中的*go/bin*目录中。设置*GOBIN*环境变量以更改此位置是强烈推荐的。建议您将`go
    install`目录添加到可执行搜索路径中（这可以通过修改Unix和Windows上的*PATH*环境变量来完成）。为简单起见，本章中的所有示例假定您已添加了此目录。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Other environment variables are recognized by the `go` tool. You can get a complete
    list, along with a brief description of each variable, using the `go help environment`
    command. Many of them control low-level behavior that can be safely ignored. I’ll
    point out the relevant ones as needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其他环境变量由`go`工具识别。您可以使用`go help environment`命令获取完整的列表，以及每个变量的简要描述。其中许多控制低级行为，可以安全地忽略。在需要时，我会指出相关的变量。
- en: Some online resources tell you to set the `GOROOT` or `GOPATH` environment variables.
    `GOROOT` specifies the location where your Go development environment is installed,
    and `GOPATH` was used to store all Go source code, both your own and third-party
    dependencies. Setting these variables is no longer necessary; the `go` tool figures
    out `GOROOT` automatically, and `GOPATH`-based development has been superseded
    by modules.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线资源告诉您设置`GOROOT`或`GOPATH`环境变量。`GOROOT`指定安装Go开发环境的位置，而`GOPATH`用于存储所有Go源代码，包括您自己的和第三方依赖项。设置这些变量已不再必要；`go`工具会自动确定`GOROOT`，并且基于`GOPATH`的开发已被模块取代。
- en: 'Let’s look at a quick example. Jaana Dogan created a great Go tool called `hey`
    that load tests HTTP servers. You can point it at the website of your choosing
    or an application that you’ve written. Here’s how to install `hey` with the `go
    install` command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个快速的例子。Jaana Dogan 创建了一个名为`hey`的出色的Go工具，用于对HTTP服务器进行负载测试。您可以将其指向您选择的网站或您编写的应用程序。以下是使用`go
    install`命令安装`hey`的方法：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This downloads `hey` and all its dependencies, builds the program, and installs
    the binary in your Go binary directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`hey`及其所有依赖项，构建程序并将二进制文件安装到您的Go二进制目录中。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As I covered in [“Module Proxy Servers”](ch10.html#proxy_server), the contents
    of Go repositories are cached in proxy servers. Depending on the repository and
    the values in your `GOPROXY` environment variable, `go install` may download from
    a proxy or directly from a repository. If `go install` downloads directly from
    a repository, it relies on command-line tools being installed on your computer.
    For example, you must have Git installed to download from GitHub.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“模块代理服务器”](ch10.html#proxy_server)中介绍的，Go存储库的内容被缓存在代理服务器中。根据`GOPROXY`环境变量中的存储库和值，`go
    install`可能会从代理服务器下载或直接从存储库下载。如果`go install`直接从存储库下载，则依赖于您计算机上已安装的命令行工具。例如，要从GitHub下载，必须安装Git。
- en: 'Now that you have built and installed `hey`, you can run it with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经构建并安装了`hey`，您可以使用以下命令运行它：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you have already installed a tool and want to update it to a newer version,
    rerun `go install` with the newer version specified or with `@latest`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了某个工具并希望将其更新到新版本，请使用指定的更高版本或使用 `@latest` 重新运行 `go install`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Of course, you don’t need to leave programs installed via `go install` in the
    *go/bin* directory; they are regular executable binaries and can be stored anywhere
    on your computer. Likewise, you don’t have to distribute programs written in Go
    using `go install`; you can put a binary up for download. However, `go install`
    is convenient for Go developers, and it has become the method of choice for distributing
    third-party developer tools.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必将通过 `go install` 安装的程序留在 *go/bin* 目录中；它们是常规的可执行二进制文件，可以存储在计算机上的任何位置。同样，您不必使用
    `go install` 分发用 Go 编写的程序；您可以提供一个可下载的二进制文件。但是，`go install` 对于 Go 开发者来说非常方便，已成为分发第三方开发者工具的首选方法。
- en: Improving Import Formatting with goimports
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `goimports` 改善导入格式
- en: An enhanced version of `go fmt` called `goimports` also cleans up your import
    statements. It puts them in alphabetical order, removes unused imports, and attempts
    to guess any unspecified imports. Its guesses are sometimes inaccurate, so you
    should insert imports yourself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`go fmt` 的增强版本 `goimports` 还可以清理您的导入语句。它会按字母顺序排列它们，删除未使用的导入，并尝试猜测任何未指定的导入。它的猜测有时不准确，因此您应该自己插入导入。'
- en: 'You can download `goimports` with the command `go install golang.org/x/tools/cmd/goimports@latest`.
    You run it across your project with this command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令 `go install golang.org/x/tools/cmd/goimports@latest` 下载 `goimports`。使用以下命令在您的项目中运行它：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `-l` flag tells `goimports` to print the files with incorrect formatting
    to the console. The `-w` flag tells `goimports` to modify the files in place.
    The `.` specifies the files to be scanned: everything in the current directory
    and all its subdirectories.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-l` 标志告诉 `goimports` 将格式不正确的文件打印到控制台。使用 `-w` 标志告诉 `goimports` 在原地修改文件。`.`
    指定要扫描的文件：当前目录及其所有子目录中的所有内容。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The packages under `golang.org/x` are part of the Go Project but outside the
    main Go tree. While useful, they are developed under looser compatibility requirements
    than the Go standard library and may introduce backward-breaking changes. Some
    packages in the standard library, such as the context package that is covered
    in [Chapter 14](ch14.html#unique_chapter_id_14), started out in `golang.org/x`.
    The `pkgsite` tool that was covered in [“Documenting Your Code with Go Doc Comments”](ch10.html#godoc)
    is also located there. You can see the other packages in the [“Sub-repositories”
    section](https://oreil.ly/tuROf).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang.org/x` 下的包是 Go 项目的一部分，但位于主 Go 树之外。尽管有用，它们的开发与 Go 标准库相比遵循更宽松的兼容性要求，可能会引入向后不兼容的更改。一些标准库中的包，例如
    [第 14 章](ch14.html#unique_chapter_id_14) 中介绍的 context 包，最初就是从 `golang.org/x` 开始的。[“使用
    Go Doc 注释文档化您的代码”](ch10.html#godoc) 中涵盖的 `pkgsite` 工具也位于此处。您可以在 [“子仓库” 部分](https://oreil.ly/tuROf)
    查看其他包。'
- en: Using Code-Quality Scanners
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码质量扫描工具
- en: Back in [“go vet”](ch01.html#go_vet), you looked at the built-in tool `go vet`,
    which scans source code for common programming errors. Many third-party tools
    can check code style and scan for potential bugs that are missed by `go vet`.
    These tools are often called *linters*.^([1](ch11.html#id2291)) In addition to
    likely programming errors, some of the changes suggested by these tools include
    properly naming variables, formatting error messages, and placing comments on
    public methods and types. These aren’t errors since they don’t keep your programs
    from compiling or make your program run incorrectly, but they do flag situations
    where you are writing nonidiomatic code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[“go vet”](ch01.html#go_vet)，你使用了内置工具 `go vet`，它扫描源代码以查找常见的编程错误。许多第三方工具可以检查代码风格并扫描可能被
    `go vet` 忽略的潜在错误。这些工具通常称为*代码检查器*。^([1](ch11.html#id2291)) 除了可能的编程错误外，这些工具建议的一些更改包括正确命名变量、格式化错误消息以及在公共方法和类型上放置注释。这些不是错误，因为它们不会阻止程序编译或使程序运行不正确，但它们会标记编写非惯用代码的情况。
- en: When you add linters to your build process, follow the old maxim “trust, but
    verify.” Since the kinds of issues that linters find are fuzzier, they sometimes
    have false positives and false negatives. This means you don’t *have* to make
    the changes that they suggest, but you should take the suggestions seriously.
    Go developers expect code to look a certain way and follow certain rules, and
    if your code does not, it sticks out.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将代码检查器添加到构建过程中时，请遵循旧的格言“信任，但验证”。由于代码检查器发现的问题类型更加模糊，它们有时会产生误报和漏报。这意味着您不一定需要按照它们的建议进行更改，但您应该认真对待这些建议。Go开发人员期望代码看起来某种方式并遵循某些规则，如果您的代码不符合这些规则，它就会显得突兀。
- en: If you find a linter’s suggestion to be unhelpful, each linting tool allows
    you to add a comment to your source code that blocks the errant result (the format
    of the comment varies from linter to linter; check each tool’s documentation to
    learn what to write). Your comment should also include an explanation of why you
    are ignoring the linter’s finding, so code reviewers (and future you, when you
    look back on your source code in six months) understand your reasoning.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为代码检查器的建议不实用，每个代码检查工具都允许您向源代码添加一个注释来阻止错误结果（注释的格式因检查工具而异，请查阅每个工具的文档了解应写入的内容）。您的注释还应包括为何忽略检查工具发现的原因，以便代码审查人员（以及未来的您，在六个月后回顾源代码时）能够理解您的推理。
- en: staticcheck
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: staticcheck
- en: If you had to pick one third-party scanner, use [`staticcheck`](https://oreil.ly/ky8ZD).
    It is supported by many companies that are active in the Go community, includes
    more than 150 code-quality checks, and tries to produce few to no false positives.
    It is installed via `go install honnef.co/go/tools/cmd/staticcheck@latest`. Invoke
    it with `staticcheck ./...` to examine your module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须选择一个第三方扫描程序，请使用[`staticcheck`](https://oreil.ly/ky8ZD)。它得到了许多活跃于Go社区的公司的支持，包括超过150种代码质量检查，并且尽可能少产生误报。您可以通过`go
    install honnef.co/go/tools/cmd/staticcheck@latest`安装它。使用`staticcheck ./...`来检查您的模块。
- en: 'Here’s an example of something that `staticcheck` finds that `go vet` does
    not:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`staticcheck`发现的一个示例，而`go vet`没有找到：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (You can also find this code in the *sample_code/staticcheck_test* directory
    in the [Chapter 11 repository](https://oreil.ly/Z_Fpg).)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (您还可以在[第11章存储库](https://oreil.ly/Z_Fpg)中的*sample_code/staticcheck_test*目录找到此代码。)
- en: 'If you run `go vet` on this code, it doesn’t find anything wrong. But, `staticcheck`
    notices a problem:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此代码上运行`go vet`，它不会发现任何问题。但是，`staticcheck`注意到了一个问题：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Pass the code in parentheses to `staticcheck` with the `-explain` flag for
    an explanation of the issue:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将带括号的代码传递给`staticcheck`时使用`-explain`标志以解释该问题：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another common issue that `staticcheck` finds is unused assignments to variables.
    While the Go compiler requires all variables to be read *once*, it doesn’t check
    that *every* value assigned to a variable is read. It is a common practice to
    reuse an `err` variable when there are multiple function calls within a function.
    If you forget to write `if err != nil` after one of those function invocations,
    the compiler won’t be able to help you. However, `staticcheck` can. This code
    compiles without a problem:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`staticcheck`发现的另一个常见问题是对变量的未使用赋值。虽然Go编译器要求所有变量至少读取一次，但它不检查对变量赋值的每一个值是否都被读取。在函数内部有多个函数调用时，重复使用`err`变量是常见的做法。如果在其中一个函数调用后忘记写`if
    err != nil`，编译器将无法帮助您。但是，`staticcheck`可以。这段代码编译没有问题：'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (This code is in the [Chapter 11 repository](https://oreil.ly/Z_Fpg) in the
    *sample_code/check_err* directory.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (此代码位于[第11章存储库](https://oreil.ly/Z_Fpg)中的*sample_code/check_err*目录。)
- en: 'Running `staticcheck` finds the mistake:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`staticcheck`发现了这个错误：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are two related issues on line 13\. The first is that the error returned
    by `returnErr` is never read. The second is that the `returnErr` function’s output
    (the error) is being ignored.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第13行存在两个相关问题。首先，`returnErr`返回的错误没有被读取。其次，`returnErr`函数的输出（即错误）被忽略了。
- en: revive
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: revive
- en: Another good linting option is [`revive`](https://revive.run). It is based on
    `golint`, a tool that used to be maintained by the Go team. Install `revive` with
    the command `go install github.com/mgechev/revive@latest`. By default, it enables
    only the rules that were present in `golint`. It can find style and code-quality
    issues like exported identifiers that don’t have comments, variables that don’t
    follow naming conventions, or error return values that aren’t the last return
    value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的lint选项是[`revive`](https://revive.run)。它基于`golint`，这是Go团队曾经维护的一个工具。使用命令`go
    install github.com/mgechev/revive@latest`安装`revive`。默认情况下，它仅启用了`golint`中存在的规则。它可以发现像没有注释的导出标识符、不遵循命名约定的变量或不是最后一个返回值的错误返回值等风格和代码质量问题。
- en: 'With a configuration file, you can turn on many more rules. For example, to
    enable a check for shadowing of universe block identifiers, create a file named
    *built_in.toml* with the following contents:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件，您可以启用更多规则。例如，要启用检查宇宙块标识符屏蔽的检查，请创建名为*built_in.toml*的文件，并包含以下内容：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you scan the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扫描以下代码：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'you’ll get this warning:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到此警告：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (You can also find this code in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)
    in the *sample_code/revive_test* directory.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （您也可以在[第11章代码库](https://oreil.ly/Z_Fpg)的*sample_code/revive_test*目录中找到这段代码。）
- en: Other rules that can be enabled are focused on opinionated code organization,
    like limiting the number of lines in a function or number of public structs in
    a file. There are even rules for evaluating the complexity of the logic in a function.
    Check out the [`revive` documentation](https://oreil.ly/WGY9S) and its [supported
    rules](https://revive.run/r).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另外可以启用的规则专注于代码组织的看法，如限制函数中的行数或文件中的公共结构数量。甚至有用于评估函数逻辑复杂性的规则。查看[`revive`文档](https://oreil.ly/WGY9S)及其[支持的规则](https://revive.run/r)。
- en: golangci-lint
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: golangci-lint
- en: Finally, if you’d rather take the buffet approach to tool selection, there’s
    [`golangci-lint`](https://oreil.ly/p9BH4). It is designed to make it as efficient
    as possible to configure and run over 50 code-quality tools, including `go vet`,
    `staticcheck`, and `revive`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用自助餐方式选择工具，可以考虑使用[`golangci-lint`](https://oreil.ly/p9BH4)。它旨在尽可能高效地配置和运行超过50个代码质量工具，包括`go
    vet`、`staticcheck`和`revive`。
- en: 'While you can use `go install` to install `golangci-lint`, it is recommended
    that you download a binary version instead. Follow the installation instructions
    on the [website](https://oreil.ly/IKa_S). Once it is installed, you run `golangci-lint`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用`go install`来安装`golangci-lint`，但建议您下载二进制版本。按照[网站](https://oreil.ly/IKa_S)上的安装说明操作。安装完成后，运行`golangci-lint`：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Back in [“Unused Variables”](ch02.html#unused_vars_section), you looked at
    a program with variables set to values that were never read, and I mentioned that
    `go vet` and the go compiler were unable to detect these issues. Neither `staticcheck`
    nor `revive` catches this problem. However, one of the tools bundled with `golangci-lint`
    does:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“未使用的变量”](ch02.html#unused_vars_section)中，您看到了一个将变量设置为从未读取过的值的程序，我提到`go vet`和Go编译器无法检测到这些问题。`staticcheck`和`revive`也都无法捕捉到这个问题。然而，`golangci-lint`捆绑的工具之一可以：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also use `golangci-lint` to provide shadowing checks that go beyond
    what `revive` can do. Configure `golangci-lint` to detect shadowing of both universe
    block identifiers and identifiers within your own code by putting the following
    configuration into a file named *.golangci.yml* in the directory where you run
    `golangci-lint`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`golangci-lint`提供的屏蔽检查功能，这超出了`revive`的能力。通过在运行`golangci-lint`的目录中创建名为*.golangci.yml*的文件，配置`golangci-lint`来检测自己代码中的宇宙块标识符和标识符的屏蔽：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these settings, running `golangci-lint` on this code
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，在此代码上运行`golangci-lint`
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'detects the following issues:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到以下问题：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (You can find both `golangci-lint` code samples in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)
    in the *sample_code/golangci-lint_test* directory.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: （您可以在[第11章代码库](https://oreil.ly/Z_Fpg)的*sample_code/golangci-lint_test*目录中找到`golangci-lint`的代码示例。）
- en: Because `golangci-lint` runs so many tools (as of this writing, it runs 7 different
    tools by default and allows you to enable more than 50 more), it’s inevitable
    that your team may disagree with some of its suggestions. Review the [documentation](https://oreil.ly/L_mH4)
    to understand what each tool can do. Once you come to agreement on which linters
    to enable, update the *.golangci.yml* file at the root of your module and commit
    it to source control. Check out the [documentation](https://oreil.ly/vufj1) for
    the file format.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`golangci-lint`运行了很多工具（截至目前为止，默认运行了7种不同的工具，并允许你启用超过50种工具），你的团队可能会对它的一些建议持不同意见。查阅[文档](https://oreil.ly/L_mH4)以了解每个工具的功能。一旦达成对启用哪些检查器达成一致意见，请更新你模块根目录下的*.golangci.yml*文件，并提交到源代码控制。查看文件格式的[文档](https://oreil.ly/vufj1)。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While `golangci-lint` allows you to have a configuration file in your home directory,
    don’t put one there if you are working with other developers. Unless you enjoy
    adding hours of silly arguments to your code reviews, you want to make sure that
    everyone is using the same code-quality tests and formatting rules.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`golangci-lint`允许你在家目录下拥有配置文件，但是如果你与其他开发人员一起工作，不要把它放在那里。除非你喜欢在代码审查中添加数小时的愚蠢争论，你要确保每个人都使用相同的代码质量测试和格式化规则。
- en: I recommend that you start using `go vet` as a required part of your automated
    build process. Add `staticcheck` next since it produces few false positives. When
    you are interested in configuring tools and setting code-quality standards, look
    at `revive`, but be aware that it might have false positives and false negatives,
    so you can’t require your team to fix every issue it reports. Once you are used
    to their recommendations, try out `golangci-lint` and tweak its settings until
    it works for your team.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你开始将`go vet`作为自动化构建流程的必需部分。接下来添加`staticcheck`，因为它几乎不会产生误报。当你对配置工具和设置代码质量标准感兴趣时，看看`revive`，但要注意它可能存在误报和漏报，所以你不能要求你的团队修复它报告的每个问题。一旦习惯了它们的建议，尝试使用`golangci-lint`并调整其设置，直到适合你的团队。
- en: Using govulncheck to Scan for Vulnerable Dependencies
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用govulncheck扫描易受攻击的依赖关系
- en: 'One kind of code quality isn’t enforced by the tools you’ve looked at so far:
    software vulnerabilities. Having a rich ecosystem of third-party modules is fantastic,
    but clever hackers find security vulnerabilities in libraries and exploit them.
    Developers patch these bugs when they are reported, but how do you ensure that
    the software that uses a vulnerable version of a library is updated to the fixed
    version?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你看到的工具没有强制执行一种代码质量：软件漏洞。拥有丰富的第三方模块生态系统非常棒，但是聪明的黑客会在库中找到安全漏洞并加以利用。开发人员在报告这些漏洞时修补它们，但是如何确保使用受影响版本库的软件更新到修复版本呢？
- en: 'The Go team has released a tool called `govulncheck` to address this situation.
    It scans through your dependencies and finds known vulnerabilities in both the
    standard library and in third-party libraries imported into your module. These
    vulnerabilities are reported in a [public database](https://oreil.ly/dffxM) maintained
    by the Go team. You can install it with this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Go团队发布了一个名为`govulncheck`的工具来解决这个问题。它扫描你的依赖关系，并查找已知的漏洞，包括标准库和导入到你模块中的第三方库。这些漏洞在Go团队维护的[公共数据库](https://oreil.ly/dffxM)中报告。你可以通过以下方式安装它：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s take a look at a small program to see the vulnerability checker in action.
    First, download the [repository](https://oreil.ly/TcwW8). The source code in *main.go*
    is very simple. It imports a third-party YAML library and uses it to load a small
    YAML string into a struct:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个小程序，看看漏洞检查器是如何运行的。首先，下载[存储库](https://oreil.ly/TcwW8)。*main.go*中的源代码非常简单。它导入了一个第三方YAML库，并使用它将一个小的YAML字符串加载到一个结构体中：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *go.mod* file contains the required modules and their versions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*go.mod*文件包含了所需的模块及其版本：'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s see what happens when you run `govulncheck` on this project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在这个项目上运行`govulncheck`时会发生什么：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This module is using an old and vulnerable version of the YAML package. `govulncheck`
    helpfully gives the exact line in the codebase that calls the problematic code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块使用了一个旧版且易受攻击的YAML包。`govulncheck`贴心地给出了调用有问题代码的确切代码行。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If `govulncheck` knows there a vulnerability in a module that your code uses,
    but can’t find an explicit call to the buggy part of the module, you’ll get a
    less severe warning. The message informs you of the library’s vulnerability and
    what version resolves the issue, but it will also let you know that your module
    is likely not affected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `govulncheck` 知道你的代码使用了某个模块中的漏洞，但无法找到明确调用模块中有问题的部分，那么会收到较轻微的警告。该消息会告知你库的漏洞及解决问题的版本，但还会指出你的模块可能不受影响。
- en: 'Let’s update to a fixed version and see if that solves the problem:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们升级到一个修复版本，并查看是否解决了问题：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember, you should always strive for the smallest possible change to your
    project’s dependencies since that makes it less likely that a change in a dependency
    breaks your code. For that reason, update to the most recent patch version for
    v2.2.*x*, which is v2.2.8\. When `govulncheck` is run again, there are no known
    issues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，应始终力求对项目依赖进行尽可能小的更改，因为这样可以减少依赖变更导致代码出现问题的可能性。因此，请升级到最新的 v2.2.*x* 补丁版本，即 v2.2.8\.
    当再次运行 `govulncheck` 时，不会出现已知问题。
- en: While `govulncheck` currently requires a `go install` to download it, it likely
    will be added to the standard toolset eventually. In the meantime, be sure to
    install and run it against your projects as a regular part of your builds. You
    can learn more about it in the [blog post](https://oreil.ly/uR09p) that announced
    it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，`govulncheck` 需要进行 `go install` 才能下载，但很可能最终会添加到标准工具集中。与此同时，确保在构建过程中像常规一样安装并运行它以检查你的项目。你可以在宣布它的[博客文章](https://oreil.ly/uR09p)中了解更多信息。
- en: Embedding Content into Your Program
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内容嵌入到您的程序中
- en: 'Many programs are distributed with directories of support files; you might
    have web page templates or some standard data that’s loaded when a program starts.
    If a Go program needs support files, you could include a directory of files, but
    this takes away one of the advantages of Go: its ability to compile to a single
    binary that’s easy to ship and distribute. However, there’s another option. You
    can embed the contents of the files within your Go binary by using `go:embed`
    comments.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序分发时都带有支持文件目录；可能是网页模板或程序启动时加载的标准数据。如果 Go 程序需要支持文件，你可以包含一个文件目录，但这会削弱 Go 的一个优点：将代码编译为单个易于分发的二进制文件。不过，还有另一种选择。你可以通过使用
    `go:embed` 注释将文件内容嵌入到你的 Go 二进制文件中。
- en: You can find a program demonstrating embedding on GitHub in the *sample_code/embed_passwords*
    directory in the [Chapter 11 repository](https://oreil.ly/Z_Fpg). It checks to
    see if a password is one of the 10,000 most commonly used passwords. Rather than
    write that list of passwords directly into the source code, you’re going to embed
    it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 的 *sample_code/embed_passwords* 目录中可以找到演示嵌入的程序，该程序检查密码是否是最常用的 10,000
    个密码之一。你不会直接将密码列表写入源代码，而是将其嵌入。
- en: 'The code in *main.go* is straightforward:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.go* 中的代码很简单：'
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You must do two things to enable embedding. First, the `embed` package must
    be imported. The Go compiler uses this import as a flag to indicate that embedding
    should be enabled. Because this sample code isn’t referring to anything exported
    from the `embed` package, you use a blank import, which was discussed in [“Avoiding
    the init Function if Possible”](ch10.html#pkg_init). The only symbol exported
    from `embed` is `FS`. You’ll see it in the next example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用嵌入，必须执行两个操作。首先，必须导入 `embed` 包。Go 编译器使用此导入作为指示启用嵌入的标志。因为这段示例代码并未引用 `embed`
    包中导出的任何内容，你可以使用空白导入，这在 [“尽量避免 init 函数”](ch10.html#pkg_init) 中有讨论。`embed` 包中唯一导出的符号是
    `FS`，你将在下一个示例中看到它。
- en: Next, you place a magic comment directly before each package-level variable
    that holds the contents of a file. This comment must start with `go:embed`, with
    no space between the slashes and `go:embed`. The comment must also be on the line
    directly before the variable. (Technically, it is legal to have blank lines or
    other, nonmagic comments between the embedding comment and the variable declaration,
    but don’t do it.) In this sample, you are embedding the contents of *passwords.txt*
    into the package-level variable named `passwords`. It is idiomatic to treat a
    variable with an embedded value as immutable. As mentioned earlier, you can embed
    into only a package-level variable. The variable must be of type `string`, `[]byte`,
    or `embed.FS`. If you have a single file, it’s simplest to use `string` or `[]byte`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在每个保存文件内容的包级变量前直接放置一个魔法注释。这个注释必须以`go:embed`开头，斜线和`go:embed`之间不能有空格。该注释还必须直接在变量声明的前一行。在这个示例中，你将*passwords.txt*的内容嵌入到名为`passwords`的包级变量中。习惯上，将包含嵌入值的变量视为不可变。正如前面提到的，你只能嵌入到包级变量中。变量必须是`string`、`[]byte`或`embed.FS`类型。如果只有一个文件，使用`string`或`[]byte`是最简单的。
- en: 'If you need to place one or more directories of files into your program, use
    a variable of type `embed.FS`. This type implements three interfaces defined in
    the `io/fs` package: `FS`, `ReadDirFS`, and `ReadFileFS`. This allows an instance
    of `embed.FS` to represent a virtual filesystem. The following program provides
    a simple command-line help system. If you don’t provide a help file, it lists
    all available files. If you specify a file that’s not present, it returns an error:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将一个或多个目录的文件放入程序中，请使用`embed.FS`类型的变量。此类型实现了`io/fs`包中定义的三个接口：`FS`、`ReadDirFS`和`ReadFileFS`。这允许`embed.FS`的实例表示一个虚拟文件系统。下面的程序提供了一个简单的命令行帮助系统。如果没有提供帮助文件，它会列出所有可用的文件。如果指定了一个不存在的文件，则返回错误消息。
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can find this code, along with the sample help files, in the *sample_code/help_system*
    directory in the [Chapter 11 repository](https://oreil.ly/Z_Fpg).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第11章代码库](https://oreil.ly/Z_Fpg)的*sample_code/help_system*目录中找到此代码和示例帮助文件。
- en: 'Here’s the output when you build and run this program:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建和运行此程序时，输出如下：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You should notice a couple of things. First, you no longer need to use a blank
    import for `embed`, since you are using `embed.FS`. Second, the directory name
    is part of the filesystem that’s embedded. The users of this program don’t enter
    the “help/” prefix, so you have to prepend it in the call to `ReadFile`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到一些事情。首先，你不再需要为`embed`使用空白导入，因为你正在使用`embed.FS`。其次，目录名称是嵌入的文件系统的一部分。这个程序的用户不输入“help/”前缀，因此你必须在调用`ReadFile`时预先添加它。
- en: 'The `printHelpFiles` function shows how you can treat an embedded virtual filesystem
    just like a real one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`printHelpFiles`函数展示了如何像处理真实文件系统一样处理嵌入的虚拟文件系统：'
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You use the `WalkDir` function in `io/fs` to walk through the embedded filesystem.
    `WalkDir` takes in an instance of `fs.FS`, a path to start at, and a function.
    This function is called for every file and directory in the filesystem, starting
    from the specified path. If the `fs.DirEntry` is not a directory, you print out
    its full pathname, removing the `help/` prefix by using `strings.Cut`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`io/fs`中的`WalkDir`函数来遍历嵌入式文件系统。`WalkDir`接受一个`fs.FS`实例，一个起始路径和一个函数。这个函数会在文件系统中的每个文件和目录上被调用，从指定的路径开始。如果`fs.DirEntry`不是一个目录，你会打印出它的完整路径名，并通过使用`strings.Cut`来去掉`help/`前缀。
- en: There are a few more things to know about file embedding. While all the examples
    have been text files, you can embed binary files as well. You can also embed multiple
    files or directories into a single `embed.FS` variable by specifying their names,
    separated by spaces. When embedding a file or directory that has a space in its
    name, put the name in quotes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件嵌入还有一些需要了解的事情。尽管所有的示例都是文本文件，你也可以嵌入二进制文件。你还可以通过将它们的名称用空格分隔来将多个文件或目录嵌入到单个`embed.FS`变量中。当嵌入一个文件或目录的名称中含有空格时，请将名称放在引号中。
- en: In addition to exact file and directory names, you can use wildcards and ranges
    to specify the names of the files and directories you want to embed. The syntax
    is defined in the [documentation for the Match function in the `path` package
    in the standard library](https://oreil.ly/BQTEX), but it follows common conventions.
    For example, `*` matches 0 or more characters, and `?` matches a single character.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了精确的文件和目录名外，你还可以使用通配符和范围来指定你想要嵌入的文件和目录的名称。语法在标准库中的 `path` 包的 [Match 函数文档](https://oreil.ly/BQTEX)
    中定义，但遵循常见约定。例如，`*` 匹配 0 或多个字符，`?` 匹配一个字符。
- en: 'All embedding specifications, whether or not they use match patterns, are checked
    by the compiler. If they aren’t valid, compilation fails. Here are the ways a
    pattern can be invalid:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的嵌入规范，无论是否使用匹配模式，都会由编译器检查。如果它们无效，则编译失败。以下是模式可能无效的情况：
- en: If the specified name or pattern doesn’t match a file or directory
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定的名称或模式不匹配文件或目录
- en: If you specify multiple filenames or patterns for a `string` or `[]byte` variable
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为 `string` 或 `[]byte` 变量指定了多个文件名或模式
- en: If you specify a pattern for a `string` or `[]byte` variable and it matches
    more than one file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为 `string` 或 `[]byte` 变量指定了一个模式，并且它匹配多个文件
- en: Embedding Hidden Files
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入隐藏文件
- en: Including files in a directory tree that start with `.` or `_` is a little complicated.
    Many operating systems consider these to be hidden files, so they are not included
    by default when a directory name is specified. However, you can override this
    behavior in two ways. The first is to put `/*` after the name of a directory you
    want to embed. This will include all hidden files within the root directory, but
    it will not include hidden files in its subdirectories. To include all hidden
    files in all subdirectories, put `all:` before the name of the directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 包括以 `.` 或 `_` 开头的目录树中的文件有点复杂。许多操作系统将其视为隐藏文件，因此在指定目录名时默认情况下不包括它们。但是，你可以通过两种方式覆盖此行为。第一种是在你想要嵌入的目录名后加上
    `/*`。这将包括根目录中的所有隐藏文件，但不会包括其子目录中的隐藏文件。要包括所有子目录中的所有隐藏文件，请在目录名前加上 `all:`。
- en: This sample program (which you can find in the *sample_code/embed_hidden* directory
    in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)) makes this easier to understand.
    In the sample, the directory *parent_dir* contains two files, *.hidden* and *visible*,
    and one subdirectory, *child_dir*. The *child_dir* subdirectory contains two files,
    *.hidden* and *visible*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例程序（你可以在 [第11章存储库](https://oreil.ly/Z_Fpg) 的 *sample_code/embed_hidden* 目录中找到）使这一点更容易理解。在示例中，目录
    *parent_dir* 包含两个文件，*.hidden* 和 *visible*，以及一个子目录 *child_dir*。*child_dir* 子目录包含两个文件，*.hidden*
    和 *visible*。
- en: 'Here is the code for the program:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的代码：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the program is shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出显示如下：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using go generate
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `go generate`
- en: The `go generate` tool is a little different, because it doesn’t do anything
    by itself. When you run `go generate`, it looks for specially formatted comments
    in your source code and runs programs specified in those comments. While you could
    use `go generate` to run anything at all, it is most commonly used by developers
    to run tools that (unsurprisingly, given the name) generate source code. This
    could be from analyzing existing code and adding functionality or processing schemas
    and making source code out of it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`go generate` 工具有些不同，因为它本身不执行任何操作。当你运行 `go generate` 时，它会查找源代码中特殊格式的注释，并运行这些注释中指定的程序。虽然你可以使用
    `go generate` 运行任何内容，但它最常用于开发者运行（顾名思义）生成源代码的工具。这可能是通过分析现有代码并添加功能，或者处理模式并生成源代码。'
- en: A good example of something that can be automatically converted to code are
    [Protocol Buffers](https://protobuf.dev), sometimes called *protobufs*. Protobuf
    is a popular binary format that is used by Google to store and transmit data.
    When working with protobufs, you write a *schema*, which is a language-independent
    description of the data structure. Developers who want to write programs to interact
    with data in protobuf format run tools that process the schema and produce language-specific
    data structures to hold the data and language-specific functions to read and write
    data in protobuf format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自动转换为代码的一个很好的例子是 [Protocol Buffers](https://protobuf.dev)，有时称为 *protobufs*。Protobuf
    是一种流行的二进制格式，被 Google 用于存储和传输数据。在处理 protobuf 时，您编写一个 *schema*，它是数据结构的语言无关描述。希望编写与
    protobuf 格式数据交互的程序的开发人员运行处理 schema 的工具，并生成特定于语言的数据结构以保存数据以及特定于语言的函数来读取和写入 protobuf
    格式的数据。
- en: 'Let’s see how this works in Go. You can find a sample module in the [proto_generate
    repo](https://oreil.ly/OJdYU). The module contains a protobuf schema file called
    *person.proto*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在 Go 中是如何工作的。您可以在 [proto_generate 仓库](https://oreil.ly/OJdYU) 中找到一个示例模块，其中包含一个名为
    *person.proto* 的 protobuf schema 文件：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While making a struct that implements `Person` would be easy, writing the code
    to convert back and forth from the binary format is difficult. Let’s use tools
    from Google to do the hard work and invoke them with `go generate`. You need to
    install two things. The first is the `protoc` binary for your computer (see the
    [installation instructions](https://oreil.ly/UIvZN). Next, use `go install` to
    install the Go protobuf plug-ins:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管制作一个实现 `Person` 的结构体很容易，但编写从二进制格式转换回去的代码却很困难。让我们使用 Google 的工具来完成这些艰难的工作，并使用
    `go generate` 调用它们。您需要安装两个工具。首先是适用于您计算机的 `protoc` 二进制文件（请参阅 [安装说明](https://oreil.ly/UIvZN)）。接下来，使用
    `go install` 安装 Go protobuf 插件：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In *main.go*, there is the magic comment that’s processed by `go generate`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *main.go* 中，有一个由 `go generate` 处理的神奇注释：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: (If you look at the source code in GitHub, you’ll see this should be a single
    line. It’s wrapped to fit the constraints of a printed page.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您在 GitHub 上查看源代码，您会看到这应该是一行。它被换行以适应打印页面的约束。）
- en: 'Run `go generate` by typing the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容运行 `go generate`：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running `go generate`, you’ll see a new directory called *data* that
    contains a file named *person.pb.go*. It contains the source code for the `Person`
    struct, and some methods and functions that are used by the `Marshal` and `Unmarshal`
    functions in the `google.golang.org/protobuf/proto` module. You call these functions
    in your `main` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `go generate` 后，您会看到一个名为 *data* 的新目录，其中包含一个名为 *person.pb.go* 的文件。它包含 `Person`
    结构体的源代码，以及在 `google.golang.org/protobuf/proto` 模块中由 `Marshal` 和 `Unmarshal` 函数使用的一些方法和函数。您在
    `main` 函数中调用这些函数：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build and run the program as usual:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样构建和运行程序：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Another tool commonly used with `go generate` is `stringer`. As I discussed
    in [“iota Is for Enumerations—Sometimes”](ch07.html#iota_section), enumerations
    in Go lack many of the features that are found in other languages with enumerations.
    One of those features is automatically generating a printable name for each value
    in the enumeration. The `stringer` tool is used with `go generate` to add a `String`
    method to your enumeration’s values so they can be printed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常与 `go generate` 一起使用的工具是 `stringer`。正如我在 [“iota 用于枚举——有时”](ch07.html#iota_section)
    中讨论的那样，Go 中的枚举缺少许多其他语言中的枚举所具有的特性之一是为枚举中的每个值自动生成可打印的名称。 `stringer` 工具与 `go generate`
    一起使用，为您枚举的值添加一个 `String` 方法，以便可以打印它们。
- en: 'Install `stringer` with `go install golang.org/x/tools/cmd/stringer@latest`.
    The *sample_code/stringer_demo* directory in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)
    provides a very simple example of how to use `stringer`. Here’s the source in
    *main.go*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go install golang.org/x/tools/cmd/stringer@latest` 安装 `stringer`。在 [第 11
    章仓库](https://oreil.ly/Z_Fpg) 的 *sample_code/stringer_demo* 目录中提供了一个非常简单的示例，展示了如何使用
    `stringer`。以下是 *main.go* 中的源代码：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run `go generate ./...` and you’ll see a new file generated called *direction_string.go*.
    Use `go build` to build the `string_demo` binary and when you run it, you’ll get
    the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `go generate ./...`，您将看到生成一个名为 *direction_string.go* 的新文件。使用 `go build` 构建
    `string_demo` 二进制文件，并在运行时，您将获得输出：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can configure `stringer` and its output in multiple ways. Arjun Mahishi
    has written a great [blog post](https://oreil.ly/2YVE2) describing how to use
    `stringer` and customize its output.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以多种方式配置 `stringer` 及其输出。Arjun Mahishi 写了一篇很棒的 [博客文章](https://oreil.ly/2YVE2)
    描述了如何使用 `stringer` 并自定义其输出。
- en: Working with go generate and Makefiles
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `go generate` 和 Makefile 进行工作
- en: Since the job of `go generate` is to run other tools, you might wonder if it’s
    worth using when you have a perfectly good Makefile in your project. The advantage
    of `go generate` is that it creates a separation of responsibilities. Use `go
    generate` commands to mechanically create source code, and use the Makefile to
    validate and compile source code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `go generate` 的工作是运行其他工具，你可能会想知道在项目中已经有一个完全正常的 Makefile 时是否值得使用它。`go generate`
    的优势在于它创建了职责的分离。使用 `go generate` 命令来机械地创建源代码，并使用 Makefile 来验证和编译源代码。
- en: It is a best practice to commit the source code created by `go generate` to
    version control. (The sample projects in the [Chapter 11 repository](https://oreil.ly/Z_Fpg)
    don’t include generated source code so you can see `go generate` work.) This allows
    people browsing your source code to see everything that’s invoked, even the generated
    parts. It also means they don’t need to have tools like `protoc` installed in
    order to build your code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将由 `go generate` 创建的源代码提交到版本控制是一种最佳实践。（在 [第11章的存储库](https://oreil.ly/Z_Fpg)
    的示例项目中不包括生成的源代码，因此你可以看到 `go generate` 的工作。）这使得浏览你源代码的人可以看到每个被调用的东西，甚至是生成的部分。它也意味着他们不需要安装诸如
    `protoc` 这样的工具来构建你的代码。
- en: Checking in your generated source code technically means that you don’t *need*
    to run `go generate` unless it will produce different output, such as processing
    a modified protobuf definition or an updated enumeration. However, it’s still
    a good idea to automate calling `go generate` before `go build`. Relying on a
    manual process is asking for trouble. Some generator tools, like `stringer`, include
    clever tricks to block compilation if you forget to rerun `go generate`, but that’s
    not universal. You’ll inevitably waste time during testing trying to understand
    why a change didn’t show up before realizing that you forgot to invoke `go generate`.
    (I made this mistake multiple times before I learned my lesson.) Given this, it
    is best to add a `generate` step to your Makefile and make it a dependency of
    your `build` step.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上来说，提交你生成的源代码意味着你不一定*需要*运行 `go generate`，除非它会产生不同的输出，例如处理修改的 protobuf 定义或更新的枚举。然而，自动化在
    `go build` 之前调用 `go generate` 仍然是一个好主意。依赖手动流程会带来麻烦。一些生成器工具，如 `stringer`，包含聪明的技巧来阻止编译，如果你忘记重新运行
    `go generate`，但这并非普遍。在测试中试图理解为什么变更没有显示之前，你会浪费时间，最终发现你忘记调用 `go generate`。 （在学习教训之前，我犯了这个错误多次。）因此，最好是在你的
    Makefile 中添加一个 `generate` 步骤，并将其作为你的 `build` 步骤的依赖项。
- en: However, I would disregard this advice in two situations. The first is if invoking
    `go generate` on identical input produces source files with minor differences,
    such as a timestamp. A well-written `go generate` tool should produce identical
    output every time it’s run on the same input, but there are no guarantees that
    every tool you need to use is well written. You don’t want to keep on checking
    in new versions of files that are functionally identical, as they will clutter
    your version control system and make your code reviews noisier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在两种情况下我会忽略这些建议。首先是当在相同输入上调用 `go generate` 产生具有轻微差异的源文件时，例如时间戳。一个良好编写的 `go
    generate` 工具每次在相同输入上运行时应该产生相同的输出，但不能保证你需要使用的每个工具都是良好编写的。你不希望不断地检查功能上相同的新版本文件，因为它们会混乱你的版本控制系统并使得代码审查更加嘈杂。
- en: The second situation is if `go generate` takes a very long time to complete.
    Fast builds are a feature of Go, because they allow developers to stay focused
    and get rapid feedback. If you are noticeably slowing down a build to generate
    identical files, the loss in developer productivity is not worth it. In both cases,
    all you can do is leave lots of comments to remind people to rebuild when things
    change and hope that everyone on your team is diligent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `go generate` 花费很长时间才能完成，这是第二种情况。快速构建是 Go 的一个特性，因为它们允许开发者保持专注并获得快速反馈。如果因为生成相同文件而显著减慢构建速度，那么这种开发者生产力的损失是不值得的。在这两种情况下，你只能留下大量注释来提醒人们在变更时重新构建，并希望你团队的每个人都很勤奋。
- en: Reading the Build Info Inside a Go Binary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 二进制文件内读取构建信息
- en: As companies develop more of their own software, it is becoming increasingly
    common for them to want to understand exactly what they have deployed to their
    data centers and cloud environments, down to the version and the dependencies.
    You might wonder why you’d want to get this information from compiled code. After
    all, a company already has this information in version control.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着公司开发越来越多的自己的软件，他们越来越希望确切地了解他们已部署到他们的数据中心和云环境中的内容，包括版本和依赖关系。您可能会想知道为什么要从编译代码中获取这些信息。毕竟，公司已经在版本控制中拥有这些信息。
- en: Companies with mature development and deployment pipelines can capture this
    information right before deploying a program, allowing them to be sure that the
    information is accurate. However, many, if not most, companies don’t track the
    exact version of internal software that’s deployed. In some cases, software can
    be deployed for years without being replaced, and no one remembers much about
    it. If a vulnerability is reported in a version of a third-party library, you
    need to either find some way to scan your deployed software and figure out what
    versions of third-party libraries are deployed, or redeploy everything just to
    be safe. In the Java world, this exact problem happened when a serious vulnerability
    was discovered in the popular Log4j library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 具有成熟的开发和部署流水线的公司可以在部署程序之前捕获此信息，以确保信息的准确性。然而，许多公司，如果不是大多数公司，不跟踪已部署的内部软件的确切版本。在某些情况下，软件可以部署多年而无需更换，并且没有人记得太多关于它。如果在流行的
    Log4j 库中发现了严重的漏洞报告，需要找到某种方法扫描已部署的软件并确定已部署的第三方库的版本，或者为了安全起见重新部署所有内容。在 Java 的世界中，这个确切的问题就发生了。
- en: 'Luckily, Go solves this problem for you. Every Go binary you create with `go
    build` automatically contains build information on what versions of what modules
    make up the binary, and also what build commands were used, what version control
    system was used, and what revision the code was at in your version control system.
    You can view this information with the `go version -m` command. The following
    shows the output for the `vulnerable` program when built on an Apple Silicon Mac:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go 为您解决了这个问题。使用 `go build` 创建的每个 Go 二进制文件都自动包含了构建信息，包括构成该二进制文件的模块的版本以及使用的构建命令、版本控制系统以及代码在版本控制系统中的修订版本。您可以使用
    `go version -m` 命令查看此信息。以下是在 Apple Silicon Mac 上构建 `vulnerable` 程序的输出：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because this information is embedded into every binary, `govulncheck` is capable
    of scanning Go programs to check for libraries with known vulnerabilities:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些信息嵌入到每个二进制文件中，`govulncheck`能够扫描 Go 程序，检查是否存在已知漏洞的库：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Be aware that `govulncheck` can’t track down exact lines of code when inspecting
    a binary. If `govulncheck` finds a problem in a binary, use `go version -m` to
    find out the exact deployed version, check the code out of version control, and
    run it again against the source code to pinpoint the issue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`govulncheck` 在检查二进制文件时无法追踪到确切的代码行。如果 `govulncheck` 在二进制文件中发现问题，请使用 `go
    version -m` 查找确切的部署版本，从版本控制中检出代码，并再次针对源代码运行以准确定位问题。
- en: If you want to build your own tools to read the build information, look at the
    [`debug/buildinfo`](https://oreil.ly/M5Jmq) package in the standard library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想构建自己的工具来读取构建信息，请查看标准库中的 [`debug/buildinfo`](https://oreil.ly/M5Jmq) 包。
- en: Building Go Binaries for Other Platforms
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为其他平台构建 Go 二进制文件
- en: One of the advantages of a VM-based language like Java, JavaScript, or Python
    is that you can take your code and get it to run on any computer where the virtual
    machine has been installed. This portability makes it easy for developers using
    these languages to build programs on a Windows or Mac computer and deploy it on
    a Linux server, even though the operating system and possibly the CPU architecture
    are different.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Java、JavaScript 或 Python 这样基于虚拟机的语言的一个优点是，您可以将您的代码放在安装了虚拟机的任何计算机上运行。这种可移植性使得使用这些语言的开发人员能够在
    Windows 或 Mac 计算机上构建程序，并在 Linux 服务器上部署，即使操作系统和可能的 CPU 架构不同。
- en: Go programs are compiled to native code, so the generated binary is compatible
    with only a single operating system and CPU architecture. However, that doesn’t
    mean that Go developers need to maintain a menagerie of machines (virtual or otherwise)
    to release on multiple platforms. The `go build` command makes it easy to *cross-compile*,
    or create a binary for a different operating system and/or CPU. When `go build`
    is run, the target operating system is specified by the `GOOS` environment variable.
    Similarly, the `GOARCH` environment variable specifies the CPU architecture. If
    you don’t set them explicitly, `go build` defaults to using the values for your
    current computer, which is why you’ve never had to worry about these variables
    before.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序被编译成本地代码，因此生成的二进制文件只能与单个操作系统和 CPU 架构兼容。但是，这并不意味着 Go 开发人员需要维护多台机器（虚拟或其他）以在多个平台上发布。`go
    build` 命令使得跨平台编译变得简单，或者为不同的操作系统和/或 CPU 创建二进制文件。运行 `go build` 时，目标操作系统由 `GOOS`
    环境变量指定。类似地，`GOARCH` 环境变量指定 CPU 架构。如果没有显式设置它们，`go build` 默认使用您当前计算机的值，这就是为什么您以前从未担心过这些变量的原因。
- en: You can find the valid values and combinations for `GOOS` and `GOARCH` (sometimes
    pronounced “GOOSE” and “GORCH”) in the [installation documentation](https://oreil.ly/Zf1lx).
    Some of the supported operating systems and CPUs are a bit esoteric, and others
    might require some translation. For example, `darwin` refers to macOS (Darwin
    is the name of the macOS kernel), and `amd64` means 64-bit Intel-compatible CPUs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [安装文档](https://oreil.ly/Zf1lx) 中找到 `GOOS` 和 `GOARCH` 的有效值和组合（有时发音为“GOOSE”和“GORCH”）。一些支持的操作系统和
    CPU 有点奇特，而其他可能需要一些翻译。例如，`darwin` 指的是 macOS（Darwin 是 macOS 内核的名称），而 `amd64` 表示
    64 位兼容 Intel 的 CPU。
- en: 'Let’s go back to the `vulnerable` program one last time. When using an Apple
    Silicon Mac (which has an ARM64 CPU), running `go build` defaults to `darwin`
    for `GOOS` and `arm64` for `GOARCH`. You can confirm this using the `file` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后再回到 `vulnerable` 程序。当使用 Apple Silicon Mac（具有 ARM64 CPU）时，运行 `go build`
    默认为 `darwin` 的 `GOOS` 和 `arm64` 的 `GOARCH`。您可以使用 `file` 命令确认这一点：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is how to build a binary for Linux on 64-bit Intel CPUs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在 64 位 Intel CPU 的 Linux 上构建二进制文件：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using Build Tags
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建标签
- en: When writing programs that need to run on multiple operating systems or CPU
    architectures, you sometimes need different code for different platforms. You
    also might want to write a module that takes advantage of the latest Go features
    but is still backward compatible with older Go compilers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写需要在多个操作系统或 CPU 架构上运行的程序时，有时需要为不同平台编写不同的代码。您可能还希望编写一个模块，利用最新的 Go 特性，但仍与旧版
    Go 编译器兼容。
- en: You can create targeted code in two ways. The first is to use the name of the
    file to indicate when the file should be included in the build. You do this by
    adding the target *GOOS* and *GOARCH*, separated by `_`, to the filename before
    *.go*. For example, if you have a file that you want to be compiled only on Windows,
    you’d name the file *something_windows.go*, but if you wanted it to be compiled
    only when building for ARM64 Windows, name the file *something_windows_arm64.go*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式创建目标代码。第一种方法是使用文件名来指示何时应将文件包含在构建中。您可以在 *.go* 之前的文件名中添加目标 *GOOS* 和 *GOARCH*，用
    `_` 分隔。例如，如果您有一个只希望在 Windows 上编译的文件，您将文件命名为 *something_windows.go*，但如果您希望在构建 ARM64
    Windows 时编译它，则将文件命名为 *something_windows_arm64.go*。
- en: A *build tag* (also called a *build constraint*) is the other option you can
    use to specify when a file is compiled. Like embedding and generating, build tags
    take advantage of a magic comment. In this case, it’s `//go:build`. This comment
    must be placed on the line before the package declaration in your file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建标签*（也称为*构建约束*）是您可以使用的另一种指定文件何时编译的选项。与嵌入和生成类似，构建标签利用了一个魔术注释。在这种情况下，它是 `//go:build`。此注释必须放置在文件中包声明之前的行上。'
- en: Build tags use boolean operators (`||`, `&&`, and `!`) and parentheses to specify
    exact build rules for architectures, operating systems, and Go versions. The build
    tag `//go:build (!darwin && !linux) || (darwin && !go1.12)`—which really appears
    in the Go standard library—specifies that the file should not be compiled on Linux
    or macOS, except it’s OK to compile it on macOS if the Go version is 1.11 or earlier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标签使用布尔运算符（`||`、`&&` 和 `!`）和括号来指定针对架构、操作系统和 Go 版本的确切构建规则。构建标签 `//go:build (!darwin
    && !linux) || (darwin && !go1.12)` —— 这实际上出现在 Go 标准库中 —— 指定该文件不应在 Linux 或 macOS
    上编译，除非在 macOS 上的 Go 版本是 1.11 或更早版本。
- en: Some meta build constraints are also available. The constraint `unix` matches
    any Unix-ish platform, and `cgo` matches if `cgo` is supported by the current
    platform and is enabled. (I cover `cgo` in [“Cgo Is for Integration, Not Performance”](ch16.html#cgo).)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用一些元构建约束。约束`unix`匹配任何类 Unix 平台，而`cgo`则在当前平台支持且启用了`cgo`时匹配（我在[“Cgo 用于集成而非性能”](ch16.html#cgo)中讨论过`cgo`）。
- en: The question becomes when you should use filenames to indicate where to run
    code and when you should use build tags. Because build tags allow binary operators,
    you can specify a more specific set of platforms with them. The Go standard library
    sometimes takes a belt-and-suspenders approach. The package `internal/cpu` in
    the standard library has platform-specific source code for CPU feature detection.
    The file *internal/cpu/cpu_arm64_darwin.go* has a name that indicates that it
    is meant only for computers using Apple CPUs. It also has a `//go:build arm64
    && darwin && !ios` line in the file to indicate that it should be compiled only
    when building for Apple Silicon Macs and not for iPhones or iPads. The build tags
    are able to specify the target platform with more detail, but following the filename
    convention makes it easy for a person to find the right file for a given platform.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于你应该何时使用文件名来指示在哪里运行代码，何时应该使用构建标签。因为构建标签允许使用二进制运算符，你可以用它们来指定更具体的平台集。Go 标准库有时采用一种“双重保险”的方法。标准库中的`internal/cpu`包针对
    CPU 特征检测具有特定于平台的源代码。文件*internal/cpu/cpu_arm64_darwin.go*的名称表明它仅适用于使用苹果 CPU 的计算机。该文件还在其内部使用了`//go:build
    arm64 && darwin && !ios`行，以指示它应仅在构建苹果 Silicon Macs 时编译，而不适用于 iPhone 或 iPad。构建标签能够更详细地指定目标平台，但遵循文件名约定使人们能够轻松找到适合特定平台的正确文件。
- en: In addition to the built-in build tags that represent Go versions, operating
    systems and CPU architectures, you can also use any string at all as a custom
    build tag. You can then control compilation of that file with the `-tags` command-line
    flag. For example, if you put `//go:build gopher` on the line before the package
    declaration in a file, it will not be compiled unless you include a `-tags gopher`
    flag as part of the `go build`, `go run`, or `go test` command.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示 Go 版本、操作系统和 CPU 架构的内置构建标签之外，您还可以使用任何字符串作为自定义构建标签。然后，您可以使用`-tags`命令行标志来控制该文件的编译。例如，如果在包声明前的行上放置了`//go:build
    gopher`，则除非在`go build`、`go run`或`go test`命令中包含`-tags gopher`标志，否则它将不会被编译。
- en: Custom build tags are surprisingly handy. If you have a source file that you
    don’t want to build right now (perhaps it doesn’t compile yet, or it’s an experiment
    that’s not ready to be included), it is idiomatic to skip over the file by putting
    `//go:build ignore` on the line before the package declaration. You will see another
    use for custom build tags when looking at integration tests in [“Using Integration
    Tests and Build Tags”](ch15.html#test_build_tag).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义构建标签非常方便。如果有一个源文件暂时不想构建（可能是因为它尚未编译或者是一个尚未准备好包含的实验），在包声明前的行上放置`//go:build
    ignore`是一种惯用方法。在查看[“使用集成测试和构建标签”](ch15.html#test_build_tag)中的集成测试时，您将看到自定义构建标签的另一个用途。
- en: Warning
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When writing your build tags, make sure there isn’t any whitespace between the
    `//` and `go:build`. If there is, Go will not consider it a build tag.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 写你的构建标签时，请确保`//`和`go:build`之间没有任何空格。如果有空格，Go 将不会将其视为构建标签。
- en: Testing Versions of Go
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Go 版本
- en: 'Despite Go’s strong backward-compatibility guarantees, bugs do happen. It’s
    natural to want to make sure that a new release doesn’t break your programs. You
    also might get a bug report from a user of your library saying that your code
    doesn’t work as expected on an older version of Go. One option is to install a
    secondary Go environment. For example, if you wanted to try out version 1.19.2,
    you would use the following commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go 提供了强大的向后兼容性保证，但仍会出现 bug。自然而然地希望确保新版本不会破坏您的程序。您还可能会收到用户反馈，称您的库在旧版本的 Go
    上运行时出现了意外行为。一个选项是安装第二个 Go 环境。例如，如果您想尝试版本 1.19.2，可以使用以下命令：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can then use the command `go1.19.2` instead of the `go` command to see
    if version 1.19.2 works for your programs:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用命令`go1.19.2`而不是`go`命令来查看版本 1.19.2 是否适用于您的程序：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you have validated that your code works, you can uninstall the secondary
    environment. Go stores secondary Go environments in the *sdk* directory within
    your home directory. To uninstall, delete the environment from the *sdk* directory
    and the binary from the *go/bin* directory. Here’s how to do that on macOS, Linux,
    and BSD:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦验证了你的代码可以工作，你可以卸载辅助环境。Go将辅助Go环境存储在你的主目录的*sdk*目录中。要卸载，请从*sdk*目录中删除该环境，并从*go/bin*目录中删除二进制文件。以下是如何在macOS、Linux和BSD上执行此操作的步骤：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using go help to Learn More About Go Tooling
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用go help了解更多关于Go工具的信息
- en: You can learn more about Go’s tooling and runtime environment with the `go help`
    command. It contains exhaustive information about all the commands mentioned here,
    as well as things like modules, import path syntax, and working with nonpublic
    source code. For example, you can get information on import path syntax by typing
    `go help importpath`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`go help`命令可以了解更多关于Go工具和运行时环境的信息。它包含了关于这里提到的所有命令的详尽信息，以及诸如模块、导入路径语法和处理非公开源码的内容。例如，你可以通过输入`go
    help importpath`获取有关导入路径语法的信息。
- en: Exercises
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: These exercises cover some of the tools that you’ve learned about in this chapter.
    You can find the solutions in the *exercise_solutions* directory in the [Chapter
    11 repository](https://oreil.ly/Z_Fpg).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习涵盖了本章介绍的一些工具。你可以在[第11章存储库](https://oreil.ly/Z_Fpg)的*exercise_solutions*目录中找到答案。
- en: Go to the [UN’s Universal Declaration of Human Rights (UDHR) page](https://oreil.ly/-q7Cn)
    and copy the text of the UDHR into a text file called *english_rights.txt*. Click
    the Other Languages link and copy the document text in a few additional languages
    into files named *LANGUAGE_rights.txt*. Create a program that embeds these files
    into package-level variables. Your program should take in one command-line parameter,
    the name of a language. It should then print out the UDHR in that language.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[联合国《世界人权宣言》页面](https://oreil.ly/-q7Cn)，并将《世界人权宣言》的文本复制到名为*english_rights.txt*的文本文件中。点击“其他语言”链接，并将该文件的文本用几种其他语言分别复制到名为*LANGUAGE_rights.txt*的文件中。创建一个程序，将这些文件嵌入包级别变量中。你的程序应接受一个命令行参数，即语言名称。然后，它应该打印出该语言的《世界人权宣言》。
- en: Use `go install` to install `staticcheck`. Run it against your program and fix
    any problems it finds.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go install`安装`staticcheck`。运行它来检查你的程序并修复它找到的任何问题。
- en: Cross-compile your program for ARM64 on Windows. If you are using an ARM64 Windows
    computer, cross-compile for AMD64 on Linux.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上为ARM64交叉编译你的程序。如果你使用的是ARM64 Windows计算机，则在Linux上为AMD64进行交叉编译。
- en: Wrapping Up
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about the tools that Go provides to improve software
    engineering practices and third-party code-quality tools. In the next chapter,
    you’re going to explore one of the signature features in Go: concurrency.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Go提供的工具，以改进软件工程实践和第三方代码质量工具。在下一章中，你将探索Go中的一个标志性特性：并发。
- en: ^([1](ch11.html#id2291-marker)) The term “linter” comes from the original `lint`
    program written by Steve Johnson when he was on the Unix team at Bell Labs and
    described in his [1978 paper](https://oreil.ly/RgZbU). The name comes from the
    tiny bits of fabric that come off clothes in a dryer and are captured by a filter.
    He saw his program as being like a filter capturing small errors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#id2291-marker))“linter”这个术语源于贝尔实验室Unix团队成员史蒂夫·约翰逊编写的原始`lint`程序，并在他的[1978年论文](https://oreil.ly/RgZbU)中描述。这个名字来自于干衣机中衣物脱落的微小纤维被滤网捕捉的现象。他将他的程序比作捕捉小错误的滤网。
