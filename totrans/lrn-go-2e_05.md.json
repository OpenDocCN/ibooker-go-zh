["```go\nfunc div(num int, denom int) int {\n    if denom == 0 {\n        return 0\n    }\n    return num / denom\n}\n```", "```go\nfunc main() {\n    result := div(5, 2)\n    fmt.Println(result)\n}\n```", "```go\nfunc div(num, denom int) int {\n```", "```go\ntype MyFuncOpts struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\nfunc MyFunc(opts MyFuncOpts) error {\n    // do something here\n}\n\nfunc main() {\n    MyFunc(MyFuncOpts{\n        LastName: \"Patel\",\n        Age:      50,\n    })\n    MyFunc(MyFuncOpts{\n        FirstName: \"Joe\",\n        LastName:  \"Smith\",\n    })\n}\n```", "```go\nfunc addTo(base int, vals ...int) []int {\n    out := make([]int, 0, len(vals))\n    for _, v := range vals {\n        out = append(out, base+v)\n    }\n    return out\n}\n```", "```go\nfunc main() {\n    fmt.Println(addTo(3))\n    fmt.Println(addTo(3, 2))\n    fmt.Println(addTo(3, 2, 4, 6, 8))\n    a := []int{4, 3}\n    fmt.Println(addTo(3, a...))\n    fmt.Println(addTo(3, []int{1, 2, 3, 4, 5}...))\n}\n```", "```go\n[]\n[5]\n[5 7 9 11]\n[7 6]\n[4 5 6 7 8]\n```", "```go\nfunc divAndRemainder(num, denom int) (int, int, error) {\n    if denom == 0 {\n        return 0, 0, errors.New(\"cannot divide by zero\")\n    }\n    return num / denom, num % denom, nil\n}\n```", "```go\nfunc main() {\n    result, remainder, err := divAndRemainder(5, 2)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    fmt.Println(result, remainder)\n}\n```", "```go\n>>> def div_and_remainder(n,d):\n...   if d == 0:\n...     raise Exception(\"cannot divide by zero\")\n...   return n / d, n % d\n>>> v = div_and_remainder(5,2)\n>>> v\n(2.5, 1)\n>>> result, remainder = div_and_remainder(5,2)\n>>> result\n2.5\n>>> remainder\n1\n```", "```go\nfunc divAndRemainder(num, denom int) (result int, remainder int, err error) {\n    if denom == 0 {\n        err = errors.New(\"cannot divide by zero\")\n        return result, remainder, err\n    }\n    result, remainder = num/denom, num%denom\n    return result, remainder, err\n}\n```", "```go\nfunc main() {\n    x, y, z := divAndRemainder(5, 2)\n    fmt.Println(x, y, z)\n}\n```", "```go\nfunc divAndRemainder(num, denom int) (result int, remainder int, err error) {\n    // assign some values\n    result, remainder = 20, 30\n    if denom == 0 {\n        return 0, 0, errors.New(\"cannot divide by zero\")\n    }\n    return num / denom, num % denom, nil\n}\n```", "```go\n2 1\n```", "```go\nfunc divAndRemainder(num, denom int) (result int, remainder int, err error) {\n    if denom == 0 {\n        err = errors.New(\"cannot divide by zero\")\n        return\n    }\n    result, remainder = num/denom, num%denom\n    return\n}\n```", "```go\nvar myFuncVariable func(string) int\n```", "```go\nfunc f1(a string) int {\n    return len(a)\n}\n\nfunc f2(a string) int {\n    total := 0\n    for _, v := range a {\n        total += int(v)\n    }\n    return total\n}\n\nfunc main() {\n    var myFuncVariable func(string) int\n    myFuncVariable = f1\n    result := myFuncVariable(\"Hello\")\n    fmt.Println(result)\n\n    myFuncVariable = f2\n    result = myFuncVariable(\"Hello\")\n    fmt.Println(result)\n}\n```", "```go\n5\n500\n```", "```go\nfunc add(i int, j int) int { return i + j }\n\nfunc sub(i int, j int) int { return i - j }\n\nfunc mul(i int, j int) int { return i * j }\n\nfunc div(i int, j int) int { return i / j }\n```", "```go\nvar opMap = map[string]func(int, int) int{\n    \"+\": add,\n    \"-\": sub,\n    \"*\": mul,\n    \"/\": div,\n}\n```", "```go\nfunc main() {\n    expressions := [][]string{\n        {\"2\", \"+\", \"3\"},\n        {\"2\", \"-\", \"3\"},\n        {\"2\", \"*\", \"3\"},\n        {\"2\", \"/\", \"3\"},\n        {\"2\", \"%\", \"3\"},\n        {\"two\", \"+\", \"three\"},\n        {\"5\"},\n    }\n    for _, expression := range expressions {\n        if len(expression) != 3 {\n            fmt.Println(\"invalid expression:\", expression)\n            continue\n        }\n        p1, err := strconv.Atoi(expression[0])\n        if err != nil {\n            fmt.Println(err)\n            continue\n        }\n        op := expression[1]\n        opFunc, ok := opMap[op]\n        if !ok {\n            fmt.Println(\"unsupported operator:\", op)\n            continue\n        }\n        p2, err := strconv.Atoi(expression[2])\n        if err != nil {\n            fmt.Println(err)\n            continue\n        }\n        result := opFunc(p1, p2)\n        fmt.Println(result)\n    }\n}\n```", "```go\n5\n-1\n6\n0\nunsupported operator: %\nstrconv.Atoi: parsing \"two\": invalid syntax\ninvalid expression: [5]\n```", "```go\ntype opFuncType func(int,int) int\n```", "```go\nvar opMap = map[string]opFuncType {\n    // same as before\n}\n```", "```go\nfunc main() {\n    f := func(j int) {\n        fmt.Println(\"printing\", j, \"from inside of an anonymous function\")\n    }\n    for i := 0; i < 5; i++ {\n        f(i)\n    }\n}\n```", "```go\nprinting 0 from inside of an anonymous function\nprinting 1 from inside of an anonymous function\nprinting 2 from inside of an anonymous function\nprinting 3 from inside of an anonymous function\nprinting 4 from inside of an anonymous function\n```", "```go\nfunc main() {\n    for i := 0; i < 5; i++ {\n        func(j int) {\n            fmt.Println(\"printing\", j, \"from inside of an anonymous function\")\n        }(i)\n    }\n}\n```", "```go\nvar (\n    add = func(i, j int) int { return i + j }\n    sub = func(i, j int) int { return i - j }\n    mul = func(i, j int) int { return i * j }\n    div = func(i, j int) int { return i / j }\n)\n\nfunc main() {\n    x := add(2, 3)\n    fmt.Println(x)\n}\n```", "```go\nfunc main() {\n    x := add(2, 3)\n    fmt.Println(x)\n    changeAdd()\n    y := add(2, 3)\n    fmt.Println(y)\n}\n\nfunc changeAdd() {\n    add = func(i, j int) int { return i + j + j }\n}\n```", "```go\n5\n8\n```", "```go\nfunc main() {\n    a := 20\n    f := func() {\n        fmt.Println(a)\n        a = 30\n    }\n    f()\n    fmt.Println(a)\n}\n```", "```go\n20\n30\n```", "```go\nfunc main() {\n    a := 20\n    f := func() {\n        fmt.Println(a)\n        a := 30\n        fmt.Println(a)\n    }\n    f()\n    fmt.Println(a)\n}\n```", "```go\n20\n30\n20\n```", "```go\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\npeople := []Person{\n    {\"Pat\", \"Patterson\", 37},\n    {\"Tracy\", \"Bobdaughter\", 23},\n    {\"Fred\", \"Fredson\", 18},\n}\nfmt.Println(people)\n```", "```go\n// sort by last name\nsort.Slice(people, func(i, j int) bool {\n    return people[i].LastName < people[j].LastName\n})\nfmt.Println(people)\n```", "```go\n// sort by age\nsort.Slice(people, func(i, j int) bool {\n    return people[i].Age < people[j].Age\n})\nfmt.Println(people)\n```", "```go\n[{Pat Patterson 37} {Tracy Bobdaughter 23} {Fred Fredson 18}]\n[{Tracy Bobdaughter 23} {Fred Fredson 18} {Pat Patterson 37}]\n[{Fred Fredson 18} {Tracy Bobdaughter 23} {Pat Patterson 37}]\n```", "```go\nfunc makeMult(base int) func(int) int {\n    return func(factor int) int {\n        return base * factor\n    }\n}\n```", "```go\nfunc main() {\n    twoBase := makeMult(2)\n    threeBase := makeMult(3)\n    for i := 0; i < 3; i++ {\n        fmt.Println(twoBase(i), threeBase(i))\n    }\n}\n```", "```go\n0 0\n2 3\n4 6\n```", "```go\nfunc main() {\n    if len(os.Args) < 2 {\n        log.Fatal(\"no file specified\")\n    }\n    f, err := os.Open(os.Args[1])\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer f.Close()\n    data := make([]byte, 2048)\n    for {\n        count, err := f.Read(data)\n        os.Stdout.Write(data[:count])\n        if err != nil {\n            if err != io.EOF {\n                log.Fatal(err)\n            }\n            break\n        }\n    }\n}\n```", "```go\n$ go build\n$ ./simple_cat simple_cat.go\npackage main\n\nimport (\n    \"io\"\n    \"log\"\n    \"os\"\n)\n...\n\n```", "```go\nfunc deferExample() int {\n    a := 10\n    defer func(val int) {\n        fmt.Println(\"first:\", val)\n    }(a)\n    a = 20\n    defer func(val int) {\n        fmt.Println(\"second:\", val)\n    }(a)\n    a = 30\n    fmt.Println(\"exiting:\", a)\n    return a\n}\n```", "```go\nexiting: 30\nsecond: 20\nfirst: 10\n```", "```go\nfunc example() {\n    defer func() int {\n        return 2 // there's no way to read this value\n    }()\n}\n```", "```go\nfunc DoSomeInserts(ctx context.Context, db *sql.DB, value1, value2 string)\n                  (err error) {\n    tx, err := db.BeginTx(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if err == nil {\n            err = tx.Commit()\n        }\n        if err != nil {\n            tx.Rollback()\n        }\n    }()\n    _, err = tx.ExecContext(ctx, \"INSERT INTO FOO (val) values $1\", value1)\n    if err != nil {\n        return err\n    }\n    // use tx to do more database inserts here\n    return nil\n}\n```", "```go\nfunc getFile(name string) (*os.File, func(), error) {\n    file, err := os.Open(name)\n    if err != nil {\n        return nil, nil, err\n    }\n    return file, func() {\n        file.Close()\n    }, nil\n}\n```", "```go\nf, closer, err := getFile(os.Args[1])\nif err != nil {\n    log.Fatal(err)\n}\ndefer closer()\n```", "```go\ntype person struct {\n    age  int\n    name string\n}\n```", "```go\nfunc modifyFails(i int, s string, p person) {\n    i = i * 2\n    s = \"Goodbye\"\n    p.name = \"Bob\"\n}\n```", "```go\nfunc main() {\n    p := person{}\n    i := 2\n    s := \"Hello\"\n    modifyFails(i, s, p)\n    fmt.Println(i, s, p)\n}\n```", "```go\n2 Hello {0 }\n```", "```go\nfunc modMap(m map[int]string) {\n    m[2] = \"hello\"\n    m[3] = \"goodbye\"\n    delete(m, 1)\n}\n\nfunc modSlice(s []int) {\n    for k, v := range s {\n        s[k] = v * 2\n    }\n    s = append(s, 10)\n}\n```", "```go\nfunc main() {\n    m := map[int]string{\n        1: \"first\",\n        2: \"second\",\n    }\n    modMap(m)\n    fmt.Println(m)\n\n    s := []int{1, 2, 3}\n    modSlice(s)\n    fmt.Println(s)\n}\n```", "```go\nmap[2:hello 3:goodbye]\n[2 4 6]\n```", "```go\n    func main() {\n        helloPrefix := prefixer(\"Hello\")\n        fmt.Println(helloPrefix(\"Bob\")) // should print Hello Bob\n        fmt.Println(helloPrefix(\"Maria\")) // should print Hello Maria\n    }\n    ```"]