["```go\n// New creates an LRU cache with the given capacity.\nfunc New(size int) (*Cache, error)\n\n// NewWithEvict creates an LRU cache with the given capacity, and also accepts\n// an \"eviction callback\" function that's called when an eviction occurs.\nfunc NewWithEvict(size int,\n    onEvicted func(key interface{}, value interface{})) (*Cache, error)\n```", "```go\n// Add adds a value to the cache and returns true if an eviction occurred.\nfunc (c *Cache) Add(key, value interface{}) (evicted bool)\n\n// Check if a key is in the cache (without updating the recent-ness).\nfunc (c *Cache) Contains(key interface{}) bool\n\n// Get looks up a key's value and returns (value, true) if it exists.\n// If the value doesn't exist, it returns (nil, false).\nfunc (c *Cache) Get(key interface{}) (value interface{}, ok bool)\n\n// Len returns the number of items in the cache.\nfunc (c *Cache) Len() int\n\n// Remove removes the provided key from the cache.\nfunc (c *Cache) Remove(key interface{}) (present bool)\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    lru \"github.com/hashicorp/golang-lru\"\n)\n\nvar cache *lru.Cache\n\nfunc init() {\n    cache, _ = lru.NewWithEvict(2,\n        func(key interface{}, value interface{}) {\n            fmt.Printf(\"Evicted: key=%v value=%v\\n\", key, value)\n        },\n    )\n}\n\nfunc main() {\n    cache.Add(1, \"a\")           // adds 1\n    cache.Add(2, \"b\")           // adds 2; cache is now at capacity\n\n    fmt.Println(cache.Get(1))   // \"a true\"; 1 now most recently used\n\n    cache.Add(3, \"c\")           // adds 3, evicts key 2\n\n    fmt.Println(cache.Get(2))   // \"<nil> false\" (not found)\n}\n```", "```go\n$ go run lru.go\na true\nEvicted: key=2 value=b\n<nil> false\n```", "```go\ntype Resource struct {\n    url        string\n    polling    bool\n    lastPolled int64\n}\n\ntype Resources struct {\n    data []*Resource\n    lock *sync.Mutex\n}\n```", "```go\nfunc Poller(res *Resources) {\n    for {\n        // Get the least recently polled Resource and mark it as being polled\n        res.lock.Lock()\n\n        var r *Resource\n\n        for _, v := range res.data {\n            if v.polling {\n                continue\n            }\n            if r == nil || v.lastPolled < r.lastPolled {\n                r = v\n            }\n        }\n\n        if r != nil {\n            r.polling = true\n        }\n\n        res.lock.Unlock()\n\n        if r == nil {\n            continue\n        }\n\n        // Poll the URL\n\n        // Update the Resource's polling and lastPolled\n        res.lock.Lock()\n        r.polling = false\n        r.lastPolled = time.Nanoseconds()\n        res.lock.Unlock()\n    }\n}\n```", "```go\ntype Resource string\n\nfunc Poller(in, out chan *Resource) {\n    for r := range in {\n        // Poll the URL\n\n        // Send the processed Resource to out\n        out <- r\n    }\n}\n```", "```go\nfor i := 0; i < numPollers; i++ {\n    go Poller(in, out)\n}\n```", "```go\nch := make(chan type, capacity)\n```", "```go\ntype FileTransactionLogger struct {\n    events       chan<- Event       // Write-only channel for sending events\n    lastSequence uint64             // The last used event sequence number\n}\n\nfunc (l *FileTransactionLogger) WritePut(key, value string) {\n    l.events <- Event{EventType: EventPut, Key: key, Value: value}\n}\n\nfunc (l *FileTransactionLogger) Run() {\n    l.events = make(chan Event, 16)             // Make an events channel\n\n    go func() {\n        for e := range events {                 // Retrieve the next Event\n            l.lastSequence++                    // Increment sequence number\n        }\n    }()\n}\n```", "```go\nvar cache = struct {\n    sync.RWMutex\n    data map[string]string\n}{data: make(map[string]string)}\n```", "```go\nfunc ThreadSafeWrite(key, value string) {\n    cache.Lock()                                    // Establish write lock\n    cache.data[key] = value\n    cache.Unlock()                                  // Release write lock\n}\n```", "```go\nfunc leaky() {\n    ch := make(chan string)\n\n    go func() {\n        s := <-ch\n        fmt.Println(\"Message:\", s)\n    }()\n}\n```", "```go\nfunc timely() {\n    timer := time.NewTimer(5 * time.Second)\n    ticker := time.NewTicker(1 * time.Second)\n\n    done := make(chan bool)\n\n    go func() {\n        for {\n            select {\n            case <-ticker.C:\n                fmt.Println(\"Tick!\")\n            case <-done:\n                return\n            }\n        }\n    }()\n\n    <-timer.C\n    fmt.Println(\"It's time!\")\n    close(done)\n}\n```", "```go\nfunc timelyFixed() {\n    timer := time.NewTimer(5 * time.Second)\n    ticker := time.NewTicker(1 * time.Second)\n    defer ticker.Stop()                         // Be sure to stop the ticker!\n\n    done := make(chan bool)\n\n    go func() {\n        for {\n            select {\n            case <-ticker.C:\n                fmt.Println(\"Tick!\")\n            case <-done:\n                return\n            }\n        }\n    }()\n\n    <-timer.C\n    fmt.Println(\"It's time!\")\n    close(done)\n}\n```"]