<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Composite Types"><div class="chapter" id="unique_chapter_id_03">
<h1><span class="label">Chapter 3. </span>Composite Types</h1>


<p>In the previous chapter, you looked at literals and predeclared variable types: numbers, booleans, and strings. In this chapter, you’ll learn about the composite types in Go, the built-in functions that support them, and the best practices for working with them.</p>






<section data-type="sect1" data-pdf-bookmark="Arrays—Too Rigid to Use Directly"><div class="sect1" id="arrays">
<h1>Arrays—Too Rigid to Use Directly</h1>

<p>Like most programming languages,<a data-type="indexterm" data-primary="types" data-secondary="composite types" data-tertiary="arrays" id="ch03-arr"/><a data-type="indexterm" data-primary="arrays" id="ch03-arr2"/><a data-type="indexterm" data-primary="composite types" data-secondary="arrays" id="ch03-arr3"/> Go has arrays. However, arrays are rarely used directly in Go. You’ll learn why in a bit, <a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="arrays" id="id828"/><a data-type="indexterm" data-primary="arrays" data-secondary="declaration" id="id829"/>but first let’s quickly cover array declaration syntax and use.</p>

<p>All elements in the array must be of the type that’s specified. There are a few declaration styles. In the first, you specify the size of the array and the type of the elements in the array:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code><code class="w"/></pre>

<p>This creates an array of three <code>int</code>s. Since no values were specified, all of the elements (<code>x[0]</code>, <code>x[1]</code>, and <code>x[2]</code>) are initialized to the zero value for an <code>int</code>, which is (of course) 0. <a data-type="indexterm" data-primary="array literals" id="id830"/><a data-type="indexterm" data-primary="literals" data-secondary="array literals" id="id831"/>If you have initial values for the array, you specify them with an <em>array literal</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">}</code><code class="w"/></pre>

<p>If you have a<a data-type="indexterm" data-primary="sparse arrays" id="id832"/> <em>sparse array</em> (an array where most elements are set to their zero value), you can specify only the indices with nonzero values in the array literal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">:</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">:</code><code class="w"> </code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">}</code><code class="w"/></pre>

<p>This creates an array of 12 <code>int</code>s with the following values: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15].</p>

<p>When using an array literal to initialize an array, you can replace the number that specifies the number of elements in the array with <code>...</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="o">...</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">}</code><code class="w"/></pre>

<p>You can use <code>==</code> and <code>!=</code> to <a data-type="indexterm" data-primary="comparison operators" data-secondary="arrays" id="id833"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="arrays" id="id834"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="arrays" id="id835"/>compare two arrays. Arrays are equal if they are the same length and contain equal values:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="o">...</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/></pre>

<p>Go has only one-dimensional arrays,<a data-type="indexterm" data-primary="arrays" data-secondary="multidimensional arrays simulated" id="id836"/> but you can simulate multidimensional arrays:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[</code><code class="mi">2</code><code class="p">][</code><code class="mi">3</code><code class="p">]</code><code class="kt">int</code><code class="w"/></pre>

<p>This declares <code>x</code> to be an array of length 2 whose type is an array of <code>int</code>s of length 3. This sounds pedantic, but some languages have true matrix support, like Fortran or Julia; Go isn’t one of them.</p>

<p>Like most languages, arrays<a data-type="indexterm" data-primary="arrays" data-secondary="reading and writing" id="id837"/> in Go are read and written using bracket syntax:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">])</code><code class="w"/></pre>

<p>You cannot read or write past the end of an array or use a negative index. If you do this with a constant or literal index, it is a compile-time error. <a data-type="indexterm" data-primary="panics" data-secondary="array access out of bounds" id="id838"/>An out-of-bounds read or write with a variable index compiles but fails at runtime with a <em>panic</em> (you’ll learn more about panics in <a data-type="xref" href="ch09.html#panic_recover">“panic and recover”</a>).</p>

<p>Finally, the built-in function <code>len</code> takes in an array and returns its length:<a data-type="indexterm" data-primary="len function" data-secondary="array length" id="id839"/><a data-type="indexterm" data-primary="arrays" data-secondary="len function for length" id="id840"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/></pre>

<p>Earlier I said that arrays in Go are rarely used explicitly. <a data-type="indexterm" data-primary="arrays" data-secondary="size affecting array type" id="id841"/><a data-type="indexterm" data-primary="types" data-secondary="array size affecting type" id="id842"/>This is because they come with an unusual limitation: Go considers the <em>size</em> of the array to be part of the <em>type</em> of the array. This makes an array that’s declared to be <code>[3]int</code> a different type from an array that’s declared to be <code>[4]int</code>. This also means that you cannot use a variable to specify the size of an array, because types must be resolved at compile time, not at runtime.</p>

<p>What’s more, <em>you can’t use<a data-type="indexterm" data-primary="type conversion" data-secondary="arrays of different sizes" id="id843"/> a type conversion to directly convert arrays of different sizes to identical types</em>. Because you can’t convert arrays of different sizes into each other, you can’t write a function that works with arrays of any size and you can’t assign arrays of different sizes to the same variable.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You’ll learn how arrays work behind the scenes when I discuss memory layout in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>.</p>
</div>

<p>Because of these restrictions, don’t use arrays unless you know the exact length you need ahead of time. For example, some of the cryptographic functions in the standard library return arrays because the sizes of checksums are defined as part of the algorithm. This is the exception, not the rule.</p>

<p>This raises the question: why is such a limited feature in the language? The main reason arrays exist in Go is to provide the backing store for <em>slices</em>, which are one of the most useful features of Go.<a data-type="indexterm" data-startref="ch03-arr" id="id844"/><a data-type="indexterm" data-startref="ch03-arr2" id="id845"/><a data-type="indexterm" data-startref="ch03-arr3" id="id846"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Slices"><div class="sect1" id="slice_info">
<h1>Slices</h1>

<p>Most of the time, when you want<a data-type="indexterm" data-primary="slices" id="ch03-slic"/><a data-type="indexterm" data-primary="types" data-secondary="composite types" data-tertiary="slices" id="ch03-slic2"/><a data-type="indexterm" data-primary="composite types" data-secondary="slices" id="ch03-slic3"/><a data-type="indexterm" data-primary="slices" data-secondary="about" id="id847"/><a data-type="indexterm" data-primary="arrays" data-secondary="size affecting array type" data-tertiary="slices contrasted" id="id848"/><a data-type="indexterm" data-primary="types" data-secondary="array size affecting type" data-tertiary="slices contrasted" id="id849"/> a data structure that holds a sequence of values, a slice is what you should use. What makes slices so useful is that you can grow slices as needed. This is because the length of a slice is <em>not</em> part of its type. This removes the biggest limitations of arrays and allows you to write a single function that processes slices of any size (I’ll cover function writing in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>). After going over the basics of using slices in Go, I’ll cover the best ways to use them.</p>

<p>Working with slices looks a lot like working with arrays, but subtle differences exist. The first thing to notice is that you don’t specify the size of the slice when you declare it:<a data-type="indexterm" data-primary="slices" data-secondary="declaration" id="id850"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">}</code><code class="w"/></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Using <code>[...]</code> makes an array. Using <code>[]</code> makes a slice.<a data-type="indexterm" data-primary="brackets ([ ]) for slices versus arrays" id="id851"/><a data-type="indexterm" data-primary="[ ] (brackets) for slices versus arrays" id="id852"/></p>
</div>

<p>This creates a slice of <a data-type="indexterm" data-primary="slice literals" id="id853"/><a data-type="indexterm" data-primary="literals" data-secondary="slice literals" id="id854"/>three <code>int</code>s using a <em>slice literal</em>. Just as with arrays, you can also specify only the indices with nonzero values in the slice literal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">:</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">:</code><code class="w"> </code><code class="mi">100</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">}</code><code class="w"/></pre>

<p>This creates a slice of 12 <code>int</code>s with the following values: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15].</p>

<p>You can simulate multidimensional slices and make a slice of slices:<a data-type="indexterm" data-primary="slices" data-secondary="multidimensional slices simulated" id="id855"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[][]</code><code class="kt">int</code><code class="w"/></pre>

<p>You read and write slices<a data-type="indexterm" data-primary="slices" data-secondary="reading and writing" id="id856"/> using bracket syntax, and, just as with arrays, you can’t read or write past the end or use a negative index:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">])</code><code class="w"/></pre>

<p>So far, slices have seemed identical to arrays. <a data-type="indexterm" data-primary="slices" data-secondary="declaration" data-tertiary="without using literal" id="id857"/>You start to see the differences between arrays and slices when you look at declaring slices without using a literal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/></pre>

<p>This creates a slice of <code>int</code>s. <a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="slices as nil" id="id858"/><a data-type="indexterm" data-primary="slices" data-secondary="zero value as nil" id="id859"/><a data-type="indexterm" data-primary="nil" data-secondary="zero value" data-tertiary="slices" id="id860"/><a data-type="indexterm" data-primary="nil" data-secondary="about" id="id861"/>Since no value is assigned, <code>x</code> is assigned the zero value for a slice, which is something you haven’t seen before: <code>nil</code>.  I’ll talk more about <code>nil</code> in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>, but it is slightly different from the <code>null</code> that’s found in other languages. In Go, <code>nil</code> is an identifier that represents the lack of a value for some types. <a data-type="indexterm" data-primary="types" data-secondary="nil untyped" id="id862"/>Like the untyped numeric constants you saw in the previous chapter, <code>nil</code> has no type, so it can be assigned or compared against values of different types. A <code>nil</code> slice contains 
<span class="keep-together">nothing.</span></p>

<p>A slice is the first type you’ve seen<a data-type="indexterm" data-primary="comparison operators" data-secondary="slices not comparable" id="id863"/><a data-type="indexterm" data-primary="slices" data-secondary="not comparable" id="id864"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="slices not comparable" id="id865"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="slices not comparable" id="id866"/> that isn’t <em>comparable</em>. It is a compile-time error to use <code>==</code> to see if two slices are identical or <code>!=</code> to see if they are different. The only thing you can compare a slice with using <code>==</code> is <code>nil</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/></pre>

<p>Since Go 1.21, the <code>slices</code> package<a data-type="indexterm" data-primary="slices" data-secondary="not comparable" data-tertiary="slices.Equal" id="id867"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="slices not comparable" data-tertiary="slices.Equal" id="id868"/><a data-type="indexterm" data-primary="standard library" data-secondary="slices package" id="id869"/><a data-type="indexterm" data-primary="slices package in standard library" id="id870"/><a data-type="indexterm" data-primary="slices" data-secondary="slices package in standard library" id="id871"/> in the standard library includes two functions to compare slices. The <code>slices.Equal</code> function takes in two slices and returns <code>true</code> if the slices are the same length, and all of the elements are equal. It requires the elements of the slice to be comparable. <a data-type="indexterm" data-primary="slices" data-secondary="not comparable" data-tertiary="slices.EqualFunc" id="id872"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="slices not comparable" data-tertiary="slices.EqualFunc" id="id873"/>The other function, <code>slices.EqualFunc</code>, lets you pass in a function to determine equality and does not require the slice elements to be comparable. You’ll learn about passing functions into functions in <a data-type="xref" href="ch05.html#func_param">“Passing Functions as Parameters”</a>. The other functions in the <code>slices</code> package are covered in <a data-type="xref" href="ch08.html#slice_map_funcs">“Adding Generics to the Standard Library”</a>.</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">}</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">}</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">slices</code><code class="p">.</code><code class="nx">Equal</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">))</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">slices</code><code class="p">.</code><code class="nx">Equal</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">z</code><code class="p">))</code><code class="w"> </code><code class="c1">// prints false</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">slices</code><code class="p">.</code><code class="nx">Equal</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">))</code><code class="w"> </code><code class="c1">// does not compile</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The <code>reflect</code> package contains<a data-type="indexterm" data-primary="slices" data-secondary="not comparable" data-tertiary="DeepEqual in reflect package" id="id874"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="slices not comparable" data-tertiary="DeepEqual in reflect package" id="id875"/><a data-type="indexterm" data-primary="DeepEqual in reflect package" id="id876"/><a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.DeepEqual" id="id877"/> a function called <code>DeepEqual</code> that can compare almost anything, including slices. It’s a legacy function, primarily intended for testing. Before the inclusion of 
<span class="keep-together"><code>slices.Equal</code></span> and <code>slices.EqualFunc</code>, <code>reflect.DeepEqual</code> was often used to compare slices. Don’t use it in new code, as it is slower and less safe than using the functions in the <code>slices</code> package.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="len"><div class="sect2" id="id216">
<h2>len</h2>

<p>Go provides several built-in functions to work with slices.<a data-type="indexterm" data-primary="len function" data-secondary="slice length" id="id878"/><a data-type="indexterm" data-primary="slices" data-secondary="len function for length" id="id879"/> You’ve already seen the built-in <code>len</code> function when looking at arrays. It works for slices too. Passing a <code>nil</code> slice to <code>len</code> returns 0.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Functions like <code>len</code> are built into Go because they can do things that can’t be done by the functions that you can write. You’ve already seen that <code>len</code>’s parameter can be any type of array or any type of slice. You’ll soon see that it also works for strings and maps. In <a data-type="xref" href="ch12.html#channels">“Channels”</a>, you’ll see it working with channels. Trying to pass a variable of any other type to <code>len</code> is a compile-time error. As you’ll see in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>, Go doesn’t let developers write a function that accepts any string, array, slice, channel, or map, but rejects other types.</p>
</div>
</div></section>








<section data-type="sect2" class="less_space" data-pdf-bookmark="append"><div class="sect2" id="id34">
<h2>append</h2>

<p>The built-in <code>append</code> function is used to grow slices:<a data-type="indexterm" data-primary="append function" data-secondary="slices grown via" id="id880"/><a data-type="indexterm" data-primary="slices" data-secondary="append function to grow" id="id881"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"> </code><code class="c1">// assign result to the variable that's passed in</code><code class="w"/></pre>

<p>The <code>append</code> function takes at least two parameters, a slice of any type and a value of that type. It returns a slice of the same type, which is assigned to the variable that was passed to <code>append</code>. In this example, you are appending to a <code>nil</code> slice, but you can append to a slice that already has elements:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">)</code><code class="w"/></pre>

<p>You can append more than one value at a time:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">)</code><code class="w"/></pre>

<p>One slice is appended onto another<a data-type="indexterm" data-primary=". . . operator" data-secondary="slice appended onto another" id="id882"/> by using the <code>...</code> operator to expand the source slice into individual values (you’ll learn more about the <code>...</code> operator in <a data-type="xref" href="ch05.html#vararg">“Variadic Input Parameters and Slices”</a>):</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">}</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="o">...</code><code class="p">)</code><code class="w"/></pre>

<p>It is a compile-time error if you forget<a data-type="indexterm" data-primary="Go" data-secondary="call-by-value language" id="id883"/><a data-type="indexterm" data-primary="append function" data-secondary="not assigning return value as error" id="id884"/><a data-type="indexterm" data-primary="errors" data-secondary="compile-time errors" data-tertiary="append return value not assigned" id="id885"/><a data-type="indexterm" data-primary="functions" data-secondary="call-by-value language" id="id886"/><a data-type="indexterm" data-primary="call-by-value language" id="id887"/><a data-type="indexterm" data-primary="parameters" data-secondary="call-by-value language" id="id888"/><a data-type="indexterm" data-primary="errors" data-secondary="Go as call-by-value language" id="id889"/><a data-type="indexterm" data-primary="variables" data-secondary="call-by-value language" id="id890"/><a data-type="indexterm" data-primary="parameters" data-secondary="input parameters not modified" id="id891"/><a data-type="indexterm" data-primary="functions" data-secondary="input parameters not modified" id="id892"/> to assign the value returned from <code>append</code>. You might be wondering why as it seems a bit repetitive. I will talk about this in greater detail in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>, but Go is a <em>call-by-value</em> language. Every time you pass a parameter to a function, Go makes a copy of the value that’s passed in. Passing a slice to the <code>append</code> function actually passes a copy of the slice to the function. The function adds the values to the copy of the slice and returns the copy. You then assign the returned slice back to the variable in the calling function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Capacity"><div class="sect2" id="id35">
<h2>Capacity</h2>

<p>As you’ve seen, a slice is a sequence<a data-type="indexterm" data-primary="slices" data-secondary="capacity" id="id893"/><a data-type="indexterm" data-primary="capacity of slices" id="id894"/><a data-type="indexterm" data-primary="append function" data-secondary="slices grown via" data-tertiary="capacity of slices" id="id895"/> of values. Each element in a slice is assigned to consecutive memory locations, which makes it quick to read or write these values. The length of a slice is the number of consecutive memory locations that have been assigned a value. Every slice also has a <em>capacity</em>, which is the number of consecutive memory locations reserved. This can be larger than the length. Each time you append to a slice, one or more values is added to the end of the slice. Each value added increases the length by one. When the length reaches the capacity, there’s no more room to put values. If you try to add additional values when the length equals the capacity, the <code>append</code> function uses the Go runtime to allocate a new backing array for the slice with a larger capacity. The values in the original backing array are copied to the new one, the new values are added to the end of the new backing array, and the slice is updated to refer to the new backing array. Finally, the updated slice is returned.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id896">
<h1>The Go Runtime</h1>
<p>Every high-level language relies<a data-type="indexterm" data-primary="Go runtime" id="id897"/> on a set of libraries to enable programs written in that language to run, and Go is no exception.<a data-type="indexterm" data-primary="garbage collector" data-secondary="Go runtime" id="id898"/><a data-type="indexterm" data-primary="memory" data-secondary="memory allocation via Go runtime" id="id899"/> The Go runtime provides services like memory allocation and garbage collection, concurrency support, networking, and implementations of built-in types and functions.</p>

<p>The Go runtime is compiled<a data-type="indexterm" data-primary="builds" data-secondary="single native binary" data-tertiary="Go runtime compiled into" id="id900"/><a data-type="indexterm" data-primary="compiling" data-secondary="single native binary" data-tertiary="Go runtime compiled into" id="id901"/><a data-type="indexterm" data-primary="Go" data-secondary="compiling to a single native binary" data-tertiary="Go runtime compiled into" id="id902"/> into every Go binary. This is different from languages that use a virtual machine, which must be installed separately to allow programs written in those languages to function. Including the runtime in the binary makes it easier to distribute Go programs and avoids worries about compatibility issues between the runtime and the program. The drawback of including the runtime in the binary is that even the simplest Go program produces a binary that’s about 2 MB.</p>
</div></aside>

<p>When a slice grows via <code>append</code>, it takes<a data-type="indexterm" data-primary="garbage collector" data-secondary="slices growing" id="id903"/><a data-type="indexterm" data-primary="memory" data-secondary="slices growing" id="id904"/> time for the Go runtime to allocate new memory and copy the existing data from the old memory to the new. The old memory also needs to be garbage collected. For this reason, the Go runtime usually increases a slice by more than one each time it runs out of capacity. The rule as of Go 1.18 is to double the capacity of a slice when the current capacity is less than 256. A bigger slice increases by <code>(current_capacity + 768)/4</code>. This slowly converges at 25% growth (a slice with capacity of 512 will grow by 63%, but a slice with capacity 4,096 will grow by only 30%).</p>

<p>Just as the built-in <code>len</code> function returns the current length of a slice, <a data-type="indexterm" data-primary="cap function" data-secondary="slice capacity" id="id905"/><a data-type="indexterm" data-primary="slices" data-secondary="capacity" data-tertiary="cap function for capacity" id="id906"/>the built-in <code>cap</code> function returns the current capacity of a slice. It is used far less frequently than <code>len</code>. Most of the time, <code>cap</code> is used to check if a slice is large enough to hold new data, or if a call to <code>make</code> is needed to create a new slice.</p>

<p>You can also pass an array to the <code>cap</code> function, but <code>cap</code> always returns the same value as <code>len</code> for arrays. Don’t put it in your code, but save this trick for Go trivia night.</p>

<p>Let’s take a look at how adding elements<a data-type="indexterm" data-primary="len function" data-secondary="slice length" data-tertiary="example code" id="id907"/><a data-type="indexterm" data-primary="cap function" data-secondary="slice capacity" data-tertiary="example code" id="id908"/><a data-type="indexterm" data-primary="slices" data-secondary="len function for length" data-tertiary="example code" id="id909"/><a data-type="indexterm" data-primary="slices" data-secondary="capacity" data-tertiary="example code" id="id910"/> to a slice changes the length and capacity. Run the code in <a data-type="xref" href="#EX3_1">Example 3-1</a> on <a href="https://oreil.ly/yiHu-">The Go Playground</a> or in the <em>sample_code/len_cap</em> directory in the <a href="https://oreil.ly/dZMDe">Chapter 3 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id911"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id912"/></p>
<div id="EX3_1" data-type="example">
<h5><span class="label">Example 3-1. </span>Understanding capacity</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">40</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/></pre></div>

<p>When you build and run the code, you’ll see the following output. Notice how and when the capacity increases:</p>

<pre data-type="programlisting">[] 0 0
[10] 1 1
[10 20] 2 2
[10 20 30] 3 4
[10 20 30 40] 4 4
[10 20 30 40 50] 5 8</pre>

<p>While it’s nice that slices grow automatically, it’s far more efficient to size them once. If you know how many things you plan to put into a slice, create it with the correct initial capacity. You do that with the <code>make</code> function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="make"><div class="sect2" id="id217">
<h2>make</h2>

<p>You’ve already seen two ways to declare a slice,<a data-type="indexterm" data-primary="slices" data-secondary="declaration" data-tertiary="make function for specifics" id="id913"/><a data-type="indexterm" data-primary="make function" data-secondary="slice declaration" id="id914"/> using a slice literal or the <code>nil</code> zero value. While useful, neither way allows you to create an empty slice that already has a length or capacity specified. That’s the job of the built-in <code>make</code> function. It allows you to specify the type, length, and, optionally, the capacity. Let’s take a look:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/></pre>

<p>This creates an <code>int</code> slice with a length of 5 and a capacity of 5. Since it has a length of 5, <code>x[0]</code> through <code>x[4]</code> are valid elements, and they are all initialized to 0.</p>

<p>One common beginner mistake is to try to populate those initial elements using <code>append</code>:<a data-type="indexterm" data-primary="make function" data-secondary="slice declaration" data-tertiary="append function after" id="id915"/><a data-type="indexterm" data-primary="slices" data-secondary="declaration" data-tertiary="make function with append function after" id="id916"/><a data-type="indexterm" data-primary="troubleshooting" data-secondary="make function slice with append after" id="id917"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>

<p>The 10 is placed at the end of the slice, <em>after</em> the zero values in elements 0–4 because <code>append</code> always increases the length of a slice. The value of <code>x</code> is now [0 0 0 0 0 10], with a length of 6 and a capacity of 10 (the capacity was doubled as soon as the sixth element was appended).</p>

<p>You can also specify an initial capacity with <code>make</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>

<p>This creates an <code>int</code> slice with a length of 5 and a capacity of 10.</p>

<p>You can also create a slice with zero length but a capacity that’s greater than zero:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>

<p>In this case, you have a non-<code>nil</code> slice with a length of 0 but a capacity of 10. Since the length is 0, you can’t directly index into it, but you can append values to it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">,</code><code class="mi">7</code><code class="p">,</code><code class="mi">8</code><code class="p">)</code><code class="w"/></pre>

<p>The value of <code>x</code> is now [5 6 7 8], with a length of 4 and a capacity of 10.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Never specify a capacity that’s less<a data-type="indexterm" data-primary="slices" data-secondary="capacity" data-tertiary="never less than length" id="id918"/><a data-type="indexterm" data-primary="capacity of slices" data-secondary="never less than length" id="id919"/><a data-type="indexterm" data-primary="errors" data-secondary="compile-time errors" data-tertiary="slice capacity less than length" id="id920"/><a data-type="indexterm" data-primary="panics" data-secondary="slice capacity less than length" id="id921"/> than the length! It is a compile-time error to do so with a constant or numeric literal. If you use a variable to specify a capacity that’s smaller than the length, your program will panic at runtime.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Emptying a Slice"><div class="sect2" id="empty_slice">
<h2>Emptying a Slice</h2>

<p>Go 1.21 added a <code>clear</code> function that<a data-type="indexterm" data-primary="slices" data-secondary="all elements to zero value" id="id922"/><a data-type="indexterm" data-primary="clear function" data-secondary="slice elements to zero value" id="id923"/> takes in a slice and sets all of the slice’s elements to their zero value. The length of the slice remains unchanged. The following code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"first"</code><code class="p">,</code><code class="w"> </code><code class="s">"second"</code><code class="p">,</code><code class="w"> </code><code class="s">"third"</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">))</code><code class="w"/>
<code class="nb">clear</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">))</code><code class="w"/></pre>

<p>prints out:</p>

<pre data-type="programlisting">[first second third] 3
[  ] 3</pre>

<p>(Remember, the zero value for a string is an empty string <code>""</code>!)</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Declaring Your Slice"><div class="sect2" id="id219">
<h2>Declaring Your Slice</h2>

<p>Now that you’ve seen all these<a data-type="indexterm" data-primary="slices" data-secondary="declaration" data-tertiary="which to use when" id="id924"/> ways to create slices, how do you choose which slice declaration style to use? The primary goal is to minimize the number of times the slice needs to grow. If it’s possible that the slice won’t need to grow at all, use a <code>var</code> declaration with no assigned value to create a <code>nil</code> slice, as shown in <a data-type="xref" href="#EX3_7">Example 3-2</a>.</p>
<div id="EX3_7" data-type="example">
<h5><span class="label">Example 3-2. </span>Declaring a slice that might stay <code>nil</code></h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can create a slice using an empty slice literal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/></pre>

<p>This creates a slice with zero length and zero capacity. It is confusingly different from a <code>nil</code> slice. Because of implementation reasons, comparing a zero-length slice to <code>nil</code> returns <code>false</code>, while comparing a <code>nil</code> slice to <code>nil</code> returns <code>true</code>. For simplicity, favor <code>nil</code> slices. A zero-length slice is useful only when converting a slice to JSON. You’ll look at this more in <a data-type="xref" href="ch13.html#json">“encoding/json”</a>.</p>
</div>

<p>If you have some starting values, or if a slice’s values aren’t going to change, then a slice literal is a good choice (see <a data-type="xref" href="#EX3_8">Example 3-3</a>).</p>
<div id="EX3_8" data-type="example">
<h5><span class="label">Example 3-3. </span>Declaring a slice with default values</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">}</code><code class="w"> </code><code class="c1">// numbers we appreciate</code><code class="w"/></pre></div>

<p>If you have a good idea of how large your slice needs to be, but don’t know what those values will be when you are writing the program, use <code>make</code>. The question then becomes whether you should specify a nonzero length in the call to <code>make</code> or specify a zero length and a nonzero capacity. There are three possibilities:</p>

<ul class="less_space">
<li>
<p>If you are using a slice as a buffer (you’ll see this in <a data-type="xref" href="ch13.html#io_friends">“io and Friends”</a>), then specify a nonzero length.</p>
</li>
<li>
<p>If you are <em>sure</em> you know the exact size you want, you can specify the length and index into the slice to set the values. This is often done when transforming values in one slice and storing them in a second. The downside to this approach is that if you have the size wrong, you’ll end up with either zero values at the end of the slice or a panic from trying to access elements that don’t exist.</p>
</li>
<li>
<p>In other situations, use <code>make</code> with a zero length and a specified capacity. This allows you to use <code>append</code> to add items to the slice. If the number of items turns out to be smaller, you won’t have an extraneous zero value at the end. If the number of items is larger, your code will not panic.</p>
</li>
</ul>

<p>The Go community is split between the second and third approaches. I personally prefer using <code>append</code> with a slice initialized to a zero length. It might be slower in some situations, but it is less likely to introduce a bug.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><code>append</code> always increases<a data-type="indexterm" data-primary="make function" data-secondary="slice declaration" data-tertiary="append function after" id="id925"/><a data-type="indexterm" data-primary="slices" data-secondary="declaration" data-tertiary="make function with append function after" id="id926"/><a data-type="indexterm" data-primary="troubleshooting" data-secondary="make function slice with append after" id="id927"/> the length of a slice! If you have specified a slice’s length using <code>make</code>, be sure that you mean to append to it before you do so, or you might end up with a bunch of surprise zero values at the beginning of your slice.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Slicing Slices"><div class="sect2" id="id36">
<h2>Slicing Slices</h2>

<p>A <em>slice expression</em> creates a slice<a data-type="indexterm" data-primary="slices" data-secondary="slices from slices" id="ch03-slfrsl"/><a data-type="indexterm" data-primary="slice expressions" id="ch03-slfrsl2"/> from a slice. It’s written inside brackets and consists of a starting offset and an ending offset, separated by a colon (:). The starting offset is the first position in the slice that is included in the new slice, and the ending offset is one past the last position to include. If you leave off the starting offset, 0 is assumed. Likewise, if you leave off the ending offset, the end of the slice is substituted. You can see how this works by running the code in <a data-type="xref" href="#EX3_9">Example 3-4</a> on <a href="https://oreil.ly/PFtfZ">The Go Playground</a> or in the <em>sample_code/slicing_slices</em> directory in the <a href="https://oreil.ly/Ka-rJ">Chapter 3 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="ix_ccc"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="ix_cccc"/></p>
<div id="EX3_9" data-type="example">
<h5><span class="label">Example 3-4. </span>Slicing slices</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">,</code><code class="w"> </code><code class="s">"d"</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code><code class="w"/>
<code class="nx">d</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">:</code><code class="mi">3</code><code class="p">]</code><code class="w"/>
<code class="nx">e</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"x:"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"y:"</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"z:"</code><code class="p">,</code><code class="w"> </code><code class="nx">z</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"d:"</code><code class="p">,</code><code class="w"> </code><code class="nx">d</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"e:"</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">)</code><code class="w"/></pre></div>

<p>It gives the following output:</p>

<pre data-type="programlisting">x: [a b c d]
y: [a b]
z: [b c d]
d: [b c]
e: [a b c d]</pre>

<p>When you take a slice from a slice,<a data-type="indexterm" data-primary="slice expressions" data-secondary="sharing memory" id="id928"/><a data-type="indexterm" data-primary="slices" data-secondary="slices from slices" data-tertiary="sharing memory" id="id929"/><a data-type="indexterm" data-primary="variables" data-secondary="slices from slices sharing memory" data-seealso="slices" id="id930"/> you are <em>not</em> making a copy of the data. Instead, you now have two variables that are sharing memory. This means that changes to an element in a slice affect all slices that share that element. Let’s see what happens when you change values. You can run the code in <a data-type="xref" href="#EX3_10">Example 3-5</a> on <a href="https://oreil.ly/xEw9J">The Go Playground</a> or in the <em>sample_code/slice_share_storage</em> directory in the <a href="https://oreil.ly/nYkrx">Chapter 3 repository</a>.</p>
<div id="EX3_10" data-type="example">
<h5><span class="label">Example 3-5. </span>Slices with overlapping storage</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">,</code><code class="w"> </code><code class="s">"d"</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code><code class="w"/>
<code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"y"</code><code class="w"/>
<code class="nx">y</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"x"</code><code class="w"/>
<code class="nx">z</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"z"</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"x:"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"y:"</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"z:"</code><code class="p">,</code><code class="w"> </code><code class="nx">z</code><code class="p">)</code><code class="w"/></pre></div>

<p>You get the following output:</p>

<pre data-type="programlisting">x: [x y z d]
y: [x y]
z: [y z d]</pre>

<p>Changing <code>x</code> modified both <code>y</code> and <code>z</code>, while changes to <code>y</code> and <code>z</code> modified <code>x</code>.</p>

<p>Slicing slices gets extra confusing when combined with <code>append</code>. Try out the code in <a data-type="xref" href="#EX3_11">Example 3-6</a> on <a href="https://oreil.ly/4f4pd">The Go Playground</a> or in the <em>sample_code/slice_append_storage</em> directory in the <a href="https://oreil.ly/H1YKD">Chapter 3 repository</a>.</p>
<div id="EX3_11" data-type="example">
<h5><span class="label">Example 3-6. </span><code>append</code> makes overlapping slices more confusing</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">,</code><code class="w"> </code><code class="s">"d"</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">y</code><code class="p">))</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="s">"z"</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"x:"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"y:"</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/></pre></div>

<p>Running this code gives the following output:</p>

<pre data-type="programlisting">4 4
x: [a b z d]
y: [a b z]</pre>

<p class="pagebreak-before">What’s going on? Whenever you take a slice from another slice, the subslice’s capacity is set to the capacity of the original slice, minus the starting offset of the subslice within the original slice. This means elements of the original slice beyond the end of the subslice, including unused capacity, are shared by both slices.</p>

<p>When you make the <code>y</code> slice from <code>x</code>, the length is set to 2, but the capacity is set to 4, the same as <code>x</code>. Since the capacity is 4, appending onto the end of <code>y</code> puts the value in the third position of <code>x</code>.</p>

<p>This behavior creates some odd scenarios, with multiple slices appending and overwriting each other’s data. See if you can guess what the code in <a data-type="xref" href="#EX3_12">Example 3-7</a> prints out, then run it on <a href="https://oreil.ly/KCveh">The Go Playground</a> or in the <em>sample_code/confusing_slices</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a> to see if you guessed correctly.</p>
<div id="EX3_12" data-type="example">
<h5><span class="label">Example 3-7. </span>Even more confusing slices</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">,</code><code class="w"> </code><code class="s">"d"</code><code class="p">)</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">cap</code><code class="p">(</code><code class="nx">x</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">y</code><code class="p">),</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">z</code><code class="p">))</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="s">"i"</code><code class="p">,</code><code class="w"> </code><code class="s">"j"</code><code class="p">,</code><code class="w"> </code><code class="s">"k"</code><code class="p">)</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="s">"x"</code><code class="p">)</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">z</code><code class="p">,</code><code class="w"> </code><code class="s">"y"</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"x:"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"y:"</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"z:"</code><code class="p">,</code><code class="w"> </code><code class="nx">z</code><code class="p">)</code><code class="w"/></pre></div>

<p>To avoid complicated slice situations, <a data-type="indexterm" data-primary="append function" data-secondary="slices grown via" data-tertiary="full slice expression protecting subslices" id="id931"/><a data-type="indexterm" data-primary="slices" data-secondary="slices from slices" data-tertiary="full slice expression protecting from append" id="id932"/><a data-type="indexterm" data-primary="slices" data-secondary="append function to grow" data-tertiary="full slice expression protecting subslices" id="id933"/><a data-type="indexterm" data-primary="slices" data-secondary="full slice expressions" id="id934"/><a data-type="indexterm" data-primary="slice expressions" data-secondary="full slice expressions" id="id935"/>you should either never use <code>append</code> with a subslice or make sure that <code>append</code> doesn’t cause an overwrite by using a <em>full slice expression</em>. This is a little weird, but it makes clear how much memory is shared between the parent slice and the subslice. The full slice expression includes a third part, which indicates the last position in the parent slice’s capacity that’s available for the subslice. Subtract the starting offset from this number to get the subslice’s capacity. <a data-type="xref" href="#EX3_13">Example 3-8</a> shows the first four lines from the previous example, modified to use full slice expressions.</p>
<div id="EX3_13" data-type="example">
<h5><span class="label">Example 3-8. </span>The full slice expression protects against <code>append</code></h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">,</code><code class="w"> </code><code class="s">"d"</code><code class="p">)</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">:</code><code class="mi">4</code><code class="p">:</code><code class="mi">4</code><code class="p">]</code><code class="w"/></pre></div>

<p class="pagebreak-before">Try out this code on <a href="https://oreil.ly/G7YBT">The Go Playground</a> or in the <em>sample_code/full_slice_expression</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>. Both <code>y</code> and <code>z</code> have a capacity of <code>2</code>. Because you limited the capacity of the subslices to their lengths, appending additional elements onto <code>y</code> and <code>z</code> created new slices that didn’t interact with the other slices. After this code runs, <code>x</code> is set to <code>[a b c d x]</code>, <code>y</code> is set to <code>[a b i j k]</code>, and <code>z</code> is set to <code>[c d y]</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be careful when taking a slice of a slice! Both slices share the same memory, and changes to one are reflected in the other. Avoid modifying slices after they have been sliced or if they were produced by slicing. Use a three-part slice expression to prevent <code>append</code> from sharing capacity between slices.<a data-type="indexterm" data-startref="ch03-slfrsl" id="id936"/><a data-type="indexterm" data-startref="ch03-slfrsl2" id="id937"/></p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="copy"><div class="sect2" id="copy_slice">
<h2>copy</h2>

<p>If you need to create a slice<a data-type="indexterm" data-primary="slices" data-secondary="copy function" id="id938"/><a data-type="indexterm" data-primary="copy function for slices" id="id939"/> that’s independent of the original, use the built-in 
<span class="keep-together"><code>copy</code> function.</span> Let’s take a look at a simple example, which you can run on <a href="https://oreil.ly/ilMNY">The Go Playground</a> or in the <em>sample_code/copy_slice</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">)</code><code class="w"/>
<code class="nx">num</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">copy</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">)</code><code class="w"/></pre>

<p>You get this output:</p>

<pre data-type="programlisting">[1 2 3 4] 4</pre>

<p>The <code>copy</code> function takes two parameters. The first is the destination slice, and the second is the source slice. The function copies as many values as it can from source to destination, limited by whichever slice is smaller, and returns the number of elements copied. The <em>capacity</em> of <code>x</code> and <code>y</code> doesn’t matter; it’s the length that’s important.</p>

<p>You can also copy a subset of a slice. The following code copies the first two elements of a four-element slice into a two-element slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="nx">num</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">copy</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/></pre>

<p>The variable <code>y</code> is set to [1 2], and <code>num</code> is set to 2.</p>

<p>You could also copy from the middle of the source slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="nb">copy</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">:])</code><code class="w"/></pre>

<p class="pagebreak-before">You are copying the third and fourth elements in <code>x</code> by taking a slice of the slice. Also note that <em>you don’t assign the output of <code>copy</code> to a variable</em>. If you don’t need the number of elements copied, you don’t need to assign it.</p>

<p>The <code>copy</code> function allows you to copy between two slices that cover overlapping sections of an underlying slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">num</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">copy</code><code class="p">(</code><code class="nx">x</code><code class="p">[:</code><code class="mi">3</code><code class="p">],</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">:])</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">)</code><code class="w"/></pre>

<p>In this case, you are copying the last three values in <code>x</code> on top of the first three values of <code>x</code>. This prints out [2 3 4 4] 3.</p>

<p>You can use <code>copy</code> with arrays by taking a slice of the array. You can make the array either the source or the destination of the copy. You can try out the following code on <a href="https://oreil.ly/-mhRW">The Go Playground</a> or in the <em>sample_code/copy_array</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">d</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="nb">copy</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="w"> </code><code class="nx">d</code><code class="p">[:])</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nb">copy</code><code class="p">(</code><code class="nx">d</code><code class="p">[:],</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">d</code><code class="p">)</code><code class="w"/></pre>

<p>The first call to <code>copy</code> copies the first two values in array <code>d</code> into slice <code>y</code>. The second copies all of the values in slice <code>x</code> into array <code>d</code>. This produces the following output:<a data-type="indexterm" data-startref="ch03-slic" id="id940"/><a data-type="indexterm" data-startref="ch03-slic2" id="id941"/><a data-type="indexterm" data-startref="ch03-slic3" id="id942"/></p>

<pre data-type="programlisting">[5 6]
[1 2 3 4]</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Converting Arrays to Slices"><div class="sect2" id="id38">
<h2>Converting Arrays to Slices</h2>

<p>Slices aren’t the only thing you can slice.<a data-type="indexterm" data-primary="arrays" data-secondary="converting to slices" id="id943"/><a data-type="indexterm" data-primary="slices" data-secondary="arrays converted to" id="id944"/> If you have an array, you can take a slice from it using a slice expression. This is a useful way to bridge an array to a function that takes only slices. To convert an entire array into a slice, use the <code>[:]</code> syntax:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">xArray</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">}</code><code class="w"/>
<code class="nx">xSlice</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">xArray</code><code class="p">[:]</code><code class="w"/></pre>

<p>You can also convert a subset of an array into a slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="w"/></pre>

<p>Be aware that taking a slice from an array has the same memory-sharing properties as taking a slice from a slice. If you run the following code on <a href="https://oreil.ly/kliaJ">The Go Playground</a> or in the <em>sample_code/slice_array_memory</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>:<a data-type="indexterm" data-startref="ix_ccc" id="id945"/><a data-type="indexterm" data-startref="ix_cccc" id="id946"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">}</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[:</code><code class="mi">2</code><code class="p">]</code><code class="w"/>
<code class="nx">z</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="w"/>
<code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"x:"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"y:"</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"z:"</code><code class="p">,</code><code class="w"> </code><code class="nx">z</code><code class="p">)</code><code class="w"/></pre>

<p>you get this output:</p>

<pre data-type="programlisting">x: [10 6 7 8]
y: [10 6]
z: [7 8]</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Converting Slices to Arrays"><div class="sect2" id="id220">
<h2>Converting Slices to Arrays</h2>

<p>Use a type conversion to make an array<a data-type="indexterm" data-primary="arrays" data-secondary="slices converted to" id="id947"/><a data-type="indexterm" data-primary="slices" data-secondary="converted to arrays" id="id948"/> variable from a slice. You can convert an entire slice to an array of the same type, or you can create an array from a subset of the slice.</p>

<p>When you convert a slice to an array, the data in the slice is copied to new memory. That means that changes to the slice won’t affect the array, and vice versa.</p>

<p>The following code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">xSlice</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">xArray</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="nb">int</code><code class="p">(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"/>
<code class="nx">smallArray</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="nb">int</code><code class="p">(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"/>
<code class="nx">xSlice</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xArray</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">smallArray</code><code class="p">)</code><code class="w"/></pre>

<p>prints out:</p>

<pre data-type="programlisting">[10 2 3 4]
[1 2 3 4]
[1 2]</pre>

<p>The size of the array must be specified at compile time. It’s a compile-time error to use <code>[...]</code> in a slice to array type conversion.</p>

<p>While the size of the array can be smaller than the size of the slice, it cannot be bigger. Unfortunately, the compiler cannot detect this, and your code will panic at runtime if you specify an array size that’s bigger than the length (not the capacity) of the slice. The following code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">panicArray</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="nb">int</code><code class="p">(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">panicArray</code><code class="p">)</code><code class="w"/></pre>

<p class="pagebreak-before">panics at runtime with the message:</p>

<pre data-type="programlisting">panic: runtime error: cannot convert slice with length 4 to array
     or pointer to array with length 5</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I haven’t talked about pointers yet, but you can also use a type conversion to convert a slice into a pointer to an array:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">xSlice</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">}</code><code class="w"/>
<code class="nx">xArrayPointer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">int</code><code class="p">)(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"/></pre>

<p>After converting a slice to an array pointer, the storage between the two is shared. A change to one will change the other:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">xSlice</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">xArrayPointer</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xSlice</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints [10 20 3 4]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xArrayPointer</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints &amp;[10 20 3 4]</code><code class="w"/></pre>

<p>Pointers are covered in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>.</p>
</div>

<p>You can try all of the array type conversions on <a href="https://oreil.ly/Ss4Ea">The Go Playground</a> or in the <em>sample_code/array_conversion</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="ix_ccc2"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="ix_cccc2"/></p>

<p>In <a data-type="xref" href="#arrays">“Arrays—Too Rigid to Use Directly”</a>, I mentioned that you can’t use <a data-type="indexterm" data-primary="arrays" data-secondary="size affecting array type" data-tertiary="converting array to slice to array" id="id949"/><a data-type="indexterm" data-primary="types" data-secondary="array size affecting type" data-tertiary="converting array to slice to array" id="id950"/>arrays as function parameters when the size of the array being passed in might vary. Technically, you can work around this limitation by converting an array to a slice, converting the slice to an array of a different size, and then passing the second array in to a function. The second array must be shorter than the first array, or your program will panic. While this might be helpful in a pinch, if you find yourself doing this frequently, strongly consider changing your function’s API to take a slice instead of an array.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Strings and Runes and Bytes"><div class="sect1" id="strings_runes_bytes">
<h1>Strings and Runes and Bytes</h1>

<p>Now that I’ve talked about slices,<a data-type="indexterm" data-primary="string type" data-secondary="bytes representing string" id="id951"/><a data-type="indexterm" data-primary="types" data-secondary="composite types" data-tertiary="strings, runes, bytes" id="ch03-srb"/><a data-type="indexterm" data-primary="string type" id="ch03-srb2"/><a data-type="indexterm" data-primary="rune integer type" id="ch03-srb3"/><a data-type="indexterm" data-primary="byte for uint8" data-secondary="strings as sequences of" id="ch03-srb4"/><a data-type="indexterm" data-primary="composite types" data-secondary="strings, runes, bytes" id="ch03-srb5"/><a data-type="indexterm" data-primary="types" data-secondary="rune integer type" id="ch03-srb6"/><a data-type="indexterm" data-primary="types" data-secondary="byte for uint8" data-tertiary="strings as sequences of" id="ch03-srb7"/> we can look at strings again. You might think that a string in Go is made out of runes, but that’s not the case. Under the covers, Go uses a sequence of bytes to represent a string. These bytes don’t have to be in any particular character encoding, but several Go library functions (and the <code>for-range</code> loop that I discuss in the next chapter) assume that a string is composed of a sequence of UTF-8-encoded code points.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>According to the language specification,<a data-type="indexterm" data-primary="string literals" data-secondary="UTF-8" id="id952"/><a data-type="indexterm" data-primary="UTF-8 for string literals" id="id953"/> Go source code is always written in UTF-8. Unless you use hexadecimal escapes in a string literal, your string literals are written in UTF-8.</p>
</div>

<p>Just as you can extract a single value<a data-type="indexterm" data-primary="string type" data-secondary="extracting single value from" id="id954"/><a data-type="indexterm" data-primary="index expression for strings" id="id955"/> from an array or a slice, you can extract a single value from a string by using an <em>index expression</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Hello there"</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="mi">6</code><code class="p">]</code><code class="w"/></pre>

<p>Like arrays and slices, string indexes are zero-based; in this example, <code>b</code> is assigned the numeric value of the seventh position in <code>s</code>, which is <code>116</code> (the UTF-8 value of a lowercase t).</p>

<p>The slice expression notation<a data-type="indexterm" data-primary="string type" data-secondary="slice expression notation working with" id="id956"/> that you used with arrays and slices also works with strings:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Hello there"</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s2</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="mi">4</code><code class="p">:</code><code class="mi">7</code><code class="p">]</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s3</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[:</code><code class="mi">5</code><code class="p">]</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s4</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="mi">6</code><code class="p">:]</code><code class="w"/></pre>

<p>This assigns “o t” to <code>s2</code>, “Hello” to <code>s3</code>, and “there” to <code>s4</code>. You can try out this code <a href="https://oreil.ly/pF8T6">on The Go Playground</a> or in the <em>sample_code/string_slicing</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.</p>

<p>While it’s handy that Go allows you to use slicing notation to make substrings and use index notation to extract individual entries from a string, you should be careful when doing so. Since strings are immutable, they don’t have the modification problems that slices of slices do. <a data-type="indexterm" data-primary="string literals" data-secondary="UTF-8" data-tertiary="string bytes versus UTF-8 multi-byte code points" id="id957"/><a data-type="indexterm" data-primary="UTF-8 for string literals" data-secondary="string bytes versus UTF-8 multi-byte code points" id="id958"/><a data-type="indexterm" data-primary="code points" data-secondary="string bytes versus UTF-8 multi-byte code points" id="id959"/><a data-type="indexterm" data-primary="byte for uint8" data-secondary="strings as sequences of" data-tertiary="string bytes versus UTF-8 multi-byte code points" id="id960"/><a data-type="indexterm" data-primary="types" data-secondary="byte for uint8" data-tertiary="string bytes versus UTF-8 multi-byte code points" id="id961"/>There is a different problem, though. A string is composed of a sequence of bytes, while a code point in UTF-8 can be anywhere from one to four bytes long. The previous example was entirely composed of code points that are one byte long in UTF-8, so everything worked out as expected. But when dealing with languages other than English or with emojis, you run into code points that are multiple bytes long in UTF-8:</p>
<pre data-type="programlisting" data-code-language="go">
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Hello </code><img src="assets/sun.png" width="150" height="150"/><code class="s">"</code><code class="w">
</code><code class="kd">var</code><code class="w"> </code><code class="nx">s2</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="mi">4</code><code class="p">:</code><code class="mi">7</code><code class="p">]</code><code class="w">
</code><code class="kd">var</code><code class="w"> </code><code class="nx">s3</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="p">:</code><code class="mi">5</code><code class="p">]</code><code class="w">
</code><code class="kd">var</code><code class="w"> </code><code class="nx">s4</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="p">[</code><code class="mi">6</code><code class="p">:</code><code class="p">]</code><code class="w">
</code></pre>

<p>In this example, <code>s3</code> will still be equal to “Hello.” The variable <code>s4</code> is set to the sun emoji. But <code>s2</code> is not set to “o <img src="assets/sun.png" width="150" height="150"/>.” Instead, you get “o <img src="assets/replacement.png" width="150" height="150"/>.” That’s because you copied only the first byte of the sun emoji’s code point, which is not a valid code point on its own.</p>

<p>Go allows you to pass a string<a data-type="indexterm" data-primary="len function" data-secondary="string length in bytes" id="id962"/><a data-type="indexterm" data-primary="string type" data-secondary="len function for length in bytes" id="id963"/> to the built-in <code>len</code> function to find the length of the string. Given that string index and slice expressions count positions in bytes, it’s not surprising that the length returned is the length in bytes, not in code points:</p>
<pre data-type="programlisting" data-code-language="go">
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Hello </code><img src="assets/sun.png" width="150" height="150"/><code class="s">"</code><code class="w">
</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="p">)</code><code class="w">
</code></pre>

<p class="pagebreak-before">This code prints out 10, not 7, because it takes four bytes to represent the sun with smiling face emoji in UTF-8. You can run these sun emoji examples on <a href="https://oreil.ly/6ngTb">The Go Playground</a> or in the <em>sample_code/sun_slicing</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.<a data-type="indexterm" data-startref="ix_ccc2" id="id964"/><a data-type="indexterm" data-startref="ix_cccc2" id="id965"/></p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Even though Go allows you to use slicing and indexing syntax with strings, you should use it only when you know that your string contains only characters that take up one byte.</p>
</div>

<p>Because of this complicated relationship<a data-type="indexterm" data-primary="string type" data-secondary="type conversions to runes and bytes" id="id966"/><a data-type="indexterm" data-primary="rune integer type" data-secondary="type conversions to strings and bytes" id="id967"/><a data-type="indexterm" data-primary="types" data-secondary="rune integer type" data-tertiary="type conversions to strings and bytes" id="id968"/><a data-type="indexterm" data-primary="byte for uint8" data-secondary="strings as sequences of" data-tertiary="type conversions to strings and runes" id="id969"/><a data-type="indexterm" data-primary="types" data-secondary="byte for uint8" data-tertiary="type conversions to strings and runes" id="id970"/><a data-type="indexterm" data-primary="type conversion" data-secondary="strings, runes, and bytes" id="id971"/> among runes, strings, and bytes, Go has some interesting type conversions between these types. A single rune or byte can be converted to a string:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="kt">rune</code><code class="w">    </code><code class="p">=</code><code class="w"> </code><code class="sc">'x'</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w">  </code><code class="p">=</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="kt">byte</code><code class="w">    </code><code class="p">=</code><code class="w"> </code><code class="sc">'y'</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s2</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A common bug for new Go developers is to try to make an <code>int</code> into a <code>string</code> by using a type conversion:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">65</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code><code class="w"/></pre>

<p>This results in <code>y</code> having the value “A,” not “65.” As of Go 1.15, <code>go vet</code> blocks a type conversion to string from any integer type other than <code>rune</code> or <code>byte</code>.</p>
</div>

<p>A string can be converted back<a data-type="indexterm" data-primary="slices" data-secondary="strings converted to" id="id972"/><a data-type="indexterm" data-primary="string type" data-secondary="converted to slices" id="id973"/> and forth to a slice of bytes or a slice of runes. Try <a data-type="xref" href="#EX1-2">Example 3-9</a> on <a href="https://oreil.ly/N7fOB">The Go Playground</a> or in the <em>sample_code/string_to_slice</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.</p>
<div data-type="example" id="EX1-2">
<h5><span class="label">Example 3-9. </span>Converting strings to slices</h5>
<pre data-type="programlisting" data-code-language="go">
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Hello, </code><img src="assets/sun.png" width="150" height="150"/><code class="s">"</code><code class="w">
</code><code class="kd">var</code><code class="w"> </code><code class="nx">bs</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w">
</code><code class="kd">var</code><code class="w"> </code><code class="nx">rs</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">rune</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="nb">rune</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w">
</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">bs</code><code class="p">)</code><code class="w">
</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">rs</code><code class="p">)</code><code class="w">
</code></pre></div>

<p>When you run this code, you see the following:</p>

<pre data-type="programlisting">[72 101 108 108 111 44 32 240 159 140 158]
[72 101 108 108 111 44 32 127774]</pre>

<p>The first output line has the string converted to UTF-8 bytes. The second has the string converted to runes.</p>

<p>Most data in Go is read and written as a sequence of bytes, so the most common string type conversions are back and forth with a slice of bytes. Slices of runes are uncommon.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id974">
<h1>UTF-8</h1>
<p>UTF-8 is the most commonly used<a data-type="indexterm" data-primary="Unicode support" data-secondary="UTF-8 encoding" id="id975"/><a data-type="indexterm" data-primary="UTF-8 for string literals" data-secondary="encoding for Unicode" id="id976"/><a data-type="indexterm" data-primary="code points" data-secondary="Unicode using four bytes for each" id="id977"/> encoding for Unicode. Unicode uses four bytes (32 bits) to represent each <em>code point</em>, the technical name for each character and modifier. <a data-type="indexterm" data-primary="Unicode support" data-secondary="UTF-8 encoding" data-tertiary="UTF-32 for four bytes per code point" id="id978"/><a data-type="indexterm" data-primary="UTF-8 for string literals" data-secondary="encoding for Unicode" data-tertiary="UTF-32 for four bytes per code point" id="id979"/>Given this, the simplest way to represent Unicode code points is to store four bytes for each code point. This is called UTF-32. It is mostly unused because it wastes so much space. Due to Unicode implementation details, 11 of the 32 bits are always zero. <a data-type="indexterm" data-primary="Unicode support" data-secondary="UTF-8 encoding" data-tertiary="UTF-16 for one or two 2-byte sequences" id="id980"/><a data-type="indexterm" data-primary="UTF-8 for string literals" data-secondary="encoding for Unicode" data-tertiary="UTF-16 for one or two 2-byte sequences" id="id981"/>Another common encoding is UTF-16, which uses one or two 16-bit (2-byte) sequences to represent each code point. This is also wasteful; much of the content in the world is written using code points that fit into a single byte. And that’s where UTF-8 comes in.</p>

<p>UTF-8 is clever. It lets you use a single byte to represent the Unicode characters whose values are below 128 (which includes all of the letters, numbers, and punctuation commonly used in English), but expands to a maximum of four bytes to represent Unicode code points with larger values. The result is that the <em>worst</em> case for UTF-8 is the same as using UTF-32. UTF-8 has some other nice properties. Unlike UTF-32 and UTF-16, you don’t have to worry about little-endian versus big-endian. It also allows you to look at any byte in a sequence and tell if you are at the start of a UTF-8 sequence or somewhere in the middle. That means you can’t accidentally read a character incorrectly.</p>

<p>The only downside is that you cannot randomly access a string encoded with UTF-8. While you can detect if you are in the middle of a character, you can’t tell how many characters in you are. You need to start at the beginning of the string and count. Go doesn’t require a string to be written in UTF-8 but strongly encourages it. You’ll see how to work with UTF-8 strings in upcoming chapters.</p>

<p>Fun fact: UTF-8 was invented<a data-type="indexterm" data-primary="UTF-8 for string literals" data-secondary="invented by Thompson and Pike" id="id982"/><a data-type="indexterm" data-primary="Thompson, Ken" id="id983"/><a data-type="indexterm" data-primary="Pike, Rob" id="id984"/><a data-type="indexterm" data-primary="Go" data-secondary="creators of" id="id985"/> in 1992 by Ken Thompson and Rob Pike, two of the creators of Go.</p>
</div></aside>

<p>Rather than use the slice and index expressions with strings, you should extract substrings and code points from strings<a data-type="indexterm" data-primary="standard library" data-secondary="strings package" id="id986"/><a data-type="indexterm" data-primary="standard library" data-secondary="unicode/utf8 package" id="id987"/><a data-type="indexterm" data-primary="strings package in standard library" id="id988"/><a data-type="indexterm" data-primary="unicode/utf8 package in standard library" id="id989"/> using the functions in the <code>strings</code> and <code>unicode/utf8</code> packages in the standard library. In the next chapter, you’ll see how to use a 
<span class="keep-together"><code>for-range</code></span> loop to iterate over the code points in a string.<a data-type="indexterm" data-startref="ch03-srb" id="id990"/><a data-type="indexterm" data-startref="ch03-srb2" id="id991"/><a data-type="indexterm" data-startref="ch03-srb3" id="id992"/><a data-type="indexterm" data-startref="ch03-srb4" id="id993"/><a data-type="indexterm" data-startref="ch03-srb5" id="id994"/><a data-type="indexterm" data-startref="ch03-srb6" id="id995"/><a data-type="indexterm" data-startref="ch03-srb7" id="id996"/></p>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Maps"><div class="sect1" id="id40">
<h1>Maps</h1>

<p>Slices are useful when you have sequential data.<a data-type="indexterm" data-primary="types" data-secondary="composite types" data-tertiary="maps" id="ch03-map"/><a data-type="indexterm" data-primary="maps" id="ch03-map2"/><a data-type="indexterm" data-primary="composite types" data-secondary="maps" id="ch03-map3"/><a data-type="indexterm" data-primary="keywords" data-secondary="map" id="id997"/><a data-type="indexterm" data-primary="maps" data-secondary="declaration" id="id998"/> Like most languages, Go provides a built-in data type for situations where you want to associate one value to another. The map type is written as <code>map[keyType]valueType</code>. Let’s take a look at a few ways to declare maps. First, you can use a <code>var</code> declaration to create a map variable that’s set to its zero value:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">nilMap</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="w"/></pre>

<p>In this case, <code>nilMap</code> is declared to be a map with <code>string</code> keys and <code>int</code> values. <a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="maps as nil" id="id999"/><a data-type="indexterm" data-primary="maps" data-secondary="zero value as nil" id="id1000"/><a data-type="indexterm" data-primary="nil" data-secondary="zero value" data-tertiary="maps" id="id1001"/><a data-type="indexterm" data-primary="maps" data-secondary="zero value as nil" data-tertiary="writing to nil map causing panic" id="id1002"/><a data-type="indexterm" data-primary="panics" data-secondary="map of nil value written to" id="id1003"/>The zero value for a map is <code>nil</code>. A <code>nil</code> map has a length of 0. Attempting to read a <code>nil</code> map always returns the zero value for the map’s value type. However, <em>attempting to write to a <code>nil</code> map variable causes a panic</em>.</p>

<p>You can use a <code>:=</code> declaration to create a map variable by assigning it a <em>map literal</em>:<a data-type="indexterm" data-primary="map literals" id="id1004"/><a data-type="indexterm" data-primary="literals" data-secondary="map literals" id="id1005"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">totalWins</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/></pre>

<p>In this case, you are using an empty map literal.<a data-type="indexterm" data-primary="maps" data-secondary="zero value as nil" data-tertiary="empty versus nil map literals" id="id1006"/> This is not the same as a <code>nil</code> map. It has a length of 0, but you can read and write to a map assigned an empty map literal. Here’s what a nonempty map literal looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">teams</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">][]</code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"Orcas"</code><code class="p">:</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"Fred"</code><code class="p">,</code><code class="w"> </code><code class="s">"Ralph"</code><code class="p">,</code><code class="w"> </code><code class="s">"Bijou"</code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="s">"Lions"</code><code class="p">:</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"Sarah"</code><code class="p">,</code><code class="w"> </code><code class="s">"Peter"</code><code class="p">,</code><code class="w"> </code><code class="s">"Billie"</code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="s">"Kittens"</code><code class="p">:</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"Waldo"</code><code class="p">,</code><code class="w"> </code><code class="s">"Raul"</code><code class="p">,</code><code class="w"> </code><code class="s">"Ze"</code><code class="p">},</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A map literal’s body is written as the key, followed by a colon (:), then the value. A comma separates each key-value pair in the map, even on the last line. In this example, the value is a slice of strings. The type of the value in a map can be anything. There are some restrictions on the types of the keys that I’ll discuss in a bit.</p>

<p>If you know how many key-value pairs you intend to put in the map but don’t know the exact values, you can use <code>make</code> to create a map with a default size:<a data-type="indexterm" data-primary="maps" data-secondary="declaration" data-tertiary="make function for sized map that grows" id="id1007"/><a data-type="indexterm" data-primary="make function" data-secondary="map declaration" id="id1008"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ages</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">int</code><code class="p">][]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>

<p>Maps created with <code>make</code> still have a length of 0, and they can grow past the initially specified size.</p>

<p>Maps are like slices in several ways:<a data-type="indexterm" data-primary="maps" data-secondary="len function for number of key-value pairs" id="id1009"/><a data-type="indexterm" data-primary="len function" data-secondary="map key-value pair count" id="id1010"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="maps not comparable" id="id1011"/><a data-type="indexterm" data-primary="maps" data-secondary="not comparable" id="id1012"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="maps not comparable" id="id1013"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="maps not comparable" id="id1014"/></p>

<ul>
<li>
<p>Maps automatically grow as you add key-value pairs to them.</p>
</li>
<li>
<p>If you know how many key-value pairs you plan to insert into a map, you can use <code>make</code> to create a map with a specific initial size.</p>
</li>
<li>
<p>Passing a map to the <code>len</code> function tells you the number of key-value pairs in a map.</p>
</li>
<li>
<p>The zero value for a map is <code>nil</code>.</p>
</li>
<li>
<p>Maps are not comparable. You can check if they are equal to <code>nil</code>, but you cannot check if two maps have identical keys and values using <code>==</code> or differ using <code>!=</code>.</p>
</li>
</ul>

<p>The key for a map can be<a data-type="indexterm" data-primary="maps" data-secondary="keys as any comparable type" id="id1015"/> any comparable type. This means <em>you cannot use a slice or a map as the key for a map</em>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>When should you use a map,<a data-type="indexterm" data-primary="maps" data-secondary="slices versus maps" id="id1016"/><a data-type="indexterm" data-primary="slices" data-secondary="maps versus slices" id="id1017"/> and when should you use a slice? You should use slices for lists of data when the data should be processed sequentially or the order of the elements is important.</p>

<p>Maps are useful when you need to organize values using something other than an increasing integer value, such as a name.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id1018">
<h1>What Is a Hash Map?</h1>
<p>In computer science, a <em>map</em> is a data structure<a data-type="indexterm" data-primary="maps" data-secondary="hash map implementation" id="id1019"/><a data-type="indexterm" data-primary="hash map implementation of maps" id="id1020"/> that associates (or maps) one value to another. Maps can be implemented in several ways, each with its own trade-offs. The map that’s built into Go is a <em>hash map</em>, or <em>hash table</em>. <a data-type="indexterm" data-primary="Grokking Algorithms (Bhargava)" id="id1021"/><a data-type="indexterm" data-primary="Bhargava, Aditya" id="id1022"/>If you aren’t familiar with the concept, Chapter 5 in <a href="https://oreil.ly/A5GzB"><em>Grokking Algorithms</em></a> by Aditya Bhargava (Manning) describes what a hash table is and why they are so useful.</p>

<p>It’s great that Go includes a hash map implementation as part of the runtime, because building your own is hard to get right. <a data-type="indexterm" data-primary="“Inside the Map Implementation” video" data-primary-sortas="Inside the Map" id="id1023"/><a data-type="indexterm" data-primary="resources online" data-secondary="“Inside the Map Implementation” video" data-secondary-sortas="Inside the Map" id="id1024"/>If you’d like to learn more about how Go does it, watch <a href="https://oreil.ly/kIeJM">“Inside the Map Implementation”</a>, a talk from GopherCon 2016 by Keith Randall.</p>

<p>Go doesn’t require (or even allow) you to define<a data-type="indexterm" data-primary="Go runtime" data-secondary="hash algorithms implemented" id="id1025"/><a data-type="indexterm" data-primary="hash map implementation of maps" data-secondary="Go runtime hash algorithm implementation" id="id1026"/> your own hash algorithm or equality definition. Instead, the Go runtime that’s compiled into every Go program has code that implements hash algorithms for all types that are allowed to be keys.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Reading and Writing a Map"><div class="sect2" id="id221">
<h2>Reading and Writing a Map</h2>

<p>Let’s look at a short program that declares,<a data-type="indexterm" data-primary="maps" data-secondary="reading and writing a map" id="id1027"/> writes to, and reads from a map. You can run the program in <a data-type="xref" href="#EX3_MAP_RW">Example 3-10</a> on <a href="https://oreil.ly/gBMvf">The Go Playground</a> or in the <em>sample_code/map_read_write</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1028"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1029"/></p>
<div id="EX3_MAP_RW" data-type="example">
<h5><span class="label">Example 3-10. </span>Using a map</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">totalWins</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/>
<code class="nx">totalWins</code><code class="p">[</code><code class="s">"Orcas"</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="nx">totalWins</code><code class="p">[</code><code class="s">"Lions"</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">totalWins</code><code class="p">[</code><code class="s">"Orcas"</code><code class="p">])</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">totalWins</code><code class="p">[</code><code class="s">"Kittens"</code><code class="p">])</code><code class="w"/>
<code class="nx">totalWins</code><code class="p">[</code><code class="s">"Kittens"</code><code class="p">]</code><code class="o">++</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">totalWins</code><code class="p">[</code><code class="s">"Kittens"</code><code class="p">])</code><code class="w"/>
<code class="nx">totalWins</code><code class="p">[</code><code class="s">"Lions"</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">totalWins</code><code class="p">[</code><code class="s">"Lions"</code><code class="p">])</code><code class="w"/></pre></div>

<p>When you run this program, you’ll see the following output:</p>

<pre data-type="programlisting">1
0
1
3</pre>

<p>You assign a value to a map key by putting the key within brackets and using <code>=</code> to specify the value, and you read the value assigned to a map key by putting the key within brackets. Note that you cannot use <code>:=</code> to assign a value to a map key.</p>

<p>When you try to read the value assigned<a data-type="indexterm" data-primary="maps" data-secondary="reading and writing a map" data-tertiary="0 for value for key not in map" id="id1030"/> to a map key that was never set, the map returns the zero value for the map’s value type. In this case, the value type is an <code>int</code>, so you get back a 0. You can use the <code>++</code> operator to increment the numeric value for a map key. Because a map returns its zero value by default, this works even when there’s no existing value associated with the key.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The comma ok Idiom"><div class="sect2" id="comma_ok_section">
<h2>The comma ok Idiom</h2>

<p>As you’ve seen, a map returns the<a data-type="indexterm" data-primary="maps" data-secondary="reading and writing a map" data-tertiary="determining if key not in map" id="id1031"/><a data-type="indexterm" data-primary="maps" data-secondary="comma ok idiom for keys not in map" id="id1032"/><a data-type="indexterm" data-primary="comma ok idiom" data-secondary="map key 0 or not in map" id="id1033"/> zero value if you ask for the value associated with a key that’s not in the map. This is handy when implementing things like the <code>totalWins</code> counter you saw earlier. However, you sometimes do need to find out if a key is in a map. Go provides the <em>comma ok idiom</em> to tell the difference between a key that’s associated with a zero value and a key that’s not in the map:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"hello"</code><code class="p">:</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"world"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">m</code><code class="p">[</code><code class="s">"hello"</code><code class="p">]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="p">)</code><code class="w"/>

<code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">m</code><code class="p">[</code><code class="s">"world"</code><code class="p">]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="p">)</code><code class="w"/>

<code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">m</code><code class="p">[</code><code class="s">"goodbye"</code><code class="p">]</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="p">)</code><code class="w"/></pre>

<p>Rather than assign the result of a map read to a single variable, with the comma ok idiom you assign the results of a map read to two variables. The first gets the value associated with the key. The second value returned is a bool. It is usually named <code>ok</code>. If <code>ok</code> is <code>true</code>, the key is present in the map. If <code>ok</code> is <code>false</code>, the key is not present. In this example, the code prints out <code>5 true</code>, <code>0 true</code>, and <code>0 false</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The comma ok idiom is used in Go when you want to differentiate between reading a value and getting back the zero value. You’ll see it again when you read from channels in <a data-type="xref" href="ch12.html#unique_chapter_id_12">Chapter 12</a> and when you use type assertions in <a data-type="xref" href="ch07.html#unique_chapter_id_07">Chapter 7</a>.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Deleting from Maps"><div class="sect2" id="id41">
<h2>Deleting from Maps</h2>

<p>Key-value pairs are removed from a map via the built-in <code>delete</code> function:<a data-type="indexterm" data-primary="maps" data-secondary="deleting key-value pairs" id="id1034"/><a data-type="indexterm" data-primary="delete function for map key-value" id="id1035"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"hello"</code><code class="p">:</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"world"</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nb">delete</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="p">)</code><code class="w"/></pre>

<p>The <code>delete</code> function takes a map and a key and then removes the key-value pair with the specified key. If the key isn’t present in the map or if the map is <code>nil</code>, nothing happens. The <code>delete</code> function doesn’t return a value.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Emptying a Map"><div class="sect2" id="id223">
<h2>Emptying a Map</h2>

<p>The <code>clear</code> function that you saw in <a data-type="xref" href="#empty_slice">“Emptying a Slice”</a> works<a data-type="indexterm" data-primary="maps" data-secondary="len function for number of key-value pairs" data-tertiary="clear function to set length to zero" id="id1036"/><a data-type="indexterm" data-primary="clear function" data-secondary="map length set to zero" id="id1037"/> on maps also. A cleared map has its length set to zero, unlike a cleared slice. The following code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"hello"</code><code class="p">:</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"world"</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">m</code><code class="p">))</code><code class="w"/>
<code class="nb">clear</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">m</code><code class="p">))</code><code class="w"/></pre>

<p>prints out:</p>

<pre data-type="programlisting">map[hello:5 world:10] 2
map[] 0</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Comparing Maps"><div class="sect2" id="id224">
<h2>Comparing Maps</h2>

<p>Go 1.21 added a package to the<a data-type="indexterm" data-primary="maps" data-secondary="not comparable" data-tertiary="maps.Equal" id="id1038"/><a data-type="indexterm" data-primary="maps" data-secondary="not comparable" data-tertiary="maps.EqualFunc" id="id1039"/><a data-type="indexterm" data-primary="maps package" data-secondary="maps.Equal" id="id1040"/><a data-type="indexterm" data-primary="maps package" data-secondary="maps.EqualFunc" id="id1041"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="maps not comparable" data-tertiary="maps.Equal" id="id1042"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="maps not comparable" data-tertiary="maps.EqualFunc" id="id1043"/><a data-type="indexterm" data-primary="standard library" data-secondary="maps package" id="id1044"/><a data-type="indexterm" data-primary="helper functions" data-secondary="maps" data-tertiary="maps.Equal" id="id1045"/><a data-type="indexterm" data-primary="helper functions" data-secondary="maps" data-tertiary="maps.EqualFunc" id="id1046"/> standard library called <code>maps</code> that contains helper functions for working with maps. You’ll learn more about this package in <a data-type="xref" href="ch08.html#slice_map_funcs">“Adding Generics to the Standard Library”</a>. Two functions in the package are useful for comparing if two maps are equal, <code>maps.Equal</code> and <code>maps.EqualFunc</code>. They are analogous to the <code>slices.Equal</code> and <code>slices.EqualFunc</code> functions:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"hello"</code><code class="p">:</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"world"</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">n</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"world"</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"hello"</code><code class="p">:</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">maps</code><code class="p">.</code><code class="nx">Equal</code><code class="p">(</code><code class="nx">m</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">))</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Using Maps as Sets"><div class="sect2" id="id42">
<h2>Using Maps as Sets</h2>

<p>Many languages include a set in their standard library.<a data-type="indexterm" data-primary="maps" data-secondary="using as sets" id="id1047"/><a data-type="indexterm" data-primary="sets" id="id1048"/><a data-type="indexterm" data-primary="sets" data-secondary="maps as sets" id="id1049"/> A <em>set</em> is a data type that ensures there is at most one of a value, but doesn’t guarantee that the values are in any particular order. Checking to see if an element is in a set is fast, no matter how many elements are in the set. (Checking to see if an element is in a slice takes longer, as you add more elements to the slice.)</p>

<p>Go doesn’t include a set, but you can use a map to simulate some of its features. Use the key of the map for the type that you want to put into the set and use a <code>bool</code> for the value. The code in <a data-type="xref" href="#EX3_SET">Example 3-11</a> demonstrates the concept. You can run it on <a href="https://oreil.ly/wC6XK">The Go Playground</a> or in the <em>sample_code/map_set</em> directory in the <a href="https://oreil.ly/Ur5f2">Chapter 3 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1050"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1051"/></p>
<div id="EX3_SET" data-type="example">
<h5><span class="label">Example 3-11. </span>Using a map as a set</h5>

<pre data-type="programlisting" data-code-language="go"><code class="nx">intSet</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">int</code><code class="p">]</code><code class="kt">bool</code><code class="p">{}</code><code class="w"/>
<code class="nx">vals</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">}</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">vals</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">intSet</code><code class="p">[</code><code class="nx">v</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">vals</code><code class="p">),</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">intSet</code><code class="p">))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">intSet</code><code class="p">[</code><code class="mi">5</code><code class="p">])</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">intSet</code><code class="p">[</code><code class="mi">500</code><code class="p">])</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">intSet</code><code class="p">[</code><code class="mi">100</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"100 is in the set"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p>You want a set of <code>int</code>s, so you create a map where the keys are of <code>int</code> type and the values are of <code>bool</code> type. You iterate over the values in <code>vals</code> using a <code>for-range</code> loop (which I discuss in <a data-type="xref" href="ch04.html#for_range">“The for-range Statement”</a>) to place them into <code>intSet</code>, associating each <code>int</code> with the boolean value <code>true</code>.</p>

<p>We wrote 11 values into <code>intSet</code>, but the length of <code>intSet</code> is 8, because you cannot have duplicate keys in a map. If you look for 5 in <code>intSet</code>, it returns <code>true</code>, because there is a key with the value 5. However, if you look for 500 or 100 in <code>intSet</code>, it returns <code>false</code>. This is because you haven’t put either value into <code>intSet</code>, which causes the map to return the zero value for the map value, and the zero value for a <code>bool</code> is <code>false</code>.</p>

<p>If you need sets that provide operations like union, intersection, and subtraction, you can either write one yourself or use one of the many third-party libraries that provide the functionality. (You’ll learn more about using third-party libraries in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some people prefer to use <code>struct{}</code> for the value<a data-type="indexterm" data-primary="maps" data-secondary="using as sets" data-tertiary="struct{} for value" id="id1052"/><a data-type="indexterm" data-primary="sets" data-secondary="maps as sets" data-tertiary="struct{} for value" id="id1053"/><a data-type="indexterm" data-primary="structs" data-secondary="maps used as sets" id="id1054"/> when a map is being used to implement a set. (I’ll discuss structs in the next section.) The advantage is that an empty struct uses zero bytes, while a boolean uses one byte.</p>

<p>The disadvantage is that using a <code>struct{}</code> makes your code clumsier. You have a less obvious assignment, and you need to use the comma ok idiom to check if a value is in the set:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">intSet</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">int</code><code class="p">]</code><code class="kd">struct</code><code class="p">{}{}</code><code class="w"/>
<code class="nx">vals</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">7</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">}</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">vals</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">intSet</code><code class="p">[</code><code class="nx">v</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}{}</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">intSet</code><code class="p">[</code><code class="mi">5</code><code class="p">];</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"5 is in the set"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Unless you have very large sets, the difference in memory usage will not likely be significant enough to outweigh the disadvantages.<a data-type="indexterm" data-startref="ch03-map" id="id1055"/><a data-type="indexterm" data-startref="ch03-map2" id="id1056"/><a data-type="indexterm" data-startref="ch03-map3" id="id1057"/></p>
</div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Structs"><div class="sect1" id="struct_first_look">
<h1>Structs</h1>

<p>Maps are a convenient way to store<a data-type="indexterm" data-primary="structs" id="id1058"/><a data-type="indexterm" data-primary="types" data-secondary="composite types" data-tertiary="structs" id="id1059"/><a data-type="indexterm" data-primary="composite types" data-secondary="structs" id="id1060"/> some kinds of data, but they have limitations. They don’t define an API since there’s no way to constrain a map to allow only certain keys. Also, all values in a map must be of the same type. For these reasons, maps are not an ideal way to pass data from function to function. When you have related data that you want to group together, you should define a <em>struct</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you already know an object-oriented language, you might be wondering about the difference between classes and structs. The difference is simple: Go doesn’t have classes, because it doesn’t have inheritance. This doesn’t mean that Go doesn’t have some of the features of object-oriented languages it just does things a little differently. You’ll learn more about the object-oriented features of Go in <a data-type="xref" href="ch07.html#unique_chapter_id_07">Chapter 7</a>.</p>
</div>

<p>Most languages have a concept that’s similar to a struct, and the syntax that Go uses to read and write structs should look familiar:<a data-type="indexterm" data-primary="structs" data-secondary="declaration" id="id1061"/><a data-type="indexterm" data-primary="keywords" data-secondary="struct" id="id1062"/><a data-type="indexterm" data-primary="type keyword" data-secondary="structs" id="id1063"/><a data-type="indexterm" data-primary="keywords" data-secondary="type" data-tertiary="structs" id="id1064"/><a data-type="indexterm" data-primary="struct keyword" id="id1065"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">pet</code><code class="w">  </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A struct type is defined with the keyword <code>type</code>, the name of the struct type, the keyword <code>struct</code>, and a pair of braces (<code>{}</code>). Within the braces, you list the fields in the struct. Just as you put the variable name first and the variable type second in a <code>var</code> declaration, you put the struct field name first and the struct field type second. Also note that unlike in map literals, no commas separate the fields in a struct declaration. You can define a struct type inside or outside of a function. A struct type that’s defined within a function can be used only within that function. (You’ll learn more about functions in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>.)</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Technically, you can scope a struct definition to any block level. You’ll learn more about blocks in <a data-type="xref" href="ch04.html#unique_chapter_id_04">Chapter 4</a>.</p>
</div>

<p>Once a struct type is declared, you can define variables of that type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">fred</code><code class="w"> </code><code class="nx">person</code><code class="w"/></pre>

<p>Here we are using a <code>var</code> declaration. Since no value is assigned to <code>fred</code>, it gets the zero value for the <code>person</code> struct type. <a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="struct fields as field’s zero value" id="id1066"/><a data-type="indexterm" data-primary="structs" data-secondary="zero value as field’s zero value" id="id1067"/>A zero value struct has every field set to the field’s zero value.</p>

<p>A <em>struct literal</em> can be assigned to a variable as well:<a data-type="indexterm" data-primary="struct literals" id="id1068"/><a data-type="indexterm" data-primary="literals" data-secondary="struct literals" id="id1069"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">bob</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">person</code><code class="p">{}</code><code class="w"/></pre>

<p>Unlike maps, there is no difference between assigning an empty struct literal and not assigning a value at all. Both initialize all fields in the struct to their zero values. There are two styles for a nonempty struct literal. First, a struct literal can be specified as a comma-separated list of values for the fields inside of braces:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">julia</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">person</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="s">"Julia"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="mi">40</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"cat"</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When using this struct literal format, a value for every field in the struct must be specified, and the values are assigned to the fields in the order they were declared in the struct definition.</p>

<p>The second struct literal style looks like the map literal style:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">beth</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">person</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="p">:</code><code class="w">  </code><code class="mi">30</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">:</code><code class="w"> </code><code class="s">"Beth"</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You use the names of the fields in the struct to specify the values. This style has some advantages. It allows you to specify the fields in any order, and you don’t need to provide a value for all fields. Any field not specified is set to its zero value.</p>

<p>You cannot mix the two struct literal styles: either all fields are specified with names, or none of them are. For small structs where all fields are always specified, the simpler struct literal style is fine. In other cases, use the names. It’s more verbose, but it makes clear what value is being assigned to what field without having to reference the struct definition. It’s also more maintainable. If you initialize a struct without using the field names and a future version of the struct adds additional fields, your code will no longer compile.</p>

<p>A field in a struct is accessed with dot notation:<a data-type="indexterm" data-primary="structs" data-secondary="reading and writing" id="id1070"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">bob</code><code class="p">.</code><code class="nx">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"Bob"</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">bob</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code><code class="w"/></pre>

<p>Just as you use brackets for both reading and writing to a map, you use dotted notation for reading and writing to struct fields.</p>








<section data-type="sect2" data-pdf-bookmark="Anonymous Structs"><div class="sect2" id="id44">
<h2>Anonymous Structs</h2>

<p>You can also declare that a <a data-type="indexterm" data-primary="structs" data-secondary="anonymous structs" id="id1071"/><a data-type="indexterm" data-primary="anonymous structs" id="id1072"/>variable implements a struct type without first giving the struct type a name. This is called an <em>anonymous struct</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">pet</code><code class="w">  </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"bob"</code><code class="w"/>
<code class="nx">person</code><code class="p">.</code><code class="nx">age</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">50</code><code class="w"/>
<code class="nx">person</code><code class="p">.</code><code class="nx">pet</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"dog"</code><code class="w"/>

<code class="nx">pet</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">kind</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">:</code><code class="w"> </code><code class="s">"Fido"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">kind</code><code class="p">:</code><code class="w"> </code><code class="s">"dog"</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this example, the types of the variables <code>person</code> and <code>pet</code> are anonymous structs. You assign (and read) fields in an anonymous struct just as you do for a named struct type. Just as you can initialize an instance of a named struct with a struct literal, you can do the same for an anonymous struct as well.</p>

<p>You might wonder when it’s useful to have a data type that’s associated only with a single instance. Anonymous structs are handy in two common situations. <a data-type="indexterm" data-primary="anonymous structs" data-secondary="unmarshaling and marshaling data" id="id1073"/><a data-type="indexterm" data-primary="structs" data-secondary="anonymous structs" data-tertiary="unmarshaling and marshaling data" id="id1074"/>The first is when you translate external data into a struct or a struct into external data (like JSON or Protocol Buffers). This is called <em>unmarshaling</em> and <em>marshaling</em> data, respectively. You’ll learn how to do this in <a data-type="xref" href="ch13.html#json">“encoding/json”</a>.</p>

<p>Writing tests is another place where anonymous structs pop up. You’ll use a slice of anonymous structs when writing table-driven tests in <a data-type="xref" href="ch15.html#unique_chapter_id_15">Chapter 15</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Comparing and Converting Structs"><div class="sect2" id="id225">
<h2>Comparing and Converting Structs</h2>

<p>Whether a struct is comparable<a data-type="indexterm" data-primary="comparison operators" data-secondary="structs comparable if fields comparable" id="id1075"/><a data-type="indexterm" data-primary="structs" data-secondary="comparing structs" id="id1076"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="structs comparable if fields comparable" id="id1077"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="structs comparable if fields comparable" id="id1078"/> depends on the struct’s fields. Structs that are entirely composed of comparable types are comparable; those with slice or map fields are not (as you will see in later chapters, function and channel fields also prevent a struct from being comparable).</p>

<p>Unlike in Python or Ruby, in Go there’s no magic method that can be overridden to redefine equality and make <code>==</code> and <code>!=</code> work for incomparable structs. You can, of course, write your own function that you use to compare structs.</p>

<p>Just as Go doesn’t allow comparisons between variables of different primitive types, Go doesn’t allow comparisons between variables that represent structs of different types. <a data-type="indexterm" data-primary="structs" data-secondary="type conversions" id="id1079"/><a data-type="indexterm" data-primary="type conversion" data-secondary="structs" id="id1080"/>Go does allow you to perform a type conversion from one struct type to another <em>if the fields of both structs have the same names, order, and types</em>. Let’s see what this means. Given this struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">firstPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>you can use a type conversion to convert an instance of <code>firstPerson</code> to 
<span class="keep-together"><code>secondPerson</code>,</span> but you can’t use <code>==</code> to compare an instance of <code>firstPerson</code> and an instance of <code>secondPerson</code>, because they are different types:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">secondPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can’t convert an instance of <code>firstPerson</code> to <code>thirdPerson</code>, because the fields are in a different order:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">thirdPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can’t convert an instance of <code>firstPerson</code> to <code>fourthPerson</code> because the field names don’t match:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">fourthPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">firstName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">       </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Finally, you can’t convert an instance of <code>firstPerson</code> to <code>fifthPerson</code> because there’s an additional field:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">fifthPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w">          </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">           </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">favoriteColor</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Anonymous structs add a small twist:<a data-type="indexterm" data-primary="structs" data-secondary="comparing structs" data-tertiary="anonymous structs" id="id1081"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="structs comparable if fields comparable" data-tertiary="anonymous structs" id="id1082"/><a data-type="indexterm" data-primary="structs" data-secondary="anonymous structs" data-tertiary="comparing structs" id="id1083"/><a data-type="indexterm" data-primary="anonymous structs" data-secondary="comparing structs" id="id1084"/> if two struct variables are being compared and at least one has a type that’s an anonymous struct, you can compare them without a type conversion if the fields of both structs have the same names, order, and types. You can also assign between named and anonymous struct types if the fields of both structs have the same names, order, and types:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">firstPerson</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">firstPerson</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">:</code><code class="w"> </code><code class="s">"Bob"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="p">:</code><code class="w">  </code><code class="mi">50</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">g</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// compiles -- can use = and == between identical named and anonymous structs</code><code class="w"/>
<code class="nx">g</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">f</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">g</code><code class="p">)</code><code class="w"/></pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id278">
<h1>Exercises</h1>

<p>The following exercises will test what you’ve learned about Go’s composite types. You can find solutions in the <em>exercise_solutions</em> directory in the <a href="https://oreil.ly/d2nrA">Chapter 3 Repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1085"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 3" data-tertiary-sortas="ccc" id="id1086"/></p>
<ol>
<li>
<p>Write a program that defines a variable named <code>greetings</code> of type slice of strings with the following values: <code>"Hello"</code>, <code>"Hola"</code>, <code>"नमस्कार"</code>, <code>"こんにちは"</code>, and <code>"Привіт"</code>. Create a subslice containing the first two values; a second subslice with the second, third, and fourth values; and a third subslice with the fourth and fifth values. Print out all four slices.</p>
</li>
<li>
<p>Write a program that defines a string variable called <code>message</code> with the value <code>"Hi <img src="assets/woman.png" width="71" height="67"/> and <img src="assets/man.png" width="69" height="71"/>"</code> and prints the fourth rune in it as a character, not a number.</p>
</li>
<li>
<p>Write a program that defines a struct called <code>Employee</code> with three fields: 
<span class="keep-together"><code>firstName</code>,</span> <code>lastName</code>, and <code>id</code>. The first two fields are of type <code>string</code>, and the last field (<code>id</code>) is of type <code>int</code>. Create three instances of this struct using whatever values you’d like. Initialize the first one using the struct literal style without names, the second using the struct literal style with names, and the third with a <code>var</code> declaration. Use dot notation to populate the fields in the third struct. Print out all three structs.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id341">
<h1>Wrapping Up</h1>

<p>You’ve learned a lot about composite types in Go. In addition to learning more about strings, you now know how to use the built-in generic container types: slices and maps. You can also construct your own composite types via structs. In the next chapter, you’re going to take a look at Go’s control structures: <code>for</code>, <code>if/else</code>, and <code>switch</code>. You will also learn how Go organizes code into blocks and how the different block levels can lead to surprising behavior.</p>
</div></section>
</div></section></div>
</div>
</body></html>