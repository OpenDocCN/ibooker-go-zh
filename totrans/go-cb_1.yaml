- en: Chapter 2\. String Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String manipulation is one of the most common activities in any programming
    language. Most programs deal with text in one way or another, whether directly
    interacting with users or even communicating with between machines. Text is probably
    the closest thing we have to a universal medium, and string as data is everywhere.
    Being able to manipulate string is a critical capability in your arsenal as a
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Go has several packages used for string manipulation. The `strconv` package
    focuses on converting to or from strings. The `fmt` package provides functions
    to format strings using verbs as replacements, much like in C. The `unicode/utf8`
    and `unicode/utf16` packages have functions used in Unicode encoded strings. The
    `strings` package has functions to do many of the string manipulations we see
    so if you’re not sure what you need, that’s the most likely location to look.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Creating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create strings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use either the double quotes `""` or the backtick (or backquote) `“` to create
    string literals. Use the single quotes `”` to create character literals.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, `string` is a read-only (immutable) slice of bytes. It can be any byte,
    doesn’t need to be in any encoding or format. This is unlike some other programming
    languages, where strings are sequences of characters. In Go, a character can be
    represented by more than a single byte. This is in line with the Unicode standard,
    which defines a code-point to represent a value within a codespace. A character
    in this case can be represented by more than a single code-point. In Go, code-points
    are also called *runes* and a rune is an alias for the type `int32` just as a
    byte is an alias for the type `uint8` which represents an unsigned 8-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: As a result if you index a string, you will end up with a byte and not a character.
    In any case Go doesn’t have a character data type — bytes and runes are used instead.
    A byte represents ASCII characters and rune represents Unicode characters in UTF-8
    encoding. To be clear, it doesn’t mean that there are no characters in Go, just
    that there is no `char` data type, just `byte` and `rune`.
  prefs: []
  type: TYPE_NORMAL
- en: Characters in Go are created using the single quotes `''`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the data type of the variable `c` is `int32` or a rune, by default.
    If oyu want it to be a byte, you can explicitly specify the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Strings in Go can be created using either the double quotes `""` or the backtick
    [PRE2].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Strings created using the double quotes can have escape characters in them.
    For example, a very common escape character is the newline, represented by a backslash
    followed by an *n* — `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another common use of escape characters is to escape a double quote itself so
    it can be used within a string that’s created with a double quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: String created using backticks are considered “raw” strings. Raw strings ignore
    all formatting including escape characters. In fact you can create multi-line
    string using backticks. For example, this is not possible using double quotes,
    in fact it’ll be a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However if we replace the double quotes with backticks `str` will be a multi-line
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because whatever comes in between the backticks are not processed by
    the Go compiler at all (i.e. it is “raw”).
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Converting strings to bytes and bytes to string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert string to bytes and bytes to string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typecast a string to an array of bytes using `[]byte(str)` and typecast an array
    of bytes to a string using `string(bytes)`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings are slices of bytes so you can convert a string to an array of bytes
    directly through typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Converting an array of bytes to a string is also done through typecasting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 2.3 Creating strings from other strings and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a string from other strings or data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a variety of ways of doing this, including direct concatenation, using
    `strings.Join`, using `fmt.Sprint` and using `strings.Builder`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At times you want to create strings from other strings or data. One and rather
    straightforward way of doing this is to concatenate strings and other data together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Now` function returns the current time, which is formatted by the `Format`
    method returned as a string. When we concatenate the strings, we will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Another way of doing this is use the `Join` function in the `string` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is quite straightforward as well, because the function takes in an array
    of strings and given the separator, put them together.
  prefs: []
  type: TYPE_NORMAL
- en: So far both ways shown are about putting strings together. Obviously you can
    convert different data types into string before joining them up, but sometimes
    you just want Go to do it. For this we have the `fmt.Sprint` function and its
    various variants. Let’s look at the simplest and most straightforward variant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This doesn’t seem very different from the `Join` or the direct concatenation
    because all 3 parameters are strings. Actually `fmt.Sprint` and its variants take
    `interface{}` parameters, which means it can take in any data type. In other words,
    you can actually pass in the `Time` struct that’s returned by `Now` directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A popular variant of `fmt.Sprint` is the formatted variant i.e. `fmt.Sprintf`.
    Using this variant is slightly different — the first parameter is the format string,
    where you can place different verb formats at different locations within the string.
    The second parameter onwards are the data values that can be replaced into the
    verbs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There is no associated verb for a `Time` struct, so we use the `%v` which will
    format the value in the default format.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `string` package also provides another way of creating strings,
    using the `strings.Builder` struct. Using `Builder` to create strings is a bit
    more involved, as it requires you to add the data piece by piece. Let’s take a
    look at using `Builder`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The idea is simple, we create a `Builder` struct, then write data to it bit
    by bit before finally extracting the final string using the `String` method. The
    `Builder` struct has a few more other methods including `Write` which takes in
    an array of bytes, `WriteByte` which takes in a single byte and `WriteRune` which
    takes in a single rune. However as you can see, they are all strings or characters.
    How about other data types? Do we need to convert all other data types to string
    or byte or rune first? No, because `Builder` is a `Writer` (it implements a `Write`
    method), you can actually use another way of writing different data types into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re using `fmt.Fprint` to write whatever data type we want into the builder,
    and extract the final string using `String`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen quite a few ways of putting a string together using different pieces
    of data, both string and other types of data. Some are very straightforward (just
    add them together) whereas others are bit more deliberate. Here’s a look at the
    performance of these various ways.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s run the benchmark from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It might come to you as a surprise that the simplest way is really the most
    performant as well. Using `fmt.Sprint` and anything that uses `interface{}` is
    simply less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Converting strings to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert string to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Atoi` or the `Parse` functions in the `strconv` package to do string
    conversions. Use functions to convert strings to numbers, and use `Itoa` or the
    `Format` functions to convert numbers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `strconv` package is true to its name and is a package used mostly for conversion
    of strings. There are two sets of functions that lets us convert strings to numbers
    and numbers to string. The `Parse` functions convert strings to numbers and the
    `Format` functions convert numbers to strings. If you’re not sure which ones to
    use, generally remember that parsing reads strings while formatting creates strings.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing strings into numbers seem to be limited in usage but it can be particularly
    useful when dealing with text formatted data, for example, JSON or Yaml or even
    XML. Text formatted data is popular because it is human readable but the drawback
    is that everything ends up being a string. Parsing the string into something more
    usable directly, in this case, numbers becomes really useful.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with something simple. We want to parse a string that shows an integer
    and produces an actual integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `strconv` package provides a convenience function to convert a string to
    an integer. This is quite easy to remember because `Atoi` basically is converting
    *alphanumeric* to *integer*.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent of `Atoi` using the `Parse` functions is `ParseInt(s, 10, 0)`
    where `s` is the string representing the number.
  prefs: []
  type: TYPE_NORMAL
- en: The `ParseInt` function as the name suggests, parses a string into an integer.
    You can specify the base (0, 2 to 36) as well as the bit size (0 to 64). You can
    use `ParseInt` for signed or unsigned integers, just place a + or - in front of
    the number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ParseFloat` function parses a string into a float. The bitsize parameter
    specifies the precision, 32 for `float32`, 64 for `float64` etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, `f` is a `float64` number.
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseBool` can be useful when you’re trying to parse a string that represents
    a boolean value. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false,
    False.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, `b` is a boolean with the value `true`.
  prefs: []
  type: TYPE_NORMAL
- en: All the `Parse` functions return `NumError`, including `Atoi`. `NumError` provides
    additional information about the error including the function that was called,
    the number that was passed in and the reason why it failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is what you can see if you run this code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 2.5 Converting numbers to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert numbers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Itoa` or the `Format` functions in the `strconv` package to convert
    numbers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed about the `strconv` package and the `Parse` functions in the previous
    recipe. In this recipe we’ll talk about the `Format` functions and how we can
    use them to convert numbers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting numbers into strings is the reverse of parsing strings into numbers.
    In cases where data needs to be communicated through text formats, formatting
    numbers can be useful. One frequent usage of formatting numbers into strings is
    when we need to show more readable numbers to users. For example, instead of showing
    1.66666666 to the user, we would want to show 1.67\. This is also commonly used
    when displaying currency.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the simplest example. Just as parsing strings has `Atoi`, formatting
    strings has `Itoa`. As the name suggests, it’s the reverse of `Atoi` — it converts
    an integer into a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Itoa` doesn’t return an error. In fact, none of the `Format` functions
    return errors. It makes sense — it is always possible to make a number a string,
    while it’s not the case in the reverse.
  prefs: []
  type: TYPE_NORMAL
- en: As before, `Itoa` is a convenient function for `FormatInt`. However we must
    first ensure the input number parameter is always an `int64`. `FormatInt` also
    requires a base parameter where base is an integer between 2 and 36, both numbers
    included. This means it can potentially convert binary numbers to string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code above returns a string `"123"`. What if we specify a base of 2?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will return a string `"1111011"`. What this means is that you can use `FormatInt`
    to convert a number in one base to another, at least to display as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FormatFloat` function is a bit more complicated that `FormatInt`. It converts
    a floating point number to a string according to a format and precision. The formats
    available in `FormatFloat` for decimal numbers (base 10) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f` - no exponent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e` and `E` - with exponent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g` and `G` - `e` or `E` respectively if the exponent is large, else it will
    be without exponent (like `f`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other formats are `b` for binary numbers (base 2) and `x` and `X` for hexadecimal
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The precision describes the number of digits (excluding the exponents) to be
    printed out. A precision of value -1 lets Go select the smallest number of digits
    such that ParseFloat returns the entire number.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some code, it will make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’re using a float value with 64-bit precision, `float64`, and we will compare
    the precision of -1 with the precision of 4\. In case you didn’t realise, both
    lower case *e* and upper case *E* are exactly the same, except the exponent letter
    *e* is in lower or upper case.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code, this is what you should see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 2.6 Replacing multiple characters in a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to replace parts in a string with another string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways of doing it. You can use the `strings.Replace` function
    or `strings.ReplaceAll` function to replace the selected string. You can also
    use the `strings.Replacer` type to create replacers.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways we can use to replace parts of a string with another
    string. The easiest is to use the `strings.Replace` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `strings.Replace` function is quite straightforward. Just pass it a string,
    the old string you want to replace, and the new string you want to replace it
    with. Let’s take a look at the code, using this quote from *Great Expectations*
    by Charles Dickens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We run a few replacements using `Replace`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The last parameter tells `Replace` the number of matches to replace. If the
    last parameter is -1, `Replace` will match every instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `ReplaceAll` function which is more of a convenience function
    that calls `Replace` with the last parameter set to -1.
  prefs: []
  type: TYPE_NORMAL
- en: The `Replacer` type in the `strings` package that allows you to make multiple
    replacements all at the same time. This is a lot more convenient if you need to
    do a lot of replacements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You just need to provide a list of replacement strings as the parameters. In
    the code above, we replaced “her” with “him”, “against” with “for” and “all” with
    “some”. It will do all the replacements at the same time. If you run the code
    above you will get the results below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So is it better to use `Replace` or create a `Replacer`? It takes a another
    line of code to create the replacer, obviously. But how about its performance?
    Let’s take a look. We’ll start with just replacing 1 word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If it’s just one string to replace, `Replace` is faster. There is just more
    overhead for a simple replacement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at if we need to do multiple replacements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to create a `Replacer` each time so we can reuse the replacer
    multiple times if you want to do the same replacements for different strings.
    At the same time, if you have a lot of replacements, it’s definitely easier to
    use a replacer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with more strings to replace, using `Replacer` becomes more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Creating substrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create substrings from a string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Treat a string like an array or a slice and take a substring out of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, a string is a slice of bytes. As a result if you want to take a substring
    out of a string, you can just do what you would do with any slice. Let’s take
    the same quote as in the previous recipes, the quote from *Great Expectations*
    by Charles Dickens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you want to extract the words “against reason” from the quote, you can do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is simple enough, but how do know the position of the words without manually
    counting letters in the quote? Like in many programming languages, we just need
    to find the index of the substring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `strings.Index` function gives us the index of the first substring that
    matches the second parameter, this case it will be 12\. This will give us position
    of substring. To find the end position of the substring, we simply add the length
    of the substring to the index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 2.8 Checking if a string contains another string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check if a string contains another string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Contains` functions in the `strings` package. If the string you want
    to check is a suffix or a prefix, you can also use the `HasSuffix` or the `HasPrefix`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checking if a string has a substring is quite easy in Go. You can use the `strings.Contains`
    function and pass in both the string and substring and it will return true or
    false accordingly. We’ll use the quote from *Great Expectations* by Charles Dickens
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `Contains` function checks if the quote contains the string “against”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Alternately you can always use `strings.Index` and if the returned result is
    < 0 it means the substring is not found in the string. The performance is the
    same in either function, not surprisingly because `Contains` is just a convenience
    function around `Index`. Another alternative is to use the `Count` function, which
    returns the number of times the substring is found in the string, but this is
    usually a poorer alternative (unless you need to know the count anyway) because
    the performance is poorer than either.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to find out if the substring is the prefix of the string, you
    can use the `HasPrefix` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can directly slice the length of the prefix from the string and
    check it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can do the same for suffixes as well with the `HasSuffix` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can also directly slice the string for the suffix and compare it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 2.9 Splitting a string into an array of strings or combining an array of strings
    into a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an array of string by splitting up a string or create a string
    by combining an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Split` functions in the `strings` package to split up a string and
    the `Join` function to combine the array of strings into a single string.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many functions take in an array of strings. You might want to tackle words in
    a string instead of individual bytes. You might be dealing with data that is delimited
    by a separator like in delimited text format like CSV or TSV. Whichever case it
    may me, being able to quickly split up a string into an array of strings is useful.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, you can do this using the `strings.Split` function. Let’s use the quote
    from *Great Expectations* by Charles Dickens again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `Split` function splits a string into an array of string, given the separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we use a space as the separator, so this is what you will
    see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that some elements have the newline character because the original
    string has it. It’s probably not what you want, so how can we remove the newline
    characters? Or worse, if you have multiple spaces, your array will look pretty
    messy with a lot of additional empty string elements. Of course you can clean
    it up by brute force later on but there is a simpler way. The `strings` package
    has a function `Fields` that can split a string considering one or more consecutive
    spaces as defined by `uniform.isSpace`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look if we use `Fields` instead of `Split`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You should see this now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The newline characters are gone. How about if we want to remove even the punctuation
    (in this case, the commas and the full stop at the end of the quote)? This is
    a bit more complicated, we need to use the `FieldsFunc` function and pass in a
    function that will determine that should be part of the separator or not. Let’s
    take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we create a function `f` that considers consecutive punctuations
    and non-letters to be part of the separator. Then we pass this function into `FieldsFunc`
    for it to be executed against the string. This is what we should see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have also removed the punctuations. The `FieldsFunc` function
    is very versatile, I’ve only given a very simple example. If you work a lot with
    splitting strings, this will be a very powerful function you can use to do many
    things.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to just split the string for the first 9 elements and put the
    rest in single string? The `SplitN` function does exactly that, with `n` being
    the number of elements to have in the resulting array, in this case here it’s
    10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You will see that there are 10 elements in the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you want to keep the delimiter after you split the string. Go has
    a function called `SplitAfter` that does this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each element ends with a space (which is the delimiter) except
    the final element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 2.10 Trimming strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to remove the leading and trailing characters of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Trim` functions in the `strings` package.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When processing strings it’s quite common to encounter trailing or leading whitespaces
    or other unnecessary characters. Very often we want to remove these characters
    before storing or processing the strings further. Because of this, the idea of
    string trimming is quite common as well. String trimming essentially removes characters
    from the start or the end of the string, but not within the string.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, there are a number of `Trim` functions in the `strings` package that
    can help us with trimming strings.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the `Trim` function. It takes in a string and a *cutset* which
    is a string consisting of one or more Unicode code points and returns a string
    with all leading and trailing these code points removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, we want to remove the leading comma and whitespace, and also
    the trailing full stop. To do this we use a cutset consisting of these 3 Unicode
    code points, so the cutset string ends up to be `",. "`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Trim` function removes both trailing and leading characters, but if you
    want to only remove trailing characters you can use the `TrimRight` function,
    or if you want to only remove the leading characters you can use the `TrimLeft`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The earlier `Trim` functions remove any characters in the cutset. However, if
    you want to remove an entire leading substring (or a prefix) you can use the `TrimPrefix`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Similarly if you want to remove an entire trailing substring (or a suffix) you
    can use the `TrimSuffix` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `Trim` functions allows you to remove any leading or trailing characters
    or string. However, the most commonly removed characters are usually whitespaces,
    which can be newlines (`\n`) or tabs (`\r`) or carriage returns )`\r`). For convenience,
    Go provides a `TrimSpace` function that simply removes trailing and leading whitespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The last set of `Trim` functions are the `TrimFunc`, `TrimLeftFunc` and `TrimRightFunc`
    functions. As you would have guessed it from the name, this allows you to substitute
    the cutset string with a function that will inspect the leading or trailing or
    both Unicode code points and make sure they satisfy the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These `TrimFunc` functions allow you finer control over string trimming, which
    can be useful if you have unexpected rules for removing the leading or trailing
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 Capturing string input from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to capture user input string data from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Scan` functions in the `fmt` package to read a single string from standard
    input. To read a string separated by spaces, use `ReadString` on a `Reader` wrapped
    around `os.Stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your Go program runs from the command line you might come across a time where
    you need to get a string input from the user. This is where the `Scan` function
    from the `fmt` package comes in useful.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `Scan` to get input from the user by creating a variable then passing
    a reference to that variable into `Scan`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, the program will wait for your input at `fmt.Scan`
    and will only continue when you enter an input. Once you have entered some data,
    `Scan` will store the data into the `input` variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code above, this is what you should see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The documentation do not explicitly mention that you need to pass in a reference
    to a variable. You can pass in a variable by value and it will compile. However
    if you do that you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, you will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `Scan` function can take in more than one parameter, and each parameter
    represents a user input that is separated by a space. Let’s do this again with
    two inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you run this, and enter the words *Hello* and *World*, they will be captured
    and stored into `input1` and `input2` respectively. If you run the code above
    you will see this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This seems a bit limited. What if you want to capture a string that has spaces
    in it? For example, you want to get a user to input a sentence. In that case you
    can use the `ReadString` function on a `Reader` that is wrapped around `os.Stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, this is what you should see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You should know that `Scan` can be used to get more than just string input from
    users, it can be used to get numbers and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 2.12 Escaping and unescaping HTML strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to escape or unescape HTML strings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `EscapeString` and `UnescapeString` functions in the `html` package
    to escape or unescape HTML strings.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML is a text-based markup language that structures a web page and its content.
    It is usually interpreted by a browser and displayed. Much of HTML is described
    within HTML tags for example, `<a>` is an anchor tag and `<img>` is an image tag.
    Similarly there are other characters like `&` and `"` and others that has specific
    meaning in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if want to show those characters in HTML itself? For example, the
    ampersand (`&`) is a commonly used character. The less than and greater than (`<`
    and `>`) are also commonly used. If we don’t intend these symbols to have any
    meaning in HTML, we need to convert them into HTML character entities. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: < (less than) becomes <
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (greater than) becomes >
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: '& (ampersand) becomes &'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on. The process of converting HTML characters into entities is called
    HTML escaping and the reverse is called HTML unescaping.
  prefs: []
  type: TYPE_NORMAL
- en: Go has a pair of functions called `EscapeString` and `UnescapeString` in the
    `html` package that can be used to escape or unescape HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Unescaping reverts the escaped HTML back to the original string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that there is also a `HTMLEscapeString` function in the `html/template`
    package. The results of both functions are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 2.13 Using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use regular expressions to do string manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `regex` package and parse the regular expression using the `Compile`
    function to return a `Regexp` struct.Then use the `Find` functions to match the
    pattern and return the string.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular expressions are a notation for describing a search pattern in a string.
    When a particular string is in the set described by a regular expression, the
    regular expression matches the string. Regular expressions are popular and available
    in many languages.
  prefs: []
  type: TYPE_NORMAL
- en: Go has an entire standard package dedicated to regular expressions called `regex`.
    The syntax of the regular expressions is the same general syntax used by Perl,
    Python, and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `regex` package is quite straightforward. You must first create a
    `Regexp` struct from the regular expressions. With this struct you can call any
    number of `Find` functions that will return the strings or the index of the strings
    that matches.
  prefs: []
  type: TYPE_NORMAL
- en: While it looks like there are a lot of `Find` functions in the `regex` package,
    mostly attached as methods to the `Regexp` struct, there is a general pattern
    to them. In particular, the ones without `All` will only return the first match
    while the ones with `All` potentially returns all the matches in the string, depending
    on the `n` parameter. The ones with `String` will return strings or slices of
    strings, while the ones without will return as an array of bytes, `[]byte`. The
    ones with `Index` returns the index of the match.
  prefs: []
  type: TYPE_NORMAL
- en: In the code snippets below we will be using the same quote from *Great Expectations*
    by Charles Dickens as with the other recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start with creating a `Regexp` struct that can be used later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression here is `` `against [\w]+` ``. We use backticks to create
    the regular expression string because regular expressions use a lot of backslashes
    and these would be interpreted differently if we use double quotes. The regular
    expression we use matches against a pattern within a string that starts with *against*
    and has a word after it.
  prefs: []
  type: TYPE_NORMAL
- en: A convenient alternative to `Compile` is the `MustCompile` function. This function
    does exactly the same thing as `Compile`, except that it doesn’t return an error.
    Instead, if the regular expression doesn’t compile, the function will panic.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the regular expression set up, we can use it to find matches. There
    are a number of `Find` methods, but we’ll only go through a few in this recipe.
    One of the most straightforward method is `MatchString` which simply tells us
    if the regular expression has any matches in the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes besides checking if the regular expression has any matches, we also
    want to return the matching string. We can use `FindString` to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here we find a string from the `quote` string, using the regular expression
    we set up earlier. It returns the first match, so the returned string is `against
    reason`. If we want to return all matches, we have to use a method with `All`
    in it, like `FindAllString`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter in `FindAllString`, like all `All` methods, indicates the
    number of matches we want to be returned. If we want to return all matches, we
    need to use a negative number, in this case `-1`. The returned values are an array
    of strings.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the code above, which also prints out the array of strings, this is
    what we get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Besides returning the matched strings, sometimes we want to find out the locations
    of the matches. In this case, we can use the `Index` functions, for example the
    `FindStringIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This returns a 2-element slice of integers, which indicates the position of
    the first match. If we use these 2 integers on the `quote` itself, we will be
    able to extract the matching substring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As before, to get all matches, we need to use the `All` method, so in this case
    we can use the `FindAllStringIndex` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This will return a 2-dimensional slice of all matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Besides finding and indexing regular expressions, we can replace the matched
    strings altogether using `ReplaceAllString`. This is a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, this is what you should see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Beyond a simple replacement, we can replace the matched string with the output
    of a function that takes in the matched string and produces another string. Let’s
    take a look at a quick example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here we are replacing all the matched strings with the uppercase version of
    the string by using the `strings.ToUpper` function. This is the results of running
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say instead of making both words in the matched string uppercase, we only
    want the second word to be uppercase. We can create a simple function to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If we run this code, we will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are very powerful and used in many places. In Go it can
    be used for very powerful string manipulation. However, there is a word of caution.
    The `regex` package in Go supports the regular expression syntax accepted by RE2\.
    This gaurantees the regular expressions to run in time linear in the size of the
    input. As a result, some of the syntax like `lookahead` and `lookbehind` are not
    supported. If you’re more familiar with the syntax supported by PCRE library,
    you might want to check and make sure your regular expressions work the way you
    want it to.
  prefs: []
  type: TYPE_NORMAL
