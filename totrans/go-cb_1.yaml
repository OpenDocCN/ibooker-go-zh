- en: Chapter 2\. String Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。字符串示例
- en: 2.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.0 介绍
- en: String manipulation is one of the most common activities in any programming
    language. Most programs deal with text in one way or another, whether directly
    interacting with users or even communicating with between machines. Text is probably
    the closest thing we have to a universal medium, and string as data is everywhere.
    Being able to manipulate string is a critical capability in your arsenal as a
    programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作是任何编程语言中最常见的活动之一。大多数程序以某种方式处理文本，无论是直接与用户交互还是机器之间的通信。文本可能是我们拥有的最接近通用媒介的东西，而作为数据的字符串则无处不在。作为程序员，能够操作字符串是你的必备技能之一。
- en: Go has several packages used for string manipulation. The `strconv` package
    focuses on converting to or from strings. The `fmt` package provides functions
    to format strings using verbs as replacements, much like in C. The `unicode/utf8`
    and `unicode/utf16` packages have functions used in Unicode encoded strings. The
    `strings` package has functions to do many of the string manipulations we see
    so if you’re not sure what you need, that’s the most likely location to look.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有几个用于字符串操作的包。`strconv` 包专注于转换到或从字符串的操作。`fmt` 包提供使用动词作为替换来格式化字符串的函数，类似于 C
    语言。`unicode/utf8` 和 `unicode/utf16` 包具有用于 Unicode 编码字符串的函数。`strings` 包提供了许多我们看到的字符串操作函数，如果您不确定需要什么，那可能是最可能查找的位置。
- en: 2.1 Creating strings
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 创建字符串
- en: Problem
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create strings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望创建字符串。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use either the double quotes `""` or the backtick (or backquote) `“` to create
    string literals. Use the single quotes `”` to create character literals.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号 `""` 或反引号（或反引号） `“` 创建字符串字面量。使用单引号 `”` 创建字符字面量。
- en: Discussion
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In Go, `string` is a read-only (immutable) slice of bytes. It can be any byte,
    doesn’t need to be in any encoding or format. This is unlike some other programming
    languages, where strings are sequences of characters. In Go, a character can be
    represented by more than a single byte. This is in line with the Unicode standard,
    which defines a code-point to represent a value within a codespace. A character
    in this case can be represented by more than a single code-point. In Go, code-points
    are also called *runes* and a rune is an alias for the type `int32` just as a
    byte is an alias for the type `uint8` which represents an unsigned 8-bit integer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，`string` 是一个只读（不可变）的字节切片。它可以是任何字节，不需要任何编码或格式。这与其他一些编程语言不同，其中字符串是字符序列。在
    Go 中，一个字符可以由多个字节表示。这符合 Unicode 标准，该标准定义了一个代码点来表示代码空间内的值。在这种情况下，一个字符可以由多个代码点表示。在
    Go 中，代码点也称为 *rune*，而 rune 是类型 `int32` 的别名，就像 byte 是类型 `uint8` 的别名，表示无符号 8 位整数。
- en: As a result if you index a string, you will end up with a byte and not a character.
    In any case Go doesn’t have a character data type — bytes and runes are used instead.
    A byte represents ASCII characters and rune represents Unicode characters in UTF-8
    encoding. To be clear, it doesn’t mean that there are no characters in Go, just
    that there is no `char` data type, just `byte` and `rune`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您对字符串进行索引，最终将得到一个字节而不是字符。无论如何，Go 没有字符数据类型——而是使用字节和符文。一个字节表示 ASCII 字符，一个符文表示
    UTF-8 编码中的 Unicode 字符。需要明确的是，这并不意味着 Go 中没有字符，只是没有 `char` 数据类型，只有 `byte` 和 `rune`。
- en: Characters in Go are created using the single quotes `''`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，字符使用单引号 `''` 创建。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, the data type of the variable `c` is `int32` or a rune, by default.
    If oyu want it to be a byte, you can explicitly specify the type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，变量 `c` 的数据类型默认为 `int32` 或 rune。如果您希望它是字节，则可以显式指定类型。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Strings in Go can be created using either the double quotes `""` or the backtick
    [PRE2].
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，可以使用双引号 `""` 或反引号 [PRE2] 创建字符串。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Strings created using the double quotes can have escape characters in them.
    For example, a very common escape character is the newline, represented by a backslash
    followed by an *n* — `\n`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号创建的字符串中可以包含转义字符。例如，一个非常常见的转义字符是换行符，用反斜杠后跟 *n* 表示 — `\n`。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another common use of escape characters is to escape a double quote itself so
    it can be used within a string that’s created with a double quote.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 转义字符的另一个常见用途是转义双引号本身，以便它可以在使用双引号创建的字符串中使用。
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: String created using backticks are considered “raw” strings. Raw strings ignore
    all formatting including escape characters. In fact you can create multi-line
    string using backticks. For example, this is not possible using double quotes,
    in fact it’ll be a syntax error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反引号创建的字符串被认为是“原始”字符串。原始字符串忽略所有格式，包括转义字符。事实上，你可以使用反引号创建多行字符串。例如，使用双引号是不可能的，实际上会导致语法错误。
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However if we replace the double quotes with backticks `str` will be a multi-line
    string.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将双引号替换为反引号，则`str`将成为多行字符串。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because whatever comes in between the backticks are not processed by
    the Go compiler at all (i.e. it is “raw”).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为反引号之间的内容不被Go编译器处理（即它是“原始”的）。
- en: 2.2 Converting strings to bytes and bytes to string
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 将字符串转换为字节和字节转换为字符串
- en: Problem
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert string to bytes and bytes to string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将字符串转换为字节并将字节转换为字符串。
- en: Solution
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Typecast a string to an array of bytes using `[]byte(str)` and typecast an array
    of bytes to a string using `string(bytes)`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[]byte(str)`将字符串类型转换为字节数组，并使用`string(bytes)`将字节数组类型转换为字符串。
- en: Discussion
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Strings are slices of bytes so you can convert a string to an array of bytes
    directly through typecasting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字节片，因此你可以通过类型转换直接将字符串转换为字节数组。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Converting an array of bytes to a string is also done through typecasting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节数组转换为字符串也是通过类型转换完成的。
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 2.3 Creating strings from other strings and data
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 从其他字符串和数据创建字符串
- en: Problem
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a string from other strings or data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从其他字符串或数据创建一个字符串。
- en: Solution
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are a variety of ways of doing this, including direct concatenation, using
    `strings.Join`, using `fmt.Sprint` and using `strings.Builder`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以做到这一点，包括直接连接、使用`strings.Join`、使用`fmt.Sprint`和使用`strings.Builder`。
- en: Discussion
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: At times you want to create strings from other strings or data. One and rather
    straightforward way of doing this is to concatenate strings and other data together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想从其他字符串或数据创建字符串。一个相当直接的方法是将字符串和其他数据连接在一起。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Now` function returns the current time, which is formatted by the `Format`
    method returned as a string. When we concatenate the strings, we will get this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Now`函数返回当前时间，由`Format`方法格式化为字符串返回。当我们连接这些字符串时，我们将得到这个结果。'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Another way of doing this is use the `Join` function in the `string` package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在`string`包中使用`Join`函数。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is quite straightforward as well, because the function takes in an array
    of strings and given the separator, put them together.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也很简单，因为函数接受一个字符串数组，并根据分隔符将它们放在一起。
- en: So far both ways shown are about putting strings together. Obviously you can
    convert different data types into string before joining them up, but sometimes
    you just want Go to do it. For this we have the `fmt.Sprint` function and its
    various variants. Let’s look at the simplest and most straightforward variant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，展示的两种方法都是关于将字符串放在一起。显然，你可以在将它们连接起来之前将不同的数据类型转换为字符串，但有时你只想让Go来做。为此，我们有`fmt.Sprint`函数及其各种变体。让我们看看最简单和最直接的变体。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This doesn’t seem very different from the `Join` or the direct concatenation
    because all 3 parameters are strings. Actually `fmt.Sprint` and its variants take
    `interface{}` parameters, which means it can take in any data type. In other words,
    you can actually pass in the `Time` struct that’s returned by `Now` directly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Join`或直接连接似乎没有太大区别，因为所有三个参数都是字符串。实际上，`fmt.Sprint`及其变体接受`interface{}`参数，这意味着它可以接受任何数据类型。换句话说，你实际上可以直接传入`Now`返回的`Time`结构体。
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A popular variant of `fmt.Sprint` is the formatted variant i.e. `fmt.Sprintf`.
    Using this variant is slightly different — the first parameter is the format string,
    where you can place different verb formats at different locations within the string.
    The second parameter onwards are the data values that can be replaced into the
    verbs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Sprint`的一个流行变体是格式化变体，即`fmt.Sprintf`。使用这种变体略有不同——第一个参数是格式字符串，在字符串中的不同位置可以放置不同的动词格式。从第二个参数开始是可以替换到动词中的数据值。'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is no associated verb for a `Time` struct, so we use the `%v` which will
    format the value in the default format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Time`结构体没有关联的动词，因此我们使用`%v`，它将以默认格式格式化值。
- en: Finally, the `string` package also provides another way of creating strings,
    using the `strings.Builder` struct. Using `Builder` to create strings is a bit
    more involved, as it requires you to add the data piece by piece. Let’s take a
    look at using `Builder`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`string` 包还提供了另一种创建字符串的方式，使用 `strings.Builder` 结构体。使用 `Builder` 创建字符串稍微复杂一些，因为它需要逐个添加数据片段。让我们看看如何使用
    `Builder`。
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The idea is simple, we create a `Builder` struct, then write data to it bit
    by bit before finally extracting the final string using the `String` method. The
    `Builder` struct has a few more other methods including `Write` which takes in
    an array of bytes, `WriteByte` which takes in a single byte and `WriteRune` which
    takes in a single rune. However as you can see, they are all strings or characters.
    How about other data types? Do we need to convert all other data types to string
    or byte or rune first? No, because `Builder` is a `Writer` (it implements a `Write`
    method), you can actually use another way of writing different data types into
    it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 思路很简单，我们创建一个 `Builder` 结构体，然后逐步将数据写入其中，最后使用 `String` 方法提取最终的字符串。`Builder` 结构体还有一些其他方法，包括接受字节数组的
    `Write` 方法，接受单个字节的 `WriteByte` 方法以及接受单个字符的 `WriteRune` 方法。然而，正如你所见，它们都是字符串或字符。其他数据类型怎么办？我们需要先将所有其他数据类型转换为字符串、字节或字符吗？不需要，因为
    `Builder` 是一个 `Writer`（它实现了 `Write` 方法），你实际上可以使用另一种方法将不同的数据类型写入其中。
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we’re using `fmt.Fprint` to write whatever data type we want into the builder,
    and extract the final string using `String`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `fmt.Fprint` 将任意数据类型写入构建器，并使用 `String` 提取最终的字符串。
- en: We’ve seen quite a few ways of putting a string together using different pieces
    of data, both string and other types of data. Some are very straightforward (just
    add them together) whereas others are bit more deliberate. Here’s a look at the
    performance of these various ways.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用不同数据片段组合字符串的几种方法，包括字符串和其他类型的数据。有些方法非常直接（只需将它们添加在一起），而其他方法则更加深思熟虑。让我们来看看这些不同方法的性能表现。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s run the benchmark from the command line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命令行运行基准测试。
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the results.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果。
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It might come to you as a surprise that the simplest way is really the most
    performant as well. Using `fmt.Sprint` and anything that uses `interface{}` is
    simply less efficient.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可能让你惊讶的是，最简单的方法实际上也是性能最佳的方法。使用 `fmt.Sprint` 和使用 `interface{}` 的任何方法都相对不那么高效。
- en: 2.4 Converting strings to numbers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 将字符串转换为数字
- en: Problem
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert string to numbers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将字符串转换为数字。
- en: Solution
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Atoi` or the `Parse` functions in the `strconv` package to do string
    conversions. Use functions to convert strings to numbers, and use `Itoa` or the
    `Format` functions to convert numbers to strings.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strconv` 包中的 `Atoi` 或 `Parse` 函数进行字符串转换。使用函数将字符串转换为数字，并使用 `Itoa` 或 `Format`
    函数将数字转换为字符串。
- en: Discussion
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `strconv` package is true to its name and is a package used mostly for conversion
    of strings. There are two sets of functions that lets us convert strings to numbers
    and numbers to string. The `Parse` functions convert strings to numbers and the
    `Format` functions convert numbers to strings. If you’re not sure which ones to
    use, generally remember that parsing reads strings while formatting creates strings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv` 包名副其实，主要用于字符串转换。有两组函数让我们可以将字符串转换为数字和将数字转换为字符串。`Parse` 函数将字符串转换为数字，`Format`
    函数将数字转换为字符串。如果不确定使用哪些函数，一般来说记住解析函数读取字符串，格式化函数创建字符串。'
- en: Parsing strings into numbers seem to be limited in usage but it can be particularly
    useful when dealing with text formatted data, for example, JSON or Yaml or even
    XML. Text formatted data is popular because it is human readable but the drawback
    is that everything ends up being a string. Parsing the string into something more
    usable directly, in this case, numbers becomes really useful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串解析为数字在使用上似乎有限，但在处理文本格式化数据时可能特别有用，例如 JSON 或 Yaml，甚至是 XML。文本格式化数据很受欢迎，因为它易于阅读，但缺点是一切最终都成为字符串。直接将字符串解析为更可用的数据类型，比如数字，在这种情况下就变得非常有用。
- en: Let’s start with something simple. We want to parse a string that shows an integer
    and produces an actual integer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始。我们想要解析一个显示整数并产生实际整数的字符串。
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `strconv` package provides a convenience function to convert a string to
    an integer. This is quite easy to remember because `Atoi` basically is converting
    *alphanumeric* to *integer*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv` 包提供了一个方便的函数，用于将字符串转换为整数。这很容易记住，因为 `Atoi` 基本上是将 *字母数字* 转换为 *整数*。'
- en: The equivalent of `Atoi` using the `Parse` functions is `ParseInt(s, 10, 0)`
    where `s` is the string representing the number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Parse`函数等效于`Atoi`，使用`ParseInt(s, 10, 0)`，其中`s`是表示数字的字符串。
- en: The `ParseInt` function as the name suggests, parses a string into an integer.
    You can specify the base (0, 2 to 36) as well as the bit size (0 to 64). You can
    use `ParseInt` for signed or unsigned integers, just place a + or - in front of
    the number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`ParseInt`正如其名称所示，将字符串解析为整数。您可以指定基数（0、2到36）以及位数（0到64）。您可以使用`ParseInt`来处理有符号或无符号整数，只需在数字前加上+或-号。
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ParseFloat` function parses a string into a float. The bitsize parameter
    specifies the precision, 32 for `float32`, 64 for `float64` etc.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`ParseFloat`将字符串解析为浮点数。bitsize参数指定了精度，32用于`float32`，64用于`float64`等。
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the code above, `f` is a `float64` number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`f`是一个`float64`数值。
- en: '`ParseBool` can be useful when you’re trying to parse a string that represents
    a boolean value. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false,
    False.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试解析代表布尔值的字符串时，`ParseBool`很有用。它接受1、t、T、TRUE、true、True、0、f、F、FALSE、false、False这些值。
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the code above, `b` is a boolean with the value `true`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`b`是一个布尔值，其值为`true`。
- en: All the `Parse` functions return `NumError`, including `Atoi`. `NumError` provides
    additional information about the error including the function that was called,
    the number that was passed in and the reason why it failed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Parse`函数都会返回`NumError`，包括`Atoi`。`NumError`提供有关错误的附加信息，包括被调用的函数、传入的数字以及失败原因。
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is what you can see if you run this code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您运行此代码时可以看到的内容。
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2.5 Converting numbers to strings
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 将数字转换为字符串
- en: Problem
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert numbers to strings.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将数字转换为字符串。
- en: Solution
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Itoa` or the `Format` functions in the `strconv` package to convert
    numbers to strings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`strconv`包中的`Itoa`或`Format`函数将数字转换为字符串。
- en: Discussion
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We discussed about the `strconv` package and the `Parse` functions in the previous
    recipe. In this recipe we’ll talk about the `Format` functions and how we can
    use them to convert numbers to strings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我们已经讨论了`strconv`包和`Parse`函数。在本示例中，我们将讨论`Format`函数及其如何将数字转换为字符串。
- en: Formatting numbers into strings is the reverse of parsing strings into numbers.
    In cases where data needs to be communicated through text formats, formatting
    numbers can be useful. One frequent usage of formatting numbers into strings is
    when we need to show more readable numbers to users. For example, instead of showing
    1.66666666 to the user, we would want to show 1.67\. This is also commonly used
    when displaying currency.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字格式化为字符串是将字符串解析为数字的逆过程。在需要通过文本格式传递数据的情况下，将数字格式化可以很有用。将数字格式化为字符串的一个常见用法是在需要向用户展示更可读的数字时使用。例如，我们希望向用户展示`1.66666666`时，会希望显示`1.67`。这在显示货币时也很常见。
- en: Let’s start with the simplest example. Just as parsing strings has `Atoi`, formatting
    strings has `Itoa`. As the name suggests, it’s the reverse of `Atoi` — it converts
    an integer into a string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的例子开始。就像解析字符串有`Atoi`一样，格式化字符串有`Itoa`。顾名思义，它是`Atoi`的逆过程，将整数转换为字符串。
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that `Itoa` doesn’t return an error. In fact, none of the `Format` functions
    return errors. It makes sense — it is always possible to make a number a string,
    while it’s not the case in the reverse.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Itoa`不会返回错误。事实上，`Format`函数中的任何一个都不会返回错误。这是有道理的 —— 将数字转换为字符串总是可能的，而反之则不然。
- en: As before, `Itoa` is a convenient function for `FormatInt`. However we must
    first ensure the input number parameter is always an `int64`. `FormatInt` also
    requires a base parameter where base is an integer between 2 and 36, both numbers
    included. This means it can potentially convert binary numbers to string.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，`Itoa`是使用`FormatInt`的便捷函数。但是，我们必须首先确保输入的数字参数始终为`int64`。`FormatInt`还需要一个基数参数，其中基数是介于2到36之间的整数，两个数字都包括在内。这意味着它可以将二进制数转换为字符串。
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code above returns a string `"123"`. What if we specify a base of 2?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码返回字符串`"123"`。如果我们指定基数为2会怎么样？
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will return a string `"1111011"`. What this means is that you can use `FormatInt`
    to convert a number in one base to another, at least to display as a string.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回字符串`"1111011"`。这意味着您可以使用`FormatInt`将一个基数中的数字转换为另一个基数，至少作为字符串显示。
- en: 'The `FormatFloat` function is a bit more complicated that `FormatInt`. It converts
    a floating point number to a string according to a format and precision. The formats
    available in `FormatFloat` for decimal numbers (base 10) are:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatFloat`函数比`FormatInt`函数稍微复杂一些。它根据格式和精度将浮点数转换为字符串。`FormatFloat`中可用于十进制数（基数10）的格式有：'
- en: '`f` - no exponent'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` - 无指数'
- en: '`e` and `E` - with exponent'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` 和 `E` - 带有指数'
- en: '`g` and `G` - `e` or `E` respectively if the exponent is large, else it will
    be without exponent (like `f`)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g` 和 `G` - 如果指数很大，则为`e`或`E`，否则将不带指数（例如`f`）'
- en: The other formats are `b` for binary numbers (base 2) and `x` and `X` for hexadecimal
    numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式是二进制数字（基数2）的`b`，十六进制数字（基数16）的`x`和`X`。
- en: The precision describes the number of digits (excluding the exponents) to be
    printed out. A precision of value -1 lets Go select the smallest number of digits
    such that ParseFloat returns the entire number.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 精度描述的是要打印的数字位数（不包括指数）。精度值为-1时，Go会选择最小的数字位数，以便`ParseFloat`返回整个数字。
- en: Let’s look at some code, it will make things clearer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码，这将使事情更清晰。
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’re using a float value with 64-bit precision, `float64`, and we will compare
    the precision of -1 with the precision of 4\. In case you didn’t realise, both
    lower case *e* and upper case *E* are exactly the same, except the exponent letter
    *e* is in lower or upper case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用64位精度的浮点值`float64`，并比较精度-1和精度4。如果你没有意识到，小写*e*和大写*E*是完全相同的，除了指数字母*e*是小写或大写的不同。
- en: When you run the code, this is what you should see.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你应该看到这个。
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 2.6 Replacing multiple characters in a string
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 替换字符串中的多个字符
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to replace parts in a string with another string.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你想用另一个字符串替换字符串的部分。
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are several ways of doing it. You can use the `strings.Replace` function
    or `strings.ReplaceAll` function to replace the selected string. You can also
    use the `strings.Replacer` type to create replacers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点。你可以使用`strings.Replace`函数或`strings.ReplaceAll`函数来替换选定的字符串。你也可以使用`strings.Replacer`类型来创建替换器。
- en: Discussion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: There are several ways we can use to replace parts of a string with another
    string. The easiest is to use the `strings.Replace` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以用来用另一个字符串替换字符串的部分。最简单的方法是使用`strings.Replace`函数。
- en: The `strings.Replace` function is quite straightforward. Just pass it a string,
    the old string you want to replace, and the new string you want to replace it
    with. Let’s take a look at the code, using this quote from *Great Expectations*
    by Charles Dickens.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Replace`函数非常简单。只需传递一个字符串，旧字符串你想要替换的字符串，以及你想要替换它的新字符串。让我们看看这段代码，使用查尔斯·狄更斯的《远大前程》中的这句话。'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We run a few replacements using `Replace`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Replace`运行了几次替换。
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The last parameter tells `Replace` the number of matches to replace. If the
    last parameter is -1, `Replace` will match every instance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数告诉`Replace`要替换的匹配数。如果最后一个参数是-1，`Replace`将匹配每一个实例。
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is also a `ReplaceAll` function which is more of a convenience function
    that calls `Replace` with the last parameter set to -1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`ReplaceAll`函数，它更像是一个方便的函数，调用`Replace`时将最后一个参数设置为-1。
- en: The `Replacer` type in the `strings` package that allows you to make multiple
    replacements all at the same time. This is a lot more convenient if you need to
    do a lot of replacements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`包中的`Replacer`类型允许您同时进行多个替换。如果您需要进行大量替换，这将更加方便。'
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You just need to provide a list of replacement strings as the parameters. In
    the code above, we replaced “her” with “him”, “against” with “for” and “all” with
    “some”. It will do all the replacements at the same time. If you run the code
    above you will get the results below.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要提供一组替换字符串作为参数。在上面的代码中，我们用“her”替换“him”，“against”替换“for”，“all”替换“some”。它将同时进行所有替换。如果你运行上面的代码，你将得到以下结果。
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So is it better to use `Replace` or create a `Replacer`? It takes a another
    line of code to create the replacer, obviously. But how about its performance?
    Let’s take a look. We’ll start with just replacing 1 word.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以使用`Replace`还是创建`Replacer`更好呢？显然，创建替换器需要额外的一行代码。但是它的性能如何？让我们看一看。我们将从仅替换一个单词开始。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If it’s just one string to replace, `Replace` is faster. There is just more
    overhead for a simple replacement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是一个字符串需要替换，`Replace`更快。对于简单替换，只是有更多的开销。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s look at if we need to do multiple replacements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否需要进行多次替换。
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We don’t need to create a `Replacer` each time so we can reuse the replacer
    multiple times if you want to do the same replacements for different strings.
    At the same time, if you have a lot of replacements, it’s definitely easier to
    use a replacer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要每次创建一个`Replacer`，因此如果您想对不同的字符串进行相同的替换，可以多次重用替换器。同时，如果您有很多替换，使用替换器肯定更容易。
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, with more strings to replace, using `Replacer` becomes more
    efficient.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，要替换更多的字符串，使用`Replacer`会更有效率。
- en: 2.7 Creating substrings
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 创建子字符串
- en: Problem
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create substrings from a string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您想从字符串中创建子字符串。
- en: Solution
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Treat a string like an array or a slice and take a substring out of the string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串视为数组或切片，并从字符串中取出一个子字符串。
- en: Discussion
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In Go, a string is a slice of bytes. As a result if you want to take a substring
    out of a string, you can just do what you would do with any slice. Let’s take
    the same quote as in the previous recipes, the quote from *Great Expectations*
    by Charles Dickens.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，字符串是字节的切片。因此，如果您想从字符串中取出一个子字符串，可以像对待任何切片一样操作。让我们使用前面的配方中相同的引语，查尔斯·狄更斯的《远大前程》。
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you want to extract the words “against reason” from the quote, you can do
    this.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从引语中提取“against reason”这几个词，可以这样做。
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is simple enough, but how do know the position of the words without manually
    counting letters in the quote? Like in many programming languages, we just need
    to find the index of the substring.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但是如何在不手动计数引语中的字母的情况下知道单词的位置呢？像许多编程语言一样，我们只需找到子字符串的索引。
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `strings.Index` function gives us the index of the first substring that
    matches the second parameter, this case it will be 12\. This will give us position
    of substring. To find the end position of the substring, we simply add the length
    of the substring to the index.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Index`函数给出了与第二个参数匹配的第一个子字符串的索引，本例中将是12。这将给我们子字符串的位置。要找到子字符串的结束位置，我们只需将子字符串的长度添加到索引即可。'
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 2.8 Checking if a string contains another string
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8 检查字符串是否包含另一个字符串
- en: Problem
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to check if a string contains another string.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您想检查一个字符串是否包含另一个字符串。
- en: Solution
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Contains` functions in the `strings` package. If the string you want
    to check is a suffix or a prefix, you can also use the `HasSuffix` or the `HasPrefix`
    functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`strings`包中的`Contains`函数。如果您要检查的字符串是后缀或前缀，也可以使用`HasSuffix`或`HasPrefix`函数。
- en: Discussion
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Checking if a string has a substring is quite easy in Go. You can use the `strings.Contains`
    function and pass in both the string and substring and it will return true or
    false accordingly. We’ll use the quote from *Great Expectations* by Charles Dickens
    again.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中检查字符串是否包含另一个字符串非常简单。您可以使用`strings.Contains`函数，传入字符串和子字符串，它会相应地返回true或false。我们将再次使用查尔斯·狄更斯的《远大前程》中的引语。
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Contains` function checks if the quote contains the string “against”.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contains`函数检查引语是否包含字符串“against”。'
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Alternately you can always use `strings.Index` and if the returned result is
    < 0 it means the substring is not found in the string. The performance is the
    same in either function, not surprisingly because `Contains` is just a convenience
    function around `Index`. Another alternative is to use the `Count` function, which
    returns the number of times the substring is found in the string, but this is
    usually a poorer alternative (unless you need to know the count anyway) because
    the performance is poorer than either.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以始终使用`strings.Index`，如果返回的结果是 < 0，这意味着字符串中找不到子字符串。两种函数的性能是一样的，这并不奇怪，因为`Contains`只是围绕`Index`函数提供的方便功能。另一种选择是使用`Count`函数，它返回子字符串在字符串中出现的次数，但这通常是一个较差的选择（除非您无论如何都需要知道计数），因为性能比任一函数都要差。
- en: If you wanted to find out if the substring is the prefix of the string, you
    can use the `HasPrefix` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查找子字符串是否是字符串的前缀，可以使用`HasPrefix`函数。
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Of course, you can directly slice the length of the prefix from the string and
    check it yourself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以直接从字符串中切出前缀的长度并自行检查。
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can do the same for suffixes as well with the `HasSuffix` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`HasSuffix`函数对后缀执行相同的操作。
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can also directly slice the string for the suffix and compare it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接切片字符串以获取后缀并进行比较。
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 2.9 Splitting a string into an array of strings or combining an array of strings
    into a string
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 将字符串分割为字符串数组或将字符串数组组合成字符串
- en: Problem
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create an array of string by splitting up a string or create a string
    by combining an array of strings.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你想通过拆分字符串创建一个字符串数组，或者通过组合字符串数组创建一个字符串。
- en: Solution
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Split` functions in the `strings` package to split up a string and
    the `Join` function to combine the array of strings into a single string.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`strings`包中的`Split`函数来拆分字符串，并使用`Join`函数将字符串数组组合成单个字符串。
- en: Discussion
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Many functions take in an array of strings. You might want to tackle words in
    a string instead of individual bytes. You might be dealing with data that is delimited
    by a separator like in delimited text format like CSV or TSV. Whichever case it
    may me, being able to quickly split up a string into an array of strings is useful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数接受一个字符串数组。你可能想要处理字符串中的单词而不是单独的字节。你可能在处理像CSV或TSV这样的分隔符分隔的数据。无论是哪种情况，能够快速地将一个字符串拆分成字符串数组是很有用的。
- en: In Go, you can do this using the `strings.Split` function. Let’s use the quote
    from *Great Expectations* by Charles Dickens again.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，你可以使用`strings.Split`函数来做到这一点。让我们再次使用查尔斯·狄更斯的《远大前程》的引语。
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `Split` function splits a string into an array of string, given the separator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Split`函数根据指定的分隔符将字符串拆分为字符串数组。'
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the code above, we use a space as the separator, so this is what you will
    see.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用空格作为分隔符，所以这是你会看到的。
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You might notice that some elements have the newline character because the original
    string has it. It’s probably not what you want, so how can we remove the newline
    characters? Or worse, if you have multiple spaces, your array will look pretty
    messy with a lot of additional empty string elements. Of course you can clean
    it up by brute force later on but there is a simpler way. The `strings` package
    has a function `Fields` that can split a string considering one or more consecutive
    spaces as defined by `uniform.isSpace`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到一些元素有换行符，因为原始字符串包含它。这可能不是你想要的，那么我们如何移除换行符？或者更糟糕的是，如果有多个空格，你的数组看起来会非常凌乱，有许多额外的空字符串元素。当然，你可以稍后用笨方法清理它们，但有一个更简单的方法。`strings`包中有一个名为`Fields`的函数，可以将一个字符串拆分为考虑一个或多个连续空格的字符串数组，由`uniform.isSpace`定义。
- en: Let’s take a look if we use `Fields` instead of `Split`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`Fields`而不是`Split`来看一下。
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You should see this now.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能看到这个了。
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The newline characters are gone. How about if we want to remove even the punctuation
    (in this case, the commas and the full stop at the end of the quote)? This is
    a bit more complicated, we need to use the `FieldsFunc` function and pass in a
    function that will determine that should be part of the separator or not. Let’s
    take a look.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符已经被去掉了。如果我们想要连标点符号（在这种情况下是逗号和句号在引号末尾）也移除掉呢？这有点复杂，我们需要使用`FieldsFunc`函数并传入一个函数来确定是否应该将其作为分隔符的一部分。让我们看看。
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the code above, we create a function `f` that considers consecutive punctuations
    and non-letters to be part of the separator. Then we pass this function into `FieldsFunc`
    for it to be executed against the string. This is what we should see.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个函数`f`，它将连续的标点符号和非字母字符视为分隔符的一部分。然后我们将这个函数传递给`FieldsFunc`来对字符串执行。这是我们应该看到的。
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we have also removed the punctuations. The `FieldsFunc` function
    is very versatile, I’ve only given a very simple example. If you work a lot with
    splitting strings, this will be a very powerful function you can use to do many
    things.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们也去掉了标点符号。`FieldsFunc`函数非常灵活，我只给出了一个非常简单的例子。如果你经常处理字符串拆分，这将是一个非常强大的函数，你可以用它做很多事情。
- en: What if we want to just split the string for the first 9 elements and put the
    rest in single string? The `SplitN` function does exactly that, with `n` being
    the number of elements to have in the resulting array, in this case here it’s
    10.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想把字符串拆分为前9个元素并将剩余部分放入单个字符串呢？`SplitN`函数正好可以做到这一点，其中`n`是生成数组中元素数量，在这种情况下是10。
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You will see that there are 10 elements in the resulting array.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会看到结果数组中有10个元素。
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Sometimes you want to keep the delimiter after you split the string. Go has
    a function called `SplitAfter` that does this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望在拆分字符串后保留分隔符。Go语言有一个名为`SplitAfter`的函数可以做到这一点。
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, each element ends with a space (which is the delimiter) except
    the final element.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个元素都以空格结尾（这是分隔符），除了最后一个元素。
- en: '[PRE61]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 2.10 Trimming strings
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 字符串修剪
- en: Problem
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to remove the leading and trailing characters of a string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要移除字符串的开头和结尾的字符。
- en: Solution
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Trim` functions in the `strings` package.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strings` 包中的 `Trim` 函数。
- en: Discussion
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When processing strings it’s quite common to encounter trailing or leading whitespaces
    or other unnecessary characters. Very often we want to remove these characters
    before storing or processing the strings further. Because of this, the idea of
    string trimming is quite common as well. String trimming essentially removes characters
    from the start or the end of the string, but not within the string.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，经常会遇到尾随或前导的空白或其他不必要的字符。我们经常希望在存储或进一步处理字符串之前移除这些字符。因此，字符串修剪的概念也非常普遍。字符串修剪基本上是从字符串的开头或结尾移除字符，而不是在字符串内部。
- en: In Go, there are a number of `Trim` functions in the `strings` package that
    can help us with trimming strings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，有许多 `strings` 包中的 `Trim` 函数可以帮助我们修剪字符串。
- en: Let’s start with the `Trim` function. It takes in a string and a *cutset* which
    is a string consisting of one or more Unicode code points and returns a string
    with all leading and trailing these code points removed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `Trim` 函数开始。它接受一个字符串和一个*切割集*，这是一个由一个或多个 Unicode 代码点组成的字符串，并返回一个删除了所有前导和尾随这些代码点的字符串。
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the code above, we want to remove the leading comma and whitespace, and also
    the trailing full stop. To do this we use a cutset consisting of these 3 Unicode
    code points, so the cutset string ends up to be `",. "`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们想要移除前导逗号和空格，以及尾随句点。为此，我们使用包含这 3 个 Unicode 代码点的切割集，因此切割集字符串最终为 `",.
    "`。
- en: The `Trim` function removes both trailing and leading characters, but if you
    want to only remove trailing characters you can use the `TrimRight` function,
    or if you want to only remove the leading characters you can use the `TrimLeft`
    function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trim` 函数同时移除前导和尾随字符，但如果您只想移除尾随字符，可以使用 `TrimRight` 函数；如果只想移除前导字符，可以使用 `TrimLeft`
    函数。'
- en: '[PRE63]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The earlier `Trim` functions remove any characters in the cutset. However, if
    you want to remove an entire leading substring (or a prefix) you can use the `TrimPrefix`
    function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `Trim` 函数会移除切割集中的任何字符。但是，如果你想要移除整个前导子字符串（或者前缀），你可以使用 `TrimPrefix` 函数。
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Similarly if you want to remove an entire trailing substring (or a suffix) you
    can use the `TrimSuffix` function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果你想要移除整个尾部子字符串（或者后缀），你可以使用 `TrimSuffix` 函数。
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `Trim` functions allows you to remove any leading or trailing characters
    or string. However, the most commonly removed characters are usually whitespaces,
    which can be newlines (`\n`) or tabs (`\r`) or carriage returns )`\r`). For convenience,
    Go provides a `TrimSpace` function that simply removes trailing and leading whitespaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trim` 函数允许您移除任何前导或尾随字符或字符串。但通常被移除的字符是空白字符，如换行符 (`\n`) 或制表符 (`\r`) 或回车符 (`\r`)。为方便起见，Go
    提供了一个 `TrimSpace` 函数，仅移除前导和尾随空白字符。'
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The last set of `Trim` functions are the `TrimFunc`, `TrimLeftFunc` and `TrimRightFunc`
    functions. As you would have guessed it from the name, this allows you to substitute
    the cutset string with a function that will inspect the leading or trailing or
    both Unicode code points and make sure they satisfy the conditions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组 `Trim` 函数是 `TrimFunc`、`TrimLeftFunc` 和 `TrimRightFunc` 函数。从名称就可以猜到，这允许您用函数替换切割集字符串，该函数将检查前导或尾随或两者都检查的
    Unicode 代码点，并确保它们满足条件。
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These `TrimFunc` functions allow you finer control over string trimming, which
    can be useful if you have unexpected rules for removing the leading or trailing
    characters.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `TrimFunc` 函数允许您对字符串修剪进行更精细的控制，如果您有意外的规则用于删除前导或尾随字符，则非常有用。
- en: 2.11 Capturing string input from the command line
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.11 从命令行捕获字符串输入
- en: Problem
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to capture user input string data from the command line.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要从命令行捕获用户输入的字符串数据。
- en: Solution
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `Scan` functions in the `fmt` package to read a single string from standard
    input. To read a string separated by spaces, use `ReadString` on a `Reader` wrapped
    around `os.Stdin`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fmt` 包中的 `Scan` 函数从标准输入读取单个字符串。要读取由空格分隔的字符串，请在包装在 `os.Stdin` 周围的 `Reader`
    上使用 `ReadString`。
- en: Discussion
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If your Go program runs from the command line you might come across a time where
    you need to get a string input from the user. This is where the `Scan` function
    from the `fmt` package comes in useful.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Go 程序从命令行运行，可能会遇到需要从用户获取字符串输入的情况。这就是 `fmt` 包中的 `Scan` 函数派上用场的地方。
- en: You can use `Scan` to get input from the user by creating a variable then passing
    a reference to that variable into `Scan`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Scan` 来从用户获取输入，方法是创建一个变量，然后将该变量的引用传递给 `Scan`。
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you run the code above, the program will wait for your input at `fmt.Scan`
    and will only continue when you enter an input. Once you have entered some data,
    `Scan` will store the data into the `input` variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上面的代码，程序将在 `fmt.Scan` 处等待您的输入，并且只有在您输入数据后才会继续。一旦您输入了一些数据，`Scan` 将把数据存储到
    `input` 变量中。
- en: If you run the code above, this is what you should see.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上面的代码，这就是您应该看到的。
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The documentation do not explicitly mention that you need to pass in a reference
    to a variable. You can pass in a variable by value and it will compile. However
    if you do that you will get an error.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文档没有明确提到您需要传递一个变量的引用。您可以按值传递一个变量，它将被编译。但是，如果您这样做，将会出现错误。
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you run the code above, you will get this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上面的代码，您将看到这个结果。
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `Scan` function can take in more than one parameter, and each parameter
    represents a user input that is separated by a space. Let’s do this again with
    two inputs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scan` 函数可以接受多个参数，每个参数表示由空格分隔的用户输入。让我们再做两个输入。'
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you run this, and enter the words *Hello* and *World*, they will be captured
    and stored into `input1` and `input2` respectively. If you run the code above
    you will see this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，并输入 *Hello* 和 *World*，它们将分别被捕获并存储到 `input1` 和 `input2` 中。如果您运行上面的代码，您将看到这个结果。
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This seems a bit limited. What if you want to capture a string that has spaces
    in it? For example, you want to get a user to input a sentence. In that case you
    can use the `ReadString` function on a `Reader` that is wrapped around `os.Stdin`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有些局限性。如果您想捕获一个带有空格的字符串怎么办？例如，您想要让用户输入一个句子。在这种情况下，您可以在包装在 `os.Stdin` 周围的 `Reader`
    上使用 `ReadString` 函数。
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you run the code above, this is what you should see.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上面的代码，这就是您应该看到的结果。
- en: '[PRE75]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You should know that `Scan` can be used to get more than just string input from
    users, it can be used to get numbers and so on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道 `Scan` 不仅可以用于从用户获取字符串输入，还可以用于获取数字等。
- en: 2.12 Escaping and unescaping HTML strings
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.12 转义和反转义 HTML 字符串
- en: Problem
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to escape or unescape HTML strings.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要转义或反转义 HTML 字符串。
- en: Solution
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `EscapeString` and `UnescapeString` functions in the `html` package
    to escape or unescape HTML strings.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `html` 包中的 `EscapeString` 和 `UnescapeString` 函数来转义或反转义 HTML 字符串。
- en: Discussion
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: HTML is a text-based markup language that structures a web page and its content.
    It is usually interpreted by a browser and displayed. Much of HTML is described
    within HTML tags for example, `<a>` is an anchor tag and `<img>` is an image tag.
    Similarly there are other characters like `&` and `"` and others that has specific
    meaning in HTML.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是一种基于文本的标记语言，用于结构化网页及其内容。它通常由浏览器解释并显示。HTML 的大部分内容都在 HTML 标签内描述，例如 `<a>`
    是锚点标签，`<img>` 是图像标签。类似地，还有其他像 `&` 和 `"` 这样具有在 HTML 中特定意义的字符。
- en: 'But what if want to show those characters in HTML itself? For example, the
    ampersand (`&`) is a commonly used character. The less than and greater than (`<`
    and `>`) are also commonly used. If we don’t intend these symbols to have any
    meaning in HTML, we need to convert them into HTML character entities. For example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果想在 HTML 中显示这些字符怎么办？例如，和符号（`&`）是一个常用字符。小于号和大于号（`<` 和 `>`）也是常用的。如果我们不打算让这些符号在
    HTML 中具有任何意义，我们需要将它们转换为 HTML 字符实体。例如：
- en: < (less than) becomes <
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于号变成了 <
- en: (greater than) becomes >
  id: totrans-267
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大于号变成了 >
- en: '& (ampersand) becomes &'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '&（和符号）变成了 &'
- en: And so on. The process of converting HTML characters into entities is called
    HTML escaping and the reverse is called HTML unescaping.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。将 HTML 字符转换为实体的过程称为 HTML 转义，反之则称为 HTML 反转义。
- en: Go has a pair of functions called `EscapeString` and `UnescapeString` in the
    `html` package that can be used to escape or unescape HTML.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言在 `html` 包中有一对函数，名为 `EscapeString` 和 `UnescapeString`，可用于转义或反转义 HTML。
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unescaping reverts the escaped HTML back to the original string.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 反转义将转义的 HTML 字符串恢复为原始字符串。
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You might notice that there is also a `HTMLEscapeString` function in the `html/template`
    package. The results of both functions are the same.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到 `html/template` 包中还有一个 `HTMLEscapeString` 函数。这两个函数的结果是相同的。
- en: 2.13 Using regular expressions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.13 使用正则表达式
- en: Problem
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use regular expressions to do string manipulation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要使用正则表达式进行字符串操作。
- en: Solution
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `regex` package and parse the regular expression using the `Compile`
    function to return a `Regexp` struct.Then use the `Find` functions to match the
    pattern and return the string.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regex`包，并使用`Compile`函数解析正则表达式以返回一个`Regexp`结构体。然后使用`Find`函数匹配模式并返回字符串。
- en: Discussion
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Regular expressions are a notation for describing a search pattern in a string.
    When a particular string is in the set described by a regular expression, the
    regular expression matches the string. Regular expressions are popular and available
    in many languages.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种描述字符串中搜索模式的表示法。当特定字符串在正则表达式描述的集合中时，正则表达式与该字符串匹配。正则表达式在许多语言中都很流行且可用。
- en: Go has an entire standard package dedicated to regular expressions called `regex`.
    The syntax of the regular expressions is the same general syntax used by Perl,
    Python, and other languages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有一个专门用于正则表达式的标准包叫做`regex`。正则表达式的语法与Perl、Python和其他语言使用的一般语法相同。
- en: Using the `regex` package is quite straightforward. You must first create a
    `Regexp` struct from the regular expressions. With this struct you can call any
    number of `Find` functions that will return the strings or the index of the strings
    that matches.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regex`包非常简单。你必须先从正则表达式创建一个`Regexp`结构体。有了这个结构体，你可以调用任意数量的`Find`函数来返回匹配的字符串或字符串的索引。
- en: While it looks like there are a lot of `Find` functions in the `regex` package,
    mostly attached as methods to the `Regexp` struct, there is a general pattern
    to them. In particular, the ones without `All` will only return the first match
    while the ones with `All` potentially returns all the matches in the string, depending
    on the `n` parameter. The ones with `String` will return strings or slices of
    strings, while the ones without will return as an array of bytes, `[]byte`. The
    ones with `Index` returns the index of the match.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`regex`包中看起来有很多`Find`函数，大多数都作为`Regexp`结构体的方法附加在上面，但它们有一个通用的模式。特别是没有`All`的那些函数只会返回第一个匹配项，而带有`All`的函数将根据`n`参数在字符串中可能返回所有匹配项。带有`String`的函数将返回字符串或字符串片段，而没有的函数将返回字节数组`[]byte`。带有`Index`的函数返回匹配项的索引。
- en: In the code snippets below we will be using the same quote from *Great Expectations*
    by Charles Dickens as with the other recipes in this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将使用查尔斯·狄更斯《远大前程》中的同一引用，就像本章节中的其他示例一样。
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let’s start with creating a `Regexp` struct that can be used later.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个`Regexp`结构体，以便稍后使用。
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The regular expression here is `` `against [\w]+` ``. We use backticks to create
    the regular expression string because regular expressions use a lot of backslashes
    and these would be interpreted differently if we use double quotes. The regular
    expression we use matches against a pattern within a string that starts with *against*
    and has a word after it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正则表达式是`` `against [\w]+` ``。我们使用反引号来创建正则表达式字符串，因为正则表达式使用了很多反斜杠，如果我们使用双引号，这些反斜杠会被解释得不同。我们使用的正则表达式匹配以*against*开头并在其后有一个单词的字符串模式。
- en: A convenient alternative to `Compile` is the `MustCompile` function. This function
    does exactly the same thing as `Compile`, except that it doesn’t return an error.
    Instead, if the regular expression doesn’t compile, the function will panic.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compile`的一个方便替代是`MustCompile`函数。这个函数与`Compile`做的事情完全一样，只是它不会返回错误。相反，如果正则表达式无法编译，该函数将会引发panic。'
- en: Once we have the regular expression set up, we can use it to find matches. There
    are a number of `Find` methods, but we’ll only go through a few in this recipe.
    One of the most straightforward method is `MatchString` which simply tells us
    if the regular expression has any matches in the string.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了正则表达式，我们就可以用它来查找匹配项。有许多`Find`方法，但在这个示例中我们只介绍了其中几个。其中一个最直接的方法是`MatchString`，它简单地告诉我们正则表达式在字符串中是否有任何匹配项。
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Sometimes besides checking if the regular expression has any matches, we also
    want to return the matching string. We can use `FindString` to do this.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有时除了检查正则表达式是否有任何匹配项外，我们还想返回匹配的字符串。我们可以使用`FindString`来实现这一点。
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here we find a string from the `quote` string, using the regular expression
    we set up earlier. It returns the first match, so the returned string is `against
    reason`. If we want to return all matches, we have to use a method with `All`
    in it, like `FindAllString`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从`quote`字符串中找到一个字符串，使用我们之前设置的正则表达式。它返回第一个匹配项，因此返回的字符串是`against reason`。如果我们想返回所有匹配项，我们必须使用带有`All`的方法，例如`FindAllString`。
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The second parameter in `FindAllString`, like all `All` methods, indicates the
    number of matches we want to be returned. If we want to return all matches, we
    need to use a negative number, in this case `-1`. The returned values are an array
    of strings.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindAllString`中的第二个参数，像所有的`All`方法一样，表示我们希望返回的匹配数。如果我们想返回所有匹配项，我们需要使用一个负数，例如`-1`。返回的值是一个字符串数组。'
- en: If we run the code above, which also prints out the array of strings, this is
    what we get.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上面的代码，同时打印出字符串数组，我们将得到这样的结果。
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Besides returning the matched strings, sometimes we want to find out the locations
    of the matches. In this case, we can use the `Index` functions, for example the
    `FindStringIndex`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回匹配的字符串，有时我们还想知道匹配项的位置。在这种情况下，我们可以使用`Index`函数，例如`FindStringIndex`。
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This returns a 2-element slice of integers, which indicates the position of
    the first match. If we use these 2 integers on the `quote` itself, we will be
    able to extract the matching substring.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个包含两个整数的切片，表示第一个匹配的位置。如果我们使用这两个整数在`quote`本身上，我们将能够提取匹配的子字符串。
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As before, to get all matches, we need to use the `All` method, so in this case
    we can use the `FindAllStringIndex` method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，要获取所有匹配项，我们需要使用`All`方法，因此在这种情况下我们可以使用`FindAllStringIndex`方法。
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This will return a 2-dimensional slice of all matches.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有匹配项的二维切片。
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Besides finding and indexing regular expressions, we can replace the matched
    strings altogether using `ReplaceAllString`. This is a simple example.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查找和索引正则表达式，我们还可以使用`ReplaceAllString`完全替换匹配的字符串。这是一个简单的例子。
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If you run the code above, this is what you should see.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，你应该看到这个结果。
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Beyond a simple replacement, we can replace the matched string with the output
    of a function that takes in the matched string and produces another string. Let’s
    take a look at a quick example.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的替换，我们还可以使用一个接受匹配字符串并生成另一个字符串作为输出的函数来替换匹配的字符串。让我们看一个快速的例子。
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here we are replacing all the matched strings with the uppercase version of
    the string by using the `strings.ToUpper` function. This is the results of running
    the code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用`strings.ToUpper`函数将所有匹配的字符串替换为大写版本。这是运行代码的结果。
- en: '[PRE91]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Let’s say instead of making both words in the matched string uppercase, we only
    want the second word to be uppercase. We can create a simple function to do this.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是将匹配字符串中的两个单词都大写，而是只想让第二个单词大写。我们可以创建一个简单的函数来实现这个目标。
- en: '[PRE92]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If we run this code, we will get this.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将得到这个结果。
- en: '[PRE93]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Regular expressions are very powerful and used in many places. In Go it can
    be used for very powerful string manipulation. However, there is a word of caution.
    The `regex` package in Go supports the regular expression syntax accepted by RE2\.
    This gaurantees the regular expressions to run in time linear in the size of the
    input. As a result, some of the syntax like `lookahead` and `lookbehind` are not
    supported. If you’re more familiar with the syntax supported by PCRE library,
    you might want to check and make sure your regular expressions work the way you
    want it to.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常强大，并且在许多地方都有用途。在Go语言中，它可以用于非常强大的字符串操作。然而，需要注意的是，Go语言中的`regex`包支持RE2接受的正则表达式语法。这保证了正则表达式在输入大小线性时间内运行。因此，一些像`lookahead`和`lookbehind`这样的语法不被支持。如果你更熟悉PCRE库支持的语法，你可能需要检查并确保你的正则表达式按照你希望的方式工作。
