<html><head></head><body><section data-pdf-bookmark="Chapter 4. gRPC: Under the Hood" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_04">&#13;
<h1><span class="label">Chapter 4. </span>gRPC: Under the Hood</h1>&#13;
&#13;
&#13;
<p>As you have learned in previous chapters, gRPC applications communicate using RPC over the network. As a gRPC application developer, you don’t need to worry about the underlying details of how RPC is implemented, what message-encoding techniques are used, and how RPC works over the network. You use the service definition to generate either server- or client-side code for the language of your choice. All the low-level communication details are implemented in the generated code and you get some high-level abstractions to work with. However, when building complex gRPC-based systems and running them in production, it’s vital to know how gRPC works under the hood.</p>&#13;
&#13;
<p>In this chapter, we’ll explore how the gRPC communication flow is implemented, what encoding techniques are used, how gRPC uses the underlying network communication techniques, and so on. We’ll walk you through the message flow where the client invokes a given RPC, then discuss how it gets marshaled to a gRPC call that goes over the network, how the network communication protocol is used, how it is unmarshaled at the server, how the corresponding service and remote function is invoked, and so on.</p>&#13;
&#13;
<p>We’ll also look at how we use protocol buffers as the encoding technique and HTTP/2 as the communication protocol for gRPC. Finally, we’ll dive into the implementation architecture of gRPC and the language support stack built around it. Although the low-level details that we are going to discuss here may not be of much use in most gRPC applications, having a good understanding of the low-level communication details is quite helpful if you are designing a complex gRPC application or trying to debug existing applications.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RPC Flow" data-type="sect1"><div class="sect1" id="idm46536641567864">&#13;
<h1>RPC Flow</h1>&#13;
&#13;
<p><a data-primary="RPC (remote procedure call)" data-secondary="communication flow" data-type="indexterm" id="ix_ch04-asciidoc0"/>In an RPC system, the server implements a set of functions that can be invoked remotely. The client application can generate a stub that provides abstractions for the same functions offered from the server so that the client application can directly call stub functions that invoke the remote functions of the server application.</p>&#13;
&#13;
<p>Let’s look at the <code>ProductInfo</code> service that we discussed in <a data-type="xref" href="ch02.html#ch_02">Chapter 2</a> to understand how a remote procedure call works over the network. One of the functions that we implemented as part of our <code>ProductInfo</code> service is  <code>getProduct</code>, where the client can retrieve product details by providing the product ID. <a data-type="xref" href="#how_remote_procedure_call_works_over_the_network">Figure 4-1</a> illustrates the actions involved when the client calls a remote function.</p>&#13;
&#13;
<figure><div class="figure" id="how_remote_procedure_call_works_over_the_network">&#13;
<img alt="How remote procedure call works over the network" src="assets/grpc_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>How a remote procedure call works over the network</h6>&#13;
</div></figure>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#how_remote_procedure_call_works_over_the_network">Figure 4-1</a>, we can identify the following key steps when the client calls the <code>getProduct</code> function in the generated stub:</p>&#13;
<dl class="calloutlist">&#13;
<dt><img alt="1" src="assets/1.png"/></dt>&#13;
<dd><p>The client process calls the <code>getProduct</code> function in the generated stub.</p></dd>&#13;
<dt><img alt="2" src="assets/2.png"/></dt>&#13;
<dd><p>The client stub creates an HTTP POST request with the encoded message. In gRPC, all requests are HTTP POST requests with content-type prefixed with <code>application/grpc</code>. The remote function (<code>/ProductInfo/getProduct</code>) that it invokes is sent as a separate HTTP header.</p></dd>&#13;
<dt><img alt="3" src="assets/3.png"/></dt>&#13;
<dd><p>The HTTP request message is sent across the network to the server machine.</p></dd>&#13;
<dt><img alt="4" src="assets/4.png"/></dt>&#13;
<dd><p>When the message is received at the server, the server examines the message headers to see which service function needs to be called and hands over the message to the service stub.</p></dd>&#13;
<dt><img alt="5" src="assets/5.png"/></dt>&#13;
<dd><p>The service stub parses the message bytes into language-specific data structures.</p></dd>&#13;
<dt><img alt="6" src="assets/6.png"/></dt>&#13;
<dd><p>Then, using the parsed message, the service makes a local call to the <code>getProduct</code> function.</p></dd>&#13;
<dt><img alt="7" src="assets/7.png"/></dt>&#13;
<dd><p>The response from the service function is encoded and sent back to the client. The response message follows the same procedure that we observed on the client side (response→encode→HTTP response on the wire); the message is unpacked and its value returned to the waiting client process.</p></dd>&#13;
</dl>&#13;
&#13;
<p>These steps are quite similar to most RPC systems like CORBA, Java RMI, etc. The main difference between gRPC here is the way that it encodes the message, which we saw in <a data-type="xref" href="#how_remote_procedure_call_works_over_the_network">Figure 4-1</a>. <a data-primary="protocol buffers" data-secondary="defined" data-type="indexterm" id="idm46536641959960"/>For encoding messages, gRPC uses protocol buffers. <a href="https://oreil.ly/u9YJI">Protocol buffers</a> are a language-agnostic, platform-neutral, extensible mechanism for serializing structured data. You define how you want your data to be structured once, then you can use the specially generated source code to easily write and read your structured data to and from a variety of data streams.<a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm46536641957896"/></p>&#13;
&#13;
<p>Let’s dive into how gRPC uses protocol buffers to encode messages.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Message Encoding Using Protocol Buffers" data-type="sect1"><div class="sect1" id="idm46536641956680">&#13;
<h1>Message Encoding Using Protocol Buffers</h1>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="using protocol buffers" data-type="indexterm" id="ix_ch04-asciidoc1"/><a data-primary="message" data-secondary="encoding using protocol buffers" data-type="indexterm" id="ix_ch04-asciidoc2"/><a data-primary="protocol buffers" data-secondary="message encoding with" data-type="indexterm" id="ix_ch04-asciidoc3"/>As we discussed in previous chapters, gRPC uses protocol buffers to write the service definition for gRPC services. Defining the service using protocol buffers includes defining remote methods in the service and defining messages we want to send across the network. For example, let’s take the <code>getProduct</code> method in the <code>ProductInfo</code> service. The <code>getProduct</code> method accepts a <code>ProductID</code> message as an input parameter and returns a <code>Product</code> message. We can define those input and output message structures using protocol buffers as shown in <a data-type="xref" href="#EX4-1">Example 4-1</a>.</p>&#13;
<div data-type="example" id="EX4-1">&#13;
<h5><span class="label">Example 4-1. </span>Service definition of ProductInfo service with getProduct function</h5>&#13;
&#13;
<pre data-code-language="proto" data-type="programlisting"><code class="na">syntax</code> <code class="o">=</code> <code class="s">"proto3"</code><code class="p">;</code>&#13;
&#13;
<code class="kn">package</code> <code class="nn">ecommerce</code><code class="p">;</code>&#13;
&#13;
<code class="kd">service</code> <code class="n">ProductInfo</code> <code class="p">{</code>&#13;
   <code class="k">rpc</code> <code class="n">getProduct</code><code class="p">(</code><code class="n">ProductID</code><code class="p">)</code> <code class="k">returns</code> <code class="p">(</code><code class="n">Product</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">message</code> <code class="nc">Product</code> <code class="p">{</code>&#13;
   <code class="kt">string</code> <code class="na">id</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
   <code class="kt">string</code> <code class="na">name</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
   <code class="kt">string</code> <code class="na">description</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>&#13;
   <code class="kt">float</code> <code class="na">price</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">message</code> <code class="nc">ProductID</code> <code class="p">{</code>&#13;
    <code class="kt">string</code> <code class="na">value</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>As per <a data-type="xref" href="#EX4-1">Example 4-1</a>, the <code>ProductID</code> message carries a unique product ID. So it has only one field with a string type. The <code>Product</code> message has the structure required to represent the product. It is important to have a message defined correctly, because how you define the message determines how the messages get encoded. We will discuss how message definitions are used when encoding messages later in this section.</p>&#13;
&#13;
<p>Now that we have the message definition, let’s look at how to encode the message and generate the equivalent byte content. Normally this is handled by the generated source code for the message definition. All the supported languages have their own compilers to generate source code. As an application developer, you need to pass the message definition and generate source code to read and write the message.</p>&#13;
&#13;
<p>Let’s say we need to get product details for product ID <code>15</code>; we create a message object with value equal to 15 and pass it to the <code>getProduct</code> function. The following code snippet shows how to create a <code>ProductID</code> message with value equal to <code>15</code> and pass it to the <code>getProduct</code> function to retrieve product details:</p>&#13;
<pre>product, err := c.GetProduct(ctx, &amp;pb.ProductID{Value: “15”})</pre>&#13;
&#13;
<p>This code snippet is written in Go. Here, the <code>ProductID</code> message definition is in the generated source code. We create an instance of <code>ProductID</code> and set the value as <code>15</code>. Similarly in the Java language, we use generated methods to create a <code>ProductID</code> instance as shown in the following code snippet:</p>&#13;
<pre>ProductInfoOuterClass.Product product = stub.getProduct(&#13;
       ProductInfoOuterClass.ProductID.newBuilder()&#13;
               .setValue("15").build());</pre>&#13;
&#13;
<p>In the <code>ProductID</code> message structure that follows, there is one field called <code>value</code> with the field index 1. When we create a message instance with <code>value</code> equal to <code>15</code>, the equivalent byte content consists of a field identifier for the <code>value</code> field followed by its encoded value. This field identifier is also known as a <em>tag</em>:</p>&#13;
&#13;
<pre data-code-language="proto" data-type="programlisting"><code class="kd">message</code> <code class="nc">ProductID</code> <code class="p">{</code>&#13;
    <code class="kt">string</code> <code class="na">value</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This byte content structure looks like <a data-type="xref" href="#protocol_buffer_encoded_byte_stream">Figure 4-2</a>, where each message field consists of a field identifier followed by its encoded value.</p>&#13;
&#13;
<figure><div class="figure" id="protocol_buffer_encoded_byte_stream">&#13;
<img alt="Protocol buffer encoded byte stream" src="assets/grpc_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Protocol buffer encoded byte stream</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="field index" data-type="indexterm" id="idm46536641907544"/>This tag builds up two values: the field index and the wire type. The field index is the unique number we assigned to each message field when defining the message in the proto file. <a data-primary="wire type" data-type="indexterm" id="idm46536641906520"/>The wire type is based on the field type, which is the type of data that can enter the field. This wire type provides information to find the length of the value. <a data-type="xref" href="#available_wire_types_and_corresponding_field_types">Table 4-1</a> shows how wire types are mapped to field types. This is the predefined mapping of wire types and field types. You can refer to the <a href="https://oreil.ly/xeLBr">official protocol buffers encoding document</a> to get more insight into the mapping.</p>&#13;
<table id="available_wire_types_and_corresponding_field_types" style="width: 75%">&#13;
<caption><span class="label">Table 4-1. </span>Available wire types and corresponding field types</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Wire type</th>&#13;
<th>Category</th>&#13;
<th>Field types</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>Varint</p></td>&#13;
<td><p>int32, int64, uint32, uint64, sint32, sint64, bool, enum</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1</p></td>&#13;
<td><p>64-bit</p></td>&#13;
<td><p>fixed64, sfixed64, double</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>2</p></td>&#13;
<td><p>Length-delimited</p></td>&#13;
<td><p>string, bytes, embedded messages, packed repeated fields</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>3</p></td>&#13;
<td><p>Start group</p></td>&#13;
<td><p>groups (deprecated)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>4</p></td>&#13;
<td><p>End group</p></td>&#13;
<td><p>groups (deprecated)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>5</p></td>&#13;
<td><p>32-bit</p></td>&#13;
<td><p>fixed32, sfixed32, float</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Once we know the field index and wire type of a certain field, we can determine the tag value of the field using the following equation. Here we left shift the binary representation of the field index by three digits and perform a bitwise union with the binary representation of the wire type value:</p>&#13;
<pre>Tag value = (field_index &lt;&lt; 3) | wire_type</pre>&#13;
&#13;
<p><a data-type="xref" href="#structure_of_the_tag_value">Figure 4-3</a> shows how field index and wire type are arranged in a tag value.</p>&#13;
&#13;
<figure><div class="figure" id="structure_of_the_tag_value">&#13;
<img alt="Structure of the tag value" src="assets/grpc_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>Structure of the tag value</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s try to understand this terminology using the example that we used earlier. The <code>ProductID</code> message has one string field with field index equal to 1 and the wire type of string is 2. When we convert them to binary representation, the field index looks like 00000001 and the wire type looks like 00000010. When we put those values into the preceding  equation, the tag value 10 is derived as follows:</p>&#13;
<pre>Tag value = (00000001 &lt;&lt; 3) | 00000010&#13;
          = 000 1010</pre>&#13;
&#13;
<p>The next step is to encode the value of the message field. Different encoding techniques are used by protocol buffers to encode the different types of data. For example, if it is a string value, the protocol buffer uses UTF-8 to encode the value and if it is an integer value with the int32 field type, it uses an encoding technique called varints. We will discuss different encoding techniques and when those techniques are applied in the next section in detail. For now, we will discuss how to encode a string value to complete the example.</p>&#13;
&#13;
<p>In protocol buffers encoding, string values are encoded using UTF-8 encoding technique. <a data-primary="UTF (Unicode Transformation Format)" data-type="indexterm" id="idm46536641487064"/>UTF (Unicode Transformation Format) uses 8-bit blocks to represent a character. It is a variable-length character encoding technique that is also a preferred encoding technique in web pages and emails.</p>&#13;
&#13;
<p>In our example, the value of the <code>value</code> field in the <code>ProductID</code> message is 15 and the UTF-8 encoded value of <code>15</code> is <code>\x31 \x35</code>. In UTF-8 encoding, the encoded value length is not fixed. In other words, the number of 8-bit blocks required to represent the encoded value is not fixed. It varies based upon the value of the message field. In our example, it is two blocks. So we need to pass the encoded value length (number of blocks the encoded value spans) before the encoded value. The hexadecimal representation of the encoded value of <code>15</code> will look like this:</p>&#13;
<pre>A 02 31 35</pre>&#13;
&#13;
<p>The two righthand bytes here are the UTF-8 encoded value of <code>15</code>. Value 0x02 represents the length of the encoded string value in 8-bit blocks.</p>&#13;
&#13;
<p>When a message is encoded, its tags and values are concatenated into a byte stream. <a data-type="xref" href="#protocol_buffer_encoded_byte_stream">Figure 4-2</a> illustrates how field values are arranged into a byte stream when a message has multiple fields. The end of the stream is marked by sending a tag valued 0.</p>&#13;
&#13;
<p>We have now completed encoding a simple message with a string field using protocol buffers. The protocol buffers support various field types and some field types have different encoding mechanisms. Let’s quickly go through the encoding techniques used by protocol buffers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encoding Techniques" data-type="sect2"><div class="sect2" id="idm46536641480024">&#13;
<h2>Encoding Techniques</h2>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="techniques for" data-type="indexterm" id="ix_ch04-asciidoc4"/><a data-primary="protocol buffers" data-secondary="encoding techniques" data-type="indexterm" id="ix_ch04-asciidoc5"/>There are many encoding techniques supported by protocol buffers. Different encoding techniques are applied based on the type of data. For example, string values are encoded using UTF-8 character encoding, whereas int32 values are encoded using a technique called varints. Having knowledge about how data is encoded in each data type is important when designing the message definition because it allows us to set the most appropriate data type for each message field so that the messages are efficiently encoded at runtime.</p>&#13;
&#13;
<p>In protocol buffers, supported field types are categorized into different groups and each group uses a different technique to encode the value. Listed in the next section are a few commonly used encoding techniques in protocol buffers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Varints" data-type="sect3"><div class="sect3" id="idm46536641475160">&#13;
<h3>Varints</h3>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="varints for" data-type="indexterm" id="idm46536641474152"/><a data-primary="varints (variable length integers)" data-type="indexterm" id="idm46536641473304"/>Varints (variable length integers) are a method of serializing integers using one or more bytes. They’re based on the idea that most numbers are not uniformly distributed. So the number of bytes allocated for each value is not fixed. It depends on the value. As per <a data-type="xref" href="#available_wire_types_and_corresponding_field_types">Table 4-1</a>, field types like int32, int64, uint32, uint64, sint32, sint64, bool, and enum are grouped into varints and encoded as varints. <a data-type="xref" href="#fieldtypes_varints">Table 4-2</a> shows what field types are categorized under varints, and what each type is used for.</p>&#13;
<table id="fieldtypes_varints">&#13;
<caption><span class="label">Table 4-2. </span>Field type definitions</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Field type</th>&#13;
<th>Definition</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>int32</code></p></td>&#13;
<td><p>A value type that represents signed integers with values that range from negative 2,147,483,648 to positive 2,147,483,647. Note this type is inefficient for encoding negative numbers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>int64</code></p></td>&#13;
<td><p>A value type that represents signed integers with values that range from negative 9,223,372,036,854,775,808 to positive 9,223,372,036,854,775,807. Note this type is inefficient for encoding negative numbers.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>uint32</code></p></td>&#13;
<td><p>A value type that represents unsigned integers with values that range from 0 to 4,294,967,295.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>uint64</code></p></td>&#13;
<td><p>A value type that represents unsigned integers with values that range from 0 to 18,446,744,073,709,551,615.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>sint32</code></p></td>&#13;
<td><p>A value type that represents signed integers with values that range from negative 2,147,483,648 to positive 2,147,483,647. This more efficiently encodes negative numbers than regular int32s.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>sint64</code></p></td>&#13;
<td><p>A value type that represents signed integers with values that range from negative 9,223,372,036,854,775,808 to positive 9,223,372,036,854,775,807. This more efficiently encodes negative numbers than regular int64s.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>bool</code></p></td>&#13;
<td><p>A value type that represents two possible values, normally denoted as true or false.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>enum</code></p></td>&#13;
<td><p>A value type that represents a set of named values.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In varints, each byte except the last byte has the most significant bit (MSB) set to indicate that there are further bytes to come. The lower 7 bits of each byte are used to store the two’s complement representation of the number. Also, the least significant group comes first, which means that we should add a continuation bit to the low-order group.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Signed integers" data-type="sect3"><div class="sect3" id="idm46536641453256">&#13;
<h3>Signed integers</h3>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="signed integers" data-type="indexterm" id="idm46536641452008"/><a data-primary="signed integers" data-type="indexterm" id="idm46536641451160"/>Signed integers are types that represent both positive and negative integer values. Field types like sint32 and sint64 are considered signed integers. <a data-primary="zigzag encoding" data-type="indexterm" id="idm46536641450264"/>For signed types, zigzag encoding is used to convert signed integers to unsigned ones. Then unsigned integers are encoded using varints encoding as mentioned previously.</p>&#13;
&#13;
<p>In zigzag encoding, signed integers are mapped to unsigned integers in a zigzag way through negative and positive integers. <a data-type="xref" href="#the_zig_zag_encoding_used_in_signed_integers">Table 4-3</a> shows how mapping works in zigzag encoding.</p>&#13;
<table id="the_zig_zag_encoding_used_in_signed_integers" style="width: 75%">&#13;
<caption><span class="label">Table 4-3. </span>The zigzag encoding used in signed integers</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Original value</th>&#13;
<th>Mapped value</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-1</p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1</p></td>&#13;
<td><p>2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>-2</p></td>&#13;
<td><p>3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>2</p></td>&#13;
<td><p>4</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#the_zig_zag_encoding_used_in_signed_integers">Table 4-3</a>, value zero is mapped to the original value of zero and other values are mapped to positive numbers in a zigzag way. The negative original values are mapped to odd positive numbers and positive original values are mapped to even positive numbers. After zigzag encoding, we get a positive number irrespective of the sign of the original value. Once we have a positive number, we perform varints to encode the value.</p>&#13;
&#13;
<p>For negative integer values, it is recommended to use signed integer types like sint32 and sint64 because if we use a regular type such as int32 or int64, negative values are converted to binary using varints encoding. Varints encoding for a negative integer value needs more bytes to represent an equivalent binary value than a positive integer value. So the efficient way of encoding negative value is to convert the negative value to a positive number and then encode the positive value. In signed integer types like sint32, the negative values are first converted to positive values using zigzag encoding and then encoded using varints.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nonvarint numbers" data-type="sect3"><div class="sect3" id="idm46536641435048">&#13;
<h3>Nonvarint numbers</h3>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="nonvarint numbers" data-type="indexterm" id="idm46536641434040"/><a data-primary="nonvarint numbers" data-type="indexterm" id="idm46536641433192"/>Nonvarint types are just the opposite of the varint type. They allocate a fixed number of bytes irrespective of the actual value. Protocol buffers use two wire types that categorize as nonvarint numbers. One is for the 64-bit data types like fixed64, sfixed64, and double. The other is for 32-bit data types like fixed32, sfixed32, and float.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="String type" data-type="sect3"><div class="sect3" id="idm46536641431848">&#13;
<h3>String type</h3>&#13;
&#13;
<p><a data-primary="encoding" data-secondary="string type" data-type="indexterm" id="idm46536641430840"/><a data-primary="string type" data-type="indexterm" id="idm46536641429992"/>In protocol buffers, the string type belongs to the length-delimited wire type, which means that the value is a varint-encoded length followed by the specified number of bytes of data. String values are encoded using UTF-8 character encoding.</p>&#13;
&#13;
<p>We just summarized the techniques used to encode commonly used data types. You can find a detailed explanation about protocol buffer encoding on <a href="https://oreil.ly/hH_gL">the official page</a>.</p>&#13;
&#13;
<p>Now that we have encoded the message using protocol buffers, the next step is to frame the message before sending it to the server over the network<a data-startref="ix_ch04-asciidoc5" data-type="indexterm" id="idm46536641427288"/><a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm46536641426680"/>.<a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm46536641425944"/><a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm46536641425336"/><a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm46536641424728"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Length-Prefixed Message Framing" data-type="sect1"><div class="sect1" id="idm46536641955736">&#13;
<h1>Length-Prefixed Message Framing</h1>&#13;
&#13;
<p><a data-primary="length-prefixed message framing" data-type="indexterm" id="ix_ch04-asciidoc6"/><a data-primary="message framing, length-prefixed" data-type="indexterm" id="ix_ch04-asciidoc7"/>In common terms, the message-framing approach constructs information and communication so that the intended audience can easily extract the information. The same thing applies to gRPC communication as well. Once we have the encoded data to send to the other party, we need to package the data in a way that other parties can easily extract the information. In order to package the message to send over the network, gRPC uses a message-framing technique called length-prefix framing.</p>&#13;
&#13;
<p>Length-prefix is a message-framing approach that writes the size of each message before writing the message itself. As you can see in <a data-type="xref" href="#how_grpc_message_framed_using_length_prefix_framing">Figure 4-4</a>, before the encoded binary message there are 4 bytes allocated to specify the size of the message. In gRPC communication, 4 additional bytes are allocated for each message to set its size. The size of the message is a finite number, and allocating 4 bytes to represent the message size means gRPC communication can handle all messages up to 4 GB in size.</p>&#13;
&#13;
<figure><div class="figure" id="how_grpc_message_framed_using_length_prefix_framing">&#13;
<img alt="How a gRPC message is encoded and framed" src="assets/grpc_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>How a gRPC message frame uses length-prefix framing</h6>&#13;
</div></figure>&#13;
&#13;
<p>As illustrated in <a data-type="xref" href="#how_grpc_message_framed_using_length_prefix_framing">Figure 4-4</a>, when the message is encoded using protocol buffers, we get the message in binary format. Then we calculate the size of the binary content and add it before the binary content in big-endian format.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="big-endian format" data-type="indexterm" id="idm46536641415320"/>Big-endian is a way of ordering binary data in the system or message. In big-endian format, the most significant value (the largest powers of two) in the sequence is stored at the lowest storage address.</p>&#13;
</div>&#13;
&#13;
<p><a data-primary="compression" data-type="indexterm" id="idm46536641413976"/>In addition to the message size, the frame also has a 1-byte unsigned integer to indicate whether the data is compressed or not. A Compressed-Flag value of 1 indicates that the binary data is compressed using the mechanism declared in the Message-Encoding header, which is one of the headers declared in HTTP transport. The value 0 indicates that no encoding of message bytes has occurred. We will discuss HTTP headers supported in gRPC communication in detail in the next section.</p>&#13;
&#13;
<p>So now the message is framed and it’s ready to be sent over the network to the recipient. For a client request message, the recipient is the server. For a response message, the recipient is the client. On the recipient side, once a message is received, it first needs to read the first byte to check whether the message is compressed or not. Then the recipient reads the next four bytes to get the size of the encoded binary message. Once the size is known, the exact length of bytes can be read from the stream. For unary/simple messages, we will have only one length-prefixed message, and for streaming messages, we will have multiple length-prefixed messages to process.</p>&#13;
&#13;
<p>Now you have a good understanding of how messages are prepared to deliver to the recipient over the network. In the next section, we are going to discuss how gRPC sends those length-prefixed messages over the network. Currently, the gRPC core supports three transport implementations: HTTP/2, <a href="https://oreil.ly/D0laq">Cronet</a>, and <a href="https://oreil.ly/lRgXF">in-process</a>. Among them, the most common transport for sending messages is HTTP/2. Let’s discuss how gRPC utilizes the HTTP/2 network to send messages efficiently.<a data-startref="ix_ch04-asciidoc7" data-type="indexterm" id="idm46536641409560"/><a data-startref="ix_ch04-asciidoc6" data-type="indexterm" id="idm46536641408952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="gRPC over HTTP/2" data-type="sect1"><div class="sect1" id="idm46536641408216">&#13;
<h1>gRPC over HTTP/2</h1>&#13;
&#13;
<p><a data-primary="HTTP/2" data-type="indexterm" id="ix_ch04-asciidoc8"/>HTTP/2 is the second major version of the internet protocol HTTP. It was introduced to overcome some of the issues encountered with security, speed, etc. in the previous version (HTTP/1.1). HTTP/2 supports all of the core features of HTTP/1.1 but in a more efficient way. So applications written in HTTP/2 are faster, simpler, and more robust.</p>&#13;
&#13;
<p>gRPC uses HTTP/2 as its transport protocol to send messages over the network. This is one of the reasons why gRPC is a high-performance RPC framework. Let’s explore the relationship between gRPC and HTTP/2.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In HTTP/2, all communication between a client and server is performed over a single TCP connection that can carry any number of bidirectional flows of bytes. To understand the HTTP/2 process, you should be familiar with the following important terminology:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Stream:</em> <a data-primary="stream" data-secondary="in HTTP/2" data-type="indexterm" id="idm46536641402536"/>A bidirectional flow of bytes within an established connection. A stream may carry one or more messages.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Frame:</em> <a data-primary="frame (HTTP/2)" data-type="indexterm" id="idm46536641400408"/>The smallest unit of communication in HTTP/2. Each frame contains a frame header, which at a minimum identifies the stream to which the frame belongs.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Message:</em> <a data-primary="message" data-secondary="in HTTP/2" data-type="indexterm" id="idm46536641398488"/>A complete sequence of frames that map to a logical HTTP message that consists of one or more frames. This allows the messages to be multiplexed, by allowing the client and server to break down the message into independent frames, interleave them, and then reassemble them on the other side.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>As you can see in <a data-type="xref" href="#how_grpc_semantics_relates_to_http2">Figure 4-5</a>, the gRPC channel represents a connection to an endpoint, which is an HTTP/2 connection. When the client application creates a gRPC channel, behind the scenes it creates an HTTP/2 connection with the server. Once the channel is created we can reuse it to send multiple remote calls to the server. These remote calls are mapped to streams in HTTP/2. Messages that are sent in the remote call are sent as HTTP/2 frames. A frame may carry one gRPC length-prefixed message, or if a gRPC message is quite large it might span multiple data frames.</p>&#13;
&#13;
<figure><div class="figure" id="how_grpc_semantics_relates_to_http2">&#13;
<img alt="How gRPC semantics relate to HTTP/2" src="assets/grpc_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>How gRPC semantics relate to HTTP/2</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the previous section, we discussed how to frame our message to a length-prefixed message. When we send them over the network as a request or response message, we need to send additional headers along with the message. Let’s discuss how to structure request/response messages and which headers need to pass for each message in the next sections.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Request Message" data-type="sect2"><div class="sect2" id="idm46536641392520">&#13;
<h2>Request Message</h2>&#13;
&#13;
<p><a data-primary="HTTP/2" data-secondary="request message" data-type="indexterm" id="ix_ch04-asciidoc9"/><a data-primary="request message, HTTP/2" data-type="indexterm" id="ix_ch04-asciidoc10"/>The request message is the one that initiates the remote call. In gRPC, the request message is always triggered by the client application and it consists of three main components: request headers, the length-prefixed message, and the end of stream flag as shown in <a data-type="xref" href="#sequence_of_message_elements_in_request_message1">Figure 4-6</a>. The remote call is initiated once the client sends request headers. Then, length-prefixed messages are sent in the call. Finally, the EOS (end of stream) flag is sent to notify the recipient that we finished sending the request <span class="keep-together">message.</span></p>&#13;
&#13;
<figure><div class="figure" id="sequence_of_message_elements_in_request_message1">&#13;
<img alt="Sequence of message elements in request message" src="assets/grpc_0406.png"/>&#13;
<h6><span class="label">Figure 4-6. </span>Sequence of message elements in request message</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s use the same <code>getProduct</code> function in the <code>ProductInfo</code> service to explain how the request message is sent in HTTP/2 frames. When we call the <code>getProduct</code> function, the client initiates a call by sending <a data-primary="request headers" data-type="indexterm" id="idm46536641383976"/>request headers as shown here:</p>&#13;
<pre>HEADERS (flags = END_HEADERS)&#13;
:method = POST <a class="co" href="#callout_grpc__under_the_hood_CO1-1" id="co_grpc__under_the_hood_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
:scheme = http <a class="co" href="#callout_grpc__under_the_hood_CO1-2" id="co_grpc__under_the_hood_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
:path = /ProductInfo/getProduct <a class="co" href="#callout_grpc__under_the_hood_CO1-3" id="co_grpc__under_the_hood_CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
:authority = abc.com <a class="co" href="#callout_grpc__under_the_hood_CO1-4" id="co_grpc__under_the_hood_CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
te = trailers <a class="co" href="#callout_grpc__under_the_hood_CO1-5" id="co_grpc__under_the_hood_CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
grpc-timeout = 1S <a class="co" href="#callout_grpc__under_the_hood_CO1-6" id="co_grpc__under_the_hood_CO1-6"><img alt="6" src="assets/6.png"/></a>&#13;
content-type = application/grpc <a class="co" href="#callout_grpc__under_the_hood_CO1-7" id="co_grpc__under_the_hood_CO1-7"><img alt="7" src="assets/7.png"/></a>&#13;
grpc-encoding = gzip <a class="co" href="#callout_grpc__under_the_hood_CO1-8" id="co_grpc__under_the_hood_CO1-8"><img alt="8" src="assets/8.png"/></a>&#13;
authorization = Bearer xxxxxx <a class="co" href="#callout_grpc__under_the_hood_CO1-9" id="co_grpc__under_the_hood_CO1-9"><img alt="9" src="assets/9.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-1" id="callout_grpc__under_the_hood_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Defines the HTTP method. For gRPC, the <code>:method</code> header is always <code>POST</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-2" id="callout_grpc__under_the_hood_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Defines the HTTP scheme. If TLS (Transport Level Security) is enabled, the scheme is set to “https,” otherwise it is “http.”</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-3" id="callout_grpc__under_the_hood_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Defines the endpoint path. For gRPC, this value is constructed as “/” {service name} “/” {method name}.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-4" id="callout_grpc__under_the_hood_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Defines the virtual hostname of the target URI.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-5" id="callout_grpc__under_the_hood_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Defines detection of incompatible proxies. For gRPC, the value must be “trailers.”</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-6" id="callout_grpc__under_the_hood_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Defines call timeout. If not specified, the server should assume an infinite <span class="keep-together">timeout.</span></p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-7" id="callout_grpc__under_the_hood_CO1-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Defines the content-type. For gRPC, the content-type should begin with <code>application/grpc</code>. If not, gRPC servers will respond with an HTTP status of 415 (Unsupported Media Type).</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-8" id="callout_grpc__under_the_hood_CO1-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Defines the message compression type. Possible values are <code>identity</code>, <code>gzip</code>, <code>deflate</code>, <code>snappy</code>, and <code>{custom}</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO1-9" id="callout_grpc__under_the_hood_CO1-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>This is optional metadata. <code>authorization</code> metadata is used to access the secure endpoint.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Some other notes on this example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="reserved headers" data-type="indexterm" id="idm46536641341848"/>Header names starting with “:” are called reserved headers and HTTP/2 requires reserved headers to appear before other headers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Headers passed in gRPC communication are categorized into two types: call-definition headers and custom metadata.</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="call definition headers" data-type="indexterm" id="idm46536641339432"/>Call-definition headers are predefined headers supported by HTTP/2. Those headers should be sent before custom metadata.</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-primary="Custom metadata" data-type="indexterm" id="idm46536641337912"/>Custom metadata is an arbitrary set of key-value pairs defined by the application layer. When you are defining custom metadata, you need to make sure not to use a header name starting with <code>grpc-</code>. This is listed as a reserved name in the gRPC core.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>Once the client initiates the call with the server, the client sends length-prefixed messages as HTTP/2 data frames. If the length-prefixed message doesn’t fit one data frame, it can span to multiple data frames. The end of the request message is indicated by adding an <code>END_STREAM</code> flag on the last <code>DATA</code> frame. When no data remains to be sent but we need to close the request stream, the implementation must send an empty data frame with the <code>END_STREAM</code> flag:</p>&#13;
<pre>DATA (flags = END_STREAM)&#13;
&lt;Length-Prefixed Message&gt;</pre>&#13;
&#13;
<p>This is just an overview of the structure of the gRPC request message. You can find more details in <a href="https://oreil.ly/VIhYs">the official gRPC GitHub repository</a>.</p>&#13;
&#13;
<p>Similar to the request message, the response message also has its own structure. Let’s look at the structure of response messages and the related headers.<a data-startref="ix_ch04-asciidoc10" data-type="indexterm" id="idm46536641332152"/><a data-startref="ix_ch04-asciidoc9" data-type="indexterm" id="idm46536641331544"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Response Message" data-type="sect2"><div class="sect2" id="idm46536641392024">&#13;
<h2>Response Message</h2>&#13;
&#13;
<p><a data-primary="HTTP/2" data-secondary="response message" data-type="indexterm" id="ix_ch04-asciidoc11"/><a data-primary="response message" data-type="indexterm" id="ix_ch04-asciidoc12"/>The response message is generated by the server in response to the client’s request. Similar to the request message, in most cases the response message also consists of three main components: response headers, length-prefixed messages, and trailers. When there is no length-prefixed message to send as a response to the client, the response message consists only of headers and trailers as shown in <a data-type="xref" href="#sequence_of_message_elements_in_request_message">Figure 4-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="sequence_of_message_elements_in_request_message">&#13;
<img alt="Sequence of message elements in a response message" src="assets/grpc_0407.png"/>&#13;
<h6><span class="label">Figure 4-7. </span>Sequence of message elements in a response message</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s look at the same example to explain the HTTP/2 framing sequence of the response message. <a data-primary="response headers" data-type="indexterm" id="idm46536641324040"/>When the server sends a response to the client, it first sends response headers as shown here:</p>&#13;
<pre>HEADERS (flags = END_HEADERS)&#13;
:status = 200 <a class="co" href="#callout_grpc__under_the_hood_CO2-1" id="co_grpc__under_the_hood_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
grpc-encoding = gzip <a class="co" href="#callout_grpc__under_the_hood_CO2-2" id="co_grpc__under_the_hood_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
content-type = application/grpc <a class="co" href="#callout_grpc__under_the_hood_CO2-3" id="co_grpc__under_the_hood_CO2-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO2-1" id="callout_grpc__under_the_hood_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Indicates the status of the HTTP request.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO2-2" id="callout_grpc__under_the_hood_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Defines the message compression type. Possible values include <code>identity</code>, <code>gzip</code>, <code>deflate</code>, <code>snappy</code>, and <code>{custom}</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO2-3" id="callout_grpc__under_the_hood_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Defines the <code>content-type</code>. For gRPC, the <code>content-type</code> should begin with <code>application/grpc</code>.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Similar to the request headers, custom metadata that contains an arbitrary set of key-value pairs defined by the application layer can be set in the response headers.</p>&#13;
</div>&#13;
&#13;
<p>Once the server sends response headers, length-prefixed messages are sent as HTTP/2 data frames in the call. Similar to the request message, if the length-prefixed message doesn’t fit one data frame, it can span to multiple data frames. As shown in the following, the <code>END_STREAM</code> flag isn’t sent with data frames. It is sent as a separate header called a trailer:</p>&#13;
<pre>DATA&#13;
&lt;Length-Prefixed Message&gt;</pre>&#13;
&#13;
<p><a data-primary="trailers" data-type="indexterm" id="idm46536641303656"/>In the end, trailers are sent to notify the client that we finished sending the response message. Trailers also carry the status code and status message of the request:</p>&#13;
&#13;
<pre data-type="programlisting">HEADERS (flags = END_STREAM, END_HEADERS)&#13;
grpc-status = 0 # OK <a class="co" href="#callout_grpc__under_the_hood_CO3-1" id="co_grpc__under_the_hood_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
grpc-message = xxxxxx <a class="co" href="#callout_grpc__under_the_hood_CO3-2" id="co_grpc__under_the_hood_CO3-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO3-1" id="callout_grpc__under_the_hood_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Defines the gRPC status code. gRPC uses a set of well-defined status codes. You can find the definition of status codes in the <a href="https://oreil.ly/3MH72">official gRPC documentation</a>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc__under_the_hood_CO3-2" id="callout_grpc__under_the_hood_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Defines the description of the error. This is optional. This is only set when there is an error in processing the request.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Trailers are also delivered as HTTP/2 header frames but at the end of the response message. The end of the response stream is indicated by setting the <code>END_STREAM</code> flag in trailer headers. Additionally, it contains the <code>grpc-status</code> and <code>grpc-message</code> headers.</p>&#13;
</div>&#13;
&#13;
<p>In certain scenarios, there can be an immediate failure in the request call. In those cases, the server needs to send a response back without the data frames. So the server sends only trailers as a response. Those trailers are also delivered as an HTTP/2 header frame and also contain the <code>END_STREAM</code> flag. Additionally, the following headers are included in trailers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>HTTP-Status → <code>:status</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Content-Type → <code>content-type</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Status → <code>grpc-status</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Status-Message → <code>grpc-message</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now that we know how a gRPC message flows over an HTTP/2 connection, let’s try to understand the message flow of different communication patterns in gRPC<a data-startref="ix_ch04-asciidoc12" data-type="indexterm" id="idm46536641282056"/>.<a data-startref="ix_ch04-asciidoc11" data-type="indexterm" id="idm46536641281224"/><a data-startref="ix_ch04-asciidoc8" data-type="indexterm" id="idm46536641280520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding the Message Flow in gRPC Communication Patterns" data-type="sect2"><div class="sect2" id="idm46536641330344">&#13;
<h2>Understanding the Message Flow in gRPC Communication Patterns</h2>&#13;
&#13;
<p><a data-primary="communication patterns" data-secondary="message flow in" data-type="indexterm" id="ix_ch04-asciidoc13"/><a data-primary="message flow" data-secondary="in gRPC communication patterns" data-type="indexterm" id="ix_ch04-asciidoc14"/>In the previous chapter, we discussed four communication patterns supported by gRPC. They are simple RPC, server-streaming RPC, client-streaming RPC, and bidirectional-streaming RPC. We also discussed how those communication patterns work using real-world use cases. In this section, we are going to look at those patterns again from a different angle. Let’s discuss how each pattern works at the transport level with the knowledge we collected in this chapter.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple RPC" data-type="sect3"><div class="sect3" id="idm46536641275320">&#13;
<h3>Simple RPC</h3>&#13;
&#13;
<p><a data-primary="message flow" data-secondary="simple RPC" data-type="indexterm" id="idm46536641274152"/><a data-primary="RPC (remote procedure call)" data-secondary="simple" data-type="indexterm" id="idm46536641273176"/><a data-primary="simple RPC" data-type="indexterm" id="idm46536641272216"/>In simple RPC you always have a single request and a single response in the communication between the gRPC server and gRPC client. As shown in <a data-type="xref" href="#simple_rpc_message_flow">Figure 4-8</a>, the request message contains headers followed by a length-prefixed message, which can span one or more data frames. An end of stream (EOS) flag is added at the end of the message to half-close the connection at the client side and mark the end of the request message. <a data-primary="half closing, defined" data-type="indexterm" id="idm46536641270152"/>Here “half-close the connection” means the client closes the connection on its side so the client is no longer able to send messages to the server but still can listen to the incoming messages from the server. The server creates the response message only after receiving the complete message on the server side. The response message contains a header frame followed by a length-prefixed message. Communication ends once the server sends the trailing header with status details.</p>&#13;
&#13;
<figure><div class="figure" id="simple_rpc_message_flow">&#13;
<img alt="Simple RPC: message flow" src="assets/grpc_0408.png"/>&#13;
<h6><span class="label">Figure 4-8. </span>Simple RPC: message flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is the simplest communication pattern. Let’s move on to a bit more complex server-streaming RPC scenario.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Server-streaming RPC" data-type="sect3"><div class="sect3" id="idm46536641266104">&#13;
<h3>Server-streaming RPC</h3>&#13;
&#13;
<p><a data-primary="message flow" data-secondary="server-streaming RPC" data-type="indexterm" id="idm46536641264904"/><a data-primary="RPC (remote procedure call)" data-secondary="server-streaming" data-type="indexterm" id="idm46536641263928"/><a data-primary="server-streaming RPC" data-type="indexterm" id="idm46536641262920"/><a data-primary="streaming" data-secondary="server-streaming RPC" data-type="indexterm" id="idm46536641262248"/>From the client perspective, both simple RPC and server-streaming RPC have the same request message flow. In both cases, we send one request message. The main difference is on the server side. Rather than sending one response message to the client, the server sends multiple messages. The server waits until it receives the completed request message and sends the response headers and multiple length-prefixed messages as shown in <a data-type="xref" href="#server_streaming_rpc_message_flow">Figure 4-9</a>. Communication ends once the server sends the trailing header with status details.</p>&#13;
&#13;
<figure><div class="figure" id="server_streaming_rpc_message_flow">&#13;
<img alt="Server-streaming RPC: message flow" src="assets/grpc_0409.png"/>&#13;
<h6><span class="label">Figure 4-9. </span>Server-streaming RPC: message flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s look at client-streaming RPC, which is pretty much the opposite of server-streaming RPC.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Client-streaming RPC" data-type="sect3"><div class="sect3" id="idm46536641257160">&#13;
<h3>Client-streaming RPC</h3>&#13;
&#13;
<p><a data-primary="client-streaming RPC" data-type="indexterm" id="idm46536641255960"/><a data-primary="message flow" data-secondary="client-streaming RPC" data-type="indexterm" id="idm46536641255256"/><a data-primary="RPC (remote procedure call)" data-secondary="client-streaming" data-type="indexterm" id="idm46536641254312"/><a data-primary="streaming" data-secondary="client-streaming RPC" data-type="indexterm" id="idm46536641253304"/>In client-streaming RPC, the client sends multiple messages to the server and the server sends one response message in reply. The client first sets up the connection with the server by sending the header frames. Once the connection is set up, the client sends multiple length-prefixed messages as data frames to the server as shown in <a data-type="xref" href="#client_streaming_rpc_message_flow">Figure 4-10</a>. In the end, the client half-closes the connection by sending an EOS flag in the last data frame. In the meantime, the server reads the messages received from the client. Once it receives all messages, the server sends a response message along with the trailing header and closes the connection.</p>&#13;
&#13;
<figure><div class="figure" id="client_streaming_rpc_message_flow">&#13;
<img alt="Client-streaming RPC: message flow" src="assets/grpc_0410.png"/>&#13;
<h6><span class="label">Figure 4-10. </span>Client-streaming RPC: message flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s move onto the last communication pattern, bidirectional RPC, in which the client and server are both sending multiple messages to each other until they close the connection.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bidirectional-streaming RPC" data-type="sect3"><div class="sect3" id="idm46536641247896">&#13;
<h3>Bidirectional-streaming RPC</h3>&#13;
&#13;
<p><a data-primary="bidirectional-streaming RPC" data-secondary="message flow in" data-type="indexterm" id="idm46536641246504"/><a data-primary="message flow" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="idm46536641245464"/><a data-primary="RPC (remote procedure call)" data-secondary="bidirectional-streaming" data-type="indexterm" id="idm46536641244504"/><a data-primary="streaming" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="idm46536641243576"/>In this pattern, the client sets up the connection by sending header frames. Once the connection is set up, the client and server both send length-prefixed messages without waiting for the other to finish. As shown in <a data-type="xref" href="#bidirectional_streaming_rpc_message_flow">Figure 4-11</a>, both client and server send messages simultaneously. Both can end the connection at their side, meaning they can’t send any more messages.</p>&#13;
&#13;
<figure><div class="figure" id="bidirectional_streaming_rpc_message_flow">&#13;
<img alt="Bidirectional-streaming RPC: message flow" src="assets/grpc_0411.png"/>&#13;
<h6><span class="label">Figure 4-11. </span>Bidirectional-streaming RPC: message flow</h6>&#13;
</div></figure>&#13;
&#13;
<p>With that, we have come to the end of our in-depth tour of gRPC communication. Network and transport-related operations in communication are normally handled at the gRPC core layer and you don’t need to be aware of the details as a gRPC application developer.<a data-startref="ix_ch04-asciidoc14" data-type="indexterm" id="idm46536641239064"/><a data-startref="ix_ch04-asciidoc13" data-type="indexterm" id="idm46536641238456"/></p>&#13;
&#13;
<p>Before wrapping up this chapter, let’s look at the gRPC implementation architecture and the language stack.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="gRPC Implementation Architecture" data-type="sect1"><div class="sect1" id="idm46536641407624">&#13;
<h1>gRPC Implementation Architecture</h1>&#13;
&#13;
<p><a data-primary="implementation" data-secondary="gRPC implementation architecture" data-type="indexterm" id="idm46536641236088"/>As shown in <a data-type="xref" href="#grpc_native_implementation_architecture">Figure 4-12</a>, gRPC implementation can be divided into multiple layers. <a data-primary="core layer" data-type="indexterm" id="idm46536641234376"/>The base layer is the gRPC core layer. It is a thin layer and it abstracts all the network operations from the upper layers so that application developers can easily make RPC calls over the network. The core layer also provides extensions to the core functionality. Some of the extension points are authentication filters to handle call security and a deadline filter to implement call deadlines, etc.</p>&#13;
&#13;
<p>gRPC is natively supported by the C/C++, Go, and Java languages. gRPC also provides language bindings in many popular languages such as Python, Ruby, PHP, etc. These language bindings are wrappers over the low-level C API.</p>&#13;
&#13;
<p><a data-primary="application layer" data-type="indexterm" id="idm46536641232344"/>Finally, the application code goes on top of language bindings. This application layer handles the application logic and data encoding logic. Normally developers generate source code for data encoding logic using compilers provided by different languages. For example, if we use protocol buffers for encoding data, the protocol buffer compiler can be used to generate source code. So developers can write their application logic by invoking the methods of generated source code.</p>&#13;
&#13;
<figure><div class="figure" id="grpc_native_implementation_architecture">&#13;
<img alt="gRPC native implementation architecture" src="assets/grpc_0412.png"/>&#13;
<h6><span class="label">Figure 4-12. </span>gRPC native implementation architecture</h6>&#13;
</div></figure>&#13;
&#13;
<p>With that, we have covered most of the low-level implementation and execution details of gRPC-based applications. As an application developer, it is always better to have an understanding of the low-level details about the techniques you’re going to use in the application. It not only helps to design robust applications, but also helps in troubleshooting application issues easily.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46536641228456">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>gRPC builds on top of two fast and efficient protocols called protocol buffers and HTTP/2. Protocol buffers are a data serialization protocol that is a language-agnostic, platform-neutral, and extensible mechanism for serializing structured data. Once serialized, this protocol produces a binary payload that is smaller in size than a normal JSON payload and is strongly typed. This serialized binary payload then travels over the binary transport protocol called HTTP/2.</p>&#13;
&#13;
<p>HTTP/2 is the next major version of the internet protocol HTTP. HTTP/2 is fully multiplexed, which means that HTTP/2 can send multiple requests for data in parallel over a single TCP connection. This makes applications written in HTTP/2 faster, simpler, and more robust than others.</p>&#13;
&#13;
<p>All these factors make gRPC a high-performance RPC framework.</p>&#13;
&#13;
<p>In this chapter we covered low-level details about gRPC communication. These details may be not essential to develop a gRPC application, because they are already handled by the library, but understanding low-level gRPC message flow is absolutely essential when it comes to troubleshooting gRPC communication-related issues when you use gRPC in production. In the next chapter, we’ll discuss some advanced capabilities provided by gRPC to cater to real-world requirements.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>