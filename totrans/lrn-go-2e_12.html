<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Concurrency in Go"><div class="chapter" id="unique_chapter_id_12">
<h1><span class="label">Chapter 12. </span>Concurrency in Go</h1>


<p><em>Concurrency</em> is the computer science term<a data-type="indexterm" data-primary="concurrency" data-secondary="about" id="id2378"/><a data-type="indexterm" data-primary="Communicating Sequential Processes (CSP)" id="id2379"/><a data-type="indexterm" data-primary="Hoare, Tony" id="id2380"/> for breaking up a single process into independent components and specifying how these components safely share data. Most languages provide concurrency via a library using operating system–level threads that share data by attempting to acquire locks. Go is different. Its main concurrency model, arguably Go’s most famous feature, is based on Communicating Sequential Processes (CSP). This style for concurrency was described in 1978 in a <a href="https://oreil.ly/x1IVG">paper by Tony Hoare</a>, the man who invented the Quicksort algorithm. The patterns implemented with CSP are just as powerful as the standard ones but are far easier to understand.</p>

<p>In this chapter, you are going to quickly review the features that are the backbone of concurrency in Go: goroutines, channels, and the <code>select</code> keyword. Then you are going to look at some common Go concurrency patterns and learn about the situations where lower-level techniques are a better approach.</p>






<section data-type="sect1" data-pdf-bookmark="When to Use Concurrency"><div class="sect1" id="id153">
<h1>When to Use Concurrency</h1>

<p>Let’s start with a word of caution. <a data-type="indexterm" data-primary="concurrency" data-secondary="when to use" id="id2381"/>Be sure that your program benefits from concurrency. When new Go developers start experimenting with concurrency, they tend to go through a series of stages:</p>
<ol>
<li>
<p>This is <em>amazing</em>; I’m going to put everything in goroutines!</p>
</li>
<li>
<p>My program isn’t any faster. I’m adding buffers to my channels.</p>
</li>
<li>
<p>My channels are blocking and I’m getting deadlocks. I’m going to use buffered channels with <em>really</em> big buffers.</p>
</li>

</ol>
<ol class="pagebreak-before" start="4">
<li>
<p>My channels are still blocking. I’m going to use mutexes.</p>
</li>
<li>
<p>Forget it, I’m giving up on concurrency.</p>
</li>

</ol>

<p>People are attracted to concurrency because they believe concurrent programs run faster. Unfortunately, that’s not always the case. More concurrency doesn’t automatically make things faster, and it can make code harder to understand. The key is understanding that <em>concurrency is not parallelism</em>. Concurrency is a tool to better structure the problem you are trying to solve.</p>

<p>Whether concurrent code runs in parallel (at the same time) depends on the hardware and whether the algorithm allows it. <a data-type="indexterm" data-primary="Amdahl, Gene" id="id2382"/><a data-type="indexterm" data-primary="Amdahl’s law" id="id2383"/><a data-type="indexterm" data-primary="The Art of Concurrency (Breshears)" data-primary-sortas="Art of Concurrency" id="id2384"/><a data-type="indexterm" data-primary="Breshears, Clay" id="id2385"/>In 1967, Gene Amdahl, one of the pioneers of computer science, derived Amdahl’s law. It is a formula for figuring out how much parallel processing can improve performance, given how much of the work must be performed sequentially. If you want to dive into the details on Amdahl’s law, you can learn more in <a href="https://oreil.ly/HaZQ8"><em>The Art of Concurrency</em></a> by Clay Breshears (O’Reilly). For our purposes, all you need to understand is that more concurrency does not mean more speed.</p>

<p>Broadly speaking, all programs follow the same three-step process: they take data, transform it, and then output the result. Whether you should use concurrency in your program depends on how data flows through the steps in your program. Sometimes two steps can be concurrent because the data from one is not required for the other to proceed, and at other times two steps must happen in series because one depends on the other’s output. Use concurrency when you want to combine data from multiple operations that can operate independently.</p>

<p>Another important thing to note is that concurrency isn’t worth using if the process that’s running concurrently doesn’t take a lot of time. Concurrency isn’t free; many common in-memory algorithms are so fast that the overhead of passing values via concurrency overwhelms any potential time savings you’d gain by running concurrent code in parallel. This is why concurrent operations are often used for I/O; reading or writing to a disk or network is thousands of times slower than all but the most complicated in-memory processes. If you are not sure if concurrency will help, first write your code serially and then write a benchmark to compare performance with a concurrent implementation. (See <a data-type="xref" href="ch15.html#benchmarking">“Using Benchmarks”</a> for information on how to benchmark your code.)</p>

<p>Let’s consider an example. Say you are writing a web service that calls three other web services. Your program sends data to two of those services, and then takes the results of those two calls and sends them to the third, returning the result. The entire process must take less than 50 milliseconds, or an error should be returned. This is a good use of concurrency, because there are parts of the code that need to perform I/O that can run without interacting with one another, there’s a part where the results are combined, and there’s a limit on how long the code needs to run. At the end of this chapter, you’ll see how to implement this code.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Goroutines"><div class="sect1" id="goroutines">
<h1>Goroutines</h1>

<p>The goroutine is the core concept <a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" id="id2386"/><a data-type="indexterm" data-primary="goroutines in concurrency" id="id2387"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" id="id2388"/>in Go’s concurrency model. To understand goroutines, let’s define a couple of terms. The first is <em>process</em>. A process is an instance of a program that’s being run by a computer’s operating system. The operating system associates some resources, such as memory, with the process and makes sure that other processes can’t access them. A process is composed of one or more <em>threads</em>. A thread is a unit of execution that is given some time to run by the operating system. Threads within a process share access to resources. A CPU can execute instructions from one or more threads at the same time, depending on the number of cores. One of the jobs of an operating system is to schedule threads on the CPU to make sure that every process (and every thread within a process) gets a chance to run.</p>

<p>Think of a goroutine as a lightweight thread,<a data-type="indexterm" data-primary="Go runtime" data-secondary="scheduler" id="id2389"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="scheduler" id="id2390"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="scheduler" id="id2391"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="scheduler" id="id2392"/> managed by the Go runtime. When a Go program starts, the Go runtime creates a number of threads and launches a single goroutine to run your program. All the goroutines created by your program, including the initial one, are assigned to these threads automatically by the Go runtime scheduler, just as the operating system schedules threads across CPU cores. This might seem like extra work, since the underlying operating system already includes a scheduler that manages threads and processes, but it has several benefits:</p>

<ul>
<li>
<p>Goroutine creation is faster than thread creation, because you aren’t creating an operating system–level resource.</p>
</li>
<li>
<p>Goroutine initial stack sizes are smaller than thread stack sizes and can grow as needed. This makes goroutines more memory efficient.</p>
</li>
<li>
<p>Switching between goroutines is faster than switching between threads because it happens entirely within the process, avoiding operating system calls that are (relatively) slow.</p>
</li>
<li>
<p>The goroutine scheduler is able to optimize its decisions because it is part of the Go process. The scheduler works with the network poller, detecting when a goroutine can be unscheduled because it is blocking on I/O. It also integrates with the garbage collector, making sure that work is properly balanced across all the operating system threads assigned to your Go process.</p>
</li>
</ul>

<p>These advantages allow Go programs to spawn hundreds, thousands, even tens of thousands of simultaneous goroutines. If you try to launch thousands of threads in a language with native threading, your program will slow to a crawl.</p>
<div data-type="tip" class="less_space pagebreak-before"><h6>Tip</h6>
<p>If you are interested in learning more<a data-type="indexterm" data-primary="Joshi, Kavya" id="id2393"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="scheduler" data-tertiary="more information URL" id="id2394"/><a data-type="indexterm" data-primary="Go runtime" data-secondary="scheduler" data-tertiary="more information URL" id="id2395"/><a data-type="indexterm" data-primary="The Scheduler Saga (talk by Joshi)" data-primary-sortas="Scheduler Saga" id="id2396"/><a data-type="indexterm" data-primary="resources online" data-secondary="Go runtime" data-tertiary="scheduler information" id="id2397"/> about how the scheduler does its work, watch the talk Kavya Joshi gave at GopherCon 2018 called <a href="https://oreil.ly/879mk">“The Scheduler Saga”</a>.</p>
</div>

<p>A goroutine is launched by<a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="launching" id="id2398"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="launching" id="id2399"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="launching" id="id2400"/><a data-type="indexterm" data-primary="functions" data-secondary="returning values" data-tertiary="goroutine return values ignored" id="id2401"/><a data-type="indexterm" data-primary="return keyword" data-secondary="goroutine return values ignored" id="id2402"/><a data-type="indexterm" data-primary="parameters" data-secondary="goroutine invocation" id="id2403"/> placing the <code>go</code> keyword before a function invocation. Just as with any other function, you can pass it parameters to initialize its state. However, any values returned by the function are ignored.</p>

<p>Any function can be launched as a goroutine. This is different from JavaScript, where a function runs asynchronously only if the author of the function declared it with the <code>async</code> keyword. However, it is customary in Go to launch goroutines with a closure that wraps business logic. The closure takes care of the concurrent bookkeeping. The following sample code demonstrates the concept:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// do something with val</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">processConcurrently</code><code class="p">(</code><code class="nx">inVals</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// create the channels</code><code class="w"/>
<code class="w">    </code><code class="nx">in</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="c1">// launch processing goroutines</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">5</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">in</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">out</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// load the data into the in channel in another goroutine</code><code class="w"/>
<code class="w">    </code><code class="c1">// read the data from the out channel</code><code class="w"/>
<code class="w">    </code><code class="c1">// return the data</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this code, the <code>processConcurrently</code> function creates a closure, which reads values out of a channel and passes them to the business logic in the <code>process</code> function. The <code>process</code> function is completely unaware that it is running in a goroutine. The result of <code>process</code> is then written back to a different channel by the closure. (I’ll do a brief overview of channels in the next section.) This separation of responsibility makes your programs modular and testable, and keeps concurrency out of your APIs. The decision to use a thread-like model for concurrency means that Go programs avoid the “function coloring” problem described by Bob Nystrom in his famous blog post <a href="https://oreil.ly/0I_Op">“What Color Is Your Function?”</a></p>

<p class="pagebreak-before">You can find a complete example<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2404"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2405"/> on <a href="https://oreil.ly/mw5NU">The Go Playground</a> or in the <em>sample_code/goroutine</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Channels"><div class="sect1" id="channels">
<h1>Channels</h1>

<p>Goroutines communicate using <em>channels</em>. Like<a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="about" id="id2406"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="about" id="id2407"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="channels for communication" id="id2408"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="channels for communication" id="id2409"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="channels for communication" id="id2410"/><a data-type="indexterm" data-primary="make function" data-secondary="channels created" id="id2411"/><a data-type="indexterm" data-primary="types" data-secondary="channels" id="id2412"/> slices and maps, channels are a built-in type created using the <code>make</code> function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>

<p>Like maps, channels are reference types. <a data-type="indexterm" data-primary="channels in concurrency" data-secondary="about" data-tertiary="passed as pointer to functions" id="id2413"/><a data-type="indexterm" data-primary="pointers" data-secondary="channels passed to functions as" id="id2414"/><a data-type="indexterm" data-primary="functions" data-secondary="call by value language" data-tertiary="channel passed to a function" id="id2415"/><a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="channels as nil" id="id2416"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="zero value as nil" id="id2417"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="zero value as nil" id="id2418"/><a data-type="indexterm" data-primary="nil" data-secondary="zero value" data-tertiary="channels" id="id2419"/>When you pass a channel to a function, you are really passing a pointer to the channel. Also like maps and slices, the zero value for a channel is <code>nil</code>.</p>








<section data-type="sect2" data-pdf-bookmark="Reading, Writing, and Buffering"><div class="sect2" id="id155">
<h2>Reading, Writing, and Buffering</h2>

<p>Use the <code>&lt;-</code> operator to interact<a data-type="indexterm" data-primary="channels in concurrency" data-secondary="reading, writing, and buffering" id="id2420"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="reading, writing, and buffering" id="id2421"/><a data-type="indexterm" data-primary="&lt;- for channel access" id="id2422"/> with a channel. You read from a channel by placing the <code>&lt;-</code> operator to the left of the channel variable, and you write to a channel by placing it to the right:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">a</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="w"> </code><code class="c1">// reads a value from ch and assigns it to a</code><code class="w"/>
<code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">b</code><code class="w">   </code><code class="c1">// write the value in b to ch</code><code class="w"/></pre>

<p>Each value written to a channel<a data-type="indexterm" data-primary="channels in concurrency" data-secondary="reading, writing, and buffering" data-tertiary="read once" id="id2423"/> can be read only once. If multiple goroutines are reading from the same channel, a value written to the channel will be read by only one of them.</p>

<p>A single goroutine rarely reads and writes to the same channel. <a data-type="indexterm" data-primary="keywords" data-secondary="chan" id="id2424"/><a data-type="indexterm" data-primary="chan keyword" id="id2425"/>When assigning a channel to a variable or field, or passing it to a function, use an arrow before the <code>chan</code> keyword (<code>ch &lt;-chan int</code>) to indicate that the goroutine only <em>reads</em> from the channel. Use an arrow after the <code>chan</code> keyword (<code>ch chan&lt;- int</code>) to indicate that the goroutine only <em>writes</em> to the channel. Doing so allows the Go compiler to ensure that a channel is only read from or written to by a function.</p>

<p>By default, channels are <em>unbuffered</em>. Every write to an open, unbuffered channel causes the writing goroutine to pause until another goroutine reads from the same channel. Likewise, a read from an open, unbuffered channel causes the reading goroutine to pause until another goroutine writes to the same channel. This means you cannot write to or read from an unbuffered channel without at least two concurrently running goroutines.</p>

<p>Go also has <em>buffered</em> channels. These channels buffer a limited number of writes without blocking. If the buffer fills before there are any reads from the channel, a subsequent write to the channel pauses the writing goroutine until the channel is read. Just as writing to a channel with a full buffer blocks, reading from a channel with an empty buffer also blocks.</p>

<p>A buffered channel is created by specifying the capacity of the buffer when creating the channel:<a data-type="indexterm" data-primary="make function" data-secondary="channels created" data-tertiary="buffer capacity" id="id2426"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>

<p>The built-in functions <code>len</code> and <code>cap</code> return<a data-type="indexterm" data-primary="cap function" data-secondary="channel buffer capacity" id="id2427"/><a data-type="indexterm" data-primary="len function" data-secondary="channel buffer contents" id="id2428"/> information about a buffered channel. Use <code>len</code> to find out how many values are currently in the buffer and use <code>cap</code> to find out the maximum buffer size. The capacity of the buffer cannot be changed.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Passing an unbuffered channel to both <code>len</code> and <code>cap</code> returns 0. This makes sense because, by definition, an unbuffered channel doesn’t have a buffer to store values.</p>
</div>

<p>Most of the time, you should use unbuffered channels. In <a data-type="xref" href="#buffered_unbuffered">“Know When to Use Buffered and Unbuffered Channels”</a>, I’ll talk about the situations where buffered channels are useful.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Using for-range and Channels"><div class="sect2" id="id288">
<h2>Using for-range and Channels</h2>

<p>You can also read from a channel by using a <code>for-range</code> loop:<a data-type="indexterm" data-primary="channels in concurrency" data-secondary="reading, writing, and buffering" data-tertiary="reading via for-range loop" id="id2429"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="reading via for-range loop" id="id2430"/><a data-type="indexterm" data-primary="for statement" data-secondary="for-range statement" data-tertiary="channel read via" id="id2431"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="k">for</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">ch</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Unlike other <code>for-range</code> loops, there is only a single variable declared for the channel, which is the value. If the channel is open and a value is available on the channel, it is assigned to <code>v</code> and the body of the loop executes. If no value is available on the channel, the goroutine pauses until a value is available or the channel is closed. The loop continues until the channel is closed, or until a <code>break</code> or <code>return</code> statement is reached.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Closing a Channel"><div class="sect2" id="close_channel">
<h2>Closing a Channel</h2>

<p>When you’re done writing to a channel,<a data-type="indexterm" data-primary="channels in concurrency" data-secondary="closing" id="id2432"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="closing" id="id2433"/><a data-type="indexterm" data-primary="close function to close a channel" id="id2434"/> you close it using the built-in <code>close</code> function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code><code class="w"/></pre>

<p>Once a channel is closed, any attempts to write to it or close it again will panic. Interestingly, attempting to read from a closed channel always succeeds. If the channel is buffered and some values haven’t been read yet, they will be returned in order. If the channel is unbuffered or the buffered channel has no more values, the zero value for the channel’s type is returned.</p>

<p class="pagebreak-before">This leads to a question that might sound familiar from your experience with maps: <a data-type="indexterm" data-primary="channels in concurrency" data-secondary="reading, writing, and buffering" data-tertiary="zero value and comma ok idiom" id="id2435"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="closing" data-tertiary="zero value when read while closed" id="id2436"/><a data-type="indexterm" data-primary="comma ok idiom" data-secondary="channel returning zero value" id="id2437"/>when your code reads from a channel, how do you tell the difference between a zero value that was written and a zero value that was returned because the channel is closed? Since Go tries to be a consistent language, there is a familiar answer—use the comma ok idiom to detect whether a channel has been closed:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="w"/></pre>

<p>If <code>ok</code> is set to <code>true</code>, the channel is open. If it is set to <code>false</code>, the channel is closed.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Anytime you are reading from a channel that might be closed, use the comma ok idiom to ensure that the channel is still open.</p>
</div>

<p>The responsibility for closing a channel lies with the goroutine that writes to the channel. Be aware that closing a channel is required only if a goroutine is waiting for the channel to close (such as one using a <code>for-range</code> loop to read from the channel). Since a channel is just another variable, Go’s runtime can detect channels that are no longer referenced and garbage collect them.</p>

<p>Channels are one of the two things that set apart Go’s concurrency model. They guide you into thinking about your code as a series of stages and making data dependencies clear, which makes it easier to reason about concurrency. Other languages rely on global shared state to communicate between threads. This mutable shared state makes it hard to understand how data flows through a program, which in turn makes it difficult to understand whether two threads are actually independent.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Understanding How Channels Behave"><div class="sect2" id="id258">
<h2>Understanding How Channels Behave</h2>

<p>Channels have many states,<a data-type="indexterm" data-primary="channels in concurrency" data-secondary="behavior chart" id="id2438"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="behavior chart" id="id2439"/><a data-type="indexterm" data-primary="panics" data-secondary="channel behavior chart" id="id2440"/> each with a different behavior when reading, writing, or closing. Use <a data-type="xref" href="#how_channels_behave">Table 12-1</a> to keep them straight.</p>
<table id="how_channels_behave">
<caption><span class="label">Table 12-1. </span>How channels behave</caption>
<thead>
<tr>
 <th> </th>
  <th>Unbuffered, open</th>
  <th>Unbuffered, closed</th>
  <th>Buffered, open</th>
  <th>Buffered, closed</th>
  <th>Nil</th>
</tr>
</thead>
<tbody>
<tr>
  <td class="fakeheader">Read</td>
  <td>Pause until something is written</td>
  <td>Return zero value (use comma ok to see if closed)</td>
  <td>Pause if buffer is empty</td>
  <td>Return a remaining value in the buffer; if the buffer is empty, return zero value (use comma ok to see if closed)</td>
  <td>Hang forever</td>
</tr>
<tr>
  <td class="fakeheader">Write</td>
  <td>Pause until something is read</td>
  <td><strong>PANIC</strong></td>
  <td>Pause if buffer is full</td>
  <td><strong>PANIC</strong></td>
  <td>Hang forever</td>
</tr>
<tr>
  <td class="fakeheader">Close</td>
  <td>Works</td>
  <td><strong>PANIC</strong></td>
  <td>Works, remaining values still there</td>
  <td><strong>PANIC</strong></td>
  <td><strong>PANIC</strong></td>
</tr>
</tbody>
</table>

<p>You must avoid situations that cause Go programs to panic. As mentioned earlier, the standard pattern is to make the writing goroutine responsible for closing the channel when there’s nothing left to write. When multiple goroutines are writing to the same channel, this becomes more complicated, as calling <code>close</code> twice on the same channel causes a panic. Furthermore, if you close a channel in one goroutine, a write to the channel in another goroutine triggers a panic as well. The way to address this is to use a <code>sync.WaitGroup</code>. You’ll see an example in <a data-type="xref" href="#wait_group">“Use WaitGroups”</a>.</p>

<p>A <code>nil</code> channel can be dangerous as well, but it is useful in some cases. You’ll learn more about them in <a data-type="xref" href="#nil_channel">“Turn Off a case in a select”</a>.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="select"><div class="sect1" id="id157">
<h1>select</h1>

<p>The <code>select</code> statement is the other<a data-type="indexterm" data-primary="concurrency" data-secondary="select keyword" id="ch12-sel"/><a data-type="indexterm" data-primary="keywords" data-secondary="select" id="ch12-sel2"/><a data-type="indexterm" data-primary="select keyword" id="ch12-sel3"/> thing that sets apart Go’s concurrency model. It is the control structure for concurrency in Go, and it elegantly solves a common problem: if you can perform two concurrent operations, which one do you do first? You can’t favor one operation over others, or you’ll never process some cases. This is called <em>starvation</em>.</p>

<p>The <code>select</code> keyword allows a goroutine to read from or write to one of a set of multiple channels. It looks a great deal like a blank <code>switch</code> statement:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch2</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="nx">ch3</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">x</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"wrote"</code><code class="p">,</code><code class="w"> </code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch4</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"got value on ch4, but ignored it"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Each <code>case</code> in a <code>select</code> is a read or a write to a channel. If a read or write is possible for a <code>case</code>, it is executed along with the body of the <code>case</code>. Like a <code>switch</code>, each <code>case</code> in a <code>select</code> creates its own block.</p>

<p>What happens if multiple cases have channels that can be read or written? The <code>select</code> algorithm is simple: it picks randomly from any of its cases that can go forward; order is unimportant. This is very different from a <code>switch</code> statement, which always chooses the first <code>case</code> that resolves to <code>true</code>. It also cleanly resolves the starvation problem, as no <code>case</code> is favored over another and all are checked at the same time.</p>

<p>Another advantage of <code>select</code> choosing at random is that it prevents one of the most common causes of deadlocks: acquiring locks in an inconsistent order. If you have two goroutines that both access the same two channels, they must be accessed in the same order in both goroutines, <a data-type="indexterm" data-primary="deadlock" id="id2441"/>or they will <em>deadlock</em>. This means that neither one can proceed because they are waiting on each other. If every goroutine in your Go application is deadlocked, the Go runtime kills your program (see <a data-type="xref" href="#EX10_1">Example 12-1</a>).</p>
<div id="EX10_1" data-type="example">
<h5><span class="label">Example 12-1. </span>Deadlocking goroutines</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">ch2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">inGoroutine</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">        </code><code class="nx">ch1</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">inGoroutine</code><code class="w"/>
<code class="w">        </code><code class="nx">fromMain</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch2</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"goroutine:"</code><code class="p">,</code><code class="w"> </code><code class="nx">inGoroutine</code><code class="p">,</code><code class="w"> </code><code class="nx">fromMain</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="nx">inMain</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="nx">ch2</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">inMain</code><code class="w"/>
<code class="w">    </code><code class="nx">fromGoroutine</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch1</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">inMain</code><code class="p">,</code><code class="w"> </code><code class="nx">fromGoroutine</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p>If you run this program on <a href="https://oreil.ly/eP3D1">The Go Playground</a> or in the <em>sample_code/deadlock</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>, you’ll see the following error:<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="ix_l1l2"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="ix_lll123"/></p>

<pre data-type="programlisting">fatal error: all goroutines are asleep - deadlock!</pre>

<p>Remember that <code>main</code> is running on a goroutine that is launched at startup by the Go runtime. The goroutine that is explicitly launched cannot proceed until <code>ch1</code> is read, and the main goroutine cannot proceed until <code>ch2</code> is read.</p>

<p>If the channel read and the channel write in the main goroutine are wrapped in a <code>select</code>, deadlock is avoided (see <a data-type="xref" href="#EX10_2">Example 12-2</a>).</p>
<div id="EX10_2" data-type="example">
<h5><span class="label">Example 12-2. </span>Using <code>select</code> to avoid deadlocks</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">ch2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">inGoroutine</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">        </code><code class="nx">ch1</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">inGoroutine</code><code class="w"/>
<code class="w">        </code><code class="nx">fromMain</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch2</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"goroutine:"</code><code class="p">,</code><code class="w"> </code><code class="nx">inGoroutine</code><code class="p">,</code><code class="w"> </code><code class="nx">fromMain</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="nx">inMain</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">fromGoroutine</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">ch2</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">inMain</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">fromGoroutine</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch1</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">inMain</code><code class="p">,</code><code class="w"> </code><code class="nx">fromGoroutine</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p>If you run this program on <a href="https://oreil.ly/Djtpj">The Go Playground</a> or in the <em>sample_code/select</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>, you’ll get the output:<a data-type="indexterm" data-startref="ix_l1l2" id="id2442"/><a data-type="indexterm" data-startref="ix_lll123" id="id2443"/></p>

<pre data-type="programlisting">main: 2 1</pre>

<p>Because a <code>select</code> checks whether any of its cases can proceed, the deadlock is avoided. The goroutine that is launched explicitly wrote the value 1 into <code>ch1</code>, so the read from <code>ch1</code> into <code>fromGoroutine</code> in the main goroutine is able to succeed.</p>

<p>Although this program doesn’t deadlock, it still doesn’t do the right thing. The <code>fmt.Println</code> statement in the launched goroutine never executes, because that goroutine is paused, waiting for a value to read from <code>ch2</code>. When the main goroutine exits, the program exits and kills any remaining goroutines, which does technically resolve the pause. However, you should make sure that all your goroutines exit properly so that you don’t <em>leak</em> them. I talk about this in more detail in <a data-type="xref" href="#goroutine_cleanup">“Always Clean Up Your Goroutines”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Making this program behave properly requires a few techniques that you’ll learn about later in the chapter. You can find a working solution on <a href="https://oreil.ly/G1bi7">The Go Playground</a>.</p>
</div>

<p>Since <code>select</code> is responsible for communicating over a number of channels, it is often embedded within a <code>for</code> loop:<a data-type="indexterm" data-primary="select keyword" data-secondary="for loop for multiple channels" id="id2444"/><a data-type="indexterm" data-primary="concurrency" data-secondary="select keyword" data-tertiary="for loop for multiple channels" id="id2445"/><a data-type="indexterm" data-primary="for statement" data-secondary="for-select loop" id="id2446"/><a data-type="indexterm" data-primary="control structures" data-secondary="for statement" data-tertiary="for-select loop" id="id2447"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">done</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is so common that the combination is often referred to as a <code>for-select</code> loop. When using a <code>for-select</code> loop, you must include a way to exit the loop. You’ll see one way to do this in <a data-type="xref" href="#done_channel">“Use the Context to Terminate Goroutines”</a>.</p>

<p>Just like <code>switch</code> statements,<a data-type="indexterm" data-primary="select keyword" data-secondary="default clause" id="id2448"/><a data-type="indexterm" data-primary="concurrency" data-secondary="select keyword" data-tertiary="default clause" id="id2449"/> a <code>select</code> statement can have a <code>default</code> clause. Also just like <code>switch</code>, <code>default</code> is selected when there are no cases with channels that can be read or written. If you want to implement a nonblocking read or write on a channel, use a <code>select</code> with a <code>default</code>. The following code does not wait if there’s no value to read in <code>ch</code>; it immediately executes the body of the <code>default</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"read from ch:"</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"no value written to ch"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You’ll take a look at a use for <code>default</code> in <a data-type="xref" href="#backpressure">“Implement Backpressure”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Having a <code>default</code> case inside a <code>for-select</code> loop is almost always the wrong thing to do. It will be triggered every time through the loop when there’s nothing to read or write for any of the cases. This makes your <code>for</code> loop run constantly, which uses a great deal of CPU.<a data-type="indexterm" data-startref="ch12-sel" id="id2450"/><a data-type="indexterm" data-startref="ch12-sel2" id="id2451"/><a data-type="indexterm" data-startref="ch12-sel3" id="id2452"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Concurrency Practices and Patterns"><div class="sect1" id="id353">
<h1>Concurrency Practices and Patterns</h1>

<p>Now that you’ve seen the basic tools that Go provides for concurrency, let’s take a look at some concurrency best practices and patterns.</p>








<section data-type="sect2" data-pdf-bookmark="Keep Your APIs Concurrency-Free"><div class="sect2" id="id259">
<h2>Keep Your APIs Concurrency-Free</h2>

<p>Concurrency is an implementation detail,<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="APIs concurrency-free" id="id2453"/><a data-type="indexterm" data-primary="APIs" data-secondary="concurrency-free" id="id2454"/> and good API design should hide implementation details as much as possible. This allows you to change how your code works without changing how your code is invoked.</p>

<p>Practically, this means that you should never expose channels or mutexes in your API’s types, functions, and methods (I’ll talk about mutexes in <a data-type="xref" href="#mutexes">“When to Use Mutexes Instead of Channels”</a>). If you expose a channel, you put the responsibility of channel management on the users of your API. The users then have to worry about concerns like whether a channel is buffered or closed or <code>nil</code>. They can also trigger deadlocks by accessing channels or mutexes in an unexpected order.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This doesn’t mean that you shouldn’t ever have channels as function parameters or struct fields. It means that they shouldn’t be exported.</p>
</div>

<p>This rule has some exceptions. If your API is a library with a concurrency helper function, channels are going to be part of its API.</p>
</div></section>








<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Goroutines, for Loops, and Varying Variables"><div class="sect2" id="shared_var_goroutine">
<h2>Goroutines, for Loops, and Varying Variables</h2>

<p>Most of the time, the closure that you<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="for loop index variable" id="ch12-forl"/><a data-type="indexterm" data-primary="for statement" data-secondary="goroutines and for loop index" id="ch12-forl2"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="for loop index variable" id="ch12-forl3"/><a data-type="indexterm" data-primary="control structures" data-secondary="for statement" data-tertiary="goroutines and for loop index" id="ch12-forl4"/> use to launch a goroutine has no parameters. Instead, it captures values from the environment where it was declared. Before Go 1.22, there was one common situation where this didn’t work: when trying to capture the index or value of a <code>for</code> loop. As mentioned in <a data-type="xref" href="ch04.html#for_range_copy">“The for-range value is a copy”</a> and <a data-type="xref" href="ch10.html#go_mod">“Using go.mod”</a>, a backward-breaking change was introduced in Go 1.22 that changed the behavior of a <code>for</code> loop so that it creates new variables for the index and value on each iteration instead of reusing a single variable.</p>

<p>The following code demonstrates the reason this change was worthwhile. You can find it in the <a href="https://oreil.ly/8KkS9"><code>goroutine_for_loop</code> repository</a> in the Learning Go 2nd Edition organization on GitHub.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="goroutine_for_loop repository" data-tertiary-sortas="rrr" id="id2455"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="goroutine_for_loop repository" data-tertiary-sortas="rrr" id="id2456"/></p>

<p>If you run the following code on Go 1.21 or earlier (or on Go 1.22 or later with the Go version set to 1.21 or earlier in the <code>go</code> directive in the <em>go.mod</em> file), you’ll see a subtle bug:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">a</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">a</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">        </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>One goroutine is launched for each value in <code>a</code>. It looks like a different value is passed in to each goroutine, but running the code shows something different:</p>

<pre data-type="programlisting">20
20
20
20
20</pre>

<p>The reason every goroutine wrote <code>20</code> to <code>ch</code> on earlier versions of Go is that the closure for every goroutine captured the same variable. The index and value variables in a <code>for</code> loop were reused on each iteration. The last value assigned to <code>v</code> was <code>10</code>. When the goroutines run, that’s the value that they see.</p>

<p>Upgrading to Go 1.22 or later and changing the value of the <code>go</code> directive in <em>go.mod</em> to 1.22 or later changes the behavior of <code>for</code> loops so they create a new index and value variable on each iteration. This gives you the expected result, with a different value passed to each goroutine:</p>

<pre data-type="programlisting">20
8
4
12
16</pre>

<p>If you cannot upgrade to Go 1.22, you can resolve this issue in two ways. The first is to make a copy of the value by shadowing the value within the loop:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">v</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If you want to avoid shadowing and make the data flow more obvious, you can also pass the value as a parameter to the goroutine:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="p">}(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>While Go 1.22 prevents this issue for the index and value variables in <code>for</code> loops, you still need to be careful with other variables that are captured by closures. Anytime a closure depends on a variable whose value might change, whether or not it is used as a goroutine, you must pass the value into the closure or make sure a unique copy of the variable is created for each closure that refers to the variable.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Anytime a closure uses a variable whose value might change, use a parameter to pass a copy of the variable’s current value into the closure.<a data-type="indexterm" data-startref="ch12-forl" id="id2457"/><a data-type="indexterm" data-startref="ch12-forl2" id="id2458"/><a data-type="indexterm" data-startref="ch12-forl3" id="id2459"/><a data-type="indexterm" data-startref="ch12-forl4" id="id2460"/></p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Always Clean Up Your Goroutines"><div class="sect2" id="goroutine_cleanup">
<h2>Always Clean Up Your Goroutines</h2>

<p>Whenever you launch a goroutine function,<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="always clean up goroutines" id="id2461"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" id="id2462"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="launching" data-tertiary="must eventually exit" id="id2463"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="launching" id="id2464"/> you must make sure that it will eventually exit. Unlike variables, the Go runtime can’t detect that a goroutine will never be used again. If a goroutine doesn’t exit, all the memory allocated for variables on its stack remains allocated and any memory on the heap that is rooted in the goroutine’s stack variables cannot be garbage collected. This is called a <em>goroutine leak</em>.<a data-type="indexterm" data-primary="memory" data-secondary="goroutine leak" id="id2465"/><a data-type="indexterm" data-primary="stack" data-secondary="goroutine leak" id="id2466"/><a data-type="indexterm" data-primary="heap" data-secondary="goroutine leak" id="id2467"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" data-tertiary="goroutine leak" id="id2468"/></p>

<p>It may not be obvious that a goroutine isn’t guaranteed to exit. For example, say you used a goroutine as a generator:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">func</code><code class="w"> </code><code class="nx">countTo</code><code class="p">(</code><code class="nx">max</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;-</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">max</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">i</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ch</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">countTo</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is just a short example; don’t use a goroutine to generate a list of numbers. It’s too simple of an operation, which violates one of our “when to use concurrency” guidelines.</p>
</div>

<p>In the common case, where you use all the values, the goroutine exits. However, if you exit the loop early, the goroutine blocks forever, waiting for a value to be read from the channel:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">countTo</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Use the Context to Terminate Goroutines"><div class="sect2" id="done_channel">
<h2>Use the Context to Terminate Goroutines</h2>

<p>To solve the <code>countTo</code> goroutine leak,<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="context to terminate goroutines" id="id2469"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" data-tertiary="context to terminate goroutines" id="id2470"/><a data-type="indexterm" data-primary="context package" data-secondary="terminating goroutines" id="id2471"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="terminating" id="id2472"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="terminating" id="id2473"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="terminating" id="id2474"/> you need a way to tell the goroutine that it’s time to stop processing. You solve this in Go by using a <em>context</em>. Here’s a rewrite of <code>countTo</code> to demonstrate this technique. You can find the code in the <em>sample_code/context_cancel</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>:<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="ix_lll"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="ix_llll"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">countTo</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">max</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;-</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nb">close</code><code class="p">(</code><code class="nx">ch</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">max</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">i</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ch</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancel</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithCancel</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">cancel</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">countTo</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">ch</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">5</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>countTo</code> function is modified to take a <code>context.Context</code> parameter in addition to <code>max</code>. The <code>for</code> loop in the goroutine is also changed. It is now a <code>for-select</code> loop with two cases. One tries to write to <code>ch</code>. The other case checks the channel returned by the <code>Done</code> method on the context. If it returns a value, you exit the <code>for-select</code> loop and the goroutine. Now, you have a way to prevent the goroutine from leaking when every value is read.</p>

<p>This leads to the question, <a data-type="indexterm" data-primary="context package" data-secondary="terminating goroutines" data-tertiary="context cancellation" id="id2475"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" data-tertiary="context cancellation" id="id2476"/><a data-type="indexterm" data-primary="context package" data-secondary="cancellation" id="id2477"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="terminating" data-tertiary="context cancellation" id="id2478"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="terminating" id="id2479"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="terminating" id="id2480"/>how do you get the <code>Done</code> channel to return a value? It is triggered via <em>context cancellation</em>. In <code>main</code>, you create a context and a cancel function by using the <code>WithCancel</code> function in the <code>context</code> package. Next, you use <code>defer</code> to call <code>cancel</code> when the <code>main</code> function exits. This closes the channel returned by <code>Done</code>, and since a closed channel always returns a value, it ensures that the goroutine running <code>countTo</code> exits.</p>

<p>Using the context to terminate a goroutine is a very common pattern. It allows you to stop goroutines based on something from an earlier function in the call stack. In <a data-type="xref" href="ch14.html#cancelation">“Cancellation”</a>, you’ll learn in detail how to use the context to tell one or more goroutines that it is time to shut down.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Know When to Use Buffered and Unbuffered Channels"><div class="sect2" id="buffered_unbuffered">
<h2>Know When to Use Buffered and Unbuffered Channels</h2>

<p>One of the most complicated techniques<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="buffered versus unbuffered channels" id="id2481"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="using buffered versus unbuffered" id="id2482"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="when to use buffered versus unbuffered" id="id2483"/> to master in Go concurrency is deciding when to use a buffered channel. By default, channels are unbuffered, and they are easy to understand: one goroutine writes and waits for another goroutine to pick up its work, like a baton in a relay race. Buffered channels are much more complicated. You have to pick a size, since buffered channels never have unlimited buffers. Proper use of a buffered channel means that you must handle the case where the buffer is full and your writing goroutine blocks waiting for a reading goroutine. So what is the proper use of a buffered channel?</p>

<p>The case for buffered channels is subtle. To sum it up in a single sentence: buffered channels are useful when you know how many goroutines you have launched, want to limit the number of goroutines you will launch, or want to limit the amount of work that is queued up.</p>

<p>Buffered channels work great when you either want to gather data back from a set of goroutines that you have launched or want to limit concurrent usage. They are also helpful for managing the amount of work a system has queued up, preventing your services from falling behind and becoming overwhelmed. Here are a couple of examples to show how they can be used.</p>

<p>In the first example, you are processing the first 10 results on a channel. To do this, you launch 10 goroutines, each of which writes its results to a buffered channel:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">processChannel</code><code class="p">(</code><code class="nx">ch</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">conc</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="w">    </code><code class="nx">results</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">conc</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">conc</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">ch</code><code class="w"/>
<code class="w">            </code><code class="nx">results</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">conc</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">results</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You know exactly how many goroutines have been launched, and you want each goroutine to exit as soon as it finishes its work. This means you can create a buffered channel with one space for each launched goroutine, and have each goroutine write data to this goroutine without blocking. You can then loop over the buffered channel, reading out the values as they are written. When all the values have been read, you return the results, knowing that you aren’t leaking any goroutines.</p>

<p>You can find this code in the <em>sample_code/buffered_channel_work</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Implement Backpressure"><div class="sect2" id="backpressure">
<h2>Implement Backpressure</h2>

<p>Another technique that can be implemented<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="backpressure" id="id2484"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="backpressure in buffered channels" id="id2485"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="backpressure in buffered channels" id="id2486"/><a data-type="indexterm" data-primary="backpressure in buffered channels" id="id2487"/> with a buffered channel is <em>backpressure</em>. It is counterintuitive, but systems perform better overall when their components limit the amount of work they are willing to perform. You can use a buffered channel and a <code>select</code> statement to limit the number of simultaneous requests in a system:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">PressureGauge</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">New</code><code class="p">(</code><code class="nx">limit</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">PressureGauge</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">PressureGauge</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ch</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kd">struct</code><code class="p">{},</code><code class="w"> </code><code class="nx">limit</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">pg</code><code class="w"> </code><code class="o">*</code><code class="nx">PressureGauge</code><code class="p">)</code><code class="w"> </code><code class="nx">Process</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="kd">func</code><code class="p">())</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">pg</code><code class="p">.</code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}{}:</code><code class="w"/>
<code class="w">        </code><code class="nx">f</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="o">&lt;-</code><code class="nx">pg</code><code class="p">.</code><code class="nx">ch</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"no more capacity"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this code, you create a struct containing a buffered channel that can hold a number of “tokens” and a function to run. Every time a goroutine wants to use the function, it calls <code>Process</code>. This is one of the rare examples of the same goroutine both reading and writing the same channel. The <code>select</code> tries to write a token to the channel. If it can, the function runs, and then a token is read to the buffered channel. If it can’t write a token, the <code>default</code> case runs, and an error is returned instead. Here’s a quick example that uses this code with the built-in HTTP server (you’ll learn more about working with HTTP in <a data-type="xref" href="ch13.html#http_server">“The Server”</a>):</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doThingThatShouldBeLimited</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="s">"done"</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">pg</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">New</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/request"</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">pg</code><code class="p">.</code><code class="nx">Process</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">doThingThatShouldBeLimited</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="p">})</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">w</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusTooManyRequests</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"Too many requests"</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":8080"</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/backpressure</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Turn Off a case in a select"><div class="sect2" id="nil_channel">
<h2>Turn Off a case in a select</h2>

<p>When you need to combine data from<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="select case turned off" id="id2488"/><a data-type="indexterm" data-primary="concurrency" data-secondary="select keyword" data-tertiary="case turned off" id="id2489"/><a data-type="indexterm" data-primary="select keyword" data-secondary="selecting a closed channel" id="id2490"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="closing" data-tertiary="selecting a closed channel" id="id2491"/><a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="closing" id="id2492"/> multiple concurrent sources, the <code>select</code> keyword is great. However, you need to properly handle closed channels. If one of the cases in a <code>select</code> is reading a closed channel, it will always be successful, returning the zero value. Every time that case is selected, you need to check to make sure that the value is valid and skip the case. If reads are spaced out, your program is going to waste a lot of time reading junk values. Even if there is lots of activity on the nonclosed channels, your program will still spend some portion of its time reading from the closed channel, since <code>select</code> chooses a case at random.</p>

<p>When that happens, you rely on something that looks like an error: reading a <code>nil</code> channel. As you saw earlier, reading from or writing to a <code>nil</code> channel causes your code to hang forever. While that is bad if it is triggered by a bug, you can use a <code>nil</code> channel to disable a <code>case</code> in a <code>select</code>. When you detect that a channel has been closed, set the channel’s variable to <code>nil</code>. The associated case will no longer run, because the read from the <code>nil</code> channel never returns a value. Here is a <code>for-select</code> loop that reads from two channels until both are closed:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// in and in2 are channels</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">in</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">in</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="c1">// the case will never succeed again!</code><code class="w"/>
<code class="w">            </code><code class="nx">count</code><code class="o">++</code><code class="w"/>
<code class="w">            </code><code class="k">continue</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="c1">// process the v that was read from in</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">in2</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">in2</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="c1">// the case will never succeed again!</code><code class="w"/>
<code class="w">            </code><code class="nx">count</code><code class="o">++</code><code class="w"/>
<code class="w">            </code><code class="k">continue</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="c1">// process the v that was read from in2</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can try out this code on <a href="https://oreil.ly/0nCDz">The Go Playground</a> or in the <em>sample_code/close_case</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Time Out Code"><div class="sect2" id="time_out">
<h2>Time Out Code</h2>

<p>Most interactive programs have<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="timing out code" id="id2493"/><a data-type="indexterm" data-primary="timing out code in concurrency" id="id2494"/><a data-type="indexterm" data-primary="code" data-secondary="timing out in concurrency" id="id2495"/><a data-type="indexterm" data-primary="time package" data-secondary="timeouts" data-tertiary="timing out code" id="id2496"/> to return a response within a certain amount of time. One of the things that you can do with concurrency in Go is manage how much time a request (or a part of a request) has to run. Other languages introduce additional 
<span class="keep-together">features</span> on top of promises or futures to add this functionality, but Go’s timeout idiom shows how you build complicated features from existing parts. Let’s take a look:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">timeLimit</code><code class="p">[</code><code class="nx">T</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">worker</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="nx">limit</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancel</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(),</code><code class="w"> </code><code class="nx">limit</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">cancel</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">worker</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">result</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">out</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">        </code><code class="kd">var</code><code class="w"> </code><code class="nx">zero</code><code class="w"> </code><code class="nx">T</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">zero</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"work timed out"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Whenever you need to limit how long an operation takes in Go, you’ll see a variation on this pattern. I talk about the context in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a> and cover using timeouts in detail in <a data-type="xref" href="ch14.html#context_timers">“Contexts with Deadlines”</a>. For now, all you need to know is that reaching the timeout cancels the context. The <code>Done</code> method on the context returns a channel that returns a value when the context is canceled by either timing out or when the context’s cancel method is called. You create a timed context by using the <code>WithTimeout</code> function in the <code>context</code> package and specify how long to wait by using constants from the <code>time</code> package (I’ll talk more about the <code>time</code> package in <a data-type="xref" href="ch13.html#time">“time”</a>).</p>

<p>Once the context is set up, you run the worker in a goroutine and then use <code>select</code> to choose between two cases. The first case reads the value from the <code>out</code> channel when the work completes. The second case waits for the channel returned by the <code>Done</code> method to return a value, just as you saw in <a data-type="xref" href="#done_channel">“Use the Context to Terminate Goroutines”</a>. If it does, you return a timeout error. You write to a buffered channel of size 1 so that the channel write in the goroutine will complete even if <code>Done</code> is triggered first.</p>

<p>You can try out this code on <a href="https://oreil.ly/mTgyA">The Go Playground</a> or in the <em>sample_code/time_out</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If <code>timeLimit</code> exits before the goroutine finishes processing, the goroutine continues to run, eventually writing the returned value to the buffered channel and exiting. You just don’t do anything with the result that is returned. If you want to stop work in a goroutine when you are no longer waiting for it to complete, use context cancellation, which I’ll discuss in <a data-type="xref" href="ch14.html#cancelation">“Cancellation”</a>.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Use WaitGroups"><div class="sect2" id="wait_group">
<h2>Use WaitGroups</h2>

<p>Sometimes one goroutine needs to wait for multiple goroutines to complete their work. If you are waiting for a single goroutine, you can use the context cancellation pattern that you saw earlier. <a data-type="indexterm" data-primary="standard library" data-secondary="sync package" id="id2497"/><a data-type="indexterm" data-primary="sync package" data-secondary="sync.WaitGroup" id="ch12-wait"/><a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="waiting for goroutines to finish" id="ch12-wait2"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="waiting for others to finish" id="ch12-wait3"/><a data-type="indexterm" data-primary="WaitGroups in concurrency" id="ch12-wait4"/>But if you are waiting on several goroutines, you need to use a <code>WaitGroup</code>, which is found in the <code>sync</code> package in the standard library. Here is a simple example, which you can run on <a href="https://oreil.ly/hg7IF">The Go Playground</a> or in the <em>sample_code/waitgroup</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"/>
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">doThing1</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">doThing2</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">doThing3</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A <code>sync.WaitGroup</code> doesn’t need to be initialized, just declared, as its zero value is useful. There are three methods on <code>sync.WaitGroup</code>: <code>Add</code>, which increments the counter of goroutines to wait for; <code>Done</code>, which decrements the counter and is called by a goroutine when it is finished; and <code>Wait</code>, which pauses its goroutine until the counter hits zero. <code>Add</code> is usually called once, with the number of goroutines that will be launched. <code>Done</code> is called within the goroutine. To ensure that it is called, even if the goroutine panics, you use a <code>defer</code>.</p>

<p>You’ll notice that you don’t explicitly pass the <code>sync.WaitGroup</code>. There are two reasons. The first is that you must ensure that every place that uses a <code>sync.WaitGroup</code> is using the same instance. If you pass the <code>sync.WaitGroup</code> to the goroutine function and don’t use a pointer, then the function has a <em>copy</em>  and the call to <code>Done</code> won’t decrement the original <code>sync.WaitGroup</code>. By using a closure to capture the <code>sync.WaitGroup</code>, you are assured that every goroutine is referring to the same instance.</p>

<p>The second reason is design. Remember, you should keep concurrency out of your API. As you saw with channels earlier, the usual pattern is to launch a goroutine with a closure that wraps the business logic. The closure manages issues around concurrency, and the function provides the algorithm.</p>

<p>Let’s take a look at a more realistic example. As I mentioned earlier, when you have multiple goroutines writing to the same channel, you need to make sure that the channel being written to is closed only once. A <code>sync.WaitGroup</code> is perfect for this. Let’s see how it works in a function that processes the values in a channel concurrently, gathers the results into a slice, and returns the slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">processAndGather</code><code class="p">[</code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="nx">R</code><code class="w"> </code><code class="kt">any</code><code class="p">](</code><code class="nx">in</code><code class="w"> </code><code class="o">&lt;-</code><code class="kd">chan</code><code class="w"> </code><code class="nx">T</code><code class="p">,</code><code class="w"> </code><code class="nx">processor</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">T</code><code class="p">)</code><code class="w"> </code><code class="nx">R</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="nx">R</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">R</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"/>
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">num</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">in</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">out</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">processor</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nb">close</code><code class="p">(</code><code class="nx">out</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">result</code><code class="w"> </code><code class="p">[]</code><code class="nx">R</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">result</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">result</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this example, you launch a monitoring goroutine that waits until all the processing goroutines exit. When they do, the monitoring goroutine calls <code>close</code> on the output channel. The <code>for-range</code> channel loop exits when <code>out</code> is closed and the buffer is empty. Finally, the function returns the processed values. You can try out this code in the <em>sample_code/waitgroup_close_once</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.</p>

<p>While <code>WaitGroups</code> are handy, they shouldn’t be your first choice when coordinating goroutines. Use them only when you have something to clean up (like closing a channel they all write to) after all your worker goroutines exit.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id2498">
<h1>golang.org/x and errgroup.Group</h1>
<p>The Go authors maintain a set of utilities<a data-type="indexterm" data-primary="golang.org/x packages" data-secondary="errgroup.Group for WaitGroup errors" id="id2499"/><a data-type="indexterm" data-primary="errgroup package Group method for WaitGroup errors" id="id2500"/><a data-type="indexterm" data-primary="WaitGroups in concurrency" data-secondary="errgroup.Group for WaitGroups errors" id="id2501"/> that supplements the standard library. Collectively known as the <code>golang.org/x</code> packages, they include a package called <code>errgroup</code> that contains a type, <code>errgroup.Group</code>. It builds on top of <code>WaitGroup</code> to create a set of goroutines that stop processing when one of them returns an error. <a data-type="indexterm" data-primary="errgroup package Group method for WaitGroup errors" data-secondary="documentation URL" id="id2502"/>Read the <code>errgroup.Group</code> <a href="https://oreil.ly/_EVsK">documentation</a> to learn more.<a data-type="indexterm" data-startref="ch12-wait" id="id2503"/><a data-type="indexterm" data-startref="ch12-wait2" id="id2504"/><a data-type="indexterm" data-startref="ch12-wait3" id="id2505"/><a data-type="indexterm" data-startref="ch12-wait4" id="id2506"/></p>
</div></aside>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Run Code Exactly Once"><div class="sect2" id="sync_once">
<h2>Run Code Exactly Once</h2>

<p>As I covered in <a data-type="xref" href="ch10.html#pkg_init">“Avoiding the init Function if Possible”</a>, <code>init</code> should <a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="running code exactly once" id="ch12-once"/><a data-type="indexterm" data-primary="init function avoided" id="id2507"/><a data-type="indexterm" data-primary="lazy load" id="id2508"/>be reserved for initialization of effectively immutable package-level state. However, sometimes you want to <em>lazy load</em>, or call some initialization code exactly once after program launch time. This is usually because the initialization is relatively slow and may not even be needed every time your program runs. <a data-type="indexterm" data-primary="sync package" data-secondary="sync.Once type for running code once" id="id2509"/><a data-type="indexterm" data-primary="types" data-secondary="sync.Once type for running code once" id="id2510"/>The <code>sync</code> package includes a handy type called <code>Once</code> that enables this functionality. Let’s take a quick look at how it works. Say you have some code that takes a long time to initialize:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">SlowComplicatedParser</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Parse</code><code class="p">(</code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">initParser</code><code class="p">()</code><code class="w"> </code><code class="nx">SlowComplicatedParser</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// do all sorts of setup and loading here</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here’s how you use <code>sync.Once</code> to delay initialization of a <code>SlowComplicatedParser</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">parser</code><code class="w"> </code><code class="nx">SlowComplicatedParser</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">once</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">Once</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Parse</code><code class="p">(</code><code class="nx">dataToParse</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">once</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">parser</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">initParser</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">parser</code><code class="p">.</code><code class="nx">Parse</code><code class="p">(</code><code class="nx">dataToParse</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There are  two package-level variables: <code>parser</code>, which is of type <code>SlowComplicatedParser</code>, and <code>once</code>, which is of type <code>sync.Once</code>. As with 
<span class="keep-together"><code>sync.WaitGroup</code>,</span> you do not have to configure an instance of <code>sync.Once</code>. This is an example of <em>making the zero value useful</em>, which is a common pattern in Go.</p>

<p>As with <code>sync.WaitGroup</code>, you must make sure not to make a copy of an instance of <code>sync.Once</code>, because each copy has its own state to indicate whether it has already been used. Declaring a <code>sync.Once</code> instance inside a function is usually the wrong thing to do, as a new instance will be created on every function call and there will be no memory of previous invocations.</p>

<p>In the example, you want to make sure that <code>parser</code> is initialized only once, so you set the value of <code>parser</code> from within a closure that’s passed to the <code>Do</code> method on <code>once</code>. If <code>Parse</code> is called more than once, <code>once.Do</code> will not execute the closure again.</p>

<p>You can try out this code on <a href="https://oreil.ly/v7qtq">The Go Playground</a> or in the <em>sample_code/sync_once</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.<a data-type="indexterm" data-startref="ix_llll" id="id2511"/></p>

<p>Go 1.21 added helper functions<a data-type="indexterm" data-primary="sync package" data-secondary="sync.Once type for running code once" data-tertiary="helper functions" id="id2512"/><a data-type="indexterm" data-primary="helper functions" data-secondary="running a function exactly once" id="id2513"/><a data-type="indexterm" data-primary="functions" data-secondary="helper functions" data-see="helper functions" id="id2514"/> that make it easier to run a function exactly once: <code>sync.OnceFunc</code>, <code>sync.OnceValue</code>, and <code>sync.OnceValues</code>. The only difference between the three functions is the number of return values of the passed-in function (zero, one, or two, respectively). The <code>sync.OnceValue</code> and <code>sync.OnceValues</code> functions are generic, so they adapt to the type of the original function’s return values.</p>

<p>Using these functions is straightforward. You pass the original function to the helper function and get back a function that calls the original function only once. The values returned by the original function are cached. Here’s how you can use <code>sync.OnceValue</code> to rewrite the <code>Parse</code> function in the previous example:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">initParserCached</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="nx">SlowComplicatedParser</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">OnceValue</code><code class="p">(</code><code class="nx">initParser</code><code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Parse</code><code class="p">(</code><code class="nx">dataToParse</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">parser</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">initParserCached</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">parser</code><code class="p">.</code><code class="nx">Parse</code><code class="p">(</code><code class="nx">dataToParse</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The package-level <code>initParserCached</code> variable is assigned the function returned by <code>sync.OnceValue</code> when <code>initParser</code> is passed to it. The first time <code>initParserCached</code> is called, <code>initParser</code> is also called, and its return value is cached. Each subsequent time <code>initParserCached</code> is called, the cached value is returned. This means you can get rid of the <code>parser</code> package-level variable.</p>

<p>You can try out this code on <a href="https://oreil.ly/VrR-s">The Go Playground</a> or in the <em>sample_code/sync_value</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.<a data-type="indexterm" data-startref="ch12-once" id="id2515"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Put Your Concurrent Tools Together"><div class="sect2" id="id163">
<h2>Put Your Concurrent Tools Together</h2>

<p>Let’s go back to the example from<a data-type="indexterm" data-primary="concurrency" data-secondary="practices and patterns" data-tertiary="putting the tools together" id="ch12-tog"/><a data-type="indexterm" data-primary="tools" data-secondary="concurrency tools working together" id="ch12-tog2"/> the first section in the chapter. You have a function that calls three web services. You send data to two of those services, and then take the results of those two calls and send them to the third, returning the result. The entire process must take less than 50 milliseconds, or an error is returned.</p>

<p>You’ll start with the function you invoke:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">GatherAndProcess</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="nx">Input</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">COut</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancel</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Millisecond</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">cancel</code><code class="p">()</code><code class="w"/>

<code class="w">    </code><code class="nx">ab</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">newABProcessor</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">ab</code><code class="p">.</code><code class="nx">start</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">inputC</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ab</code><code class="p">.</code><code class="nx">wait</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">COut</code><code class="p">{},</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nx">c</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">newCProcessor</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">start</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">inputC</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">wait</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The first thing to do is set up a <code>context.Context</code> that times out in 50 milliseconds, as you saw in <a data-type="xref" href="#time_out">“Time Out Code”</a>.</p>

<p>After creating the context, use a <code>defer</code> to make sure the context’s <code>cancel</code> function is called. As I’ll discuss in <a data-type="xref" href="ch14.html#cancelation">“Cancellation”</a>, you must call this function, or resources leak.</p>

<p>You are using <code>A</code> and <code>B</code> as the names of the two services that are called in parallel, so you’ll make a new <code>abProcessor</code> to call them. You then start processing with a call to the <code>start</code> method, and then wait for your results with a call to the <code>wait</code> method.</p>

<p>When <code>wait</code> returns, you do a standard error check. If all is well, you call the third service, which you are calling <code>C</code>. The logic is the same as before. Processing is started with a call to the <code>start</code> method on the <code>cProcessor</code> and then you wait for the result with a call to the <code>wait</code> method on <code>cProcessor</code>. You then return the result of the <code>wait</code> method call.</p>

<p>This looks a lot like standard sequential code without concurrency. Let’s look at the <code>abProcessor</code> and <code>cProcessor</code> to see how the concurrency happens:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">abProcessor</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">outA</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="nx">aOut</code><code class="w"/>
<code class="w">    </code><code class="nx">outB</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="nx">bOut</code><code class="w"/>
<code class="w">    </code><code class="nx">errs</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">newABProcessor</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="nx">abProcessor</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">abProcessor</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">outA</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">aOut</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nx">outB</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">bOut</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nx">errs</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">error</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>abProcessor</code> has three fields, all of which are channels. They are <code>outA</code>, <code>outB</code>, and <code>errs</code>. You’ll see how you use all these channels next. Notice that every channel is buffered, so that the goroutines that write to them can exit after writing without waiting for a read to happen. The <code>errs</code> channel has a buffer size of <code>2</code>, because it could have up to two errors written to it.</p>

<p>Next is the implementation of the <code>start</code> method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="o">*</code><code class="nx">abProcessor</code><code class="p">)</code><code class="w"> </code><code class="nx">start</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="nx">Input</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">aOut</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">getResultA</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">A</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">p</code><code class="p">.</code><code class="nx">errs</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">p</code><code class="p">.</code><code class="nx">outA</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">aOut</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">bOut</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">getResultB</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">p</code><code class="p">.</code><code class="nx">errs</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">p</code><code class="p">.</code><code class="nx">outB</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">bOut</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>start</code> method launches two goroutines. The first one calls <code>getResultA</code> to talk to the <code>A</code> service. If the call returns an error, you write to the <code>errs</code> channel. Otherwise, you write to the <code>outA</code> channel. Since these channels are buffered, the goroutine will not hang, no matter which channel is written to. Also notice that you are passing the context along to <code>getResultA</code>, which allows it to cancel processing if the timeout happens.</p>

<p>The second goroutine is just like the first, only it calls <code>getResultB</code> and writes to the <code>outB</code> channel on success.</p>

<p>Let’s see what the <code>wait</code> method for <code>ABProcessor</code> looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="o">*</code><code class="nx">abProcessor</code><code class="p">)</code><code class="w"> </code><code class="nx">wait</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">cIn</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">cData</code><code class="w"> </code><code class="nx">cIn</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">2</code><code class="p">;</code><code class="w"> </code><code class="nx">count</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">p</code><code class="p">.</code><code class="nx">outA</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">cData</code><code class="p">.</code><code class="nx">a</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">a</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">p</code><code class="p">.</code><code class="nx">outB</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">cData</code><code class="p">.</code><code class="nx">b</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">b</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">p</code><code class="p">.</code><code class="nx">errs</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">cIn</code><code class="p">{},</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">cIn</code><code class="p">{},</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">cData</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>wait</code> method on <code>abProcessor</code> is the most complicated method you need to implement. It populates a struct of type <code>cIn</code>, which holds the data returned from calling the <code>A</code> service and the <code>B</code> service. You define your output variable, <code>cData</code>, as type <code>cIn</code>. You then have a <code>for</code> loop that counts to two, since you need to read from two channels to finish successfully. Inside the loop, you have a <code>select</code> statement. If you read a value on <code>outA</code>, you set the <code>a</code> field on <code>cData</code>. If you read a value on <code>outB</code>, you set the <code>b</code> field on <code>cData</code>. If you read a value on the <code>errs</code> channel, you return immediately with the error. Finally, if the context times out, you return immediately with the error from the context’s <code>Err</code> method.</p>

<p>Once you have read a value from both the <code>p.outA</code> channel and the <code>p.outB</code> channel, you exit the loop and return the input that you’re going to use with the <code>cProcessor</code>.</p>

<p>The <code>cProcessor</code> looks like a simpler version of the <code>abProcessor</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">cProcessor</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">outC</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="nx">COut</code><code class="w"/>
<code class="w">    </code><code class="nx">errs</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">newCProcessor</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="nx">cProcessor</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">cProcessor</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">outC</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">COut</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="nx">errs</code><code class="p">:</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">error</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="o">*</code><code class="nx">cProcessor</code><code class="p">)</code><code class="w"> </code><code class="nx">start</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">inputC</code><code class="w"> </code><code class="nx">cIn</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">cOut</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">getResultC</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">inputC</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">p</code><code class="p">.</code><code class="nx">errs</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">p</code><code class="p">.</code><code class="nx">outC</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">cOut</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="o">*</code><code class="nx">cProcessor</code><code class="p">)</code><code class="w"> </code><code class="nx">wait</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">COut</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">p</code><code class="p">.</code><code class="nx">outC</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">p</code><code class="p">.</code><code class="nx">errs</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">COut</code><code class="p">{},</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">COut</code><code class="p">{},</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>cProcessor</code> struct has one out channel and one error channel.</p>

<p>The <code>start</code> method on the <code>cProcessor</code> looks like the <code>start</code> method on the <code>abProcessor</code>. It launches a goroutine that calls <code>getResultC</code> with your input data, writes to the <code>errs</code> channel on an error, and writes to the <code>outC</code> channel on success.</p>

<p>Finally, the <code>wait</code> method on the <code>cProcessor</code> is a simple <code>select</code> statement that checks whether there’s a value to read from the <code>outC</code> channel, the <code>errs</code> channel, or the context’s <code>Done</code> channel.</p>

<p>By structuring code with goroutines, channels, and <code>select</code> statements, you separate the individual steps, allow independent parts to run and complete in any order, and cleanly exchange data between the dependent parts. In addition, you make sure that no part of the program hangs, and you properly handle timeouts set both within this function and from earlier functions in the call history. If you are not convinced that this is a better method for implementing concurrency, try to implement this in another language. You might be surprised at how difficult it is.</p>

<p>You can find the code for this concurrent pipeline in the <em>sample_code/pipeline</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.<a data-type="indexterm" data-startref="ix_lll" id="id2516"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2517"/><a data-type="indexterm" data-startref="ch12-tog" id="id2518"/><a data-type="indexterm" data-startref="ch12-tog2" id="id2519"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="When to Use Mutexes Instead of Channels"><div class="sect1" id="mutexes">
<h1>When to Use Mutexes Instead of Channels</h1>

<p>If you’ve had to coordinate access<a data-type="indexterm" data-primary="concurrency" data-secondary="channels" data-tertiary="mutexes used instead" id="ch12-mutt"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="mutexes used instead" id="ch12-mutt2"/><a data-type="indexterm" data-primary="mutexes instead of channels in concurrency" id="ch12-mutt3"/> to data across threads in other programming languages, you have probably used a <em>mutex</em>. This is short for <em>mutual exclusion</em>, and the job of a mutex is to limit the concurrent execution of some code or access to a shared piece of data. <a data-type="indexterm" data-primary="mutexes instead of channels in concurrency" data-secondary="critical section" id="id2520"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="mutexes used instead" data-tertiary="critical section" id="id2521"/>This protected part is called the 
<span class="keep-together"><em>critical section</em>.</span></p>

<p>There are good reasons Go’s creators designed channels and <code>select</code> to manage concurrency. The main problem with mutexes is that they obscure the flow of data through a program. When a value is passed from goroutine to goroutine over a series of channels, the data flow is clear. Access to the value is localized to a single goroutine at a time. When a mutex is used to protect a value, there is nothing to indicate which goroutine currently has ownership of the value, because access to the value is shared by all the concurrent processes. That makes it hard to understand the order of processing. There is a saying in the Go community to describe this philosophy: “Share memory by communicating; do not communicate by sharing memory.”</p>

<p>That said, sometimes it is clearer to use a mutex, and the Go standard library includes mutex implementations for these situations. The most common case is when your goroutines read or write a shared value, but don’t process the value. Let’s use an in-memory scoreboard for a multiplayer game as an example. You’ll first see how to implement this using channels. Here’s a function that you can launch as a goroutine to manage the scoreboard:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">scoreboardManager</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">in</code><code class="w"> </code><code class="o">&lt;-</code><code class="kd">chan</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">scoreboard</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">in</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">f</code><code class="p">(</code><code class="nx">scoreboard</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function declares a map and then listens on one channel for a function that reads or modifies the map and on a context’s Done channel to know when to shut down. Let’s create a type with a method to write a value to the map:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">ChannelScoreboardManager</code><code class="w"> </code><code class="kd">chan</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">NewChannelScoreboardManager</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="nx">ChannelScoreboardManager</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="nx">ChannelScoreboardManager</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="nx">scoreboardManager</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">ch</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ch</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">csm</code><code class="w"> </code><code class="nx">ChannelScoreboardManager</code><code class="p">)</code><code class="w"> </code><code class="nx">Update</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">csm</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">m</code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">val</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The update method is very straightforward: just pass a function that puts a value into the map. But how about reading from the scoreboard? You need to return a value back. That means creating a channel that’s written to within the passed-in function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">csm</code><code class="w"> </code><code class="nx">ChannelScoreboardManager</code><code class="p">)</code><code class="w"> </code><code class="nx">Read</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">type</code><code class="w"> </code><code class="nx">Result</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="w">        </code><code class="nx">ok</code><code class="w">  </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">resultCh</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="nx">Result</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">csm</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">m</code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code class="w"/>
<code class="w">        </code><code class="nx">resultCh</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">Result</code><code class="p">{</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">resultCh</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">result</code><code class="p">.</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">result</code><code class="p">.</code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>While this code works, it’s cumbersome and allows only a single reader at a time. A better approach is to use a mutex. <a data-type="indexterm" data-primary="standard library" data-secondary="sync package" id="id2522"/><a data-type="indexterm" data-primary="sync package" data-secondary="sync.Mutex" id="id2523"/>The standard library has two mutex implementations, both in the <code>sync</code> package. The first, <code>Mutex</code>, has two methods, <code>Lock</code> and <code>Unlock</code>. Calling <code>Lock</code> causes the current goroutine to pause as long as another goroutine is currently in the critical section. When the critical section is clear, the lock is <em>acquired</em> by the current goroutine, and the code in the critical section is executed. A call to the <code>Unlock</code> method on the <code>Mutex</code> marks the end of the critical 
<span class="keep-together">section.</span></p>

<p>The second mutex implementation<a data-type="indexterm" data-primary="sync package" data-secondary="sync.RWMutex" id="id2524"/>, called <code>RWMutex</code>, allows you to have both reader locks and writer locks. While only one writer can be in the critical section at a time, reader locks are shared; multiple readers can be in the critical section at once. The writer lock is managed with the <code>Lock</code> and <code>Unlock</code> methods, while the reader lock is managed with <code>RLock</code> and <code>RUnlock</code> methods.</p>

<p>Anytime you acquire a mutex lock,<a data-type="indexterm" data-primary="defer keyword" data-secondary="Mutex Unlock called after Lock or RLock" id="id2525"/> you must make sure that you release the lock. Use a <code>defer</code> statement to call <code>Unlock</code> immediately after calling <code>Lock</code> or <code>RLock</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MutexScoreboardManager</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">l</code><code class="w">          </code><code class="nx">sync</code><code class="p">.</code><code class="nx">RWMutex</code><code class="w"/>
<code class="w">    </code><code class="nx">scoreboard</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">NewMutexScoreboardManager</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="nx">MutexScoreboardManager</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">MutexScoreboardManager</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">scoreboard</code><code class="p">:</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{},</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">msm</code><code class="w"> </code><code class="o">*</code><code class="nx">MutexScoreboardManager</code><code class="p">)</code><code class="w"> </code><code class="nx">Update</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">msm</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">msm</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">msm</code><code class="p">.</code><code class="nx">scoreboard</code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">val</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">msm</code><code class="w"> </code><code class="o">*</code><code class="nx">MutexScoreboardManager</code><code class="p">)</code><code class="w"> </code><code class="nx">Read</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">msm</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">RLock</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">msm</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">RUnlock</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">msm</code><code class="p">.</code><code class="nx">scoreboard</code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">val</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find the example in the <em>sample_code/mutex</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2526"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2527"/></p>

<p>Now that you’ve seen an implementation using mutexes, carefully consider your options before using one.<a data-type="indexterm" data-primary="Cox-Buday, Katherine" id="id2528"/><a data-type="indexterm" data-primary="Concurrency in Go (Cox-Buday)" id="id2529"/> Katherine Cox-Buday’s excellent book <a href="https://oreil.ly/G7bpu"><em>Concurrency in Go</em></a> (O’Reilly) includes a decision tree to help you decide whether to use channels or mutexes:</p>

<ul>
<li>
<p>If you are coordinating goroutines or tracking a value as it is transformed by a series of goroutines, use channels.</p>
</li>
<li>
<p>If you are sharing access to a field in a struct, use mutexes.</p>
</li>
<li>
<p>If you discover a critical performance issue when using channels (see <a data-type="xref" href="ch15.html#benchmarking">“Using Benchmarks”</a> to learn how to do this), and you cannot find any other way to fix the issue, modify your code to use a mutex.</p>
</li>
</ul>

<p>Since your scoreboard is a field in a struct and there’s no transfer of the scoreboard, using a mutex makes sense. This is a good use for a mutex only because the data is stored in-memory. When data is stored in external services, like an HTTP server or a database, don’t use a mutex to guard access to the system.</p>

<p>Mutexes require you to do more bookkeeping. For example, you must correctly pair locks and unlocks, or your programs will likely deadlock. The example both acquires and releases the locks within the same method. Another issue is that mutexes in Go aren’t <em>reentrant</em>. If a goroutine tries to acquire the same lock twice, it deadlocks, waiting for itself to release the lock. This is different from languages like Java, where locks are reentrant.</p>

<p>Nonreentrant locks make it tricky to acquire a lock in a function that calls itself recursively. You must release the lock before the recursive function call. In general, be 
<span class="keep-together">careful</span> when holding a lock while making a function call, because you don’t know what locks are going to be acquired in those calls. If your function calls another function that tries to acquire the same mutex lock, the goroutine deadlocks.</p>

<p>Like <code>sync.WaitGroup</code> and <code>sync.Once</code>, mutexes<a data-type="indexterm" data-primary="mutexes instead of channels in concurrency" data-secondary="passed via pointer" id="id2530"/><a data-type="indexterm" data-primary="channels in concurrency" data-secondary="mutexes used instead" data-tertiary="passed via pointer" id="id2531"/> must never be copied. If they are passed to a function or accessed as a field on a struct, it must be via a pointer. If a mutex is copied, its lock won’t be shared.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Never try to access a variable from multiple goroutines unless you acquire a mutex for that variable first. It can cause odd errors that are hard to trace. See <a data-type="xref" href="ch15.html#race_checker">“Finding Concurrency Problems with the 
<span class="keep-together">Data Race Detector</span>”</a> to learn how to detect these problems.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id2532">
<h1>sync.Map—This Is Not the Map You Are Looking For</h1>
<p>When looking through the <code>sync</code> package, <a data-type="indexterm" data-primary="sync package" data-secondary="sync.Map type" id="id2533"/><a data-type="indexterm" data-primary="concurrency" data-secondary="sync.Map type" id="id2534"/><a data-type="indexterm" data-primary="types" data-secondary="sync.Map" id="id2535"/>you’ll find a type called <code>Map</code>. It provides a concurrency-safe version of Go’s built-in <code>map</code>. Because of trade-offs in its implementation, <code>sync.Map</code> is appropriate only in very specific situations:</p>

<ul>
<li>
<p>When you have a shared map where key-value pairs are inserted once and read many times</p>
</li>
<li>
<p>When goroutines share the map, but don’t access each other’s keys and values</p>
</li>
</ul>

<p>Furthermore, because <code>sync.Map</code> was added to the standard library before the introduction of generics, <code>sync.Map</code> uses <code>any</code> as the type for its keys and values. This means the compiler cannot help you ensure that the right data types are used.</p>

<p>Given these limitations, in the rare situations where you need to share a map across multiple goroutines, use a built-in <code>map</code> protected by a <code>sync.RWMutex</code>.<a data-type="indexterm" data-startref="ch12-mutt" id="id2536"/><a data-type="indexterm" data-startref="ch12-mutt2" id="id2537"/><a data-type="indexterm" data-startref="ch12-mutt3" id="id2538"/></p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Atomics—You Probably Don’t Need These"><div class="sect1" id="id165">
<h1>Atomics—You Probably Don’t Need These</h1>

<p>In addition to mutexes, Go provides another<a data-type="indexterm" data-primary="concurrency" data-secondary="atomic variables" id="id2539"/><a data-type="indexterm" data-primary="variables" data-secondary="atomic variables" id="id2540"/><a data-type="indexterm" data-primary="atomic variables" id="id2541"/> way to keep data consistent across multiple threads. The <code>sync/atomic</code> package provides access to the <em>atomic variable</em> operations built into modern CPUs to add, swap, load, store, or compare and swap (CAS) a value that fits into a single register.</p>

<p>If you need to squeeze out every last bit of performance and are an expert on writing concurrent code, you’ll be glad that Go includes atomic support. For everyone else, use goroutines and mutexes to manage your concurrency needs.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Where to Learn More About Concurrency"><div class="sect1" id="id166">
<h1>Where to Learn More About Concurrency</h1>

<p>I’ve covered a few simple concurrency patterns here, but there are many more. In fact, you could write an entire book on how to properly implement various concurrency patterns in Go, and, <a data-type="indexterm" data-primary="Concurrency in Go (Cox-Buday)" id="id2542"/><a data-type="indexterm" data-primary="Cox-Buday, Katherine" id="id2543"/>luckily, Katherine Cox-Buday has. I’ve already mentioned <em>Concurrency in Go</em>, when discussing how to decide between mutexes or channels, but it’s an excellent resource on all things involving Go and concurrency. Check out her book if you want to learn more.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id289">
<h1>Exercises</h1>

<p>Using concurrency effectively is one of the most important skills for a Go developer. Work through these exercises to see if you have mastered them. The solutions are available in the <em>exercise_solutions</em> directory in the <a href="https://oreil.ly/uSQBs">Chapter 12 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2544"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 12" data-tertiary-sortas="lll" id="id2545"/></p>
<ol>
<li>
<p>Create a function that launches three goroutines that communicate using a channel. The first two goroutines each write 10 numbers to the channel. The third goroutine reads all the numbers from the channel and prints them out. The function should exit when all values have been printed out. Make sure that none of the goroutines leak. You can create additional goroutines if needed.</p>
</li>
<li>
<p>Create a function that launches two goroutines. Each goroutine writes 10 numbers to its own channel. Use a <code>for-select</code> loop to read from both channels, printing out the number and the goroutine that wrote the value. Make sure that your function exits after all values are read and that none of your goroutines leak.</p>
</li>
<li>
<p>Write a function that builds a <code>map[int]float64</code> where the keys are the numbers from 0 (inclusive) to 100,000 (exclusive) and the values are the square roots of those numbers (use the <a href="https://oreil.ly/DPNYi"><code>math.Sqrt</code></a> function to calculate square roots). Use <code>sync.OnceValue</code> to generate a function that caches the <code>map</code> returned by this function and use the cached value to look up square roots for every 1,000th number from 0 to 100,000.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id354">
<h1>Wrapping Up</h1>

<p>In this chapter, you’ve looked at concurrency and learned why Go’s approach is simpler than more traditional concurrency mechanisms. In doing so, you’ve also learned when you should use concurrency as well as a few concurrency rules and patterns. In the next chapter, you’re going to take a quick look at Go’s standard library, which embraces a “batteries included” ethos for modern computing.</p>
</div></section>
</div></section></div>
</div>
</body></html>