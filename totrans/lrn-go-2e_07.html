<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Types, Methods, and Interfaces"><div class="chapter" id="unique_chapter_id_07">
<h1><span class="label">Chapter 7. </span>Types, Methods, and Interfaces</h1>


<p>As you saw in earlier chapters, <a data-type="indexterm" data-primary="types" data-secondary="about Go" id="id1556"/>Go is a statically typed language with both built-in types and user-defined types. Like most modern languages, Go allows you to attach methods to types. It also has type abstraction, allowing you to write code that invokes methods without explicitly specifying the implementation.</p>

<p>However, Go’s approach to methods, interfaces, and types is very different from that of most other languages in common use today. Go is designed to encourage the best practices advocated by software engineers, avoiding inheritance while encouraging composition. In this chapter, you’ll take a look at types, methods, and interfaces, and see how to use them to build testable and maintainable programs.</p>






<section data-type="sect1" data-pdf-bookmark="Types in Go"><div class="sect1" id="id77">
<h1>Types in Go</h1>

<p>Back in <a data-type="xref" href="ch03.html#struct_first_look">“Structs”</a>, you saw how to define a struct type:<a data-type="indexterm" data-primary="types" data-secondary="about Go" data-tertiary="types in Go" id="id1557"/><a data-type="indexterm" data-primary="structs" data-secondary="declaration" data-tertiary="as user-defined type with underlying struct" data-tertiary-sortas="user-defined type" id="id1558"/><a data-type="indexterm" data-primary="keywords" data-secondary="type" data-tertiary="structs" id="id1559"/><a data-type="indexterm" data-primary="struct keyword" id="id1560"/><a data-type="indexterm" data-primary="type keyword" data-secondary="structs" id="id1561"/><a data-type="indexterm" data-primary="type keyword" id="id1562"/><a data-type="indexterm" data-primary="keywords" data-secondary="type" id="id1563"/><a data-type="indexterm" data-primary="types" data-secondary="user-defined types" id="id1564"/><a data-type="indexterm" data-primary="user-defined types" id="id1565"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">FirstName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">LastName</code><code class="w">  </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">       </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This should be read as declaring a user-defined type with the name <code>Person</code> to have the <em>underlying type</em> of the struct literal that follows. <a data-type="indexterm" data-primary="concrete types" data-secondary="examples" id="id1566"/>In addition to struct literals, you can use any primitive type or compound type literal to define a concrete type. Here are a few examples:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Score</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">Converter</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="kt">string</code><code class="p">)</code><code class="nx">Score</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">TeamScores</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">Score</code><code class="w"/></pre>

<p>Go allows you to declare a type at any block level, from the package block down. However, you can access the type only from within its scope. The only exceptions are types exported from other packages. I’ll talk more about those in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To make it easier to talk about types, I’ll define a couple of terms. <a data-type="indexterm" data-primary="abstract types" id="id1567"/><a data-type="indexterm" data-primary="types" data-secondary="abstract types" id="id1568"/><a data-type="indexterm" data-primary="concrete types" id="id1569"/><a data-type="indexterm" data-primary="types" data-secondary="concrete types" id="id1570"/>An <em>abstract type</em> is one that specifies <em>what</em> a type should do but not <em>how</em> it is done. A <em>concrete type</em> specifies what and how. This means that tthe type has a specified way to store its data and provides an implementation of any methods declared on the type. While all types in Go are either abstract or concrete, some languages allow hybrid types, such as abstract classes or interfaces with default methods in Java.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Methods"><div class="sect1" id="methods">
<h1>Methods</h1>

<p>Like most modern languages, Go supports methods on user-defined types.<a data-type="indexterm" data-primary="user-defined types" data-secondary="methods" id="id1571"/><a data-type="indexterm" data-primary="methods" data-secondary="about" id="id1572"/><a data-type="indexterm" data-primary="types" data-secondary="user-defined types" data-tertiary="methods" id="ch07-metd"/></p>

<p>The methods for a type are defined at the package block level:<a data-type="indexterm" data-primary="package blocks" data-secondary="method definitions" id="id1573"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">FirstName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">LastName</code><code class="w">  </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">       </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="nx">Person</code><code class="p">)</code><code class="w"> </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%s %s, age %d"</code><code class="p">,</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">FirstName</code><code class="p">,</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">LastName</code><code class="p">,</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">Age</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Method declarations look like<a data-type="indexterm" data-primary="methods" data-secondary="declaring" id="id1574"/><a data-type="indexterm" data-primary="user-defined types" data-secondary="methods" data-tertiary="declaring" id="id1575"/><a data-type="indexterm" data-primary="methods" data-secondary="declaring" data-tertiary="receiver specification" id="id1576"/><a data-type="indexterm" data-primary="receiver specification of methods" id="id1577"/><a data-type="indexterm" data-primary="func keyword" data-secondary="method declarations" id="id1578"/><a data-type="indexterm" data-primary="keywords" data-secondary="func" data-tertiary="method declarations" id="id1579"/><a data-type="indexterm" data-primary="methods" data-secondary="declaring" data-tertiary="functions versus" id="id1580"/><a data-type="indexterm" data-primary="functions" data-secondary="declaring" data-tertiary="methods versus" id="id1581"/> function declarations, with one addition: the <em>receiver</em> specification. The receiver appears between the keyword <code>func</code> and the name of the method. Like all other variable declarations, the receiver name appears before the type. By convention, the receiver name is a short abbreviation of the type’s name, usually its first letter. It is nonidiomatic to use <code>this</code> or <code>self</code>.</p>

<p>There is one key difference between declaring methods and functions: methods can be defined <em>only</em> at the package block level, while functions can be defined inside any block.</p>

<p>Just like functions, <a data-type="indexterm" data-primary="functions" data-secondary="no overloading" id="id1582"/><a data-type="indexterm" data-primary="methods" data-secondary="no overloading" id="id1583"/>method names cannot be overloaded. You can use the same method names for different types, but you can’t use the same method name for two different methods on the same type. While this philosophy feels limiting when coming from languages that have method overloading, not reusing names is part of Go’s philosophy of making clear what your code is doing.</p>

<p class="pagebreak-before">I’ll talk more about packages in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>, but be aware that methods must be declared in the same package as their associated type; Go doesn’t allow you to add methods to types you don’t control. While you can define a method in a different file within the same package as the type declaration, it is best to keep your type definition and its associated methods together so that it’s easy to follow the implementation.</p>

<p>Method invocations should look familiar to those who have used methods in other languages:<a data-type="indexterm" data-primary="methods" data-secondary="invoking" id="id1584"/><a data-type="indexterm" data-primary="user-defined types" data-secondary="methods" data-tertiary="invoking" id="id1585"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">p</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Person</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">FirstName</code><code class="p">:</code><code class="w"> </code><code class="s">"Fred"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">LastName</code><code class="p">:</code><code class="w">  </code><code class="s">"Fredson"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="p">:</code><code class="w">       </code><code class="mi">52</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">output</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/></pre>








<section data-type="sect2" data-pdf-bookmark="Pointer Receivers and Value Receivers"><div class="sect2" id="pointer_value_receivers">
<h2>Pointer Receivers and Value Receivers</h2>

<p>As I covered in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>, Go uses<a data-type="indexterm" data-primary="pointers" data-secondary="indicating mutable parameters" id="id1586"/><a data-type="indexterm" data-primary="parameters" data-secondary="pointers indicating mutable parameters" id="id1587"/><a data-type="indexterm" data-primary="pointer type" data-secondary="pointer receivers" id="ch07-pore"/><a data-type="indexterm" data-primary="pointers" data-secondary="pointer type" data-tertiary="pointer receivers" id="ch07-pore2"/><a data-type="indexterm" data-primary="pointer receivers" id="ch07-pore3"/><a data-type="indexterm" data-primary="methods" data-secondary="pointer receivers" id="ch07-pore4"/><a data-type="indexterm" data-primary="types" data-secondary="pointer type" data-tertiary="pointer receivers" id="ch07-pore5"/><a data-type="indexterm" data-primary="methods" data-secondary="value receivers" id="ch07-pore6"/><a data-type="indexterm" data-primary="value receivers" id="ch07-pore7"/><a data-type="indexterm" data-primary="types" data-secondary="value type of value receivers" id="ch07-pore8"/><a data-type="indexterm" data-primary="value type of value receivers" id="ch07-pore9"/> parameters of pointer type to indicate that a parameter might be modified by the function. The same rules apply for method receivers too. They can be <em>pointer receivers</em> (the type is a pointer) or <em>value receivers</em> (the type is a value type). The following rules help you determine when to use each kind of receiver:</p>

<ul>
<li>
<p>If your method modifies the receiver, you <em>must</em> use a pointer receiver.</p>
</li>
<li>
<p>If your method needs to handle <code>nil</code> instances (see <a data-type="xref" href="#nil_instances">“Code Your Methods for nil Instances”</a>), then it <em>must</em> use a pointer receiver.</p>
</li>
<li>
<p>If your method doesn’t modify the receiver, you <em>can</em> use a value receiver.</p>
</li>
</ul>

<p>Whether you use a value receiver for a method that doesn’t modify the receiver depends on the other methods declared on the type. When a type has <em>any</em> pointer receiver methods, a common practice is to be consistent and use pointer receivers for <em>all</em> methods, even the ones that don’t modify the receiver.</p>

<p>Here’s some simple code to demonstrate pointer and value receivers. It starts with a type that has two methods on it, one using a value receiver, the other with a pointer receiver:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Counter</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">total</code><code class="w">       </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">lastUpdated</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Time</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="o">*</code><code class="nx">Counter</code><code class="p">)</code><code class="w"> </code><code class="nx">Increment</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">total</code><code class="o">++</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">lastUpdated</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="nx">Counter</code><code class="p">)</code><code class="w"> </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"total: %d, last updated: %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">total</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">lastUpdated</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can then try out these methods with the following code. You can run it yourself on <a href="https://oreil.ly/aqY0i">The Go Playground</a> or use the code in the <em>sample_code/pointer_value</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1588"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1589"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">c</code><code class="w"> </code><code class="nx">Counter</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="nx">c</code><code class="p">.</code><code class="nx">Increment</code><code class="p">()</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/></pre>

<p>You should see the following output:</p>

<pre data-type="programlisting">total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001</pre>

<p>One thing you might notice is that you were able to call the pointer receiver method even though <code>c</code> is a value type. When you use a pointer receiver with a local variable that’s a value type, Go automatically takes the address of the local variable when calling the method. In this case, 
<span class="keep-together"><code>c.Increment()</code></span> is converted to <code>(&amp;c).Increment()</code>.</p>

<p>If you call a value receiver on a pointer variable, Go automatically dereferences the pointer when calling the method. In the code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">c</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">Counter</code><code class="p">{}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="nx">c</code><code class="p">.</code><code class="nx">Increment</code><code class="p">()</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/></pre>

<p>the call <code>c.String()</code> is silently converted to <code>(*c).String()</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you call a value receiver method<a data-type="indexterm" data-primary="panics" data-secondary="value receiver method called with nil value pointer instance" id="id1590"/> with pointer instance whose value is <code>nil</code>, your code will compile but will panic at runtime (I discuss panics in <a data-type="xref" href="ch09.html#panic_recover">“panic and recover”</a>).</p>
</div>

<p>Be aware that the rules for passing values to functions still apply. If you pass a value type to a function and call a pointer receiver method on the passed value, you are invoking the method on a <em>copy</em>. You can try out the following code on <a href="https://oreil.ly/bGdDi">The Go Playground</a> or use the code in the <em>sample_code/update_wrong</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doUpdateWrong</code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="nx">Counter</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">Increment</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in doUpdateWrong:"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">doUpdateRight</code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="o">*</code><code class="nx">Counter</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">Increment</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in doUpdateRight:"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">c</code><code class="w"> </code><code class="nx">Counter</code><code class="w"/>
<code class="w">    </code><code class="nx">doUpdateWrong</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="w">    </code><code class="nx">doUpdateRight</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">c</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When you run this code, you’ll get the following output:</p>

<pre data-type="programlisting">in doUpdateWrong: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC
    m=+0.000000001
in main: total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC
in doUpdateRight: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC
    m=+0.000000001
in main: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001</pre>

<p>The parameter in <code>doUpdateRight</code> is of type <code>*Counter</code>, which is a pointer instance. As you can see, you can call both <code>Increment</code> and <code>String</code> on it. <a data-type="indexterm" data-primary="method set" id="id1591"/><a data-type="indexterm" data-primary="pointer type" data-secondary="pointer receivers" data-tertiary="methods with value receiver methods in method set" id="id1592"/><a data-type="indexterm" data-primary="value receivers" data-secondary="methods in method set" id="id1593"/>Go considers both pointer and value receiver methods to be in the <em>method set</em> for a pointer instance. For a value instance, only the value receiver methods are in the method set. This seems like a pedantic detail right now, but I’ll come back to it when talking about interfaces in just a bit.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This can be confusing to new Go programmers (and, to be honest, to not-so-new Go programmers), but Go’s automatic conversion from pointer types to value types, and vice versa, is purely syntactic sugar. It is independent of the method set concept. Alexey Gronskiy has written a <a href="https://oreil.ly/i7P5_">blog post</a> that explores in detail why the method set of pointer instances have both pointer and value receiver methods, but the method set of value instances has only value receiver methods.</p>
</div>

<p>One final note: do not<a data-type="indexterm" data-primary="structs" data-secondary="direct field access encouraged" id="id1594"/><a data-type="indexterm" data-primary="methods" data-secondary="struct field direct access encouraged" id="id1595"/> write getter and setter methods for Go structs unless you need them to meet an interface (I’ll start covering interfaces in <a data-type="xref" href="#interfaces">“A Quick Lesson on Interfaces”</a>). Go encourages you to directly access a field. Reserve methods for business logic. The exceptions are when you need to update multiple fields as a single operation or when the update isn’t a straightforward assignment of a new value. The <code>Increment</code> method defined earlier demonstrates both of these properties.<a data-type="indexterm" data-startref="ch07-pore" id="id1596"/><a data-type="indexterm" data-startref="ch07-pore2" id="id1597"/><a data-type="indexterm" data-startref="ch07-pore3" id="id1598"/><a data-type="indexterm" data-startref="ch07-pore4" id="id1599"/><a data-type="indexterm" data-startref="ch07-pore5" id="id1600"/><a data-type="indexterm" data-startref="ch07-pore6" id="id1601"/><a data-type="indexterm" data-startref="ch07-pore7" id="id1602"/><a data-type="indexterm" data-startref="ch07-pore8" id="id1603"/><a data-type="indexterm" data-startref="ch07-pore9" id="id1604"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Code Your Methods for nil Instances"><div class="sect2" id="nil_instances">
<h2>Code Your Methods for nil Instances</h2>

<p>The  previous section covered pointer receivers,<a data-type="indexterm" data-primary="methods" data-secondary="nil instance handling" id="id1605"/><a data-type="indexterm" data-primary="nil" data-secondary="methods coded for nil instances" id="id1606"/><a data-type="indexterm" data-primary="methods" data-secondary="value receivers" data-tertiary="nil instance handling" id="id1607"/><a data-type="indexterm" data-primary="value receivers" data-secondary="nil instance handling" id="id1608"/><a data-type="indexterm" data-primary="methods" data-secondary="pointer receivers" data-tertiary="nil instance handling" id="id1609"/><a data-type="indexterm" data-primary="pointer receivers" data-secondary="nil instance handling" id="id1610"/> which might make you wonder what happens when you call a method on a <code>nil</code> instance. In most languages, this produces some sort of error. (Objective-C allows you to call a method on a <code>nil</code> instance, but it always does nothing.)</p>

<p>Go does something a little different. It actually tries to invoke the method. As mentioned earlier, if it’s a method with a value receiver, you’ll get a panic, since there is no value being pointed to by the pointer. If it’s a method with a pointer receiver, it can work if the method is written to handle the possibility of a <code>nil</code> instance.</p>

<p>In some cases, expecting a <code>nil</code> receiver makes the code simpler. Here’s an implementation of a binary tree that takes advantage of <code>nil</code> values for the receiver:<a data-type="indexterm" data-primary="binary trees" data-secondary="nil values for value receiver" id="id1611"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">IntTree</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val</code><code class="w">         </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">left</code><code class="p">,</code><code class="w"> </code><code class="nx">right</code><code class="w"> </code><code class="o">*</code><code class="nx">IntTree</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">it</code><code class="w"> </code><code class="o">*</code><code class="nx">IntTree</code><code class="p">)</code><code class="w"> </code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">IntTree</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">it</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">IntTree</code><code class="p">{</code><code class="nx">val</code><code class="p">:</code><code class="w"> </code><code class="nx">val</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">val</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">it</code><code class="p">.</code><code class="nx">left</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">left</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">val</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">it</code><code class="p">.</code><code class="nx">right</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">right</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">it</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">it</code><code class="w"> </code><code class="o">*</code><code class="nx">IntTree</code><code class="p">)</code><code class="w"> </code><code class="nx">Contains</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">it</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">val</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">left</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">val</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">right</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>Contains</code> method doesn’t modify the <code>*IntTree</code>, but it is declared with a pointer receiver. This demonstrates the rule mentioned previously about supporting a <code>nil</code> receiver. A method with a value receiver can’t check for <code>nil</code> and, as mentioned earlier, panics if invoked with a <code>nil</code> receiver.</p>
</div>

<p>The following code uses the tree. You can try it out on <a href="https://oreil.ly/-F2i-">The Go Playground</a> or use the code in the <em>sample_code/tree</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1612"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1613"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">it</code><code class="w"> </code><code class="o">*</code><code class="nx">IntTree</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">it</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">it</code><code class="p">.</code><code class="nx">Insert</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">it</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code><code class="w">  </code><code class="c1">// true</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">it</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="mi">12</code><code class="p">))</code><code class="w"> </code><code class="c1">// false</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>It’s very clever that Go allows you to call a method on a <code>nil</code> receiver, and there are situations where it is useful, like the previous tree node example. However, most of the time it’s not very useful. Pointer receivers work like pointer function parameters; it’s a copy of the pointer that’s passed into the method. Just like <code>nil</code> parameters passed to functions, if you change the copy of the pointer, you haven’t changed the original. This means you can’t write a pointer receiver method that handles <code>nil</code> and makes the original pointer non-nil.</p>

<p>If your method has a pointer receiver and won’t work for a <code>nil</code> receiver, you have to decide how your method should handle a <code>nil</code> receiver. One choice is to treat it as a fatal flaw, like trying to access a position in a slice beyond its length. In that case, don’t do anything and let the code panic. (Also make sure you write good tests, as discussed in <a data-type="xref" href="ch15.html#unique_chapter_id_15">Chapter 15</a>.) If a <code>nil</code> receiver is something that is recoverable, check for <code>nil</code> and return an error (I discuss errors in <a data-type="xref" href="ch09.html#unique_chapter_id_09">Chapter 9</a>).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Methods Are Functions Too"><div class="sect2" id="method_function">
<h2>Methods Are Functions Too</h2>

<p>Methods in Go are so much<a data-type="indexterm" data-primary="methods" data-secondary="functions replaced by methods" id="id1614"/><a data-type="indexterm" data-primary="functions" data-secondary="methods as replacements for" id="id1615"/> like functions that you can use a method as a replacement for a function anytime there’s a variable or parameter of a function type.</p>

<p>Let’s start with this simple type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Adder</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">start</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="nx">Adder</code><code class="p">)</code><code class="w"> </code><code class="nx">AddTo</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">start</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">val</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You create an instance of the type in the usual way and invoke its method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">myAdder</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Adder</code><code class="p">{</code><code class="nx">start</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">myAdder</code><code class="p">.</code><code class="nx">AddTo</code><code class="p">(</code><code class="mi">5</code><code class="p">))</code><code class="w"> </code><code class="c1">// prints 15</code><code class="w"/></pre>

<p class="pagebreak-before">You can also assign the method<a data-type="indexterm" data-primary="method value" id="id1616"/><a data-type="indexterm" data-primary="parameters" data-secondary="method passed to" id="id1617"/><a data-type="indexterm" data-primary="variables" data-secondary="method assigned to" id="id1618"/><a data-type="indexterm" data-primary="methods" data-secondary="as parameters or variables" data-secondary-sortas="parameters or variables" id="id1619"/> to a variable or pass it to a parameter of type <code>func(int)int</code>. This is called a <em>method value</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">f1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">myAdder</code><code class="p">.</code><code class="nx">AddTo</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f1</code><code class="p">(</code><code class="mi">10</code><code class="p">))</code><code class="w">           </code><code class="c1">// prints 20</code><code class="w"/></pre>

<p>A method value is a bit like a closure, since it can access the values in the fields of the instance from which it was created.</p>

<p>You can also create a function from the type itself.<a data-type="indexterm" data-primary="method expression" id="id1620"/> This is called a <em>method expression</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">f2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Adder</code><code class="p">.</code><code class="nx">AddTo</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f2</code><code class="p">(</code><code class="nx">myAdder</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">))</code><code class="w">  </code><code class="c1">// prints 25</code><code class="w"/></pre>

<p>In a method expression, the first parameter is the receiver for the method; the function signature is <code>func(Adder, int) int</code>.</p>

<p>Method values and method expressions aren’t clever corner cases. You’ll see one way to use them when you look at dependency injection in <a data-type="xref" href="#dependency_injection">“Implicit Interfaces Make Dependency Injection Easier”</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Functions Versus Methods"><div class="sect2" id="id282">
<h2>Functions Versus Methods</h2>

<p>Since you can use a method as a function,<a data-type="indexterm" data-primary="methods" data-secondary="functions replaced by methods" data-tertiary="when to use functions versus methods" id="id1621"/><a data-type="indexterm" data-primary="functions" data-secondary="methods as replacements for" data-tertiary="when to use methods versus functions" id="id1622"/> you might wonder when you should declare a function and when you should use a method.</p>

<p>The differentiator is whether your function depends on other data. As I’ve covered several times, package-level state should be effectively immutable. Anytime your logic depends on values that are configured at startup or changed while your program is running, those values should be stored in a struct, and that logic should be implemented as a method. If your logic depends only on the input parameters, it should be a function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Type Declarations Aren’t Inheritance"><div class="sect2" id="id81">
<h2>Type Declarations Aren’t Inheritance</h2>

<p>In addition to declaring types based<a data-type="indexterm" data-primary="user-defined types" data-secondary="based on another user-defined type" id="id1623"/><a data-type="indexterm" data-primary="types" data-secondary="user-defined types" data-tertiary="based on another user-defined type" id="id1624"/><a data-type="indexterm" data-primary="inheritance not a part of Go" id="id1625"/><a data-type="indexterm" data-primary="user-defined types" data-secondary="based on another user-defined type" data-tertiary="not inheritance" id="id1626"/><a data-type="indexterm" data-primary="methods" data-secondary="no inheritance from type based on type" id="id1627"/> on built-in Go types and struct literals, you can also declare a user-defined type based on another user-defined type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">HighScore</code><code class="w"> </code><code class="nx">Score</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">Employee</code><code class="w"> </code><code class="nx">Person</code><code class="w"/></pre>

<p>Many concepts can be considered “object-oriented,” but one stands out: <em>inheritance</em>. With inheritance, the state and methods of a <em>parent</em> type are declared to be available on a <em>child</em> type, and values of the child type can be substituted for the parent type.<sup><a data-type="noteref" id="id1628-marker" href="ch07.html#id1628">1</a></sup></p>

<p>Declaring a type based on another type looks a bit like inheritance but isn’t. The two types have the same underlying type, but that’s all. The types have no hierarchy. In languages with inheritance, a child instance can be used anywhere the parent instance is used. The child instance also has all the methods and  data  structures of  the  parent  instance.  That’s  not  the  case  in  Go.  You  can’t assign  an  instance  of  type  <code>HighScore</code> to  a  variable  of  type  <code>Score</code>, or  vice  versa,  without  a type conversion, nor can you assign either of them to a variable of type <code>int</code> without a type conversion. Furthermore, any methods defined on <code>Score</code> aren’t defined on <code>HighScore</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// assigning untyped constants is valid</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">300</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="nx">Score</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">100</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">hs</code><code class="w"> </code><code class="nx">HighScore</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">200</code><code class="w"/>
<code class="nx">hs</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">s</code><code class="w">                  </code><code class="c1">// compilation error!</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w">                   </code><code class="c1">// compilation error!</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">Score</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w">            </code><code class="c1">// ok</code><code class="w"/>
<code class="nx">hs</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">HighScore</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w">       </code><code class="c1">// ok</code><code class="w"/></pre>

<p>User-defined types whose underlying types are built-in types can be assigned literals and constants compatible with the underlying type. They can also be used with the operators for those types:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="nx">Score</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">50</code><code class="w"/>
<code class="nx">scoreWithBonus</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">100</code><code class="w"> </code><code class="c1">// type of scoreWithBonus is Score</code><code class="w"/></pre>
<div data-type="tip"><h6>Tip</h6>
<p>A type conversion between types that share an underlying type keeps the same underlying storage but associates different 
<span class="keep-together">methods.</span></p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Types Are Executable Documentation"><div class="sect2" id="id82">
<h2>Types Are Executable Documentation</h2>

<p>While it’s well understood that you should<a data-type="indexterm" data-primary="types" data-secondary="user-defined types" data-tertiary="executable documentation" id="id1629"/><a data-type="indexterm" data-primary="user-defined types" data-secondary="executable documentation" id="id1630"/><a data-type="indexterm" data-primary="methods" data-secondary="no inheritance from type based on type" data-tertiary="executable documentation" id="id1631"/> declare a struct type to hold a set of related data, it’s less clear when you should declare a user-defined type based on other built-in types or one user-defined type that’s based on another user-defined type. The short answer is that types are documentation. They make code clearer by providing a name for a concept and describing the kind of data that is expected. It’s clearer for someone reading your code when a method has a parameter of type <code>Percentage</code> than of type <code>int</code>, and it’s harder for it to be invoked with an invalid value.</p>

<p>The same logic applies when declaring one user-defined type based on another user-defined type. When you have the same underlying data, but different sets of operations to perform, make two types. Declaring one as being based on the other avoids some repetition and makes it clear that the two types are related.<a data-type="indexterm" data-startref="ch07-metd" id="id1632"/></p>
</div></section>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="iota Is for Enumerations—Sometimes"><div class="sect1" id="iota_section">
<h1>iota Is for Enumerations—Sometimes</h1>

<p>Many programming languages have the concept of enumerations,<a data-type="indexterm" data-primary="enumerations via iota" id="id1633"/><a data-type="indexterm" data-primary="iota for enumerations" id="ch07-iota"/> which allow you to specify that a type can have only a limited set of values. Go doesn’t have an enumeration type. Instead, it has <code>iota</code>, which lets you assign an increasing value to a set of constants.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The concept of <code>iota</code> comes <a data-type="indexterm" data-primary="iota for enumerations" data-secondary="origin of iota" id="id1634"/><a data-type="indexterm" data-primary="APL (A Programming Language) and iota" id="id1635"/>from the programming language APL (which stood for “A Programming Language”). To generate a list of the first three positive integers in APL, you write <code>ι3</code>, where <code>ι</code> is the lowercase Greek letter iota.</p>

<p>APL is famous for being so reliant on its own custom notation that it required computers with a special keyboard. For example, (~R∊R∘.×R)/R←1↓ιR is an APL program to find all the prime numbers up to the value of the variable R.</p>

<p>It may seem ironic that a language as focused on readability as Go would borrow a concept from a language that is concise to a fault, but this is why you should learn multiple programming languages: you can find inspiration everywhere.</p>
</div>

<p>When using <code>iota</code>, the best practice is to first define a type based on <code>int</code> that will represent all the valid values:<a data-type="indexterm" data-primary="types" data-secondary="iota enumeration type" id="id1636"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MailCategory</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>

<p>Next, use a <code>const</code> block to define a set of values for your type:<a data-type="indexterm" data-primary="const keyword" data-secondary="const block for iota set of values" id="id1637"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">Uncategorized</code><code class="w"> </code><code class="nx">MailCategory</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">iota</code><code class="w"/>
<code class="w">    </code><code class="nx">Personal</code><code class="w"/>
<code class="w">    </code><code class="nx">Spam</code><code class="w"/>
<code class="w">    </code><code class="nx">Social</code><code class="w"/>
<code class="w">    </code><code class="nx">Advertisements</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>The first constant in the <code>const</code> block has the type specified, and its value is set to <code>iota</code>. Every subsequent line has neither the type nor a value assigned to it. When the Go compiler sees this, it repeats the type and the assignment to all the subsequent constants in the block, which is <code>iota</code>. The value of <code>iota</code> increments for each constant defined in the <code>const</code> block, starting with <code>0</code>. This means that <code>0</code> is assigned to the first constant (<code>Uncategorized</code>), 1 to the second constant (<code>Personal</code>), and so on. When a new <code>const</code> block is created, <code>iota</code> is set back to 0.</p>

<p class="pagebreak-before">The value of <code>iota</code> increments for each constant in the <code>const</code> block, whether or not <code>iota</code> is used to define the value of a constant. The following code demonstrates what happens when <code>iota</code> is used intermittently in a <code>const</code> block:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">Field1</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">    </code><code class="nx">Field2</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="kc">iota</code><code class="w"/>
<code class="w">    </code><code class="nx">Field3</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="w">    </code><code class="nx">Field4</code><code class="w"/>
<code class="w">    </code><code class="nx">Field5</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">iota</code><code class="w"/>
<code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">Field1</code><code class="p">,</code><code class="w"> </code><code class="nx">Field2</code><code class="p">,</code><code class="w"> </code><code class="nx">Field3</code><code class="p">,</code><code class="w"> </code><code class="nx">Field4</code><code class="p">,</code><code class="w"> </code><code class="nx">Field5</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can run this code on <a href="https://oreil.ly/jTXxD">The Go Playground</a> and see the (perhaps unexpected) result:</p>

<pre data-type="programlisting">0 2 20 20 4</pre>

<p><code>Field2</code> is assigned <code>2</code> because <code>iota</code> has a value of <code>1</code> on the second line in the <code>const</code> block. <code>Field4</code> is assigned <code>20</code> because it has no type or value explicitly assigned, so it gets the value of the previous line with a type and assignment. Finally, <code>Field5</code> gets the value <code>4</code> because it is the fifth line and <code>iota</code> starts counting from <code>0</code>.</p>

<p>This is the best advice I’ve seen on <code>iota</code>:<a data-type="indexterm" data-primary="van Heumen, Danny" id="id1638"/><a data-type="indexterm" data-primary="iota for enumerations" data-secondary="advice on" id="id1639"/></p>
<blockquote>
<p>Don’t use <em>iota</em> for defining constants where its values are explicitly defined (elsewhere). For example, when implementing parts of a specification and the specification says which values are assigned to which constants, you should explicitly write the constant values. Use <em>iota</em> for “internal” purposes only. That is, where the constants are referred to by name rather than by value. That way, you can optimally enjoy <em>iota</em> by inserting new constants at any moment in time / location in the list without the risk of breaking everything.</p>
<p data-type="attribution"><a href="https://oreil.ly/3MKwn">Danny van Heumen</a></p>
</blockquote>

<p>The important thing to understand is that nothing in Go will stop you (or anyone else) from creating additional values of your type. Furthermore, if you insert a new identifier in the middle of your list of literals, all subsequent ones will be renumbered. This will break your application in a subtle way if those constants represented values in another system or in a database. Given these two limitations, <code>iota</code>-based enumerations make sense only when you care about being able to differentiate between a set of values and don’t particularly care what the value is behind the scenes. If the actual value matters, specify it explicitly.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Because you can assign a literal expression to a constant, you’ll see sample code that suggests you should use <code>iota</code> for cases like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">BitField</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">Field1</code><code class="w"> </code><code class="nx">BitField</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">&lt;&lt;</code><code class="w"> </code><code class="kc">iota</code><code class="w"> </code><code class="c1">// assigned 1</code><code class="w"/>
<code class="w">    </code><code class="nx">Field2</code><code class="w">                      </code><code class="c1">// assigned 2</code><code class="w"/>
<code class="w">    </code><code class="nx">Field3</code><code class="w">                      </code><code class="c1">// assigned 4</code><code class="w"/>
<code class="w">    </code><code class="nx">Field4</code><code class="w">                      </code><code class="c1">// assigned 8</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>While this is clever, be careful when using this pattern. If you do so, document what you are doing. As mentioned previously, using <code>iota</code> with constants is fragile when you care about the value. You don’t want a future maintainer to insert a new constant in the middle of the list and break your code.</p>
</div>

<p>Be aware that <code>iota</code> starts numbering from 0. If you are using your set of constants to represent different configuration states, the zero value might be useful. You saw this earlier in the <code>MailCategory</code> type. When mail first arrives, it is uncategorized, so the zero value makes sense. <a data-type="indexterm" data-primary="underscore (_)" data-secondary="first iota value when ignored" id="id1640"/><a data-type="indexterm" data-primary="_ (underscore)" data-secondary="first iota value when ignored" id="id1641"/>If there isn’t a sensical default value for your constants, a common pattern is to assign the first <code>iota</code> value in the constant block to <code>_</code> or to a constant that indicates the value is invalid. This makes it easy to detect when a variable has not been properly initialized.<a data-type="indexterm" data-startref="ch07-iota" id="id1642"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Use Embedding for Composition"><div class="sect1" id="struct_embedding">
<h1>Use Embedding for Composition</h1>

<p>The software engineering advice “Favor object composition over class inheritance” dates<a data-type="indexterm" data-primary="Design Patterns (Gamma, Helm, Johnson, and Vlissides)" id="id1643"/><a data-type="indexterm" data-primary="Gamma, Erich" id="id1644"/><a data-type="indexterm" data-primary="Helm, Richard" id="id1645"/><a data-type="indexterm" data-primary="Johnson, Ralph" id="id1646"/><a data-type="indexterm" data-primary="Vlissides, John" id="id1647"/><a data-type="indexterm" data-primary="Gang of Four book" id="id1648"/><a data-type="indexterm" data-primary="composition and promotion" id="id1649"/><a data-type="indexterm" data-primary="promotion and composition" id="id1650"/><a data-type="indexterm" data-primary="embedding for composition" id="id1651"/> back to at least the 1994 book <em>Design Patterns</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley), better known as the Gang of Four book. <a data-type="indexterm" data-primary="inheritance not a part of Go" data-secondary="code reuse via composition and promotion" id="id1652"/>While Go doesn’t have inheritance, it encourages code reuse via built-in support for composition and promotion:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Employee</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w">         </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">           </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">e</code><code class="w"> </code><code class="nx">Employee</code><code class="p">)</code><code class="w"> </code><code class="nx">Description</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%s (%s)"</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">ID</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Manager</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Employee</code><code class="w"/>
<code class="w">    </code><code class="nx">Reports</code><code class="w"> </code><code class="p">[]</code><code class="nx">Employee</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="nx">Manager</code><code class="p">)</code><code class="w"> </code><code class="nx">FindNewEmployees</code><code class="p">()</code><code class="w"> </code><code class="p">[]</code><code class="nx">Employee</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// do business logic</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Note that <code>Manager</code> contains a field of type <code>Employee</code>, <a data-type="indexterm" data-primary="embedding for composition" data-secondary="embedded field" id="id1653"/><a data-type="indexterm" data-primary="structs" data-secondary="embedded field methods promoted to containing struct" id="id1654"/>but no name is assigned to that field. This makes <code>Employee</code> an <em>embedded field</em>. Any fields or methods declared on an embedded field are <em>promoted</em> to the containing struct and can be invoked directly on it. That makes the following code valid:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Manager</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Employee</code><code class="p">:</code><code class="w"> </code><code class="nx">Employee</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Name</code><code class="p">:</code><code class="w"> </code><code class="s">"Bob Bobson"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">ID</code><code class="p">:</code><code class="w">   </code><code class="s">"12345"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="nx">Reports</code><code class="p">:</code><code class="w"> </code><code class="p">[]</code><code class="nx">Employee</code><code class="p">{},</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">.</code><code class="nx">ID</code><code class="p">)</code><code class="w">            </code><code class="c1">// prints 12345</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">m</code><code class="p">.</code><code class="nx">Description</code><code class="p">())</code><code class="w"> </code><code class="c1">// prints Bob Bobson (12345)</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can embed any type within a struct, not just another struct. This promotes the methods on the embedded type to the containing struct.</p>
</div>

<p>If the containing struct has <a data-type="indexterm" data-primary="structs" data-secondary="embedded field methods promoted to containing struct" data-tertiary="fields or methods with same name" id="id1655"/>fields or methods with the same name as an embedded field, you need to use the embedded field’s type to refer to the obscured fields or methods. If you have types defined like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Inner</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">X</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Outer</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Inner</code><code class="w"/>
<code class="w">    </code><code class="nx">X</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>you can access the <code>X</code> on <code>Inner</code> only by specifying <code>Inner</code> explicitly:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">o</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Outer</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Inner</code><code class="p">:</code><code class="w"> </code><code class="nx">Inner</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">X</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="nx">X</code><code class="p">:</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">X</code><code class="p">)</code><code class="w">       </code><code class="c1">// prints 20</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">Inner</code><code class="p">.</code><code class="nx">X</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints 10</code><code class="w"/></pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Embedding Is Not Inheritance"><div class="sect1" id="id240">
<h1>Embedding Is Not Inheritance</h1>

<p>Built-in embedding support is rare<a data-type="indexterm" data-primary="embedding for composition" data-secondary="embedding is not inheritance" id="id1656"/><a data-type="indexterm" data-primary="structs" data-secondary="embedded field methods promoted to containing struct" data-tertiary="embedding is not inheritance" id="id1657"/><a data-type="indexterm" data-primary="inheritance not a part of Go" data-secondary="embedding is not inheritance" id="id1658"/> in programming languages (I’m not aware of another popular language that supports it). Many developers who are familiar with inheritance (which is available in many languages) try to understand embedding by treating it as inheritance. That way lies tears. You cannot assign a variable of type <code>Manager</code> to a variable of type <code>Employee</code>. If you want to access the <code>Employee</code> field in <code>Manager</code>, you must do so explicitly. You can run the following code on <a href="https://oreil.ly/vBl7o">The Go Playground</a> or use the code in the <em>sample_code/embedding</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1659"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1660"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">eFail</code><code class="w"> </code><code class="nx">Employee</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">m</code><code class="w">        </code><code class="c1">// compilation error!</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">eOK</code><code class="w"> </code><code class="nx">Employee</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">m</code><code class="p">.</code><code class="nx">Employee</code><code class="w"> </code><code class="c1">// ok!</code><code class="w"/></pre>

<p>You’ll get the error:</p>

<pre data-type="programlisting">cannot use m (type Manager) as type Employee in assignment</pre>

<p>Furthermore, Go has no <em>dynamic dispatch</em> for concrete types. The methods on the embedded field have no idea they are embedded. If you have a method on an embedded field that calls another method on the embedded field, and the containing struct has a method of the same name, the method on the embedded field is invoked, not the method on the containing struct. This behavior is demonstrated in the following code, which you can run on <a href="https://oreil.ly/yN6bV">The Go Playground</a>, or use the code in the <em>sample_code/no_dispatch</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Inner</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">A</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="nx">Inner</code><code class="p">)</code><code class="w"> </code><code class="nx">IntPrinter</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"Inner: %d"</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="nx">Inner</code><code class="p">)</code><code class="w"> </code><code class="nx">Double</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="p">.</code><code class="nx">IntPrinter</code><code class="p">(</code><code class="nx">i</code><code class="p">.</code><code class="nx">A</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Outer</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Inner</code><code class="w"/>
<code class="w">    </code><code class="nx">S</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">o</code><code class="w"> </code><code class="nx">Outer</code><code class="p">)</code><code class="w"> </code><code class="nx">IntPrinter</code><code class="p">(</code><code class="nx">val</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"Outer: %d"</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">o</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Outer</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Inner</code><code class="p">:</code><code class="w"> </code><code class="nx">Inner</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">A</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">},</code><code class="w"/>
<code class="w">        </code><code class="nx">S</code><code class="p">:</code><code class="w"> </code><code class="s">"Hello"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">Double</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this code produces the following output:</p>

<pre data-type="programlisting">Inner: 20</pre>

<p>While embedding one concrete type inside another won’t allow you to treat the outer type as the inner type, <a data-type="indexterm" data-primary="method set" data-secondary="methods on embedded field and containing struct" id="id1661"/>the methods on an embedded field do count toward the <em>method set</em> of the containing struct. This means they can make the containing struct implement an interface.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="A Quick Lesson on Interfaces"><div class="sect1" id="interfaces">
<h1>A Quick Lesson on Interfaces</h1>

<p>While Go’s concurrency model<a data-type="indexterm" data-primary="interfaces" id="id1662"/><a data-type="indexterm" data-primary="types" data-secondary="abstract types" data-tertiary="interfaces" id="id1663"/><a data-type="indexterm" data-primary="abstract types" data-secondary="interfaces" id="id1664"/> (which I cover in <a data-type="xref" href="ch12.html#unique_chapter_id_12">Chapter 12</a>) gets all the publicity, the real star of Go’s design is its implicit interfaces, the only abstract type in Go. Let’s see what makes them so great.</p>

<p>Let’s start by taking a quick look at how<a data-type="indexterm" data-primary="interfaces" data-secondary="declaring" id="id1665"/><a data-type="indexterm" data-primary="interface keyword" id="id1666"/><a data-type="indexterm" data-primary="keywords" data-secondary="interface" id="id1667"/><a data-type="indexterm" data-primary="keywords" data-secondary="type" data-tertiary="interface" id="id1668"/><a data-type="indexterm" data-primary="type keyword" data-secondary="interface" id="id1669"/><a data-type="indexterm" data-primary="methods" data-secondary="interface declaration" id="id1670"/> to declare interfaces. At their core, interfaces are simple. Like other user-defined types, you use the <code>type</code> keyword.</p>

<p>Here’s the definition of the <code>Stringer</code> interface in the <code>fmt</code> package:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Stringer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">String</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In an interface declaration, <a data-type="indexterm" data-primary="interface literals" id="id1671"/><a data-type="indexterm" data-primary="literals" data-secondary="interface literals" id="id1672"/>an interface literal appears after the name of the interface type. It lists the methods that must be implemented by a concrete type to meet the interface. The methods defined by an interface are the method set of the 
<span class="keep-together">interface.</span> As I covered in <a data-type="xref" href="#pointer_value_receivers">“Pointer Receivers and Value Receivers”</a>, the method set of a pointer instance contains the methods defined with both pointer and value receivers, while the method set of a value instance contains only the methods with value receivers. Here’s a quick example using the <code>Counter</code> struct defined previously:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Incrementer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Increment</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">myStringer</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Stringer</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">myIncrementer</code><code class="w"> </code><code class="nx">Incrementer</code><code class="w"/>
<code class="nx">pointerCounter</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">Counter</code><code class="p">{}</code><code class="w"/>
<code class="nx">valueCounter</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Counter</code><code class="p">{}</code><code class="w"/>

<code class="nx">myStringer</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">pointerCounter</code><code class="w">    </code><code class="c1">// ok</code><code class="w"/>
<code class="nx">myStringer</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">valueCounter</code><code class="w">      </code><code class="c1">// ok</code><code class="w"/>
<code class="nx">myIncrementer</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">pointerCounter</code><code class="w"> </code><code class="c1">// ok</code><code class="w"/>
<code class="nx">myIncrementer</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">valueCounter</code><code class="w">   </code><code class="c1">// compile-time error!</code><code class="w"/></pre>

<p>Trying to compile this code results in the error <code>cannot use valueCounter (variable of type Counter) as Incrementer value in assignment: Counter does not implement Incrementer (method Increment has pointer receiver).</code></p>

<p>You can try this code on <a href="https://oreil.ly/yYx8Q">The Go Playground</a> or use the code in the <em>sample_code/method_set</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1673"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1674"/></p>

<p>Like other types, interfaces can be declared in any block.</p>

<p>Interfaces are usually <a data-type="indexterm" data-primary="interfaces" data-secondary="declaring" data-tertiary="named with “er” endings" id="id1675"/>named with “er” endings. You’ve already seen <code>fmt.Stringer</code>, but there are many more, including <code>io.Reader</code>, <code>io.Closer</code>, <code>io.ReadCloser</code>, <code>json.Marshaler</code>, and <code>http.Handler</code>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Interfaces Are Type-Safe Duck Typing"><div class="sect1" id="interface_duck_typing">
<h1>Interfaces Are Type-Safe Duck Typing</h1>

<p>So far, nothing that’s been said about the Go interface is much different from interfaces in other languages. <a data-type="indexterm" data-primary="interfaces" data-secondary="implicit implementation" id="id1676"/><a data-type="indexterm" data-primary="types" data-secondary="concrete types" data-tertiary="interface implicit implementation" id="id1677"/><a data-type="indexterm" data-primary="concrete types" data-secondary="interface implicit implementation" id="id1678"/><a data-type="indexterm" data-primary="method set" data-secondary="interface implicit implementation" id="id1679"/>What makes Go’s interfaces special is that they are implemented <em>implicitly</em>. As you’ve seen with the <code>Counter</code> struct type and the <code>Incrementer</code> interface type that you’ve used in previous examples, a concrete type does not declare that it implements an interface. If the method set for a concrete type contains all the methods in the method set for an interface, the concrete type implements the interface. Therefore, that the concrete type can be assigned to a variable or field declared to be of the type of the interface.</p>

<p>This implicit behavior makes interfaces<a data-type="indexterm" data-primary="interfaces" data-secondary="implicit implementation" data-tertiary="safety and decoupling, static and dynamic" id="ch07-duck"/> the most interesting thing about types in Go, because they enable both type safety and decoupling, bridging the functionality in both static and dynamic languages.</p>

<p>To understand why, let’s talk about why languages have interfaces. <a data-type="indexterm" data-primary="Design Patterns (Gamma, Helm, Johnson, and Vlissides)" id="id1680"/><a data-type="indexterm" data-primary="Gamma, Erich" id="id1681"/><a data-type="indexterm" data-primary="Helm, Richard" id="id1682"/><a data-type="indexterm" data-primary="Johnson, Ralph" id="id1683"/><a data-type="indexterm" data-primary="Vlissides, John" id="id1684"/>Earlier I mentioned that <em>Design Patterns</em> taught developers to favor composition over inheritance. Another piece of advice from the book is “Program to an interface, not an implementation.” Doing so allows you to depend on behavior, not on implementation, allowing you to swap implementations as needed. This allows your code to evolve over time, as requirements inevitably change.</p>

<p>Dynamically typed languages like Python, Ruby, and JavaScript don’t have interfaces. <a data-type="indexterm" data-primary="duck typing" id="id1685"/><a data-type="indexterm" data-primary="types" data-secondary="duck typing" id="id1686"/>Instead, those developers use <em>duck typing</em>, which is based on the expression “If it walks like a duck and quacks like a duck, it’s a duck.” The concept is that you can pass an instance of a type as a parameter to a function as long as the function can find a method to invoke that it expects:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">class</code> <code class="nc">Logic</code><code class="p">:</code>
    <code class="k">def</code> <code class="nf">process</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">data</code><code class="p">):</code>
        <code class="c1"># business logic</code>

<code class="k">def</code> <code class="nf">program</code><code class="p">(</code><code class="n">logic</code><code class="p">):</code>
    <code class="c1"># get data from somewhere</code>
    <code class="n">logic</code><code class="o">.</code><code class="n">process</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>

<code class="n">logicToUse</code> <code class="o">=</code> <code class="n">Logic</code><code class="p">()</code>
<code class="n">program</code><code class="p">(</code><code class="n">logicToUse</code><code class="p">)</code></pre>

<p>Duck typing might sound weird at first, but it’s been used to build large and successful systems. If you program in a statically typed language, this sounds like utter chaos. Without an explicit type being specified, it’s hard to know exactly what functionality should be expected. As new developers move on to a project or the existing developers forget what the code is doing, they have to trace through the code to identify the actual dependencies.</p>

<p>Java developers use a different pattern. They define an interface, create an implementation of the interface, but refer to the interface only in the client code:</p>

<pre data-type="programlisting" data-code-language="java"><code class="kd">public</code><code class="w"> </code><code class="kd">interface</code> <code class="nc">Logic</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">String</code><code class="w"> </code><code class="nf">process</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">data</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">LogicImpl</code><code class="w"> </code><code class="kd">implements</code><code class="w"> </code><code class="n">Logic</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="n">String</code><code class="w"> </code><code class="nf">process</code><code class="p">(</code><code class="n">String</code><code class="w"> </code><code class="n">data</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// business logic</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">class</code> <code class="nc">Client</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">private</code><code class="w"> </code><code class="kd">final</code><code class="w"> </code><code class="n">Logic</code><code class="w"> </code><code class="n">logic</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="c1">// this type is the interface, not the implementation</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="nf">Client</code><code class="p">(</code><code class="n">Logic</code><code class="w"> </code><code class="n">logic</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">logic</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">logic</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="kd">public</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">program</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// get data from somewhere</code><code class="w"/>
<code class="w">        </code><code class="k">this</code><code class="p">.</code><code class="na">logic</code><code class="p">.</code><code class="na">process</code><code class="p">(</code><code class="n">data</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">public</code><code class="w"> </code><code class="kd">static</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="nf">main</code><code class="p">(</code><code class="n">String</code><code class="o">[]</code><code class="w"> </code><code class="n">args</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">Logic</code><code class="w"> </code><code class="n">logic</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">LogicImpl</code><code class="p">();</code><code class="w"/>
<code class="w">    </code><code class="n">Client</code><code class="w"> </code><code class="n">client</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">new</code><code class="w"> </code><code class="n">Client</code><code class="p">(</code><code class="n">logic</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="n">client</code><code class="p">.</code><code class="na">program</code><code class="p">();</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Dynamic language developers look at the explicit interfaces in Java and don’t see how you can possibly refactor your code over time when you have explicit dependencies. Switching to a new implementation from a different provider means rewriting your code to depend on a new interface.</p>

<p>Go’s developers decided that both groups are right. If your application is going to grow and change over time, you need flexibility to change implementation. However, in order for people to understand what your code is doing (as new people work on the same code over time), you also need to specify what the code depends on. That’s where implicit interfaces come in. Go code is a blend of the previous two styles:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">LogicProvider</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">lp</code><code class="w"> </code><code class="nx">LogicProvider</code><code class="p">)</code><code class="w"> </code><code class="nx">Process</code><code class="p">(</code><code class="nx">data</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// business logic</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Logic</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Process</code><code class="p">(</code><code class="nx">data</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Client</code><code class="w"> </code><code class="kd">struct</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">L</code><code class="w"> </code><code class="nx">Logic</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="nx">Client</code><code class="p">)</code><code class="w"> </code><code class="nx">Program</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// get data from somewhere</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">L</code><code class="p">.</code><code class="nx">Process</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Client</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">L</code><code class="p">:</code><code class="w"> </code><code class="nx">LogicProvider</code><code class="p">{},</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">Program</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The Go code provides an interface, but only the caller (<code>Client</code>) knows about it; nothing is declared on <code>LogicProvider</code> to indicate that it meets the interface. This is sufficient to both allow a new logic provider in the future and provide executable documentation to ensure that any type passed into the client will match the client’s need.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Interfaces specify what callers need. The client code defines the interface to specify what functionality it requires.</p>
</div>

<p>This doesn’t mean that interfaces can’t be shared.<a data-type="indexterm" data-primary="interfaces" data-secondary="standard interfaces" id="id1687"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="standard interface" id="id1688"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Writer" data-tertiary="standard interface" id="id1689"/><a data-type="indexterm" data-primary="standard library" data-secondary="io package" id="id1690"/><a data-type="indexterm" data-primary="io package" data-secondary="standard interfaces" id="id1691"/><a data-type="indexterm" data-primary="interfaces" data-secondary="standard interfaces" data-tertiary="io package" id="id1692"/> You’ve already seen several interfaces in the standard library that are used for input and output. Having a standard interface is powerful; if you write your code to work with <code>io.Reader</code> and <code>io.Writer</code>, it will function correctly whether it is writing to a file on local disk or a value in memory.</p>

<p>Furthermore, using standard interfaces<a data-type="indexterm" data-primary="interfaces" data-secondary="standard interfaces" data-tertiary="interface instance returning type implementing same interface" id="id1693"/><a data-type="indexterm" data-primary="decorator pattern with standard interfaces" id="id1694"/> encourages the <em>decorator pattern</em>. It is common in Go to write factory functions that take in an instance of an interface and return another type that implements the same interface. For example, say you have a function with the following definition:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">r</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"/></pre>

<p>You can process data from a file with the following code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="k">return</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code><code class="w"/></pre>

<p>The <code>os.File</code> instance returned by <code>os.Open</code> <a data-type="indexterm" data-primary="os package" data-secondary="os.File with io.Reader interface" id="id1695"/><a data-type="indexterm" data-primary="os package" data-secondary="os.Open" id="id1696"/>meets the <code>io.Reader</code> interface and can be used in any code that reads in data. If the file is gzip-compressed, you can wrap the <code>io.Reader</code> in another <code>io.Reader</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="nx">gz</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">gzip</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">gz</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="k">return</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">gz</code><code class="p">)</code><code class="w"/></pre>

<p>Now the exact same code that was reading from an uncompressed file is reading from a compressed file instead.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If an interface in the standard library describes what your code needs, use it! Commonly used interfaces include <code>io.Reader</code>, <code>io.Writer</code>, and <code>io.Closer</code>.</p>
</div>

<p>It’s perfectly fine for a type that meets an interface to specify additional methods that aren’t part of the interface. One set of client code may not care about those methods, but others do. For example, the <code>io.File</code> type also meets the <code>io.Writer</code> interface. If your code cares only about reading from a file, use the <code>io.Reader</code> interface to refer to the file instance and ignore the other methods.<a data-type="indexterm" data-startref="ch07-duck" id="id1697"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Embedding and Interfaces"><div class="sect1" id="embed_interface">
<h1>Embedding and Interfaces</h1>

<p>Embedding  is not only for structs.<a data-type="indexterm" data-primary="interfaces" data-secondary="embedding and" id="id1698"/><a data-type="indexterm" data-primary="embedding an interface in an interface" id="id1699"/> You can also embed an interface in an interface. For example, the <code>io.ReadCloser</code> interface is built out of an <code>io.Reader</code> and an <code>io.Closer</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Reader</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Read</code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Closer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Close</code><code class="p">()</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">ReadCloser</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Reader</code><code class="w"/>
<code class="w">        </code><code class="nx">Closer</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Just as you can embed a concrete type in a struct, you can also embed an interface in a struct. You’ll see a use for this in <a data-type="xref" href="ch15.html#test_stubs">“Using Stubs in Go”</a>.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Accept Interfaces, Return Structs"><div class="sect1" id="accept_interface">
<h1>Accept Interfaces, Return Structs</h1>

<p>You’ll often hear experienced Go developers<a data-type="indexterm" data-primary="interfaces" data-secondary="accept interfaces, return structs" id="ch07-in2st"/><a data-type="indexterm" data-primary="structs" data-secondary="accept interfaces, return structs" id="ch07-in2st2"/><a data-type="indexterm" data-primary="functions" data-secondary="accept interfaces, return structs" id="ch07-in2st3"/><a data-type="indexterm" data-primary="Lindamood, Jack" id="id1700"/><a data-type="indexterm" data-primary="“Preemptive Interface Anti-Pattern in Go” (Lindamood)" data-primary-sortas="Preemptive Interface Anti-Pattern" id="id1701"/><a data-type="indexterm" data-primary="resources online" data-secondary="“Preemptive Interface Anti-Pattern in Go” (Lindamood)" data-secondary-sortas="Preemptive Interface" id="id1702"/> say that your code should “Accept interfaces, return structs.” This phrase was most likely coined by Jack Lindamood in his 2016 blog post <a href="https://oreil.ly/OT1yi">“Preemptive Interface Anti-Pattern in Go”</a>. <a data-type="indexterm" data-primary="return keyword" data-secondary="concrete types returned" id="id1703"/><a data-type="indexterm" data-primary="functions" data-secondary="returning values" data-tertiary="concrete types returned" id="id1704"/><a data-type="indexterm" data-primary="concrete types" data-secondary="function return values" id="id1705"/>It means that the business logic invoked by your functions should be invoked via interfaces, but the output of your functions should be a concrete type. I’ve already covered why functions should accept interfaces: they make your code more flexible and explicitly declare the exact functionality being used.</p>

<p>The primary reason your functions should return concrete types is they make it easier to gradually update a function’s return values in new versions of your code. When a concrete type is returned by a function, new methods and fields can be added without breaking existing code that calls the function, because the new fields and methods are ignored. The same is not true for an interface. Adding a new method to an interface means that all existing implementations of that interface must be updated, or your code breaks. In semantic versioning terms, this is the difference between a minor release that is backward compatible and a major release, which is backward breaking. If you are exposing an API that’s consumed by other people (either inside your organization or as part of an open source project), avoiding backward-breaking changes keeps your users happy.</p>

<p>In some rare situations, the least bad option is to have your functions return interfaces. <a data-type="indexterm" data-primary="APIs" data-secondary="database/sql/driver package evolution" id="id1706"/><a data-type="indexterm" data-primary="database/sql/driver package" data-secondary="evolution of" id="id1707"/><a data-type="indexterm" data-primary="database/sql/driver package" data-secondary="interfaces defined for database driver" id="id1708"/><a data-type="indexterm" data-primary="standard library" data-secondary="database/sql/driver package" id="id1709"/>For example, the <code>database/sql/driver</code> package in the standard library defines a set of interfaces that define what a database driver must provide. It is the responsibility of the database driver author to provide concrete implementations of these interfaces, so almost all methods on all interfaces defined in <code>database/sql/driver</code> return interfaces. Starting in Go 1.8, database drivers are expected to support additional features. <a data-type="indexterm" data-primary="standard library" data-secondary="Go Compatibility Promise" id="id1710"/><a data-type="indexterm" data-primary="Go" data-secondary="backward compatibility" data-tertiary="Go Compatibility Promise" id="id1711"/><a data-type="indexterm" data-primary="backward compatibility of Go" data-secondary="Go Compatibility Promise" id="id1712"/>The standard library has a compatibility promise, so the existing interfaces can’t be updated with new methods, and the existing methods on these interfaces can’t be updated to return different types. The solution is to leave the existing interfaces alone, define new interfaces that describe the new functionality, and tell database driver authors that they should implement both the old and new methods on their concrete types.</p>

<p>This leads to the question of how to check whether these new methods are present and how to access them if they are. You’ll learn how in <a data-type="xref" href="#type_assert">“Type Assertions and Type Switches”</a>.</p>

<p>Rather than writing a single factory function that returns different instances behind an interface based on input parameters, try to write separate factory functions for each concrete type. In some situations (such as a parser that can return one or more kinds of tokens), it’s unavoidable and you have no choice but to return an interface.</p>

<p>Errors are an exception to this rule.<a data-type="indexterm" data-primary="errors" data-secondary="error interface type" id="id1713"/><a data-type="indexterm" data-primary="error interface type" id="id1714"/><a data-type="indexterm" data-primary="types" data-secondary="error interface type" id="id1715"/><a data-type="indexterm" data-primary="interfaces" data-secondary="accept interfaces, return structs" data-tertiary="error interface type exception" id="id1716"/> As you’ll see in <a data-type="xref" href="ch09.html#unique_chapter_id_09">Chapter 9</a>, Go functions and methods can declare a return parameter of the <code>error</code> interface type. In the case of <code>error</code>, it’s quite likely that different implementations of the interface could be returned, so you need to use an interface to handle all possible options, as interfaces are the only abstract type in Go.</p>

<p>This pattern has one potential drawback.<a data-type="indexterm" data-primary="interfaces" data-secondary="accept interfaces, return structs" data-tertiary="heap allocation trade-off" id="id1717"/><a data-type="indexterm" data-primary="heap" data-secondary="garbage collector workload reduced" data-tertiary="interface trade-off" id="id1718"/><a data-type="indexterm" data-primary="garbage collector" data-secondary="reducing workload" data-tertiary="interface trade-off" id="id1719"/><a data-type="indexterm" data-primary="memory" data-secondary="reducing garbage collector’s workload" data-tertiary="interface trade-off" id="id1720"/> As I discussed in <a data-type="xref" href="ch06.html#memory">“Reducing the Garbage Collector’s Workload”</a>, reducing heap allocations improves performance by reducing the amount of work for the garbage collector. Returning a struct avoids a heap allocation, which is good. However, when invoking a function with parameters of interface types, a heap allocation occurs for each interface parameter. Figuring out the trade-off between better abstraction and better performance should be done over the life of your program. Write your code so that it is readable and maintainable. If you find that your program is too slow <em>and</em> you have profiled it <em>and</em> you have determined that the performance problems are due to a heap allocation caused by an interface parameter, then you should rewrite the function to use a concrete type parameter. If multiple implementations of an interface are passed into the function, this will mean creating multiple functions with repeated logic.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Developers who come from a C++ or Rust background might try using generics as a way to get the compiler to generate specialized functions. As of Go 1.21, this will probably not produce faster code. I’ll cover why in <a data-type="xref" href="ch08.html#generic_speed">“Idiomatic Go and Generics”</a>.<a data-type="indexterm" data-startref="ch07-in2st" id="id1721"/><a data-type="indexterm" data-startref="ch07-in2st2" id="id1722"/><a data-type="indexterm" data-startref="ch07-in2st3" id="id1723"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Interfaces and nil"><div class="sect1" id="interface_nil">
<h1>Interfaces and nil</h1>

<p>When discussing pointers in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>, I <a data-type="indexterm" data-primary="interfaces" data-secondary="nil and" id="id1724"/><a data-type="indexterm" data-primary="nil" data-secondary="interfaces and" id="id1725"/><a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="interface types as nil" id="id1726"/><a data-type="indexterm" data-primary="interfaces" data-secondary="zero value as nil" id="id1727"/>also talked about <code>nil</code>, the zero value for pointer types. You can also use <code>nil</code> to represent the zero value for an interface instance, but it’s not as simple as it is for concrete types.</p>

<p>Understanding the relationship between interfaces and <code>nil</code> requires understanding a little bit about how interfaces are implemented. In the Go runtime, interfaces are implemented as a struct with two pointer fields, one for the value and one for the type of the value. As long as the type field is non-nil, the interface is non-nil. (Since you cannot have a variable without a type, if the value pointer is non-nil, the type pointer is always non-nil.)</p>

<p>In order for an interface to be considered <code>nil</code>, <em>both</em> the type and the value must be <code>nil</code>. The following code prints out <code>true</code> on the first two lines and <code>false</code> on the last:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">pointerCounter</code><code class="w"> </code><code class="o">*</code><code class="nx">Counter</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">pointerCounter</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">incrementer</code><code class="w"> </code><code class="nx">Incrementer</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">incrementer</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints true</code><code class="w"/>
<code class="nx">incrementer</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">pointerCounter</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">incrementer</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints false</code><code class="w"/></pre>

<p>You can run this code for yourself on <a href="https://oreil.ly/njtz9">The Go Playground</a> or use the code in the <em>sample_code/interface_nil</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1728"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1729"/></p>

<p>What <code>nil</code> indicates for a variable with an interface type is whether you can invoke methods on it. As I covered earlier, you can invoke methods on <code>nil</code> concrete instances, so it makes sense that you can invoke methods on an interface variable that was assigned a <code>nil</code> concrete instance. If an interface variable is <code>nil</code>, invoking any methods on it triggers a panic (which I’ll discuss in <a data-type="xref" href="ch09.html#panic_recover">“panic and recover”</a>). If an interface variable is non-nil, you can invoke methods on it. (But note that if the value is <code>nil</code> and the methods of the assigned type don’t properly handle <code>nil</code>, you could still trigger a panic.)</p>

<p>Since an interface instance with a non-nil type is not equal to <code>nil</code>, it is not straightforward to tell whether the value associated with the interface is <code>nil</code> when the type is non-nil. You must use reflection (which I’ll discuss in <a data-type="xref" href="ch16.html#reflect_interface_nil">“Use Reflection to Check If an Interface’s Value Is nil”</a>) to find out.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Interfaces Are Comparable"><div class="sect1" id="compare_interfaces">
<h1>Interfaces Are Comparable</h1>

<p>In <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>, you learned<a data-type="indexterm" data-primary="interfaces" data-secondary="as comparable" data-secondary-sortas="comparable" id="id1730"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="interfaces comparable" id="id1731"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="interfaces comparable" id="id1732"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="interfaces comparable" id="id1733"/> about comparable types, the ones that can be checked for equality with <code>==</code>. You might be surprised to learn that interfaces are comparable. Just as an interface is equal to <code>nil</code> only if its type and value fields are both <code>nil</code>, two instances of an interface type are equal only if their types are equal and their values are equal. This suggests a question: what happens if the type isn’t comparable? Let’s use a simple example to explore this concept. Start with an interface definition and a couple of implementations of that interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Doubler</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Double</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">DoubleInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">d</code><code class="w"> </code><code class="o">*</code><code class="nx">DoubleInt</code><code class="p">)</code><code class="w"> </code><code class="nx">Double</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="nx">d</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="o">*</code><code class="nx">d</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">DoubleIntSlice</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">d</code><code class="w"> </code><code class="nx">DoubleIntSlice</code><code class="p">)</code><code class="w"> </code><code class="nx">Double</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">d</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">d</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">d</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Double</code> method on <code>DoubleInt</code> is declared with a pointer receiver because you are modifying the value of the <code>int</code>. You can use a value receiver for the <code>Double</code> method on <code>DoubleIntSlice</code> because, as covered in <a data-type="xref" href="ch06.html#map_slice">“The Difference Between Maps and Slices”</a>, you can change the value of an item in a parameter that is a slice type. The <code>*DoubleInt</code> type is comparable (all pointer types are), and the <code>DoubleIntSlice</code> type is not comparable (slices aren’t comparable).</p>

<p>You also have a function that takes in two parameters of type <code>Doubler</code> and prints if they are equal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">DoublerCompare</code><code class="p">(</code><code class="nx">d1</code><code class="p">,</code><code class="w"> </code><code class="nx">d2</code><code class="w"> </code><code class="nx">Doubler</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">d1</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">d2</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You now define four variables:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">di</code><code class="w"> </code><code class="nx">DoubleInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">di2</code><code class="w"> </code><code class="nx">DoubleInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">dis</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">DoubleIntSlice</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">dis2</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">DoubleIntSlice</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">}</code><code class="w"/></pre>

<p>Now, you’re going to call this function three times. The first call is as follows:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">DoublerCompare</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">di</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">di2</code><code class="p">)</code><code class="w"/></pre>

<p>This prints out <code>false</code>. The types match (both are <code>*DoubleInt</code>), but you are comparing pointers, not values, and the pointers point to different instances.</p>

<p>Next, you compare a <code>*DoubleInt</code> with a <code>DoubleIntSlice</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">DoublerCompare</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">di</code><code class="p">,</code><code class="w"> </code><code class="nx">dis</code><code class="p">)</code><code class="w"/></pre>

<p>This prints out <code>false</code>, because the types do not match.</p>

<p>Finally, you get to the problematic case:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">DoublerCompare</code><code class="p">(</code><code class="nx">dis</code><code class="p">,</code><code class="w"> </code><code class="nx">dis2</code><code class="p">)</code><code class="w"/></pre>

<p>This code compiles without issue, but triggers a panic at runtime:</p>

<pre data-type="programlisting">panic: runtime error: comparing uncomparable type main.DoubleIntSlice</pre>

<p>The entire program is available in the <em>sample_code/comparable</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1734"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1735"/></p>

<p>Also be aware that the key of a map must be comparable, so a map can be defined to have an interface as a key:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="nx">Doubler</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/></pre>

<p>If you add a key-value pair to this map and the key isn’t comparable, that will also trigger a panic.</p>

<p>Given this behavior, be careful when using <code>==</code> or <code>!=</code> with interfaces or using an interface as a map key, as it’s easy to accidentally generate a panic that will crash your program. Even if all your interface implementations are currently comparable, you don’t know what will happen when someone else uses or modifies your code, and there’s no way to specify that an interface can be implemented only by comparable types.<a data-type="indexterm" data-primary="any as type alias for empty interface" data-secondary="comparable interface" id="id1736"/><a data-type="indexterm" data-primary="comparable interface" id="id1737"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="comparable interface" id="id1738"/> If you want to be extra safe, you can use the <code>Comparable</code> method on <code>reflect.Value</code> to inspect an interface before using it with <code>==</code> or <code>!=</code>. (You’ll learn more about reflection in <a data-type="xref" href="ch16.html#reflection">“Reflection Lets You Work with Types at Runtime”</a>).</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Empty Interface Says Nothing"><div class="sect1" id="empty_interface">
<h1>The Empty Interface Says Nothing</h1>

<p>Sometimes in a statically typed language,<a data-type="indexterm" data-primary="variables" data-secondary="empty interface to indicate value of any type" id="id1739"/><a data-type="indexterm" data-primary="interfaces" data-secondary="empty interface for variable value of any type" id="id1740"/><a data-type="indexterm" data-primary="braces ({ })" data-secondary="empty interface" id="id1741"/><a data-type="indexterm" data-primary="{ } (braces)" data-secondary="empty interface" id="id1742"/><a data-type="indexterm" data-primary="interface keyword" data-secondary="interface{}" id="id1743"/><a data-type="indexterm" data-primary="keywords" data-secondary="interface" data-tertiary="interface{}" id="id1744"/><a data-type="indexterm" data-primary="types" data-secondary="empty interface for variable of any type" id="id1745"/> you need a way to say that a variable could store a value of any type. Go uses an <em>empty interface</em>, <code>interface{}</code>, to represent this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="kd">interface</code><code class="p">{}</code><code class="w"/>
<code class="nx">i</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">i</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/>
<code class="nx">i</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">FirstName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">LastName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="p">{</code><code class="s">"Fred"</code><code class="p">,</code><code class="w"> </code><code class="s">"Fredson"</code><code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>interface{}</code> isn’t special case syntax. An empty interface type simply states that the variable can store any value whose type implements zero or more methods. This just happens to match every type in Go.</p>
</div>

<p>To improve readability, Go<a data-type="indexterm" data-primary="interface keyword" data-secondary="interface{}" data-tertiary="any as type alias for" id="id1746"/><a data-type="indexterm" data-primary="interfaces" data-secondary="empty interface for variable value of any type" data-tertiary="any as type alias for" id="id1747"/><a data-type="indexterm" data-primary="types" data-secondary="empty interface for variable of any type" data-tertiary="any as type alias for" id="id1748"/><a data-type="indexterm" data-primary="variables" data-secondary="empty interface to indicate value of any type" data-tertiary="any as type alias for" id="id1749"/><a data-type="indexterm" data-primary="any as type alias for empty interface" id="id1750"/> added <code>any</code> as a type alias for <code>interface{}</code>. Legacy code (written before <code>any</code> was added in Go 1.18) used <code>interface{}</code>, but stick with <code>any</code> for new code.</p>

<p>Because an empty interface doesn’t tell you anything about the value it represents, you can’t do a lot with it. One common use of <code>any</code> is as a placeholder for data of uncertain schema that’s read from an external source, like a JSON file:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">any</code><code class="p">{}</code><code class="w"/>
<code class="nx">contents</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="s">"testdata/sample.json"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">contents</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="c1">// the contents are now in the data map</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>User-created data containers that were written before generics were added to Go use an empty interface to store a value. (I’ll talk about generics in <a data-type="xref" href="ch08.html#unique_chapter_id_08">Chapter 8</a>.) An example in the standard library is <a href="https://oreil.ly/53tmr"><code>container/list</code></a>. Now that generics are part of Go, please use them for any newly created data containers.</p>
</div>

<p>If you see a function that takes in an empty interface, it’s likely using reflection (which I’ll talk about in <a data-type="xref" href="ch16.html#unique_chapter_id_16">Chapter 16</a>) to either populate or read the value. In the preceding example, the second parameter of the <code>json.Unmarshal</code> function is declared to be of type <code>any</code>.</p>

<p>These situations should be relatively rare. Avoid using <code>any</code>. As you’ve seen, Go is designed as a strongly typed language and attempts to work around this are 
<span class="keep-together">unidiomatic.</span></p>

<p>If you find yourself in a situation where you had to store a value into an empty interface, you might be wondering how to read the value back again. To do that, you need to learn about type assertions and type switches.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Type Assertions and Type Switches"><div class="sect1" id="type_assert">
<h1>Type Assertions and Type Switches</h1>

<p>Go provides two ways to see<a data-type="indexterm" data-primary="types" data-secondary="type assertions" id="ch07-tya"/><a data-type="indexterm" data-primary="type assertions" id="ch07-tya2"/><a data-type="indexterm" data-primary="concrete types" data-secondary="type assertions" id="id1751"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type assertions" id="id1752"/> if a variable of an interface type has a specific concrete type or if the concrete type implements another interface. Let’s start by looking at type assertions. A <em>type assertion</em> names the concrete type that implemented the interface, or names another interface that is also implemented by the concrete type whose value is stored in the interface. You can try it out on <a href="https://oreil.ly/XUfuO">The Go Playground</a> or in the <code>typeAssert</code> function in <em>main.go</em> in the <em>sample_code/type_assertions</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1753"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1754"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="kt">any</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">mine</code><code class="w"> </code><code class="nx">MyInt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">mine</code><code class="w"/>
<code class="w">    </code><code class="nx">i2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="p">.(</code><code class="nx">MyInt</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In the preceding code, the variable <code>i2</code> is of type <code>MyInt</code>.</p>

<p>You might wonder what happens<a data-type="indexterm" data-primary="panics" data-secondary="type assertion wrong" id="id1755"/> if a type assertion is wrong. In that case, your code panics. You can try it out on <a href="https://oreil.ly/qoXu_">The Go Playground</a> or in the <code>typeAssertPanicWrongType</code> function in <em>main.go</em> in the <em>sample_code/type_assertions</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">i2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="p">.(</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i2</code><code class="p">)</code><code class="w"/></pre>

<p>Running this code produces the following panic:</p>

<pre data-type="programlisting">panic: interface conversion: interface {} is main.MyInt, not string</pre>

<p>As you’ve already seen, Go is very careful about concrete types. Even if two types share an underlying type, a type assertion must match the type of the value stored in the interface. The following code panics. You can try it out on <a href="https://oreil.ly/YUaka">The Go Playground</a> or in the <code>typeAssertPanicTypeNotIdentical</code> function in <em>main.go</em> in the <em>sample_code/type_assertions</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">i2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="p">.(</code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/></pre>

<p>Obviously, crashing is not desired behavior. <a data-type="indexterm" data-primary="comma ok idiom" data-secondary="handling wrong type assertion" id="id1756"/><a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="wrong type assertion" id="id1757"/>You avoid this by using the comma ok idiom, just as you saw in <a data-type="xref" href="ch03.html#comma_ok_section">“The comma ok Idiom”</a> when detecting whether a zero value was in a map.  You can see this in the <code>typeAssertCommaOK</code> function in <em>main.go</em> in the <em>sample_code/type_assertions</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">i2</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="p">.(</code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"unexpected type for %v"</code><code class="p">,</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i2</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/></pre>

<p>The boolean <code>ok</code> is set to <code>true</code> if the type conversion was successful. If it was not, <code>ok</code> is set to <code>false</code> and the other variable (in this case <code>i2</code>) is set to its zero value. You then handle the unexpected condition within an <code>if</code> statement. I’ll talk more about error handling in <a data-type="xref" href="ch09.html#unique_chapter_id_09">Chapter 9</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A type assertion is very different<a data-type="indexterm" data-primary="type assertions" data-secondary="type conversions versus" id="id1758"/><a data-type="indexterm" data-primary="type conversion" data-secondary="type assertion versus" id="id1759"/> from a type conversion. Conversions change a value to a new type, while assertions reveal the type of the value stored in the interface. Type conversions can be applied to both concrete types and interfaces. Type assertions can be applied only to interface types. All type assertions are checked at runtime, so they can fail at runtime with a panic if you don’t use the comma ok idiom. Most type conversions are checked at compile time, so if they are invalid, your code won’t compile. (Type conversions between slices and array pointers can fail at runtime and don’t support the comma ok idiom, so be careful when using them!)</p>
</div>

<p>Even if you are absolutely certain<a data-type="indexterm" data-primary="comma ok idiom" data-secondary="handling wrong type assertion" id="id1760"/><a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="wrong type assertion" id="id1761"/> that your type assertion is valid, use the comma ok idiom version. You don’t know how other people (or you in six months) will reuse your code. Sooner or later, your unvalidated type assertions will fail at runtime.<a data-type="indexterm" data-startref="ch07-tya" id="id1762"/><a data-type="indexterm" data-startref="ch07-tya2" id="id1763"/></p>

<p>When an interface could be one of multiple possible types, use a <em>type switch</em> instead:<a data-type="indexterm" data-primary="interfaces" data-secondary="type switches" id="id1764"/><a data-type="indexterm" data-primary="types" data-secondary="type switches" id="id1765"/><a data-type="indexterm" data-primary="type switches" id="id1766"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doThings</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="p">.(</code><code class="kd">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="kc">nil</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// i is nil, type of j is any</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="kt">int</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// j is of type int</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">MyInt</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// j is of type MyInt</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// j is of type io.Reader</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="kt">string</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// j is a string</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="kt">bool</code><code class="p">,</code><code class="w"> </code><code class="kt">rune</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// i is either a bool or rune, so j is of type any</code><code class="w"/>
<code class="w">    </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// no idea what i is, so j is of type any</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A type <code>switch</code> looks a lot like the <code>switch</code> statement that you saw way back in <a data-type="xref" href="ch04.html#switch_statement">“switch”</a>. Instead of specifying a boolean operation, you specify a variable of an interface type and follow it with <code>.(type)</code>. Usually, you assign the variable being checked to another variable that’s valid only within the <code>switch</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Since the purpose of a type <code>switch</code> is to derive<a data-type="indexterm" data-primary="shadowing variables" data-secondary="type switch making shadowing good" id="id1767"/><a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="shadowing variables good with type switch" id="id1768"/> a new variable from an existing one, it is idiomatic to assign the variable being switched on to a variable of the same name (<code>i := i.(type)</code>), making this one of the few places where shadowing is a good idea. To make the comments more readable, this example doesn’t use shadowing.</p>
</div>

<p>The type of the new variable depends on which case matches. You can use <code>nil</code> for one case to see if the interface has no associated type. If you list more than one type on a case, the new variable is of type <code>any</code>. Just as with a <code>switch</code> statement, you can have a <code>default</code> case that matches when no specified type does. Otherwise, the new variable has the type of the case that matches.</p>

<p>While the examples so far have used the <code>any</code> interface with type assertions and type switches, you can uncover the concrete type from all interface types.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you <em>don’t</em> know the type of the value stored in an interface, you need to use reflection. I’ll talk more about reflection in <a data-type="xref" href="ch16.html#unique_chapter_id_16">Chapter 16</a>.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Use Type Assertions and Type Switches Sparingly"><div class="sect1" id="rare_type_assertions">
<h1>Use Type Assertions and Type Switches Sparingly</h1>

<p>While being able<a data-type="indexterm" data-primary="type assertions" data-secondary="uses for" id="ch07-spar"/><a data-type="indexterm" data-primary="concrete types" data-secondary="type assertions" data-tertiary="uses for" id="ch07-spar2"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type assertions" data-tertiary="uses for" id="ch07-spar3"/><a data-type="indexterm" data-primary="types" data-secondary="type assertions" data-tertiary="uses for" id="ch07-spar4"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type switches" data-tertiary="uses for" id="ch07-spar5"/><a data-type="indexterm" data-primary="type switches" data-secondary="uses for" id="ch07-spar6"/><a data-type="indexterm" data-primary="types" data-secondary="type switches" data-tertiary="uses for" id="ch07-spar7"/> to extract the concrete implementation from an interface variable might seem handy, you should use these techniques infrequently. For the most part, treat a parameter or return value as the type that was supplied and not what else it could be. <a data-type="indexterm" data-primary="APIs" data-secondary="type assertions and type switches" id="id1769"/>Otherwise, your function’s API isn’t accurately declaring the types it needs to perform its task. If you needed a different type, it should be specified.</p>

<p>That said, type assertions and type switches are useful in some use cases. <a data-type="indexterm" data-primary="interfaces" data-secondary="optional interfaces" id="id1770"/>One common use of a type assertion is to see if the concrete type behind the interface also implements another interface. This allows you to specify optional interfaces. <a data-type="indexterm" data-primary="io package" data-secondary="io.Copy" id="id1771"/><a data-type="indexterm" data-primary="standard library" data-secondary="io package" id="id1772"/>For example, the standard library uses this technique to allow more efficient copies when the <code>io.Copy</code> function is called. This function has two parameters of types <code>io.Writer</code> and <code>io.Reader</code> and calls the <code>io.copyBuffer</code> function to do its work. If the <code>io.Writer</code> parameter also implements <code>io.WriterTo</code>, or the <code>io.Reader</code> parameter also implements <code>io.ReaderFrom</code>, most of the work in the function can be skipped:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// copyBuffer is the actual implementation of Copy and CopyBuffer.</code><code class="w"/>
<code class="c1">// if buf is nil, one is allocated.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">copyBuffer</code><code class="p">(</code><code class="nx">dst</code><code class="w"> </code><code class="nx">Writer</code><code class="p">,</code><code class="w"> </code><code class="nx">src</code><code class="w"> </code><code class="nx">Reader</code><code class="p">,</code><code class="w"> </code><code class="nx">buf</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">written</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// If the reader has a WriteTo method, use it to do the copy.</code><code class="w"/>
<code class="w">    </code><code class="c1">// Avoids an allocation and a copy.</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">wt</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">src</code><code class="p">.(</code><code class="nx">WriterTo</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">wt</code><code class="p">.</code><code class="nx">WriteTo</code><code class="p">(</code><code class="nx">dst</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">rt</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">dst</code><code class="p">.(</code><code class="nx">ReaderFrom</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">rt</code><code class="p">.</code><code class="nx">ReadFrom</code><code class="p">(</code><code class="nx">src</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// function continues...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Another place optional interfaces<a data-type="indexterm" data-primary="APIs" data-secondary="optional interfaces for evolving APIs" id="id1773"/><a data-type="indexterm" data-primary="APIs" data-secondary="database/sql/driver package evolution" id="id1774"/><a data-type="indexterm" data-primary="database/sql/driver package" data-secondary="evolution of" id="id1775"/> are used is when evolving an API. As was covered in <a data-type="xref" href="#accept_interface">“Accept Interfaces, Return Structs”</a>, the API for the database drivers has changed over time. One of the reasons for this change is the addition of the context, which is discussed in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a>. Context is a parameter that’s passed to functions that provides, among other things, a standard way to manage cancellation. It was added to Go in version 1.7, which means older code doesn’t support it. This includes older database drivers.</p>

<p>In Go 1.8, new context-aware analogues of existing interfaces were defined in the <code>database/sql/driver</code> package. For example, the <code>StmtExecContext</code> interface defines a method called <code>ExecContext</code>, which is a context-aware replacement for the <code>Exec</code> method in <code>Stmt</code>. When an implementation of <code>Stmt</code> is passed into standard library database code, it checks whether it also implements <code>StmtExecContext</code>. If it does, 
<span class="keep-together"><code>ExecContext</code></span> is invoked. If not, the Go standard library provides a fallback implementation of the cancellation support provided by newer code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">ctxDriverStmtExec</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">si</code><code class="w"> </code><code class="nx">driver</code><code class="p">.</code><code class="nx">Stmt</code><code class="p">,</code><code class="w"/>
<code class="w">                       </code><code class="nx">nvdargs</code><code class="w"> </code><code class="p">[]</code><code class="nx">driver</code><code class="p">.</code><code class="nx">NamedValue</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">driver</code><code class="p">.</code><code class="nx">Result</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">siCtx</code><code class="p">,</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">si</code><code class="p">.(</code><code class="nx">driver</code><code class="p">.</code><code class="nx">StmtExecContext</code><code class="p">);</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">siCtx</code><code class="p">.</code><code class="nx">ExecContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">nvdargs</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// fallback code is here</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This optional interface technique has one drawback. You saw earlier that it 
<span class="keep-together">is common</span> for implementations of interfaces to use the decorator pattern to wrap other implementations of the same interface to layer behavior. The problem is that if an optional interface is implemented by one of the wrapped implementations, you cannot detect it with a type assertion or type switch. <a data-type="indexterm" data-primary="bufio package" data-secondary="bufio.NewReader" id="id1776"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="passing to bufio.NewReader" id="id1777"/><a data-type="indexterm" data-primary="bufio package" data-secondary="bufio.Reader" id="id1778"/>For example, the standard library includes a <code>bufio</code> package that provides a buffered reader. You can buffer any other <code>io.Reader</code> implementation by passing it to the <code>bufio.NewReader</code> function and using the returned <code>*bufio.Reader</code>. If the passed-in <code>io.Reader</code> also implemented <code>io.ReaderFrom</code>, wrapping it in a buffered reader prevents the 
<span class="keep-together">optimization.</span></p>

<p>You also see this when handling errors.<a data-type="indexterm" data-primary="errors" data-secondary="error interface type" data-tertiary="wrapped errors" id="id1779"/><a data-type="indexterm" data-primary="error interface type" data-secondary="wrapped errors" id="id1780"/><a data-type="indexterm" data-primary="types" data-secondary="error interface type" data-tertiary="wrapped errors" id="id1781"/><a data-type="indexterm" data-primary="errors package" data-secondary="errors.As" id="id1782"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.As" id="id1783"/><a data-type="indexterm" data-primary="errors package" data-secondary="errors.Is" id="id1784"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.Is" id="id1785"/><a data-type="indexterm" data-primary="errors" data-secondary="wrapping errors" id="id1786"/><a data-type="indexterm" data-primary="wrapping errors" id="id1787"/> As mentioned earlier, they implement the <code>error</code> interface. Errors can include additional information by wrapping other errors. A type switch or type assertion cannot detect or match wrapped errors. If you want different behaviors to handle different concrete implementations of a returned error, use the <code>errors.Is</code> and <code>errors.As</code> functions to test for and access the wrapped error.</p>

<p>Type <code>switch</code> statements provide the ability to differentiate between multiple implementations of an interface that require different processing. They are most useful when only certain possible valid types can be supplied for an interface. Be sure to include a <code>default</code> case in the type <code>switch</code> to handle implementations that aren’t known at development time. This protects you if you forget to update your type <code>switch</code> statements when adding new interface implementations:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">walkTree</code><code class="p">(</code><code class="nx">t</code><code class="w"> </code><code class="o">*</code><code class="nx">treeNode</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">t</code><code class="p">.</code><code class="nx">val</code><code class="p">.(</code><code class="kd">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="kc">nil</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"invalid expression"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">number</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// we know that t.val is of type number, so return the</code><code class="w"/>
<code class="w">        </code><code class="c1">// int value</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nb">int</code><code class="p">(</code><code class="nx">val</code><code class="p">),</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">operator</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// we know that t.val is of type operator, so</code><code class="w"/>
<code class="w">        </code><code class="c1">// find the values of the left and right children, then</code><code class="w"/>
<code class="w">        </code><code class="c1">// call the process() method on operator to return the</code><code class="w"/>
<code class="w">        </code><code class="c1">// result of processing their values.</code><code class="w"/>
<code class="w">        </code><code class="nx">left</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">walkTree</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">lchild</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">right</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">walkTree</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">rchild</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">val</code><code class="p">.</code><code class="nx">process</code><code class="p">(</code><code class="nx">left</code><code class="p">,</code><code class="w"> </code><code class="nx">right</code><code class="p">),</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1">// if a new treeVal type is defined, but walkTree wasn't updated</code><code class="w"/>
<code class="w">        </code><code class="c1">// to process it, this detects it</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"unknown node type"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can see the complete implementation on <a href="https://oreil.ly/jDhqM">The Go Playground</a> or in the <em>sample_code/type_switch</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1788"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="id1789"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can further protect yourself from unexpected interface implementations by making the interface unexported and at least one method unexported. If the interface is exported, it can be embedded in a struct in another package, making the struct implement the interface. I’ll talk more about packages and exporting identifiers in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>.<a data-type="indexterm" data-startref="ch07-spar" id="id1790"/><a data-type="indexterm" data-startref="ch07-spar2" id="id1791"/><a data-type="indexterm" data-startref="ch07-spar3" id="id1792"/><a data-type="indexterm" data-startref="ch07-spar4" id="id1793"/><a data-type="indexterm" data-startref="ch07-spar5" id="id1794"/><a data-type="indexterm" data-startref="ch07-spar6" id="id1795"/><a data-type="indexterm" data-startref="ch07-spar7" id="id1796"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Function Types Are a Bridge to Interfaces"><div class="sect1" id="function_type_interface">
<h1>Function Types Are a Bridge to Interfaces</h1>

<p>I haven’t talked<a data-type="indexterm" data-primary="functions" data-secondary="interface implementation" id="id1797"/><a data-type="indexterm" data-primary="types" data-secondary="user-defined types" data-tertiary="underlying type of int or string" id="id1798"/><a data-type="indexterm" data-primary="user-defined types" data-secondary="underlying type of int or string" id="id1799"/><a data-type="indexterm" data-primary="interfaces" data-secondary="functions implementing" id="id1800"/> about one last thing with type declarations. Once you understand the concept of declaring a method on a struct, you can start to see how a user-defined type with an underlying type of <code>int</code> or <code>string</code> can have a method as well. After all, a method provides business logic that interacts with the state of an instance, and integers and strings have state as well.</p>

<p>Go, however, allows methods on <em>any</em> user-defined type, including user-defined function types. This sounds like an academic corner case, but they are actually very useful. They allow functions to implement interfaces. The most common usage is for HTTP handlers. An HTTP handler processes an HTTP server request. It’s defined by an interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Handler</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By using a type conversion to <code>http.HandlerFunc</code>, any function that has the signature <code>func(http.ResponseWriter,*http.Request)</code> can be used as an <code>http.Handler</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">HandlerFunc</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="nx">HandlerFunc</code><code class="p">)</code><code class="w"> </code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This lets you implement HTTP handlers using functions, methods, or closures using the exact same code path as the one used for other types that meet the <code>http.Handler</code> interface.</p>

<p>Functions in Go are first-class concepts,<a data-type="indexterm" data-primary="parameters" data-secondary="passing functions as parameters" data-tertiary="when to use interface instead" id="id1801"/><a data-type="indexterm" data-primary="functions" data-secondary="passing functions as parameters" data-tertiary="when to use interface instead" id="id1802"/><a data-type="indexterm" data-primary="interfaces" data-secondary="passing functions as parameters or interface" id="id1803"/> and as such, they are often passed as parameters into functions. Meanwhile, Go encourages small interfaces, and an interface of only one method could easily replace a parameter of a function type. The question becomes: when should your function or method specify an input parameter of a function type, and when should you use an interface?</p>

<p>If your single function is likely to depend on many other functions or other state that’s not specified in its input parameters, use an interface parameter and define a function type to bridge a function to the interface. That’s what’s done in the <code>http</code> package; a <code>Handler</code> is likely just the entry point for a chain of calls that needs to be configured. However, if it’s a simple function (like the one used in <code>sort.Slice</code>), then a parameter of a function type is a good choice.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Implicit Interfaces Make Dependency Injection Easier"><div class="sect1" id="dependency_injection">
<h1>Implicit Interfaces Make Dependency Injection Easier</h1>

<p>In  the preface, I compared writing software<a data-type="indexterm" data-primary="interfaces" data-secondary="implicit implementation" data-tertiary="dependency injection easier" id="ch07-depin"/><a data-type="indexterm" data-primary="dependency injection via implicit interfaces" id="ch07-depin2"/> to building bridges. One of the things that software has in common with physical infrastructure is that any program used for a lengthy period of time by multiple people will need maintenance. While programs don’t wear out, developers are often asked to update programs to fix bugs, add features, and run in new environments. Therefore, you should structure your programs in ways that make them easier to modify. Software engineers talk about <em>decoupling</em> code, so that changes to different parts of a program have no effect on one another.</p>

<p>One of the techniques that has been developed to ease decoupling is called <em>dependency injection</em>. Dependency injection is the concept that your code should explicitly specify the functionality it needs to perform its task. It’s quite a bit older than you might think; in 1996, Robert Martin wrote an article called <a href="https://oreil.ly/6HVob">“The Dependency Inversion Principle”</a>.</p>

<p>One of the surprising benefits of Go’s implicit interfaces is that they make dependency injection an excellent way to decouple your code. While developers in other languages often use large, complicated frameworks to inject their dependencies, the truth is that it is easy to implement dependency injection in Go without any additional libraries. Let’s work through a simple example to see how to use implicit interfaces to compose applications via dependency injection.</p>

<p>To understand this concept better and see how to implement dependency injection in Go, you’ll build a very simple web application. (I’ll talk more about Go’s built-in HTTP server support in <a data-type="xref" href="ch13.html#http_server">“The Server”</a>; consider this a preview.) Start by writing a small utility function, a logger:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">LogOutput</code><code class="p">(</code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Another thing your app needs is a data store. Let’s create a simple one:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">SimpleDataStore</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">userData</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">sds</code><code class="w"> </code><code class="nx">SimpleDataStore</code><code class="p">)</code><code class="w"> </code><code class="nx">UserNameForID</code><code class="p">(</code><code class="nx">userID</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sds</code><code class="p">.</code><code class="nx">userData</code><code class="p">[</code><code class="nx">userID</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Also define a factory function to create an instance of a <code>SimpleDataStore</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">NewSimpleDataStore</code><code class="p">()</code><code class="w"> </code><code class="nx">SimpleDataStore</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">SimpleDataStore</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">userData</code><code class="p">:</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="s">"1"</code><code class="p">:</code><code class="w"> </code><code class="s">"Fred"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="s">"2"</code><code class="p">:</code><code class="w"> </code><code class="s">"Mary"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="s">"3"</code><code class="p">:</code><code class="w"> </code><code class="s">"Pat"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Next, write some business logic that looks up a user and says hello or goodbye. Your business logic needs some data to work with, so it requires a data store. You also want your business logic to log when it is invoked, so it depends on a logger. However, you don’t want to force it to depend on <code>LogOutput</code> or <code>SimpleDataStore</code>, because you might want to use a different logger or data store later. What your business logic needs are interfaces to describe what it depends on:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">DataStore</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">UserNameForID</code><code class="p">(</code><code class="nx">userID</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Logger</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Log</code><code class="p">(</code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>To make your <code>LogOutput</code> function meet this interface, you define a function type with a method on it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">LoggerAdapter</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">lg</code><code class="w"> </code><code class="nx">LoggerAdapter</code><code class="p">)</code><code class="w"> </code><code class="nx">Log</code><code class="p">(</code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">lg</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By a stunning coincidence, <code>LoggerAdapter</code> and <code>SimpleDataStore</code> happen to meet the interfaces needed by your business logic, but neither type has any idea that it does.</p>

<p>Now that you have the dependencies defined, let’s look at the implementation of your business logic:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">SimpleLogic</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">l</code><code class="w">  </code><code class="nx">Logger</code><code class="w"/>
<code class="w">    </code><code class="nx">ds</code><code class="w"> </code><code class="nx">DataStore</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">sl</code><code class="w"> </code><code class="nx">SimpleLogic</code><code class="p">)</code><code class="w"> </code><code class="nx">SayHello</code><code class="p">(</code><code class="nx">userID</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sl</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">Log</code><code class="p">(</code><code class="s">"in SayHello for "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">userID</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sl</code><code class="p">.</code><code class="nx">ds</code><code class="p">.</code><code class="nx">UserNameForID</code><code class="p">(</code><code class="nx">userID</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"unknown user"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="s">"Hello, "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">sl</code><code class="w"> </code><code class="nx">SimpleLogic</code><code class="p">)</code><code class="w"> </code><code class="nx">SayGoodbye</code><code class="p">(</code><code class="nx">userID</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sl</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">Log</code><code class="p">(</code><code class="s">"in SayGoodbye for "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">userID</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sl</code><code class="p">.</code><code class="nx">ds</code><code class="p">.</code><code class="nx">UserNameForID</code><code class="p">(</code><code class="nx">userID</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"unknown user"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="s">"Goodbye, "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You have a <code>struct</code> with two fields: one a <code>Logger</code>, the other a <code>DataStore</code>. Nothing in <code>SimpleLogic</code> mentions the concrete types, so there’s no dependency on them. There’s no problem if you later swap in new implementations from an entirely different provider, because the provider has nothing to do with your interface. This is very different from explicit interfaces in languages like Java. Even though Java uses an interface to decouple the implementation from the interface, the explicit interfaces bind the client and the provider together. This makes replacing a dependency in Java (and other languages with explicit interfaces) far more difficult than it is in Go.</p>

<p>When you want a <code>SimpleLogic</code> instance, you call a factory function, passing in interfaces and returning a struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">NewSimpleLogic</code><code class="p">(</code><code class="nx">l</code><code class="w"> </code><code class="nx">Logger</code><code class="p">,</code><code class="w"> </code><code class="nx">ds</code><code class="w"> </code><code class="nx">DataStore</code><code class="p">)</code><code class="w"> </code><code class="nx">SimpleLogic</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">SimpleLogic</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">l</code><code class="p">:</code><code class="w">    </code><code class="nx">l</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">ds</code><code class="p">:</code><code class="w"> </code><code class="nx">ds</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The fields in <code>SimpleLogic</code> are unexported. This means they can be accessed only by code within the same package as <code>SimpleLogic</code>. You can’t enforce immutability in Go, but limiting which code can access these fields makes their accidental modification less likely. I’ll talk more about exported and unexported identifiers in 
<span class="keep-together"><a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>.</span></p>
</div>

<p>Now you get to your API. You’re going to have only a single endpoint, <code>/hello</code>, which says hello to the person whose user ID is supplied. (Please do not use query parameters in your real applications for authentication information; this is just a quick sample.) Your controller needs business logic that says hello, so you define an interface for that:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Logic</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">SayHello</code><code class="p">(</code><code class="nx">userID</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This method is available on your <code>SimpleLogic</code> struct, but once again, the concrete type is not aware of the interface. Furthermore, the other method on <code>SimpleLogic</code>, 
<span class="keep-together"><code>SayGoodbye</code>,</span> is not in the interface because your controller doesn’t care about it. The interface is owned by the client code, so its method set is customized to the needs of the client code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Controller</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">l</code><code class="w">     </code><code class="nx">Logger</code><code class="w"/>
<code class="w">    </code><code class="nx">logic</code><code class="w"> </code><code class="nx">Logic</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="nx">Controller</code><code class="p">)</code><code class="w"> </code><code class="nx">SayHello</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="p">.</code><code class="nx">l</code><code class="p">.</code><code class="nx">Log</code><code class="p">(</code><code class="s">"In SayHello"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">userID</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">URL</code><code class="p">.</code><code class="nx">Query</code><code class="p">().</code><code class="nx">Get</code><code class="p">(</code><code class="s">"user_id"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">message</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">logic</code><code class="p">.</code><code class="nx">SayHello</code><code class="p">(</code><code class="nx">userID</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">w</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusBadRequest</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">message</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Just as you have factory functions for your other types, let’s write one for the 
<span class="keep-together"><code>Controller</code>:</span></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">NewController</code><code class="p">(</code><code class="nx">l</code><code class="w"> </code><code class="nx">Logger</code><code class="p">,</code><code class="w"> </code><code class="nx">logic</code><code class="w"> </code><code class="nx">Logic</code><code class="p">)</code><code class="w"> </code><code class="nx">Controller</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">Controller</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">l</code><code class="p">:</code><code class="w">     </code><code class="nx">l</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">logic</code><code class="p">:</code><code class="w"> </code><code class="nx">logic</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Again, you accept interfaces and return structs.</p>

<p>Finally, you wire up all your components in your <code>main</code> function and start your server:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">l</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">LoggerAdapter</code><code class="p">(</code><code class="nx">LogOutput</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">ds</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewSimpleDataStore</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">logic</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewSimpleLogic</code><code class="p">(</code><code class="nx">l</code><code class="p">,</code><code class="w"> </code><code class="nx">ds</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">c</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">NewController</code><code class="p">(</code><code class="nx">l</code><code class="p">,</code><code class="w"> </code><code class="nx">logic</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/hello"</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">SayHello</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":8080"</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find the complete code for this application in the <em>sample_code/dependency_injection</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="ix_ggg123"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 7" data-tertiary-sortas="ggg" id="ix_g123g"/></p>

<p>The <code>main</code> function is the only part of the code that knows what all the concrete types actually are. If you want to swap in different implementations, this is the only place that needs to change. Externalizing the dependencies via dependency injection means that you limit the changes that are needed to evolve your code over time.</p>

<p>Dependency injection is also a great pattern for making testing easier. It shouldn’t be surprising, since writing unit tests is effectively reusing your code in a different environment, one that constrains the inputs and outputs to validate functionality. For example, you can validate the logging output in a test by injecting a type that captures the log output and meets the <code>Logger</code> interface. I’ll talk about this more in <a data-type="xref" href="ch15.html#unique_chapter_id_15">Chapter 15</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The line <code>http.HandleFunc("/hello", c.SayHello)</code> demonstrates two points I talked about earlier.</p>

<p>First, you are treating the <code>SayHello</code> method as a function.</p>

<p>Second, the <code>http.HandleFunc</code> function takes in a function and converts it to an <code>http.HandlerFunc</code> function type, which declares a method to meet the <code>http.Handler</code> interface, which is the type used to represent a request handler in Go. You took a method from one type and converted it into another type with its own method. That’s pretty neat.<a data-type="indexterm" data-startref="ch07-depin" id="id1804"/><a data-type="indexterm" data-startref="ch07-depin2" id="id1805"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wire"><div class="sect1" id="id94">
<h1>Wire</h1>

<p>If you feel that writing dependency injection<a data-type="indexterm" data-primary="dependency injection via implicit interfaces" data-secondary="Wire helper instead" id="id1806"/><a data-type="indexterm" data-primary="Wire helper (Google)" id="id1807"/><a data-type="indexterm" data-primary="Google Wire helper" id="id1808"/> code by hand is too much work, you can use <a href="https://oreil.ly/Akwt_">Wire</a>, a dependency injection helper written by Google. Wire uses code generation to automatically create the concrete type declarations that you wrote yourself in <code>main</code>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Go Isn’t Particularly Object-Oriented (and That’s Great)"><div class="sect1" id="id283">
<h1>Go Isn’t Particularly Object-Oriented (and That’s Great)</h1>

<p>Now that you’ve taken a look at the idiomatic use of types in Go, you can see that categorizing Go as a particular style of language is difficult. It clearly isn’t a strictly procedural language. At the same time, Go’s lack of method overriding, inheritance, or, well, objects means that it is also not a particularly object-oriented language. Go has function types and closures, but it isn’t a functional language either. If you attempt to shoehorn Go into one of these categories, the result is nonidiomatic code.</p>

<p>If you had to label Go’s style,<a data-type="indexterm" data-primary="Go" data-secondary="boring" data-tertiary="but practical" id="id1809"/> the best word to use is <em>practical</em>. It borrows concepts from many places with the overriding goal of creating a language that is simple, readable, and maintainable by large teams for many years.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id95">
<h1>Exercises</h1>

<p>In these exercises, you’re going to build a program that uses what you’ve learned about types, methods, and interfaces. Answers are available in the <em>exercise_solutions</em> directory in the <a href="https://oreil.ly/qJQgV">Chapter 7 repository</a>.<a data-type="indexterm" data-startref="ix_ggg123" id="id1810"/><a data-type="indexterm" data-startref="ix_g123g" id="id1811"/></p>
<ol>
<li>
<p>You have been asked to manage a basketball league and are going to write a program to help you. Define two types. The first one, called <code>Team</code>, has a field for the name of the team and a field for the player names. The second type is called <code>League</code> and has a field called <code>Teams</code> for the teams in the league and a field called <code>Wins</code> that maps a team’s name to its number of wins.</p>
</li>
<li>
<p>Add two methods to <code>League</code>. The first method is called <code>MatchResult</code>. It takes four parameters: the name of the first team, its score in the game, the name of the second team, and its score in the game. This method should update the <code>Wins</code> field in <code>League</code>. Add a second method to <code>League</code> called <code>Ranking</code> that returns a slice of the team names in order of wins. Build your data structures and call these methods from the <code>main</code> function in your program using some sample data.</p>
</li>
<li>
<p>Define an interface called <code>Ranker</code> that has a single method called <code>Ranking</code> that returns a slice of strings. Write a function called <code>RankPrinter</code> with two parameters, the first of type <code>Ranker</code> and the second of type <code>io.Writer</code>. Use the <code>io.WriteString</code> function to write the values returned by <code>Ranker</code> to the <code>io.Writer</code>, with a newline separating each result. Call this function from <code>main</code>.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id345">
<h1>Wrapping Up</h1>

<p>In this chapter, you learned about types, methods, interfaces, and their best practices. In the next chapter, you’ll learn about generics, which improve readability and maintainability by allowing you to reuse logic and custom-written containers with different types.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id1628"><sup><a href="ch07.html#id1628-marker">1</a></sup> For the computer scientists in the audience, I realize that subtyping is not inheritance. However, most programming languages use inheritance to implement subtyping, so the definitions are often conflated in popular usage.</p></div></div></section></div>
</div>
</body></html>