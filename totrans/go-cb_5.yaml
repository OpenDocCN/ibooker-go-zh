- en: Chapter 6\. Data Structure Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has 4 basic types of data structures — arrays, slices, maps and structs.
    We have a separate chapter on structs altogether so we’ll discuss that separately.
    In this chapter we’ll be discussing arrays, slices and maps only. We’ll start
    off with some background information on them before getting into specific recipes
    on using them.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are data structures that represent an ordered sequence of elements of
    the same type. Array sizes are static, they are set when the array is defined
    and cannot be changed subsequently. Arrays are values. This is an important difference
    because in some languages an array is like a pointer to the first item in the
    array. This means if we pass an array to a function we will be passing a copy
    of the array and this could be expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices are data structures that also represent an ordered sequence of elements.
    In fact slices are built on top of arrays and are used much more often than arrays
    because of its flexibility. Slices have no fixed length. Internally, a slice is
    a struct that consists of a pointer to an array, the length of the segment of
    the array, and the capacity of the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are data structures that associate the values of one type (called the *key*)
    with values of another type (called the *value*). Such data structures are very
    common in many other programming languages, called in different names like hash
    table, hash map and dictionary. Internally, a map is a pointer to `runtime.hmap`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that these 3 data structures are the basic building
    blocks of all other data structures, but they are also fundamentally very different
    from each other. In short, arrays are fixed length order lists that are values.
    Slices are structs that has the first element that is a pointer to an array. Maps
    are pointers to an internal hashmap struct.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Creating arrays or slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create arrays or slices.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways of creating arrays or slices including directly from literals,
    or from another array, or using `make`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are very different constructs but conceptually they are very
    similar. As a result, creating arrays and slices are also very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Defining arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define an array by declaring the size of the array in square brackets,
    followed by the data type of the elements. Arrays and slices can only have elements
    of the same type. You can also initialize the array during the declaration by
    putting the elements in curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code snippet above, this is what you will see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The default values for an int or float array is 0\. Note that the size of the
    array cannot be changed once it’s created, but the elements can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slices are constructs that are built on top of arrays. Most of the time when
    you need to deal with ordered lists, you would normally use slices because they
    are more flexible and also much cheaper to use, especially if the underlying array
    is large.
  prefs: []
  type: TYPE_NORMAL
- en: Slices are defined exactly the same way, except you don’t provide the size of
    the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code snippet above, this is what you will see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can also create slices through the `make` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you use `make`, you need to provide the type, the length and an optional
    capacity. If you don’t provide the capacity, it will default to the given length.
    This is what you will see if you run the snippet above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `make` initializes the slice as well.
  prefs: []
  type: TYPE_NORMAL
- en: To find out the length of an array or a slice, you can use the `len` function.
    To find out the capacity of an array or a slice, you can use the `cap` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `make` function above allocates an array of 15 integers, then creates a
    slice with length of 10 and capacity of 15 that points at the first 10 elements
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code above, this is what you get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can also create new slices with the `new` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `new` method doesn’t return the slice directly, it only returns a pointer
    to the slice. It also doesn’t initialize the slice, instead it just zeros it.
    You can see what you get when you run the code above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can’t create new arrays using the `make` function, but we can create new
    arrays using the `new` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we get is a pointer to an array as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 6.2 Accessing arrays or slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access elements in an array of a slice.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to access elements in an array or a slice. Arrays and slices
    are ordered lists so elements in them can be accessed by their index. The elements
    can be access through a single index or through a range of indices. You can also
    access them by iterating through the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing arrays and slices are almost the same. As they are ordered lists,
    we can access an element of an array or a slice through its index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Given the slice above, the 4th element in the slice, given the index 3 (we start
    with 0) is 25 and can be accessed using the name of variable, followed by square
    brackets, and indicating the index within the square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can also access a range of number by using the starting index, followed by
    a colon `:` and the ending index. The ending index is not included and this results
    in a slice (of course).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t have a starting index, the slice will start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t have an ending index, the slice will end with the last element of
    the original slice (or array).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Needless to say if you don’t have either a starting or ending index, the whole
    original slice is returned. While this sounds silly, there is a valid use for
    this — it simply converts an array into a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can also access elements in an array or a slice by iterating through the
    array or slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This uses a normal `for` loop, iterating through the length of the slice, incrementing
    the count at every loop. The resulting output is as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This uses a `for …​ range` loop and returns the index `i` and the value `v`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The resulting output is as below
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 6.3 Modifying arrays or slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add, insert or remove elements in an array or a slice.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to modify elements in an array or a slice. Elements can
    be appended to the end of the slice, inserted at a particular index, removed or
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides accessing the elements in an array or slice, you would also want to
    add, modify or remove elements in a slice. While you cannot add or remove elements
    in an array, you can always modify its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When you modify the element at the given index, it will change the array or
    slice accordingly. In this case, when you run the code, you will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Appending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays cannot change its size, so appending or adding elements to an array is
    out of question. Appending to slices is quite straightforward though. We can just
    use the `append` function, passing it the slice and the new element and we will
    be returned with a new slice that has the appended element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, you will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You cannot append an element of a different type to the slice. However you can
    append multiple items to the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This means you can actually append a slice (or an array) to another slice by
    using the slice unpacking notation `…​`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, appending both an element and an unpacked slice at the same time is
    not allowed. You can only choose to append multiple elements or an unpacked slice,
    but not both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inserting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While appending adds an element to the end of the slice, inserting means adding
    an element anywhere in between elements in a slice. Again, this only applies to
    slices because array sizes are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: There is no built-in function for insertion, unlike `append` but we can still
    use `append` for the task. Let’s say we want to insert the number 1000 between
    elements at index 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to create a slice from the start of the original slice, to the
    index 2 plus 1\. This will reserve a space for the new element we want to add.
    Next we append this slice to another slice that begins at the index 2 to the end
    of the original slice, using the unpack notation. With this, we have created a
    new element between the index 2 and 3\. Finally, we set the new element, 1000,
    at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: As as result we will get this new slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What if we want to add an element to the beginning of the slice? Let’s say we
    want to add the integer 2000 to the beginning of the slice. This is quite simple,
    we simply append the value, in the form of a slice, to the unpacked values of
    the original slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That was the case with inserting a single element. What if we want to insert
    another slice in between another slice? Let’s say we want to insert the slice
    `[]int{1000, 2000, 3000, 4000}` in between our `numbers` slice.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways of doing this, but we’ll stick with using `append`, which
    is one of the shortest way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First of all, we need to create another slice, `tail` to store the *tail* part
    of the original slice. We can’t simply slice it and store into another variable
    (this is called *shallow copy*), because remember — slices are not arrays, they
    are a pointer to a part of the array, and its length. If we slice `numbers` and
    store it in `tail`, when we change `numbers`, `tail` will also change, and that
    is not what we want. Instead, we want to create a new slice by appending it to
    an empty slice of ints.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have put the tail aside, we append the head of `numbers` to the
    unpacked `inserted`. Finally we append `numbers` (which now consist of the head
    of the original slice, and `inserted`) and the `tail`. This is what we should
    get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Removing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removing elements from a slice is very easy. If it’s at the start or end of
    the slice, you simply re-slice it accordingly to remove either the start or the
    end of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take out the first element of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When you run the code above, you will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s take out the last element of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you run the code above, you will get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Removing elements in between is quite straightforward too. You simply append
    the head of the original slice with the tail of the original slice, removing whatever
    is in between. In this case, we want to remove the element at index 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we run the code above, we get this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 6.4 Making arrays and slices safe for concurrent use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make arrays and slices safe for concurrent use by multiple goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a mutex from the `sync` library to safeguard the array or slice. Lock the
    array or slice before modifying it, and unlock it after modifications are made.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are not safe for concurrent use. If you are going to share
    a slice or array between goroutines, you need to make it safe from race conditions.
    Go provides a `sync` package that can be used for this, in particular `Mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look first at how a race condition can come about. Race conditions
    occur when a shared resource is used by multiple goroutines trying to access it
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we have a slice of integers named `shared`, that is used
    by 2 functions named `increase` and `decrease`. These 2 functions simply takes
    each element in the shared slice and increases or decreases it by 1 respectively.
    However before we increase or decrease the element, we wait for a very short period
    of time, with the `increase` function waiting for a longer time. This simulates
    the differences in timing between multiple goroutines. We print out the `shared`
    slice before we start modifying the shared element and also after we modify it
    to show the state of the shared slice before and after.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `increase` and `decrease functions from +main` and we make each
    call to the functions a separate goroutine. At the end of the program we wait
    a bit to let all the goroutines finish up (else all goroutines will end when the
    program ends).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When we run the program, you will see something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you run it multiple times it will be a bit different each time. You will
    notice that even though we spin out a goroutine in sequence (sending in the sequence
    number to `modify` each time), the sequence that actually executes is random,
    which is an expected behavior. What we wouldn’t expect is that the goroutines
    overlap each other and the shared slice is incremented or decremented depending
    on which goroutine accesses it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we look at the first line in the output `[-4 a] : [1 2 3 4
    5 6]` is printed before the loop to decrease each element is called. Subsequently
    after the loop the line that is printed is `[-4 b] : [-2 -2 1 3 4 5]` and you
    can see the first 3 elements are not what is expected!'
  prefs: []
  type: TYPE_NORMAL
- en: Also you can will realise that the overlap even happens within the loop for
    increasing or decreasing the element.
  prefs: []
  type: TYPE_NORMAL
- en: How can we prevent such race conditions? Go has the `sync` package in the standard
    library that provides us with a *mutex* or a mutual exclusion lock.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the output if you call these functions from `main` as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The results are a lot more organized. The goroutines no longer overlap, the
    increase and decrease of elements are orderly and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Sorting arrays of slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort elements in an array or slice.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For `int`, `float64` and `string` arrays or slices you can use `sort.Ints`,
    `sort.Float64s` and `sort.Strings`. You can also use a custom comparator by using
    `sort.Slice`. For structs, you can create a sortable interface by implementing
    the `sort.Interface` interface and then using `sort.Sort` to sort the array or
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are ordered sequence of elements. However this doesn’t mean
    they are sorted in any way, it only means the elements are always laid out in
    the same sequence. To sort the arrays or slices, we can use the various functions
    in the `sort` package.
  prefs: []
  type: TYPE_NORMAL
- en: For `int`, `float64` and `string` we can use the corresponding `sort.Ints`,
    `sort.Float64s` and `sort.Strings` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we run the code above, this is what we will see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is sorted in ascending order. What if we want to sort it in descending
    order? There is no ready-made function to sort in descending order, but we want
    easily use a simple `for` loop to reverse the sorted slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We simply find the middle of the slice, and then using a loop, we exchange the
    elements with their opposite side, starting from that middle. If we run the snippet
    above, this is what you will get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `sort.Slice` function, passing in our own `less` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will product the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `less` function, which is the second parameter in the `sort.Slice` function,
    takes in 2 parameters `i` and `j`, indices of the consecutive elements of the
    slice. It’s supposed to return true if the element at `i` is less than the element
    at `j` when sorting.
  prefs: []
  type: TYPE_NORMAL
- en: What if the elements are the same? Using `sort.Slice` means the elements order
    might be reversed from their original order (or remain the same). If you want
    the order to be consistently the same as the original, you can use `sort.SliceStable`.
  prefs: []
  type: TYPE_NORMAL
- en: The `sort.Slice` function works with slices with any types, so this means you
    can also sort custom structs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above you will the output below, with the `people` slice
    sorted according to the ages of the people.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Another way of sorting structs is by implementing the `sort.Interface`. Let’s
    see how we can do this for the `Person` struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We want to sort a slice of structs, so we need to associate the interface functions
    to the slice, not the struct. We create a type named `ByAge` that is a slice of
    `Person` structs. Next, we associate the `Len`, `Less` and `Swap` functions to
    `ByAge`, making it a struct that implements `sort.Interface`. The `Less` method
    here is the same as the one we used in the `sort.Slice` function above.
  prefs: []
  type: TYPE_NORMAL
- en: Using this is quite simple. We cast `people` to `ByAge`, and pass that into
    `sort.Sort`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you run the code above, you will see the same results as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Implementing `sort.Interface` is a bit long-winded, but there are certainly
    some advantages. For one, we can use the `sort.Reverse` to sort by descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This produces the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `sort.IsSorted` function to check if the slice is already
    sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The biggest advantage though, is using `sort.Interface` is a lot more performant
    than using `sort.Slice`. Let’s do a simple benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here’s the results of the benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the `sort.Interface` is more efficient. This is because
    `sort.Slice` uses `interface{}` as the first parameter. This means it takes in
    any structs but is less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 6.6 Creating maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create new maps.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `map` keyword to declare it, and then use the `make` function to initialize
    it. Maps must be intialized before use.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a map, we can use the `map` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The snippet above declares a map named `people`, that maps a key of type string
    to a value of type int. The `people` map can’t be used yet since its zero-value
    is nil. To use it we need to initialize it with the `make` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If it looks silly to you that you have to repeat `map[string]int` in both the
    declaration and initialization, you should look at doing both at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is will create an empty map. To populate the map you can map a string to
    an int.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You can also initialize the map this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you print the map out, this is how it will look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 6.7 Accessing maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access keys and values in a map.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the key within square brackets to access the value in a map. You can also
    use a `for …​ range` loop to iterate through map.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing the values given a key is straightforward. Just use the key within
    square brackets to access the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: What if the key doesn’t exist? Nothing happens, Go simply returns the zero-value
    of the value type. In our case the zero value of an integer is 0, so if we do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It will simply returns a 0\. This might not be what we’re looking for (especially
    if 0 is a valid response) so there is a mechanism to check if the key exists or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The *comma, ok* pattern is commonly used in many cases, and can be used here
    to check if the key exists in the map. The use is obvious, if the key exists,
    `ok` becomes true, else if is be false. The `ok` is not a keyword though, you
    can use any variable name, it’s using the multiple value assignment. The value
    is still returned but since you know the key doesn’t exist and it’s just a zero-value,
    you would probably not use it.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a `for …​ range` loop to iterate through a map, just like what
    we did with arrays and slices, except instead of getting the index and the element,
    we get the key and the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Running the code above will give us this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you just want the keys, you can just leave out the the second value you get
    from the range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You will get this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How about if we want just the values? There is no special way of getting just
    the values, you have to use the same mechanism, and put them all in a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You will get this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 6.8 Modifying maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to modify or remove elements in a map.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `delete` function to remove key-value pairs from a map. To modify the
    value, just re-assign the value.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modifying a value is simply overriding the existing value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The value of `people["Alice"]` will become 23.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a key, Go provides a built-in function named `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This will be the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: What happens if you try to delete a key that doesn’t exist? Nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Sorting maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want sort a map by its keys.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get the keys of the map in a slice and sort that slice. Then using the sorted
    slice of keys, iterate through map again.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are unordered. This means each time you iterate through a map, the order
    of the key-value pairs might not be the same as the previous time. So how can
    we ensure that it’s the same each time?
  prefs: []
  type: TYPE_NORMAL
- en: First, we extract the keys out into a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Then we sort the keys accordingly. In this case we want to sort by descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Finally we can access the map by the descending order of the keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: When we run the code, we will see this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: About the Author
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Chang Sau Sheong** has been in the software development industry for more
    than 27 years, and has been involved in building software products in many industries
    and using various technologies. He is an active member of the software development
    communities for Java, Ruby previously and now focuses mostly on Go, running meetups
    and giving talks in conferences all around the world. He also runs the GopherCon
    Singapore, one of the largest community-led developer conferences in Southeast
    Asia, and has been doing so since 2017\. Sau Sheong has written 4 programming
    books, 3 in Ruby and the last one in Go.'
  prefs: []
  type: TYPE_NORMAL
