- en: Chapter 6\. Data Structure Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has 4 basic types of data structures — arrays, slices, maps and structs.
    We have a separate chapter on structs altogether so we’ll discuss that separately.
    In this chapter we’ll be discussing arrays, slices and maps only. We’ll start
    off with some background information on them before getting into specific recipes
    on using them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Array
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are data structures that represent an ordered sequence of elements of
    the same type. Array sizes are static, they are set when the array is defined
    and cannot be changed subsequently. Arrays are values. This is an important difference
    because in some languages an array is like a pointer to the first item in the
    array. This means if we pass an array to a function we will be passing a copy
    of the array and this could be expensive.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Slice
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices are data structures that also represent an ordered sequence of elements.
    In fact slices are built on top of arrays and are used much more often than arrays
    because of its flexibility. Slices have no fixed length. Internally, a slice is
    a struct that consists of a pointer to an array, the length of the segment of
    the array, and the capacity of the underlying array.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Map
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are data structures that associate the values of one type (called the *key*)
    with values of another type (called the *value*). Such data structures are very
    common in many other programming languages, called in different names like hash
    table, hash map and dictionary. Internally, a map is a pointer to `runtime.hmap`
    structure.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that these 3 data structures are the basic building
    blocks of all other data structures, but they are also fundamentally very different
    from each other. In short, arrays are fixed length order lists that are values.
    Slices are structs that has the first element that is a pointer to an array. Maps
    are pointers to an internal hashmap struct.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Creating arrays or slices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create arrays or slices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways of creating arrays or slices including directly from literals,
    or from another array, or using `make`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are very different constructs but conceptually they are very
    similar. As a result, creating arrays and slices are also very similar.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Defining arrays
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define an array by declaring the size of the array in square brackets,
    followed by the data type of the elements. Arrays and slices can only have elements
    of the same type. You can also initialize the array during the declaration by
    putting the elements in curly brackets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you run the code snippet above, this is what you will see.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default values for an int or float array is 0\. Note that the size of the
    array cannot be changed once it’s created, but the elements can be changed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Defining slices
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slices are constructs that are built on top of arrays. Most of the time when
    you need to deal with ordered lists, you would normally use slices because they
    are more flexible and also much cheaper to use, especially if the underlying array
    is large.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Slices are defined exactly the same way, except you don’t provide the size of
    the slice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the code snippet above, this is what you will see.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can also create slices through the `make` function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you use `make`, you need to provide the type, the length and an optional
    capacity. If you don’t provide the capacity, it will default to the given length.
    This is what you will see if you run the snippet above.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `make` initializes the slice as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: To find out the length of an array or a slice, you can use the `len` function.
    To find out the capacity of an array or a slice, you can use the `cap` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `make` function above allocates an array of 15 integers, then creates a
    slice with length of 10 and capacity of 15 that points at the first 10 elements
    of the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code above, this is what you get.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also create new slices with the `new` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `new` method doesn’t return the slice directly, it only returns a pointer
    to the slice. It also doesn’t initialize the slice, instead it just zeros it.
    You can see what you get when you run the code above.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can’t create new arrays using the `make` function, but we can create new
    arrays using the `new` function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we get is a pointer to an array as below.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 6.2 Accessing arrays or slices
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access elements in an array of a slice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to access elements in an array or a slice. Arrays and slices
    are ordered lists so elements in them can be accessed by their index. The elements
    can be access through a single index or through a range of indices. You can also
    access them by iterating through the elements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing arrays and slices are almost the same. As they are ordered lists,
    we can access an element of an array or a slice through its index.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Given the slice above, the 4th element in the slice, given the index 3 (we start
    with 0) is 25 and can be accessed using the name of variable, followed by square
    brackets, and indicating the index within the square brackets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can also access a range of number by using the starting index, followed by
    a colon `:` and the ending index. The ending index is not included and this results
    in a slice (of course).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we don’t have a starting index, the slice will start at 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we don’t have an ending index, the slice will end with the last element of
    the original slice (or array).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Needless to say if you don’t have either a starting or ending index, the whole
    original slice is returned. While this sounds silly, there is a valid use for
    this — it simply converts an array into a slice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also access elements in an array or a slice by iterating through the
    array or slice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This uses a normal `for` loop, iterating through the length of the slice, incrementing
    the count at every loop. The resulting output is as below.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This uses a `for …​ range` loop and returns the index `i` and the value `v`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resulting output is as below
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 6.3 Modifying arrays or slices
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add, insert or remove elements in an array or a slice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways to modify elements in an array or a slice. Elements can
    be appended to the end of the slice, inserted at a particular index, removed or
    modified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides accessing the elements in an array or slice, you would also want to
    add, modify or remove elements in a slice. While you cannot add or remove elements
    in an array, you can always modify its elements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you modify the element at the given index, it will change the array or
    slice accordingly. In this case, when you run the code, you will get this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Appending
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays cannot change its size, so appending or adding elements to an array is
    out of question. Appending to slices is quite straightforward though. We can just
    use the `append` function, passing it the slice and the new element and we will
    be returned with a new slice that has the appended element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you run the code above, you will get this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You cannot append an element of a different type to the slice. However you can
    append multiple items to the slice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means you can actually append a slice (or an array) to another slice by
    using the slice unpacking notation `…​`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, appending both an element and an unpacked slice at the same time is
    not allowed. You can only choose to append multiple elements or an unpacked slice,
    but not both at the same time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inserting
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While appending adds an element to the end of the slice, inserting means adding
    an element anywhere in between elements in a slice. Again, this only applies to
    slices because array sizes are fixed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: There is no built-in function for insertion, unlike `append` but we can still
    use `append` for the task. Let’s say we want to insert the number 1000 between
    elements at index 2 and 3.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we need to create a slice from the start of the original slice, to the
    index 2 plus 1\. This will reserve a space for the new element we want to add.
    Next we append this slice to another slice that begins at the index 2 to the end
    of the original slice, using the unpack notation. With this, we have created a
    new element between the index 2 and 3\. Finally, we set the new element, 1000,
    at index 2.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: As as result we will get this new slice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What if we want to add an element to the beginning of the slice? Let’s say we
    want to add the integer 2000 to the beginning of the slice. This is quite simple,
    we simply append the value, in the form of a slice, to the unpacked values of
    the original slice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That was the case with inserting a single element. What if we want to insert
    another slice in between another slice? Let’s say we want to insert the slice
    `[]int{1000, 2000, 3000, 4000}` in between our `numbers` slice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways of doing this, but we’ll stick with using `append`, which
    is one of the shortest way.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First of all, we need to create another slice, `tail` to store the *tail* part
    of the original slice. We can’t simply slice it and store into another variable
    (this is called *shallow copy*), because remember — slices are not arrays, they
    are a pointer to a part of the array, and its length. If we slice `numbers` and
    store it in `tail`, when we change `numbers`, `tail` will also change, and that
    is not what we want. Instead, we want to create a new slice by appending it to
    an empty slice of ints.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have put the tail aside, we append the head of `numbers` to the
    unpacked `inserted`. Finally we append `numbers` (which now consist of the head
    of the original slice, and `inserted`) and the `tail`. This is what we should
    get.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Removing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removing elements from a slice is very easy. If it’s at the start or end of
    the slice, you simply re-slice it accordingly to remove either the start or the
    end of the slice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take out the first element of the slice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you run the code above, you will get this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now let’s take out the last element of the slice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When you run the code above, you will get this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Removing elements in between is quite straightforward too. You simply append
    the head of the original slice with the tail of the original slice, removing whatever
    is in between. In this case, we want to remove the element at index 2.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we run the code above, we get this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 6.4 Making arrays and slices safe for concurrent use
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make arrays and slices safe for concurrent use by multiple goroutines.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a mutex from the `sync` library to safeguard the array or slice. Lock the
    array or slice before modifying it, and unlock it after modifications are made.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are not safe for concurrent use. If you are going to share
    a slice or array between goroutines, you need to make it safe from race conditions.
    Go provides a `sync` package that can be used for this, in particular `Mutex`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look first at how a race condition can come about. Race conditions
    occur when a shared resource is used by multiple goroutines trying to access it
    at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the example above, we have a slice of integers named `shared`, that is used
    by 2 functions named `increase` and `decrease`. These 2 functions simply takes
    each element in the shared slice and increases or decreases it by 1 respectively.
    However before we increase or decrease the element, we wait for a very short period
    of time, with the `increase` function waiting for a longer time. This simulates
    the differences in timing between multiple goroutines. We print out the `shared`
    slice before we start modifying the shared element and also after we modify it
    to show the state of the shared slice before and after.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We call the `increase` and `decrease functions from +main` and we make each
    call to the functions a separate goroutine. At the end of the program we wait
    a bit to let all the goroutines finish up (else all goroutines will end when the
    program ends).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we run the program, you will see something like this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you run it multiple times it will be a bit different each time. You will
    notice that even though we spin out a goroutine in sequence (sending in the sequence
    number to `modify` each time), the sequence that actually executes is random,
    which is an expected behavior. What we wouldn’t expect is that the goroutines
    overlap each other and the shared slice is incremented or decremented depending
    on which goroutine accesses it first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we look at the first line in the output `[-4 a] : [1 2 3 4
    5 6]` is printed before the loop to decrease each element is called. Subsequently
    after the loop the line that is printed is `[-4 b] : [-2 -2 1 3 4 5]` and you
    can see the first 3 elements are not what is expected!'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Also you can will realise that the overlap even happens within the loop for
    increasing or decreasing the element.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How can we prevent such race conditions? Go has the `sync` package in the standard
    library that provides us with a *mutex* or a mutual exclusion lock.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here’s the output if you call these functions from `main` as before.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The results are a lot more organized. The goroutines no longer overlap, the
    increase and decrease of elements are orderly and consistent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Sorting arrays of slices
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort elements in an array or slice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For `int`, `float64` and `string` arrays or slices you can use `sort.Ints`,
    `sort.Float64s` and `sort.Strings`. You can also use a custom comparator by using
    `sort.Slice`. For structs, you can create a sortable interface by implementing
    the `sort.Interface` interface and then using `sort.Sort` to sort the array or
    slice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and slices are ordered sequence of elements. However this doesn’t mean
    they are sorted in any way, it only means the elements are always laid out in
    the same sequence. To sort the arrays or slices, we can use the various functions
    in the `sort` package.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: For `int`, `float64` and `string` we can use the corresponding `sort.Ints`,
    `sort.Float64s` and `sort.Strings` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run the code above, this is what we will see.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is sorted in ascending order. What if we want to sort it in descending
    order? There is no ready-made function to sort in descending order, but we want
    easily use a simple `for` loop to reverse the sorted slice.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按升序排序的。如果我们想要按降序排序怎么办？目前没有现成的函数可以按降序排序，但我们可以简单地使用一个 `for` 循环来反转排序后的切片。
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We simply find the middle of the slice, and then using a loop, we exchange the
    elements with their opposite side, starting from that middle. If we run the snippet
    above, this is what you will get.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地找到切片的中间部分，然后使用循环，从中间开始，将元素与它们的对侧交换。如果我们运行上面的片段，你将会得到这样的结果。
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can also use the `sort.Slice` function, passing in our own `less` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `sort.Slice` 函数，传入我们自己的 `less` 函数。
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will product the output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生输出。
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `less` function, which is the second parameter in the `sort.Slice` function,
    takes in 2 parameters `i` and `j`, indices of the consecutive elements of the
    slice. It’s supposed to return true if the element at `i` is less than the element
    at `j` when sorting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 函数是 `sort.Slice` 函数的第二个参数，接受两个参数 `i` 和 `j`，是切片连续元素的索引。它的作用是在排序时，如果 `i`
    处的元素小于 `j` 处的元素则返回 true。'
- en: What if the elements are the same? Using `sort.Slice` means the elements order
    might be reversed from their original order (or remain the same). If you want
    the order to be consistently the same as the original, you can use `sort.SliceStable`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素相同怎么办？使用 `sort.Slice` 意味着元素的顺序可能与它们的原始顺序相反（或保持不变）。如果希望顺序始终与原始顺序一致，可以使用 `sort.SliceStable`。
- en: The `sort.Slice` function works with slices with any types, so this means you
    can also sort custom structs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort.Slice` 函数可以处理任何类型的切片，这意味着你也可以对自定义结构体进行排序。'
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you run the code above you will the output below, with the `people` slice
    sorted according to the ages of the people.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述代码，你将会看到下面的输出，`people` 切片按照人们的年龄排序。
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Another way of sorting structs is by implementing the `sort.Interface`. Let’s
    see how we can do this for the `Person` struct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种排序结构体的方法是实现 `sort.Interface`。让我们看看如何为 `Person` 结构体做这个操作。
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We want to sort a slice of structs, so we need to associate the interface functions
    to the slice, not the struct. We create a type named `ByAge` that is a slice of
    `Person` structs. Next, we associate the `Len`, `Less` and `Swap` functions to
    `ByAge`, making it a struct that implements `sort.Interface`. The `Less` method
    here is the same as the one we used in the `sort.Slice` function above.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要对结构体切片进行排序，所以我们需要将接口函数关联到切片，而不是结构体。我们创建一个名为 `ByAge` 的类型，它是 `Person` 结构体的切片。接下来，我们将
    `Len`、`Less` 和 `Swap` 函数关联到 `ByAge`，使其成为一个实现了 `sort.Interface` 的结构体。这里的 `Less`
    方法与我们在上面 `sort.Slice` 函数中使用的方法相同。
- en: Using this is quite simple. We cast `people` to `ByAge`, and pass that into
    `sort.Sort`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个非常简单。我们将 `people` 强制转换为 `ByAge`，然后将其传入 `sort.Sort`。
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you run the code above, you will see the same results as below.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，你将会看到与下面相同的结果。
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Implementing `sort.Interface` is a bit long-winded, but there are certainly
    some advantages. For one, we can use the `sort.Reverse` to sort by descending
    order.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `sort.Interface` 有点冗长，但显然有一些优势。首先，我们可以使用 `sort.Reverse` 按降序排序。
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This produces the following output.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出。
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can also use the `sort.IsSorted` function to check if the slice is already
    sorted.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `sort.IsSorted` 函数来检查切片是否已经排序。
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The biggest advantage though, is using `sort.Interface` is a lot more performant
    than using `sort.Slice`. Let’s do a simple benchmark.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势在于，使用 `sort.Interface` 比使用 `sort.Slice` 更高效。让我们做一个简单的基准测试。
- en: '[PRE60]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here’s the results of the benchmark.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基准测试的结果。
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, using the `sort.Interface` is more efficient. This is because
    `sort.Slice` uses `interface{}` as the first parameter. This means it takes in
    any structs but is less efficient.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用 `sort.Interface` 更有效率。这是因为 `sort.Slice` 使用 `interface{}` 作为第一个参数。这意味着它可以接受任何结构体但效率较低。
- en: 6.6 Creating maps
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 创建地图
- en: Problem
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create new maps.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你想创建新的地图。
- en: Solution
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `map` keyword to declare it, and then use the `make` function to initialize
    it. Maps must be intialized before use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map` 关键字声明它，然后使用 `make` 函数进行初始化。在使用之前必须先初始化地图。
- en: Discussion
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To create a map, we can use the `map` keyword.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地图，我们可以使用 `map` 关键字。
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The snippet above declares a map named `people`, that maps a key of type string
    to a value of type int. The `people` map can’t be used yet since its zero-value
    is nil. To use it we need to initialize it with the `make` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If it looks silly to you that you have to repeat `map[string]int` in both the
    declaration and initialization, you should look at doing both at the same time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is will create an empty map. To populate the map you can map a string to
    an int.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can also initialize the map this way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you print the map out, this is how it will look.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 6.7 Accessing maps
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access keys and values in a map.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the key within square brackets to access the value in a map. You can also
    use a `for …​ range` loop to iterate through map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing the values given a key is straightforward. Just use the key within
    square brackets to access the values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What if the key doesn’t exist? Nothing happens, Go simply returns the zero-value
    of the value type. In our case the zero value of an integer is 0, so if we do
    this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It will simply returns a 0\. This might not be what we’re looking for (especially
    if 0 is a valid response) so there is a mechanism to check if the key exists or
    not.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The *comma, ok* pattern is commonly used in many cases, and can be used here
    to check if the key exists in the map. The use is obvious, if the key exists,
    `ok` becomes true, else if is be false. The `ok` is not a keyword though, you
    can use any variable name, it’s using the multiple value assignment. The value
    is still returned but since you know the key doesn’t exist and it’s just a zero-value,
    you would probably not use it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a `for …​ range` loop to iterate through a map, just like what
    we did with arrays and slices, except instead of getting the index and the element,
    we get the key and the value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Running the code above will give us this output.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you just want the keys, you can just leave out the the second value you get
    from the range.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You will get this output.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How about if we want just the values? There is no special way of getting just
    the values, you have to use the same mechanism, and put them all in a slice.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will get this output.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 6.8 Modifying maps
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to modify or remove elements in a map.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `delete` function to remove key-value pairs from a map. To modify the
    value, just re-assign the value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modifying a value is simply overriding the existing value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The value of `people["Alice"]` will become 23.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: To remove a key, Go provides a built-in function named `delete`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This will be the output.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What happens if you try to delete a key that doesn’t exist? Nothing happens.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 6.9 Sorting maps
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want sort a map by its keys.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get the keys of the map in a slice and sort that slice. Then using the sorted
    slice of keys, iterate through map again.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps are unordered. This means each time you iterate through a map, the order
    of the key-value pairs might not be the same as the previous time. So how can
    we ensure that it’s the same each time?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是无序的。这意味着每次遍历映射时，键值对的顺序可能与上次不同。那么我们如何确保每次都是相同的顺序呢？
- en: First, we extract the keys out into a slice.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将键提取到一个切片中。
- en: '[PRE80]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Then we sort the keys accordingly. In this case we want to sort by descending
    order.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据需要对键进行排序。在这种情况下，我们要按照降序排序。
- en: '[PRE81]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finally we can access the map by the descending order of the keys.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按键的降序访问映射。
- en: '[PRE82]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When we run the code, we will see this.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，我们将看到这个结果。
- en: '[PRE83]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: About the Author
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者简介
- en: '**Chang Sau Sheong** has been in the software development industry for more
    than 27 years, and has been involved in building software products in many industries
    and using various technologies. He is an active member of the software development
    communities for Java, Ruby previously and now focuses mostly on Go, running meetups
    and giving talks in conferences all around the world. He also runs the GopherCon
    Singapore, one of the largest community-led developer conferences in Southeast
    Asia, and has been doing so since 2017\. Sau Sheong has written 4 programming
    books, 3 in Ruby and the last one in Go.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**张守祥**在软件开发行业已超过27年，并参与了多个行业的软件产品构建，使用了多种技术。他是Java、Ruby社区的活跃成员，现在主要专注于Go语言，在全球各地的会议上组织和发表演讲。他还主办着GopherCon新加坡，这是东南亚最大的社区主导的开发者大会之一，自2017年以来一直如此。张守祥已经写了4本编程书籍，其中3本是关于Ruby，最后一本是关于Go的。'
