["```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n   fmt.Println(\"Hello World!\")\n}\n```", "```go\npackage main\n\nconst privateConst = 1\nconst PublicConst = 2\n\nvar privateVar int\nvar PublicVar int\n\nfunc privateFunc() {}\nfunc PublicFunc()  {}\n\ntype privateStruct struct {\n   privateField int\n   PublicField  int ![1](assets/1.png)\n}\n\nfunc (privateStruct) privateMethod() {}\nfunc (privateStruct) PublicMethod()  {} ![1](assets/1.png)\n\ntype PublicStruct struct {\n   privateField int\n   PublicField  int\n}\n\nfunc (PublicStruct) privateMethod() {}\nfunc (PublicStruct) PublicMethod()  {}\n\ntype privateInterface interface {\n   privateMethod()\n   PublicMethod() ![1](assets/1.png)\n}\n\ntype PublicInterface interface {\n   privateMethod()\n   PublicMethod()\n}\n```", "```go\nimport (\n   \"context\" ![1](assets/1.png)\n   \"net/http\"\n   _ \"net/http/pprof\" ![2](assets/2.png)\n\n   \"github.com/oklog/run\" ![3](assets/3.png)\n   \"github.com/prometheus/common/version\"\n   \"go.uber.org/atomic\"\n\n   \"github.com/prometheus/prometheus/config\" ![4](assets/4.png)\n   promruntime \"github.com/prometheus/prometheus/pkg/runtime\"\n   \"github.com/prometheus/prometheus/scrape\"\n   \"github.com/prometheus/prometheus/storage\"\n   \"github.com/prometheus/prometheus/storage/remote\"\n   \"github.com/prometheus/prometheus/tsdb\"\n   \"github.com/prometheus/prometheus/util/strutil\"\n   \"github.com/prometheus/prometheus/web\"\n)\n```", "```go\nfunc noErrCanHappen() int { ![1](assets/1.png)\n   // ...\n   return 204\n}\n\nfunc doOrErr() error { ![2](assets/2.png)\n   // ...\n   if shouldFail() {\n      return errors.New(\"ups, XYZ failed\")\n   }\n   return nil\n}\n\nfunc intOrErr() (int, error) { ![3](assets/3.png)\n   // ...\n   if shouldFail() {\n      return 0, errors.New(\"ups, XYZ2 failed\")\n   }\n   return noErrCanHappen(), nil\n}\n```", "```go\nimport \"github.com/efficientgo/core/errors\" ![1](assets/1.png)\n\nfunc main() {\n   ret := noErrCanHappen()\n   if err := nestedDoOrErr(); err != nil { ![2](assets/2.png)\n      // handle error\n   }\n   ret2, err := intOrErr()\n   if err != nil {\n      // handle error\n   }\n   // ...\n}\n\nfunc nestedDoOrErr() error {\n   // ...\n   if err := doOrErr(); err != nil {\n      return errors.Wrap(err, \"do\") ![3](assets/3.png)\n   }\n   return nil\n}\n```", "```go\npackage main\n\nimport  \"net/http\"\n\nfunc handle(w http.ResponseWriter, _ *http.Request) {\n   w.Write([]byte(\"It kind of works!\"))\n}\n\nfunc main() {\n   http.ListenAndServe(\":8080\", http.HandlerFunc(handle))\n}\n```", "```go\npackage main\n\nfunc use(_ int) {}\n\nfunc main() {\n   var a int // error: a declared but not used ![1](assets/1.png)\n\n   b := 1 // error: b declared but not used ![1](assets/1.png)\n\n   var c int\n   d := c // error: d declared but not used ![1](assets/1.png)\n\n   e := 1\n   use(e) ![2](assets/2.png)\n\n   f := 1\n   _ = f ![3](assets/3.png)\n}\n```", "```go\npackage max\n\nimport (\n   \"math\"\n   \"testing\"\n\n   \"github.com/efficientgo/core/testutil\"\n)\n\nfunc TestMax(t *testing.T) { ![1](assets/1.png)\n   for _, tcase := range []struct { ![2](assets/2.png)\n      a, b     int\n      expected int\n   }{\n      {a: 0, b: 0, expected: 0},\n      {a: -1, b: 0, expected: 0},\n      {a: 1, b: 0, expected: 1},\n      {a: 0, b: -1, expected: 0},\n      {a: 0, b: 1, expected: 1},\n      {a: math.MinInt64, b: math.MaxInt64, expected: math.MaxInt64},\n   } {\n      t.Run(\"\", func(t *testing.T) { ![3](assets/3.png)\n         testutil.Equals(t, tcase.expected, max(tcase.a, tcase.b)) ![4](assets/4.png)\n      })\n   }\n}\n```", "```go\n// Package block contains common functionality for interacting with TSDB blocks\n// in the context of Thanos.\npackage block ![1](assets/1.png)\n\nimport ...\n\nconst (\n   // MetaFilename is the known JSON filename for meta information. ![2](assets/2.png)\n   MetaFilename = \"meta.json\"\n)\n\n// Download the downloads directory... ![2](assets/2.png)\n// BUG(bwplotka): No known bugs, but if there was one, it would be outlined here. ![3](assets/3.png)\nfunc Download(ctx context.Context, id ulid.ULID, dst string) error {\n// ...\n\n// cleanUp cleans the partially uploaded files. ![4](assets/4.png)\nfunc cleanUp(ctx context.Context, id ulid.ULID) error {\n// ...\n```", "```go\npackage block_test\n\nimport ...\n\nfunc ExampleDownload() { ![1](assets/1.png)\n    // ...\n\n    // Output: ... ![2](assets/2.png)\n}\n```", "```go\ntype Block struct { ![1](assets/1.png)\n    id         uuid.UUID\n    start, end time.Time\n    // ...\n}\n\nfunc (b Block) Duration() time.Duration { ![1](assets/1.png)\n    return b.end.Sub(b.start)\n}\n\ntype Group struct {\n    Block ![2](assets/2.png)\n\n    children []uuid.UUID\n}\n\nfunc (g *Group) Merge(b Block) { ![3](assets/3.png)\n    if g.end.IsZero() || g.end.Before(b.end) {\n        g.end = b.end\n    }\n    if g.start.IsZero() || g.start.After(b.start) {\n        g.start = b.start\n    }\n    g.children = append(g.children, b.id)\n}\n\nfunc Compact(blocks ...Block) Block {\n    sort.Sort(sortable(blocks)) ![4](assets/4.png)\n\n    g := &Group{}\n    g.id = uuid.New()\n    for _, b := range blocks {\n        g.Merge(b)\n    }\n    return g.Block ![5](assets/5.png)\n}\n```", "```go\n// A type, typically a collection, that satisfies sort.Interface can be\n// sorted by the routines in this package. The methods require that the\n// elements of the collection be enumerated by an integer index.\ntype Interface interface {\n    // Len is the number of elements in the collection.\n    Len() int\n    // Less reports whether the element with\n    // index i should sort before the element with index j.\n    Less(i, j int) bool\n    // Swap swaps the elements with indexes i and j.\n    Swap(i, j int)\n}\n```", "```go\ntype sortable []Block ![1](assets/1.png)\n\nfunc (s sortable) Len() int           { return len(s) }\nfunc (s sortable) Less(i, j int) bool { return s[i].start.Before(s[j].start) } ![2](assets/2.png)\nfunc (s sortable) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nvar _ sort.Interface = sortable{} ![3](assets/3.png)\n```", "```go\n// import \"golang.org/x/exp/constraints\" ![1](assets/1.png)\n\ntype genericSortableBasic[T constraints.Ordered] []T ![1](assets/1.png)\n\nfunc (s genericSortableBasic[T]) Len() int           { return len(s) }\nfunc (s genericSortableBasic[T]) Less(i, j int) bool { return s[i] < s[j] } ![2](assets/2.png)\nfunc (s genericSortableBasic[T]) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc genericSortBasic[T constraints.Ordered](slice []T) { ![3](assets/3.png)\n    sort.Sort(genericSortableBasic[T](slice))\n}\n\nfunc Example() {\n    toSort := []int{-20, 1, 10, 20}\n   sort.Ints(toSort) ![4](assets/4.png)\n\n   toSort2 := []int{-20, 1, 10, 20}\n   genericSortBasic[int](toSort2) ![4](assets/4.png)\n    // ...\n}\n```", "```go\ntype Comparable[T any] interface { ![1](assets/1.png)\n    Compare(T) int\n}\n\ntype genericSortable[T Comparable[T]] []T ![2](assets/2.png)\n\nfunc (s genericSortable[T]) Len() int           { return len(s) }\nfunc (s genericSortable[T]) Less(i, j int) bool { return s[i].Compare(s[j]) > 0 } ![2](assets/2.png)\nfunc (s genericSortable[T]) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n\nfunc genericSort[T Comparable[T]](slice []T) {\n    sort.Sort(genericSortable[T](slice))\n}\n\nfunc (b Block) Compare(other Block) int { ![3](assets/3.png)\n    // ...\n}\n\nfunc Example() {\n    toSort := []Block{ /* ... */ }\n    sort.Sort(sortable(toSort)) ![4](assets/4.png)\n\n    toSort2 := []Block{ /* ... */ }\n    genericSort[Block](toSort2) ![4](assets/4.png)\n}\n```"]