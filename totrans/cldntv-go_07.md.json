["```go\nvar store = make(map[string]string)\n```", "```go\nfunc Put(key string, value string) error {\n    store[key] = value\n\n    return nil\n}\n```", "```go\nvar ErrorNoSuchKey = errors.New(\"no such key\")\n\nfunc Get(key string) (string, error) {\n    value, ok := store[key]\n\n    if !ok {\n        return \"\", ErrorNoSuchKey\n    }\n\n    return value, nil\n}\n\nfunc Delete(key string) error {\n    delete(store, key)\n\n    return nil\n}\n```", "```go\nif errors.Is(err, ErrorNoSuchKey) {\n    http.Error(w, err.Error(), http.StatusNotFound)\n    return\n}\n```", "```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n)\n\nfunc helloGoHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello net/http!\\n\"))\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", helloGoHandler)\n\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```", "```go\ntype HandlerFunc func(http.ResponseWriter, *http.Request)\n```", "```go\n$ go run .\n```", "```go\n$ curl http://localhost:8080\nHello net/http!\n```", "```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n)\n\nfunc helloMuxHandler(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello gorilla/mux!\\n\"))\n}\n\nfunc main() {\n    r := mux.NewRouter()\n\n    r.HandleFunc(\"/\", helloMuxHandler)\n\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\n$ go run .\nmain.go:7:5: cannot find package \"github.com/gorilla/mux\" in any of:\n        /go/1.15.8/libexec/src/github.com/gorilla/mux (from $GOROOT)\n        /go/src/github.com/gorilla/mux (from $GOPATH)\n```", "```go\n$ go mod init example.com/gorilla\ngo: creating new go.mod: module example.com/gorilla\n```", "```go\n$ cat go.mod\nmodule example.com/gorilla\n\ngo 1.15\n```", "```go\n$ go mod tidy\ngo: finding module for package github.com/gorilla/mux\ngo: found github.com/gorilla/mux in github.com/gorilla/mux v1.8.0\n```", "```go\n$ cat go.mod\nmodule example.com/gorilla\n\ngo 1.15\n\nrequire github.com/gorilla/mux v1.8.0\n```", "```go\n$ go run .\n```", "```go\n$ curl http://localhost:8080\nHello gorilla/mux!\n```", "```go\nr := mux.NewRouter()\nr.HandleFunc(\"/products/{key}\", ProductHandler)\nr.HandleFunc(\"/articles/{category}/\", ArticlesCategoryHandler)\nr.HandleFunc(\"/articles/{category}/{id:[0-9]+}\", ArticleHandler)\n```", "```go\nvars := mux.Vars(request)\ncategory := vars[\"category\"]\n```", "```go\nr := mux.NewRouter()\n\nr.HandleFunc(\"/products\", ProductsHandler).\n    Host(\"www.example.com\").                // Only match a specific domain\n    Methods(\"GET\", \"PUT\").                  // Only match GET+PUT methods\n    Schemes(\"http\")                         // Only match the http scheme\n```", "```go\n// keyValuePutHandler expects to be called with a PUT request for\n// the \"/v1/key/{key}\" resource.\nfunc keyValuePutHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)                     // Retrieve \"key\" from the request\n    key := vars[\"key\"]\n\n    value, err := io.ReadAll(r.Body)        // The request body has our value\n    defer r.Body.Close()\n\n    if err != nil {                         // If we have an error, report it\n        http.Error(w,\n            err.Error(),\n            http.StatusInternalServerError)\n        return\n    }\n\n    err = Put(key, string(value))           // Store the value as a string\n    if err != nil {                         // If we have an error, report it\n        http.Error(w,\n            err.Error(),\n            http.StatusInternalServerError)\n        return\n    }\n\n    w.WriteHeader(http.StatusCreated)       // All good! Return StatusCreated\n}\n```", "```go\nfunc main() {\n    r := mux.NewRouter()\n\n    // Register keyValuePutHandler as the handler function for PUT\n    // requests matching \"/v1/{key}\"\n    r.HandleFunc(\"/v1/{key}\", keyValuePutHandler).Methods(\"PUT\")\n\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\n$ curl -X PUT -d 'Hello, key-value store!' -v http://localhost:8080/v1/key-a\n```", "```go\n> PUT /v1/key-a HTTP/1.1\n< HTTP/1.1 201 Created\n```", "```go\n$ curl -X GET -v http://localhost:8080/v1/key-a\n> GET /v1/key-a HTTP/1.1\n< HTTP/1.1 405 Method Not Allowed\n```", "```go\nfunc keyValueGetHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)                     // Retrieve \"key\" from the request\n    key := vars[\"key\"]\n\n    value, err := Get(key)                  // Get value for key\n    if errors.Is(err, ErrorNoSuchKey) {\n        http.Error(w,err.Error(), http.StatusNotFound)\n        return\n    }\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    w.Write([]byte(value))                  // Write the value to the response\n}\n```", "```go\nfunc main() {\n    r := mux.NewRouter()\n\n    r.HandleFunc(\"/v1/{key}\", keyValuePutHandler).Methods(\"PUT\")\n    r.HandleFunc(\"/v1/{key}\", keyValueGetHandler).Methods(\"GET\")\n\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\n$ curl -X PUT -d 'Hello, key-value store!' -v http://localhost:8080/v1/key-a\n> PUT /v1/key-a HTTP/1.1\n< HTTP/1.1 201 Created\n\n$ curl -v http://localhost:8080/v1/key-a\n> GET /v1/key-a HTTP/1.1\n< HTTP/1.1 200 OK\nHello, key-value store!\n```", "```go\n$ curl -X PUT -d 'Hello, key-value store!' -v http://localhost:8080/v1/key-a\n> PUT /v1/key-a HTTP/1.1\n< HTTP/1.1 201 Created\n\n$ curl -v http://localhost:8080/v1/key-a\n> GET /v1/key-a HTTP/1.1\n< HTTP/1.1 200 OK\nHello, key-value store!\n```", "```go\n$ curl -X PUT -d 'Hello, again, key-value store!' \\\n    -v http://localhost:8080/v1/key-a\n> PUT /v1/key-a HTTP/1.1\n< HTTP/1.1 201 Created\n\n$ curl -v http://localhost:8080/v1/key-a\n> GET /v1/key-a HTTP/1.1\n< HTTP/1.1 200 OK\nHello, again, key-value store!\n```", "```go\nvar myMap = struct{\n    sync.RWMutex\n    m map[string]string\n}{m: make(map[string]string)}\n```", "```go\nmyMap.Lock()                                // Take a write lock\nmyMap.m[\"some_key\"] = \"some_value\"\nmyMap.Unlock()                              // Release the write lock\n```", "```go\nmyMap.RLock()                               // Take a read lock\nvalue := myMap.m[\"some_key\"]\nmyMap.RUnlock()                             // Release the read lock\n\nfmt.Println(\"some_key:\", value)\n```", "```go\nvar store = struct{\n    sync.RWMutex\n    m map[string]string\n}{m: make(map[string]string)}\n```", "```go\nfunc Get(key string) (string, error) {\n    store.RLock()\n    value, ok := store.m[key]\n    store.RUnlock()\n\n    if !ok {\n        return \"\", ErrorNoSuchKey\n    }\n\n    return value, nil\n}\n\nfunc Put(key string, value string) error {\n    store.Lock()\n    store.m[key] = value\n    store.Unlock()\n\n    return nil\n}\n```", "```go\ntype TransactionLogger interface {\n    WriteDelete(key string)\n    WritePut(key, value string)\n}\n```", "```go\ntype FileTransactionLogger struct {\n    // Something, something, fields\n}\n\nfunc (l *FileTransactionLogger) WritePut(key, value string) {\n    // Something, something, logic\n}\n\nfunc (l *FileTransactionLogger) WriteDelete(key string) {\n    // Something, something, logic\n}\n```", "```go\ntype Event struct {\n    Sequence  uint64                // A unique record ID\n    EventType EventType             // The action taken\n    Key       string                // The key affected by this transaction\n    Value     string                // The value of a PUT the transaction\n}\n```", "```go\nconst (\n    EventDelete byte = 1\n    EventPut    byte = 2\n)\n```", "```go\ntype EventType byte\n\nconst (\n    _                     = iota         // iota == 0; ignore the zero value\n    EventDelete EventType = iota         // iota == 1\n    EventPut                             // iota == 2; implicitly repeat\n)\n```", "```go\ntype FileTransactionLogger struct {\n    events       chan<- Event       // Write-only channel for sending events\n    errors       <-chan error       // Read-only channel for receiving errors\n    lastSequence uint64             // The last used event sequence number\n    file         *os.File           // The location of the transaction log\n}\n\nfunc (l *FileTransactionLogger) WritePut(key, value string) {\n    l.events <- Event{EventType: EventPut, Key: key, Value: value}\n}\n\nfunc (l *FileTransactionLogger) WriteDelete(key string) {\n    l.events <- Event{EventType: EventDelete, Key: key}\n}\n\nfunc (l *FileTransactionLogger) Err() <-chan error {\n    return l.errors\n}\n```", "```go\nfunc NewFileTransactionLogger(filename string) (TransactionLogger, error) {\n    file, err := os.OpenFile(filename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0755)\n    if err != nil {\n        return nil, fmt.Errorf(\"cannot open transaction log file: %w\", err)\n    }\n\n    return &FileTransactionLogger{file: file}, nil\n}\n```", "```go\nfunc (l *FileTransactionLogger) Run() {\n    events := make(chan Event, 16)              // Make an events channel\n    l.events = events\n\n    errors := make(chan error, 1)               // Make an errors channel\n    l.errors = errors\n\n    go func() {\n        for e := range events {                 // Retrieve the next Event\n\n            l.lastSequence++                    // Increment sequence number\n\n            _, err := fmt.Fprintf(              // Write the event to the log\n                l.file,\n                \"%d\\t%d\\t%s\\t%s\\n\",\n                l.lastSequence, e.EventType, e.Key, e.Value)\n\n            if err != nil {\n                errors <- err\n                return\n            }\n        }\n    }()\n}\n```", "```go\nfunc (l *FileTransactionLogger) ReadEvents() (<-chan Event, <-chan error) {\n    scanner := bufio.NewScanner(l.file)     // Create a Scanner for l.file\n    outEvent := make(chan Event)            // An unbuffered Event channel\n    outError := make(chan error, 1)         // A buffered error channel\n\n    go func() {\n        var e Event\n\n        defer close(outEvent)               // Close the channels when the\n        defer close(outError)               // goroutine ends\n\n        for scanner.Scan() {\n            line := scanner.Text()\n\n            if err := fmt.Sscanf(line, \"%d\\t%d\\t%s\\t%s\",\n                &e.Sequence, &e.EventType, &e.Key, &e.Value); err != nil {\n\n                outError <- fmt.Errorf(\"input parse error: %w\", err)\n                return\n            }\n\n            // Sanity check! Are the sequence numbers in increasing order?\n            if l.lastSequence >= e.Sequence {\n                outError <- fmt.Errorf(\"transaction numbers out of sequence\")\n                return\n            }\n\n            l.lastSequence = e.Sequence     // Update last used sequence #\n\n            outEvent <- e                   // Send the event along\n        }\n\n        if err := scanner.Err(); err != nil {\n            outError <- fmt.Errorf(\"transaction log read failure: %w\", err)\n            return\n        }\n    }()\n\n    return outEvent, outError\n}\n```", "```go\ntype TransactionLogger interface {\n    WriteDelete(key string)\n    WritePut(key, value string)\n    Err() <-chan error\n\n    ReadEvents() (<-chan Event, <-chan error)\n\n    Run()\n}\n```", "```go\nvar logger TransactionLogger\n```", "```go\nfunc initializeTransactionLog() error {\n    var err error\n\n    logger, err = NewFileTransactionLogger(\"transaction.log\")\n    if err != nil {\n        return fmt.Errorf(\"failed to create event logger: %w\", err)\n    }\n\n    events, errors := logger.ReadEvents()\n    e, ok := Event{}, true\n\n    for ok && err == nil {\n        select {\n        case err, ok = <-errors:                // Retrieve any errors\n        case e, ok = <-events:\n            switch e.EventType {\n            case EventDelete:                   // Got a DELETE event!\n                err = Delete(e.Key)\n            case EventPut:                      // Got a PUT event!\n                err = Put(e.Key, e.Value)\n            }\n        }\n    }\n\n    logger.Run()\n\n    return err\n}\n```", "```go\nimport (\n    \"database/sql\"\n    _ \"github.com/lib/pq\"       // Anonymously import the driver package\n)\n```", "```go\ntype TransactionLogger interface {\n    WriteDelete(key string)\n    WritePut(key, value string)\n    Err() <-chan error\n\n    ReadEvents() (<-chan Event, <-chan error)\n\n    Run()\n}\n```", "```go\ntype PostgresTransactionLogger struct {\n    events       chan<- Event       // Write-only channel for sending events\n    errors       <-chan error       // Read-only channel for receiving errors\n    db           *sql.DB            // The database access interface\n}\n\nfunc (l *PostgresTransactionLogger) WritePut(key, value string) {\n    l.events <- Event{EventType: EventPut, Key: key, Value: value}\n}\n\nfunc (l *PostgresTransactionLogger) WriteDelete(key string) {\n    l.events <- Event{EventType: EventDelete, Key: key}\n}\n\nfunc (l *PostgresTransactionLogger) Err() <-chan error {\n    return l.errors\n}\n```", "```go\nfunc NewPostgresTransactionLogger(host, dbName, user, password string)\n    (TransactionLogger, error) { ... }\n```", "```go\ntype PostgresDBParams struct {\n    dbName   string\n    host     string\n    user     string\n    password string\n}\n```", "```go\nlogger, err = NewPostgresTransactionLogger(PostgresDBParams{\n    host:     \"localhost\",\n    dbName:   \"kvs\",\n    user:     \"test\",\n    password: \"hunter2\"\n})\n```", "```go\nfunc NewPostgresTransactionLogger(config PostgresDBParams) (TransactionLogger,\n    error) {\n\n    connStr := fmt.Sprintf(\"host=%s dbname=%s user=%s password=%s\",\n        config.host, config.dbName, config.user, config.password)\n\n    db, err := sql.Open(\"postgres\", connStr)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open db: %w\", err)\n    }\n\n    err = db.Ping()                 // Test the database connection\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open db connection: %w\", err)\n    }\n\n    logger := &PostgresTransactionLogger{db: db}\n\n    exists, err := logger.verifyTableExists()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to verify table exists: %w\", err)\n    }\n    if !exists {\n        if err = logger.createTable(); err != nil {\n            return nil, fmt.Errorf(\"failed to create table: %w\", err)\n        }\n    }\n\n    return logger, nil\n}\n```", "```go\nfunc (l *PostgresTransactionLogger) Run() {\n    events := make(chan Event, 16)              // Make an events channel\n    l.events = events\n\n    errors := make(chan error, 1)               // Make an errors channel\n    l.errors = errors\n\n    go func() {                                 // The INSERT query\n        query := `INSERT INTO transactions\n (event_type, key, value)\n VALUES ($1, $2, $3)`\n\n        for e := range events {                 // Retrieve the next Event\n\n            _, err := l.db.Exec(                // Execute the INSERT query\n                query,\n                e.EventType, e.Key, e.Value)\n\n            if err != nil {\n                errors <- err\n            }\n        }\n    }()\n}\n```", "```go\nfunc (l *PostgresTransactionLogger) ReadEvents() (<-chan Event, <-chan error) {\n    outEvent := make(chan Event)                // An unbuffered events channel\n    outError := make(chan error, 1)             // A buffered errors channel\n\n    go func() {\n        defer close(outEvent)                   // Close the channels when the\n        defer close(outError)                   // goroutine ends\n\n        query := `SELECT sequence, event_type, key, value FROM transactions\n ORDER BY sequence`\n\n        rows, err := db.Query(query)            // Run query; get result set\n        if err != nil {\n            outError <- fmt.Errorf(\"sql query error: %w\", err)\n            return\n        }\n\n        defer rows.Close()                      // This is important!\n\n        e := Event{}                            // Create an empty Event\n\n        for rows.Next() {                       // Iterate over the rows\n\n            err = rows.Scan(                    // Read the values from the\n                &e.Sequence, &e.EventType,      // row into the Event.\n                &e.Key, &e.Value)\n\n            if err != nil {\n                outError <- fmt.Errorf(\"error reading row: %w\", err)\n                return\n            }\n\n            outEvent <- e                       // Send e to the channel\n        }\n\n        err = rows.Err()\n        if err != nil {\n            outError <- fmt.Errorf(\"transaction log read failure: %w\", err)\n        }\n    }()\n\n    return outEvent, outError\n}\n```", "```go\nlogger, err = NewFileTransactionLogger(\"transaction.log\")\n```", "```go\nlogger, err = NewPostgresTransactionLogger(\"localhost\")\n```", "```go\nfunc main() {\n    http.HandleFunc(\"/\", helloGoHandler)            // Add a root path handler\n\n    http.ListenAndServe(\":8080\", nil)               // Start the HTTP server\n}\n```", "```go\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\n```", "```go\nhttp.ListenAndServeTLS(\":8080\", \"cert.pem\", \"key.pem\", nil)\n```", "```go\n$ curl -X PUT -d 'Hello, key-value store!' -v https://localhost:8080/v1/key-a\n* SSL certificate problem: self signed certificate\ncurl: (60) SSL certificate problem: self signed certificate\n```", "```go\n$ curl -X PUT -d 'Hello, key-value store!' --insecure -v \\\n    https://localhost:8080/v1/key-a\n* SSL certificate verify result: self signed certificate (18), continuing anyway.\n> PUT /v1/key-a HTTP/2\n< HTTP/2 201\n```", "```go\n# The parent image. At build time, this image will be pulled and\n# subsequent instructions run against it.\nFROM ubuntu:20.04\n\n# Update apt cache and install nginx without an approval prompt.\nRUN apt-get update && apt-get install --yes nginx\n\n# Tell Docker this image's containers will use port 80.\nEXPOSE 80\n\n# Run Nginx in the foreground. This is important: without a\n# foreground process the container will automatically stop.\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```", "```go\n$ docker build --tag my-nginx .\n```", "```go\n$ docker images\nREPOSITORY      TAG         IMAGE ID           CREATED               SIZE\nmy-nginx        latest      64ea3e21a388       29 seconds ago        159MB\nubuntu          20.04       f63181f19b2f       3 weeks ago           72.9MB\n```", "```go\n$ docker run --detach --publish 8080:80 --name nginx my-nginx\n61bb4d01017236f6261ede5749b421e4f65d43cb67e8e7aa8439dc0f06afe0f3\n```", "```go\n$ docker ps\nCONTAINER ID    IMAGE       STATUS          PORTS                   NAMES\n4cce9201f484    my-nginx    Up 4 minutes    0.0.0.0:8080->80/tcp    nginx\n```", "```go\n$ curl localhost:80\ncurl: (7) Failed to connect to localhost port 80: Connection refused\n```", "```go\n$ docker run --detach --publish 8081:80 --name httpd httpd\n```", "```go\n$ curl localhost:8081\n<html><body><h1>It works!</h1></body></html>\n```", "```go\n$ docker stop 4cce      # \"docker stop nginx\" will work too\n4cce\n```", "```go\n$ docker ps\nCONTAINER ID    IMAGE       STATUS                      PORTS    NAMES\n4cce9201f484    my-nginx    Exited (0) 3 minutes ago             nginx\n```", "```go\n$ docker rm 4cce            # \"docker rm nginx\" will work too\n4cce\n```", "```go\n# We use a \"scratch\" image, which contains no distribution files. The\n# resulting image and containers will have only the service binary.\nFROM scratch\n\n# Copy the existing binary from the host.\nCOPY kvs .\n\n# Copy in your PEM files.\nCOPY *.pem .\n\n# Tell Docker we'll be using port 8080.\nEXPOSE 8080\n\n# Tell Docker to execute this command on a `docker run`.\nCMD [\"/kvs\"]\n```", "```go\n$ CGO_ENABLED=0 GOOS=linux go build -a -o kvs\n```", "```go\n$ file kvs\nkvs: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked,\nnot stripped\n```", "```go\n$ docker build --tag kvs .\n...output omitted.\n\n$ docker images\nREPOSITORY     TAG        IMAGE ID           CREATED               SIZE\nkvs            latest     7b1fb6fa93e3       About a minute ago    6.88MB\nnode           15         ebcfbb59a4bd      7 days ago             936MB\npython         3.9        2a93c239d591      8 days ago             885MB\nopenjdk        15         7666c92f41b0      2 weeks ago            486MB\n```", "```go\n$ docker run --detach --publish 8080:8080 kvs\n4a05617539125f7f28357d3310759c2ef388f456b07ea0763350a78da661afd3\n\n$ curl -X PUT -d 'Hello, key-value store!' -v http://localhost:8080/v1/key-a\n> PUT /v1/key-a HTTP/1.1\n< HTTP/1.1 201 Created\n\n$ curl http://localhost:8080/v1/key-a\nHello, key-value store!\n```", "```go\nFROM golang:1.16 as build\n```", "```go\nCOPY --from=build /src/kvs .\n```", "```go\n# Stage 1: Compile the binary in a containerized Golang environment\n#\nFROM golang:1.16 as build\n\n# Copy the source files from the host\nCOPY . /src\n\n# Set the working directory to the same place we copied the code\nWORKDIR /src\n\n# Build the binary!\nRUN CGO_ENABLED=0 GOOS=linux go build -o kvs\n\n# Stage 2: Build the Key-Value Store image proper\n#\n# Use a \"scratch\" image, which contains no distribution files\nFROM scratch\n\n# Copy the binary from the build container\nCOPY --from=build /src/kvs .\n\n# If you're using TLS, copy the .pem files too\nCOPY --from=build /src/*.pem .\n\n# Tell Docker we'll be using port 8080\nEXPOSE 8080\n\n# Tell Docker to execute this command on a \"docker run\"\nCMD [\"/kvs\"]\n```", "```go\n$ docker build --tag kvs:multipart .\n...output omitted.\n\n$ docker images\nREPOSITORY     TAG           IMAGE ID           CREATED               SIZE\nkvs            latest        7b1fb6fa93e3       2 hours ago           6.88MB\nkvs            multipart     b83b9e479ae7       4 minutes ago         6.56MB\n```"]