<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Here Be Dragons: Reflect, &#10;Unsafe, and Cgo"><div class="chapter" id="unique_chapter_id_16">
<h1><span class="label">Chapter 16. </span>Here Be Dragons: Reflect, 
<span class="keep-together">Unsafe, and Cgo</span></h1>


<p>The edges of the known world are scary. Ancient maps would fill in the unexplored areas with pictures of dragons and lions. In the previous sections, I have emphasized that Go is a safe language, with typed variables to make clear what sort of data you are using and garbage collection to manage memory. Even the pointers are tame; you can’t abuse them in the way that C and C++ do.</p>

<p>All those things are true, and for the vast majority of the Go code that you’ll write, you can be assured that the Go runtime will protect you. But there are escape hatches. Sometimes your Go programs need to venture out into less defined areas. In this chapter, you’re going to look at how to handle situations that can’t be solved with normal Go code. <a data-type="indexterm" data-primary="standard library" data-secondary="reflect package" id="id2879"/><a data-type="indexterm" data-primary="reflect package" id="id2880"/>For example, when the type of the data can’t be determined at compile time, you can use the reflection support in the <code>reflect</code> package to interact with and even construct data. When you need to take advantage of the memory layout of data types in Go, you can use the <code>unsafe</code> package. And if there is functionality that can be provided only by libraries written in C, you can call into C code with <code>cgo</code>.</p>

<p>You might be wondering why these advanced concepts appear in a book targeted at those new to Go. There are two reasons. First, developers searching for a solution to a problem sometimes discover (and copy and paste) techniques they don’t fully understand. It’s best to know a bit about advanced techniques that can cause problems before you add them to your codebase. Second, these tools are fun. Because they allow you to do things that aren’t normally possible with Go, it feels a bit exciting to play with them and see what you can do.</p>






<section data-type="sect1" data-pdf-bookmark="Reflection Lets You Work with Types at Runtime"><div class="sect1" id="reflection">
<h1>Reflection Lets You Work with Types at Runtime</h1>

<p>One of the things that people who use Go like about it is that it is a statically typed language. Most of the time, declaring variables, types, and functions in Go is pretty straightforward. When you need a type, a variable, or a function, you define it:<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="about" id="id2881"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="about" id="id2882"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Foo</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nx">A</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="w">  </code><code class="nx">B</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="nx">Foo</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">DoSomething</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="nx">Foo</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">f</code><code class="p">.</code><code class="nx">A</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You use types to represent the data structures you know you need when you write your programs. Since types are a core part of Go, the compiler uses them to make sure that your code is correct. But sometimes, relying on only compilation-time information is a limitation. You might need to work with variables at runtime using information that didn’t exist when the program was written. Maybe you’re trying to map data from a file or network request into a variable. In those situations, you need to use <em>reflection</em>. Reflection allows you to examine types at runtime. It also provides the ability to examine, modify, and create variables, functions, and structs at runtime.</p>

<p>This leads to the question of when this functionality is needed. If you look at the Go standard library, you can get an idea. Its uses fall into one of a few general categories:</p>

<ul>
<li>
<p>Reading and writing from a database. The <code>database/sql</code> package uses reflection to send records to databases and read data back.</p>
</li>
<li>
<p>Go’s built-in templating libraries, <code>text/template</code> and <code>html/template</code>, use reflection to process the values that are passed to the templates.</p>
</li>
<li>
<p>The <code>fmt</code> package uses reflection heavily, as all those calls to <code>fmt.Println</code> and friends rely on reflection to detect the type of the provided parameters.</p>
</li>
<li>
<p>The <code>errors</code> package uses reflection to implement <code>errors.Is</code> and <code>errors.As</code>.</p>
</li>
<li>
<p>The <code>sort</code> package uses reflection to implement functions that sort and evaluate slices of any type: <code>sort.Slice</code>, <code>sort.SliceStable</code>, and <code>sort.SliceIsSorted</code>.</p>
</li>
<li>
<p>The last main usage of reflection in the Go standard library is for marshaling and unmarshaling data into JSON and XML, along with the other data formats defined in the various <code>encoding</code> packages. Struct tags (which I will talk about soon) are accessed via reflection, and the fields in structs are read and written using reflection as well.</p>
</li>
</ul>

<p>Most of these examples have one thing in common: they involve accessing and formatting data that is being imported into or exported out of a Go program. You’ll often see reflection used at the boundaries between your program and the outside world.</p>

<p>As you take a look at the techniques you can implement with reflection, keep in mind that this power has a price. Using reflection is quite a bit slower than performing the identical operation without it. I’ll talk more about this in <a data-type="xref" href="#slow_reflection">“Use Reflection Only if It’s Worthwhile”</a>. Even more importantly, code that uses reflection is both more fragile and more verbose. Many functions and methods in the <code>reflect</code> package panic when passed the wrong type of data. Be sure to leave comments in your code to explain what you are doing so that it’s clear to future reviewers (including yourself).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another use of the <code>reflect</code> package in the Go<a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.DeepEqual" id="id2883"/><a data-type="indexterm" data-primary="standard library" data-secondary="reflect package" id="id2884"/><a data-type="indexterm" data-primary="reflect package" id="id2885"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="slices not comparable" data-tertiary="DeepEqual in reflect package" id="id2886"/><a data-type="indexterm" data-primary="DeepEqual in reflect package" id="id2887"/><a data-type="indexterm" data-primary="slices" data-secondary="not comparable" data-tertiary="DeepEqual in reflect package" id="id2888"/> standard library is testing. In <a data-type="xref" href="ch03.html#slice_info">“Slices”</a>, I mentioned a function that you can find in the <code>reflect</code> package called <code>DeepEqual</code>. It’s in the <code>reflect</code> package because it takes advantage of reflection to do its work. The <code>reflect.DeepEqual</code> function checks whether two values are “deeply equal” to each other. This is a more thorough comparison than what you get if you use <code>==</code> to compare two things, and it’s used in the standard library as a way to validate test results. It can also compare things that can’t be compared using <code>==</code>, like slices and maps. Most of the time, you don’t need <code>DeepEqual</code>. Since the release of Go 1.21, it’s faster to use <code>slices.Equal</code> and <code>maps.Equal</code> to check for equality in slices and maps.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Types, Kinds, and Values"><div class="sect2" id="id360">
<h2>Types, Kinds, and Values</h2>

<p>Now that you know what reflection is and when you might need it, let’s see how it works. The <code>reflect</code> package in the standard library is the home for the types and functions that implement reflection in Go. Reflection is built around three core concepts: types, kinds, and values.</p>










<section data-type="sect3" data-pdf-bookmark="Types and kinds"><div class="sect3" id="id202">
<h3>Types and kinds</h3>

<p>A <em>type</em> is exactly what it sounds like.<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="types and kinds" id="ch16-tk"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="types and kinds" id="ch16-tk2"/> It defines the properties of a variable, what it can hold, and how you can interact with it. With reflection, you are able to query a type to find out about these properties using code.</p>

<p>You get the reflection representation of the type of a variable with the <code>TypeOf</code> function in the <code>reflect</code> package:<a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.TypeOf" id="ch16-tyof"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">vType</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/></pre>

<p>The <code>reflect.TypeOf</code> function returns a value of type <code>reflect.Type</code>, which represents the type of the variable passed into the <code>TypeOf</code> function. The <code>reflect.Type</code> type defines methods with information about a variable’s type. I can’t cover all the methods, but here are a few.</p>

<p>The <code>Name</code> method returns, not surprisingly, the name of the type. Here is a quick example:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="nx">xt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xt</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w">     </code><code class="c1">// returns int</code><code class="w"/>
<code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Foo</code><code class="p">{}</code><code class="w"/>
<code class="nx">ft</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ft</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w">     </code><code class="c1">// returns Foo</code><code class="w"/>
<code class="nx">xpt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xpt</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w">    </code><code class="c1">// returns an empty string</code><code class="w"/></pre>

<p>You start with a variable <code>x</code> of type <code>int</code>. You pass it to <code>reflect.TypeOf</code> and get back a <code>reflect.Type</code> instance. For primitive types like <code>int</code>, <code>Name</code> returns the name of the type, in this case the string “int” for your <code>int</code>. For a struct, the name of the struct is returned. Some types, like a slice or a pointer, don’t have names; in those cases, <code>Name</code> returns an empty string.</p>

<p>The <code>Kind</code> method on <code>reflect.Type</code> returns a value of type <code>reflect.Kind</code>, which is a constant that says what the type is made of—a slice, a map, a pointer, a struct, an interface, a string, an array, a function, an int, or some other primitive type. The difference between the kind and the type can be tricky to understand. Remember this rule: if you define a struct named Foo, the kind is <code>reflect.Struct</code> and the type is “Foo.”</p>

<p>The kind is very important. One thing to be aware of when using reflection is that almost everything in the <code>reflect</code> package assumes that you know what you are doing. Some of the methods defined on <code>reflect.Type</code> and other types in the <code>reflect</code> package make sense for only certain kinds. For example, there’s a method on <code>reflect.Type</code> called <code>NumIn</code>. If your <code>reflect.Type</code> instance represents a function, it returns the number of input parameters for the function. If your <code>reflect.Type</code> instance isn’t a function, calling <code>NumIn</code> will panic your program.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>In general, if you call a method that doesn’t make sense for the kind of the type, the method call panics. Always remember to use the kind of the reflected type to know which methods will work and which ones will panic.</p>
</div>

<p>Another important method on <code>reflect.Type</code> is <code>Elem</code>. Some types in Go have references to other types and <code>Elem</code> is how to find out the contained type. For example, let’s use <code>reflect.TypeOf</code> on a pointer to an <code>int</code>:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="nx">xpt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xpt</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w">        </code><code class="c1">// returns an empty string</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xpt</code><code class="p">.</code><code class="nx">Kind</code><code class="p">())</code><code class="w">        </code><code class="c1">// returns reflect.Pointer</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xpt</code><code class="p">.</code><code class="nx">Elem</code><code class="p">().</code><code class="nx">Name</code><code class="p">())</code><code class="w"> </code><code class="c1">// returns "int"</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">xpt</code><code class="p">.</code><code class="nx">Elem</code><code class="p">().</code><code class="nx">Kind</code><code class="p">())</code><code class="w"> </code><code class="c1">// returns reflect.Int</code><code class="w"/></pre>

<p>That gives you a <code>reflect.Type</code> instance with a blank name and a kind of <code>reflect.Pointer</code>. When the <code>reflect.Type</code> represents a pointer, <code>Elem</code> returns the <code>reflect.Type</code> for the type the pointer points to. In this case, the <code>Name</code> method returns “int,” and <code>Kind</code> returns <code>reflect.Int</code>. The <code>Elem</code> method also works for slices, maps, channels, and arrays.</p>

<p>There are methods on <code>reflect.Type</code> for reflecting on structs. Use the <code>NumField</code> method to get the number of fields in the struct, and get the fields in a struct by index with the <code>Field</code> method. That returns each field’s structure described in a <code>reflect.StructField</code>, which has the name, order, type, and struct tags on a field. Let’s look at a quick example, which you can run on <a href="https://oreil.ly/Ynv_4">The Go Playground</a> or in the <em>sample_code/struct_tag</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>:<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="id2889"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="id2890"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Foo</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">A</code><code class="w"> </code><code class="kt">int</code><code class="w">    </code><code class="s">`myTag:"value"`</code><code class="w"/>
<code class="w">    </code><code class="nx">B</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`myTag:"value2"`</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="nx">Foo</code><code class="w"/>
<code class="nx">ft</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">ft</code><code class="p">.</code><code class="nx">NumField</code><code class="p">();</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">curField</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ft</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">curField</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code><code class="w"> </code><code class="nx">curField</code><code class="p">.</code><code class="nx">Type</code><code class="p">.</code><code class="nx">Name</code><code class="p">(),</code><code class="w"/>
<code class="w">        </code><code class="nx">curField</code><code class="p">.</code><code class="nx">Tag</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"myTag"</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You create an instance of type <code>Foo</code> and use <code>reflect.TypeOf</code> to get the <code>reflect.Type</code> for <code>f</code>. Next you use the <code>NumField</code> method to set up a <code>for</code> loop to get the index of each field in <code>f</code>. Then you use the <code>Field</code> method to get the <code>reflect.StructField</code> struct that represents the field, and then you can use the fields on <code>reflect.StructField</code> to get more information about the field. This code prints out the following:</p>

<pre data-type="programlisting">A int value
B string value2</pre>

<p>There are many more methods in <code>reflect.Type</code>, but they all follow the same pattern, allowing you to access the information that describes the type of a variable. You can look at the <a href="https://oreil.ly/p4AZ6"><code>reflect.Type</code> documentation</a> in the standard library for more 
<span class="keep-together">information.</span><a data-type="indexterm" data-startref="ch16-tk" id="id2891"/><a data-type="indexterm" data-startref="ch16-tk2" id="id2892"/><a data-type="indexterm" data-startref="ch16-tyof" id="id2893"/></p>
</div></section>










<section data-type="sect3" class="less_space" data-pdf-bookmark="Values"><div class="sect3" id="id271">
<h3>Values</h3>

<p>In addition to examining the types of variables,<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="values" id="id2894"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="values" id="id2895"/> you can also use reflection to read a variable’s value, set its value, or create a new value from scratch.</p>

<p>You use the <code>reflect.ValueOf</code> function to create a <code>reflect.Value</code> instance that represents the value of a variable:<a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.ValueOf" id="id2896"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">vValue</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/></pre>

<p>Since every variable in Go has a type, <code>reflect.Value</code> has a method called <code>Type</code> that returns the <code>reflect.Type</code> of the <code>reflect.Value</code>. There’s also a <code>Kind</code> method, just as there is on <code>reflect.Type</code>.</p>

<p>Just as <code>reflect.Type</code> has methods for finding out information about the type of a variable, <code>reflect.Value</code> has methods for finding out information about the value of a variable. I’m not going to cover all of them, but let’s take a look at how to use a <code>reflect.Value</code> to get the value of the variable.</p>

<p>I’ll start by demonstrating how to read your values back out of a <code>reflect.Value</code>. The <code>Interface</code> method returns the value of the variable as <code>any</code>. When you put the value returned by <code>Interface</code> into a variable, you have to use a type assertion to get back to a usable type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"a"</code><code class="p">,</code><code class="w"> </code><code class="s">"b"</code><code class="p">,</code><code class="w"> </code><code class="s">"c"</code><code class="p">}</code><code class="w"/>
<code class="nx">sv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w">        </code><code class="c1">// sv is of type reflect.Value</code><code class="w"/>
<code class="nx">s2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sv</code><code class="p">.</code><code class="nx">Interface</code><code class="p">().([]</code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="c1">// s2 is of type []string</code><code class="w"/></pre>

<p>While <code>Interface</code> can be called for <code>reflect.Value</code> instances that contain values of any kind, you can use special case methods if the kind of the variable is one of the built-in, primitive types: <code>Bool</code>, <code>Complex</code>, <code>Int</code>, <code>Uint</code>, <code>Float</code>, and <code>String</code>. There’s also a <code>Bytes</code> method that works if the type of the variable is a slice of bytes. If you use a method that doesn’t match the type of the <code>reflect.Value</code>, your code will panic. If you are unsure about the type of the <code>Value</code>, methods can preemptively check: the <code>CanComplex</code>, <code>CanFloat</code>, <code>CanInt</code>, and <code>CanUint</code> methods validate that the <code>Value</code> is of one of the numeric types, and <code>CanConvert</code> checks for other types.</p>

<p>You can use reflection to set the value of a variable as well, but it’s a three-step process.</p>

<p>First, you pass a pointer to the variable into <code>reflect.ValueOf</code>. This returns a <code>reflect.Value</code> that represents the pointer:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">iv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">i</code><code class="p">)</code><code class="w"/></pre>

<p>Next, you need to get to the actual value to set it. You use the <code>Elem</code> method on <code>reflect.Value</code> to get to the value pointed to by the pointer that was passed into <code>reflect.ValueOf</code>. Just as <code>Elem</code> on <code>reflect.Type</code> returns the type that’s pointed to by a containing type, <code>Elem</code> on <code>reflect.Value</code> returns the value that’s pointed to by a pointer or the value that’s stored in an interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ivv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">iv</code><code class="p">.</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/></pre>

<p>Finally, you get to the actual method that’s used to set the value. Just as there are special-case methods for reading primitive types, there are special-case methods for setting primitive types: <code>SetBool</code>, <code>SetInt</code>, <code>SetFloat</code>, <code>SetString</code>, and <code>SetUint</code>.  In the example, calling <code>ivv.SetInt(20)</code> changes the value of <code>i</code>. If you print out <code>i</code> now, you will get 20:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ivv</code><code class="p">.</code><code class="nx">SetInt</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints 20</code><code class="w"/></pre>

<p>For all other types, you need to use the <code>Set</code> method, which takes a variable of type <code>reflect.Value</code>. The value that you are setting it to doesn’t need to be a pointer, because you are just reading this value, not changing it. And just as you can use <code>Interface()</code> to read primitive types, you can use <code>Set</code> to write primitive types.</p>

<p>The reason you need to pass a pointer to <code>reflect.ValueOf</code> to change the value of the input parameter is that it is just like any other function in Go. As I discussed in <a data-type="xref" href="ch06.html#pointer_mutable">“Pointers Indicate Mutable Parameters”</a>, you use a parameter of a pointer type to indicate that you want to modify the value of the parameter. When you modify the value, you dereference the pointer and then set the value. The following two functions follow the same process:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">changeInt</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="o">*</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="nx">i</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">changeIntReflect</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="o">*</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">iv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">iv</code><code class="p">.</code><code class="nx">Elem</code><code class="p">().</code><code class="nx">SetInt</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Attempting to set a <code>reflect.Value</code> to a value of the wrong type will produce a panic.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you don’t pass a pointer to a variable to <code>reflect.ValueOf</code>, you can still read the value of the variable using reflection. But if you try to use any of the methods that can change the value of a variable, the method calls will (not surprisingly) panic. The <code>CanSet</code> method on <code>reflect.Value</code> will tell you if calling <code>Set</code> will produce a panic.</p>
</div>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Make New Values"><div class="sect2" id="id272">
<h2>Make New Values</h2>

<p>Before you learn how to best use reflection,<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="making new values" id="id2897"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="making new values" id="id2898"/><a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.New" id="id2899"/><a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.Type" id="id2900"/><a data-type="indexterm" data-primary="reflect package" data-secondary="reflect.Value" id="id2901"/> there’s one more thing to cover: how to create a value. The <code>reflect.New</code> function is the reflection analogue of the <code>new</code> function. It takes in a <code>reflect.Type</code> and returns a <code>reflect.Value</code> that’s a pointer to a <code>reflect.Value</code> of the specified type. Since it’s a pointer, you can modify it and then assign the modified value to a variable by using the <code>Interface</code> method.</p>

<p>Just as <code>reflect.New</code> creates a pointer to a scalar type, you can also use reflection to do the same thing as the <code>make</code> keyword with the following functions:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">MakeChan</code><code class="p">(</code><code class="nx">typ</code><code class="w"> </code><code class="nx">Type</code><code class="p">,</code><code class="w"> </code><code class="nx">buffer</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="nx">Value</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">MakeMap</code><code class="p">(</code><code class="nx">typ</code><code class="w"> </code><code class="nx">Type</code><code class="p">)</code><code class="w"> </code><code class="nx">Value</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">MakeMapWithSize</code><code class="p">(</code><code class="nx">typ</code><code class="w"> </code><code class="nx">Type</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="nx">Value</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">MakeSlice</code><code class="p">(</code><code class="nx">typ</code><code class="w"> </code><code class="nx">Type</code><code class="p">,</code><code class="w"> </code><code class="nx">len</code><code class="p">,</code><code class="w"> </code><code class="nx">cap</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="nx">Value</code><code class="w"/></pre>

<p>Each of these functions takes in a <code>reflect.Type</code> that represents the compound type, not the contained type.</p>

<p>You must always start from a value when constructing a <code>reflect.Type</code>. However, a trick lets you create a variable to represent a <code>reflect.Type</code> if you don’t have a value handy:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">stringType</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">((</code><code class="o">*</code><code class="kt">string</code><code class="p">)(</code><code class="kc">nil</code><code class="p">)).</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">stringSliceType</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">([]</code><code class="nb">string</code><code class="p">(</code><code class="kc">nil</code><code class="p">))</code><code class="w"/></pre>

<p>The variable <code>stringType</code> contains a <code>reflect.Type</code> that represents a <code>string</code>, and the variable <code>stringSliceType</code> contains a <code>reflect.Type</code> that represents a <code>[]string</code>. That first line can take a bit of effort to decode. What you are doing is converting <code>nil</code> to a pointer to <code>string</code>, using <code>reflect.TypeOf</code> to make a <code>reflect.Type</code> of that pointer type, and then calling <code>Elem</code> on that pointer’s <code>reflect.Type</code> to get the underlying type. You have to put <code>*string</code> in parentheses because of the Go order of operations; without the parentheses, the compiler thinks that you are converting <code>nil</code> to <code>string</code>, which is illegal.</p>

<p>For the <code>stringSliceType</code>, it’s a bit simpler since <code>nil</code> is a valid value for a slice. All you have to do is type conversion of <code>nil</code> to a <code>[]string</code> and pass that to <code>reflect.Type</code>.</p>

<p>Now that you have these types, you can see how to use <code>reflect.New</code> and 
<span class="keep-together"><code>reflect.MakeSlice</code>:</span></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ssv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">MakeSlice</code><code class="p">(</code><code class="nx">stringSliceType</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>

<code class="nx">sv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">stringType</code><code class="p">).</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>
<code class="nx">sv</code><code class="p">.</code><code class="nx">SetString</code><code class="p">(</code><code class="s">"hello"</code><code class="p">)</code><code class="w"/>

<code class="nx">ssv</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Append</code><code class="p">(</code><code class="nx">ssv</code><code class="p">,</code><code class="w"> </code><code class="nx">sv</code><code class="p">)</code><code class="w"/>
<code class="nx">ss</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ssv</code><code class="p">.</code><code class="nx">Interface</code><code class="p">().([]</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ss</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints [hello]</code><code class="w"/></pre>

<p>You can try out this code for yourself on <a href="https://oreil.ly/ak2PG">The Go Playground</a> or in the <em>sample_code/reflect_string_slice</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="ix_qpqp"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="ix_qqq123"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Use Reflection to Check If an Interface’s Value Is nil"><div class="sect2" id="reflect_interface_nil">
<h2>Use Reflection to Check If an Interface’s Value Is nil</h2>

<p>As I talked about in <a data-type="xref" href="ch07.html#interface_nil">“Interfaces and nil”</a>, <a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="checking for nil interface value" id="id2902"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="checking for nil interface value" id="id2903"/><a data-type="indexterm" data-primary="interfaces" data-secondary="nil and" data-tertiary="reflection checking for nil value" id="id2904"/><a data-type="indexterm" data-primary="nil" data-secondary="interfaces and" data-tertiary="reflection checking for nil value" id="id2905"/>if a <code>nil</code> variable of a concrete type is assigned to a variable of an interface type, the variable of the interface type is not <code>nil</code>. This is because a type is associated with the interface variable. If you want to check whether the value associated with an interface is <code>nil</code>, you can do so with reflection by using two methods—<code>IsValid</code> and <code>IsNil</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">hasNoValue</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">iv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">iv</code><code class="p">.</code><code class="nx">IsValid</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">switch</code><code class="w"> </code><code class="nx">iv</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">,</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Slice</code><code class="p">,</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Map</code><code class="p">,</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Func</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Interface</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">iv</code><code class="p">.</code><code class="nx">IsNil</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>IsValid</code> method returns <code>true</code> if <code>reflect.Value</code> holds anything other than a <code>nil</code> interface. You need to check this first because calling any other method on <code>reflect.Value</code> will (unsurprisingly) panic if <code>IsValid</code> is <code>false</code>. The <code>IsNil</code> method returns <code>true</code> if the value of the <code>reflect.Value</code> is <code>nil</code>, but it can be called only if the <code>reflect.Kind</code> is something that <em>can</em> be <code>nil</code>. If you call it on a type whose zero value isn’t <code>nil</code>, it (you guessed it) panics.</p>

<p>You can see this function in use on <a href="https://oreil.ly/D-HR9">The Go Playground</a> or in the <em>sample_code/no_value</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.</p>

<p>Even though it is possible to detect an interface with a <code>nil</code> value, strive to write your code so that it performs correctly even when the value associated with an interface is <code>nil</code>. Reserve this code for situations where you have no other options.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Use Reflection to Write a Data Marshaler"><div class="sect2" id="csv_marshaler">
<h2>Use Reflection to Write a Data Marshaler</h2>

<p>As mentioned earlier, reflection is what<a data-type="indexterm" data-primary="marshaling" data-secondary="reflection for data marshaler" id="ch16-marsh"/><a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="data marshaler" id="ch16-marsh2"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="data marshaler" id="ch16-marsh3"/> the standard library uses to implement marshaling and unmarshaling. Let’s see how it’s done by building a data marshaler for ourselves. <a data-type="indexterm" data-primary="csv package" data-secondary="csv.NewReader" id="id2906"/><a data-type="indexterm" data-primary="csv package" data-secondary="csv.NewWriter" id="id2907"/><a data-type="indexterm" data-primary="standard library" data-secondary="encoding/csv package" id="id2908"/>Go provides the <code>csv.NewReader</code> and <code>csv.NewWriter</code> functions to read a CSV file into a slice of slice of strings and to write a slice of slice of strings out to a CSV file, but nothing in the standard library can automatically map that data to the fields in a struct. The following code is going to add that missing functionality.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The examples here have been cut down a bit to fit, reducing the number of supported types. You can find the complete code on <a href="https://oreil.ly/VDytK">The Go Playground</a> or in the <em>sample_code/csv</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-startref="ix_qqq123" id="id2909"/><a data-type="indexterm" data-startref="ix_qpqp" id="id2910"/></p>
</div>

<p>You’ll start by defining your API. As with other marshalers, you’ll define a struct tag that specifies the name of a field in the data to map it to a field in a struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MyData</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w">   </code><code class="kt">string</code><code class="w"> </code><code class="s">`csv:"name"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">    </code><code class="kt">int</code><code class="w">    </code><code class="s">`csv:"age"`</code><code class="w"/>
<code class="w">    </code><code class="nx">HasPet</code><code class="w"> </code><code class="kt">bool</code><code class="w">   </code><code class="s">`csv:"has_pet"`</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The public API consists of two functions:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// Unmarshal maps all of the rows of data in a slice of slice of strings</code><code class="w"/>
<code class="c1">// into a slice of structs.</code><code class="w"/>
<code class="c1">// The first row is assumed to be the header with the column names.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">data</code><code class="w"> </code><code class="p">[][]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"/>

<code class="c1">// Marshal maps all of the structs in a slice of structs to a slice of slice</code><code class="w"/>
<code class="c1">// of strings.</code><code class="w"/>
<code class="c1">// The first row written is the header with the column names.</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">v</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="p">([][]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/></pre>

<p>You’ll start with <code>Marshal</code>, writing the function and then looking at the two helper functions it uses:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">v</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="p">([][]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sliceVal</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Slice</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"must be a slice of structs"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">structType</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Type</code><code class="p">().</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">structType</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"must be a slice of structs"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="p">[][]</code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">header</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">marshalHeader</code><code class="p">(</code><code class="nx">structType</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">header</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Len</code><code class="p">();</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">marshalOne</code><code class="p">(</code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Index</code><code class="p">(</code><code class="nx">i</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">row</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Since you can marshal a struct of any type, you need to use a parameter of type 
<span class="keep-together"><code>any</code>.</span> This isn’t a pointer to a slice of structs, because you are only reading from your slice, not modifying it.</p>

<p>The first row of your CSV is going to be the header with the column names, so you get those column names from the struct tags on fields in the struct’s type. You use the <code>Type</code> method to get the <code>reflect.Type</code> of the slice from the <code>reflect.Value</code>, and then call the <code>Elem</code> method to get the <code>reflect.Type</code> of the elements of the slice. You then pass this to <code>marshalHeader</code> and append the response to your output.</p>

<p>Next, you iterate through each element in the struct slice using reflection, passing the <code>reflect.Value</code> of each element to <code>marshalOne</code>, appending the result to your output. When you finish iterating, you return your slice of slice of <code>string</code>.</p>

<p>Look at the implementation of your first helper function, <code>marshalHeader</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">marshalHeader</code><code class="p">(</code><code class="nx">vt</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Type</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">row</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">vt</code><code class="p">.</code><code class="nx">NumField</code><code class="p">();</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">field</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vt</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">curTag</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">field</code><code class="p">.</code><code class="nx">Tag</code><code class="p">.</code><code class="nx">Lookup</code><code class="p">(</code><code class="s">"csv"</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">row</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">curTag</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">row</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function simply loops over the fields of the <code>reflect.Type</code>, reads the <code>csv</code> tag on each field, appends it into a <code>string</code> slice, and returns the slice.</p>

<p>The second helper function is <code>marshalOne</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">marshalOne</code><code class="p">(</code><code class="nx">vv</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"> </code><code class="p">([]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">row</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">vt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">Type</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">NumField</code><code class="p">();</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fieldVal</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vt</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">).</code><code class="nx">Tag</code><code class="p">.</code><code class="nx">Lookup</code><code class="p">(</code><code class="s">"csv"</code><code class="p">);</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">continue</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">switch</code><code class="w"> </code><code class="nx">fieldVal</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Int</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">row</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatInt</code><code class="p">(</code><code class="nx">fieldVal</code><code class="p">.</code><code class="nx">Int</code><code class="p">(),</code><code class="w"> </code><code class="mi">10</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">String</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">row</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">fieldVal</code><code class="p">.</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Bool</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">row</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatBool</code><code class="p">(</code><code class="nx">fieldVal</code><code class="p">.</code><code class="nx">Bool</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"cannot handle field of kind %v"</code><code class="p">,</code><code class="w"/>
<code class="w">                                   </code><code class="nx">fieldVal</code><code class="p">.</code><code class="nx">Kind</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function takes in a <code>reflect.Value</code> and returns a <code>string</code> slice. You create the <code>string</code> slice, and for each field in the struct, you switch on its <code>reflect.Kind</code> to determine how to convert it to a <code>string</code>, and append it to the output.</p>

<p>Your simple marshaler is now complete. Let’s see what you have to do to unmarshal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">data</code><code class="w"> </code><code class="p">[][]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sliceValPointer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">sliceValPointer</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Pointer</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"must be a pointer to a slice of structs"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">sliceVal</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sliceValPointer</code><code class="p">.</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Slice</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"must be a pointer to a slice of structs"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">structType</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Type</code><code class="p">().</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">structType</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"must be a pointer to a slice of structs"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="c1">// assume the first row is a header</code><code class="w"/>
<code class="w">    </code><code class="nx">header</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">data</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nx">namePos</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">header</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">name</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">header</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">namePos</code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">row</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">data</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">newVal</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">structType</code><code class="p">).</code><code class="nx">Elem</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">unmarshalOne</code><code class="p">(</code><code class="nx">row</code><code class="p">,</code><code class="w"> </code><code class="nx">namePos</code><code class="p">,</code><code class="w"> </code><code class="nx">newVal</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">sliceVal</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Append</code><code class="p">(</code><code class="nx">sliceVal</code><code class="p">,</code><code class="w"> </code><code class="nx">newVal</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Since you are copying data into a slice of any kind of struct, you need to use a parameter of type <code>any</code>. Furthermore, because you are modifying the value stored in this parameter, you <em>must</em> pass in a pointer to a slice of structs. The <code>Unmarshal</code> function converts that slice of structs pointer to a <code>reflect.Value</code>, then gets the underlying slice, and then gets the type of the structs in the underlying slice.</p>

<p>As I said earlier, the code assumes that the first row of data is a header with the names of the columns. You use this information to build up a map, so you can associate the <code>csv</code> struct tag value with the correct data element.</p>

<p>You then loop through all the remaining <code>string</code> slices, creating a new <code>reflect.Value</code> using the <code>reflect.Type</code> of the struct, call <code>unmarshalOne</code> to copy the data in the current <code>string</code> slice into the struct, and then add the struct to your slice. After iterating through all the rows of data, you return.</p>

<p>All that remains is looking at the implementation of <code>unmarshalOne</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">unmarshalOne</code><code class="p">(</code><code class="nx">row</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">namePos</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">vv</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">vt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">Type</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">NumField</code><code class="p">();</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">typeField</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vt</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">pos</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">namePos</code><code class="p">[</code><code class="nx">typeField</code><code class="p">.</code><code class="nx">Tag</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"csv"</code><code class="p">)]</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">continue</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">val</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">row</code><code class="p">[</code><code class="nx">pos</code><code class="p">]</code><code class="w"/>
<code class="w">        </code><code class="nx">field</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">vv</code><code class="p">.</code><code class="nx">Field</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">switch</code><code class="w"> </code><code class="nx">field</code><code class="p">.</code><code class="nx">Kind</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Int</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">val</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nx">field</code><code class="p">.</code><code class="nx">SetInt</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">String</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">field</code><code class="p">.</code><code class="nx">SetString</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Bool</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseBool</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nx">field</code><code class="p">.</code><code class="nx">SetBool</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"cannot handle field of kind %v"</code><code class="p">,</code><code class="w"/>
<code class="w">                              </code><code class="nx">field</code><code class="p">.</code><code class="nx">Kind</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function iterates over each field in the newly created <code>reflect.Value</code>, uses the <code>csv</code> struct tag on the current field to find its name, looks up the element in the <code>data</code> slice by using the <code>namePos</code> map, converts the value from a <code>string</code> to the correct type, and sets the value on the current field. After all fields have been populated, the function returns.</p>

<p>Now that you have written your marshaler and unmarshaler, you can integrate with the existing CSV support in the Go standard library:<a data-type="indexterm" data-startref="ch16-marsh" id="id2911"/><a data-type="indexterm" data-startref="ch16-marsh2" id="id2912"/><a data-type="indexterm" data-startref="ch16-marsh3" id="id2913"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">`name,age,has_pet</code>
<code class="s">Jon,"100",true</code>
<code class="s">"Fred ""The Hammer"" Smith",42,false</code>
<code class="s">Martha,37,"true"</code>
<code class="s">`</code><code class="w"/>
<code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">csv</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">data</code><code class="p">))</code><code class="w"/>
<code class="nx">allData</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">ReadAll</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">entries</code><code class="w"> </code><code class="p">[]</code><code class="nx">MyData</code><code class="w"/>
<code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">allData</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">entries</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">entries</code><code class="p">)</code><code class="w"/>

<code class="c1">//now to turn entries into output</code><code class="w"/>
<code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">entries</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">sb</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">strings</code><code class="p">.</code><code class="nx">Builder</code><code class="p">{}</code><code class="w"/>
<code class="nx">w</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">csv</code><code class="p">.</code><code class="nx">NewWriter</code><code class="p">(</code><code class="nx">sb</code><code class="p">)</code><code class="w"/>
<code class="nx">w</code><code class="p">.</code><code class="nx">WriteAll</code><code class="p">(</code><code class="nx">out</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sb</code><code class="p">)</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Build Functions with Reflection to Automate Repetitive Tasks"><div class="sect2" id="reflect_function">
<h2>Build Functions with Reflection to Automate Repetitive Tasks</h2>

<p>Another thing that Go lets you do with<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="automating repetitive tasks" id="id2914"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="automating repetitive tasks" id="id2915"/><a data-type="indexterm" data-primary="functions" data-secondary="automating repetitive tasks via reflection" id="id2916"/> reflection is create a function. You can use this technique to wrap existing functions with common functionality without writing repetitive code. For example, here’s a factory function that adds timing to any function that’s passed into it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">MakeTimedFunction</code><code class="p">(</code><code class="nx">f</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">any</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ft</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">wrapperF</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">MakeFunc</code><code class="p">(</code><code class="nx">ft</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">in</code><code class="w"> </code><code class="p">[]</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">start</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fv</code><code class="p">.</code><code class="nx">Call</code><code class="p">(</code><code class="nx">in</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">end</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">end</code><code class="p">.</code><code class="nx">Sub</code><code class="p">(</code><code class="nx">start</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">wrapperF</code><code class="p">.</code><code class="nx">Interface</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function takes in any function, so the parameter is of type <code>any</code>. It 
<span class="keep-together">then passes</span> the <code>reflect.Type</code> that represents the function into <code>reflect.MakeFunc</code>, along with a closure that captures the start time, calls the original function using reflection, captures the end time, prints out the difference, and returns the value calculated 
<span class="keep-together">by the</span> original function. The value returned from <code>reflect.MakeFunc</code> is a <code>reflect.Value</code>, and you call its <code>Interface</code> method to get the value to return. Here’s how you use it:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">timeMe</code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Duration</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">result</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">timed</code><code class="o">:=</code><code class="w"> </code><code class="nx">MakeTimedFunction</code><code class="p">(</code><code class="nx">timeMe</code><code class="p">).(</code><code class="kd">func</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">timed</code><code class="p">(</code><code class="mi">2</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can run a more complete version of this program on <a href="https://oreil.ly/NDfp1">The Go Playground</a> or in the <em>sample_code/timed_function</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="id2917"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="id2918"/></p>

<p>While generating functions is clever, be careful when using this feature. Make sure that it’s clear when you are using a generated function and what functionality it is adding. Otherwise, you will be making it harder to understand the flow of data through your program. Furthermore, as I’ll discuss in <a data-type="xref" href="#slow_reflection">“Use Reflection Only if It’s Worthwhile”</a>, reflection makes your programs slower, so using it to 
<span class="keep-together">generate</span> and invoke functions seriously impacts performance unless the code you are generating is already performing a slow operation, like a network call. Remember, reflection works best when it’s used to map data in and out of the edge of your 
<span class="keep-together">programs.</span></p>

<p>One project that follows these rules for generated functions is my SQL mapping library Proteus. It creates a type-safe database API by generating a function from a SQL query and a function field or variable. You can learn more about Proteus in my GopherCon 2017 talk, <a href="https://oreil.ly/ZUE47">“Runtime Generated, Typesafe, and Declarative: Pick Any Three,”</a> and you can find the source code on <a href="https://oreil.ly/KtFyj">GitHub</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="You Can Build Structs with Reflection, but Don’t"><div class="sect2" id="id274">
<h2>You Can Build Structs with Reflection, but Don’t</h2>

<p>You can make one more thing<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="avoid building structs with" id="id2919"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="avoid building structs with" id="id2920"/><a data-type="indexterm" data-primary="structs" data-secondary="reflection avoided for building" id="id2921"/> with reflection, and it’s weird. The <code>reflect.StructOf</code> function takes in a slice of <code>reflect.StructField</code> and returns a <code>reflect.Type</code> that represents a new struct type. These structs can be assigned only to variables of type <code>any</code>, and their fields can only be read and written using reflection.</p>

<p>For the most part, this is a feature of academic interest only. To see a demo of how <code>reflect.StructOf</code> works, look at the memoizer function on <a href="https://oreil.ly/iJwqv">The Go Playground</a> or in the <em>sample_code/memoizer</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>. It uses dynamically generated structs as the keys to a map that caches the output of a function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Reflection Can’t Make Methods"><div class="sect2" id="id275">
<h2>Reflection Can’t Make Methods</h2>

<p>You’ve seen all the things that you can<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="cannot add methods to a type" id="id2922"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="cannot add methods to a type" id="id2923"/><a data-type="indexterm" data-primary="methods" data-secondary="reflection cannot add to a type" id="id2924"/> do with reflection, but there’s one thing you can’t make. While you can use reflection to create new functions and new struct types, there’s no way to use reflection to add methods to a type. This means you cannot use reflection to create a new type that implements an interface.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Use Reflection Only if It’s Worthwhile"><div class="sect2" id="slow_reflection">
<h2>Use Reflection Only if It’s Worthwhile</h2>

<p>Although reflection is essential when<a data-type="indexterm" data-primary="reflect package" data-secondary="reflection" data-tertiary="use only if worthwhile" id="id2925"/><a data-type="indexterm" data-primary="types" data-secondary="reflection" data-tertiary="use only if worthwhile" id="id2926"/> converting data at the boundaries of Go, be careful using it in other situations. Reflection isn’t free. To demonstrate, let’s implement 
<span class="keep-together"><code>Filter</code></span> by using reflection. You looked at a generic implementation in <a data-type="xref" href="ch08.html#generic_functions">“Generic Functions Abstract Algorithms”</a>, but let’s see what a reflection-based version looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Filter</code><code class="p">(</code><code class="nx">slice</code><code class="w"> </code><code class="kt">any</code><code class="p">,</code><code class="w"> </code><code class="nx">filter</code><code class="w"> </code><code class="kt">any</code><code class="p">)</code><code class="w"> </code><code class="kt">any</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">slice</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fv</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">ValueOf</code><code class="p">(</code><code class="nx">filter</code><code class="p">)</code><code class="w"/>

<code class="w">    </code><code class="nx">sliceLen</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sv</code><code class="p">.</code><code class="nx">Len</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">MakeSlice</code><code class="p">(</code><code class="nx">sv</code><code class="p">.</code><code class="nx">Type</code><code class="p">(),</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">sliceLen</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">sliceLen</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">curVal</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sv</code><code class="p">.</code><code class="nx">Index</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">values</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fv</code><code class="p">.</code><code class="nx">Call</code><code class="p">([]</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Value</code><code class="p">{</code><code class="nx">curVal</code><code class="p">})</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">values</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">Bool</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">out</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">Append</code><code class="p">(</code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">curVal</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="p">.</code><code class="nx">Interface</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You use it like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">names</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"Andrew"</code><code class="p">,</code><code class="w"> </code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="s">"Clara"</code><code class="p">,</code><code class="w"> </code><code class="s">"Hortense"</code><code class="p">}</code><code class="w"/>
<code class="nx">longNames</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Filter</code><code class="p">(</code><code class="nx">names</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="p">}).([]</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">longNames</code><code class="p">)</code><code class="w"/>

<code class="nx">ages</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">20</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">,</code><code class="w"> </code><code class="mi">13</code><code class="p">}</code><code class="w"/>
<code class="nx">adults</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Filter</code><code class="p">(</code><code class="nx">ages</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">age</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">age</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">18</code><code class="w"/>
<code class="p">}).([]</code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">adults</code><code class="p">)</code><code class="w"/></pre>

<p>This prints out the following:</p>

<pre data-type="programlisting">[Andrew Clara Hortense]
[20 50]</pre>

<p>Your reflection-using filter function isn’t difficult to understand, but it’s certainly longer than a custom-written or generic function. Let’s see how it performs on an Apple Silicon M1 with 16 GB of RAM on Go 1.20 when filtering 1,000 element slices of strings and <code>int</code>s, compared to custom-written functions:</p>
<pre data-type="programlisting" class="no-indent">
BenchmarkFilterReflectString-8     5870  203962 ns/op  46616 B/op  2219 allocs/op
BenchmarkFilterGenericString-8   294355    3920 ns/op  16384 B/op     1 allocs/op
BenchmarkFilterString-8          302636    3885 ns/op  16384 B/op     1 allocs/op
BenchmarkFilterReflectInt-8        5756  204530 ns/op  45240 B/op  2503 allocs/op
BenchmarkFilterGenericInt-8      439100    2698 ns/op   8192 B/op     1 allocs/op
BenchmarkFilterInt-8             443745    2677 ns/op   8192 B/op     1 allocs/op
</pre>

<p>You can find this code in the <em>sample_code/reflection_filter</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a> so you can run it 
<span class="keep-together">yourself.</span><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="id2927"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="id2928"/></p>

<p>This benchmark demonstrates the value of using generics when you can. Reflection is over 50 times slower than a custom or generic function for string filtering and roughly 75 times slower for <code>int</code>s. It uses significantly more memory and performs thousands of allocations, which creates additional work for the garbage collector. The generic version provides the same performance as the custom-written functions without having to write multiple versions.</p>

<p>A more serious downside to the reflection implementation is that the compiler can’t stop you from passing in a wrong type for either the <code>slice</code> or the <code>filter</code> parameter. You might not mind a few thousand nanoseconds of CPU time, but if someone passes in a function or slice of the wrong type to <code>Filter</code>, your program will crash in production. The maintenance cost might be too high to accept.</p>

<p>Some things can’t be written using generics, and you’ll need to fall back to reflection. CSV marshaling and unmarshaling requires reflection, as does the memoizing program. In both cases, you need to work with an unknown number of values of different (and unknown) types. But do make sure that reflection is essential before employing it.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="unsafe Is Unsafe"><div class="sect1" id="id204">
<h1>unsafe Is Unsafe</h1>

<p>Just as the <code>reflect</code> package allows<a data-type="indexterm" data-primary="standard library" data-secondary="unsafe package" id="id2929"/><a data-type="indexterm" data-primary="unsafe package" id="id2930"/> you to manipulate types and values, the <code>unsafe</code> package allows you to manipulate memory. The <code>unsafe</code> package is very small and very odd. It defines several functions and one type, none of which act like the types and functions found in other packages.</p>

<p>Given Go’s focus on memory safety, you might wonder why <code>unsafe</code> even exists. Just as you used <code>reflect</code> to translate text data between the outside world and Go code, you use <code>unsafe</code> to translate binary data. There are two main reasons for using <code>unsafe</code>. A 2020 paper by Diego Elias Costa et al. called <a href="https://oreil.ly/N_6JX">“Breaking Type-Safety in Go: An Empirical Study on the Usage of the unsafe Package”</a> surveyed 2,438 popular Go open source projects and found the following:</p>

<ul>
<li>
<p>24% of the studied Go projects use <code>unsafe</code> at least once in their codebase.</p>
</li>
<li>
<p>The majority of <code>unsafe</code> usages were motivated by integration with operating systems and C code.</p>
</li>
<li>
<p>Developers frequently use <code>unsafe</code> to write more efficient Go code.</p>
</li>
</ul>

<p>The plurality of the uses of <code>unsafe</code> are for system interoperability. The Go standard library uses <code>unsafe</code> to read data from and write data to the operating system. <a data-type="indexterm" data-primary="standard library" data-secondary="syscall package" id="id2931"/><a data-type="indexterm" data-primary="syscall package" id="id2932"/><a data-type="indexterm" data-primary="standard library" data-secondary="sys package" id="id2933"/><a data-type="indexterm" data-primary="sys package" id="id2934"/><a data-type="indexterm" data-primary="golang.org/x packages" data-secondary="golang.org/x/sys" id="id2935"/><a data-type="indexterm" data-primary="Layher, Matt" id="id2936"/><a data-type="indexterm" data-primary="resources online" data-secondary="unsafe blog post" id="id2937"/>You can see examples in the <code>syscall</code> package in the standard library or in the higher-level <a href="https://oreil.ly/ueHY3"><code>sys</code> package</a>. You can learn more about how to use <code>unsafe</code> to communicate with the operating system in <a href="https://oreil.ly/VtE1t">a great blog post</a> written by Matt Layher.</p>

<p>The <code>unsafe.Pointer</code> type is a <a data-type="indexterm" data-primary="unsafe package" data-secondary="unsafe.Pointer type" id="id2938"/><a data-type="indexterm" data-primary="types" data-secondary="unsafe.Pointer type" id="id2939"/>special type that exists for a single purpose: a pointer of any type can be converted to or from <code>unsafe.Pointer</code>. In addition to pointers, <code>unsafe.Pointer</code> can also be converted to or from a special integer type, called <code>uintptr</code>. As with any other integer type, you can do math with it. This allows you to walk into an instance of a type, extracting individual bytes. You can also perform pointer arithmetic, just as you can with pointers in C and C++. This byte manipulation changes the value of the variable.</p>

<p>There are two common patterns in <code>unsafe</code> code. The first is a conversion between two types of variables that are normally not convertible. This is performed using a series of type conversions with <code>unsafe.Pointer</code> in the middle. The second is reading or modifying the bytes in a variable by converting a variable to an <code>unsafe.Pointer</code>, converting the <code>unsafe.Pointer</code> to a pointer, and then copying or manipulating the underlying bytes. Both of these techniques require you to know the size (and possibly the location) of the data being manipulated. The <code>Sizeof</code> and <code>Offsetof</code> functions in the <code>unsafe</code> package provide this information.</p>








<section data-type="sect2" data-pdf-bookmark="Using Sizeof and Offsetof"><div class="sect2" id="id205">
<h2>Using Sizeof and Offsetof</h2>

<p>Some of the functions in <code>unsafe</code> reveal how<a data-type="indexterm" data-primary="unsafe package" data-secondary="unsafe.Sizeof" id="ch16-sizeof"/> the bytes in various types are laid out in memory. The first one you’ll look at is <code>Sizeof</code>. As the name implies, it returns the size in bytes of whatever is passed into it.</p>

<p>While the sizes for numeric types are fairly obvious (an <code>int16</code> is 16 bits or 2 bytes, a <code>byte</code> is 1 byte, and so on), other types are a bit more complicated. For a pointer, you get the size of the memory to store the pointer (usually 8 bytes on a 64-bit system), not the size of the data that the pointer points to. This is why <code>Sizeof</code> considers any slice to be 24 bytes long on a 64-bit system; it’s implemented as two <code>int</code> fields (for length and capacity) and a pointer to the data for the slice. Any <code>string</code> is 16 bytes long on a 64-bit system (an <code>int</code> for length and a pointer to the contents of the string). Any <code>map</code> on a 64-bit system is 8 bytes, since within the Go runtime, a <code>map</code> is implemented as a pointer to a rather complicated data structure.</p>

<p>Arrays are value types, so their size is calculated by multiplying the length of the array by the size of each element in the array.</p>

<p>For a struct, the size is the sum of the sizes of the fields, plus some adjustments for <em>alignment</em>. Computers like to read and write data in regular-sized chunks and they really don’t want a value to start in one chunk and end in another. To make this happen, the compiler adds padding between fields so they line up properly. The compiler also wants the entire struct to be properly aligned. On a 64-bit system, it will add padding at the end of the struct to bring its size up to a multiple of 8 bytes.</p>

<p>Another function in <code>unsafe</code>, <code>Offsetof</code>, tells you<a data-type="indexterm" data-primary="unsafe package" data-secondary="unsafe.Offsetof" id="ch16-offsetof"/> the position of a field within a struct. Let’s use <code>Sizeof</code> and <code>Offsetof</code> to look at the effects of field order on the size of a struct. Say you have two structs:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">BoolInt</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w"> </code><code class="kt">int64</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">IntBool</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w"> </code><code class="kt">int64</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this code</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Sizeof</code><code class="p">(</code><code class="nx">BoolInt</code><code class="p">{}),</code><code class="w"/>
<code class="w">    </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Offsetof</code><code class="p">(</code><code class="nx">BoolInt</code><code class="p">{}.</code><code class="nx">b</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Offsetof</code><code class="p">(</code><code class="nx">BoolInt</code><code class="p">{}.</code><code class="nx">i</code><code class="p">))</code><code class="w"/>

<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Sizeof</code><code class="p">(</code><code class="nx">IntBool</code><code class="p">{}),</code><code class="w"/>
<code class="w">    </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Offsetof</code><code class="p">(</code><code class="nx">IntBool</code><code class="p">{}.</code><code class="nx">i</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Offsetof</code><code class="p">(</code><code class="nx">IntBool</code><code class="p">{}.</code><code class="nx">b</code><code class="p">))</code><code class="w"/></pre>

<p>produces the following output:</p>

<pre data-type="programlisting">16 0 8
16 0 8</pre>

<p>The size of both types is 16 bytes. When the <code>bool</code> comes first, the compiler puts 7 bytes of padding between <code>b</code> and <code>i</code>. When the <code>int64</code> comes first, the compiler puts 7 bytes of padding after <code>b</code> to make the struct’s size a multiple of 8 bytes.</p>

<p class="pagebreak-before">You can see the effect of field order when there are more fields:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">BoolIntBool</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w">  </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w">  </code><code class="kt">int64</code><code class="w"/>
<code class="w">    </code><code class="nx">b2</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">BoolBoolInt</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w">  </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">b2</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w">  </code><code class="kt">int64</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">IntBoolBool</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="w">  </code><code class="kt">int64</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w">  </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">b2</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Printing out the sizes and offsets for these types produces the following output:</p>

<pre data-type="programlisting">24 0 8 16
16 0 1 8
16 0 8 9</pre>

<p>Putting the <code>int64</code> field between the two <code>bool</code> fields produces a struct that’s 24 bytes long, since both <code>bool</code> fields need to be padded to 8 bytes. Meanwhile, grouping the <code>bool</code> fields together produces a struct that’s 16 bytes long, the same as the structs with only two fields. You can validate this on <a href="https://oreil.ly/1X9--">The Go Playground</a> or in the <em>sample_code/sizeof_offsetof</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="ix_qq123"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="ix_p1p"/></p>

<p>Although only of academic interest most of the time, this information is useful in two situations. The first is in programs that manage large amounts of data. You can sometimes achieve significant savings in memory usage simply by reordering the fields in heavily used structs in order to minimize the amount of padding needed for alignment.<a data-type="indexterm" data-startref="ch16-sizeof" id="id2940"/><a data-type="indexterm" data-startref="ch16-offsetof" id="id2941"/></p>

<p>The second situation occurs when you want to map a sequence of bytes directly into a struct. You’ll look at that next.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Using unsafe to Convert External Binary Data"><div class="sect2" id="id206">
<h2>Using unsafe to Convert External Binary Data</h2>

<p>As was mentioned earlier, one of the main reasons<a data-type="indexterm" data-primary="unsafe package" data-secondary="converting external binary data" id="ch16-ext"/> people use <code>unsafe</code> is for performance, especially when reading data from a network. If you want to map the data into or out of a Go data structure, <code>unsafe.Pointer</code> gives you a very fast way to do so. You can explore this with a contrived example. Imagine a <em>wire protocol</em> (a specification indicating which bytes are written in which order when communicating over a network) with the following structure:</p>

<ul class="less_space">
<li>
<p>Value: 4 bytes, representing an unsigned, big-endian 32-bit int</p>
</li>
<li>
<p>Label: 10 bytes, ASCII name for the value</p>
</li>
<li>
<p>Active: 1 byte, boolean flag to indicate whether the field is active</p>
</li>
<li>
<p>Padding: 1 byte, because you want everything to fit into 16 bytes</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Data sent over a network is usually sent in big-endian format (most significant bytes first), often called <em>network byte order</em>. Since most CPUs in use today are little-endian (or bi-endian running in little-endian mode), you need to be careful when reading or writing data to a network.</p>
</div>

<p>The code for this example is in the <em>sample_code/unsafe_data</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-startref="ix_p1p" id="id2942"/><a data-type="indexterm" data-startref="ix_qq123" id="id2943"/></p>

<p>You define a data structure whose in-memory layout matches the wire protocol:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Data</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Value</code><code class="w">  </code><code class="kt">uint32</code><code class="w">   </code><code class="c1">// 4 bytes</code><code class="w"/>
<code class="w">    </code><code class="nx">Label</code><code class="w">  </code><code class="p">[</code><code class="mi">10</code><code class="p">]</code><code class="kt">byte</code><code class="w"> </code><code class="c1">// 10 bytes</code><code class="w"/>
<code class="w">    </code><code class="nx">Active</code><code class="w"> </code><code class="kt">bool</code><code class="w">     </code><code class="c1">// 1 byte</code><code class="w"/>
<code class="w">    </code><code class="c1">// Go pads this with 1 byte to make it align</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You use <code>unsafe.Sizeof</code> to define a constant that represents its size:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="nx">dataSize</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Sizeof</code><code class="p">(</code><code class="nx">Data</code><code class="p">{})</code><code class="w"> </code><code class="c1">// sets dataSize to 16</code><code class="w"/></pre>

<p>(One of the weird things about <code>unsafe.Sizeof</code> and <code>Offsetof</code> is that you can use them in <code>const</code> expressions. The size and layout of a data structure in memory is known at compile time, so the results of these functions are calculated at compile time, just like a constant expression.)</p>

<p>Say you just read the following bytes off the network:</p>

<pre data-type="programlisting">[0 132 95 237 80 104 111 110 101 0 0 0 0 0 1 0]</pre>

<p>You’re going to read these bytes into an array of length 16 and then convert that array into the <code>struct</code> described previously.</p>

<p>With safe Go code, you could map it like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">DataFromBytes</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="nx">Data</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">d</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Data</code><code class="p">{}</code><code class="w"/>
<code class="w">    </code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">binary</code><code class="p">.</code><code class="nx">BigEndian</code><code class="p">.</code><code class="nx">Uint32</code><code class="p">(</code><code class="nx">b</code><code class="p">[:</code><code class="mi">4</code><code class="p">])</code><code class="w"/>
<code class="w">    </code><code class="nb">copy</code><code class="p">(</code><code class="nx">d</code><code class="p">.</code><code class="nx">Label</code><code class="p">[:],</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="mi">4</code><code class="p">:</code><code class="mi">14</code><code class="p">])</code><code class="w"/>
<code class="w">    </code><code class="nx">d</code><code class="p">.</code><code class="nx">Active</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="mi">14</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">d</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Or, you could use <code>unsafe.Pointer</code> instead:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">DataFromBytesUnsafe</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="nx">Data</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">*</code><code class="p">(</code><code class="o">*</code><code class="nx">Data</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">b</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">isLE</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">data</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">bits</code><code class="p">.</code><code class="nx">ReverseBytes32</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">data</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The first line is a little confusing, but you can take it apart and understand what’s going on. First, you take the address of the byte array and convert it to an <code>unsafe.Pointer</code>. Then you convert the <code>unsafe.Pointer</code> to a <code>(*Data)</code> (you have to put <code>(*Data)</code> in parentheses because of Go’s order of operations). You want to return the struct, not a pointer to it, so you dereference the pointer. Next, you check your flag to see if you are on a little-endian platform. If so, you reverse the bytes in the <code>Value</code> field. Finally, you return the value.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Why did you use an array instead of a slice for the parameter? Remember, arrays, like structs, are value types; the bytes are allocated directly. That means you can map the values in <code>b</code> directly into the <code>data</code> struct. A slice is composed of three parts: a length, a capacity, and a pointer to the actual values. You’ll see how to map a slice into a struct using <code>unsafe</code> in a bit.</p>
</div>

<p>How do you know if you are on a little-endian platform? Here’s the code you’re using:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">isLE</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">init</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">uint16</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mh">0xFF00</code><code class="w"/>
<code class="w">    </code><code class="nx">xb</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">*</code><code class="p">(</code><code class="o">*</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="kt">byte</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">isLE</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">(</code><code class="nx">xb</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mh">0x00</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>As I discussed in <a data-type="xref" href="ch10.html#pkg_init">“Avoiding the init Function if Possible”</a>, you should avoid using <code>init</code> functions, except when initializing a package-level value whose value is effectively immutable. Since the endianness of your processor isn’t going to change while your program is running, this is a good use case.</p>

<p>On a little-endian platform, the bytes that represent <code>x</code> will be stored as [00 FF]. On a big-endian platform, <code>x</code> is stored in memory as [FF 00]. You use <code>unsafe.Pointer</code> to convert a number to an array of bytes, and you check what the first byte is to determine the value of <code>isLE</code>.</p>

<p class="less_space pagebreak-before">Likewise, if you wanted to write your <code>Data</code> back to the network, you could use safe Go:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">BytesFromData</code><code class="p">(</code><code class="nx">d</code><code class="w"> </code><code class="nx">Data</code><code class="p">)</code><code class="w"> </code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="p">{}</code><code class="w"/>
<code class="w">    </code><code class="nx">binary</code><code class="p">.</code><code class="nx">BigEndian</code><code class="p">.</code><code class="nx">PutUint32</code><code class="p">(</code><code class="nx">out</code><code class="p">[:</code><code class="mi">4</code><code class="p">],</code><code class="w"> </code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nb">copy</code><code class="p">(</code><code class="nx">out</code><code class="p">[</code><code class="mi">4</code><code class="p">:</code><code class="mi">14</code><code class="p">],</code><code class="w"> </code><code class="nx">d</code><code class="p">.</code><code class="nx">Label</code><code class="p">[:])</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">d</code><code class="p">.</code><code class="nx">Active</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">out</code><code class="p">[</code><code class="mi">14</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Or you could use <code>unsafe</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">BytesFromDataUnsafe</code><code class="p">(</code><code class="nx">d</code><code class="w"> </code><code class="nx">Data</code><code class="p">)</code><code class="w"> </code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">isLE</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">bits</code><code class="p">.</code><code class="nx">ReverseBytes32</code><code class="p">(</code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">*</code><code class="p">(</code><code class="o">*</code><code class="p">[</code><code class="nx">dataSize</code><code class="p">]</code><code class="kt">byte</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">d</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">b</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If the bytes are stored in a slice, you can use the <code>unsafe.Slice</code> function to create a slice from the contents of <code>Data</code>. The <code>unsafe.SliceData</code> function is used to create a <code>Data</code> instance from the data stored in a slice:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">BytesFromDataUnsafeSlice</code><code class="p">(</code><code class="nx">d</code><code class="w"> </code><code class="nx">Data</code><code class="p">)</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">isLE</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">bits</code><code class="p">.</code><code class="nx">ReverseBytes32</code><code class="p">(</code><code class="nx">d</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">bs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Slice</code><code class="p">((</code><code class="o">*</code><code class="kt">byte</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">d</code><code class="p">)),</code><code class="w"> </code><code class="nx">dataSize</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">bs</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">DataFromBytesUnsafeSlice</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="nx">Data</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">*</code><code class="p">(</code><code class="o">*</code><code class="nx">Data</code><code class="p">)((</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">)(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">SliceData</code><code class="p">(</code><code class="nx">b</code><code class="p">)))</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">isLE</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">data</code><code class="p">.</code><code class="nx">Value</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">bits</code><code class="p">.</code><code class="nx">ReverseBytes32</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">data</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The first parameter to <code>unsafe.Slice</code> requires two casts. The first cast converts a pointer of the <code>Data</code> instance to an <code>unsafe.Pointer</code>. Then you need to cast again to a pointer of the type of data that you want the slice to hold. For a slice of bytes, you use <code>*byte</code>. The second parameter is the length of the data.</p>

<p>The <code>unsafe.SliceData</code> function takes in a slice and returns a pointer to the type of the data contained in the slice. In this case, you passed in a <code>[]byte</code>, so it returned a <code>*byte</code>.  You then use <code>unsafe.Pointer</code> as a bridge between <code>*byte</code> and <code>*Data</code> to convert the contents of the slice into a <code>Data</code> instance.</p>

<p>Is this worth it? Here are the timings on an Apple Silicon M1 (which is little-endian):</p>

<pre data-type="programlisting">BenchmarkBytesFromData-8             548607271  2.185 ns/op   0 B/op 0 allocs/op
BenchmarkBytesFromDataUnsafe-8      1000000000  0.8418 ns/op  0 B/op 0 allocs/op
BenchmarkBytesFromDataUnsafeSlice-8  91179056  13.14 ns/op   16 B/op 1 allocs/op
BenchmarkDataFromBytes-8             538443861  2.186 ns/op   0 B/op 0 allocs/op
BenchmarkDataFromBytesUnsafe-8      1000000000  1.160 ns/op   0 B/op 0 allocs/op
BenchmarkDataFromBytesUnsafeSlice-8 1000000000  0.9617 ns/op  0 B/op 0 allocs/op</pre>

<p>Two things stand out in this chart. First, the conversion from a struct to a slice is by far the slowest operation, and it’s the only one that allocates memory. This isn’t surprising, since the slice’s data needs to escape to the heap when it is returned from the function. Allocating memory on the heap is almost always slower than using memory on the stack. Converting from a slice to a struct is very fast, though.</p>

<p>If you are working with arrays, using <code>unsafe</code> is about 2–2.5 times faster than the standard approach. If you have a program with many of these kinds of conversions, or if you are trying to map a very large and complicated data structure, using these low-level techniques is worthwhile. But for the vast majority of programs, stick with the safe code. <a data-type="indexterm" data-startref="ch16-ext" id="id2944"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing Unexported Fields"><div class="sect2" id="id276">
<h2>Accessing Unexported Fields</h2>

<p>Here’s another bit of magic you can<a data-type="indexterm" data-primary="unsafe package" data-secondary="unexported field access" id="id2945"/> do with <code>unsafe</code>, but it’s something to use only as a last resort. You can combine reflection and <code>unsafe</code> to read and modify unexported fields in structs. Let’s see how.</p>

<p>First, define a struct in one package:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">HasUnexportedField</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">A</code><code class="w"> </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="kt">bool</code><code class="w"/>
<code class="w">    </code><code class="nx">C</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Normally, code outside this package is unable to access <code>b</code>. However, let’s see what you can do from another package by using <code>unsafe</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">SetBUnsafe</code><code class="p">(</code><code class="nx">huf</code><code class="w"> </code><code class="o">*</code><code class="nx">one_package</code><code class="p">.</code><code class="nx">HasUnexportedField</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sf</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reflect</code><code class="p">.</code><code class="nx">TypeOf</code><code class="p">(</code><code class="nx">huf</code><code class="p">).</code><code class="nx">Elem</code><code class="p">().</code><code class="nx">FieldByName</code><code class="p">(</code><code class="s">"b"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">offset</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sf</code><code class="p">.</code><code class="nx">Offset</code><code class="w"/>
<code class="w">    </code><code class="nx">start</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="nx">huf</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">pos</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code><code class="w"> </code><code class="nx">offset</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="kt">bool</code><code class="p">)(</code><code class="nx">pos</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="o">*</code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="c1">// read the value</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="nx">b</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">true</code><code class="w">       </code><code class="c1">// write the value</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You use reflection to access type information about field <code>b</code>. The <code>FieldByName</code> method returns a <code>reflect.StructField</code> instance for any field on a struct, even unexported ones. The instance includes the offset of its associated field. You then convert <code>huf</code> into an <code>unsafe.Pointer</code> and use the <code>unsafe.Add</code> method to add the offset to the pointer in order to find the location of <code>b</code> within the struct. All that remains is casting the <code>unsafe.Pointer</code> returned by <code>Add</code> to a <code>*bool</code>. Now you can read the value of <code>b</code> or set its value. You can try out this code in the <em>sample_code/unexported_field_access</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="ix_qqq"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="ix_qqqq"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Using unsafe Tools"><div class="sect2" id="id277">
<h2>Using unsafe Tools</h2>

<p>Go is a language that values tooling,<a data-type="indexterm" data-primary="unsafe package" data-secondary="-gcflags=-d=checkptr" data-secondary-sortas="gcflags" id="id2946"/> and a compiler flag can help you find 
<span class="keep-together">misuse</span> of <code>Pointer</code> and <code>unsafe.Pointer</code>. Run your code with the flag 
<span class="keep-together"><code>-gcflags=-d=checkptr</code></span> to add additional checks at runtime. Like the race checker, it’s not guaranteed to find every <code>unsafe</code> problem and it does slow your program. However, it’s a good practice while testing your code.</p>

<p>If you want to learn more about <code>unsafe</code>, read through the package <a href="https://oreil.ly/xmihF">documentation</a>.<a data-type="indexterm" data-primary="unsafe package" data-secondary="documentation URL" id="id2947"/><a data-type="indexterm" data-primary="resources online" data-secondary="unsafe documentation" id="id2948"/></p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The <code>unsafe</code> package is powerful and low-level! Avoid using it unless you know what you are doing and you need the performance improvements that it provides.</p>
</div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Cgo Is for Integration, Not Performance"><div class="sect1" id="cgo">
<h1>Cgo Is for Integration, Not Performance</h1>

<p>Just like reflection and <code>unsafe</code>,<a data-type="indexterm" data-primary="cgo package for C library integration" id="ch16-cgo"/><a data-type="indexterm" data-primary="C library integration" data-secondary="cgo" id="ch16-cgo2"/><a data-type="indexterm" data-primary="Go" data-secondary="cgo for C library integration" id="ch16-cgo3"/> <code>cgo</code> is most useful at the border between Go programs and the outside world. Reflection helps integrate with external textual data,  <code>unsafe</code> is best used with operating system and network data, and <code>cgo</code> is best for integrating with C libraries.</p>

<p>Despite being nearly 50 years old, C is still the <em>lingua franca</em> of programming languages. All the major operating systems are primarily written in either C or C++, which means that they are bundled with libraries written in C. It also means that nearly every programming language provides a way to integrate with C libraries. Go calls its  foreign function interface (FFI) to C <code>cgo</code>.</p>

<p>As you have seen many times, Go is a language that favors explicit specification. Go developers sometimes deride automatic behaviors in other languages as “magic.” However, using <code>cgo</code> feels a bit like spending time with Merlin. Let’s take a look at this magical glue code.</p>

<p>You’ll start with a very simple program that calls C code to do some math. The source code is in GitHub in the <em>sample_code/call_c_from_go</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>. First, here’s the code in <em>main.go</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="s">"fmt"</code><code class="w"/>

<code class="cm">/*</code>
<code class="cm">    #cgo LDFLAGS: -lm</code>
<code class="cm">    #include &lt;stdio.h&gt;</code>
<code class="cm">    #include &lt;math.h&gt;</code>
<code class="cm">    #include "mylib.h"</code>

<code class="cm">    int add(int a, int b) {</code>
<code class="cm">        int sum = a + b;</code>
<code class="cm">        printf("a: %d, b: %d, sum %d\n", a, b, sum);</code>
<code class="cm">        return sum;</code>
<code class="cm">    }</code>
<code class="cm">*/</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="s">"C"</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">sum</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">C</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">C</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="mi">100</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">C</code><code class="p">.</code><code class="nx">multiply</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <em>mylib.h</em> header is in the same directory as your <em>main.go</em>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code><code class="w"> </code><code class="nf">multiply</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">b</code><code class="p">);</code><code class="w"/></pre>

<p>There is also <em>mylib.c</em>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"mylib.h"</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">multiply</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Assuming you have a C compiler installed on your computer, all you need to do is compile your program with <code>go build</code>:</p>

<pre data-type="programlisting">$ go build
$ ./call_c_from_go
a: 3, b: 2, sum 5
5
10
200</pre>

<p>What’s going on here? The standard library<a data-type="indexterm" data-primary="standard library" data-secondary="C pseudopackage" id="ch16-pseu"/><a data-type="indexterm" data-primary="C library integration" data-secondary="C pseudopackage" id="ch16-pseu2"/> doesn’t have a real package named <code>C</code>. Instead, <code>C</code> is an automatically generated package whose identifiers mostly come from the C code embedded in the comments that immediately precede it. In this example, you declare a C function called <code>add</code>, and <code>cgo</code> makes it available to your Go program as the name <code>C.add</code>. You can also invoke functions or global variables that are imported into the comment block from libraries via header files, as you can see when you call <code>C.sqrt</code> from <code>main</code> (imported from <em>math.h</em>) or <code>C.multiply</code> (imported from <em>mylib.h</em>).</p>

<p>In addition to the identifier names that appear in the comment block (or are imported into the comment block), the <code>C</code> pseudopackage also defines types like <code>C.int</code> and <code>C.char</code> to represent the built-in C types and functions, such as <code>C.CString</code> to convert a Go string to a C string.</p>

<p>You can use more magic to call Go functions from C functions. Go functions can be exposed to C code by putting an <code>//export</code> comment before the function. You can see this in use in the <em>sample_code/call_go_from_c</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>. In <em>main.go</em>, you export the doubler function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">//export doubler</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">doubler</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When you export a Go function, you can no longer write C code directly in the comment before the <code>import "C"</code> statement. You can only list function headers:</p>

<pre data-type="programlisting" data-code-language="go"><code class="cm">/*</code>
<code class="cm">    extern int add(int a, int b);</code>
<code class="cm">*/</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="s">"C"</code><code class="w"/></pre>

<p>Put your C code into a <em>.c</em> file in the same directory as your Go code and include the magic header <code>"cgo_export.h"</code>. You can see this in the <em>example.c</em> file:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include</code><code class="w"> </code><code class="cpf">"_cgo_export.h"</code><code class="cp"/>

<code class="kt">int</code><code class="w"> </code><code class="nf">add</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">doubleA</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">doubler</code><code class="p">(</code><code class="n">a</code><code class="p">);</code><code class="w"/>
<code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="n">sum</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">doubleA</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="n">b</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">sum</code><code class="p">;</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this program with <code>go build</code> give the following output:</p>

<pre data-type="programlisting">$ go build
$ ./call_go_from_c
8</pre>

<p>So far, this seems pretty simple, but one major stumbling block arises when using <code>cgo</code>: Go is a garbage-collected language, and C is not. This makes it difficult to integrate nontrivial Go code with C. While you can pass a pointer into C code, you cannot directly pass something that contains a pointer. This is very limiting, as things like strings, slices, and functions are implemented with pointers and therefore cannot be contained in a struct passed into a C function.</p>

<p>That’s not all: a C function cannot store a copy of a Go pointer that lasts after the function returns. If you break these rules, your program will compile and run, but it may crash or behave incorrectly at runtime when the memory pointed to by the  pointer is garbage collected.</p>

<p>If you find yourself needing to pass an instance of a type that contains a pointer from Go to C and then back into Go, <a data-type="indexterm" data-primary="cgo package for C library integration" data-secondary="cgo.Handle" id="id2949"/>you can use a <code>cgo.Handle</code> to wrap the instance. Here’s a short example. You can find the source code in the <em>sample_code/handle</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-startref="ix_qqqq" id="id2950"/><a data-type="indexterm" data-startref="ix_qqq" id="id2951"/><a data-type="indexterm" data-primary="cgo package for C library integration" data-secondary="cgo.NewHandle" id="id2952"/></p>

<p>First you have your Go code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>

<code class="cm">/*</code>
<code class="cm">    #include &lt;stdint.h&gt;</code>

<code class="cm">    extern void in_c(uintptr_t handle);</code>
<code class="cm">*/</code><code class="w"/>
<code class="kn">import</code><code class="w"> </code><code class="s">"C"</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="s">"fmt"</code><code class="w"/>
<code class="w">    </code><code class="s">"runtime/cgo"</code><code class="w"/>
<code class="p">)</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">p</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Person</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Name</code><code class="p">:</code><code class="w"> </code><code class="s">"Jon"</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">Age</code><code class="p">:</code><code class="w">  </code><code class="mi">21</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">C</code><code class="p">.</code><code class="nx">in_c</code><code class="p">(</code><code class="nx">C</code><code class="p">.</code><code class="nx">uintptr_t</code><code class="p">(</code><code class="nx">cgo</code><code class="p">.</code><code class="nx">NewHandle</code><code class="p">(</code><code class="nx">p</code><code class="p">)))</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">//export processor</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">processor</code><code class="p">(</code><code class="nx">handle</code><code class="w"> </code><code class="nx">C</code><code class="p">.</code><code class="nx">uintptr_t</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">h</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">cgo</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="nx">handle</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">p</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">h</code><code class="p">.</code><code class="nx">Value</code><code class="p">().(</code><code class="nx">Person</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">Age</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">h</code><code class="p">.</code><code class="nx">Delete</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p class="pagebreak-before">And this is the C code:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include</code><code class="w"> </code><code class="cpf">&lt;stdint.h&gt;</code><code class="cp"/>
<code class="cp">#include</code><code class="w"> </code><code class="cpf">"_cgo_export.h"</code><code class="cp"/>

<code class="kt">void</code><code class="w"> </code><code class="nf">in_c</code><code class="p">(</code><code class="kt">uintptr_t</code><code class="w"> </code><code class="n">handle</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="n">processor</code><code class="p">(</code><code class="n">handle</code><code class="p">);</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In the Go code, you’re passing a <code>Person</code> instance into the C function <code>in_c</code>. This function in turn calls the Go function <code>processor</code>. You can’t safely pass a <code>Person</code> into C via <code>cgo</code>, because one of its fields is a <code>string</code>, and every <code>string</code> contains a pointer. To make this work, use the <code>cgo.NewHandle</code> function to convert <code>p</code> to a <code>cgo.Handle</code>. You then cast the <code>Handle</code> to a <code>C.uintptr_t</code> so you can pass it to the C function <code>in_c</code>. The function takes in a single parameter of type <code>uintptr_t</code>, which is a C type that is analogous to Go’s <code>uintptr</code> type. The <code>in_c</code> function calls the Go function <code>process</code>, which also takes in a single parameter of type <code>C.uintptr_t</code>. It casts this parameter to a <code>cgo.Handle</code>, and then uses a type assertion to convert the <code>Handle</code> to a <code>Person</code> instance. You print out the fields in <code>p</code>. Now that you are done using the <code>Handle</code>, you call the <code>Delete</code> method to delete it.</p>

<p>In addition to working with pointers, other <code>cgo</code> limitations exist. For example, you cannot use <code>cgo</code> to call a variadic C function (such as <code>printf</code>). Union types in C are converted into byte arrays. And you cannot invoke a C function pointer (but you can assign it to a Go variable and pass it back into a C function).</p>

<p>These rules make using <code>cgo</code> nontrivial. If you have a background in Python or Ruby, you might think that using <code>cgo</code> is worth it for performance reasons. Those developers write the performance-critical parts of their programs in C. The speed of NumPy is due to the C libraries that are wrapped by Python code.</p>

<p>In most cases, Go code is many times faster than Python or Ruby, so the need to rewrite algorithms in a lower-level language is greatly reduced. You might think that you could save <code>cgo</code> for those situations when you do need additional performance gains, but unfortunately, using <code>cgo</code> to make your code faster is difficult. Because of the mismatches in the processing and memory models, calling a C function from Go is roughly 29 times slower than a C function calling another C function.</p>

<p>At CapitalGo 2018, Filippo Valsorda gave a talk, called “Why cgo is slow.” Unfortunately, the talk wasn’t recorded, but <a href="https://oreil.ly/MLRFY">slides are available</a>. They explain why <code>cgo</code> is slow and why it will not be made appreciably faster in the future. In his blog post <a href="https://oreil.ly/AoCDG">“CGO Performance in Go 1.21,”</a> Shane Hansen measured the overhead of a <code>cgo</code> call in Go 1.21 at roughly 40ns on an Intel Core i7-12700H.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Since <code>cgo</code> isn’t fast, and it isn’t easy to use for nontrivial programs, the only reason to use <code>cgo</code> is if you must use a C library and there is no suitable Go replacement. Rather than writing <code>cgo</code> yourself, see if a third-party module already provides the wrapper. <a data-type="indexterm" data-primary="ImageMagick" id="id2953"/><a data-type="indexterm" data-primary="SQLite embedded in Go application" id="id2954"/>For example, if you want to embed SQLite in a Go application, look at <a href="https://oreil.ly/IEskN">GitHub</a>. For ImageMagick, check out <a href="https://oreil.ly/l58-1">this repository</a>.</p>
</div>

<p>If you find yourself needing to use an internal C library or third-party library that doesn’t have a wrapper, you can find <a href="https://oreil.ly/9JvNI">additional details</a> on how to write your integration in the Go documentation. For information on the sorts of performance and design trade-offs that you are likely to encounter when using <code>cgo</code>, read Tobias Grieger’s blog post called <a href="https://oreil.ly/Oj9Tw">“The Cost and Complexity of Cgo.”</a><a data-type="indexterm" data-startref="ch16-cgo" id="id2955"/><a data-type="indexterm" data-startref="ch16-cgo2" id="id2956"/><a data-type="indexterm" data-startref="ch16-cgo3" id="id2957"/><a data-type="indexterm" data-startref="ch16-pseu" id="id2958"/><a data-type="indexterm" data-startref="ch16-pseu2" id="id2959"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id295">
<h1>Exercises</h1>

<p>Now it’s time to test yourself to see if you can write small programs using reflection, <code>unsafe</code>, and <code>cgo</code>. Answers for the exercises are found in the <em>exercise_solutions</em> directory in the <a href="https://oreil.ly/jAIdQ">Chapter 16 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 16" data-tertiary-sortas="ppp" id="id2960"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 16" data-tertiary-sortas="qqq" id="id2961"/></p>
<ol>
<li>
<p>Use reflection to create a simple minimal string-length validator for struct fields. Write a <code>ValidateStringLength</code> function that takes in a struct and returns an error if one or more of the fields is a string, has a struct tag called <code>minStrlen</code>, and the length of the value in the field is less than the value specified in the struct tag. Nonstring fields and string fields that don’t have the <code>minStrlen</code> struct tag are ignored. Use <code>errors.Join</code> to report all invalid fields. Be sure to validate that a struct was passed in. Return <code>nil</code> if all fields are of the proper length.</p>
</li>
<li>
<p>Use <code>unsafe.Sizeof</code> and <code>unsafe.Offsetof</code> to print out the size and offsets for the <code>OrderInfo</code> struct defined in <a href="https://oreil.ly/SrSpa"><em>ch16/tree/main/sample_code/orders</em></a>. Create a new type, <code>SmallOrderInfo</code>, that has the same fields, but reordered to use as little memory as possible.</p>
</li>
<li>
<p>Copy the C code at <a href="https://oreil.ly/E-PfQ"><em>ch16/tree/main/sample_code/mini_calc</em></a> into your own module and use <code>cgo</code> to call it from a Go program.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id361">
<h1>Wrapping Up</h1>

<p>In this chapter, you’ve learned about reflection, <code>unsafe</code>, and <code>cgo</code>. These features are probably the most exciting parts of Go because they allow you to break the rules that make Go a boring, type-safe, memory-safe language. More importantly, you’ve learned <em>why</em> you would want to break the rules and why you should avoid doing so most of the time.</p>

<p>You’ve completed your journey through Go and how to use it idiomatically. As with any graduation ceremony, it’s time for a few closing words. Let’s look back at what was said in the preface. “[P]roperly written, Go is boring…​.Well-written Go programs tend to be straightforward and sometimes a bit repetitive.” I hope you can now see why this leads to better software engineering.</p>

<p>Idiomatic Go is a set of tools, practices, and patterns that makes it easier to maintain software across time and changing teams. That’s not to say the cultures around other languages don’t value maintainability; it just may not be their highest priority. Instead, they emphasize things like performance, new features, or concise syntax. There is a place for these trade-offs, but in the long run, I suspect Go’s focus on crafting software that lasts will win out. I wish you the best as you create the software for the next 50 years of computing.</p>
</div></section>
</div></section></div>
</div>
</body></html>