["```go\nexport ver=v1 && go test -run '^$' -bench '^BenchmarkSum$' \\\n    -benchtime 10s -count 5 -cpu 1 -benchmem \\\n    -cpuprofile=${ver}.cpu.pprof -memprofile=${ver}.mem.pprof | tee ${ver}.txt\n```", "```go\n// BenchmarkSum_fgprof recommended run options:\n// $ export ver=v1fg && go test -run '^$' -bench '^BenchmarkSum_fgprof' \\\n//    -benchtime 60s  -cpu 1 | tee ${ver}.txt ![1](assets/1.png)\nfunc BenchmarkSum_fgprof(b *testing.B) {\n    f, err := os.Create(\"fgprof.pprof\")\n    testutil.Ok(b, err)\n\n    defer func() { testutil.Ok(b, f.Close()) }()\n\n    closeFn := fgprof.Start(f, fgprof.FormatPprof)\n    BenchmarkSum(b) ![2](assets/2.png)\n    testutil.Ok(b, closeFn())\n}\n```", "```go\nfunc Sum2(fileName string) (ret int64, _ error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var last int ![1](assets/1.png)\n    for i := 0; i < len(b); i++ {\n        if b[i] != '\\n' { ![2](assets/2.png)\n            continue\n        }\n        num, err := strconv.ParseInt(string(b[last:i]), 10, 64)\n        if err != nil {\n            return 0, err\n        }\n\n        ret += num\n        last = i + 1\n    }\n    return ret, nil\n}\n```", "```go\n// import \"unsafe\"\n\nfunc zeroCopyToString(b []byte) string {\n    return *((*string)(unsafe.Pointer(&b))) ![1](assets/1.png)\n}\n\nfunc Sum3(fileName string) (ret int64, _ error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var last int\n    for i := 0; i < len(b); i++ {\n        if b[i] != '\\n' {\n            continue\n        }\n        num, err := strconv.ParseInt(zeroCopyToString(b[last:i]), 10, 64)\n        if err != nil {\n            return 0, err\n        }\n\n        ret += num\n        last = i + 1\n    }\n    return ret, nil\n}\n```", "```go\nfunc ParseInt(input []byte) (n int64, _ error) {\n    factor := int64(1)\n    k := 0\n\n    if input[0] == '-' {\n        factor *= -1\n        k++\n    }\n\n    for i := len(input) - 1; i >= k; i-- {\n        if input[i] < '0' || input[i] > '9' {\n           return 0, errors.Newf(\"not a valid integer: %v\", input)\n        }\n\n        n += factor * int64(input[i]-'0')\n        factor *= 10\n    }\n    return n, nil\n}\n\nfunc Sum4(fileName string) (ret int64, err error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var last int\n    for i := 0; i < len(b); i++ {\n        if b[i] != '\\n' {\n            continue\n        }\n        num, err := ParseInt(b[last:i])\n        if err != nil {\n            return 0, err\n        }\n\n        ret += num\n        last = i + 1\n    }\n    return ret, nil\n}\n```", "```go\n$ benchstat v1.txt v2.txt v3.txt v4.txt\nname \\ (time/op)  v1.txt       v2.txt       v3.txt       v4.txt\nSum                101ms ± 0%    50ms ± 2%   25ms ± 0%   14ms ± 0% ![1](assets/1.png) name \\ (alloc/op) v1.txt       v2.txt       v3.txt       v4.txt\nSum               60.8MB ± 0%  12.8MB ± 0%  7.2MB ± 0%  7.2MB ± 0%\n\nname \\ (allocs/op) v1.txt       v2.txt       v3.txt       v4.txt\nSum                1.60M ± 0%   1.60M ± 0%  0.00M ± 0%  0.00M ± 0%\n```", "```go\nfunc Sum5(fileName string) (ret int64, err error) {\n    f, err := os.Open(fileName) ![1](assets/1.png)\n    if err != nil {\n        return 0, err\n    }\n    defer errcapture.Do(&err, f.Close, \"close file\") ![2](assets/2.png)\n\n    scanner := bufio.NewScanner(f)\n    for scanner.Scan() { ![3](assets/3.png)\n        num, err := ParseInt(scanner.Bytes())\n        if err != nil {\n            return 0, err\n        }\n\n        ret += num\n    }\n    return ret, scanner.Err() ![4](assets/4.png)\n}\n```", "```go\nfunc Sum6(fileName string) (ret int64, err error) {\n    f, err := os.Open(fileName)\n    if err != nil {\n        return 0, err\n    }\n    defer errcapture.Do(&err, f.Close, \"close file\")\n\n    buf := make([]byte, 8*1024) ![1](assets/1.png)\n    return Sum6Reader(f, buf)\n}\n\nfunc Sum6Reader(r io.Reader, buf []byte) (ret int64, err error) { ![2](assets/2.png)\n    var offset, n int\n    for err != io.EOF {\n        n, err = r.Read(buf[offset:]) ![3](assets/3.png)\n        if err != nil && err != io.EOF { ![4](assets/4.png)\n            return 0, err\n        }\n        n += offset ![5](assets/5.png)\n\n        var last int\n        for i := range buf[:n] { ![6](assets/6.png)\n            if buf[i] != '\\n' {\n                continue\n            }\n            num, err := ParseInt(buf[last:i])\n            if err != nil {\n                return 0, err\n            }\n\n            ret += num\n            last = i + 1\n        }\n\n        offset = n - last\n        if offset > 0 {\n            _ = copy(buf, buf[last:n]) ![7](assets/7.png)\n        }\n    }\n    return ret, nil\n}\n```", "```go\n$ benchstat v1.txt v2.txt v3.txt v4.txt\nname \\ (time/op)   v4-10M.txt   v5-10M.txt    v6-10M.txt\nSum                67.8ms ± 3%  157.1ms ± 2%  69.4ms ± 1%\n\nname \\ (alloc/op) v4-10M.txt   v5-10M.txt    v6-10M.txt\nSum               36.0MB ± 0%    0.0MB ± 3%   0.0MB ± 0%\n\nname \\ (allocs/op)  v4-10M.txt   v5-10M.txt    v6-10M.txt\nSum                 5.00 ± 0%     4.00 ± 0%    4.00 ± 0%\n```", "```go\nfunc ConcurrentSum1(fileName string) (ret int64, _ error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var wg sync.WaitGroup\n    var last int\n    for i := 0; i < len(b); i++ {\n        if b[i] != '\\n' {\n            continue\n        }\n\n        wg.Add(1)\n        go func(line []byte) {\n            defer wg.Done()\n            num, err := ParseInt(line)\n            if err != nil {\n                // TODO(bwplotka): Return err using other channel.\n                return\n            }\n            atomic.AddInt64(&ret, num)\n        }(b[last:i])\n        last = i + 1\n    }\n    wg.Wait()\n    return ret, nil\n```", "```go\nfunc ConcurrentSum2(fileName string, workers int) (ret int64, _ error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var (\n        wg     = sync.WaitGroup{}\n        workCh = make(chan []byte, 10)\n    )\n\n    wg.Add(workers + 1)\n    go func() {\n        var last int\n        for i := 0; i < len(b); i++ {\n            if b[i] != '\\n' {\n                continue\n            }\n            workCh <- b[last:i]\n            last = i + 1\n      }\n        close(workCh) ![1](assets/1.png)\n        wg.Done()\n    }()\n\n    for i := 0; i < workers; i++ {\n        go func() {\n            var sum int64\n            for line := range workCh { ![2](assets/2.png)\n                num, err := ParseInt(line)\n                if err != nil {\n                    // TODO(bwplotka): Return err using other channel.\n                    continue\n                }\n                sum += num\n            }\n            atomic.AddInt64(&ret, sum)\n            wg.Done()\n        }()\n    }\n    wg.Wait()\n    return ret, nil\n}\n```", "```go\nfunc ConcurrentSum3(fileName string, workers int) (ret int64, _ error) {\n    b, err := os.ReadFile(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    var (\n        bytesPerWorker = len(b) / workers\n        resultCh       = make(chan int64)\n    )\n\n    for i := 0; i < workers; i++ {\n        go func(i int) {\n            // Coordination-free algorithm, which shards\n            // buffered file deterministically.\n            begin, end := shardedRange(i, bytesPerWorker, b) ![1](assets/1.png)\n\n            var sum int64\n            for last := begin; begin < end; begin++ {\n                if b[begin] != '\\n' {\n                    continue\n                }\n                num, err := ParseInt(b[last:begin])\n                if err != nil {\n                    // TODO(bwplotka): Return err using other channel.\n                    continue\n                }\n                sum += num\n                last = begin + 1\n            }\n            resultCh <- sum\n        }(i)\n    }\n\n    for i := 0; i < workers; i++ {\n        ret += <-resultCh\n    }\n    close(resultCh)\n    return ret, nil\n}\n```", "```go\nfunc ConcurrentSum4(fileName string, workers int) (ret int64, _ error) {\n    f, err := os.Open(fileName)\n    if err != nil {\n        return 0, err\n    }\n    defer errcapture.Do(&err, f.Close, \"close file\")\n\n    s, err := f.Stat()\n    if err != nil {\n        return 0, err\n    }\n\n    var (\n        size           = int(s.Size())\n        bytesPerWorker = size / workers\n        resultCh       = make(chan int64)\n    )\n\n    if bytesPerWorker < 10 {\n        return 0, errors.New(\"can't have less bytes per goroutine than 10\")\n    }\n\n    for i := 0; i < workers; i++ {\n        go func(i int) {\n            begin, end := shardedRangeFromReaderAt(i, bytesPerWorker, size, f)\n            r := io.NewSectionReader(f, int64(begin), int64(end-begin)) ![1](assets/1.png)\n\n            b := make([]byte, 8*1024)\n            sum, err := Sum6Reader(r, b) ![2](assets/2.png)\n            if err != nil {\n                // TODO(bwplotka): Return err using other channel.\n            }\n            resultCh <- sum\n        }(i)\n    }\n\n    for i := 0; i < workers; i++ {\n        ret += <-resultCh\n    }\n    close(resultCh)\n    return ret, nil\n}\n```", "```go\nname \\ (time/op)   v4-4core.txt  vc3.txt      vc4.txt\nSum-4              13.3ms ± 1%   6.9ms ± 6%   4.5ms ± 3%\n\nname \\ (alloc/op)  v4-4core.txt  vc3.txt      vc4.txt\nSum-4              7.20MB ± 0%   7.20MB ± 0%  0.03MB ± 0%\n```", "```go\nvar sumByFile = map[string]int64{} ![1](assets/1.png)\n\nfunc Sum7(fileName string) (int64, error) {\n    if s, ok := sumByFile[fileName]; ok {\n        return s, nil\n    }\n\n    ret, err := Sum(fileName)\n    if err != nil {\n        return 0, err\n    }\n\n    sumByFile[fileName] = ret\n    return ret, nil\n}\n```"]