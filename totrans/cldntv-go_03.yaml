- en: Chapter 2\. Why Go Rules the Cloud Native World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。为什么 Go 主导了云原生世界
- en: Any intelligent fool can make things bigger, more complex, and more violent.
    It takes a touch of genius—and a lot of courage—to move in the opposite direction.^([1](ch02.xhtml#idm45983645071000))
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何愚蠢的人都可以让事物变得更大、更复杂和更暴力。反其道而行之需要一些天才的触觉——以及大量的勇气。^([1](ch02.xhtml#idm45983645071000))
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: E.F. Schumacher, Small Is Beautiful (August 1973)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: E.F. 舒马赫，《小即美》（1973年8月）
- en: The Motivation Behind Go
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 语言背后的动机
- en: The idea of Go emerged in September of 2007 at Google, the inevitable outcome
    of putting a bunch of smart people in a room and frustrating the heck out of them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的理念始于2007年9月的谷歌，这不可避免地是将一群聪明人聚在一起并且让他们感到沮丧的结果。
- en: The people in question were Robert Griesemer, Rob Pike, and Ken Thompson; all
    already highly regarded for their individual work in designing other languages.
    The source of their collective ire was nothing less than the entire set of programming
    languages that were available at the time, which they were finding just weren’t
    well-suited to the task of describing the kinds of distributed, scalable, resilient
    services that Google was building.^([2](ch02.xhtml#idm45983651866712))
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有关人士是罗伯特·格里塞默、罗布·派克和肯·汤普森；他们三人因各自在设计其他语言方面的工作而广受赞誉。他们集体关注的焦点是当时可用的整套编程语言，他们发现这些语言并不适合描述谷歌正在构建的分布式、可扩展和弹性服务的任务。^([2](ch02.xhtml#idm45983651866712))
- en: Essentially, the common languages of the day had been developed in a different
    era, one before multiple processors were commonplace, and networks were quite
    so ubiquitous. Their support for multicore processing and networking—essential
    building blocks of modern “cloud native” services^([3](ch02.xhtml#idm45983651864088))—was
    often limited or required extraordinary efforts to utilize. Simply put, programming
    languages weren’t keeping up with the needs of modern software development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，当今普通的编程语言是在多处理器尚未普及、网络尚未如此普及的时代开发的。它们对多核处理和网络的支持——现代“云原生”服务的基本构建模块^([3](ch02.xhtml#idm45983651864088))——通常受到限制或需要非同寻常的努力来利用。简单来说，编程语言没有跟上现代软件开发的需求。
- en: Features for a Cloud Native World
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向云原生世界的特性
- en: 'Their frustrations were many, but all of them amounted to one thing: the undue
    complexity of the languages they were working with was making it harder to build
    server software. These included, but weren’t limited to:^([4](ch02.xhtml#idm45983651860872))'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的挫折很多，但所有这些挫折归结为一件事：他们正在使用的语言的不必要复杂性使得构建服务器软件变得更加困难。这些问题包括但不限于：^([4](ch02.xhtml#idm45983651860872))
- en: Low program comprehensibility
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的可理解性低
- en: Code had become too hard to read. Unnecessary bookkeeping and repetition was
    compounded by functionally overlapping features that often encouraged cleverness
    over clarity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得难以阅读。不必要的簿记和重复由功能重叠的特性加剧，这些特性往往鼓励聪明而不是清晰。
- en: Slow builds
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建速度慢
- en: Language construction and years of feature creep resulted in build times that
    ran for minutes or hours, even on large build clusters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的构建和多年的功能膨胀导致构建时间长达数分钟甚至数小时，即使在大型构建集群上也是如此。
- en: Inefficiency
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 效率低下
- en: Many programmers responded to the aforementioned problems by adopting more fluid,
    dynamic languages, effectively trading efficiency and type safety for expressiveness.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员对上述问题的反应是采用更灵活、动态的语言，有效地以表达能力换取效率和类型安全性。
- en: High cost of updates
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 更新成本高昂
- en: Incompatibilities between even minor versions of a language, as well as any
    dependencies it may have (and its transitive dependencies!) often made updating
    an exercise in frustration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至是语言的次要版本之间的不兼容性，以及它可能有的任何依赖项（及其传递依赖项！），经常使得更新成为一种令人沮丧的练习。
- en: Over the years, multiple—often quite clever—solutions have been presented to
    address some of these issues in various ways, usually introducing additional complexity
    in the process. Clearly, they couldn’t be fixed with a new API or language feature.
    So, Go’s designers envisioned a modern language, the first language built for
    the cloud native era, supporting modern networked and multicore computing, expressive
    yet comprehensible, and allowing its users to focus on solving their problems
    instead of struggling with their language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经提出了多种——通常相当巧妙的——解决方案来解决这些问题，通常在过程中引入了额外的复杂性。显然，这些问题不能仅通过新的 API 或语言特性来解决。因此，Go
    的设计师们设想了一种现代化的语言，这是第一种为云原生时代而构建的语言，支持现代网络化和多核计算，既富有表现力又易于理解，让用户能够专注于解决问题，而不是苦于语言的限制。
- en: The result, the Go language, is notable as much for the features it explicitly
    *doesn’t have* as it is for the ones it does. Some of those features (and nonfeatures)
    and the motivation behind them are discussed in the following sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的结果，与其具有的特性一样显著，还因其明确*不具备*的一些特性（和非特性）而闻名。这些特性（和非特性）及其背后的动机在以下章节中讨论。
- en: Composition and Structural Typing
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和结构化类型
- en: Object-oriented programming, which is based on the concept of “objects” of various
    “types” possessing various attributes, has existed since the 1960s, but it truly
    came into vogue in the early to mid-1990s with the release of Java and the addition
    of object-oriented features to C++. Since then, it has emerged as the dominant
    programming paradigm, and remains so even today.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪60年代以来，基于“对象”和各种“类型”拥有各种属性的面向对象编程就已存在，但真正流行起来是在20世纪90年代初至中期，随着Java的发布和向C++添加面向对象特性。从那时起，它已经成为主导的编程范式，甚至今天仍然如此。
- en: The promise of object-oriented programming is seductive, and the theory behind
    it even makes a certain kind of intuitive sense. Data and behaviors can be associated
    with *types* of things, which can be inherited by *subtypes* of those things.
    *Instances* of those types can be conceptualized as tangible objects with properties
    and behaviors—components of a larger system modeling concrete, real-world concepts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的吸引力是令人着迷的，其背后的理论甚至具有某种直观上的意义。数据和行为可以与事物的*类型*相关联，这些可以被*子类型*继承。这些类型的*实例*可以被概念化为具有属性和行为的有形对象——是一个更大系统建模具体的、现实世界的概念的组成部分。
- en: In practice however, objected-oriented programming using inheritance often requires
    that relationships between types be carefully considered and painstakingly designed,
    and that particular design patterns and practices be faithfully observed. As such,
    as illustrated in [Figure 2-1](#img_ch02_inheritance), the tendency in object-oriented
    programming is for the focus to shift away from developing algorithms, and towards
    developing and maintaining taxonomies and ontologies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，使用继承的面向对象编程通常要求认真考虑类型之间的关系并精心设计，并且必须忠实遵循特定的设计模式和实践。因此，正如在[图2-1](#img_ch02_inheritance)中所示，面向对象编程的趋势是将重点从开发算法转向开发和维护分类学和本体论。
- en: '![cngo 0201](Images/cngo_0201.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0201](Images/cngo_0201.png)'
- en: Figure 2-1\. Over time, objected-oriented programming trends towards taxonomy
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1。随着时间的推移，面向对象编程趋向于分类学
- en: 'That’s not to say that Go doesn’t have object-oriented features that allow
    polymorphic behavior and code reuse. It, too, has a type-like concept in the form
    of *structs*, which can have properties and behaviors. What it rejects is inheritance
    and the elaborate relationships that come with it, opting instead to assemble
    more complex types by *embedding* simpler ones within them: an approach known
    as *composition*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言并非不具备允许多态行为和代码重用的面向对象特性。它也有一种类似类型的概念，即*structs*，这些可以具有属性和行为。它所拒绝的是继承以及伴随其而来的复杂关系，而是选择通过*embedding*较简单的类型在其中来组装更复杂的类型：这种方法被称为*composition*。
- en: Specifically, where inheritance revolves around extending “is a” relationships
    between classes (i.e., a car “is a” motored vehicle), composition allows types
    to be constructed using “has a” relationships to define what they can do (i.e.,
    a car “has a” motor). In practice, this permits greater design flexibility while
    allowing the creation of business domains that are less susceptible to disruption
    by the quirks of “family members.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，继承围绕着在类之间扩展“is a”的关系（即，汽车“是一个”机动车），而组合允许使用“has a”关系构建类型，以定义它们可以做什么（即，汽车“有一个”发动机）。在实践中，这允许更大的设计灵活性，同时允许创建的业务域不太容易受到“家庭成员”特异性的干扰。
- en: 'By extension, while Go uses interfaces to describe behavioral contracts, it
    has no “is a” concept, so equivalency is determined by inspecting a type’s definition,
    not its lineage. For example, given a `Shape` interface that defines an `Area`
    method, any type with an `Area` method will implicitly satisfy the `Shape` interface,
    without having to explicitly declare itself as a `Shape`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，虽然Go使用接口来描述行为契约，但它没有“is a”概念，因此等价性是通过检查类型的定义而不是其血统来确定的。例如，给定一个定义了`Area`方法的`Shape`接口，任何具有`Area`方法的类型将隐式满足`Shape`接口，而无需显式声明自己为`Shape`：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This *structural typing* mechanism, which has been described as *duck typing*^([5](ch02.xhtml#idm45983645616360))
    at compile time, largely sheds the burdensome maintenance of tedious taxonomies
    that saddle more traditional object-oriented languages like Java and C++, freeing
    programmers to focus on data structures and algorithms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*结构化类型*机制，在编译时被描述为*鸭子类型*^([5](ch02.xhtml#idm45983645616360))，大大减少了繁琐的分类体系的维护，这些分类体系使得像Java和C++这样的更传统的面向对象语言负担过重，从而解放程序员专注于数据结构和算法。
- en: Comprehensibility
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可理解性
- en: Service languages like C++ and Java are often criticized for being clumsy, awkward
    to use, and unnecessarily verbose. They require lots of repetition and careful
    bookkeeping, saddling projects with superfluous boilerplate that gets in the way
    of programmers who have to divert their attention to things other than the problem
    they’re trying to solve, and limiting projects’ scalability under the weight of
    all the resulting complexity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像C++和Java这样的服务语言经常因笨拙、难以使用和冗长而受到批评。它们需要大量重复和仔细的账务记录，使得项目不得不背负冗余的样板代码，这些代码会妨碍程序员专注于解决问题以外的事务，并在所有结果复杂性的重压下限制项目的可扩展性。
- en: Go was designed with large projects with lots of contributors in mind. Its minimalist
    design (just 25 keywords and 1 loop type), and the strong opinions of its compiler,
    strongly favor clarity over cleverness.^([6](ch02.xhtml#idm45983651382280)) This
    in turn encourages simplicity and productivity over clutter and complexity. The
    resulting code is relatively easy to ingest, review, and maintain, and harbors
    far fewer “gotchas.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Go是为大型项目和众多贡献者设计的。其简约的设计（只有25个关键字和1种循环类型）以及其编译器的强烈观点，强烈倾向于清晰而非巧妙。^([6](ch02.xhtml#idm45983651382280))
    这反过来鼓励简单和高效率，而非混乱和复杂性。由此产生的代码相对容易消化、审查和维护，并且减少了“陷阱”。
- en: CSP-Style Concurrency
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSP风格的并发
- en: Most mainstream languages provide some means of running multiple processes concurrently,
    allowing a program to be composed of independently executed processes. Used correctly,
    concurrency can be incredibly useful, but it also introduces a number of challenges,
    particularly around ordering events, communication between processes, and coordination
    of access to shared resources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数主流语言提供了一些运行多个进程并发的方式，允许程序由独立执行的进程组成。正确使用并发可以非常有用，但它也引入了许多挑战，特别是关于事件排序、进程间通信和对共享资源访问的协调。
- en: Traditionally, a programmer will confront these challenges by allowing processes
    to share some piece of memory, which is then wrapped in locks or mutexes to restrict
    access to one process at a time. But even when well-implemented, this strategy
    can generate a fair amount of bookkeeping overhead. It’s also easy to forget to
    lock or unlock shared memory, potentially introducing race conditions, deadlocks,
    or concurrent modifications. This class of errors can be fiendishly difficult
    to debug.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，程序员通常通过允许进程共享一些内存来解决这些挑战，然后在此基础上用锁或互斥体包装以限制一次只能访问一个进程。但即使实施良好，这种策略也可能产生大量繁琐的账务开销。忘记锁定或解锁共享内存的可能性也很高，可能会引入竞态条件、死锁或并发修改。这类错误非常难以调试。
- en: Go, on the other hand, favors another strategy, based on a formal language called
    Communicating Sequential Processes (CSP), first described in Tony Hoare’s influential
    paper of the same name^([7](ch02.xhtml#idm45983647612392)) that describes patterns
    of interaction in concurrent systems in terms of message passing via channels.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Go语言更倾向于基于一个称为“通信顺序进程（CSP）”的正式语言的策略，这个策略首次由托尼·霍尔在同名的影响力论文中描述^([7](ch02.xhtml#idm45983647612392))，该论文描述了通过通道进行消息传递来表达并发系统中的交互模式。
- en: 'The resulting concurrency model, implemented in Go with language primitives
    like `goroutines` and `channels`, makes Go uniquely^([8](ch02.xhtml#idm45983651600136))
    capable of elegantly structuring concurrent software without depending entirely
    on locking. It encourages developers to limit sharing memory, and to instead allow
    processes to interact with one another *entirely* by passing messages. This idea
    is often summarized by the Go proverb:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过像`goroutines`和`channels`这样的语言原语实现的并发模型，使得Go能够优雅地构建并发软件，而不完全依赖于锁定。它鼓励开发者限制共享内存，而是允许进程完全通过传递消息来互动。这个理念通常由Go的谚语总结：
- en: Do not communicate by sharing memory. Instead, share memory by communicating.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要通过共享内存进行通信。相反，通过通信来共享内存。
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go Proverb
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Go谚语
- en: Fast Builds
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速构建
- en: One of the primary motivations for the Go language was the maddeningly long
    build times for certain languages of the time,^([10](ch02.xhtml#idm45983647604888))
    which even on Google’s large compilation clusters often require minutes, or even
    hours, to complete. This eats away at development time and grinds down developer
    productivity. Given Go’s primary purpose of enhancing rather than hindering developer
    productivity, long build times had to go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的主要动机之一是当时某些语言的令人发狂的长构建时间，（[10](ch02.xhtml#idm45983647604888)）即使在 Google
    的大型编译集群上，也常常需要数分钟甚至数小时才能完成。这大大消耗了开发时间，削弱了开发者的生产力。鉴于 Go 的主要目的是增强而非阻碍开发者的生产力，长时间的构建过程必须消失。
- en: 'The specifics of the Go compiler are beyond the scope of this book (and beyond
    my own expertise). Briefly, however, the Go language was designed to provide a
    model of software construction free of complex relationships, greatly simplifying
    dependency analysis and eliminating the need for C-style include files and libraries
    and the overhead that comes with them. As a result, most Go builds complete in
    seconds, or occasionally minutes, even on relatively humble hardware. For example,
    building all 1.8 million lines^([11](ch02.xhtml#idm45983647603016)) of Go in Kubernetes
    v1.20.2 on a MacBook Pro with a 2.4 GHz 8-Core Intel i9 processor and 32 GB of
    RAM required about 45 seconds of real time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围之外，Go 编译器的具体细节（以及我的专业知识之外）。然而，简而言之，Go 语言的设计旨在提供一个自由于复杂关系的软件构建模型，极大简化了依赖分析，并消除了
    C 风格的包含文件和库以及伴随其而来的开销。因此，即使在相对较低性能的硬件上，如 MacBook Pro，使用 2.4 GHz 8 核 Intel i9 处理器和
    32 GB RAM，在 Kubernetes v1.20.2 上构建所有 180 万行 Go 代码也只需约 45 秒真实时间：（[11](ch02.xhtml#idm45983647603016)）
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Not that this doesn’t come without compromises. Any proposed change to the Go
    language is weighed in part against its likely effect on build times; some otherwise
    promising proposals have been rejected on the grounds that they would increase
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并非没有妥协。对 Go 语言的任何建议性改动都在一定程度上考虑其对构建时间的可能影响；一些原本有前途的提案因增加构建时间而被拒绝。
- en: Linguistic Stability
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语言稳定性
- en: Go 1 was released in March of 2012, defining both the specification of the language
    and the specification of a set of core APIs. The natural consequence of this is
    an explicit promise, from the Go design team to the Go users, that programs written
    in Go 1 will continue to compile and run correctly, unchanged, for the lifetime
    of the Go 1 specification. That is, Go programs that work today can be expected
    to continue to work even under future “point” releases of Go 1 (Go 1.1, Go 1.2,
    etc.).^([12](ch02.xhtml#idm45983647594312))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1 于 2012 年 3 月发布，定义了语言规范和一组核心 API 的规范。这自然导致了 Go 设计团队对 Go 1 用户的明确承诺，即使用 Go
    1 编写的程序将在整个 Go 1 规范的生命周期内继续编译和正确运行，无需修改。也就是说，今天能工作的 Go 程序可以预期在未来的“点”版本（如 Go 1.1、Go
    1.2 等）中仍然能够工作。（[12](ch02.xhtml#idm45983647594312)）
- en: This stands in stark contrast to many other languages, which sometimes add new
    features enthusiastically, gradually increasing the complexity of the language—and
    anything written in it—in time, leading to a once elegant language becoming a
    sprawling featurescape that’s often exceedingly difficult to master.^([13](ch02.xhtml#idm45983647591464))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这与许多其他语言形成鲜明对比，后者有时会热情地添加新功能，逐渐增加语言和其中任何写入的复杂性，最终导致一度优雅的语言变成一个庞大的功能景观，往往难以掌握。（[13](ch02.xhtml#idm45983647591464)）
- en: The Go Team considers this exceptional level of linguistic stability to be a
    vital feature of Go; it allows users to trust Go and to build on it. It allows
    libraries to be consumed and built upon with minimal hassle, and dramatically
    lowers the cost of updates, particularly for large projects and organizations.
    Importantly, it also allows the Go community to use Go and to learn from it; to
    spend time writing with the language rather than writing the language.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go 团队认为这种卓越的语言稳定性是 Go 的重要特性；它使用户能够信任 Go 并在其基础上构建。它允许库被轻松消费和构建，并显著降低了更新成本，尤其是对于大型项目和组织而言。重要的是，它还允许
    Go 社区使用 Go 并从中学习；花时间用这种语言写作，而不是写这种语言。
- en: 'This is not to say that Go won’t grow: both the APIs and the core language
    certainly *can* acquire new packages and features,^([14](ch02.xhtml#idm45983647588664))
    and there are many proposals for exactly that,^([15](ch02.xhtml#idm45983647587976))
    but not in a way that breaks existing Go 1 code.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着 Go 不会发展壮大：API 和核心语言肯定*可以*获取新的包和功能^([14](ch02.xhtml#idm45983647588664))，而且确实有许多关于此的提案^([15](ch02.xhtml#idm45983647587976))，但不会以破坏现有
    Go 1 代码的方式。
- en: That being said, it’s quite possible^([16](ch02.xhtml#idm45983647584664)) that
    there will actually *never* be a Go 2\. More likely, Go 1 will continue to be
    compatible indefinitely; and in the unlikely event that a breaking change is introduced,
    Go will provide a conversion utility, like the `go fix` command that was used
    during the move to Go 1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，很可能^([16](ch02.xhtml#idm45983647584664))实际上*永远*不会有 Go 2。更有可能的是，Go 1 将持续无限期兼容；并且在引入破坏性变更的不太可能事件中，Go
    将提供一个转换实用程序，就像在转向 Go 1 时使用的 `go fix` 命令一样。
- en: Memory Safety
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存安全
- en: The designers of Go have taken great pains to ensure that the language is free
    of the various bugs and security vulnerabilities—not to mention tedious bookkeeping—associated
    with direct memory access. Pointers are strictly typed and are always initialized
    to some value (even if that value is `nil`), and pointer arithmetic is explicitly
    disallowed. Built-in reference types like maps and channels, which are represented
    internally as pointers to mutable structures, are initialized by the `make` function.
    Simply put, Go neither needs nor allows the kind of manual memory management and
    manipulation that lower-level languages like C and C++ allow and require, and
    the subsequent gains with respect to complexity and memory safety can’t be overstated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的设计者们非常努力地确保这门语言不受直接内存访问带来的各种错误和安全漏洞（更不用说繁琐的簿记了）。指针是严格类型化的，并且总是初始化为某个值（即使该值是
    `nil`），指针算术明确禁止。内置的引用类型如映射和通道，内部表示为指向可变结构的指针，由 `make` 函数初始化。简而言之，Go 既不需要也不允许像
    C 和 C++ 那样的手动内存管理和操作，这些对于复杂性和内存安全的后果不可低估。
- en: For the programmer, the fact that Go is a garbage-collected language obviates
    the need to carefully track and free up memory for every allocated byte, eliminating
    a considerable bookkeeping burden from the programmer’s shoulders. Life without
    `malloc` is liberating.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，Go 是一种具有垃圾收集功能的语言，这消除了需要为每个分配的字节仔细跟踪和释放内存的需求，减轻了程序员的很大负担。没有 `malloc`
    的生活是自由的。
- en: What’s more, by eliminating manual memory management and manipulation—even pointer
    arithmetic—Go’s designers have made it effectively immune to an entire class of
    memory errors and the security holes they can introduce. No memory leaks, no buffer
    overruns, no address space layout randomization. Nothing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，通过消除手动内存管理和操作——甚至是指针算术——Go 的设计者们使其有效地免疫了一整类内存错误和它们可能引入的安全漏洞。没有内存泄漏，没有缓冲区溢出，没有地址空间布局随机化。什么都没有。
- en: Of course, this simplicity and ease of development comes with some tradeoffs,
    and while Go’s garbage collector is incredibly sophisticated, it does introduce
    some overhead. As such, Go can’t compete with languages like C++ and Rust in pure
    raw execution speed. That said, as we see in the next section, Go still does pretty
    well for itself in that arena.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种简单和开发便利性是有一些折衷的，虽然 Go 的垃圾收集器非常复杂，但也带来了一些开销。因此，Go 在纯粹的原始执行速度上无法与 C++ 和 Rust
    等语言竞争。尽管如此，正如我们在下一节看到的，Go 在这个领域仍然表现出色。
- en: Performance
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Confronted with the slow builds and tedious bookkeeping of the statically typed,
    compiled languages like C++ and Java, many programmers moved towards more dynamic,
    fluid languages like Python. While these languages are excellent for many things,
    they’re also very inefficient relative to compiled languages like Go, C++, and
    Java.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 面对像 C++ 和 Java 这样静态类型的编译语言的缓慢构建和繁琐的簿记，许多程序员转向更动态、更流畅的语言，如 Python。虽然这些语言在许多方面表现出色，但相对于
    Go、C++ 和 Java 等编译语言来说，它们的效率也很低。
- en: Some of this is made quite clear in the benchmarks of [Table 2-1](#table_ch02_benchmarks).
    Of course, benchmarks in general should be taken with a grain of salt, but some
    results are particularly striking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 [表 2-1](#table_ch02_benchmarks) 的基准测试中已经很明显。当然，总体而言，基准测试应该带着一颗谨慎的心看待，但有些结果确实非常引人注目。
- en: Table 2-1\. Relative benchmarks for common service languages (seconds)^([a](ch02.xhtml#idm45983647562936))
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 常见服务语言的相对基准（秒）^([a](ch02.xhtml#idm45983647562936))
- en: '|  | C++ | Go | Java | NodeJS | Python3 | Ruby | Rust |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  | C++ | Go | Java | NodeJS | Python3 | Ruby | Rust |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Fannkuch-Redux** | `8.08` | `8.28` | `11.00` | `11.89` | `367.49` | `1255.50`
    | `7.28` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **Fannkuch-Redux** | `8.08` | `8.28` | `11.00` | `11.89` | `367.49` | `1255.50`
    | `7.28` |'
- en: '| **FASTA** | `0.78` | `1.20` | `1.20` | `2.02` | `39.10` | `31.29` | `0.74`
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **FASTA** | `0.78` | `1.20` | `1.20` | `2.02` | `39.10` | `31.29` | `0.74`
    |'
- en: '| **K-Nucleotide** | `1.95` | `8.29` | `5.00` | `15.48` | `46.37` | `72.19`
    | `2.76` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **K-核苷酸** | `1.95` | `8.29` | `5.00` | `15.48` | `46.37` | `72.19` | `2.76`
    |'
- en: '| **Mandlebrot** | `0.84` | `3.75` | `4.11` | `4.03` | `172.58` | `259.25`
    | `0.93` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **曼德布罗特集** | `0.84` | `3.75` | `4.11` | `4.03` | `172.58` | `259.25` | `0.93`
    |'
- en: '| **N-Body** | `4.09` | `6.38` | `6.75` | `8.36` | `586.17` | `253.50` | `3.31`
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **N-体问题** | `4.09` | `6.38` | `6.75` | `8.36` | `586.17` | `253.50` | `3.31`
    |'
- en: '| **Spectral norm** | `0.72` | `1.43` | `4.09` | `1.84` | `118.40` | `113.92`
    | `0.71` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **谱范数** | `0.72` | `1.43` | `4.09` | `1.84` | `118.40` | `113.92` | `0.71`
    |'
- en: '| ^([a](ch02.xhtml#idm45983647562936-marker)) Gouy, Isaac. The Computer Language
    Benchmarks Game. 18 Jan. 2021\. [*https://oreil.ly/bQFjc*](https://oreil.ly/bQFjc).
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.xhtml#idm45983647562936-marker)) 戈伊，艾萨克。计算机语言基准测试游戏。2021 年 1 月
    18 日。[*https://oreil.ly/bQFjc*](https://oreil.ly/bQFjc)。 |'
- en: 'On inspection, it seems that the results can be clustered into three categories
    corresponding with the types of languages used to generate them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查过程中，似乎可以将结果分为三类，分别对应生成它们所使用的语言类型：
- en: Compiled, strictly typed languages with manual memory management (C++, Rust)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译型、严格类型检查且手动内存管理（C++、Rust）
- en: Compiled, strictly typed languages with garbage collection (Go, Java)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译型、严格类型检查且具有垃圾回收（Go、Java）
- en: Interpreted, dynamically typed languages (Python, Ruby)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释型、动态类型语言（Python、Ruby）
- en: These results suggest that, while the garbage-collected languages are generally
    slightly less performant than the ones with manual memory management, the differences
    don’t appear to be great enough to matter except under the most demanding requirements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，尽管带有垃圾回收的语言通常比手动内存管理的语言稍慢，但这些差异似乎不足以在除了最苛刻的需求之外造成影响。
- en: The differences between the interpreted and compiled languages, however, is
    striking. At least in these examples, Python, the archetypical dynamic language,
    benchmarks about *ten to one hundred times slower* than most compiled languages.
    Of course, it can be argued that this is still perfectly adequate for many—if
    not most—purposes, but this is less true for cloud native applications, which
    often have to endure significant spikes in demand, ideally without having to rely
    on potentially costly upscaling.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，解释型和编译型语言之间的差异是显著的。至少在这些例子中，Python，这种典型的动态语言，基准测试速度约为*编译型语言的十到一百倍慢*。当然，可以争论说这对许多——如果不是大多数——用途来说仍然完全足够，但对于云原生应用程序来说则不是这样，这些应用程序经常需要在不依赖潜在昂贵的升级的情况下忍受需求的显著波动。
- en: Static Linking
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态链接
- en: By default, Go programs are compiled directly into native, statically linked
    executable binaries into which all necessary Go libraries and the Go runtime are
    copied. This produces slightly larger files (on the order of about 2MB for a “hello
    world”), but the resulting binary has no external language runtime to install,^([17](ch02.xhtml#idm45983647493096))
    or external library dependencies to upgrade or conflict,^([18](ch02.xhtml#idm45983647492440))
    and can be easily distributed to users or deployed to a host without fear of suffering
    dependency or environmental conflicts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 程序直接编译成本地、静态链接的可执行二进制文件，其中包括所有必需的 Go 库和 Go 运行时。这会产生稍大一些的文件（大约对于一个“hello
    world”来说是 2MB 左右），但生成的二进制文件没有外部语言运行时需要安装，^([17](ch02.xhtml#idm45983647493096))
    或者外部库依赖需要升级或冲突，^([18](ch02.xhtml#idm45983647492440)) 可以轻松地分发给用户或部署到主机，而不用担心依赖性或环境冲突。
- en: This ability is particularly useful when you’re working with containers. Because
    Go binaries don’t require an external language runtime or even a distribution,
    they can be built into “scratch” images that don’t have parent images. The result
    is a very small (single digit MB) image with minimal deployment latency and data
    transfer overhead. These are very useful traits in an orchestration system like
    Kubernetes that may need to pull the image with some regularity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用容器时，这种能力特别有用。因为 Go 二进制文件不需要外部语言运行时甚至不需要分发，它们可以被构建成“空白”镜像，这些镜像没有父镜像。结果是一个非常小（仅几兆字节）的镜像，具有最小的部署延迟和数据传输开销。这些特点在像
    Kubernetes 这样的编排系统中非常有用，这些系统可能需要定期获取镜像。
- en: Static Typing
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类型
- en: 'Back in the early days of Go’s design, its authors had to make a choice: would
    it be *statically typed*, like C++ or Java, requiring variables to be explicitly
    defined before use, or *dynamically typed*, like Python, allowing programmers
    to assign values to variables without defining them and therefore generally faster
    to code? It wasn’t a particularly hard decision; it didn’t take very long. Static
    typing was the obvious choice, but it wasn’t arbitrary, or based on personal preference.^([19](ch02.xhtml#idm45983647482936))'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go设计的早期阶段，其作者们不得不做出选择：是否要像C++或Java那样*静态类型*，需要在使用之前明确定义变量，或者像Python那样*动态类型*，允许程序员在不定义变量的情况下为其赋值，因此编码速度通常更快？这并不是一个特别困难的决定；也没花多少时间。静态类型显然是明智的选择，但并不是任意的或基于个人偏好。^([19](ch02.xhtml#idm45983647482936))
- en: First, type correctness for statically typed languages can be evaluated at compile
    time, making them far more performant (see [Table 2-1](#table_ch02_benchmarks)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，静态类型语言的类型正确性可以在编译时评估，使其更加高效（见[表2-1](#table_ch02_benchmarks)）。
- en: The designers of Go understood that the time spent in development is only a
    fraction of a project’s total lifecycle, and that any gains in coding velocity
    with dynamically typed languages is more than made up for by the increased difficulty
    in debugging and maintaining such code. After all, what Python programmer hasn’t
    had their code crash because they tried to use a string as an integer?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Go的设计者们明白，开发中花费的时间仅仅是项目总生命周期的一小部分，而在动态类型语言中提高编码速度的任何收益都被调试和维护这类代码的难度所弥补。毕竟，有哪个Python程序员没有因为试图将字符串用作整数而使其代码崩溃？
- en: 'Take the following Python code snippet, for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，看看以下Python代码片段：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See it yet? Keep trying if you don’t. It can take a second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？如果你还没看到，请继续尝试。这可能需要一秒钟。
- en: Any programmer can make this kind of subtle misspelling error, which just so
    happens to also produce perfectly valid, executable Python. These are just two
    trivial examples of an entire class of errors that Go will catch at compile time
    rather than (heaven forbid) in production, and generally closer in the code to
    the location where they are introduced. After all, it’s well-understood that the
    earlier in the development cycle you catch a bug, the easier (read cheaper) it
    is to fix it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序员都可能犯这种微妙的拼写错误，这种错误恰好也能生成完全有效的可执行Python代码。这只是Go将在编译时捕获的整个错误类别中的两个微不足道的示例，而不是（天啊）在生产中，通常更接近引入它们的位置。毕竟，众所周知，在开发周期的早期捕获错误，修复起来更容易（更便宜）。
- en: 'Finally, I’ll even assert something somewhat controversial: typed languages
    are more readable. Python is often lauded as especially readable with its forgiving
    nature and somewhat English-like syntax,^([20](ch02.xhtml#idm45983647617624))
    but what would you do if presented with the following Python function signature?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我甚至会断言一些有些争议的事情：类型语言更易读。Python通常被誉为尤其易读，因其宽容的特性和略带英语风格的语法，^([20](ch02.xhtml#idm45983647617624))但如果给你看到以下Python函数签名，你会怎么做呢？
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Is `message` a string? Is `recipient` an instance of some class described elsewhere?
    Yes, this could be improved with some documentation and a couple of reasonable
    defaults, but many of us have had to maintain enough code to know that that’s
    a pretty distant star to wish on. Explicitly defined types can guide development
    and ease the mental burden of writing code by automatically tracking information
    the programmer would otherwise have to track mentally by serving as documentation
    for both the programmer and everybody who has to maintain their code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`是一个字符串吗？`recipient`是在其他地方描述的某个类的实例吗？是的，这可以通过一些文档和一些合理的默认值来改进，但我们中的许多人都必须维护足够的代码，以知道这是一个相当遥远的愿望。显式定义的类型可以通过自动跟踪信息来引导开发，并减轻编写代码的心理负担，否则程序员将不得不通过为程序员和所有必须维护其代码的人提供文档来手动跟踪。'
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: If [Chapter 1](ch01.xhtml#chapter_1) focused on what makes a *system* cloud
    native, then this chapter can be said to have focused on what makes a *language*,
    specifically Go, a good fit for building cloud native services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[第1章](ch01.xhtml#chapter_1)专注于什么使得*系统*云原生，那么这一章可以说是专注于什么使得*语言*，特别是Go，成为构建云原生服务的良好选择。
- en: However, while a cloud native system needs to be scalable, loosely coupled,
    resilient, manageable, and observable, a language for the cloud native era has
    to be able to do more than just build systems with those attributes. After all,
    with a bit of effort, pretty much any language can, technically, be used to build
    such systems. So what makes Go so special?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管云原生系统需要具备可伸缩性、松耦合性、弹性、可管理性和可观察性，一个面向云原生时代的语言必须能够做到不仅仅是构建具备这些特性的系统。毕竟，几乎任何语言在技术上都可以被用来构建这样的系统。那么是什么使得
    Go 如此特别呢？
- en: It can be argued that all of the features presented in this chapter directly
    or indirectly contribute to the cloud native attributes from the previous chapter.
    Concurrency and memory safety can be said to contribute to service scalability,
    and structural typing to allow loose coupling, for example. But while Go is the
    only mainstream language I know that puts all of these features in one place,
    are they *really* so novel?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，本章介绍的所有特性直接或间接地促进了前一章关于云原生特性的讨论。例如，并发性和内存安全性可以说有助于服务的可伸缩性，结构化类型允许松耦合，等等。但虽然
    Go 是我所知道的唯一一个将所有这些特性集于一身的主流语言，它们是否真的那么新颖呢？
- en: Perhaps most conspicuous of Go’s features are its baked-in—not bolted-on—concurrency
    features, which allow a programmer to fully and more safely utilize modern networking
    and multicore hardware. Goroutines and channels are wondrous, of course, and make
    it far easier to build resilient, highly concurrent networked services, but they’re
    technically not unique if you consider some less common languages like Clojure
    or Crystal.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可能 Go 最引人注目的特性之一是其内置而非外挂的并发功能，这使得程序员能够更充分、更安全地利用现代网络和多核硬件。当然，Goroutines 和 channels
    非常奇妙，使得构建具有弹性、高并发网络服务变得更加容易，但从技术上讲，如果考虑到像 Clojure 或 Crystal 这样不那么常见的语言，它们并非独一无二。
- en: I would assert that where Go really shines is in its faithful adherence to the
    principle of clarity over cleverness, which extends from an understanding that
    source code is written by humans for other humans.^([21](ch02.xhtml#idm45983647387240))
    That it compiles into machine code is almost immaterial.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 Go 真正优秀的地方在于其忠实地坚持清晰胜于聪明的原则，这一理念源于对于源代码是由人类为其他人类编写的的理解。^([21](ch02.xhtml#idm45983647387240))
    它能编译成机器码几乎是无关紧要。
- en: 'Go is designed to support the way people actually work together: in teams,
    which sometimes change membership, whose members also work on other things. In
    this environment, code clarity, the minimization of “tribal knowledge,” and the
    ability to rapidly iterate are critical. Go’s simplicity is often misunderstood
    and unappreciated, but it lets programmers focus on solving problems instead of
    struggling with the language.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的设计是为了支持人们实际上的工作方式：团队协作，有时团队成员会变动，并且这些成员还可能同时从事其他工作。在这种环境下，代码的清晰度、“部落知识”的最小化以及快速迭代的能力是至关重要的。Go
    的简洁性经常被误解和未被重视，但它使得程序员可以专注于解决问题，而不是与语言斗争。
- en: In [Chapter 3](ch03.xhtml#chapter_3), we’ll review many of the specific features
    of the Go language, where we’ll get to see that simplicity up close.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.xhtml#chapter_3)中，我们将详细回顾 Go 语言的许多具体特性，从而近距离地看到这种简单性。
- en: ^([1](ch02.xhtml#idm45983645071000-marker)) Schumacher, E.F. “Small Is Beautiful.”
    *The Radical Humanist*, August 1973, p. 22.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45983645071000-marker)) Schumacher, E.F. “Small Is Beautiful.”
    *The Radical Humanist*, 1973 年 8 月, p. 22.
- en: ^([2](ch02.xhtml#idm45983651866712-marker)) These were “cloud native” services
    before the term “cloud native” was coined.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45983651866712-marker)) 在“云原生”这个术语被创造出来之前，这些已经是“云原生”服务了。
- en: ^([3](ch02.xhtml#idm45983651864088-marker)) Of course, they weren’t called “cloud
    native” at the time; to Google they were just “services.”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45983651864088-marker)) 当然，在当时它们并不被称为“云原生”，对于 Google 而言它们只是“服务”。
- en: '^([4](ch02.xhtml#idm45983651860872-marker)) Pike, Rob. “Go at Google: Language
    Design in the Service of Software Engineering.” Google, Inc., 2012\. [*https://oreil.ly/6V9T1*](https://oreil.ly/6V9T1).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45983651860872-marker)) Pike, Rob. “Google 内部的 Go 语言设计与软件工程.”
    Google, Inc., 2012\. [*https://oreil.ly/6V9T1*](https://oreil.ly/6V9T1).
- en: ^([5](ch02.xhtml#idm45983645616360-marker)) In languages that use duck typing,
    the type of an object is less important than the methods it defines. In other
    words, “if it walks like a duck and it quacks like a duck, then it must be a duck.”
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45983645616360-marker)) 在使用鸭子类型的语言中，对象的类型不如其定义的方法重要。换句话说，“如果它像鸭子一样走路和嘎嘎叫，那么它一定是鸭子。”
- en: ^([6](ch02.xhtml#idm45983651382280-marker)) Cheney, Dave. “Clear Is Better than
    Clever.” *The Acme of Foolishness*, 19 July 2019\. [*https://oreil.ly/vJs0X*](https://oreil.ly/vJs0X).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45983651382280-marker)) Cheney, Dave. “清晰胜于巧妙。” *The Acme
    of Foolishness*, 2019年7月19日。[*https://oreil.ly/vJs0X*](https://oreil.ly/vJs0X).
- en: ^([7](ch02.xhtml#idm45983647612392-marker)) Hoare, C.A.R. “Communicating Sequential
    Processes.” *Communications of the ACM*, vol. 21, no. 8, Aug. 1978, pp. 666–77\.
    [*https://oreil.ly/CHiLt*](https://oreil.ly/CHiLt).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45983647612392-marker)) Hoare, C.A.R. “通信顺序进程。” *Communications
    of the ACM*, vol. 21, no. 8, 1978年8月, pp. 666–77。[*https://oreil.ly/CHiLt*](https://oreil.ly/CHiLt).
- en: ^([8](ch02.xhtml#idm45983651600136-marker)) At least among the “mainstream”
    languages, whatever that means.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#idm45983651600136-marker)) 至少在“主流”语言中，无论这是什么意思。
- en: ^([9](ch02.xhtml#idm45983651594184-marker)) Gerrand, Andrew. “Concurrency Is
    Not Parallelism.” *The Go Blog*, 16 Jan. 2016\. [*https://oreil.ly/WXf4g*](https://oreil.ly/WXf4g).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.xhtml#idm45983651594184-marker)) Gerrand, Andrew. “并发不等于并行。” *Go
    Blog*, 2016年1月16日。[*https://oreil.ly/WXf4g*](https://oreil.ly/WXf4g).
- en: ^([10](ch02.xhtml#idm45983647604888-marker)) C++. We’re talking about C++.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.xhtml#idm45983647604888-marker)) C++。我们在讨论 C++。
- en: ^([11](ch02.xhtml#idm45983647603016-marker)) Not counting comments; Openhub.net.
    “Kubernetes.” *Open Hub*, Black Duck Software, Inc., 18 Jan. 2021\. [*https://oreil.ly/y5Rty*](https://oreil.ly/y5Rty).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.xhtml#idm45983647603016-marker)) 不包括注释；Openhub.net. “Kubernetes.”
    *Open Hub*, Black Duck Software, Inc., 2021年1月18日。[*https://oreil.ly/y5Rty*](https://oreil.ly/y5Rty).
- en: ^([12](ch02.xhtml#idm45983647594312-marker)) The Go Team. “Go 1 and the Future
    of Go Programs.” *The Go Documentation*. [*https://oreil.ly/Mqn0I*](https://oreil.ly/Mqn0I).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch02.xhtml#idm45983647594312-marker)) Go Team. “Go 1 及 Go 程序的未来。” *Go
    Documentation*. [*https://oreil.ly/Mqn0I*](https://oreil.ly/Mqn0I).
- en: ^([13](ch02.xhtml#idm45983647591464-marker)) Anybody remember Java 1.1? I remember
    Java 1.1\. Sure, we didn’t have generics or autoboxing or enhanced `for` loops
    back then, but we were happy. Happy, I tell you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch02.xhtml#idm45983647591464-marker)) 还记得 Java 1.1 吗？我记得 Java 1.1。当时虽然没有泛型、自动装箱或增强的`for`循环，但我们很开心。是的，我告诉你，很开心。
- en: ^([14](ch02.xhtml#idm45983647588664-marker)) I’m on team generics. Go, fightin’
    Parametric Polymorphics!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch02.xhtml#idm45983647588664-marker)) 我支持泛型团队。加油，参数化多态！
- en: ^([15](ch02.xhtml#idm45983647587976-marker)) The Go Team. “Proposing Changes
    to Go.” *GitHub*, 7 Aug. 2019\. [*https://oreil.ly/folYF*](https://oreil.ly/folYF).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch02.xhtml#idm45983647587976-marker)) Go Team. “Go 提议变更。” *GitHub*, 2019年8月7日。[*https://oreil.ly/folYF*](https://oreil.ly/folYF).
- en: ^([16](ch02.xhtml#idm45983647584664-marker)) Pike, Rob. “Sydney Golang Meetup—Rob
    Pike—Go 2 Draft Specifications” (video). *YouTube*, 13 Nov. 2018\. [*https://oreil.ly/YmMAd*](https://oreil.ly/YmMAd).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch02.xhtml#idm45983647584664-marker)) Pike, Rob. “悉尼 Golang Meetup—Rob
    Pike—Go 2 草案规范”（视频）。 *YouTube*, 2018年11月13日。[*https://oreil.ly/YmMAd*](https://oreil.ly/YmMAd).
- en: ^([17](ch02.xhtml#idm45983647493096-marker)) Take that, Java.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch02.xhtml#idm45983647493096-marker)) 没法和 Java 比。
- en: ^([18](ch02.xhtml#idm45983647492440-marker)) Take that, Python.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch02.xhtml#idm45983647492440-marker)) 没法和 Python 比。
- en: ^([19](ch02.xhtml#idm45983647482936-marker)) Few arguments in programming generate
    as many snarky comments as Static versus Dynamic typing, except perhaps the Great
    Tabs versus Spaces Debate, on which Go’s unofficial position is “shut up, who
    cares?”
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch02.xhtml#idm45983647482936-marker)) 在编程中，很少有像静态与动态类型、或者伟大的制表符与空格辩论一样引发讽刺评论的争论，对于这些，Go
    的非官方立场是“闭嘴，谁在乎？”
- en: ^([20](ch02.xhtml#idm45983647617624-marker)) I, too, have been lauded for my
    forgiving nature and somewhat English-like syntax.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch02.xhtml#idm45983647617624-marker)) 我也因宽容的天性和有些像英语的语法而受到赞扬。
- en: ^([21](ch02.xhtml#idm45983647387240-marker)) Or for the same human after a few
    months of thinking about other things.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch02.xhtml#idm45983647387240-marker)) 或者在同一个人几个月思考其他事情后。
