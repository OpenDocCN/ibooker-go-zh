<html><head></head><body><section data-pdf-bookmark="Chapter 4. How Go Uses the CPU Resource (or Two)" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch-hardware">&#13;
<h1><span class="label">Chapter 4. </span>How Go Uses the CPU Resource (or Two)</h1>&#13;
&#13;
<blockquote><p>One of the most useful abstractions we can make is to treat properties of our hardware and infrastructure systems as resources. CPU, memory, data storage, and the network are similar to resources in the natural world: they are finite, they are physical objects in the real world, and they must be distributed and shared between various key players in the ecosystem.</p><p data-type="attribution">Susan J. Fowler, <a href="https://oreil.ly/8xO1v"><i>Production-Ready Microservices</i></a> (O’Reilly, 2016)</p></blockquote>&#13;
&#13;
<p>As<a data-primary="CPU resource" data-type="indexterm" id="ix_ch04-asciidoc0"/><a data-primary="Fowler, Susan J., on resources" data-type="indexterm" id="idm45606836123744"/> you learned in <a data-type="xref" href="ch01.html#ch-eff-s-performance">“Behind Performance”</a>, software efficiency depends on how our program uses the hardware resources. If the same functionality uses fewer resources, our efficiency increases and the requirements and net cost of running such a program decrease. For example, if we use less CPU time (CPU “resource”) or fewer resources with slower access time (e.g., disk), we usually reduce the latency of our software.</p>&#13;
&#13;
<p>This might sound simple, but in modern computers, these resources interact with each other in a complex, nontrivial way. Furthermore, more than one process is using these resources, so our program does not use them directly. Instead, these resources are managed for us by an operating system. If that wasn’t complex enough, especially in cloud environments, we often “virtualize” the hardware further so it can be shared across many individual systems in an isolated way. That means there are methods for “hosts” to give access to part of a single CPU or disk to a “guest” operating system that thinks it’s all the hardware that exists. In the end, operating systems and virtualization mechanisms create layers between our program and the actual physical devices that store or compute our data.</p>&#13;
&#13;
<p>To understand how to write efficient code or improve our program’s efficiency effectively, we have to learn the characteristics, purpose, and limits of the typical computer resources like CPU, different types of storage, and network. There is no shortcut here. Furthermore, we can’t ignore understanding how these physical components are managed by the operating system and typical virtualization layers.</p>&#13;
&#13;
<p>In this chapter, we will examine our program execution from the point of view of the CPU. We will discuss how Go uses CPUs for single and multiple core tasking.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>We won’t discuss all types of computer architectures with all mechanisms of all existing operating systems, as this would be impossible to fit in one book, never mind one chapter. So instead, this chapter will focus on a typical x86-64 CPU architecture with Intel or AMD, ARM CPUs, and the modern Linux operating system. This should get you started and give you a jumping-off point if you ever run your program on other, unique types of hardware or operating systems.</p>&#13;
</div>&#13;
&#13;
<p>We will start with exploring CPU in a modern computer architecture to understand how modern computers are designed, mainly focusing on the CPU, or processor. Then I will introduce the Assembly language, which will help us understand how the CPU core executes instructions. After that, we will dig into the Go compiler to build awareness of what happens when we do a <code>go build</code>. Furthermore, we will jump into the CPU and memory wall problem, showing you why modern CPU hardware is complex. This problem directly impacts writing efficient code on these ultracritical paths. Finally, we will enter the realm of multitasking by explaining how the operating system scheduler tries to distribute thousands of executing programs on outnumbered CPU cores and how the Go runtime scheduler leverages that to implement an efficient concurrency framework for us to use. We will finish with the summary on when to use concurrency.</p>&#13;
<div data-type="tip"><h1>Mechanical Sympathy</h1>&#13;
<p><a data-primary="mechanical sympathy" data-type="indexterm" id="idm45606836116480"/>Initially, this chapter might get overwhelming, especially if you are new to low-level programming. Yet, awareness of what is happening will help us understand the optimizations, so focus on understanding high-level patterns and characteristics of each resource (e.g., how the Go scheduler works). We don’t need to know how to write machine code manually or how to, blindfolded, manufacture the computer.</p>&#13;
&#13;
<p>Instead, let’s treat this with curiosity about how things work under the computer case in general. In other words, we need to have <a href="https://oreil.ly/Co2IM">mechanical sympathy</a>.</p>&#13;
</div>&#13;
&#13;
<p>To understand how the CPU architecture works, we need to explain how modern computers operate. So let’s dive into that in the next section.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CPU in a Modern Computer Architecture" data-type="sect1"><div class="sect1" id="ch-hw-basics">&#13;
<h1>CPU in a Modern Computer Architecture</h1>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="modern computer architecture and" data-type="indexterm" id="ix_ch04-asciidoc1"/>All we do while programming in Go is construct a set of statements that tells the computer what to do, step-by-step. Given predefined language constructs like variables, loops, control mechanisms, arithmetic, and I/O operations, we can implement any algorithms that interact with data stored in different mediums. This is why Go, like many other popular programming languages, can be called imperative—as developers, we have to describe how the program will operate. This is also how hardware is designed nowadays—it is imperative too. It waits for program instructions, optional input data, and the desired place for output.</p>&#13;
&#13;
<p>Programming wasn’t always so simple. Before general-purpose machines, engineers had to design fixed program hardware to achieve requested functionality, e.g., a desk calculator. Adding a feature, fixing a bug, or optimizing required changing the &#13;
<span class="keep-together">circuits</span> and manufacturing new devices. Probably not the easiest time to be a &#13;
<span class="keep-together">“programmer”!</span></p>&#13;
&#13;
<p>Fortunately, around the 1950s, a few inventors worldwide figured out the opportunity for the universal machine that could be programmed using a set of predefined instructions stored in memory. <a data-primary="general-purpose computers" data-type="indexterm" id="idm45606836107328"/><a data-primary="von Neumann, John, and general-purpose computers" data-type="indexterm" id="idm45606836106608"/>One of the first people to document this idea was a great mathematician, John von Neumann, and his <a data-primary="Burks, Arthur W., on general-purpose computers" data-type="indexterm" id="idm45606836105600"/><a data-primary="Goldstine, Herman H., on general-purpose computers" data-type="indexterm" id="idm45606836104896"/>team.</p>&#13;
<blockquote><p>It is evident that the machine must be capable of storing in some manner not only the digital information needed in a given computation ..., the intermediate results of the computation (which may be wanted for varying lengths of time), but also the instructions which govern the actual routine to be performed on the numerical data. ... For an all-purpose machine, it must be possible to instruct the device to carry out whatsoever computation that can be formulated in numerical terms.</p>&#13;
<p data-type="attribution">Arthur W. Burks, Herman H. Goldstine, and John von Neumann, <i>Preliminary Discussion of the Logical Design of an Electronic Computing Instrument</i> (Institute for Advanced Study, 1946)</p></blockquote>&#13;
&#13;
<p>What’s noteworthy is that most modern general-purpose computers (e.g., PCs, laptops, and servers) are based on John von Neumann’s design. This assumes that program instructions can be stored and fetched similar to storing and reading program data (instruction input and output). We fetch both the instruction to be performed (e.g., <code>add</code>) and data (e.g., addition operands) by reading bytes from a certain memory address in the main memory (or caches). While it doesn’t sound like a novel idea now, it established how general-purpose machines work. We call this Von Neumann computer architecture, and you can see its modern, evolved variation in <a data-type="xref" href="#img-uma">Figure 4-1</a>.<sup><a data-type="noteref" href="ch04.html#idm45606836099536" id="idm45606836099536-marker">1</a></sup></p>&#13;
&#13;
<figure><div class="figure" id="img-uma">&#13;
<img alt="efgo 0401" src="assets/efgo_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>High-level computer architecture with a single multicore CPU and uniform memory access (UMA)</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the heart of modern architecture, we see a CPU consisting of multiple cores (four to six physical cores are the norm in the 2020s PCs). Each core can execute desired instructions with certain data saved in random-access memory (RAM) or any other memory layers like registers or L-caches (discussed later).</p>&#13;
&#13;
<p>The RAM explained in <a data-type="xref" href="ch05.html#ch-hardware2">Chapter 5</a> performs the duty of the main, fast, volatile memory that can store our data and program code as long as the computer is powered. In addition, the memory controller makes sure RAM is supplied with a constant power flow to keep the information on RAM chips. Last, the CPU can interact with various external or internal input/output (I/O) devices. From a high-level view, an I/O device means anything that accepts sending or receiving a stream of bytes, for example, mouse, keyboard, speaker, monitor, HDD or SSD disk, network interface, GPU, and thousands more.</p>&#13;
&#13;
<p>Roughly speaking, CPU, RAM, and popular I/O devices like disks and network interfaces are the essential parts of computer architecture. This is what we use as “resources” in our RAERs mentioned in <a data-type="xref" href="ch03.html#ch-conq-req-formal">“Efficiency Requirements Should Be Formalized”</a> and what we are usually optimizing for in our software &#13;
<span class="keep-together">development.</span></p>&#13;
&#13;
<p>In this chapter, we will focus on the brain of our general-purpose machines—the CPU. When should we care about CPU resources? Typically, from an efficiency standpoint, we should start looking at our Go process CPU resource usage when either of the following occurs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Our machine can’t do other tasks because our process uses all the available CPU resource computing capacity.</p>&#13;
</li>&#13;
<li>&#13;
<p>Our process runs unexpectedly slow, while we see higher CPU consumption.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are many techniques to troubleshoot these symptoms, but we must first understand the CPU’s internal working and program execution basics. This is the key to efficient Go programming. Furthermore, it explains the numerous optimization techniques that might surprise us initially. For example, do you know why in Go (and other languages), we should avoid using linked lists like structures if we plan to iterate over them a lot, despite their theoretical advantages like quick insertion and<a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm45606836088032"/> &#13;
<span class="keep-together">deletion?</span></p>&#13;
&#13;
<p>Before we learn why, we must understand how the CPU core executes our programs. Surprisingly, I found that the best way to explain this is by learning how the Assembly language works. Trust me on this; it might be easier than you think!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Assembly" data-type="sect1"><div class="sect1" id="ch-hw-assembly">&#13;
<h1>Assembly</h1>&#13;
&#13;
<p><a data-primary="Assembly language" data-secondary="CPU time and" data-type="indexterm" id="ix_ch04-asciidoc2"/><a data-primary="CPU resource" data-secondary="Assembly language" data-type="indexterm" id="ix_ch04-asciidoc3"/><a data-primary="Go Assembly language" data-secondary="CPU time and" data-type="indexterm" id="ix_ch04-asciidoc4"/>The CPU core, indirectly, can execute programs we write. For example, consider the simple Go code in <a data-type="xref" href="#code-sum">Example 4-1</a>.</p>&#13;
<div data-type="example" id="code-sum">&#13;
<h5><span class="label">Example 4-1. </span>Simple function that reads numbers from a file and returns the total sum</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">Sum</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">line</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">bytes</code><code class="p">.</code><code class="nx">Split</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"\n"</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">      </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseInt</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">line</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">         </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">      </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">      </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO1-1" id="co_how_go_uses_the_cpu_resource__or_two__CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO1-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The main arithmetic operation in this function adds a parsed number from the file into a <code>ret</code> integer variable representing the total sum.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>While such language is far from, let’s say, spoken English, unfortunately, it is still too complex and incomprehensible for the CPU. It is not “machine-readable” code. Thankfully every programming language has a dedicated tool called a compiler<sup><a data-type="noteref" href="ch04.html#idm45606835882864" id="idm45606835882864-marker">2</a></sup> that (among other things discussed in <a data-type="xref" href="#ch-hw-compilation">“Understanding Go Compiler”</a>) translates our higher-level code to machine code. You might be familiar with a <code>go build</code> command that invokes a default Go compiler.</p>&#13;
&#13;
<p><a data-primary="machine code" data-type="indexterm" id="idm45606835904704"/>The machine code is a sequence of instructions written in binary format (famous zeros and ones). In principle, each instruction is represented by a number (<code>opcode</code>) followed by optional operands in the form of a constant value or address in the main memory. We can also refer to a few CPU core registers, which are tiny “slots” directly on the CPU chip that can be used to store intermediate results. For example, on AMD64 CPU, we have sixteen 64-bit general-purpose registers referred to as RAX, RBX, RDX, RBP, RSI, RDI, RSP, and R8-R15.</p>&#13;
&#13;
<p>While translating to machine code, the compiler often adds additional code like extra memory safety bound checks. It automatically changes our code for known efficiency patterns for a given architecture. Sometimes this might not be what we expect. This is why inspecting the resulting machine code when troubleshooting some efficiency problems is sometimes useful. Another advanced example of humans needing to read machine code is when we need to reverse engineer programs without source code.</p>&#13;
&#13;
<p>Unfortunately, machine code is impossible to read for humans unless you are a genius. However, there is a great tool we can use in such situations. <a data-primary="Assembly language" data-secondary="machine code and" data-type="indexterm" id="idm45606835901584"/>We can compile <a data-type="xref" href="#code-sum">Example 4-1</a> code to <a href="https://oreil.ly/3xZAs">Assembly language</a> instead of machine code. We can also disassemble the compiled machine code to Assembly. The Assembly language represents the lowest code level that can be practically read and (in theory) written by human developers. It also represents well what will be interpreted by the CPU when converted to machine code.</p>&#13;
&#13;
<p>It is worth mentioning that we can disassemble compiled code into various Assembly dialects. For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To <a href="https://oreil.ly/alpt4">Intel syntax</a> using the standard Linux tool <a href="https://oreil.ly/kZO3j"><code>objdump -d &#13;
<span class="keep-together">-M</span> intel &lt;binary&gt;</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p>To <a href="https://oreil.ly/k6bKs">AT&amp;T syntax</a> using the similar command <a href="https://oreil.ly/cmAW9"><code>objdump -d -M att &lt;binary&gt;</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p>To <a href="https://oreil.ly/lT07J">Go “pseudo” assembly language</a> using Go tooling <a href="https://oreil.ly/5I9t2"><code>go tool objdump -s &lt;binary&gt;</code></a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p class="fix_tracking">All three of these dialects are used in the various tools, and their syntax varies. To have an easier time, always ensure what syntax your disassembly tool uses. <a data-primary="Go Assembly language" data-secondary="machine code and" data-type="indexterm" id="idm45606835849904"/>The Go Assembly is a dialect that tries to be as portable as possible, so it might not exactly represent the machine code. Yet it is usually consistent and close enough for our purposes. It can show all compilation optimization discussed in <a data-type="xref" href="#ch-hw-compilation">“Understanding Go Compiler”</a>. This is why Go Assembly is what we will use throughout this book.</p>&#13;
<div data-type="note" epub:type="note"><h1>Do I Need to Understand Assembly?</h1>&#13;
<p>You don’t need to know how to program in Assembly to write efficient Go code. Yet a rough understanding of Assembly and the decompilation process are essential tools that can often reveal hidden, lower-level computation waste. Practically speaking, it’s useful primarily for advanced optimizations when we have already applied all of the more straightforward optimizations. Assembly is also beneficial for understanding the changes the compiler applies to our code when translating to machine code. Sometimes these might surprise us! Finally, it also tells us how the CPU works.</p>&#13;
</div>&#13;
&#13;
<p>In <a data-type="xref" href="#code-sum-asm">Example 4-2</a> we can see a tiny, disassembled part of the compiled <a data-type="xref" href="#code-sum">Example 4-1</a> (using <code>go tool objsdump -s</code>) that represents <code>ret += num</code> statement.<sup><a data-type="noteref" href="ch04.html#idm45606835843408" id="idm45606835843408-marker">3</a></sup></p>&#13;
<div data-type="example" id="code-sum-asm">&#13;
<h5><span class="label">Example 4-2. </span>Addition part of code in Go Assembly language decompiled from the compiled <a data-type="xref" href="#code-sum">Example 4-1</a></h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>//</code><code> </code><code>go</code><code> </code><code>tool</code><code> </code><code>objdump</code><code> </code><code>-s</code><code> </code><code>sum.test</code><code>&#13;
</code><code class="nv">ret</code><code> </code><code class="o">+=</code><code> </code><code>num</code><code>&#13;
</code><code>0x4f9b6d</code><code>      </code><code>488b742450</code><code>    </code><code>MOVQ</code><code> </code><code>0x50</code><code class="o">(</code><code>SP</code><code class="o">)</code><code>,</code><code> </code><code>SI</code><code>  </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO2-1" id="co_how_go_uses_the_cpu_resource__or_two__CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>0x4f9b72</code><code>      </code><code>4801c6</code><code>       </code><code>ADDQ</code><code> </code><code>AX,</code><code> </code><code>SI</code><code>  </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO2-2" id="co_how_go_uses_the_cpu_resource__or_two__CO2-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO2-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The first line represents a <a href="https://oreil.ly/SDE5R">quadword (64 bit) MOV instruction</a> that tells the CPU to copy the 64-bit value from memory under the address stored in register <code>SP</code> plus 80 bytes and put that into the <code>SI</code> register.<sup><a data-type="noteref" href="ch04.html#idm45606835798912" id="idm45606835798912-marker">4</a></sup> The compiler decided that <code>SI</code> will store the initial value of the return argument in our function, so the <code>ret</code> integer variable for the <code>ret+=num</code> operation.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO2-2" id="callout_how_go_uses_the_cpu_resource__or_two__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>As a second instruction, we tell the CPU to add a quadword value from the <code>AX</code> register to the <code>SI</code> register. The compiler used the <code>AX</code> register to store the <code>num</code> integer variable, which we parsed from the <code>string</code> in previous instructions (outside of this snippet).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The preceding example shows <code>MOVQ</code> and <code>ADDQ</code> instructions. To make things more complex, each distinct CPU implementation allows a different set of instructions, with different memory addressing, etc. <a data-primary="Instruction Set Architecture (ISA)" data-type="indexterm" id="idm45606835765936"/><a data-primary="ISA (Instruction Set Architecture)" data-type="indexterm" id="idm45606835765232"/>The industry created the <a href="https://oreil.ly/eTzST">Instruction Set Architecture (ISA)</a> to specify a strict, portable interface between software and hardware. Thanks to the ISA, we can compile our program, for example, to machine code compatible with the ISA for x86 architecture and run it on any x86 CPU.<sup><a data-type="noteref" href="ch04.html#idm45606835763760" id="idm45606835763760-marker">5</a></sup> The ISA defines data types, registers, main memory management, fixed set of instructions, unique identification, input/output model, etc. There are various <a href="https://oreil.ly/TLxJn">ISAs</a> for different types of CPUs. For example, both 32-bit and 64-bit Intel and AMD processors use x86 ISA, and ARM uses its ARM ISA (for example, new <a href="https://oreil.ly/NZqT1">Apple M chips use ARMv8.6-A</a>).</p>&#13;
&#13;
<p>As far as Go developers are concerned, the ISA defines a set of instructions and registers our compiled machine code can use. To produce a portable program, a compiler can transform our Go code into machine code compatible with a specific ISA (architecture) and the type of the desired operating system.<a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm45606835760608"/><a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm45606835759904"/><a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm45606835759232"/> In the next section, let’s look at how the default Go compiler works. On the way, we will uncover mechanisms to help the Go compiler produce efficient and fast machine code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Go Compiler" data-type="sect1"><div class="sect1" id="ch-hw-compilation">&#13;
<h1>Understanding Go Compiler</h1>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="Go compiler and" data-type="indexterm" id="ix_ch04-asciidoc5"/><a data-primary="Go compiler" data-type="indexterm" id="ix_ch04-asciidoc6"/>The topic of building effective compilers can fill a few books. In this book, however, we will try to understand the Go compiler basics that we, as Go developers interested in efficient code, have to be aware of. Generally, many things are involved in executing the Go code we write on the typical operating system, not only compilation. First, we need to compile it using a compiler, and then we have to use a linker to link different object files together, including potentially shared libraries. These compile and link procedures, often called <em>building</em>, produce the executable (“binary”) that the operating system can execute. During the initial start, called <em>loading</em>, other shared libraries can be dynamically loaded too (e.g., Go plug-ins).</p>&#13;
&#13;
<p>There are many code-building methods for Go code, designed for different target environments. For example, <a href="https://oreil.ly/c2C5E">Tiny Go</a> is optimized to produce binaries for microcontrollers, <a href="https://oreil.ly/D83Jq">gopherjs</a> produces JavaScript for in-browser execution, and <a href="https://oreil.ly/83Wm1">android</a> produces programs executable on Android operating systems. <a data-primary="go build command" data-type="indexterm" id="ix_ch04-asciidoc7"/>However, this book will focus on the default and most popular Go compiler and linking mechanism available in the <code>go build</code> command. The compiler itself is written in Go (initially in C). The rough documentation and source code can be found <a href="https://oreil.ly/qcrLt">here</a>.</p>&#13;
&#13;
<p>The <code>go build</code> can build our code into many different outputs. We can build executables that require system libraries to be dynamically linked on startup. We can build shared libraries or even C-compatible shared libraries. Yet the most common and recommended way of using Go is to build executables with all dependencies statically linked in. It offers a much better experience where invocation of our binary does not need any system dependency of a specific version in a certain directory. It is a default build mode for code with a starting <code>main</code> function that can also be explicitly invoked using <code>go build -buildmode=exe</code>.</p>&#13;
&#13;
<p>The <code>go build</code> command invokes both compilation and linking. While the linking phase also performs certain optimizations and checks, the compiler probably performs the most complex duty. The Go compiler focuses on a single package at once. It compiles package source code into the native code that the target architecture and operating systems support. On top of that, it validates, optimizes that code, and prepares important metadata for debugging purposes. We need to “collaborate” with the compiler (and operating system and hardware) to write efficient Go and not work against it.<a data-primary="Kennedy, William" data-secondary="on mechanical sympathy" data-type="indexterm" id="idm45606835745088"/><a data-primary="mechanical sympathy" data-secondary="Bill Kennedy on" data-type="indexterm" id="idm45606835744112"/></p>&#13;
<blockquote>&#13;
<p>I tell everyone, if you’re not sure how to do something, ask the question around what is the most idiomatic way to do this in Go. Because many of those answers are already tuned to being sympathetic with the operating system of the hardware.</p>&#13;
<p data-type="attribution">Bill Kennedy, <a href="https://oreil.ly/X3XzI">“Bill Kennedy on Mechanical Sympathy”</a></p>&#13;
</blockquote>&#13;
&#13;
<p>To make things more interesting, <code>go build</code> also offers a special cross-compilation mode if you want to compile a mix of Go code that uses functions implemented in C, C++, or even Fortran! This is possible if you enable a mode called <a href="https://oreil.ly/Xjh9U"><code>cgo</code></a>, which uses a mix of C (or C++) compiler and Go compiler. Unfortunately, <code>cgo</code> <a href="https://oreil.ly/QojX3">is not recommended</a>, and it should be avoided if possible. It makes the build process slow, the performance of passing data between C and Go is questionable, and non-<code>cgo</code> compilation is already powerful enough to cross-compile binaries for different architectures and operating systems. Luckily, most of the libraries are either pure Go or are using pieces of Assembly that can be included in the Go binary without <code>cgo</code>.</p>&#13;
&#13;
<p>To understand the impact of the compiler on our code, see the stages the Go compiler performs in <a data-type="xref" href="#img-hw-comp">Figure 4-2</a>. While <code>go build</code> includes such compilation, we can trigger just the compilation (without linking) alone using  <code>go tool compile</code>.</p>&#13;
&#13;
<figure><div class="figure" id="img-hw-comp">&#13;
<img alt="efgo 0402" src="assets/efgo_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Stages performed by the Go compiler on each Go package</h6>&#13;
</div></figure>&#13;
&#13;
<p>As mentioned previously, the whole process resides around the packages you use in your Go program. Each package is compiled in separation, allowing parallel compilation and separation of concerns. The compilation flow presented in <a data-type="xref" href="#img-hw-comp">Figure 4-2</a> works as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The Go source code is first tokenized and parsed. The syntax is checked. The syntax tree references files and file positions to produce meaningful error and debugging information.</p>&#13;
</li>&#13;
<li>&#13;
<p>An abstract syntax tree (AST) is built. Such a tree notion is a common abstraction that allows developers to create algorithms that easily transform or check parsed statements. While in AST form, code is initially type-checked. Declared but not used items are detected.</p>&#13;
</li>&#13;
<li>&#13;
<p>The first pass of optimization is performed. For example, the initial dead code is eliminated, so the binary size can be smaller and less code needs to be compiled. Then, escape analysis (mentioned in <a data-type="xref" href="ch05.html#ch-hw-go-mem">“Go Memory Management”</a>) is performed to decide which variables can be placed on the stack and which have to be allocated on the heap. On top of that, in this stage, function inlining occurs for simple and small functions.</p>&#13;
<div data-type="note" epub:type="note"><h1>Function Inlining</h1>&#13;
<p><a data-primary="function inlining" data-type="indexterm" id="idm45606835724992"/><a data-primary="inlining" data-secondary="function" data-type="indexterm" id="idm45606835724288"/>Functions<sup><a data-type="noteref" href="ch04.html#idm45606835723216" id="idm45606835723216-marker">6</a></sup> in programming language allow us to create abstractions, hide complexities, and reduce repeated code. Yet the cost of calling execution is nonzero. For example, <a href="https://oreil.ly/4OPbI">a function with a single argument call needs ~10 extra CPU instructions</a>.<sup><a data-type="noteref" href="ch04.html#idm45606835721776" id="idm45606835721776-marker">7</a></sup> So, while the cost is fixed and typically at the level of nanoseconds, it can matter if we have thousands of these calls in the hot path and the function body is small enough that this execution call matters.</p>&#13;
&#13;
<p>There are also other benefits of inlining. For example, the compiler can apply other optimizations more effectively in code with fewer functions and does not need to use heap or large stack memory (with copy) to pass arguments between function scopes. Heap and stack are explained in <a data-type="xref" href="ch05.html#ch-hw-go-mem">“Go Memory Management”</a>.</p>&#13;
</div>&#13;
&#13;
<p>The compiler automatically substitutes some function calls with the exact copy of its body. This is called <em>inlining</em> or <a href="https://oreil.ly/JGde3"><em>inline expansion</em></a>. The logic is quite smart. For instance, from Go 1.9, the compiler can <a href="https://oreil.ly/CX2v0">inline both leaf and mid-stack functions</a>.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Manual Inlining Is Rarely Needed</h1>&#13;
<p><a data-primary="inlining" data-secondary="manual" data-type="indexterm" id="idm45606835715264"/>It is tempting for beginner engineers to micro-optimize by manually inlining some of their functions. However, while developers had to do it in the early days of programming, this functionality is a fundamental duty of the compiler, which usually knows better when and how to inline a function. Use that fact by focusing on your code readability and maintainability first regarding the choice of functions. Inline manually only as a last resort, and always measure.</p>&#13;
</div>&#13;
</li>&#13;
<li>&#13;
<p>After early optimizations on the AST, the tree is converted to the Static Single Assignment (SSA) form. This low-level, more explicit representation makes it easier to perform further optimization passes using a set of rules. For example, with the help of the SSA, the compiler can easily find places of unnecessary variable assignments.<sup><a data-type="noteref" href="ch04.html#idm45606835712848" id="idm45606835712848-marker">8</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>The compiler applies further machine-independent optimization rules. So, for example, statements like <code>y := 0*x</code> will be simplified to <code>y :=0</code>. The complete &#13;
<span class="keep-together">list of</span> rules is <a href="https://oreil.ly/QTljA">enormous</a> and only confirms how complex this space is. Furthermore, some code pieces can be replaced by an <a href="https://oreil.ly/FMjT0">intrinsic function</a>—heavily optimized equivalent code (e.g., in raw &#13;
<span class="keep-together">Assembly).</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Based on <code>GOARCH</code> and <code>GOOS</code> environment variables, the compiler invokes the &#13;
<span class="keep-together"><code>genssa</code></span> function that converts SSA to the machine code for the desired architecture (ISA) and operating system.</p>&#13;
</li>&#13;
<li>&#13;
<p>Further ISA- and operating system–specific optimizations are applied.</p>&#13;
</li>&#13;
<li>&#13;
<p>Package machine code that is not dead is built into a single object file (with the <em>.o</em> suffix) and debug information.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The final “object file” is compressed into a <code>tar</code> file called a Go <em>archive</em>, usually with <em>.a</em> file suffix.<sup><a data-type="noteref" href="ch04.html#idm45606835698096" id="idm45606835698096-marker">9</a></sup> <a data-primary="binary file" data-type="indexterm" id="idm45606835696128"/>Such archive files for each package can be used by Go linker (or other linkers) to combine all into a single executable, commonly called a <em>binary file</em>. Depending on the operating system, such a file follows a certain format, telling the system how to execute and use it. Typically for Linux, it will be an <a href="https://oreil.ly/jnicX">Executable and Linkable Format</a> (ELF). On Windows, it might be <a href="https://oreil.ly/SdohW">Portable Executable</a> (PE).</p>&#13;
&#13;
<p>The machine code is not the only part of such a binary file. It also carries the program’s static data, like global variables and constants. The executable file also contains a lot of debugging information that can take a considerable amount of binary size, like a simple symbols table, basic type information (for reflection), and <a href="https://oreil.ly/akAR2">PC-to-line mapping</a> (address of the instruction to the line in the source code where the command was). That extra information enables valuable debugging tools to link machine code to the source code. Many debugging tools use it, for example, <a data-type="xref" href="ch09.html#ch-obs-profiling">“Profiling in Go”</a> and the aforementioned <code>objdump</code> tool. &#13;
<span class="keep-together">For compatibility</span> with debugging software like Delve or GDB, the DWARF table is also attached to the binary file.<sup><a data-type="noteref" href="ch04.html#idm45606835689456" id="idm45606835689456-marker">10</a></sup></p>&#13;
&#13;
<p>On top of the already long list of responsibilities, the Go compiler must perform extra steps to ensure Go <a href="https://oreil.ly/kkCRb">memory safety</a>. For instance, the compiler can often tell during compile time that some commands will use a memory space that is safe to use (contains an expected data structure and is reserved for our program). However, there are cases when this cannot be determined during compilation, so additional checks have to be done at runtime, e.g., extra bound checks or nil checks.</p>&#13;
&#13;
<p>We will discuss this in more detail in <a data-type="xref" href="ch05.html#ch-hw-go-mem">“Go Memory Management”</a>, but &#13;
<span class="keep-together">for our</span> conversation about CPU, we need to acknowledge that such checks can take our valuable CPU time. While the Go compiler tries to eliminate these checks when unnecessary (e.g., in the bound check elimination stage during SSA optimizations), there might be cases where we need to write code in a way that helps the compiler eliminate some checks.<sup><a data-type="noteref" href="ch04.html#idm45606835684112" id="idm45606835684112-marker">11</a></sup></p>&#13;
&#13;
<p>There are many different configuration options for the Go build process. The first large batch of options can be passed through <code>go build -ldflags="&lt;flags&gt;"</code>, which represents <a href="https://oreil.ly/g8dvv">linker command options</a> (the <code>ld</code> prefix traditionally stands for <a href="https://oreil.ly/uJEda">Linux linker</a>). For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We can omit the DWARF table, thus reducing the binary size using &#13;
<span class="keep-together"><code>-ldflags="-w"</code></span> (recommended for production build if you don’t use debuggers there).</p>&#13;
</li>&#13;
<li>&#13;
<p>We can further reduce the size with <code>-ldflags= "-s -w"</code>, removing the DWARF and symbols tables with other debug information. I would not recommend the latter option, as non-DWARF elements allow important runtime routines, like gathering profiles.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Similarly, <code>go build -gcflags="&lt;flags&gt;"</code> represents <a href="https://oreil.ly/rRtRs">Go compiler options</a> (<code>gc</code> stands for <code>Go Compiler</code>; don’t confuse it with GC, which means garbage collection, as explained in <a data-type="xref" href="ch05.html#ch-hw-garbage">“Garbage Collection”</a>). For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>-gcflags="-S"</code> prints Go Assembly from the source code.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>-gcflags="-N"</code> disables all compiler optimizations.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>-gcflags="-m=&lt;number&gt;</code> builds the code while printing the main optimization decisions, where the number represents the level of detail. See <a data-type="xref" href="#code-comp-sum">Example 4-3</a> for the automatic compiler optimizations made on our <code>Sum</code> function in <a data-type="xref" href="#code-sum">Example 4-1</a>.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="example" id="code-comp-sum">&#13;
<h5><span class="label">Example 4-3. </span>Output of <code>go build -gcflags="-m=1" sum.go</code> on <a data-type="xref" href="#code-sum">Example 4-1</a> code</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c1"># command-line-arguments&#13;
</code><code>./sum.go:10:27:</code><code> </code><code>inlining</code><code> </code><code>call</code><code> </code><code>to</code><code> </code><code>os.ReadFile</code><code> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO3-1" id="co_how_go_uses_the_cpu_resource__or_two__CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>./sum.go:15:34:</code><code> </code><code>inlining</code><code> </code><code>call</code><code> </code><code>to</code><code> </code><code>bytes.Split</code><code> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO3-1" id="co_how_go_uses_the_cpu_resource__or_two__CO3-2"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>./sum.go:9:10:</code><code> </code><code>leaking</code><code> </code><code>param:</code><code> </code><code>fileName</code><code> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO3-2" id="co_how_go_uses_the_cpu_resource__or_two__CO3-3"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>./sum.go:15:44:</code><code> </code><code class="o">(</code><code class="o">[</code><code class="o">]</code><code>byte</code><code class="o">)</code><code class="o">(</code><code class="s2">"\n"</code><code class="o">)</code><code> </code><code>does</code><code> </code><code>not</code><code> </code><code>escape</code><code> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO3-3" id="co_how_go_uses_the_cpu_resource__or_two__CO3-4"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>./sum.go:16:38:</code><code> </code><code>string</code><code class="o">(</code><code>line</code><code class="o">)</code><code> </code><code>escapes</code><code> </code><code>to</code><code> </code><code>heap</code><code> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO3-4" id="co_how_go_uses_the_cpu_resource__or_two__CO3-5"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO3-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>os.ReadFile</code> and <code>bytes.Split</code> are short enough, so the compiler can copy the whole body of the <code>Sum</code>  function.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO3-3" id="callout_how_go_uses_the_cpu_resource__or_two__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>fileName</code> argument is “leaking,” meaning this function keeps its parameter alive after it returns (it can still be on stack, though).</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO3-4" id="callout_how_go_uses_the_cpu_resource__or_two__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Memory for <code>[]byte("\n")</code> will be allocated on the stack. Messages like this help debug escape analysis. Learn more about it <a href="https://oreil.ly/zBCyO">here</a>.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO3-5" id="callout_how_go_uses_the_cpu_resource__or_two__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Memory for <code>string(line)</code> will be allocated in a more expensive heap.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The compiler will print more details with an increased <code>-m</code> number. For example, <code>-m=3</code> will explain why certain decisions were made. This option is handy when we expect certain optimization (inlining or keeping variables on the stack) to occur, but we still see an overhead while benchmarking in our TFBO cycle (<a data-type="xref" href="ch03.html#ch-conq-eff-flow">“Efficiency-Aware Development Flow”</a>).</p>&#13;
&#13;
<p>The Go compiler implementation is highly tested and mature, but there are limitless ways of writing the same functionality. There might be edge cases when our implementation confuses the compiler, so it does not apply certain naive implementations. Benchmarking if there is a problem, profiling the code, and confirming with the <code>-m</code> option help. More detailed optimizations can also be printed using further options. For example, <code>-gcflags="-d=ssa/check_bce/debug=1"</code> prints all bound check elimination optimizations.</p>&#13;
<div class="tip5" data-type="tip"><h1>The Simpler the Code, the More Effective Compiler Optimizations &#13;
<span class="keep-together">Will Be</span></h1>&#13;
<p>Too-clever code is hard to read and makes it difficult to maintain programmed functionality. But it also can confuse the compiler that tries to match patterns with their optimized equivalents. Using idiomatic code, keeping your functions and loops straightforward, increases the chances that the compiler applies the optimizations so you don’t need to!</p>&#13;
</div>&#13;
&#13;
<p>Knowing compiler internals helps, especially when it comes to more advanced optimizations tricks, which among other things, help compilers optimize our code. Unfortunately, it also means our optimizations might be a bit fragile regarding portability between different compiler versions. The Go team reserves rights to change compiler implementation and flags since they are not part of any specification. This might mean that the way you wrote a function that allows automatic inline by the compiler might not trigger inline in the next version of the Go compiler. This is why it’s even more important to benchmark and closely observe the efficiency of your program when you switch to a different Go version.</p>&#13;
&#13;
<p>To sum up, the compilation process has a crucial role in offloading programmers from pretty tedious work. Without compiler optimizations, we would need to write more code to get to the same efficiency level while sacrificing readability and portability. Instead, if you focus on making your code simple, you can trust that the Go compiler will do a good enough job. If you need to increase efficiency for a particular hot path, it might be beneficial to double-check if the compiler did what you expected. For example, it might be that the compiler did not match our code with common optimization; there is some extra memory safety check that the compiler could further eliminate or function that could be inlined but was not. In very extreme cases, there might be even a value to write a dedicated assembly code and import it from the Go code.<sup><a data-type="noteref" href="ch04.html#idm45606835565472" id="idm45606835565472-marker">12</a></sup></p>&#13;
&#13;
<p>The Go building process constructs fully executable machine code from our Go source code. The operating system loads machine code to memory and writes the first instruction address to the program counter (PC) register when it needs to be executed. From there, the CPU core can compute each instruction one by one. At first glance, it might mean that the CPU has a relatively simple job to do. But unfortunately, a memory wall problem causes CPU makers to continuously work on additional hardware optimizations that change how these instructions are executed. Understanding these mechanisms will allow us to control the efficiency and speed of our Go programs even better. Let’s uncover this problem in the next section<a data-startref="ix_ch04-asciidoc7" data-type="indexterm" id="idm45606835564528"/>.<a data-startref="ix_ch04-asciidoc6" data-type="indexterm" id="idm45606835563696"/><a data-startref="ix_ch04-asciidoc5" data-type="indexterm" id="idm45606835562992"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CPU and Memory Wall Problem" data-type="sect1"><div class="sect1" id="ch-hw-mem-wall">&#13;
<h1>CPU and Memory Wall Problem</h1>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="memory wall problem" data-type="indexterm" id="ix_ch04-asciidoc8"/><a data-primary="memory wall" data-type="indexterm" id="ix_ch04-asciidoc9"/><a data-primary="memory wall" data-secondary="CPU resource and" data-type="indexterm" id="ix_ch04-asciidoc10"/>To understand the memory wall and its consequences, let’s dive briefly into CPU core internals. The details and implementation of the CPU core change over time for better efficiency (usually getting more complex), but the fundamentals stay the same. In principle, a Control Unit, shown in <a data-type="xref" href="#img-uma">Figure 4-1</a>, manages reads from memory through various L-caches (from smallest and fastest), decodes program instructions, coordinates their execution in the Arithmetic Logic Unit (ALU), and handles &#13;
<span class="keep-together">interruptions.</span></p>&#13;
&#13;
<p>An important fact is that the CPU works in cycles. <a data-primary="Single Instruction Single Data (SISD)" data-type="indexterm" id="idm45606835555120"/>Most CPUs in one cycle can perform one instruction on one set of tiny data. This pattern is called the Single Instruction Single Data (SISD) in characteristics mentioned in <a href="https://oreil.ly/oQu0M">Flynn’s taxonomy</a>, and it’s the key aspect of the von Neumann architecture. <a data-primary="Single Instruction Multiple Data (SIMD)" data-type="indexterm" id="idm45606835553664"/>Some CPUs also allow Single Instruction Multiple Data (SIMD)<sup><a data-type="noteref" href="ch04.html#idm45606835552784" id="idm45606835552784-marker">13</a></sup> processing with special instructions like SSE, which allows the same arithmetic operation on four floating numbers in one cycle. Unfortunately, these instructions are not straightforward to use in Go and are therefore quite rarely seen.</p>&#13;
&#13;
<p>Meanwhile, registers are the fastest local storage available to the CPU core. Because they are small circuits wired directly into the ALU, it takes only one CPU cycle to read their data. Unfortunately, there are also only a few of them (depending on the CPU, typically 16 for general use), and their size is usually not larger than 64 bits. This means they are used as short-time variables in our program lifetime. Some of the registers can be used for our machine code. Others are reserved for CPU use. For example, the <a href="https://oreil.ly/TvHVd">PC register</a> holds the address of the next instruction that the CPU should fetch, decode, and execute.</p>&#13;
&#13;
<p>Computation is all about the data. As we learned in <a data-type="xref" href="ch01.html#ch-efficiency-matters">Chapter 1</a>, there is lots of data nowadays, scattered around different storage mediums—uncomparably more than what’s available to store in a single CPU register. Moreover, a single CPU cycle is faster than accessing data from the main memory (RAM)—on average, one hundred times faster, as we read from our rough napkin math of latencies in <a data-type="xref" href="app01.html#appendix-napkin-math">Appendix A</a> that we will use throughout this book. As discussed in the misconception <a data-type="xref" href="ch01.html#ch-eff-s-hardware">“Hardware Is Getting Faster and Cheaper”</a>, technology allows us to create CPU cores with dynamic clock speed, yet the maximum is always around 4 GHz. Funny enough, the fact we can’t make faster CPU cores is not the most important problem since our CPU cores are already…​too fast! It’s a fact we cannot make faster memory, which causes the main efficiency issues in CPUs nowadays.<a data-primary="Carruth, Chandler" data-secondary="on time spent waiting for data" data-type="indexterm" id="idm45606835546496"/></p>&#13;
<blockquote>&#13;
<p>We can execute something in the ballpark of 36 billion instructions every second. Unfortunately, most of that time is spent waiting for data. About 50% of the time in almost every application. In some applications upwards of 75% of the time is spent waiting for data rather than executing instructions. If this horrifies you, good. It should.</p>&#13;
<p data-type="attribution"> Chandler Carruth, <a href="https://oreil.ly/I55mm">“Efficiency with Algorithms, Performance with Data <span class="keep-together">Structures”</span></a></p></blockquote>&#13;
&#13;
<p>The aforementioned problem is often referred to as a <a href="https://oreil.ly/l5zgk">“memory wall” problem</a>. As a result of this problem, we risk wasting dozens, if not hundreds, of CPU cycles per single instruction, since fetching that instruction and data (and then saving the results) takes ages.</p>&#13;
&#13;
<p>This problem is so prominent that it has triggered recent discussions about <a href="https://oreil.ly/xqbNU">revisiting von Neumann’s architecture</a> as machine learning (ML) workloads (e.g., neural networks) for artificial intelligence (AI) use become more popular. These workloads are especially affected by the memory wall problem because most of the time is spent performing complex matrix math calculations, which require traversing large amounts of memory.<sup><a data-type="noteref" href="ch04.html#idm45606835540240" id="idm45606835540240-marker">14</a></sup></p>&#13;
&#13;
<p>The memory wall problem effectively limits how fast our programs do their job. It also impacts the overall energy efficiency that matters for mobile applications. Nevertheless, it is the best common general-purpose hardware nowadays. Industry mitigated many of these problems by developing a few main CPU optimizations we will discuss below: the hierarchical cache system, pipelining, out-of-order execution, and hyperthreading. These directly impact our low-level Go code efficiency, especially in terms of how fast our program will be executed.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hierachical Cache System" data-type="sect2"><div class="sect2" id="ch-hw-lcache">&#13;
<h2>Hierachical Cache System</h2>&#13;
&#13;
<p><a data-primary="cache, hierarchical" data-type="indexterm" id="idm45606835537312"/><a data-primary="CPU resource" data-secondary="hierarchical cache system" data-type="indexterm" id="idm45606835536384"/><a data-primary="memory wall" data-secondary="hierarchical cache system" data-type="indexterm" id="idm45606835535472"/><a data-primary="SRAM (static random-access memory)" data-type="indexterm" id="idm45606835534512"/><a data-primary="static random-access memory (SRAM)" data-type="indexterm" id="idm45606835533824"/>All modern CPUs include local, fast, small caches for often-used data. L1, L2, L3 (and sometimes L4) caches are on-chip static random-access memory (SRAM) circuits. SRAM uses different technology for storing data faster than our main memory RAM but is much more expensive to use and produce in large capacities (main memory is explained in <a data-type="xref" href="ch05.html#ch-hw-memory-ph">“Physical Memory”</a>). <a data-primary="L-caches" data-type="indexterm" id="idm45606835531856"/>Therefore, L-caches are touched first when the CPU needs to fetch instruction or data for an instruction from the main memory (RAM). The way the CPU is using L-caches is presented in <a data-type="xref" href="#img-hw-lcaches">Figure 4-3</a>.<sup><a data-type="noteref" href="ch04.html#idm45606835530224" id="idm45606835530224-marker">15</a></sup> In the example, we will use a simple CPU instruction <code>MOVQ</code>, explained in <a data-type="xref" href="#code-sum-asm">Example 4-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-hw-lcaches">&#13;
<img alt="efgo 0403" src="assets/efgo_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>The “look up” cache method performed by the CPU to read bytes from the main memory through L-caches</h6>&#13;
</div></figure>&#13;
&#13;
<p>To copy 64 bits (<code>MOVQ</code> command) from a specific memory address to register <code>SI</code>, we must access the data that normally resides in the main memory. Since reading from RAM is slow, it uses L-caches to check for data first. The CPU will ask the L1 cache for these bytes on the first try. If the data is not there (cache miss), it visits a larger L2 cache, then the largest cache L3, then eventually main memory (RAM). In any of these misses, the CPU will try to fetch the complete “cache line” (typically 64 bytes, so eight times the size of the register), save it in all caches, and only use these specific bytes.</p>&#13;
&#13;
<p>Reading more bytes at once (cache line) is useful as it takes the same latency as reading a single byte (explained in <a data-type="xref" href="ch05.html#ch-hw-memory-ph">“Physical Memory”</a>). Statistically, it is also likely that the next operation needs bytes next to the previously accessed area. &#13;
<span class="keep-together">L-caches</span> partially mitigate the memory latency problem and reduce the overall amount of data to be transferred, preserving memory bandwidth.</p>&#13;
&#13;
<p>The first direct consequence of having L-caches in our CPUs is that the smaller and more aligned the data structure we define, the better the efficiency. Such a structure will have more chances to fit fully in lower-level caches and avoid expensive cache misses. The second result is that instructions on sequential data will be faster since cache lines typically contain multiple items stored next to each other.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pipelining and Out-of-Order Execution" data-type="sect2"><div class="sect2" id="ch-hw-pipeline">&#13;
<h2>Pipelining and Out-of-Order Execution</h2>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="pipelining and out-of-order CPU execution" data-type="indexterm" id="ix_ch04-asciidoc11"/><a data-primary="memory wall" data-secondary="pipelining and out-of-order CPU execution" data-type="indexterm" id="ix_ch04-asciidoc12"/><a data-primary="out-of-order CPU execution" data-type="indexterm" id="ix_ch04-asciidoc13"/><a data-primary="pipelining, out-of-order CPU execution and" data-type="indexterm" id="ix_ch04-asciidoc14"/>If the data were magically accessible in zero time, we would have a perfect situation where every CPU core cycle performs a meaningful instruction, executing instructions as fast as CPU core speed allows. Since this is not the case, modern CPUs try to keep every part of the CPU core busy using cascading pipelining. In principle, the CPU core can perform many stages required for instruction execution at once in one cycle. <a data-primary="ILP (Instruction-Level Parallelism)" data-type="indexterm" id="idm45606835513104"/><a data-primary="Instruction-Level Parallelism (ILP)" data-type="indexterm" id="idm45606835512464"/>This means we can exploit Instruction-Level Parallelism (ILP) to execute, for example, five independent instructions in five CPU cycles, giving us that sweet average of one instruction per cycle (IPC).<sup><a data-type="noteref" href="ch04.html#idm45606835511424" id="idm45606835511424-marker">16</a></sup> For example, in an <a href="https://oreil.ly/ccBg2">initial 5-stage pipeline system</a> (modern CPUs have 14–24 stages!), a single CPU core computes 5 instructions at the same time within a cycle, as presented in <a data-type="xref" href="#img-hw-cpupipe">Figure 4-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-hw-cpupipe">&#13;
<img alt="efgo 0404" src="assets/efgo_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>Example five-stage pipeline</h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">The classic five-stage pipeline consists of five operations:</p>&#13;
<dl>&#13;
<dt><code>IF</code></dt>&#13;
<dd>&#13;
<p>Fetch the instruction to execute.</p>&#13;
</dd>&#13;
<dt><code>ID</code></dt>&#13;
<dd>&#13;
<p>Decode the instruction.</p>&#13;
</dd>&#13;
<dt><code>EX</code></dt>&#13;
<dd>&#13;
<p>Start the execution of the instruction.</p>&#13;
</dd>&#13;
<dt><code>MEM</code></dt>&#13;
<dd>&#13;
<p>Fetch the operands for the execution.</p>&#13;
</dd>&#13;
<dt><code>WB</code></dt>&#13;
<dd>&#13;
<p>Write back the result of the operation (if any).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>To make it even more complex, as we discussed in the L-caches section, it is rarely the case that even the fetch of the data (e.g., the <code>MEM</code> stage) takes only one cycle. To mitigate this, the CPU core also employs <a href="https://oreil.ly/ccBg2">a technique called out-of-order execution</a>. In this method, the CPU attempts to schedule instructions in an order governed by the availability of the input data and execution unit (if possible) rather than by their original order in the program. For our purposes, it is enough to think about it as a complex, more dynamic pipeline that utilizes internal queues for more efficient CPU execution.</p>&#13;
&#13;
<p>The resulting pipelined and out-of-order CPU execution is complex, but the preceding simplified explanation should be all we need to understand two critical consequences for us as developers. The first, trivial one is that every switch of the instruction stream has a huge cost (e.g., in latency),<sup><a data-type="noteref" href="ch04.html#idm45606835495520" id="idm45606835495520-marker">17</a></sup> because the pipeline has to reset and start from scratch, on top of the obvious cache trashing. We haven’t yet mentioned the operating system overhead that must be added on top. We often call this a <em>context switch</em>, which is inevitable in modern computers since the typical operating systems use preemptive task scheduling. In these systems, the execution flow of the single CPU core can be preempted many times a second, which might matter in extreme cases. We will discuss how to influence such behavior in <a data-type="xref" href="#ch-hw-os-scheduler">“Operating System Scheduler”</a>.</p>&#13;
&#13;
<p>The second consequence is that the more predictive our code is, the better. <a data-primary="branch predictions" data-type="indexterm" id="idm45606835489840"/>This is because pipelining requires the CPU cores to perform complex <em>branch predictions</em> to find instructions that will be executed after the current one. If our code is full of branches like <code>if</code> statements, <code>switch</code> cases, or jump statements like <code>continue</code>, finding even two instructions to execute simultaneously might be impossible, simply because one instruction might decide on what instruction will be done next. This is called data dependency. <a data-primary="speculative execution" data-type="indexterm" id="idm45606835486928"/>Modern CPU core implementation goes even further by performing speculative execution. Since it does not know which instruction is next, it picks the most likely one and assumes that such a branch will be chosen. Unnecessary executions on the wrong branches are better than wasted CPU cycles doing nothing. Therefore, many branchless coding techniques have emerged, which help the CPU predict branches and might result in faster code. Some methods are applied automatically by the <a href="https://oreil.ly/VqKzx">Go compiler</a>, but sometimes, manual improvements have to be added.</p>&#13;
&#13;
<p>Generally speaking, the simpler the code, with fewer nested conditionals and loops, the better for the branch predictor. This is why we often hear that the code that “leans to the left” is faster.<a data-primary="Alexandrescu, Andrei" data-secondary="on code that “leans to the left”" data-type="indexterm" id="idm45606835484400"/></p>&#13;
<blockquote>&#13;
<p>In my experience [I saw] repeatedly that code that wants to be fast, go to the left of the page. So if you [write] like a loop and the if, and the for and a switch, it’s not going to be fast. By the way, the Linux kernel, do you know what the coding standard is? Eight characters tab, 80 characters line width. You can’t write bad code in the Linux kernel. You can’t write slow code there. ... The moment you have too many ifs and decision points ... in your code, the efficiency is out of the window.</p>&#13;
<p data-type="attribution">Andrei Alexandrescu, <a href="https://oreil.ly/6mERC">“Speed Is Found in the Minds of People”</a></p>&#13;
</blockquote>&#13;
&#13;
<p>The existence of branch predictors and speculative approaches in the CPU has another consequence. It causes contiguous memory data structures to perform much better in pipelined CPU architecture with L-caches.</p>&#13;
<div class="tip5" data-type="tip"><h1>Contiguous Memory Structure Matters</h1>&#13;
<p><a data-primary="arrays" data-secondary="lined lists versus" data-type="indexterm" id="idm45606835478992"/><a data-primary="CPU resource" data-secondary="contiguous memory structure and" data-type="indexterm" id="idm45606835478016"/><a data-primary="lined lists, arrays versus" data-type="indexterm" id="idm45606835477008"/>Practically speaking, on modern CPUs, developers in most cases should prefer contiguous memory data structures like arrays instead of linked lists in their programs. This is because a typical linked-like list implementation (e.g., a tree) uses memory pointers to the next, past, child, or parent elements. This means that when iterating over such a structure, the CPU core can’t tell what data and what instruction we will do next until we visit the node and check that pointer. This effectively limits the speculation capabilities, causing inefficient CPU usage.<a data-startref="ix_ch04-asciidoc14" data-type="indexterm" id="idm45606835475616"/><a data-startref="ix_ch04-asciidoc13" data-type="indexterm" id="idm45606835474944"/><a data-startref="ix_ch04-asciidoc12" data-type="indexterm" id="idm45606835474272"/><a data-startref="ix_ch04-asciidoc11" data-type="indexterm" id="idm45606835473600"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hyper-Threading" data-type="sect2"><div class="sect2" id="ch-hw-ht">&#13;
<h2>Hyper-Threading</h2>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="Hyper-Threading and" data-type="indexterm" id="ix_ch04-asciidoc15"/><a data-primary="Hyper-Threading" data-type="indexterm" id="ix_ch04-asciidoc16"/><a data-primary="memory wall" data-secondary="Hyper-Threading" data-type="indexterm" id="ix_ch04-asciidoc17"/><a data-primary="simultaneous multithreading (SMT)" data-type="indexterm" id="ix_ch04-asciidoc18"/><a data-primary="SMT (simultaneous multithreading)" data-type="indexterm" id="ix_ch04-asciidoc19"/>Hyper-Threading is Intel’s proprietary name for the CPU optimization technique called <a href="https://oreil.ly/L5va6"><em>simultaneous multithreading</em> (SMT)</a>.<sup><a data-type="noteref" href="ch04.html#idm45606835464576" id="idm45606835464576-marker">18</a></sup> Other CPU makers implement SMT too. This method allows a single CPU core to operate in a mode visible to programs and operating systems as two logical CPU cores.<sup><a data-type="noteref" href="ch04.html#idm45606835463680" id="idm45606835463680-marker">19</a></sup> SMT prompts the operating system to schedule two threads onto the same physical CPU core. While a single physical core will never execute more than one instruction at a time, more instructions in the queue help make the CPU core busy during idle times. Given the memory access wait times, this can utilize a single CPU core more without impacting the latency of the process execution. In addition, extra registers in SMT enable CPUs to allow for faster context switches between multiple threads running on a single physical core.</p>&#13;
&#13;
<p>SMT has to be supported and integrated with the operating system. You should see twice as many cores as physical ones in your machine when enabled. To understand if your CPU supports Hyper-Threading, check the “thread(s) per core” information in the specifications. For example, using the <code>lscpu</code> Linux command in <a data-type="xref" href="#code-lscpu">Example 4-4</a>, my CPU has two threads, meaning Hyper-Threading is available.</p>&#13;
<div data-type="example" id="code-lscpu">&#13;
<h5><span class="label">Example 4-4. </span>Output of the <code>lscpu</code> command on my Linux laptop</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting"><code>Architecture:                    x86_64&#13;
CPU op-mode(s):                  32-bit, 64-bit&#13;
Byte Order:                      Little Endian&#13;
Address sizes:                   39 bits physical, 48 bits virtual&#13;
CPU(s):                          12&#13;
On-line CPU(s) list:             0-11&#13;
Thread(s) per core:              2 </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO4-1" id="co_how_go_uses_the_cpu_resource__or_two__CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
Core(s) per socket:              6&#13;
Socket(s):                       1&#13;
NUMA node(s):                    1&#13;
Vendor ID:                       GenuineIntel&#13;
CPU family:                      6&#13;
Model:                           158&#13;
Model name:                      Intel(R) Core(TM) i7-9850H CPU @ 2.60GHz&#13;
CPU MHz:                         2600.000&#13;
CPU max MHz:                     4600.0000&#13;
CPU min MHz:                     800.0000</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO4-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>My CPU supports SMT, and it’s enabled on my Linux installation.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The SMT is usually enabled by default but can be turned to on demand on newer kernels. This poses one consequence when running our Go programs. We can usually choose if we should enable or disable this mechanism for our processes. But should we? In most cases, it is better to keep it enabled for our Go programs as it allows us to fully utilize physical cores when running multiple different tasks on a single computer. Yet, in some extreme cases, it might be worth dedicating full physical core to a single process to ensure the highest quality of service. Generally, a benchmark on each specific hardware should tell us.</p>&#13;
&#13;
<p>To sum up, all the aforementioned CPU optimizations and the corresponding programming techniques utilizing that knowledge tend to be used only at the very end of the optimization cycle and only when we want to squeeze out the last dozen nanoseconds on the critical path.</p>&#13;
<div data-type="tip"><h1>Three Principles of Writing CPU-Efficient Code on Critical Path</h1>&#13;
<p>The three basic rules that will yield CPU-friendly code are as &#13;
<span class="keep-together">follows:</span></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use algorithms that do less work.</p>&#13;
</li>&#13;
<li>&#13;
<p>Focus on writing low-complexity code that will be easier to optimize for the compiler and CPU branch predictors. Ideally, separate “hot” from “cold” code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Favor contiguous memory data structures when you plan to iterate or traverse over them a lot<a data-startref="ix_ch04-asciidoc19" data-type="indexterm" id="idm45606835421760"/><a data-startref="ix_ch04-asciidoc18" data-type="indexterm" id="idm45606835421152"/><a data-startref="ix_ch04-asciidoc17" data-type="indexterm" id="idm45606835420480"/><a data-startref="ix_ch04-asciidoc16" data-type="indexterm" id="idm45606835419808"/><a data-startref="ix_ch04-asciidoc15" data-type="indexterm" id="idm45606835419136"/>.<a data-startref="ix_ch04-asciidoc10" data-type="indexterm" id="idm45606835418336"/><a data-startref="ix_ch04-asciidoc9" data-type="indexterm" id="idm45606835417632"/><a data-startref="ix_ch04-asciidoc8" data-type="indexterm" id="idm45606835416960"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>With this brief understanding of CPU hardware dynamics, let’s dive deeper into the essential software types that allow us to run thousands of programs simultaneously on shared hardware—schedulers.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Schedulers" data-type="sect1"><div class="sect1" id="ch-hw-scheduler">&#13;
<h1>Schedulers</h1>&#13;
&#13;
<p><a data-primary="CPU resource" data-secondary="schedulers" data-type="indexterm" id="ix_ch04-asciidoc20"/><a data-primary="schedulers" data-type="indexterm" id="ix_ch04-asciidoc21"/>Scheduling generally means allocating necessary, usually limited, resources for a certain process to finish. For example, assembling car parts must be tightly scheduled in a certain place at a certain time in a car factory to avoid downtime. We might also need to schedule a meeting among certain attendees with only certain time slots of the day free.</p>&#13;
&#13;
<p>In modern computers or clusters of servers, we have thousands of programs that have to be running on shared resources like CPU, memory, network, disks, etc. That’s why the industry developed many types of scheduling software (commonly called <em>schedulers</em>) focused on allocating these programs to free resources on many levels.</p>&#13;
&#13;
<p>In this section, we will discuss CPU scheduling. Starting from the bottom level, we have an operating system that schedules arbitrary programs on a limited number of physical CPUs. Operating system mechanisms should tell us how multiple programs running simultaneously can impact our CPU resources and, in effect, our own Go program execution latency. It will also help us understand how a developer can utilize multiple CPU cores simultaneously, in parallel or concurrently, to achieve faster execution.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operating System Scheduler" data-type="sect2"><div class="sect2" id="ch-hw-os-scheduler">&#13;
<h2>Operating System Scheduler</h2>&#13;
&#13;
<p><a data-primary="operating system (OS) schedulers" data-type="indexterm" id="ix_ch04-asciidoc22"/><a data-primary="schedulers" data-secondary="operating system schedulers" data-type="indexterm" id="ix_ch04-asciidoc23"/>As with compilers, there are many different operating systems (OSes), each with different task scheduling and resource management logic. While most of the systems operate on similar abstractions (e.g., threads, processes with priorities), we will focus on the Linux operating system in this book. Its core, called the kernel, has many important functionalities, like managing memory, devices, network access, security, and more. It also ensures program execution using a configurable component called a scheduler.</p>&#13;
<blockquote>&#13;
<p>As a central part of resource management, the OS thread scheduler must maintain the following, simple, invariant: make sure that ready threads are scheduled on available cores.</p>&#13;
<p data-type="attribution">J.P. Lozi et al., <a href="https://oreil.ly/bfiEW">“The Linux Scheduler: A Decade of Wasted Cores”</a></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Lozi, J. P., on OS thread scheduler" data-type="indexterm" id="idm45606835402704"/>The smallest scheduling unit for the Linux scheduler is called an <a href="https://oreil.ly/Lp2Sk">OS thread</a>. The thread (sometimes also referred to as a <em>task</em> or <em>lightweight process</em>) contains an independent set of machine code in the form of CPU instructions designed to run sequentially. While threads can maintain their execution state, stack, and register set, they cannot run out of context.</p>&#13;
&#13;
<p>Each thread runs as a part of the process. <a data-primary="PID (Process Identification Number)" data-type="indexterm" id="idm45606835399568"/><a data-primary="Process Identification Number (PID)" data-type="indexterm" id="idm45606835398848"/>The process represents a program in execution and can be identified by its Process Identification Number (PID). When we tell Linux OS to execute our compiled program, a new process is created (for example, when a <a href="https://oreil.ly/IPKYU"><code>fork</code></a> system call is used).</p>&#13;
&#13;
<p>The process creation includes the assignment of a new PID, the creation of the initial thread with its machine code (our <code>func main()</code> in the Go code) and stack, files for standard outputs and input, and tons of other data (e.g., list of open file descriptors, statistics, limits, attributes, mounted items, groups, etc.). On top of that, a new memory address space is created, which has to be protected from other processes. All of that information is maintained under the dedicated directory <em>/proc/<code>&lt;PID&gt;</code></em> for the duration of the program execution.</p>&#13;
&#13;
<p>Threads can create new threads (e.g., using the <a href="https://oreil.ly/6qSg3"><code>clone</code></a> &#13;
<span class="keep-together">syscall) that</span> will have independent machine code sequences but will share the &#13;
<span class="keep-together">same memory</span> address space. Threads can also create new processes (e.g., using <a href="https://oreil.ly/idB06"><code>fork</code></a>) that will run in isolation and execute the desired program. Threads maintain their execution state: Running, Ready, and Blocked. Possible transformations of these states are presented in <a data-type="xref" href="#img-threads">Figure 4-5</a>.</p>&#13;
&#13;
<p>Thread state tells the scheduler what the thread is doing at the moment:</p>&#13;
<dl>&#13;
<dt>Running</dt>&#13;
<dd>&#13;
<p>Thread is assigned to the CPU core and is doing its job.</p>&#13;
</dd>&#13;
<dt>Blocked</dt>&#13;
<dd>&#13;
<p>Thread is waiting on some event that potentially takes longer than a context switch. For example, a thread reads from a network connection and is waiting for a packet or its turn on the mutex lock. This is an opportunity for the scheduler to step in and allow other threads to run.</p>&#13;
</dd>&#13;
<dt>Ready</dt>&#13;
<dd>&#13;
<p>Thread is ready for execution but is waiting for its turn.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="img-threads">&#13;
<img alt="efgo 0405" src="assets/efgo_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>Thread states as seen by the Linux OS scheduler</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you might already notice, the Linux scheduler does a preemptive type of thread scheduling. Preemptive means the scheduler can freeze a thread execution at any time. In modern OS, we always have more threads to be executed than available CPU cores, so the scheduler must run multiple “ready” threads on a single CPU core. The thread is preempted every time it waits for an I/O request or other events. The thread can also tell the operating system to yield itself (e.g., using the <a href="https://oreil.ly/QfnCs"><code>sched_yield</code></a> syscall). When preempted, it enters a “blocked” state, and another thread can take its place in the meantime.</p>&#13;
&#13;
<p>The naive scheduling algorithm could wait for the thread to preempt itself. This would work great for I/O bound threads, which are often in the “Blocked” state—for example, interactive systems with graphical interfaces or lightweight web servers working with network calls. But what if the thread is CPU bound, which means it spends most of its time using only CPU and memory—for example, doing some computation-heavy jobs like linear search, multiplying matrixes, or brute-forcing a hashed password? In such cases, the CPU core could be busy on one task for minutes, which will starve all other threads in the system. For example, imagine not being able to type in your browser or resize a window for a minute—it would look like a long system freeze!</p>&#13;
&#13;
<p><a data-primary="CFS (Completely Fair Scheduler)" data-type="indexterm" id="idm45606835380240"/><a data-primary="Completely Fair Scheduler (CFS)" data-type="indexterm" id="idm45606835379568"/>This primary Linux scheduler implementation addresses that problem. It is called a Completely Fair Scheduler (CFS), and it assigns threads in short turns. Each thread is given a certain slice of the CPU time, typically something between 1 ms and 20 ms, which creates the illusion that threads are running simultaneously. It especially helps desktop systems, which must be responsive to human interactions. There are a few other important consequences of that design:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The more threads that want to be executed, the less time they will have in each turn. However, this can result in lower productive utilization of the CPU core, which starts to spend more time on expensive context switches.</p>&#13;
</li>&#13;
<li>&#13;
<p>On the overloaded machine, each thread has shorter turns on the CPU core and can also end up having fewer turns per second. While none of the threads is completely starved (blocked), their execution can significantly slow down.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>CPU Overloading</h1>&#13;
<p><a data-primary="CPU overloading" data-type="indexterm" id="idm45606835375024"/><a data-primary="overloading" data-type="indexterm" id="idm45606835374320"/>Writing CPU-efficient code means our program wastes significantly fewer CPU cycles. Of course, this is always great, but the efficient implementation might be still doing its job very slowly if the CPU is overloaded.</p>&#13;
&#13;
<p>An overloaded CPU or system means too many threads are competing for the available CPU cores. As a result, the machine might be overscheduled, or a process or two spawns too many threads to perform some heavy task (we call this situation a <em>noisy neighbor</em>). If an overloaded CPU situation occurs, checking the machine CPU utilization metric should show us CPU cores running at 100% capacity. Every thread will be executed slower in such a case, resulting in a frozen system, timeouts, and lack of responsiveness.</p>&#13;
</div>&#13;
</li>&#13;
<li>&#13;
<p>It is hard to rely on pure program execution latency (sometimes referred to as <em>wall time</em> or <em>wall-clock time</em>) to estimate our program CPU efficiency. This is because modern OS schedulers are preemptive, and the program often waits for other I/O or synchronizations. As a result, it’s pretty hard to reliably check if, after a fix, our program utilizes the CPU better than the previous implementation. This is why the industry defined an important metric to gather how long our program’s process (all its threads) spent in the “Running” state on all &#13;
<span class="keep-together">CPU cores.</span> We usually call it CPU time and we will discuss it in <a data-type="xref" href="ch06.html#ch-obs-cpu-usage">“CPU Usage”</a>.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>CPU Time on an Overloaded Machine</h1>&#13;
<p><a data-primary="CPU resource" data-secondary="on overloaded machine" data-type="indexterm" id="idm45606835367280"/>Measuring CPU time is a great way to check our program’s CPU efficiency. However, be careful when looking at the CPU time from some narrow window of process execution time. For example, lower CPU time might mean our process was not using much CPU during that moment, but it might also represent an overloaded CPU.</p>&#13;
</div>&#13;
&#13;
<p>Overall, sharing processes on the same system has its problems. That’s why in virtualized environments, we tend to reserve these resources. For example, we can limit CPU use of one process to 200 milliseconds of CPU time per second, so 20% of one CPU core.</p>&#13;
</li>&#13;
<li>&#13;
<p>The final consequence of the CFS design is that it is too fair to ensure dedicated CPU time for a single thread. The Linux scheduler has priorities, a user-configurable “niceness” flag, and different scheduling policies. Modern Linux OS even has a scheduling policy that uses a special real-time scheduler in place of CFS for threads that need to be executed in the first order.<sup><a data-type="noteref" href="ch04.html#idm45606835364128" id="idm45606835364128-marker">20</a></sup></p>&#13;
&#13;
<p>Unfortunately, even with a real-time scheduler, a Linux system cannot ensure that higher-priority threads will have all the CPU time they need, as it will still try to ensure that low-priority threads are not starved. Furthermore, because both CFS and real-time counterparts are preemptive, they are not deterministic and predictive. As a result, any task with hard real-time requirements (e.g., millisecond trading or airplane software) can’t be guaranteed enough execution time before its deadline. This is why some companies develop their own schedulers or systems for <a href="https://oreil.ly/oVsCz">strict real-time programs</a> like <a href="https://oreil.ly/hV7ym">Zephyr OS</a>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Despite the somewhat complex characteristics of the CFS scheduler, it remains the most popular thread orchestration system available in modern Linux systems. In 2016 the CFS was also overhauled for multicore machines and NUMA architectures, based on findings from <a href="https://oreil.ly/kUEiQ">a famous research paper</a>. As a result, threads are now smartly distributed across idle cores while ensuring migrations are not done too often and not among threads sharing the same resources.<a data-startref="ix_ch04-asciidoc23" data-type="indexterm" id="idm45606835358336"/><a data-startref="ix_ch04-asciidoc22" data-type="indexterm" id="idm45606835357632"/></p>&#13;
&#13;
<p>With a basic understanding of the OS scheduler, let’s dive into why the Go scheduler exists and how it enables developers to program multiple tasks to run concurrently on single or multiple CPU cores.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Go Runtime Scheduler" data-type="sect2"><div class="sect2" id="ch-hw-concurrency">&#13;
<h2>Go Runtime Scheduler</h2>&#13;
&#13;
<p><a data-primary="Go runtime scheduler" data-type="indexterm" id="ix_ch04-asciidoc24"/><a data-primary="runtime scheduler" data-type="indexterm" id="ix_ch04-asciidoc25"/><a data-primary="schedulers" data-secondary="Go runtime scheduler" data-type="indexterm" id="ix_ch04-asciidoc26"/>The Go concurrency framework is built on the premise that it’s hard for a single flow of CPU instructions (e.g., function) to utilize all CPU cycles due to the I/O-bound nature of the typical workflow. <a data-primary="goroutine" data-secondary="Go runtime scheduler and" data-type="indexterm" id="ix_ch04-asciidoc27"/>While OS thread abstraction mitigates this by multiplexing threads into a set of CPU cores, the Go language brings another layer—a <em>goroutine</em>—that multiplexes functions on top of a set of threads. The <a href="https://oreil.ly/TClXu">idea for goroutines</a> is similar to <a href="https://oreil.ly/t7oXZ">coroutines</a>, but since it is not the same (goroutines can be preempted) and since it’s in Go language, it has the <em>go</em> prefix. Similar to the OS thread, when the goroutine is blocked on a system call or I/O, the Go scheduler (not OS!) can quickly switch to a different goroutine, which will resume on the same thread (or a different one if needed).</p>&#13;
<blockquote>&#13;
<p>Essentially, Go has turned I/O-bound work [on the application level] into CPU-bound work at the OS level. Since all the context switching is happening at the application level, we don’t lose the same 12K instructions (on average) per context switch that we were losing when using threads. In Go, those same context switches are costing you 200 nanoseconds or 2.4K instructions. The scheduler is also helping with gains on cache-line efficiencies and NUMA. This is why we don’t need more threads than we have virtual cores.</p>&#13;
<p data-type="attribution">William Kennedy, <a href="https://oreil.ly/Z4sRA">“Scheduling in Go: Part II—Go Scheduler”</a></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Kennedy, William" data-secondary="on context switching" data-type="indexterm" id="idm45606835343040"/>As a result, we have in Go very cheap execution “threads” in the user space (a new goroutine only allocates a few kilobytes for the initial, local stack), which reduce the number of competing threads in our machine and allow hundreds of goroutines in our program without extensive overhead. Just one OS thread per CPU core should be enough to get all the work in our goroutines done.<sup><a data-type="noteref" href="ch04.html#idm45606835341536" id="idm45606835341536-marker">21</a></sup> This enables many readability patterns—like event loops, map-reduce, pipes, iterators, and more—without involving more expensive kernel multithreading.</p>&#13;
<div data-type="tip">&#13;
<p>Using Go concurrency in the form of goroutines is an excellent way to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Represent complex asynchronous abstractions (e.g., events)</p>&#13;
</li>&#13;
<li>&#13;
<p>Utilize our CPU to the fullest for I/O-bound tasks</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a multithreaded application that can utilize multiple CPUs to execute faster</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>Starting another goroutine is very easy in Go. It is built in the language via a <code>go &lt;func&gt;()</code> syntax. <a data-type="xref" href="#code-goroutine">Example 4-5</a> shows a function that starts two goroutines and finishes its work.</p>&#13;
<div data-type="example" id="code-goroutine">&#13;
<h5><span class="label">Example 4-5. </span>A function that starts two goroutines</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">anotherFunction</code><code class="p">(</code><code class="nx">arg1</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/*...*/</code><code class="w"> </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">function</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="c1">// ... </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO5-1" id="co_how_go_uses_the_cpu_resource__or_two__CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">      </code><code class="c1">// ... </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO5-2" id="co_how_go_uses_the_cpu_resource__or_two__CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">anotherFunction</code><code class="p">(</code><code class="s">"argument1"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO5-3" id="co_how_go_uses_the_cpu_resource__or_two__CO5-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
&#13;
   </code><code class="k">return</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO5-4" id="co_how_go_uses_the_cpu_resource__or_two__CO5-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO5-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The scope of the current goroutine.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO5-2" id="callout_how_go_uses_the_cpu_resource__or_two__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The scope of a new goroutine that will run concurrently any moment now.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO5-3" id="callout_how_go_uses_the_cpu_resource__or_two__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>anotherFunction</code> will start running concurrently any moment now.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO5-4" id="callout_how_go_uses_the_cpu_resource__or_two__CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>When <code>function</code> terminates, the two goroutines we started can still run.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>It’s important to remember that all goroutines have a flat hierarchy between each other. Technically, there is no difference when goroutine <code>A</code> started <code>B</code> or <code>B</code> started <code>A</code>. &#13;
<span class="keep-together">In both</span> cases, both <code>A</code> and <code>B</code> goroutines are equal, and they don’t know about each other.<sup><a data-type="noteref" href="ch04.html#idm45606835218752" id="idm45606835218752-marker">22</a></sup> They also cannot stop each other unless we implement explicit communication or synchronization and “ask” the goroutine to shut down. The only exception is the main goroutine that starts with the <code>main()</code> function. If the main goroutine finishes, the whole program terminates, killing all other goroutines forcefully.</p>&#13;
&#13;
<p>Regarding communication, goroutines, similarly to OS threads, have access to the same memory space within the process. This means that we can pass data between goroutines using shared memory. However, this is not so trivial because almost no operation in Go is atomic. Concurrent writing (or writing and reading) from the same memory can cause data races, leading to nondeterministic behavior or even data corruption. To solve this, we need to use synchronization techniques like explicit atomic function (as presented in <a data-type="xref" href="#code-goroutine-atomic">Example 4-6</a>) or mutex (as shown in <a data-type="xref" href="#code-goroutine-mutex">Example 4-7</a>), so in other words, a lock.</p>&#13;
<div data-type="example" id="code-goroutine-atomic">&#13;
<h5><span class="label">Example 4-6. </span>Safe multigoroutine communication through dedicated atomic addition</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">sharingWithAtomic</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">sum</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO6-1" id="co_how_go_uses_the_cpu_resource__or_two__CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
   </code><code class="nx">concurrentFn</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">      </code><code class="nx">atomic</code><code class="p">.</code><code class="nx">AddInt64</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">sum</code><code class="p">,</code><code class="w"> </code><code class="nx">randInt64</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">      </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">   </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="nx">sum</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO6-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Notice that while we use atomic to synchronize additions between <code>concurrentFn</code> goroutines, we use additional <code>sync.WaitGroup</code> (another form of locking) to wait for all these goroutines to finish. We do the same in <a data-type="xref" href="#code-goroutine-mutex">Example 4-7</a>.</p></dd>&#13;
</dl></div>&#13;
<div data-type="example" id="code-goroutine-mutex">&#13;
<h5><span class="label">Example 4-7. </span>Safe multigoroutine communication through mutex (lock)</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">sharingWithMutex</code><code class="p">()</code><code class="w"> </code><code class="p">(</code><code class="nx">sum</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"/>&#13;
<code class="w">   </code><code class="kd">var</code><code class="w"> </code><code class="nx">mu</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">Mutex</code><code class="w"/>&#13;
&#13;
<code class="w">   </code><code class="nx">concurrentFn</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">mu</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">randInt64</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">mu</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">   </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">   </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">()</code><code class="w"/>&#13;
&#13;
<code class="w">   </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="nx">sum</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre></div>&#13;
&#13;
<p>The choice between atomic and lock depends on readability, efficiency requirements, and what operation you want to synchronize. For example, if you want to concurrently perform a simple operation on a number like value write or read, addition, substitution, or compare and swap, you can consider the <a href="https://oreil.ly/NZnXr">atomic package</a>. Atomic is often more efficient than mutexes (lock) since the compiler will translate them into special <a href="https://oreil.ly/8g0yM">atomic CPU operations</a> that can change data under a single memory address in a thread-safe way.<sup><a data-type="noteref" href="ch04.html#idm45606834944896" id="idm45606834944896-marker">23</a></sup></p>&#13;
&#13;
<p class="fix_tracking">If, however, using atomic impacts the readability of our code, the code is not on a critical path, or we have a more complex operation to synchronize, we can use a lock. Go offers <code>sync.Mutex</code>, which allows simple locking, and <code>sync.RWMutex</code>, which allows locking for reads (<code>RLock()</code>) and writes (<code>Lock()</code>). If you have many goroutines that do not modify shared memory, lock them with <code>RLock()</code> so there is no lock contention between them, since concurrent read of shared memory is safe. Only when a goroutine wants to modify that memory can it acquire a full lock using <code>Lock()</code> that will block all readers.</p>&#13;
&#13;
<p>On the other hand, lock and atomic are not the only choices. The Go language has another ace in its hand on this subject. <a data-primary="Communicating Sequential Processes (CSP)" data-type="indexterm" id="idm45606834939120"/><a data-primary="Hoare, C. A. R., on CSP paradigm" data-type="indexterm" id="idm45606834938560"/>On top of the coroutine concept, Go also utilizes <a href="https://oreil.ly/5KXA9">&#13;
<span class="keep-together">C. A. R.</span> Hoare’s Communicating Sequential Processes (CSP)</a> paradigm, which can also be seen as a type-safe generalization of Unix pipes.</p>&#13;
<blockquote>&#13;
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>&#13;
<p data-type="attribution"><a href="https://oreil.ly/G4Lmq">“Effective Go”</a></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="channels" data-type="indexterm" id="ix_ch04-asciidoc28"/>This model encourages sharing data by implementing a communication pipeline between goroutines using a channel concept. Sharing the same memory address to pass some data requires extra synchronization. However, suppose one goroutine sends that data to some channel, and another receives it. In that case, the whole flow naturally synchronizes itself, and shared data is never accessed by two goroutines simultaneously, ensuring thread safety.<sup><a data-type="noteref" href="ch04.html#idm45606834933072" id="idm45606834933072-marker">24</a></sup> Example channel communication is presented in <a data-type="xref" href="#code-goroutine-channel">Example 4-8</a>.</p>&#13;
<div data-type="example" id="code-goroutine-channel">&#13;
<h5><span class="label">Example 4-8. </span>An example of memory-safe multigoroutine communication through the channel</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">sharingWithChannel</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">sum</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="nx">result</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO7-1" id="co_how_go_uses_the_cpu_resource__or_two__CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
   </code><code class="nx">concurrentFn</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">      </code><code class="c1">// ...</code><code class="w">&#13;
</code><code class="w">      </code><code class="nx">result</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">randInt64</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO7-2" id="co_how_go_uses_the_cpu_resource__or_two__CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">go</code><code class="w"> </code><code class="nx">concurrentFn</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">3</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO7-3" id="co_how_go_uses_the_cpu_resource__or_two__CO7-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
      </code><code class="nx">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">result</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO7-4" id="co_how_go_uses_the_cpu_resource__or_two__CO7-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">   </code><code class="nb">close</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_how_go_uses_the_cpu_resource__or_two__CO7-5" id="co_how_go_uses_the_cpu_resource__or_two__CO7-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
   </code><code class="k">return</code><code class="w"> </code><code class="nx">sum</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO7-1" id="callout_how_go_uses_the_cpu_resource__or_two__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Channel can be created in Go with the <code>ch := make(chan &lt;type&gt;, &lt;buffer size&gt;)</code> syntax.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO7-2" id="callout_how_go_uses_the_cpu_resource__or_two__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We can send values of a given type to our channel.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO7-3" id="callout_how_go_uses_the_cpu_resource__or_two__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Notice that in this example, we don’t need <code>sync.WaitGroup</code> since we abuse the knowledge of how many exact messages we expect to receive. If we did not have that information, we would need a waiting group or another mechanism.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO7-4" id="callout_how_go_uses_the_cpu_resource__or_two__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We can read values of a given type from our channel.</p></dd>&#13;
<dt><a class="co" href="#co_how_go_uses_the_cpu_resource__or_two__CO7-5" id="callout_how_go_uses_the_cpu_resource__or_two__CO7-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Channels should also be closed if we don’t plan to send anything through them anymore. This releases resources and unblocks certain receiving and sending flows (more on that later).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="fix_tracking">The important aspect of channels is that they can be buffered. In such a case, it behaves like a queue. If we create a channel with, e.g., a buffer of three elements, a sending goroutine can send exactly three elements before it gets blocked until someone reads from this channel. If we send three elements and close the channel, the receiving goroutine can still read three elements before noticing the channel was closed. A channel can be in three states. It’s important to remember how the goroutine sending or receiving from this channel behaves when switching between these states:</p>&#13;
<dl>&#13;
<dt>Allocated, open channel</dt>&#13;
<dd>&#13;
<p>If we create a channel using <code>make(chan &lt;type&gt;)</code>, it’s allocated and open from the start. Assuming no buffer, such a channel will block an attempt to send a value until another goroutine receives it or when we use the <code>select</code> statement with multiple cases. Similarly, the channel receive will block until someone sends to that channel unless we receive in a <code>select</code> statement with multiple cases or the channel was closed.</p>&#13;
</dd>&#13;
<dt>Closed channel</dt>&#13;
<dd>&#13;
<p>If we <code>close(ch)</code> the allocated channel, a send to that channel will cause panic and receives will return zero values immediately. This is why it is recommended to keep responsibility for the closing channel in the goroutine that sends the data (sender).</p>&#13;
</dd>&#13;
<dt>Nil channel</dt>&#13;
<dd>&#13;
<p>If you define channel type (<code>var ch chan &lt;type&gt;</code>) without allocating it using <code>make(chan &lt;type&gt;)</code>, our channel is nil. We can also “nil” an allocated channel by assigning nil (<code>ch = nil</code>). In this state, sending and receiving will block forever. Practically speaking, it’s rarely useful to nil channels.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Go channels is an amazing and elegant paradigm that allows for building very readable, event-based concurrency patterns. However, in terms of CPU efficiency, they might be the least efficient compared to the <code>atomic</code> package and mutexes. Don’t let that discourage you! For most practical applications (if not overused!), channels can structure our application into robust and efficient concurrent implementation. We will explore some practical patterns of using channels in <a data-type="xref" href="ch10.html#ch-opt-latency-concurrency-example">“Optimizing Latency Using Concurrency”</a>.<a data-startref="ix_ch04-asciidoc28" data-type="indexterm" id="idm45606834713344"/></p>&#13;
&#13;
<p>Before we finish this section, it’s important to understand how we can tune concurrency efficiency in the Go program. Concurrency logic is implemented by the Go scheduler in the <a href="https://oreil.ly/q3iCp">Go runtime package</a>, which is also responsible for other things like garbage collection (see <a data-type="xref" href="ch05.html#ch-hw-garbage">“Garbage Collection”</a>), &#13;
<span class="keep-together">profiles, or</span> stack framing. The Go scheduler is pretty automatic. There aren’t many configuration flags. As it stands at the current moment, there are two practical ways developers can control concurrency in their code:<sup><a data-type="noteref" href="ch04.html#idm45606834709824" id="idm45606834709824-marker">25</a></sup></p>&#13;
<dl>&#13;
<dt>A number of goroutines</dt>&#13;
<dd>&#13;
<p>As developers, we usually control how many goroutines we create in our program. Spawning them for every small workpiece is usually not the best idea, so don’t overuse them. It’s also worth noting that many abstractions from standard or third-party libraries can spawn goroutines, especially those that require <code>Close</code> or cancellation. Notably, common operations like <code>http.Do</code>, <code>context.WithCancel</code>, and <code>time.After</code> create goroutines. If used incorrectly, the goroutines can be easily leaked (leaving orphan goroutines), which typically wastes memory and CPU effort. We will explore ways to debug numbers and snapshots of goroutines in <a data-type="xref" href="ch09.html#ch-obs-pprof-goroutine">“Goroutine”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip"><h1>First Rule of Efficient Code</h1>&#13;
<p><a data-primary="First Rule of Efficient Code" data-type="indexterm" id="idm45606834702512"/>Always close or release the resources you use. Sometimes simple structures can cause colossal and unbounded waste of memory and goroutines if we forget to close them. We will explore common examples in <a data-type="xref" href="ch11.html#ch-basic-leaks">“Don’t Leak Resources”</a>.</p>&#13;
</div>&#13;
<dl>&#13;
<dt><code>GOMAXPROCS</code></dt>&#13;
<dd>&#13;
<p><a data-primary="GOMAXPROCS environmental variable" data-type="indexterm" id="idm45606834699056"/>This important environmental variable can be set to control the number of virtual CPUs you want to leverage in your Go program. The same configuration value can be applied via the <code>runtime.GOMAXPROCS(n)</code> function. The underlying logic on how the Go scheduler uses this variable is fairly complex,<sup><a data-type="noteref" href="ch04.html#idm45606834697536" id="idm45606834697536-marker">26</a></sup> but it generally controls how many parallel OS thread executions Go can expect (internally called a “proc” number). The Go scheduler will then maintain <code>GOMAXPROCS/proc</code> number of queues and try to distribute goroutines among them. The default value of <code>GOMAXPROCS</code> is always the number of virtual CPU cores your OS exposes, and that is typically what will give you the best performance. Trim the <code>GOMAXPROCS</code> value down if you want your Go program to use fewer CPU cores (less parallelism) in exchange for potentially higher latency.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip"><h1>Recommended GOMAXPROCS Configuration</h1>&#13;
<p>Set <code>GOMAXPROCS</code> to the number of virtual cores you want your Go program to utilize at once. Typically, we want to use the whole machine; thus, the default value should work.</p>&#13;
&#13;
<p>For virtualized environments, especially using lightweight virtualization mechanisms like containers, use <a href="https://oreil.ly/ysr40">Uber’s <code>automaxprocs</code> library</a>, which will adjust <code>GOMAXPROCS</code> based on the Linux CPU limits the container is allowed to use, which is often what we want.</p>&#13;
</div>&#13;
&#13;
<p>Multitasking is always a tricky concept to introduce into a language. I believe the &#13;
<span class="keep-together">goroutines</span> with channels in Go are quite an elegant solution to this problem, which allows many readable programming patterns without sacrificing efficiency. We will explore practical concurrency patterns in <a data-type="xref" href="ch10.html#ch-opt-latency-concurrency-example">“Optimizing Latency Using Concurrency”</a>, by improving the latency of <a data-type="xref" href="#code-sum">Example 4-1</a> presented in this chapter<a data-startref="ix_ch04-asciidoc27" data-type="indexterm" id="idm45606834686912"/><a data-startref="ix_ch04-asciidoc26" data-type="indexterm" id="idm45606834686240"/><a data-startref="ix_ch04-asciidoc25" data-type="indexterm" id="idm45606834685568"/>.<a data-startref="ix_ch04-asciidoc24" data-type="indexterm" id="idm45606834684768"/><a data-startref="ix_ch04-asciidoc21" data-type="indexterm" id="idm45606834684064"/></p>&#13;
&#13;
<p>Let’s now look into when concurrency might be useful in our Go programs.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to Use Concurrency" data-type="sect1"><div class="sect1" id="ch-hw-concurrency-when">&#13;
<h1>When to Use Concurrency</h1>&#13;
&#13;
<p><a data-primary="concurrency" data-secondary="CPU resource and" data-type="indexterm" id="ix_ch04-asciidoc29"/><a data-primary="CPU resource" data-secondary="concurrency and" data-type="indexterm" id="ix_ch04-asciidoc30"/>As with any efficiency optimization, the same classic rules apply when transforming a single goroutine code to a concurrent one. No exceptions here. We have to focus on the goal, apply the TFBO loop, benchmark early, and look for the biggest bottleneck. As with everything, adding concurrency has trade-offs, and there are cases where we should avoid it. Let’s summarize the practical benefits and disadvantages of concurrent code versus sequential:</p>&#13;
<dl>&#13;
<dt>Advantages</dt>&#13;
<dd>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="concurrency" data-secondary="advantages" data-type="indexterm" id="idm45606834677072"/>Concurrency allows us to speed up the work by splitting it into pieces and executing each part concurrently. As long as the synchronization and shared resources are not a significant bottleneck, we should expect an improved latency.</p>&#13;
</li>&#13;
<li>&#13;
<p>Because the Go scheduler implements an efficient preemptive mechanism, concurrency improves CPU core utilization for I/O-bound tasks, which should translate into lower latency, even with a <code>GOMAXPROCS=1</code> (a single CPU core).</p>&#13;
</li>&#13;
<li>&#13;
<p>Especially in virtual environments, we often reserve a certain CPU time for our programs. Concurrency allows us to distribute work across available CPU time in a more even way.</p>&#13;
</li>&#13;
<li>&#13;
<p>For some cases, like asynchronous programming and event handling, concurrency represents a problem domain well, resulting in improved readability despite some complexities. Another example is the HTTP server. Treating each HTTP incoming request as a separate goroutine not only allows efficient CPU core utilization but also naturally fits into how code should be read and &#13;
<span class="keep-together">understood.</span></p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
<dt>Disadvantages</dt>&#13;
<dd>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="concurrency" data-secondary="disadvantages" data-type="indexterm" id="idm45606834669776"/>Concurrency adds significant complexity to the code, especially when we transform existing code into concurrency (instead of building API around channels from day one). This hits readability since it almost always obfuscates execution flow, but even worse, it limits the developer’s ability to predict all edge cases and potential bugs. This is one of the main reasons why I recommend postponing adding concurrency as long as possible. And once you have to introduce concurrency, use as few channels as possible for the given problem.</p>&#13;
</li>&#13;
<li>&#13;
<p>With concurrency, there is a risk of saturating resources due to unbounded concurrency (uncontrolled amount of goroutines in a single moment) or leaking goroutines (orphan goroutines). This is something we also need to care about and test against (more on this in <a data-type="xref" href="ch11.html#ch-basic-leaks">“Don’t Leak Resources”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Despite Go’s very efficient concurrency framework, goroutines and channels are not free of overhead. If used wrongly, it can impact our code efficiency. Focus on providing enough work to each goroutine that will justify its cost. Benchmarks are a must-have.</p>&#13;
</li>&#13;
<li>&#13;
<p>When using concurrency, we suddenly add three more nontrivial tuning parameters into our program. We have a <code>GOMAXPROCS</code> setting, and depending on how we implement things, we can control the number of goroutines we spawn and how large a buffer of the channel we should have. Finding correct numbers requires hours of benchmarking and is still prone to errors.<a data-startref="ix_ch04-asciidoc30" data-type="indexterm" id="idm45606834663888"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Concurrent code is hard to benchmark because it depends even more on the environment, possible noisy neighbors, multicore settings, OS version, and so on. On the other hand, sequential, single-core code has much more deterministic and portable performance, which is easier to prove and compare against.</p>&#13;
</li>&#13;
</ul>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>As we can see, using concurrency is not the cure for all performance problems. It’s just another tool in our hands that we can use to fulfill our efficiency goals.</p>&#13;
<div data-type="tip"><h1>Adding Concurrency Should Be One of Our Last Deliberate Optimizations to Try</h1>&#13;
<p>As per our TFBO cycle, if you are still not meeting your RAERs, e.g., in terms of speed, make sure you try more straightforward optimization techniques before adding concurrency. The rule of thumb is to think about concurrency when our CPU profiler (explained in <a data-type="xref" href="ch09.html#ch-observability3">Chapter 9</a>) shows that our program spends CPU time only on things that are crucial to our functionality. Ideally, before we hit our readability limit, is the most efficient way we know.</p>&#13;
&#13;
<p>The mentioned list of disadvantages is one reason, but the second is that our program’s characteristics might differ after basic (without concurrency) optimizations. For example, we thought our task was CPU bound, but after improvements, we may find most of the time is now spent waiting on I/O. Or we might realize we did not need the heavy concurrency changes after all.<a data-startref="ix_ch04-asciidoc29" data-type="indexterm" id="idm45606834658416"/><a data-startref="ix_ch04-asciidoc20" data-type="indexterm" id="idm45606834657712"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45606834656656">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>The modern CPU hardware is a nontrivial component that allows us to run our software efficiently. With ongoing operating systems, Go language development, and advancements in hardware, only more optimization techniques and complexities will arise to decrease running costs and increase processing power.</p>&#13;
&#13;
<p>In this chapter, I hopefully gave you basics that will help you optimize your usage of CPU resources and, generally, your software execution speed. First, we discussed the Assembly language and how it can be useful during Go development. Then, we explored Go compiler functionalities, optimizations, and ways to debug its execution.</p>&#13;
&#13;
<p>Later, we jumped into the main challenge for CPU execution: memory access latency in modern systems. Finally, we discussed the various low-level optimizations like L-caches, pipelining, CPU branch prediction, and Hyper-Threading.</p>&#13;
&#13;
<p>Last, we explored the practical problems of executing our programs in production systems. Unfortunately, our machine’s program is rarely the only process, so efficient execution matters. Finally, we summarized Go’s concurrency framework’s benefits and disadvantages.</p>&#13;
&#13;
<p>In practice, CPU resource is essential to optimize in modern infrastructure to achieve faster execution and the ability to pay less for our workloads. Unfortunately, CPU resource is only one aspect. For example, our choice optimization might prefer using more memory to reduce CPU usage or vice versa.</p>&#13;
&#13;
<p>As a result, our programs typically use a lot of memory resources (plus I/O traffic through disk or network). While execution is tied to CPU resources like memory and I/O, it might be the first on our list of optimizations depending on what we want (e.g., cheaper execution, faster execution, or both). Let’s discuss the memory resource in the next chapter.<a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm45606834651968"/></p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45606836099536"><sup><a href="ch04.html#idm45606836099536-marker">1</a></sup> To be technically strict, modern computers nowadays have distinct caches for program instructions and data, while both are stored the same on the main memory. This is the so-called modified Harvard architecture. At the optimization levels we aim for in this book, we can safely skip this level of detail.</p><p data-type="footnote" id="idm45606835882864"><sup><a href="ch04.html#idm45606835882864-marker">2</a></sup> For scripted (interpreted) languages, there is no complete code compilation. Instead, there is an interpreter that compiles the code statement by statement. Another unique type of language is represented by a family of languages that use Java Virtual Machine (JVM). Such a machine can dynamically switch from interpreting to just-in-time (JIT) compilation for runtime optimizations.</p><p data-type="footnote" id="idm45606835843408"><sup><a href="ch04.html#idm45606835843408-marker">3</a></sup> Similar output to <a data-type="xref" href="#code-sum-asm">Example 4-2</a> can be obtained by compiling the source code to Assembly using <code>go build  <span class="keep-together">-gcflags</span> <em>-S</em> &lt;source&gt;</code>.</p><p data-type="footnote" id="idm45606835798912"><sup><a href="ch04.html#idm45606835798912-marker">4</a></sup> Note that in the Go Assembly register, names are abstracted for portability. Since we will compile to 64-bit architecture, <code>SP</code> and <code>SI</code> will mean RSP and RSI registers.</p><p data-type="footnote" id="idm45606835763760"><sup><a href="ch04.html#idm45606835763760-marker">5</a></sup> There can be incompatibilities, but mostly with special-purpose instructions like cryptographic or SIMD instructions, which can be checked at runtime if they are available before execution.</p><p data-type="footnote" id="idm45606835723216"><sup><a href="ch04.html#idm45606835723216-marker">6</a></sup> Note that the structure methods, from a compiler perspective, are just functions, with the first argument being that structure, so the same inlining technique applies here.</p><p data-type="footnote" id="idm45606835721776"><sup><a href="ch04.html#idm45606835721776-marker">7</a></sup> A function call needs more CPU instructions since the program has to pass argument variables and return parameters through the stack, keep the current function’s state, rewind the stack after the function call, add the new frame stack, etc.</p><p data-type="footnote" id="idm45606835712848"><sup><a href="ch04.html#idm45606835712848-marker">8</a></sup> Go tooling allows us to check the state of our program through each optimization in the SSA form thanks to the <code>GOSSAFUNC</code> environment variable. It’s as easy as building our program with <code>GOSSAFUNC=&lt;function to see&gt; go build</code> and opening the resulting <em>ssa.html</em> file. You can read more about it <a href="https://oreil.ly/32Zbd">here</a>.</p><p data-type="footnote" id="idm45606835698096"><sup><a href="ch04.html#idm45606835698096-marker">9</a></sup> You can unpack it with the <code>tar &lt;archive&gt;</code> or <code>go tool pack e &lt;archive&gt;</code> command. Go archive typically contains the object file and package metadata in the <em>__.PKGDEF</em> file.</p><p data-type="footnote" id="idm45606835689456"><sup><a href="ch04.html#idm45606835689456-marker">10</a></sup> However, there are <a href="https://oreil.ly/xoijc">discussions to remove</a> it from the default building process.</p><p data-type="footnote" id="idm45606835684112"><sup><a href="ch04.html#idm45606835684112-marker">11</a></sup> <a href="https://oreil.ly/E7FJI">Bound check elimination</a> is not explained in this book, as it’s a rare optimization idea.</p><p data-type="footnote" id="idm45606835565472"><sup><a href="ch04.html#idm45606835565472-marker">12</a></sup> This is very often used in standard libraries for critical code.</p><p data-type="footnote" id="idm45606835552784"><sup><a href="ch04.html#idm45606835552784-marker">13</a></sup> On top of SISD and SIMD, Flynn’s taxonomy also specifies MISD, which describes performing multiple instructions on the same data, and MIMD, which describes full parallelism. MISD is rare and only happens when reliability is important. For example, four flight control computers perform exactly the same computations for quadruple error checks in every NASA space shuttle. MIMD, on the other hand, is more common thanks to multicore or even multi-CPU designs.</p><p data-type="footnote" id="idm45606835540240"><sup><a href="ch04.html#idm45606835540240-marker">14</a></sup> This is why we see specialized chips (called Neural Processing Units, or NPUs) appearing in the commodity devices—for example, Tensor Processing Unit (TPU) in Google phones, A14 Bionic chip in iPhones, and dedicated NPU in the M1 chip in Apple laptops.</p><p data-type="footnote" id="idm45606835530224"><sup><a href="ch04.html#idm45606835530224-marker">15</a></sup> Sizes of caches can vary. Example sizes are taken from my laptop. You can check the sizes of your CPU caches in Linux by using the <code>sudo dmidecode -t cache</code> command.</p><p data-type="footnote" id="idm45606835511424"><sup><a href="ch04.html#idm45606835511424-marker">16</a></sup> If a CPU can in total perform up to one instruction per cycle (IPC ⇐ 1), we call it a scalar CPU. Most modern CPU cores have IPC ⇐ 1, but one CPU has more than one core, which makes IPC &gt; 1. This makes these CPUs superscalar. IPC has quickly become a performance metric for CPUs.</p><p data-type="footnote" id="idm45606835495520"><sup><a href="ch04.html#idm45606835495520-marker">17</a></sup> Huge cost is not an overstatement. <a data-primary="context switch" data-type="indexterm" id="idm45606835494960"/>Latency of context switch depends on many factors, but it was measured that in the best case, direct latency (including operating system switch latency) is around 1,350  <span class="keep-together">nanoseconds—2,200</span> nanoseconds if it has to migrate to a different core. This is only a direct latency, from the end of one thread to the start of another. The total latency that would include the indirect cost in the form of cache and pipeline warm-up could be as high as 10,000 nanoseconds (and this is what we see in <a data-type="xref" href="app01.html#table-napkin-math">Table A-1</a>). During this time, we could compute something like 40,000 instructions.</p><p data-type="footnote" id="idm45606835464576"><sup><a href="ch04.html#idm45606835464576-marker">18</a></sup> In some sources, this technique is also called CPU threading (aka hardware threads). I will avoid this terminology in this book due to possible confusion with operating system threads.</p><p data-type="footnote" id="idm45606835463680"><sup><a href="ch04.html#idm45606835463680-marker">19</a></sup> Do not confuse Hyper-Threading logical cores with virtual CPUs (vCPUs) referenced when we use virtualizations like virtual machines. Guest operating systems use the machine’s physical or logical CPUs depending on host choice, but in both cases, they are called vCPUs.</p><p data-type="footnote" id="idm45606835364128"><sup><a href="ch04.html#idm45606835364128-marker">20</a></sup> There are <a href="https://oreil.ly/8OPW3">lots of good materials</a> about tuning up the operating system. Many virtualization mechanisms, like containers with orchestrating systems like Kubernetes, also have their notion of priorities and affinities (pinning processes to specific cores or machines). In this book, we focus on writing efficient code, but we must be aware that execution environment tuning has an important role in ensuring quick and reliable program  <span class="keep-together">executions.</span></p><p data-type="footnote" id="idm45606835341536"><sup><a href="ch04.html#idm45606835341536-marker">21</a></sup> Details around Go runtime implementing Go scheduling <a href="https://oreil.ly/G9bFb">are pretty impressive</a>. Essentially, Go does everything to keep the OS thread busy (spinning the OS thread) so it’s not moving to a blocking state as long as possible. If needed, it can steal goroutines from other threads, poll networks, etc., to ensure we keep the CPU busy so the OS does not preempt the Go process.</p><p data-type="footnote" id="idm45606835218752"><sup><a href="ch04.html#idm45606835218752-marker">22</a></sup> In practice, there are ways to get this information using debug tracing. However, we should not rely on the program knowing which goroutine is a parent goroutine for normal execution flow.</p><p data-type="footnote" id="idm45606834944896"><sup><a href="ch04.html#idm45606834944896-marker">23</a></sup> Funny enough, even atomic operations on CPU require some kind of locking. The difference is that instead of specialized locking mechanisms like <a href="https://oreil.ly/ZKXuN">spinlock</a>, atomic instruction can use faster <a href="https://oreil.ly/9jchk">memory bus lock</a>.</p><p data-type="footnote" id="idm45606834933072"><sup><a href="ch04.html#idm45606834933072-marker">24</a></sup> Assuming the programmer keeps to that rule. There is a way to send a pointer variable (e.g., <code>*string</code>) that points to shared memory, which violates the rule of sharing information through communicating.</p><p data-type="footnote" id="idm45606834709824"><sup><a href="ch04.html#idm45606834709824-marker">25</a></sup> I omitted two additional mechanisms on purpose. First of all, <code>runtime.Gosched()</code> exists, which allows yielding the current goroutine so others can do some work in the meantime. This command is less useful nowadays since the current Go scheduler is preemptive, and manual yielding has become impractical. The second interesting operation, <code>runtime.LockOSThread()</code>, sounds useful, but it’s not designed for efficiency; rather, it pins the goroutine to the OS thread so we can read certain OS thread states from it.</p><p data-type="footnote" id="idm45606834697536"><sup><a href="ch04.html#idm45606834697536-marker">26</a></sup> I recommend watching <a href="https://oreil.ly/LoFiH">Chris Hines’s talk from GopherCon 2019</a> to learn the low-level details around the Go scheduler.</p></div></div></section></body></html>