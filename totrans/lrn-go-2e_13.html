<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. The Standard Library"><div class="chapter" id="unique_chapter_id_13">
<h1><span class="label">Chapter 13. </span>The Standard Library</h1>


<p>One of the best parts of developing with Go is being able to take advantage of its standard library. Like Python, it has a “batteries included” philosophy, providing many of the tools that you need to build an application. Since Go is a relatively new language, it ships with a library that is focused on problems faced in modern programming environments.</p>

<p>I can’t cover all the standard library packages, and luckily, I don’t have to, as there are many excellent sources of information on the standard library, <a data-type="indexterm" data-primary="standard library" data-secondary="documentation URL" id="id2546"/><a data-type="indexterm" data-primary="resources online" data-secondary="standard library documentation" id="id2547"/>starting with the <a href="https://oreil.ly/g970a">documentation</a>. Instead, I’ll focus on several of the most important packages and how their design and use demonstrate the principles of idiomatic Go. Some packages (<code>errors</code>, <code>sync</code>, <code>context</code>, <code>testing</code>, <code>reflect</code>, and <code>unsafe</code>) are covered in their own chapters. In this chapter, you’ll look at Go’s built-in support for I/O, time, JSON, and HTTP.</p>






<section data-type="sect1" data-pdf-bookmark="io and Friends"><div class="sect1" id="io_friends">
<h1>io and Friends</h1>

<p>For a program to be useful, it needs<a data-type="indexterm" data-primary="standard library" data-secondary="io package" id="ch13-io"/><a data-type="indexterm" data-primary="io package" id="ch13-io2"/> to read in and write out data. The heart of Go’s input/output philosophy can be found in the <code>io</code> package. <a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" id="ch13-iorw"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Writer" id="ch13-iorw2"/>In particular, two interfaces defined in this package are probably the second and third most-used interfaces in Go: <code>io.Reader</code> and <code>io.Writer</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>What’s number one? That’d be <code>error</code>, which you already looked at in 
<span class="keep-together"><a data-type="xref" href="ch09.html#unique_chapter_id_09">Chapter 9</a></span>.</p>
</div>

<p class="pagebreak-before less_space">Both <code>io.Reader</code> and <code>io.Writer</code> define a single method:<a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="standard interface" id="id2548"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Writer" data-tertiary="standard interface" id="id2549"/><a data-type="indexterm" data-primary="io package" data-secondary="standard interfaces" id="id2550"/><a data-type="indexterm" data-primary="interfaces" data-secondary="standard interfaces" data-tertiary="io package" id="id2551"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Reader</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Read</code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Writer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Write</code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Write</code> method on the <code>io.Writer</code> interface takes in a slice of bytes, which are written to the interface implementation. It returns the number of bytes written and an error if something went wrong. The <code>Read</code> method on <code>io.Reader</code> is more interesting. Rather than return data through a return parameter, a slice is passed into the implementation and modified. Up to <code>len(p)</code> bytes will be written into the slice. The method returns the number of bytes written. This might seem a little strange. You might expect this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">NotHowReaderIsDefined</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Read</code><code class="p">()</code><code class="w"> </code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There’s a very good reason <code>io.Reader</code> is defined the way it is. Let’s write a function that’s representative of how to work with an <code>io.Reader</code> to illustrate:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">countLetters</code><code class="p">(</code><code class="nx">r</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">buf</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="mi">2048</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{}</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">Read</code><code class="p">(</code><code class="nx">buf</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">buf</code><code class="p">[:</code><code class="nx">n</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="sc">'A'</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="sc">'Z'</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="sc">'a'</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="sc">'z'</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">out</code><code class="p">[</code><code class="nb">string</code><code class="p">(</code><code class="nx">b</code><code class="p">)]</code><code class="o">++</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There are three things to note. First, you create your buffer once and reuse it on every call to <code>r.Read</code>. This allows you to use a single memory allocation to read from a potentially large data source. If the <code>Read</code> method were written to return a <code>[]byte</code>, it would require a new allocation on every single call. Each allocation would end up on the heap, which would make quite a lot of work for the garbage collector.</p>

<p>If you want to reduce the allocations further, you could create a pool of buffers when the program launches. You would then take a buffer out of the pool when the function starts, and return it when it ends. By passing in a slice to <code>io.Reader</code>, memory allocation is under the control of the developer.</p>

<p>Second, you use the <code>n</code> value returned from <code>r.Read</code> to know how many bytes were written to the buffer and iterate over a subslice of your <code>buf</code> slice, processing the data that was read.</p>

<p>Finally, you know that you’re done<a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="io.EOF" id="id2552"/><a data-type="indexterm" data-primary="errors" data-secondary="io.Reader" data-tertiary="io.EOF" id="id2553"/> reading from <code>r</code> when the error returned from <code>r.Read</code> is <code>io.EOF</code>. This error is a bit odd, in that it isn’t really an error. It indicates that there’s nothing left to read from the <code>io.Reader</code>. When <code>io.EOF</code> is returned, you are finished processing and return your result.</p>

<p>The <code>Read</code> method in <code>io.Reader</code> has one unusual aspect. In most cases when a function or method has an error return value, you check the error before you try to process the nonerror return values. You do the opposite for <code>Read</code> because bytes might have been copied into the buffer before an error was triggered by the end of the data stream or by an unexpected condition.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you get to the end of an <code>io.Reader</code> unexpectedly,<a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="io.ErrUnexpectedEOF" id="id2554"/><a data-type="indexterm" data-primary="errors" data-secondary="io.Reader" data-tertiary="io.ErrUnexpectedEOF" id="id2555"/> a different sentinel error is returned (<code>io.ErrUnexpectedEOF</code>). Note that it starts with the string <code>Err</code> to indicate that it is an unexpected state.</p>
</div>

<p>Because <code>io.Reader</code> and <code>io.Writer</code> are such simple interfaces, they can be implemented many ways. You can create an <code>io.Reader</code> from a string by using the <code>strings.NewReader</code> function:<a data-type="indexterm" data-primary="io package" data-secondary="io.Reader" data-tertiary="strings.NewReader function" id="id2556"/><a data-type="indexterm" data-primary="string type" data-secondary="strings.NewReader function creating io.Reader" id="id2557"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"The quick brown fox jumped over the lazy dog"</code><code class="w"/>
<code class="nx">sr</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">counts</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">countLetters</code><code class="p">(</code><code class="nx">sr</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">counts</code><code class="p">)</code><code class="w"/></pre>

<p>As I discussed in <a data-type="xref" href="ch07.html#interface_duck_typing">“Interfaces Are Type-Safe Duck Typing”</a>, implementations of <code>io.Reader</code> and <code>io.Writer</code> are often chained together in a decorator pattern. Because <code>countLetters</code> depends on an <code>io.Reader</code>, you can use the exact same 
<span class="keep-together"><code>countLetters</code></span> function to count English letters in a gzip-compressed file. First you write a function that, when given a filename, returns a <code>*gzip.Reader</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">buildGZipReader</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="nx">gzip</code><code class="p">.</code><code class="nx">Reader</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(),</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">gr</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">gzip</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">gr</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">gr</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">r</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This function demonstrates the way<a data-type="indexterm" data-primary="gzip package" data-secondary="gzip.NewReader function" id="id2558"/><a data-type="indexterm" data-primary="gzip package" data-secondary="gzip.Reader pointer to io.Reader" id="id2559"/> to properly wrap types that implement <code>io.Reader</code>. You create an <code>*os.File</code> (which meets the <code>io.Reader</code> interface), and after making sure it’s valid, you pass it to the <code>gzip.NewReader</code> function, which returns a <code>*gzip.Reader</code> instance. If it is valid, you return the <code>*gzip.Reader</code> and a closure that properly cleans up your resources when it is invoked.</p>

<p>Since <code>*gzip.Reader</code> implements <code>io.Reader</code>, you can use it with <code>countLetters</code> just as you used the <code>*strings.Reader</code> previously:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">closer</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">buildGZipReader</code><code class="p">(</code><code class="s">"my_data.txt.gz"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">closer</code><code class="p">()</code><code class="w"/>
<code class="nx">counts</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">countLetters</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">counts</code><code class="p">)</code><code class="w"/></pre>

<p>You can find the code<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2560"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2561"/> for <code>countLetters</code> and <code>buildGZipReader</code> in the <em>sample_code/io_friends</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.</p>

<p>Because there are standard interfaces for reading and writing,<a data-type="indexterm" data-primary="io package" data-secondary="io.Copy" id="id2562"/> there’s a standard function in the <code>io</code> package for copying from an <code>io.Reader</code> to an <code>io.Writer</code>, <code>io.Copy</code>. There are other standard functions for adding new functionality to existing <code>io.Reader</code> and <code>io.Writer</code> instances. These include the following:<a data-type="indexterm" data-primary="io package" data-secondary="io.MultiReader" id="id2563"/><a data-type="indexterm" data-primary="io package" data-secondary="io.LimitReader" id="id2564"/><a data-type="indexterm" data-primary="io package" data-secondary="io.MultiWriter" id="id2565"/></p>
<dl>
<dt><code>io.MultiReader</code></dt>
<dd>
<p>Returns an <code>io.Reader</code> that reads from multiple <code>io.Reader</code> instances, one after another</p>
</dd>
<dt><code>io.LimitReader</code></dt>
<dd>
<p>Returns an <code>io.Reader</code> that reads only up to a specified number of bytes from the supplied <code>io.Reader</code></p>
</dd>
<dt><code>io.MultiWriter</code></dt>
<dd>
<p>Returns an <code>io.Writer</code> that writes to multiple <code>io.Writer</code> instances at the same time</p>
</dd>
</dl>

<p>Other packages in the standard library provide their own types and functions to work with <code>io.Reader</code> and <code>io.Writer</code>. You’ve seen a few of them already, but there are many more. These cover compression algorithms, archives, cryptography, buffers, byte slices, and strings.<a data-type="indexterm" data-startref="ch13-iorw" id="id2566"/><a data-type="indexterm" data-startref="ch13-iorw2" id="id2567"/></p>

<p>Other one-method interfaces are defined in <code>io</code>, such as <code>io.Closer</code> and <code>io.Seeker</code>:<a data-type="indexterm" data-primary="io package" data-secondary="io.Closer" id="id2568"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Seeker" id="id2569"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Closer</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Close</code><code class="p">()</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Seeker</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Seek</code><code class="p">(</code><code class="nx">offset</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">whence</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>io.Closer</code> interface is implemented by types like <code>os.File</code> that need to do cleanup when reading or writing is complete. Usually, <code>Close</code> is called via a <code>defer</code>:<a data-type="indexterm" data-primary="defer keyword" data-secondary="io.Closer Close function called via" id="id2570"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="c1">// use f</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you are opening the resource in a loop,<a data-type="indexterm" data-primary="defer keyword" data-secondary="io.Closer Close function called via" data-tertiary="loops and" id="id2571"/> do not use <code>defer</code>, as it will not run until the function exits. Instead, you should call <code>Close</code> before the end of the loop iteration. If there are errors that can lead to an exit, you must call <code>Close</code> there too.</p>
</div>

<p>The <code>io.Seeker</code> interface is used for random access to a resource. <a data-type="indexterm" data-primary="const keyword" data-secondary="constants" data-tertiary="io.Seeker whence constants" id="id2572"/><a data-type="indexterm" data-primary="io package" data-secondary="io.Seeker" data-tertiary="whence constants" id="id2573"/><a data-type="indexterm" data-primary="whence constants for io.Seeker" id="id2574"/>The valid values for <code>whence</code> are the constants <code>io.SeekStart</code>, <code>io.SeekCurrent</code>, and <code>io.SeekEnd</code>. This should have been made clearer by using a custom type, but in a surprising design oversight, <code>whence</code> is of type <code>int</code>.</p>

<p>The <code>io</code> package defines interfaces that combine these four interfaces in various ways.<a data-type="indexterm" data-primary="io package" data-secondary="io.ReadCloser" id="id2575"/><a data-type="indexterm" data-primary="io package" data-secondary="io.ReadSeeker" id="id2576"/><a data-type="indexterm" data-primary="io package" data-secondary="io.ReadWriteCloser" id="id2577"/><a data-type="indexterm" data-primary="io package" data-secondary="io.ReadWriteSeeker" id="id2578"/><a data-type="indexterm" data-primary="io package" data-secondary="Io.ReadWriter" id="id2579"/><a data-type="indexterm" data-primary="io package" data-secondary="io.WriteCloser" id="id2580"/><a data-type="indexterm" data-primary="io package" data-secondary="io.WriteSeeker" id="id2581"/><a data-type="indexterm" data-primary="io package" data-secondary="standard interfaces" id="id2582"/><a data-type="indexterm" data-primary="interfaces" data-secondary="standard interfaces" data-tertiary="io package" id="id2583"/> They include <code>io.ReadCloser</code>, <code>io.ReadSeeker</code>, <code>io.ReadWriteCloser</code>, <code>io.ReadWriteSeeker</code>, <code>io.ReadWriter</code>, <code>io.WriteCloser</code>, and <code>io.WriteSeeker</code>. Use these interfaces to specify what your functions expect to do with the data. For example, rather than just using an <code>os.File</code> as a parameter, use the interfaces to specify exactly what your function will do with the parameter. Not only does it make your functions more general-purpose, it also makes your intent clearer. Furthermore, make your code compatible with these interfaces if you are writing your own data sources and sinks. In general, strive to create interfaces as simple and decoupled as the interfaces defined in <code>io</code>. They demonstrate the power of simple abstractions.</p>

<p>In addition to the interfaces in the <code>io</code> package, <a data-type="indexterm" data-primary="io package" data-secondary="helper functions" id="id2584"/><a data-type="indexterm" data-primary="helper functions" data-secondary="io package" id="id2585"/><a data-type="indexterm" data-primary="io package" data-secondary="io.ReadAll" id="id2586"/><a data-type="indexterm" data-primary="io package" data-secondary="io.NopCloser" id="id2587"/>there are several helper functions for common operations. For example, the <code>io.ReadAll</code> function reads all the data from an <code>io.Reader</code> into a byte slice. <a data-type="indexterm" data-primary="types" data-secondary="adding a method to" id="id2588"/><a data-type="indexterm" data-primary="methods" data-secondary="adding to types" id="id2589"/>One of the more clever functions in <code>io</code> demonstrates a pattern for adding a method to a Go type. If you have a type that implements <code>io.Reader</code> but not <code>io.Closer</code> (such as <code>strings.Reader</code>) and need to pass it to a function that expects an <code>io.ReadCloser</code>, pass your <code>io.Reader</code> into <code>io.NopCloser</code> and get back a type that implements <code>io.ReadCloser</code>. If you look at the implementation, it’s very simple:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">nopCloser</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">nopCloser</code><code class="p">)</code><code class="w"> </code><code class="nx">Close</code><code class="p">()</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">NopCloser</code><code class="p">(</code><code class="nx">r</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">ReadCloser</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">nopCloser</code><code class="p">{</code><code class="nx">r</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Anytime you need to add additional methods to a type so that it can meet an interface, use this embedded type pattern.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>io.NopCloser</code> function violates the general rule of not returning an interface from a function, but it’s a simple adapter for an interface that is guaranteed to stay the same because it is part of the standard library.</p>
</div>

<p>Among other things, the <code>os</code> package<a data-type="indexterm" data-primary="standard library" data-secondary="os package" id="id2590"/><a data-type="indexterm" data-primary="os package" data-secondary="os.ReadFile" id="id2591"/><a data-type="indexterm" data-primary="os package" data-secondary="os.WriteFile" id="id2592"/><a data-type="indexterm" data-primary="os package" data-secondary="os.Create" id="id2593"/><a data-type="indexterm" data-primary="os package" data-secondary="os.NewFile" id="id2594"/><a data-type="indexterm" data-primary="os package" data-secondary="os.Open" id="id2595"/><a data-type="indexterm" data-primary="os package" data-secondary="os.OpenFile" id="id2596"/><a data-type="indexterm" data-primary="os package" data-secondary="*os.File instance returned" data-secondary-sortas="os.File instance" id="id2597"/><a data-type="indexterm" data-primary="bufio package" data-secondary="*os.File instance with Scanner type" data-secondary-sortas="os.File instance" id="id2598"/><a data-type="indexterm" data-primary="types" data-secondary="Scanner type for *os.File instance" id="id2599"/> contains functions for interacting with files. The functions <code>os.ReadFile</code> and <code>os.WriteFile</code> read an entire file into a slice of bytes and write a slice of bytes into a file, respectively. These functions (and <code>io.ReadAll</code>) are fine for small amounts of data, but they are not appropriate for large data sources. When working with larger data sources, use the <code>Create</code>, <code>NewFile</code>, <code>Open</code>, and <code>OpenFile</code> functions in the <code>os</code> package. They return an <code>*os.File</code> instance, which implements the <code>io.Reader</code> and <code>io.Writer</code> interfaces. You can use an <code>*os.File</code> instance with the <code>Scanner</code> type in the <code>bufio</code> package.<a data-type="indexterm" data-startref="ch13-io" id="id2600"/><a data-type="indexterm" data-startref="ch13-io2" id="id2601"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="time"><div class="sect1" id="time">
<h1>time</h1>

<p>Like most languages, Go’s standard library<a data-type="indexterm" data-primary="standard library" data-secondary="time package" id="ch13-time"/><a data-type="indexterm" data-primary="time package" id="ch13-time2"/><a data-type="indexterm" data-primary="time package" data-secondary="types" data-tertiary="time.Duration" id="id2602"/><a data-type="indexterm" data-primary="time package" data-secondary="types" data-tertiary="time.Time" id="id2603"/><a data-type="indexterm" data-primary="types" data-secondary="time package" data-tertiary="time.Duration" id="id2604"/><a data-type="indexterm" data-primary="types" data-secondary="time package" data-tertiary="time.Time" id="id2605"/> includes time support, which is found, unsurprisingly, in the <code>time</code> package. Two main types are used to represent time: <code>time.Duration</code> and <code>time.Time</code>.</p>

<p>A period of time is represented with a <code>time.Duration</code>, a type based on an <code>int64</code>. The smallest amount of time that Go can represent is one nanosecond, but the <code>time</code> package defines constants of type <code>time.Duration</code> to represent a nanosecond, microsecond, millisecond, second, minute, and hour. For example, you represent a duration of 2 hours and 30 minutes as follows:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">d</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Hour</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">30</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Minute</code><code class="w"> </code><code class="c1">// d is of type time.Duration</code><code class="w"/></pre>

<p>These constants make the use of a <code>time.Duration</code> both readable and type-safe. They demonstrate a good use of a typed constant.</p>

<p>Go defines a sensible string format, a series of numbers,<a data-type="indexterm" data-primary="time package" data-secondary="time.ParseDuration" id="id2606"/><a data-type="indexterm" data-primary="string type" data-secondary="time duration strings" id="id2607"/> that can be parsed into a <code>time.Duration</code> with the <code>time.ParseDuration</code> function. This format is described in the standard library documentation:</p>
<blockquote>
<p>A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as “300ms”, “-1.5h” or “2h45m”. Valid time units are “ns”, “us” (or “µs”), “ms”, “s”, “m”, “h”.</p>
<p data-type="attribution"><a href="https://oreil.ly/wmZdy">Go Standard Library Documentation</a></p></blockquote>

<p>Several methods are defined on <code>time.Duration</code>. It <a data-type="indexterm" data-primary="fmt package" data-secondary="fmt.Stringer" id="id2608"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Truncate" id="id2609"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Round" id="id2610"/>meets the <code>fmt.Stringer</code> interface and returns a formatted duration string via the <code>String</code> method. It also has methods to get the value as a number of hours, minutes, seconds, milliseconds, microseconds, or nanoseconds. The <code>Truncate</code> and <code>Round</code> methods truncate or round a <code>time.Duration</code> to the units of the specified <code>time.Duration</code>.</p>

<p>A moment of time is represented with the <code>time.Time</code> type, complete with a time zone. <a data-type="indexterm" data-primary="time zone in time.Time type" id="id2611"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Now" id="id2612"/>You acquire a reference to the current time with the function <code>time.Now</code>. This returns a <code>time.Time</code> instance set to the current local time.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The fact that a <code>time.Time</code> instance contains<a data-type="indexterm" data-primary="time zone in time.Time type" data-secondary="Equal method for comparison" id="id2613"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="time.Time methods" id="id2614"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="time.Time methods" id="id2615"/><a data-type="indexterm" data-primary="time package" data-secondary="types" data-tertiary="time.Time comparisons" id="id2616"/> a time zone means that you should not use <code>==</code> to check whether two <code>time.Time</code> instances refer to the same moment in time. Instead, use the <code>Equal</code> method, which corrects for time zone.</p>
</div>

<p>The <code>time.Parse</code> function converts<a data-type="indexterm" data-primary="time package" data-secondary="time.Parse" id="id2617"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Format" id="id2618"/><a data-type="indexterm" data-primary="string type" data-secondary="time converted to and from" id="id2619"/><a data-type="indexterm" data-primary="time package" data-secondary="formatting of date and time" id="id2620"/> from a <code>string</code> to a <code>time.Time</code>, while the <code>Format</code> method converts a <code>time.Time</code> to a <code>string</code>. While Go usually adopts ideas that worked well in the past, it uses <a href="https://oreil.ly/yfm_V">its own date and time formatting language</a>. It  relies on the idea of formatting the date and time January 2, 2006 at 3:04:05PM MST (Mountain Standard Time) to specify your format.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Why that date? Because each part of it represents one of the numbers from 1 to 7 in sequence, that is, 01/02 03:04:05PM ’06 -0700 (MST is 7 hours before UTC).</p>
</div>

<p>For example, the following code</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">t</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Parse</code><code class="p">(</code><code class="s">"2006-01-02 15:04:05 -0700"</code><code class="p">,</code><code class="w"> </code><code class="s">"2023-03-13 00:00:00 +0000"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">t</code><code class="p">.</code><code class="nx">Format</code><code class="p">(</code><code class="s">"January 2, 2006 at 3:04:05PM MST"</code><code class="p">))</code><code class="w"/></pre>

<p>prints out this output:</p>

<pre data-type="programlisting">March 13, 2023 at 12:00:00AM UTC</pre>

<p>While the date and time used for formatting is intended to be a clever mnemonic, I find it hard to remember and have to look it up each time I want to use it. Luckily, the most commonly used date and time formats have been given their own constants in the <code>time</code> package.</p>

<p>Just as there are methods on <code>time.Duration</code> to extract portions of it, <a data-type="indexterm" data-primary="time package" data-secondary="Day, Month, Year, Hour, Minute, Second, Weekday methods" id="id2621"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Clock" id="id2622"/>there are methods defined on <code>time.Time</code> to do the same, including <code>Day</code>, <code>Month</code>, <code>Year</code>, <code>Hour</code>, <code>Minute</code>, <code>Second</code>, <code>Weekday</code>, <code>Clock</code> (which returns the time portion of a <code>time.Time</code> as separate hour, minute, and second <code>int</code> values), and <code>Date</code> (which returns the year, month, and day as separate <code>int</code> values). <a data-type="indexterm" data-primary="comparison operators" data-secondary="time.Time methods" id="id2623"/><a data-type="indexterm" data-primary="time package" data-secondary="types" data-tertiary="time.Time comparisons" id="id2624"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="time.Time methods" id="id2625"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="time.Time methods" id="id2626"/>You can compare one <code>time.Time</code> instance against another with the <code>After</code>, <code>Before</code>, and <code>Equal</code> methods.</p>

<p>The <code>Sub</code> method returns<a data-type="indexterm" data-primary="time package" data-secondary="time.Sub" id="id2627"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Add" id="id2628"/><a data-type="indexterm" data-primary="time package" data-secondary="time.AddDate" id="id2629"/> a <code>time.Duration</code> that represents the elapsed time between two <code>time.Time</code> instances, while the <code>Add</code> method returns a <code>time.Time</code> that is <code>time.Duration</code> later, and the <code>AddDate</code> method returns a new <code>time.Time</code> instance that’s incremented by the specified number of years, months, and days. <a data-type="indexterm" data-primary="time package" data-secondary="time.Round" id="id2630"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Truncate" id="id2631"/>As with <code>time.Duration</code>, there are <code>Truncate</code> and <code>Round</code> methods defined as well. <a data-type="indexterm" data-primary="value receivers" data-secondary="time package methods" id="id2632"/><a data-type="indexterm" data-primary="time package" data-secondary="methods not modifying time.Time instance" id="id2633"/>All these methods are defined on a value receiver, so they do not modify the <code>time.Time</code> instance.</p>








<section data-type="sect2" data-pdf-bookmark="Monotonic Time"><div class="sect2" id="id169">
<h2>Monotonic Time</h2>

<p>Most operating systems keep track<a data-type="indexterm" data-primary="time package" data-secondary="monotonic time" id="id2634"/><a data-type="indexterm" data-primary="monotonic time" id="id2635"/> of two sorts of time: the <em>wall clock</em>, which corresponds to the current time, and the <em>monotonic clock</em>, which counts up from the time the computer was booted. The reason for tracking two clocks is that the wall clock doesn’t uniformly increase. Daylight Saving Time, leap seconds, and  Network Time Protocol (NTP) updates can make the wall clock move unexpectedly forward or backward. This can cause problems when setting a timer or finding the amount of time that’s elapsed.</p>

<p>To address this potential problem, Go uses monotonic time to track elapsed time whenever a timer is set or a <code>time.Time</code> instance is created with <code>time.Now</code>. This support is invisible; timers use it automatically. The <code>Sub</code> method uses the monotonic clock to calculate the <code>time.Duration</code> if both <code>time.Time</code> instances have it set. If they don’t (because one or both of the instances was not created with <code>time.Now</code>), the <code>Sub</code> method uses the time specified in the instances to calculate the <code>time.Duration</code> instead.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you want to understand the sorts<a data-type="indexterm" data-primary="time package" data-secondary="monotonic time" data-tertiary="importance of handling correctly" id="id2636"/><a data-type="indexterm" data-primary="resources online" data-secondary="monotonic time blog post" id="id2637"/> of problems that can occur when not handling monotonic time correctly, take a look at the Cloudflare <a href="https://oreil.ly/IxS2D">blog post</a> that detailed a bug caused by the lack of monotonic time support in an earlier version of Go.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Timers and Timeouts"><div class="sect2" id="id170">
<h2>Timers and Timeouts</h2>

<p>As I covered in <a data-type="xref" href="ch12.html#time_out">“Time Out Code”</a>, the <code>time</code> package<a data-type="indexterm" data-primary="time package" data-secondary="timers" id="id2638"/><a data-type="indexterm" data-primary="time package" data-secondary="timeouts" id="id2639"/><a data-type="indexterm" data-primary="time package" data-secondary="time.After" id="id2640"/><a data-type="indexterm" data-primary="time package" data-secondary="time.Tick" id="id2641"/> includes functions that return channels that output values after a specified time. The <code>time.After</code> function returns a channel that outputs once, while the channel returned by <code>time.Tick</code> returns a new value every time the specified <code>time.Duration</code> elapses. These are used with Go’s concurrency support to enable timeouts or recurring tasks. <a data-type="indexterm" data-primary="time package" data-secondary="time.AfterFunc" id="id2642"/><a data-type="indexterm" data-primary="functions" data-secondary="triggering to run after time duration" id="id2643"/></p>

<p>You can also trigger a single function to run after a specified <code>time.Duration</code> with the <code>time.AfterFunc</code> function. <a data-type="indexterm" data-primary="time package" data-secondary="time.Tick" data-tertiary="time.NewTicker instead" id="id2644"/><a data-type="indexterm" data-primary="time package" data-secondary="time.NewTicker" id="id2645"/>Don’t use <code>time.Tick</code> outside trivial programs, because the underlying <code>time.Ticker</code> cannot be shut down (and therefore cannot be garbage collected). Use the <code>time.NewTicker</code> function instead, which returns a <code>*time.Ticker</code> that has the channel to listen to, as well as methods to reset and stop the ticker.<a data-type="indexterm" data-startref="ch13-time" id="id2646"/><a data-type="indexterm" data-startref="ch13-time2" id="id2647"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="encoding/json"><div class="sect1" id="json">
<h1>encoding/json</h1>

<p>REST APIs have enshrined JSON as<a data-type="indexterm" data-primary="JSON support in encoding/json package" id="ch13-json2"/><a data-type="indexterm" data-primary="standard library" data-secondary="encoding/json package" id="ch13-json3"/><a data-type="indexterm" data-primary="encoding/json package" id="ch13-json4"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="about JSON" id="id2648"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="JSON" data-tertiary="about" id="id2649"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="marshaling versus unmarshaling" id="id2650"/><a data-type="indexterm" data-primary="marshaling" data-secondary="about" id="id2651"/><a data-type="indexterm" data-primary="Unmarshal function" data-secondary="about unmarshaling" id="id2652"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Unmarshal" data-tertiary="about unmarshaling" id="id2653"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Unmarshal" data-tertiary="about unmarshaling" id="id2654"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="JSON" data-tertiary="marshaling versus unmarshaling" id="id2655"/> the standard way to communicate between services, and Go’s standard library includes support for converting Go data types to and from JSON. The word <em>marshaling</em> means converting from a Go data type to an encoding, and <em>unmarshaling</em> means converting to a Go data type.</p>








<section data-type="sect2" data-pdf-bookmark="Using Struct Tags to Add Metadata"><div class="sect2" id="id172">
<h2>Using Struct Tags to Add Metadata</h2>

<p>Let’s say that you are building an order management system and have to read and write the following JSON:<a data-type="indexterm" data-primary="structs" data-secondary="struct tags for metadata" id="id2656"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="struct tags to add metadata" id="id2657"/><a data-type="indexterm" data-primary="metadata" data-secondary="struct tags for" id="id2658"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="JSON" data-tertiary="struct tags to add metadata" id="id2659"/></p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"id"</code><code class="p">:</code><code class="s2">"12345"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"date_ordered"</code><code class="p">:</code><code class="s2">"2020-05-01T13:01:02Z"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"customer_id"</code><code class="p">:</code><code class="s2">"3"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"items"</code><code class="p">:[{</code><code class="nt">"id"</code><code class="p">:</code><code class="s2">"xyz123"</code><code class="p">,</code><code class="nt">"name"</code><code class="p">:</code><code class="s2">"Thing 1"</code><code class="p">},{</code><code class="nt">"id"</code><code class="p">:</code><code class="s2">"abc789"</code><code class="p">,</code><code class="nt">"name"</code><code class="p">:</code><code class="s2">"Thing 2"</code><code class="p">}]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You define types to map this data:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Order</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">            </code><code class="kt">string</code><code class="w">        </code><code class="s">`json:"id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">DateOrdered</code><code class="w">   </code><code class="nx">time</code><code class="p">.</code><code class="nx">Time</code><code class="w">     </code><code class="s">`json:"date_ordered"`</code><code class="w"/>
<code class="w">    </code><code class="nx">CustomerID</code><code class="w">    </code><code class="kt">string</code><code class="w">        </code><code class="s">`json:"customer_id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Items</code><code class="w">         </code><code class="p">[]</code><code class="nx">Item</code><code class="w">        </code><code class="s">`json:"items"`</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Item</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">   </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"name"`</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You specify the rules for processing your JSON with <em>struct tags</em>, strings that are written after the fields in a struct. <a data-type="indexterm" data-primary="backquote (`)" data-secondary="struct tags" id="id2660"/><a data-type="indexterm" data-primary="` (backquote)" data-secondary="struct tags" id="id2661"/><a data-type="indexterm" data-primary="go commands" data-secondary="go vet" data-tertiary="struct tag validation" id="id2662"/><a data-type="indexterm" data-primary="testing" data-secondary="go vet" data-tertiary="struct tag validation" id="id2663"/>Even though struct tags are strings marked with backticks, they cannot extend past a single line. Struct tags are composed of one or more tag/value pairs, written as <em><code>tagName:"tagValue"</code></em> and separated by spaces. Because they are just strings, the compiler cannot validate that they are formatted correctly, but <code>go vet</code> does. Also, note that all these fields are exported. Like any other package, the code in the <code>encoding/json</code> package cannot access an unexported field on a struct in another package.</p>

<p>For JSON processing, use the<a data-type="indexterm" data-primary="json tag with struct field" id="id2664"/> tag <code>json</code> to specify the name of the JSON field that should be associated with the struct field. If no <code>json</code> tag is provided, the default behavior is to assume that the name of the JSON object field matches the name of the Go struct field. Despite this default behavior, it’s best to use the struct tag to specify the name of the field explicitly, even if the field names are identical.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When unmarshaling from JSON into a struct field with no <code>json</code> tag, the name match is case-insensitive. When marshaling a struct field with no <code>json</code> tag back to JSON, the JSON field will always have an uppercase first letter, because the field is exported.</p>
</div>

<p>If a field should be ignored when<a data-type="indexterm" data-primary="dash (-) for ignored field in marshaling or unmarshaling" id="id2665"/><a data-type="indexterm" data-primary="- (dash) for ignored field in marshaling or unmarshaling" id="id2666"/><a data-type="indexterm" data-primary="marshaling" data-secondary="dash for name of ignored field" id="id2667"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Unmarshal" data-tertiary="dash for name of ignored field" id="id2668"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Unmarshal" data-tertiary="dash for name of ignored field" id="id2669"/><a data-type="indexterm" data-primary="Unmarshal function" data-secondary="dash for name of ignored field" id="id2670"/> marshaling or unmarshaling, use a dash (<code>-</code>) for the name. If the field should be left out of the output when it is empty, add <code>,omitempty</code> after the name. For example, in the <code>Order</code> struct, if you didn’t want to include <code>CustomerID</code> in the output if it was set to an empty string, the struct tag would be <code>json:"customer_id,omitempty"</code>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Unfortunately, the definition of “empty” doesn’t exactly align with the zero value, as you might expect. The zero value of a struct doesn’t count as empty, but a zero-length slice or map does.</p>
</div>

<p>Struct tags allow you to use metadata to control how your program behaves. Other languages, most notably Java, encourage developers to place annotations on various program elements to describe <em>how</em> they should be processed, without explicitly specifying <em>what</em> is going to do the processing. While declarative programming allows for more concise programs, automatic processing of metadata makes it difficult to understand how a program behaves. Anyone who has worked on a large Java project with annotations has had a moment of panic when something goes wrong and they don’t understand which code is processing a particular annotation and what changes it made. Go favors explicit code over short code. Struct tags are never evaluated automatically; they are processed when a struct instance is passed into a function.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Unmarshaling and Marshaling"><div class="sect2" id="id265">
<h2>Unmarshaling and Marshaling</h2>

<p>The <code>Unmarshal</code> function in the <code>encoding/json</code> package<a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Unmarshal" id="id2671"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Unmarshal" id="id2672"/> is used to convert a slice of bytes into a struct. If you have a string named <code>data</code>, this is the code to convert <code>data</code> to a struct of type <code>Order</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">o</code><code class="w"> </code><code class="nx">Order</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">data</code><code class="p">),</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">o</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>json.Unmarshal</code> function populates data into an input parameter, just like the implementations of the <code>io.Reader</code> interface. As I discussed in <a data-type="xref" href="ch06.html#last_resort">“Pointers Are a Last Resort”</a>, this allows for efficient reuse of the same struct over and over, giving you control over memory usage.</p>

<p>You use the <code>Marshal</code> function<a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Marshal" id="id2673"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Marshal" id="id2674"/> in the <code>encoding/json</code> package to write an <code>Order</code> instance back as JSON, stored in a slice of bytes:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">out</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code><code class="w"/></pre>

<p>This leads to the question: how are you able to evaluate struct tags? You might also be wondering how <code>json.Marshal</code> and <code>json.Unmarshal</code> are able to read and write a struct of any type. After all, every other method that you’ve written has worked only with types that were known when the program was compiled (even the types listed in a type switch are enumerated ahead of time). The answer to both questions is reflection. You can find out more about reflection in <a data-type="xref" href="ch16.html#unique_chapter_id_16">Chapter 16</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="JSON, Readers, and Writers"><div class="sect2" id="id173">
<h2>JSON, Readers, and Writers</h2>

<p>The <code>json.Marshal</code> and <code>json.Unmarshal</code> functions<a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Decoder" id="ch13-dec"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Decoder" id="ch13-dec2"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Encoder" id="ch13-dec3"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Encoder" id="ch13-dec4"/> work on slices of bytes. As you just saw, most data sources and sinks in Go implement the <code>io.Reader</code> and <code>io.Writer</code> interfaces. While you could use <code>io.ReadAll</code> to copy the entire contents of an <code>io.Reader</code> into a byte slice so it can be read by <code>json.Unmarshal</code>, this is inefficient. Similarly, you could write to an in-memory byte slice buffer using <code>json.Marshal</code> and then write that byte slice to the network or disk, but it’d be better if you could write to an <code>io.Writer</code> directly.</p>

<p>The <code>encoding/json</code> package includes two types that allow you to handle these situations. The <code>json.Decoder</code> and <code>json.Encoder</code> types read from and write to anything that meets the <code>io.Reader</code> and <code>io.Writer</code> interfaces, respectively. Let’s take a quick look at how they work.</p>

<p>Start with your data in <code>toFile</code>, which implements a simple struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"name"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">  </code><code class="kt">int</code><code class="w">    </code><code class="s">`json:"age"`</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">toFile</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="p">:</code><code class="w"> </code><code class="s">"Fred"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="p">:</code><code class="w">  </code><code class="mi">40</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>os.File</code> type implements both the <code>io.Reader</code> and <code>io.Writer</code> interfaces, so it can be used to demonstrate <code>json.Decoder</code> and <code>json.Encoder</code>. First, you write <code>toFile</code> to a temp file by passing the temp file to <code>json.NewEncoder</code>, which returns a <code>json.Encoder</code> for the temp file. You then pass <code>toFile</code> to the <code>Encode</code> method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">tmpFile</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">CreateTemp</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">TempDir</code><code class="p">(),</code><code class="w"> </code><code class="s">"sample-"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Remove</code><code class="p">(</code><code class="nx">tmpFile</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">NewEncoder</code><code class="p">(</code><code class="nx">tmpFile</code><code class="p">).</code><code class="nx">Encode</code><code class="p">(</code><code class="nx">toFile</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">tmpFile</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Once <code>toFile</code> is written, you can read the JSON back in by passing a reference to the temp file to <code>json.NewDecoder</code> and then calling the <code>Decode</code> method on the returned <code>json.Decoder</code> with a variable of type <code>Person</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">tmpFile2</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">tmpFile</code><code class="p">.</code><code class="nx">Name</code><code class="p">())</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">fromFile</code><code class="w"> </code><code class="nx">Person</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">NewDecoder</code><code class="p">(</code><code class="nx">tmpFile2</code><code class="p">).</code><code class="nx">Decode</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">fromFile</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">tmpFile2</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%+v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">fromFile</code><code class="p">)</code><code class="w"/></pre>

<p>You can see a complete example on <a href="https://oreil.ly/eLk64">The Go Playground</a> or in the <em>sample_code/json</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-startref="ch13-dec" id="id2675"/><a data-type="indexterm" data-startref="ch13-dec2" id="id2676"/><a data-type="indexterm" data-startref="ch13-dec3" id="id2677"/><a data-type="indexterm" data-startref="ch13-dec4" id="id2678"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="ix_mmmm"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="ix_mmm"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Encoding and Decoding JSON Streams"><div class="sect2" id="id290">
<h2>Encoding and Decoding JSON Streams</h2>

<p>What do you do when you have multiple<a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Decoder" data-tertiary="multiple JSON structs at once" id="id2679"/><a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="json.Encoder" data-tertiary="multiple JSON structs at once" id="id2680"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="json.Encoder" data-tertiary="multiple JSON structs at once" id="id2681"/> JSON structs to read or write at once? Our friends <code>json.Decoder</code> and <code>json.Encoder</code> can be used for these situations too.</p>

<p>Assume you have the following data:</p>

<pre data-type="programlisting">{"name": "Fred", "age": 40}
{"name": "Mary", "age": 21}
{"name": "Pat", "age": 30}</pre>

<p>For the sake of this example, assume it’s stored in a string called <code>streamData</code>, but it could be in a file or even an incoming HTTP request (you’ll see how HTTP servers work in just a bit).</p>

<p>You’re going to store this data into your <code>t</code> variable, one JSON object at a time.</p>

<p>Just as before, you initialize your <code>json.Decoder</code> with the data source, but this time you use a <code>for</code> loop and run until you get an error. If the error is <code>io.EOF</code>, you have successfully read all the data. If not, there was a problem with the JSON stream. This lets you read and process the data, one JSON object at a time:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">t</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"name"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">  </code><code class="kt">int</code><code class="w">    </code><code class="s">`json:"age"`</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">dec</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">NewDecoder</code><code class="p">(</code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">streamData</code><code class="p">))</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">dec</code><code class="p">.</code><code class="nx">Decode</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">t</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Is</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// process t</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Writing out multiple values with the <code>json.Encoder</code> works just like using it to write out a single value. In this example, you are writing to a <code>bytes.Buffer</code>, but any type that meets the <code>io.Writer</code> interface will work:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="nx">bytes</code><code class="p">.</code><code class="nx">Buffer</code><code class="w"/>
<code class="nx">enc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">NewEncoder</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">b</code><code class="p">)</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">input</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">allInputs</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">t</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">process</code><code class="p">(</code><code class="nx">input</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">enc</code><code class="p">.</code><code class="nx">Encode</code><code class="p">(</code><code class="nx">t</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/></pre>

<p>You can run this example on <a href="https://oreil.ly/XGbRQ">The Go Playground</a> or find it in the <em>sample_code/encode_decode</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.</p>

<p>This example has multiple JSON objects in the data stream that aren’t wrapped in an array, but you can also use the <code>json.Decoder</code> to read a single object from an array without loading the entire array into memory at once. This can greatly increase performance and reduce memory usage. An example is in the <a href="https://oreil.ly/_LTZQ">Go documentation</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Custom JSON Parsing"><div class="sect2" id="id174">
<h2>Custom JSON Parsing</h2>

<p>While the default functionality<a data-type="indexterm" data-primary="JSON support in encoding/json package" data-secondary="custom JSON parsing" id="ch13-cus"/><a data-type="indexterm" data-primary="encoding/json package" data-secondary="custom JSON parsing" id="ch13-cus2"/> is often sufficient, sometimes you need to override it. While <code>time.Time</code> supports JSON fields in RFC 3339 format out of the box, you might have to deal with other time formats. You can handle this by creating a new type that implements two interfaces, <code>json.Marshaler</code> and <code>json.Unmarshaler</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">RFC822ZTime</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">time</code><code class="p">.</code><code class="nx">Time</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">rt</code><code class="w"> </code><code class="nx">RFC822ZTime</code><code class="p">)</code><code class="w"> </code><code class="nx">MarshalJSON</code><code class="p">()</code><code class="w"> </code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">out</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">rt</code><code class="p">.</code><code class="nx">Time</code><code class="p">.</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">RFC822Z</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">`"`</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">out</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">`"`</code><code class="p">),</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">rt</code><code class="w"> </code><code class="o">*</code><code class="nx">RFC822ZTime</code><code class="p">)</code><code class="w"> </code><code class="nx">UnmarshalJSON</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">"null"</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">t</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Parse</code><code class="p">(</code><code class="s">`"`</code><code class="o">+</code><code class="nx">time</code><code class="p">.</code><code class="nx">RFC822Z</code><code class="o">+</code><code class="s">`"`</code><code class="p">,</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">b</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="o">*</code><code class="nx">rt</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">RFC822ZTime</code><code class="p">{</code><code class="nx">t</code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You embedded a <code>time.Time</code> instance into a new struct called <code>RFC822ZTime</code> so that you still have access to the other methods on <code>time.Time</code>. As was discussed in <a data-type="xref" href="ch07.html#pointer_value_receivers">“Pointer Receivers and Value Receivers”</a>, the method that reads the time value is declared on a value receiver, while the method that modifies the time value is declared on a pointer receiver.</p>

<p>You then change the type of your <code>DateOrdered</code> field and can work with RFC 822 formatted times instead:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Order</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">          </code><code class="kt">string</code><code class="w">      </code><code class="s">`json:"id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">DateOrdered</code><code class="w"> </code><code class="nx">RFC822ZTime</code><code class="w"> </code><code class="s">`json:"date_ordered"`</code><code class="w"/>
<code class="w">    </code><code class="nx">CustomerID</code><code class="w">  </code><code class="kt">string</code><code class="w">      </code><code class="s">`json:"customer_id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Items</code><code class="w">       </code><code class="p">[]</code><code class="nx">Item</code><code class="w">      </code><code class="s">`json:"items"`</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can run this code on <a href="https://oreil.ly/I_cSY">The Go Playground</a> or find it in the <em>sample_code/custom_json</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-startref="ix_mmm" id="id2682"/><a data-type="indexterm" data-startref="ix_mmmm" id="id2683"/></p>

<p>This approach has a philosophical drawback: the date format of the JSON determines the types of the fields in your data structure. This is a drawback to the <code>encoding/json</code> approach. You could have <code>Order</code> implement <code>json.Marshaler</code> and <code>json.Unmarshaler</code>, but that requires you to write code to handle all the fields, even the ones that don’t require custom support. The struct tag format does not provide a way to specify a function to parse a particular field. That leaves you with creating a custom type for the field.</p>

<p>Another option is described in a <a href="https://oreil.ly/Jl05c">blog post by Ukiah Smith</a>. It allows you to redefine only the fields that don’t match the default marshaling behavior by taking advantage of how struct embedding (which was covered in <a data-type="xref" href="ch07.html#struct_embedding">“Use Embedding for Composition”</a>) interacts with JSON marshaling and unmarshaling. If a field on an embedded struct has the same name as the containing struct, that field is ignored when marshaling or unmarshaling JSON.</p>

<p>In this example, the fields for <code>Order</code> look like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Order</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">          </code><code class="kt">string</code><code class="w">    </code><code class="s">`json:"id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Items</code><code class="w">       </code><code class="p">[]</code><code class="nx">Item</code><code class="w">    </code><code class="s">`json:"items"`</code><code class="w"/>
<code class="w">    </code><code class="nx">DateOrdered</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Time</code><code class="w"> </code><code class="s">`json:"date_ordered"`</code><code class="w"/>
<code class="w">    </code><code class="nx">CustomerID</code><code class="w">  </code><code class="kt">string</code><code class="w">    </code><code class="s">`json:"customer_id"`</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>MarshalJSON</code> method looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">o</code><code class="w"> </code><code class="nx">Order</code><code class="p">)</code><code class="w"> </code><code class="nx">MarshalJSON</code><code class="p">()</code><code class="w"> </code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">type</code><code class="w"> </code><code class="nx">Dup</code><code class="w"> </code><code class="nx">Order</code><code class="w"/>

<code class="w">    </code><code class="nx">tmp</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">DateOrdered</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"date_ordered"`</code><code class="w"/>
<code class="w">        </code><code class="nx">Dup</code><code class="w"/>
<code class="w">    </code><code class="p">}{</code><code class="w"/>
<code class="w">        </code><code class="nx">Dup</code><code class="p">:</code><code class="w"> </code><code class="p">(</code><code class="nx">Dup</code><code class="p">)(</code><code class="nx">o</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">tmp</code><code class="p">.</code><code class="nx">DateOrdered</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">o</code><code class="p">.</code><code class="nx">DateOrdered</code><code class="p">.</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">RFC822Z</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">tmp</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In the <code>MarshalJSON</code> method for <code>Order</code>, you define a type <code>Dup</code> whose underlying type is <code>Order</code>. The reason for creating <code>Dup</code> is that a type based on another type has the same fields as the underlying type, but not the methods. If you didn’t have <code>Dup</code>, there would be an infinite loop of calls to <code>MarshalJSON</code> when you call <code>json.Marshal</code>, eventually resulting in a stack overflow.</p>

<p>You define an anonymous struct that has the <code>DateOrdered</code> field and an embedded <code>Dup</code>. You then assign the <code>Order</code> instance to the embedded field in <code>tmp</code>, assign the <code>DateOrdered</code> field in <code>tmp</code> the time formatted as RFC822Z, and call <code>json.Marshal</code> on <code>tmp</code>. This produces the desired JSON output.</p>

<p>There is similar logic in <code>UnmarshalJSON</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">o</code><code class="w"> </code><code class="o">*</code><code class="nx">Order</code><code class="p">)</code><code class="w"> </code><code class="nx">UnmarshalJSON</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">type</code><code class="w"> </code><code class="nx">Dup</code><code class="w"> </code><code class="nx">Order</code><code class="w"/>

<code class="w">    </code><code class="nx">tmp</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">DateOrdered</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"date_ordered"`</code><code class="w"/>
<code class="w">        </code><code class="o">*</code><code class="nx">Dup</code><code class="w"/>
<code class="w">    </code><code class="p">}{</code><code class="w"/>
<code class="w">        </code><code class="nx">Dup</code><code class="p">:</code><code class="w"> </code><code class="p">(</code><code class="o">*</code><code class="nx">Dup</code><code class="p">)(</code><code class="nx">o</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">tmp</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>

<code class="w">    </code><code class="nx">o</code><code class="p">.</code><code class="nx">DateOrdered</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Parse</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">RFC822Z</code><code class="p">,</code><code class="w"> </code><code class="nx">tmp</code><code class="p">.</code><code class="nx">DateOrdered</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In <code>UnmarshalJSON</code>, the call to <code>json.Unmarshal</code> populates the fields in <code>o</code> (except <code>DateOrdered</code>) because it’s embedded into <code>tmp</code>. You then populate <code>DateOrdered</code> in <code>o</code> by using <code>time.Parse</code> to process the <code>DateOrdered</code> field in <code>tmp</code>.</p>

<p>You can run this code on <a href="https://oreil.ly/JHsdO">The Go Playground</a> or find it in the <em>sample_code/custom_json2</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2684"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2685"/></p>

<p>While this does keep <code>Order</code> from having a field tied to the JSON format, the <code>MarshalJSON</code> and <code>UnmarshalJSON</code> methods on <code>Order</code> are coupled to the format of the time field in the JSON. You cannot reuse <code>Order</code> to support JSON that has the time formatted another way.</p>

<p>To limit the amount of code that cares about what your JSON looks like, define two structs. Use one for converting to and from JSON and the other for data processing. Read in JSON to your JSON-aware type, and then copy it to the other. When you want to write out JSON, do the reverse. This does create some duplication, but it keeps your business logic from depending on wire protocols.</p>

<p>You can pass a <code>map[string]any</code> to <code>json.Marshal</code> and <code>json.Unmarshal</code> to translate back and forth between JSON and Go, but save that for the exploratory phase of your coding and replace it with a concrete type when you understand what you are processing. Go uses types for a reason; they document the expected data and the types of the expected data.</p>

<p>While JSON is probably the most commonly used encoder in the standard library, Go ships with others, including XML and Base64. If you have a data format that you want to encode and you can’t find support for it in the standard library or a third-party module, you can write one yourself. You’ll learn how to implement our own encoder in <a data-type="xref" href="ch16.html#csv_marshaler">“Use Reflection to Write a Data Marshaler”</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The standard library includes <code>encoding/gob</code>, which is a Go-specific binary representation that is a bit like serialization in Java. Just as Java serialization is the wire protocol for Enterprise Java Beans and Java RMI, the gob protocol is intended as the wire format for a Go-specific RPC (remote procedure call) implementation in the <code>net/rpc</code> package. Don’t use either <code>encoding/gob</code> or <code>net/rpc</code>. If you want to do remote method invocation with Go, use a standard protocol like <a href="https://grpc.io">GRPC</a> so that you aren’t tied to a specific language. No matter how much you love Go, if you want your services to be useful, make them callable by developers using other 
<span class="keep-together">languages.</span><a data-type="indexterm" data-startref="ch13-json2" id="id2686"/><a data-type="indexterm" data-startref="ch13-json3" id="id2687"/><a data-type="indexterm" data-startref="ch13-json4" id="id2688"/><a data-type="indexterm" data-startref="ch13-cus" id="id2689"/><a data-type="indexterm" data-startref="ch13-cus2" id="id2690"/></p>
</div>
</div></section>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="net/http"><div class="sect1" id="id175">
<h1>net/http</h1>

<p>Every language ships with a standard library,<a data-type="indexterm" data-primary="standard library" data-secondary="net/http package" id="ch13-net"/><a data-type="indexterm" data-primary="net/http package" id="ch13-net2"/><a data-type="indexterm" data-primary="http support" data-see="net/http package" id="id2691"/> but the expectations of what a standard library should include have changed over time. As a language launched in the 2010s, Go’s standard library includes something that other language distributions had 
<span class="keep-together">considered</span> the responsibility of a third party: a production-quality HTTP/2 client and server.</p>








<section data-type="sect2" data-pdf-bookmark="The Client"><div class="sect2" id="id176">
<h2>The Client</h2>

<p>The <code>net/http</code> package defines<a data-type="indexterm" data-primary="types" data-secondary="net/http package Client type" id="ch13-net3"/><a data-type="indexterm" data-primary="Client type" id="ch13-net4"/><a data-type="indexterm" data-primary="net/http package" data-secondary="Client type" id="ch13-net5"/> a <code>Client</code> type to make HTTP requests and receive HTTP responses. A default client instance (cleverly named <code>DefaultClient</code>) is found in the <code>net/http</code> package, but you should avoid using it in production applications, because it defaults to having no timeout. Instead, instantiate your own. You need to create only a single <code>http.Client</code> for your entire program, as it properly handles multiple simultaneous requests across goroutines:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">client</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">http</code><code class="p">.</code><code class="nx">Client</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Timeout</code><code class="p">:</code><code class="w"> </code><code class="mi">30</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When you want to make a request,<a data-type="indexterm" data-primary="net/http package" data-secondary="http.NewRequestWithContext" id="id2692"/> you create a new <code>*http.Request</code> instance with the <code>http.NewRequestWithContext</code> function, passing it a context, the method, and URL that you are connecting to. If you are making a <code>PUT</code>, <code>POST</code>, or <code>PATCH</code> request, specify the body of the request with the last parameter as an <code>io.Reader</code>. If there is no body, use <code>nil</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">req</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewRequestWithContext</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(),</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">MethodGet</code><code class="p">,</code><code class="w"> </code><code class="s">"https://jsonplaceholder.typicode.com/todos/1"</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I’ll talk about what a context is in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a>.</p>
</div>

<p>Once you have an <code>*http.Request</code> instance, you can set any headers via the <code>Headers</code> field of the instance. Call the <code>Do</code> method on the <code>http.Client</code> with your <code>http.Request</code>, and the result is returned in an <code>http.Response</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">req</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="s">"X-My-Client"</code><code class="p">,</code><code class="w"> </code><code class="s">"Learning Go"</code><code class="p">)</code><code class="w"/>
<code class="nx">res</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">client</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The response has several fields with information on the request. The numeric code of the response status is in the <code>StatusCode</code> field, the text of the response code is in the <code>Status</code> field, the response headers are in the <code>Header</code> field, and any returned content is in a <code>Body</code> field of type <code>io.ReadCloser</code>. This allows you to use it with <code>json.Decoder</code> to process REST API responses:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">defer</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">Body</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">StatusCode</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusOK</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"unexpected status: got %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">Status</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">res</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"Content-Type"</code><code class="p">))</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">UserID</code><code class="w">    </code><code class="kt">int</code><code class="w">    </code><code class="s">`json:"userId"`</code><code class="w"/>
<code class="w">    </code><code class="nx">ID</code><code class="w">        </code><code class="kt">int</code><code class="w">    </code><code class="s">`json:"id"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Title</code><code class="w">     </code><code class="kt">string</code><code class="w"> </code><code class="s">`json:"title"`</code><code class="w"/>
<code class="w">    </code><code class="nx">Completed</code><code class="w"> </code><code class="kt">bool</code><code class="w">   </code><code class="s">`json:"completed"`</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">NewDecoder</code><code class="p">(</code><code class="nx">res</code><code class="p">.</code><code class="nx">Body</code><code class="p">).</code><code class="nx">Decode</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%+v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">)</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/client</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 
<span class="keep-together">repository</span></a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="ix_m12"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="ix_mmm123"/></p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>There are functions in the <code>net/http</code> package to make <code>GET</code>, <code>HEAD</code>, and <code>POST</code> calls. Avoid using these functions because they use the default client, which means they don’t set a request timeout.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Server"><div class="sect2" id="http_server">
<h2>The Server</h2>

<p>The HTTP Server is built around the concept<a data-type="indexterm" data-primary="net/http package" data-secondary="http.Server" id="id2693"/> of an <code>http.Server</code> and the 
<span class="keep-together"><code>http.Handler</code></span> interface. Just as the <code>http.Client</code> sends HTTP requests, the <code>http.Server</code> is responsible for listening for HTTP requests. It is a performant HTTP/2 server that supports TLS.</p>

<p>A request to a server is handled by an implementation<a data-type="indexterm" data-primary="net/http package" data-secondary="http.Handler interface" id="id2694"/> of the <code>http.Handler</code> interface that’s assigned to the <code>Handler</code> field. This interface defines a single method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Handler</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>*http.Request</code> should look familiar, as it’s the exact same type that’s used to send a request to an HTTP server. The <code>http.ResponseWriter</code> is an interface with three methods:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">ResponseWriter</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">Header</code><code class="p">()</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Header</code><code class="w"/>
<code class="w">        </code><code class="nx">Write</code><code class="p">([]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">statusCode</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>These methods must be called in a specific order. First, call <code>Header</code> to get an instance of <code>http.Header</code> and set any response headers you need. If you don’t need to set any headers, you don’t need to call it. Next, call <code>WriteHeader</code> with the HTTP status code for your response. (All the status codes are defined as constants in the <code>net/http</code> package. This would have been a good place to define a custom type, but that was not done; all status code constants are untyped integers.) If you are sending a response that has a 200 status code, you can skip <code>WriteHeader</code>. Finally, call the <code>Write</code> method to set the body for the response. Here’s what a trivial handler looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">HelloHandler</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">hh</code><code class="w"> </code><code class="nx">HelloHandler</code><code class="p">)</code><code class="w"> </code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"Hello!\n"</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You instantiate a new <code>http.Server</code> just like any other struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Server</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Addr</code><code class="p">:</code><code class="w">         </code><code class="s">":8080"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">ReadTimeout</code><code class="p">:</code><code class="w">  </code><code class="mi">30</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">WriteTimeout</code><code class="p">:</code><code class="w"> </code><code class="mi">90</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">IdleTimeout</code><code class="p">:</code><code class="w">  </code><code class="mi">120</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">Handler</code><code class="p">:</code><code class="w">      </code><code class="nx">HelloHandler</code><code class="p">{},</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">s</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ErrServerClosed</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Addr</code> field specifies the host and port the server listens on. If you don’t specify them, your server defaults to listening on all hosts on the standard HTTP port, 80. You specify timeouts for the server’s reads, writes, and idles by using <code>time.Duration</code> values. Be sure to set these to properly handle malicious or broken HTTP clients, as the default behavior is to not time out at all. Finally, you specify the <code>http.Handler</code> for your server with the <code>Handler</code> field.</p>

<p>You can find this code in the <em>sample_code/server</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 
<span class="keep-together">repository</span></a>.<a data-type="indexterm" data-startref="ix_mmm123" id="id2695"/></p>

<p>A server that handles only a single request isn’t terribly useful,<a data-type="indexterm" data-primary="net/http package" data-secondary="*http.ServeMux" data-secondary-sortas="http.ServeMux" id="id2696"/><a data-type="indexterm" data-primary="net/http package" data-secondary="http.NewServeMux" id="id2697"/> so the Go standard library includes a request router, <code>*http.ServeMux</code>. You create an instance with the <code>http.NewServeMux</code> function. It meets the <code>http.Handler</code> interface, so it can be assigned to the <code>Handler</code> field in <code>http.Server</code>. It also includes two methods that allow it to dispatch requests. The first method is called <code>Handle</code> and takes in two parameters, a path and an <code>http.Handler</code>. If the path matches, the <code>http.Handler</code> is invoked.</p>

<p>While you could create implementations of <code>http.Handler</code>, the more common pattern is to use the <code>HandleFunc</code> method on <code>*http.ServeMux</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">mux</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/hello"</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"Hello!\n"</code><code class="p">))</code><code class="w"/>
<code class="p">})</code><code class="w"/></pre>

<p>This method takes in a function or closure and converts it to an <code>http.HandlerFunc</code>. You explored the <code>http.HandlerFunc</code> type in <a data-type="xref" href="ch07.html#function_type_interface">“Function Types Are a Bridge to Interfaces”</a>. For simple handlers, a closure is sufficient. For more complicated handlers that depend on other business logic, use a method on a struct, as demonstrated in <a data-type="xref" href="ch07.html#dependency_injection">“Implicit Interfaces Make Dependency Injection Easier”</a>.</p>

<p>Go 1.22 extends the path syntax to optionally allow HTTP verbs and path wildcard variables. The value of a wildcard variable is read using the <code>PathValue</code> method on <code>http.Request</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">mux</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"GET /hello/{name}"</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"/>
<code class="w">                                         </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">name</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">PathValue</code><code class="p">(</code><code class="s">"name"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"Hello, %s!\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">name</code><code class="p">)))</code><code class="w"/>
<code class="p">})</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The package-level functions<a data-type="indexterm" data-primary="net/http package" data-secondary="http.DefaultServeMux and functions avoided" id="id2698"/> <code>http.Handle</code>, <code>http.HandleFunc</code>, <code>http.ListenAndServe</code>, and <code>http.ListenAndServeTLS</code> that work with a package-level instance of the <code>*http.ServeMux</code> called <code>http.​DefaultServeMux</code>. Don’t use them outside trivial test 
<span class="keep-together">programs.</span> The <code>http.Server</code> instance is created in the 
<span class="keep-together"><code>http.ListenAndServe</code></span> and <code>http.ListenAndServeTLS</code> functions, 
<span class="keep-together">so you</span> are unable to configure server properties like timeouts. Furthermore, third-party libraries could have registered their own handlers with the <code>http.DefaultServeMux</code>, and there’s no way to know without scanning through all your dependencies (both direct and indirect). Keep your application under control by avoiding shared state.</p>
</div>

<p>Because <code>*http.ServeMux</code> dispatches requests to <code>http.Handler</code> instances, and since <code>*http.ServeMux</code> implements <code>http.Handler</code>, you can create an 
<span class="keep-together"><code>*http.ServeMux</code></span> instance with multiple related requests and register it with a parent 
<span class="keep-together"><code>*http.ServeMux</code>:</span></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">person</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewServeMux</code><code class="p">()</code><code class="w"/>
<code class="nx">person</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/greet"</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"greetings!\n"</code><code class="p">))</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">dog</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewServeMux</code><code class="p">()</code><code class="w"/>
<code class="nx">dog</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/greet"</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"good puppy!\n"</code><code class="p">))</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">mux</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewServeMux</code><code class="p">()</code><code class="w"/>
<code class="nx">mux</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/person/"</code><code class="p">,</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StripPrefix</code><code class="p">(</code><code class="s">"/person"</code><code class="p">,</code><code class="w"> </code><code class="nx">person</code><code class="p">))</code><code class="w"/>
<code class="nx">mux</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/dog/"</code><code class="p">,</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StripPrefix</code><code class="p">(</code><code class="s">"/dog"</code><code class="p">,</code><code class="w"> </code><code class="nx">dog</code><code class="p">))</code><code class="w"/></pre>

<p>In this example, a request for <code>/person/greet</code> is handled by handlers attached to 
<span class="keep-together"><code>person</code>,</span> while <code>/dog/greet</code> is handled by handlers attached to <code>dog</code>. When you register 
<span class="keep-together"><code>person</code></span> and <code>dog</code> with <code>mux</code>, you use the <code>http.StripPrefix</code> helper function to remove the part of the path that’s already been processed by <code>mux</code>. You can find this code in the <em>sample_code/server_mux</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2699"/></p>










<section data-type="sect3" data-pdf-bookmark="Middleware"><div class="sect3" id="middleware">
<h3>Middleware</h3>

<p>One of the most common requirements<a data-type="indexterm" data-primary="net/http package" data-secondary="http.Server" data-tertiary="middleware pattern" id="ch13-midw"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" id="ch13-midw2"/> of an HTTP server is to perform a set of actions across multiple handlers, such as checking whether a user is logged in, timing a request, or checking a request header. Go handles these cross-cutting concerns with the <em>middleware pattern</em>.</p>

<p>Rather than using a special type, the middleware pattern uses a function that takes in an <code>http.Handler</code> instance and returns an <code>http.Handler</code>. Usually, the returned <code>http.Handler</code> is a closure that is converted to an 
<span class="keep-together"><code>http.HandlerFunc</code>.</span> Here are two middleware generators, one that provides timing of requests and another that uses perhaps the worst access controls imaginable:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">RequestTimer</code><code class="p">(</code><code class="nx">h</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">start</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">h</code><code class="p">.</code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">dur</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Since</code><code class="p">(</code><code class="nx">start</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"request time"</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="s">"path"</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">URL</code><code class="p">.</code><code class="nx">Path</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="s">"duration"</code><code class="p">,</code><code class="w"> </code><code class="nx">dur</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">var</code><code class="w"> </code><code class="nx">securityMsg</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"You didn't give the secret password\n"</code><code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">TerribleSecurityProvider</code><code class="p">(</code><code class="nx">password</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">h</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"X-Secret-Password"</code><code class="p">)</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">password</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">w</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusUnauthorized</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">(</code><code class="nx">securityMsg</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nx">h</code><code class="p">.</code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">})</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>These two middleware implementations demonstrate what middleware does. First, you do setup operations or checks. If the checks don’t pass, you write the output in the middleware (usually with an error code) and return. If all is well, you call the handler’s <code>ServeHTTP</code> method. When that returns, you run cleanup operations.</p>

<p>The <code>TerribleSecurityProvider</code> shows how to create configurable middleware. You pass in the configuration information (in this case, the password), and the function returns middleware that uses that configuration information. It is a bit of a mind bender, as it returns a closure that returns a closure.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You might be wondering how to pass values through the layers of middleware. This is done via the context, which you’ll look at in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a>.</p>
</div>

<p>You add middleware to your request handlers by chaining them:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">terribleSecurity</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">TerribleSecurityProvider</code><code class="p">(</code><code class="s">"GOPHER"</code><code class="p">)</code><code class="w"/>

<code class="nx">mux</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/hello"</code><code class="p">,</code><code class="w"> </code><code class="nx">terribleSecurity</code><code class="p">(</code><code class="nx">RequestTimer</code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"Hello!\n"</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}))))</code><code class="w"/></pre>

<p>We get back your middleware from <code>TerribleSecurityProvider</code> and then wrap your handler in a series of function calls. This calls the <code>terribleSecurity</code> closure first, then calls the <code>RequestTimer</code>, which then calls your actual request handler.</p>

<p>Because <code>*http.ServeMux</code> implements the <code>http.Handler</code> interface, you can apply a set of middleware to all the handlers registered with a single request router:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">terribleSecurity</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">TerribleSecurityProvider</code><code class="p">(</code><code class="s">"GOPHER"</code><code class="p">)</code><code class="w"/>
<code class="nx">wrappedMux</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">terribleSecurity</code><code class="p">(</code><code class="nx">RequestTimer</code><code class="p">(</code><code class="nx">mux</code><code class="p">))</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Server</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Addr</code><code class="p">:</code><code class="w">    </code><code class="s">":8080"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nx">Handler</code><code class="p">:</code><code class="w"> </code><code class="nx">wrappedMux</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/middleware</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-startref="ix_m12" id="id2700"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2701"/><a data-type="indexterm" data-startref="ch13-midw" id="id2702"/><a data-type="indexterm" data-startref="ch13-midw2" id="id2703"/></p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Use third-party modules to enhance the server"><div class="sect3" id="id179">
<h3>Use third-party modules to enhance the server</h3>

<p>Just because the server is production<a data-type="indexterm" data-primary="net/http package" data-secondary="http.Server" data-tertiary="third-party modules to enhance" id="id2704"/><a data-type="indexterm" data-primary="third-party modules for http.Server" id="id2705"/> quality doesn’t mean that you shouldn’t use third-party modules to improve its functionality. If you don’t like the function chains for middleware, <a data-type="indexterm" data-primary="alice module for http.Server" id="id2706"/>you can use a third-party module called <a href="https://oreil.ly/_cS1w"><code>alice</code></a>, which allows you to use the following syntax:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">helloHandler</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"Hello!\n"</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">chain</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">alice</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">terribleSecurity</code><code class="p">,</code><code class="w"> </code><code class="nx">RequestTimer</code><code class="p">).</code><code class="nx">ThenFunc</code><code class="p">(</code><code class="nx">helloHandler</code><code class="p">)</code><code class="w"/>
<code class="nx">mux</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/hello"</code><code class="p">,</code><code class="w"> </code><code class="nx">chain</code><code class="p">)</code><code class="w"/></pre>

<p>While <code>*http.ServeMux</code> gained some much-requested features in Go 1.22, its routing and variable support are still basic. Nesting <code>*http.ServeMux</code> instances is also a bit clunky. If you find yourself needing more advanced features, such as routing based on a header value, specifying a path variable using a regular expression, or better handler nesting, <a data-type="indexterm" data-primary="gorilla mux request router" id="id2707"/><a data-type="indexterm" data-primary="chi request router" id="id2708"/> many third-party request routers are available. Two of the most popular ones are <a href="https://oreil.ly/CrQ4i">gorilla mux</a> and <a href="https://oreil.ly/twYcG">chi</a>. Both are considered idiomatic because they work with <code>http.Handler</code> and <code>http.HandlerFunc</code> instances, demonstrating the Go philosophy of using composable libraries that fit together with the standard library. They also work with idiomatic middleware, and both projects provide optional middleware implementations of common concerns.</p>

<p>Several popular web frameworks<a data-type="indexterm" data-primary="Echo web framework" id="id2709"/><a data-type="indexterm" data-primary="Gin web framework" id="id2710"/> also implement their own handler and middleware patterns. Two of the most popular are <a href="https://oreil.ly/7UdEi">Echo</a> and <a href="https://oreil.ly/vvTve">Gin</a>. They simplify web development by incorporating features like automating the binding of data in requests or responses to JSON. They also provide adapter functions that enable you to use <code>http.Handler</code> implementations, providing a migration path.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="ResponseController"><div class="sect2" id="id180">
<h2>ResponseController</h2>

<p>In <a data-type="xref" href="ch07.html#accept_interface">“Accept Interfaces, Return Structs”</a>, you learned that<a data-type="indexterm" data-primary="net/http package" data-secondary="http.ResponseController" id="id2711"/> modifying interfaces breaks backward compatibility. You also learned that you can evolve an interface over time by defining new interfaces and using type switches and type assertions to see whether the new interfaces are implemented. The drawback to creating these additional interfaces is that it is difficult to know that they exist, and using type switches to check for them is verbose.</p>

<p>You can find an example of this in the <code>http</code> package. When the package was designed, the choice was made to make <code>http.ResponseWriter</code> an interface. This meant that additional methods could not be added to it in future releases, or the Go Compatibility Guarantee would be broken. <a data-type="indexterm" data-primary="net/http package" data-secondary="http.Flusher interface" id="id2712"/><a data-type="indexterm" data-primary="net/http package" data-secondary="http.Hijacker interface" id="id2713"/>To represent new optional functionality for an <code>http.ResponseWriter</code> instance, the <code>http</code> package contains a couple of interfaces that may be implemented by <code>http.ResponseWriter</code> implementations: <code>http.Flusher</code> and <code>http.Hijacker</code>. The methods on these interfaces are used to control the output for a response.</p>

<p>In Go 1.20, a new concrete type was added to the <code>http</code> package, <code>http.ResponseController</code>. It demonstrates another way to expose methods that have been added to an existing API:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">handler</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">rc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewResponseController</code><code class="p">(</code><code class="nx">rw</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">result</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doStuff</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">result</code><code class="p">))</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="s">"error writing"</code><code class="p">,</code><code class="w"> </code><code class="s">"msg"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">rc</code><code class="p">.</code><code class="nx">Flush</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">!</code><code class="nx">errors</code><code class="p">.</code><code class="nx">Is</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ErrNotSupported</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="s">"error flushing"</code><code class="p">,</code><code class="w"> </code><code class="s">"msg"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In this example, you want to return data to the client as it is calculated, if the <code>http.ResponseWriter</code> supports <code>Flush</code>.  If not, you will return all the data after all of it has been calculated. The factory function <code>http.NewResponseController</code> takes in an <code>http.ResponseWriter</code> and returns a pointer to an <code>http.ResponseController</code>. This concrete type has methods for the optional functionality of an <code>http.ResponseWriter</code>. You check whether the optional method is implemented by the underlying <code>http.ResponseWriter</code> by comparing the returned error to <code>http.ErrNotSupported</code> using <code>errors.Is</code>. <a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2714"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="ix_mmmmm12345"/>You can find this code in the <em>sample_code/response_controller</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.</p>

<p>Because <code>http.ResponseController</code> is a concrete type that wraps access to an <code>http.ResponseWriter</code> implementation, new methods can be added to it over time without breaking existing implementations. This makes new functionality discoverable and provides a way to check for the presence or absence of an optional method with a standard error check. This pattern is an interesting way to handle situations where an interface needs to evolve. In fact, <code>http.ResponseController</code> contains two methods that don’t have corresponding interfaces: <code>SetReadDeadline</code> and <code>SetWriteDeadline</code>. Future optional methods on <code>http.ResponseWriter</code> will likely be added via this technique.<a data-type="indexterm" data-startref="ch13-net" id="id2715"/><a data-type="indexterm" data-startref="ch13-net2" id="id2716"/><a data-type="indexterm" data-startref="ch13-net3" id="id2717"/><a data-type="indexterm" data-startref="ch13-net4" id="id2718"/><a data-type="indexterm" data-startref="ch13-net5" id="id2719"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Structured Logging"><div class="sect1" id="slog">
<h1>Structured Logging</h1>

<p>Since its initial release, the Go standard library<a data-type="indexterm" data-primary="standard library" data-secondary="log/slog package" id="ch13-slog"/><a data-type="indexterm" data-primary="structured logging" id="ch13-slog2"/><a data-type="indexterm" data-primary="log/slog package" id="ch13-slog3"/> has included a simple logging package, <code>log</code>. While it’s fine for small programs, it doesn’t easily produce <em>structured</em> logs. Modern web services can have millions of simultaneous users, and at that scale you need software to process log output in order to understand what’s going on. A structured log uses a documented format for each log entry, making it easier to write programs that process log output and discover patterns and anomalies.</p>

<p>JSON is commonly used for structured logs, but even whitespace separated key-value pairs are easier to process than unstructured logs that don’t separate values into fields. While you certainly could write JSON by using the <code>log</code> package, it doesn’t provide any support for simplifying structured log creation. The <code>log/slog</code> package resolves this problem.</p>

<p>Adding <code>log/slog</code> to the standard library demonstrated several good Go library design practices. The first good decision was to include structured logging in the standard library. Having a standard structured logger makes it easier to write modules that work together. Several third-party structured loggers have been released to address the shortcomings of <code>log</code>, including <a href="https://oreil.ly/gkd0p">zap</a>, <a href="https://oreil.ly/7QpFC">logrus</a>, <a href="https://oreil.ly/Obk0L">go-kit log</a>, and many others. The problem with a fragmented logging ecosystem is that you want control over where log output goes and what level of messages are logged. If your code depends on third-party modules that use different loggers, this becomes impossible. The usual advice to prevent logging fragmentation is to not log in a module intended as a library, but that’s impossible to enforce and makes it harder to monitor what’s going on in a third-party library. The <code>log/slog</code> package was new in Go 1.21, but the fact that it solves these inconsistencies makes it likely that within a few years, it will be used in the vast majority of Go programs.</p>

<p>The second good decision was to make structured logging its own package and not part of the <code>log</code> package. While both packages have similar purposes, they have very different design philosophies. Trying to add structured logging into an unstructured logging package would confuse the API. By making them separate packages, you know at a glance that <code>slog.Info</code> is a structured log and <code>log.Print</code> is unstructured, even if you don’t remember whether <code>Info</code> is for structured or unstructured logging.</p>

<p>The next good decision was to make the <code>log/slog</code> API scalable. It starts simply, with a default logger available via functions:<a data-type="indexterm" data-primary="log/slog package" data-secondary="slog.Debug" id="id2720"/><a data-type="indexterm" data-primary="log/slog package" data-secondary="slog.Info" id="id2721"/><a data-type="indexterm" data-primary="log/slog package" data-secondary="slog.Warn" id="id2722"/><a data-type="indexterm" data-primary="log/slog package" data-secondary="slog.Error" id="id2723"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Debug</code><code class="p">(</code><code class="s">"debug log message"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"info log message"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Warn</code><code class="p">(</code><code class="s">"warning log message"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="s">"error log message"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>These functions allow you to log simple messages at various logging levels. The output looks like the following:</p>

<pre data-type="programlisting">2023/04/20 23:13:31 INFO info log message
2023/04/20 23:13:31 WARN warning log message
2023/04/20 23:13:31 ERROR error log message</pre>

<p>There are two things to notice. First, the default logger suppresses debug messages by default. You’ll see how to control the logging level when I discuss creating your own logger in a bit.</p>

<p>The second point is a bit more subtle. While this is plain-text output, it uses whitespace to make a structured log. The first column is the date in year/month/day format. The second column is the time in 24-hour time. The third column is the logging level. Finally, there is the message.</p>

<p>The power of structured logging comes from the ability to add fields with custom values. Update your logs with some custom fields:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">userID</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"fred"</code><code class="w"/>
<code class="nx">loginCount</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">slog</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"user login"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"id"</code><code class="p">,</code><code class="w"> </code><code class="nx">userID</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"login_count"</code><code class="p">,</code><code class="w"> </code><code class="nx">loginCount</code><code class="p">)</code><code class="w"/></pre>

<p>You use the same function as before, but now you add optional arguments. Optional arguments come in pairs. The first part is the key, which should be a string. The second part is the value. This log line prints out the following:</p>

<pre data-type="programlisting">2023/04/20 23:36:38 INFO user login id=fred login_count=20</pre>

<p>After the message, you have key-value pairs, again space separated.</p>

<p>While this text format is far easier to parse than an unstructured log, you might want to use something like JSON instead. You also might want to customize where the log is written or the logging level. To do that, you create a structured logging instance:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">options</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">slog</code><code class="p">.</code><code class="nx">HandlerOptions</code><code class="p">{</code><code class="nx">Level</code><code class="p">:</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">LevelDebug</code><code class="p">}</code><code class="w"/>
<code class="nx">handler</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">NewJSONHandler</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Stderr</code><code class="p">,</code><code class="w"> </code><code class="nx">options</code><code class="p">)</code><code class="w"/>
<code class="nx">mySlog</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">handler</code><code class="p">)</code><code class="w"/>
<code class="nx">lastLogin</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Date</code><code class="p">(</code><code class="mi">2023</code><code class="p">,</code><code class="w"> </code><code class="mo">01</code><code class="p">,</code><code class="w"> </code><code class="mo">01</code><code class="p">,</code><code class="w"> </code><code class="mi">11</code><code class="p">,</code><code class="w"> </code><code class="mi">50</code><code class="p">,</code><code class="w"> </code><code class="mo">00</code><code class="p">,</code><code class="w"> </code><code class="mo">00</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">UTC</code><code class="p">)</code><code class="w"/>
<code class="nx">mySlog</code><code class="p">.</code><code class="nx">Debug</code><code class="p">(</code><code class="s">"debug message"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"id"</code><code class="p">,</code><code class="w"> </code><code class="nx">userID</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s">"last_login"</code><code class="p">,</code><code class="w"> </code><code class="nx">lastLogin</code><code class="p">)</code><code class="w"/></pre>

<p>You are using the <code>slog.HandlerOptions</code> struct to define the minimum logging level for the new logger. You then use the <code>NewJSONHandler</code> method on 
<span class="keep-together"><code>slog.HandlerOptions</code></span> to create a <code>slog.Handler</code> that writes logs using JSON to the specified <code>io.Writer</code>. In this case, you are using the standard error output. Finally, you use the <code>slog.New</code> function to create a <code>*slog.Logger</code> that wraps the 
<span class="keep-together"><code>slog.Handler</code>.</span> You then create a <code>lastLogin</code> value to log, along with a user ID. This gives the following output:</p>

<pre data-type="programlisting">{"time":"2023-04-22T23:30:01.170243-04:00","level":"DEBUG",
 "msg":"debug message","id":"fred","last_login":"2023-01-01T11:50:00Z"}</pre>

<p>If JSON and text aren’t sufficient for your output needs, you can define your own implementation of the <code>slog.Handler</code> interface and pass it to <code>slog.New</code>.</p>

<p>Finally, the <code>log/slog</code> package takes performance into consideration. If you aren’t careful, your program might end up spending more time writing logs than doing the work it was designed to perform. You can choose to write data out to <code>log/slog</code> in a number of ways. You have already seen the simplest (but slowest) method, using alternating keys and values on the <code>Debug</code>, <code>Info</code>, <code>Warn</code>, and <code>Error</code> methods. For improved performance with fewer allocations, use the <code>LogAttrs</code> method instead:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">mySlog</code><code class="p">.</code><code class="nx">LogAttrs</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">LevelInfo</code><code class="p">,</code><code class="w"> </code><code class="s">"faster logging"</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="nx">slog</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"id"</code><code class="p">,</code><code class="w"> </code><code class="nx">userID</code><code class="p">),</code><code class="w"/>
<code class="w">                </code><code class="nx">slog</code><code class="p">.</code><code class="nx">Time</code><code class="p">(</code><code class="s">"last_login"</code><code class="p">,</code><code class="w"> </code><code class="nx">lastLogin</code><code class="p">))</code><code class="w"/></pre>

<p>The first parameter is a <code>context.Context</code>, next comes the logging level, and then zero or more <code>slog.Attr</code> instances. There are factory functions for the most commonly used types, and you can use <code>slog.Any</code> for the ones that don’t have functions already supplied.</p>

<p>Because of the Go Compatibility Promise, the <code>log</code> package isn’t going away. Existing programs that use it will continue to work, as will programs that use third-party structured loggers.<a data-type="indexterm" data-primary="log/slog package" data-secondary="slog.NewLogLogger" id="id2724"/> If you have code that uses a <code>log.Logger</code>, the <code>slog.NewLogLogger</code> function provides a bridge to the original <code>log</code> package. It creates a <code>log.Logger</code> instance that uses a <code>slog.Handler</code> to write its output:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">myLog</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">NewLogLogger</code><code class="p">(</code><code class="nx">mySlog</code><code class="p">.</code><code class="nx">Handler</code><code class="p">(),</code><code class="w"> </code><code class="nx">slog</code><code class="p">.</code><code class="nx">LevelDebug</code><code class="p">)</code><code class="w"/>
<code class="nx">myLog</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"using the mySlog Handler"</code><code class="p">)</code><code class="w"/></pre>

<p>This produces the following output:</p>

<pre data-type="programlisting">{"time":"2023-04-22T23:30:01.170269-04:00","level":"DEBUG",
 "msg":"using the mySlog Handler"}</pre>

<p>You can find all the coding examples for <code>log/slog</code> in the <em>sample_code/structured_logging</em> directory in the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2725"/></p>

<p>The <code>log/slog</code> API includes more features, including dynamic logging-level support, context support (the context is covered in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a>), grouping values, and creating a common header of values. <a data-type="indexterm" data-primary="log/slog package" data-secondary="API documentation URL" id="id2726"/><a data-type="indexterm" data-primary="APIs" data-secondary="log/slog package documentation URL" id="id2727"/><a data-type="indexterm" data-primary="resources online" data-secondary="log/slog package documentation" id="id2728"/>You can learn more by looking at its <a href="https://oreil.ly/LRhGf">API documentation</a>. Most importantly, look at how <code>log/slog</code> was put together so you can learn how to construct APIs of your own.<a data-type="indexterm" data-startref="ch13-slog" id="id2729"/><a data-type="indexterm" data-startref="ch13-slog2" id="id2730"/><a data-type="indexterm" data-startref="ch13-slog3" id="id2731"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id182">
<h1>Exercises</h1>

<p>Now that you’ve learned more about the standard library, work through these exercises to reinforce what you’ve learned. Solutions are in the <em>exercise_solutions</em> directory of the <a href="https://oreil.ly/XOPbD">Chapter 13 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 13" data-tertiary-sortas="mmm" id="id2732"/><a data-type="indexterm" data-startref="ix_mmmmm12345" id="id2733"/></p>
<ol>
<li>
<p>Write a small web server that returns the current time in RFC 3339 format when you send it a <code>GET</code> command. You can use a third-party module if you’d like.</p>
</li>
<li>
<p>Write a small middleware component that uses JSON structured logging to log the IP address of each incoming request to your web server.</p>
</li>
<li>
<p>Add the ability to return the time as JSON. Use the <code>Accept</code> header to control whether JSON or text is returned (default to text). The JSON should be structured as follows:</p>
<div class="openblock">
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"day_of_week"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Monday"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"day_of_month"</code><code class="p">:</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"month"</code><code class="p">:</code><code class="w"> </code><code class="s2">"April"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"year"</code><code class="p">:</code><code class="w"> </code><code class="mi">2023</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"hour"</code><code class="p">:</code><code class="w"> </code><code class="mi">20</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"minute"</code><code class="p">:</code><code class="w"> </code><code class="mi">15</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"second"</code><code class="p">:</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id355">
<h1>Wrapping Up</h1>

<p>In this chapter, you looked at some of the most commonly used packages in the standard library and saw how they embody best practices that should be emulated in your code. You’ve also seen other sound software engineering principles: how some decisions might have been made differently given experience, and how to respect backward compatibility so you can build applications on a solid foundation.</p>

<p>In the next chapter, you’re going to look at the context, a package and pattern for passing state and timers through Go code.</p>
</div></section>
</div></section></div>
</div>
</body></html>