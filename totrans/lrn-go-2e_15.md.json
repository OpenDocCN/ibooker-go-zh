["```go\nfunc addNumbers(x, y int) int {\n    return x + x\n}\n```", "```go\nfunc Test_addNumbers(t *testing.T) {\n    result := addNumbers(2,3)\n    if result != 5 {\n        t.Error(\"incorrect result: expected 5, got\", result)\n    }\n}\n```", "```go\n$ go test\n--- FAIL: Test_addNumbers (0.00s)\n    adder_test.go:8: incorrect result: expected 5, got 4\nFAIL\nexit status 1\nFAIL    test_examples/adder     0.006s\n\n```", "```go\n$ go test\nPASS\nok      test_examples/adder     0.006s\n\n```", "```go\nt.Errorf(\"incorrect result: expected %d, got %d\", 5, result)\n```", "```go\nvar testTime time.Time\n\nfunc TestMain(m *testing.M) {\n    fmt.Println(\"Set up stuff for tests here\")\n    testTime = time.Now()\n    exitVal := m.Run()\n    fmt.Println(\"Clean up stuff after tests here\")\n    os.Exit(exitVal)\n}\n\nfunc TestFirst(t *testing.T) {\n    fmt.Println(\"TestFirst uses stuff set up in TestMain\", testTime)\n}\n\nfunc TestSecond(t *testing.T) {\n    fmt.Println(\"TestSecond also uses stuff set up in TestMain\", testTime)\n}\n```", "```go\n$ go test\nSet up stuff for tests here\nTestFirst uses stuff set up in TestMain 2020-09-01 21:42:36.231508 -0400 EDT\n    m=+0.000244286\nTestSecond also uses stuff set up in TestMain 2020-09-01 21:42:36.231508 -0400\n    EDT m=+0.000244286\nPASS\nClean up stuff after tests here\nok      test_examples/testmain  0.006s\n\n```", "```go\n// createFile is a helper function called from multiple tests\nfunc createFile(t *testing.T) (_ string, err error) {\n    f, err := os.Create(\"tempFile\")\n    if err != nil {\n        return \"\", err\n    }\n    defer func() {\n        err = errors.Join(err, f.Close())\n    }()\n    // write some data to f\n    t.Cleanup(func() {\n        os.Remove(f.Name())\n    })\n    return f.Name(), nil\n}\n\nfunc TestFileProcessing(t *testing.T) {\n    fName, err := createFile(t)\n    if err != nil {\n        t.Fatal(err)\n    }\n    // do testing, don't worry about cleanup\n}\n```", "```go\n// createFile is a helper function called from multiple tests\nfunc createFile(tempDir string) (_ string, err error) {\n    f, err := os.CreateTemp(tempDir, \"tempFile\")\n    if err != nil {\n        return \"\", err\n    }\n    defer func() {\n        err = errors.Join(err, f.Close())\n    }()\n    // write some data to f\n    return f.Name(), nil\n}\n\nfunc TestFileProcessing(t *testing.T) {\n    tempDir := t.TempDir()\n    fName, err := createFile(tempDir)\n    if err != nil {\n        t.Fatal(err)\n    }\n    // do testing, don't worry about cleanup\n}\n```", "```go\n// assume ProcessEnvVars is a function that processes environment variables\n// and returns a struct with an OutputFormat field\nfunc TestEnvVarProcess(t *testing.T) {\n    t.Setenv(\"OUTPUT_FORMAT\", \"JSON\")\n    cfg := ProcessEnvVars()\n    if cfg.OutputFormat != \"JSON\" {\n        t.Error(\"OutputFormat not set correctly\")\n    }\n    // value of OUTPUT_FORMAT is reset when the test function exits\n}\n```", "```go\nfunc AddNumbers(x, y int) int {\n    return x + y\n}\n```", "```go\npackage pubadder_test\n\nimport (\n    \"github.com/learning-go-book-2e/ch15/sample_code/pubadder\"\n    \"testing\"\n)\n\nfunc TestAddNumbers(t *testing.T) {\n    result := pubadder.AddNumbers(2, 3)\n    if result != 5 {\n        t.Error(\"incorrect result: expected 5, got\", result)\n    }\n}\n```", "```go\nmodule github.com/learning-go-book-2e/ch15\n```", "```go\ntype Person struct {\n    Name      string\n    Age       int\n    DateAdded time.Time\n}\n\nfunc CreatePerson(name string, age int) Person {\n    return Person{\n        Name:      name,\n        Age:       age,\n        DateAdded: time.Now(),\n    }\n}\n```", "```go\nfunc TestCreatePerson(t *testing.T) {\n    expected := Person{\n        Name: \"Dennis\",\n        Age:  37,\n    }\n    result := CreatePerson(\"Dennis\", 37)\n    if diff := cmp.Diff(expected, result); diff != \"\" {\n        t.Error(diff)\n    }\n}\n```", "```go\n$ go test\n--- FAIL: TestCreatePerson (0.00s)\n    ch13_cmp_test.go:16:   ch13_cmp.Person{\n              Name:      \"Dennis\",\n              Age:       37,\n        -     DateAdded: s\"0001-01-01 00:00:00 +0000 UTC\",\n        +     DateAdded: s\"2020-03-01 22:53:58.087229 -0500 EST m=+0.001242842\",\n          }\n\nFAIL\nFAIL    ch13_cmp    0.006s\n\n```", "```go\ncomparer := cmp.Comparer(func(x, y Person) bool {\n    return x.Name == y.Name && x.Age == y.Age\n})\n```", "```go\nif diff := cmp.Diff(expected, result, comparer); diff != \"\" {\n    t.Error(diff)\n}\n```", "```go\nfunc DoMath(num1, num2 int, op string) (int, error) {\n    switch op {\n    case \"+\":\n        return num1 + num2, nil\n    case \"-\":\n        return num1 - num2, nil\n    case \"*\":\n        return num1 + num2, nil\n    case \"/\":\n        if num2 == 0 {\n            return 0, errors.New(\"division by zero\")\n        }\n        return num1 / num2, nil\n    default:\n        return 0, fmt.Errorf(\"unknown operator %s\", op)\n    }\n}\n```", "```go\nfunc TestDoMath(t *testing.T) {\n    result, err := DoMath(2, 2, \"+\")\n    if result != 4 {\n        t.Error(\"Should have been 4, got\", result)\n    }\n    if err != nil {\n        t.Error(\"Should have been nil error, got\", err)\n    }\n    result2, err2 := DoMath(2, 2, \"-\")\n    if result2 != 0 {\n        t.Error(\"Should have been 0, got\", result2)\n    }\n    if err2 != nil {\n        t.Error(\"Should have been nil error, got\", err2)\n    }\n    // and so on...\n}\n```", "```go\ndata := []struct {\n    name     string\n    num1     int\n    num2     int\n    op       string\n    expected int\n    errMsg   string\n}{\n    {\"addition\", 2, 2, \"+\", 4, \"\"},\n    {\"subtraction\", 2, 2, \"-\", 0, \"\"},\n    {\"multiplication\", 2, 2, \"*\", 4, \"\"},\n    {\"division\", 2, 2, \"/\", 1, \"\"},\n    {\"bad_division\", 2, 0, \"/\", 0, `division by zero`},\n}\n```", "```go\nfor _, d := range data {\n    t.Run(d.name, func(t *testing.T) {\n        result, err := DoMath(d.num1, d.num2, d.op)\n        if result != d.expected {\n            t.Errorf(\"Expected %d, got %d\", d.expected, result)\n        }\n        var errMsg string\n        if err != nil {\n            errMsg = err.Error()\n        }\n        if errMsg != d.errMsg {\n            t.Errorf(\"Expected error message `%s`, got `%s`\",\n                d.errMsg, errMsg)\n        }\n    })\n}\n```", "```go\nfunc TestMyCode(t *testing.T) {\n    t.Parallel()\n    // rest of test goes here\n}\n```", "```go\nfunc TestParallelTable(t *testing.T) {\n    data := []struct {\n        name   string\n        input  int\n        output int\n    }{\n        {\"a\", 10, 20},\n        {\"b\", 30, 40},\n        {\"c\", 50, 60},\n    }\n    for _, d := range data {\n        t.Run(d.name, func(t *testing.T) {\n            t.Parallel()\n            fmt.Println(d.input, d.output)\n            out := toTest(d.input)\n            if out != d.output {\n                t.Error(\"didn't match\", out, d.output)\n            }\n        })\n    }\n}\n```", "```go\n=== CONT  TestParallelTable/a\n50 60\n=== CONT  TestParallelTable/c\n50 60\n=== CONT  TestParallelTable/b\n50 60\n```", "```go\n    for _, d := range data {\n        d := d // THIS IS THE LINE THAT SHADOWS d!\n        t.Run(d.name, func(t *testing.T) {\n            t.Parallel()\n            fmt.Println(d.input, d.output)\n            out := toTest(d.input)\n            if out != d.output {\n                t.Error(\"didn't match\", out, d.output)\n            }\n        })\n    }\n```", "```go\n$ go test -v -cover -coverprofile=c.out\n\n```", "```go\n$ go tool cover -html=c.out\n\n```", "```go\n{\"bad_op\", 2, 2, \"?\", 0, `unknown operator ?`},\n```", "```go\n{\"another_mult\", 2, 3, \"*\", 6, \"\"},\n```", "```go\ntable_test.go:57: Expected 6, got 5\n```", "```go\nfunc ParseData(r io.Reader) ([]string, error) {\n    s := bufio.NewScanner(r)\n    if !s.Scan() {\n        return nil, errors.New(\"empty\")\n    }\n    countStr := s.Text()\n    count, err := strconv.Atoi(countStr)\n    if err != nil {\n        return nil, err\n    }\n    out := make([]string, 0, count)\n    for i := 0; i < count; i++ {\n        hasLine := s.Scan()\n        if !hasLine {\n            return nil, errors.New(\"too few lines\")\n        }\n        line := s.Text()\n        out = append(out, line)\n    }\n    return out, nil\n}\n```", "```go\nfunc TestParseData(t *testing.T) {\n    data := []struct {\n        name   string\n        in     []byte\n        out    []string\n        errMsg string\n    }{\n        {\n            name:   \"simple\",\n            in:     []byte(\"3\\nhello\\ngoodbye\\ngreetings\\n\"),\n            out:    []string{\"hello\", \"goodbye\", \"greetings\"},\n            errMsg: \"\",\n        },\n        {\n            name:   \"empty_error\",\n            in:     []byte(\"\"),\n            out:    nil,\n            errMsg: \"empty\",\n        },\n        {\n            name:   \"zero\",\n            in:     []byte(\"0\\n\"),\n            out:    []string{},\n            errMsg: \"\",\n        },\n        {\n            name:   \"number_error\",\n            in:     []byte(\"asdf\\nhello\\ngoodbye\\ngreetings\\n\"),\n            out:    nil,\n            errMsg: `strconv.Atoi: parsing \"asdf\": invalid syntax`,\n        },\n        {\n            name:   \"line_count_error\",\n            in:     []byte(\"4\\nhello\\ngoodbye\\ngreetings\\n\"),\n            out:    nil,\n            errMsg: \"too few lines\",\n        },\n    }\n    for _, d := range data {\n        t.Run(d.name, func(t *testing.T) {\n            r := bytes.NewReader(d.in)\n            out, err := ParseData(r)\n            var errMsg string\n            if err != nil {\n                errMsg = err.Error()\n            }\n            if diff := cmp.Diff(d.out, out); diff != \"\" {\n                t.Error(diff)\n            }\n            if diff := cmp.Diff(d.errMsg, errMsg); diff != \"\" {\n                t.Error(diff)\n            }\n        })\n    }\n}\n```", "```go\nfunc FuzzParseData(f *testing.F) {\n    testcases := [][]byte{\n        []byte(\"3\\nhello\\ngoodbye\\ngreetings\\n\"),\n        []byte(\"0\\n\"),\n    }\n    for _, tc := range testcases {\n        f.Add(tc)\n    }\n    f.Fuzz(func(t *testing.T, in []byte) {\n        r := bytes.NewReader(in)\n        out, err := ParseData(r)\n        if err != nil {\n            t.Skip(\"handled error\")\n        }\n        roundTrip := ToData(out)\n        rtr := bytes.NewReader(roundTrip)\n        out2, err := ParseData(rtr)\n        if diff := cmp.Diff(out, out2); diff != \"\" {\n            t.Error(diff)\n        }\n    })\n}\n```", "```go\nf.Add(tc)\n```", "```go\nf.Add(1, \"some text\")\n```", "```go\n$ go test -fuzz=FuzzParseData\nfuzz: elapsed: 0s, gathering baseline coverage: 0/243 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 243/243 completed,\n    now fuzzing with 8 workers\nfuzz: minimizing 289-byte failing input file\nfuzz: elapsed: 3s, minimizing\nfuzz: elapsed: 6s, minimizing\nfuzz: elapsed: 9s, minimizing\nfuzz: elapsed: 10s, minimizing\n--- FAIL: FuzzParseData (10.48s)\n    fuzzing process hung or terminated unexpectedly while minimizing: EOF\n    Failing input written to testdata/fuzz/FuzzParseData/\n        fedbaf01dc50bf41b40d7449657cdc9af9868b1be0421c98b2910071de9be3df\n    To re-run:\n    go test -run=FuzzParseData/\n        fedbaf01dc50bf41b40d7449657cdc9af9868b1be0421c98b2910071de9be3df\nFAIL\nexit status 1\nFAIL    file_parser     10.594s\n\n```", "```go\ngo test fuzz v1\n[]byte(\"300000000000\")\n```", "```go\n$ go test -run=FuzzParseData/\n    fedbaf01dc50bf41b40d7449657cdc9af9868b1be0421c98b2910071de9be3df\nsignal: killed\nFAIL    file_parser     15.046s\n\n```", "```go\n    if count > 1000 {\n        return nil, errors.New(\"too many\")\n    }\n```", "```go\n$ go test -fuzz=FuzzParseData\nfuzz: elapsed: 0s, gathering baseline coverage: 0/245 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 245/245 completed,\n    now fuzzing with 8 workers\nfuzz: minimizing 29-byte failing input file\nfuzz: elapsed: 2s, minimizing\n--- FAIL: FuzzParseData (2.20s)\n    --- FAIL: FuzzParseData (0.00s)\n        testing.go:1356: panic: runtime error: makeslice: cap out of range\n            goroutine 23027 [running]:\n            runtime/debug.Stack()\n                /usr/local/go/src/runtime/debug/stack.go:24 +0x104\n            testing.tRunner.func1()\n                /usr/local/go/src/testing/testing.go:1356 +0x258\n            panic({0x1003f9920, 0x10042a260})\n                /usr/local/go/src/runtime/panic.go:884 +0x204\n            file_parser.ParseData({0x10042a7c8, 0x14006c39bc0})\n                file_parser/file_parser.go:24 +0x254\n[...]\n    Failing input written to testdata/fuzz/FuzzParseData/\n        03f81b404ad91d092a482ad1ccb4a457800599ab826ec8dae47b49c01c38f7b1\n    To re-run:\n    go test -run=FuzzParseData/\n        03f81b404ad91d092a482ad1ccb4a457800599ab826ec8dae47b49c01c38f7b1\nFAIL\nexit status 1\nFAIL    file_parser     2.434s\n\n```", "```go\ngo test fuzz v1\n[]byte(\"-1\")\n```", "```go\n    out := make([]string, 0, count)\n```", "```go\n    if count < 0 {\n        return nil, errors.New(\"no negative numbers\")\n    }\n```", "```go\n$ go test -fuzz=FuzzParseData\nfuzz: elapsed: 0s, gathering baseline coverage: 0/246 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 246/246 completed,\n    now fuzzing with 8 workers\nfuzz: elapsed: 3s, execs: 288734 (96241/sec), new interesting: 0 (total: 246)\nfuzz: elapsed: 6s, execs: 418803 (43354/sec), new interesting: 0 (total: 246)\nfuzz: minimizing 34-byte failing input file\nfuzz: elapsed: 7s, minimizing\n--- FAIL: FuzzParseData (7.43s)\n    --- FAIL: FuzzParseData (0.00s)\n        file_parser_test.go:89:   []string{\n            -   \"\\r\",\n            +   \"\",\n              }\n\n    Failing input written to testdata/fuzz/FuzzParseData/\n        b605c41104bf41a21309a13e90cfc6f30ecf133a2382759f2abc34d41b45ae79\n    To re-run:\n    go test -run=FuzzParseData/\n        b605c41104bf41a21309a13e90cfc6f30ecf133a2382759f2abc34d41b45ae79\nFAIL\nexit status 1\nFAIL    file_parser     7.558s\n\n```", "```go\n        line = strings.TrimSpace(line)\n        if len(line) == 0 {\n            return nil, errors.New(\"blank line\")\n        }\n```", "```go\n$ go test -fuzz=FuzzParseData\nfuzz: elapsed: 0s, gathering baseline coverage: 0/247 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 247/247 completed,\n    now fuzzing with 8 workers\nfuzz: elapsed: 3s, execs: 391018 (130318/sec), new interesting: 2 (total: 249)\nfuzz: elapsed: 6s, execs: 556939 (55303/sec), new interesting: 2 (total: 249)\nfuzz: elapsed: 9s, execs: 622126 (21734/sec), new interesting: 2 (total: 249)\n[...]\nfuzz: elapsed: 2m0s, execs: 2829569 (0/sec), new interesting: 16 (total: 263)\nfuzz: elapsed: 2m3s, execs: 2829569 (0/sec), new interesting: 16 (total: 263)\n^Cfuzz: elapsed: 2m4s, execs: 2829569 (0/sec), new interesting: 16 (total: 263)\nPASS\nok      file_parser     123.662s\n\n```", "```go\nfunc FileLen(f string, bufsize int) (int, error) {\n    file, err := os.Open(f)\n    if err != nil {\n        return 0, err\n    }\n    defer file.Close()\n    count := 0\n    for {\n        buf := make([]byte, bufsize)\n        num, err := file.Read(buf)\n        count += num\n        if err != nil {\n            break\n        }\n    }\n    return count, nil\n}\n```", "```go\nfunc TestFileLen(t *testing.T) {\n    result, err := FileLen(\"testdata/data.txt\", 1)\n    if err != nil {\n        t.Fatal(err)\n    }\n    if result != 65204 {\n        t.Error(\"Expected 65204, got\", result)\n    }\n}\n```", "```go\nvar blackhole int\n\nfunc BenchmarkFileLen1(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        result, err := FileLen(\"testdata/data.txt\", 1)\n        if err != nil {\n            b.Fatal(err)\n        }\n        blackhole = result\n    }\n}\n```", "```go\nBenchmarkFileLen1-12  25  47201025 ns/op  65342 B/op  65208 allocs/op\n```", "```go\nfunc BenchmarkFileLen(b *testing.B) {\n    for _, v := range []int{1, 10, 100, 1000, 10000, 100000} {\n        b.Run(fmt.Sprintf(\"FileLen-%d\", v), func(b *testing.B) {\n            for i := 0; i < b.N; i++ {\n                result, err := FileLen(\"testdata/data.txt\", v)\n                if err != nil {\n                    b.Fatal(err)\n                }\n                blackhole = result\n            }\n        })\n    }\n}\n```", "```go\nBenchmarkFileLen/FileLen-1-12          25  47828842 ns/op   65342 B/op  65208 allocs/op\nBenchmarkFileLen/FileLen-10-12        230   5136839 ns/op  104488 B/op   6525 allocs/op\nBenchmarkFileLen/FileLen-100-12      2246    509619 ns/op   73384 B/op    657 allocs/op\nBenchmarkFileLen/FileLen-1000-12    16491     71281 ns/op   68744 B/op     70 allocs/op\nBenchmarkFileLen/FileLen-10000-12   42468     26600 ns/op   82056 B/op     11 allocs/op\nBenchmarkFileLen/FileLen-100000-12  36700     30473 ns/op  213128 B/op      5 allocs/op\n\n```", "```go\nBenchmarkFileLen/FileLen-1-12          25  46167597 ns/op     137 B/op  4 allocs/op\nBenchmarkFileLen/FileLen-10-12        261   4592019 ns/op     152 B/op  4 allocs/op\nBenchmarkFileLen/FileLen-100-12      2518    478838 ns/op     248 B/op  4 allocs/op\nBenchmarkFileLen/FileLen-1000-12    20059     60150 ns/op    1160 B/op  4 allocs/op\nBenchmarkFileLen/FileLen-10000-12   62992     19000 ns/op   10376 B/op  4 allocs/op\nBenchmarkFileLen/FileLen-100000-12  51928     21275 ns/op  106632 B/op  4 allocs/op\n\n```", "```go\ntype Processor struct {\n    Solver MathSolver\n}\n```", "```go\ntype MathSolver interface {\n    Resolve(ctx context.Context, expression string) (float64, error)\n}\n```", "```go\nfunc (p Processor) ProcessExpression(ctx context.Context, r io.Reader)\n                                    (float64, error) {\n    curExpression, err := readToNewLine(r)\n    if err != nil {\n        return 0, err\n    }\n    if len(curExpression) == 0 {\n        return 0, errors.New(\"no expression to read\")\n    }\n    answer, err := p.Solver.Resolve(ctx, curExpression)\n    return answer, err\n}\n```", "```go\ntype MathSolverStub struct{}\n\nfunc (ms MathSolverStub) Resolve(ctx context.Context, expr string)\n                                (float64, error) {\n    switch expr {\n    case \"2 + 2 * 10\":\n        return 22, nil\n    case \"( 2 + 2 ) * 10\":\n        return 40, nil\n    case \"( 2 + 2 * 10\":\n        return 0, errors.New(\"invalid expression: ( 2 + 2 * 10\")\n    }\n    return 0, nil\n}\n```", "```go\nfunc TestProcessorProcessExpression(t *testing.T) {\n    p := Processor{MathSolverStub{}}\n    in := strings.NewReader(`2 + 2 * 10\n( 2 + 2 ) * 10\n( 2 + 2 * 10`)\n    data := []float64{22, 40, 0}\n    hasErr := []bool{false, false, true}\n    for i, d := range data {\n        result, err := p.ProcessExpression(context.Background(), in)\n        if err != nil && !hasErr[i] {\n            t.Error(err)\n        }\n        if result != d {\n            t.Errorf(\"Expected result %f, got %f\", d, result)\n        }\n    }\n}\n```", "```go\ntype Entities interface {\n    GetUser(id string) (User, error)\n    GetPets(userID string) ([]Pet, error)\n    GetChildren(userID string) ([]Person, error)\n    GetFriends(userID string) ([]Person, error)\n    SaveUser(user User) error\n}\n```", "```go\ntype Logic struct {\n    Entities Entities\n}\n```", "```go\nfunc (l Logic) GetPetNames(userId string) ([]string, error) {\n    pets, err := l.Entities.GetPets(userId)\n    if err != nil {\n        return nil, err\n    }\n    out := make([]string, len(pets))\n    for _, p := range pets {\n        out = append(out, p.Name)\n    }\n    return out, nil\n}\n```", "```go\ntype GetPetNamesStub struct {\n    Entities\n}\n\nfunc (ps GetPetNamesStub) GetPets(userID string) ([]Pet, error) {\n    switch userID {\n    case \"1\":\n        return []Pet{{Name: \"Bubbles\"}}, nil\n    case \"2\":\n        return []Pet{{Name: \"Stampy\"}, {Name: \"Snowball II\"}}, nil\n    default:\n        return nil, fmt.Errorf(\"invalid id: %s\", userID)\n    }\n}\n```", "```go\nfunc TestLogicGetPetNames(t *testing.T) {\n    data := []struct {\n        name     string\n        userID   string\n        petNames []string\n    }{\n        {\"case1\", \"1\", []string{\"Bubbles\"}},\n        {\"case2\", \"2\", []string{\"Stampy\", \"Snowball II\"}},\n        {\"case3\", \"3\", nil},\n    }\n    l := Logic{GetPetNamesStub{}}\n    for _, d := range data {\n        t.Run(d.name, func(t *testing.T) {\n            petNames, err := l.GetPetNames(d.userID)\n            if err != nil {\n                t.Error(err)\n            }\n            if diff := cmp.Diff(d.petNames, petNames); diff != \"\" {\n                t.Error(diff)\n            }\n        })\n    }\n}\n```", "```go\ntype EntitiesStub struct {\n    getUser     func(id string) (User, error)\n    getPets     func(userID string) ([]Pet, error)\n    getChildren func(userID string) ([]Person, error)\n    getFriends  func(userID string) ([]Person, error)\n    saveUser    func(user User) error\n}\n```", "```go\nfunc (es EntitiesStub) GetUser(id string) (User, error) {\n    return es.getUser(id)\n}\n\nfunc (es EntitiesStub) GetPets(userID string) ([]Pet, error) {\n    return es.getPets(userID)\n}\n```", "```go\nfunc TestLogicGetPetNames(t *testing.T) {\n    data := []struct {\n        name     string\n        getPets  func(userID string) ([]Pet, error)\n        userID   string\n        petNames []string\n        errMsg   string\n    }{\n        {\"case1\", func(userID string) ([]Pet, error) {\n            return []Pet{{Name: \"Bubbles\"}}, nil\n        }, \"1\", []string{\"Bubbles\"}, \"\"},\n        {\"case2\", func(userID string) ([]Pet, error) {\n            return nil, errors.New(\"invalid id: 3\")\n        }, \"3\", nil, \"invalid id: 3\"},\n    }\n    l := Logic{}\n    for _, d := range data {\n        t.Run(d.name, func(t *testing.T) {\n            l.Entities = EntitiesStub{getPets: d.getPets}\n            petNames, err := l.GetPetNames(d.userID)\n            if diff := cmp.Diff(d.petNames, petNames); diff != \"\" {\n                t.Error(diff)\n            }\n            var errMsg string\n            if err != nil {\n                errMsg = err.Error()\n            }\n            if errMsg != d.errMsg {\n                t.Errorf(\"Expected error `%s`, got `%s`\", d.errMsg, errMsg)\n            }\n        })\n    }\n}\n```", "```go\ntype RemoteSolver struct {\n    MathServerURL string\n    Client        *http.Client\n}\n\nfunc (rs RemoteSolver) Resolve(ctx context.Context, expression string)\n                              (float64, error) {\n    req, err := http.NewRequestWithContext(ctx, http.MethodGet,\n        rs.MathServerURL+\"?expression=\"+url.QueryEscape(expression),\n        nil)\n    if err != nil {\n        return 0, err\n    }\n    resp, err := rs.Client.Do(req)\n    if err != nil {\n        return 0, err\n    }\n    defer resp.Body.Close()\n    contents, err := io.ReadAll(resp.Body)\n    if err != nil {\n        return 0, err\n    }\n    if resp.StatusCode != http.StatusOK {\n        return 0, errors.New(string(contents))\n    }\n    result, err := strconv.ParseFloat(string(contents), 64)\n    if err != nil {\n        return 0, err\n    }\n    return result, nil\n}\n```", "```go\ntype info struct {\n    expression string\n    code       int\n    body       string\n}\nvar io info\n```", "```go\nserver := httptest.NewServer(\n    http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n        expression := req.URL.Query().Get(\"expression\")\n        if expression != io.expression {\n            rw.WriteHeader(http.StatusBadRequest)\n            fmt.Fprintf(rw, \"expected expression '%s', got '%s'\",\n                io.expression, expression)\n            return\n        }\n        rw.WriteHeader(io.code)\n        rw.Write([]byte(io.body))\n    }))\ndefer server.Close()\nrs := RemoteSolver{\n    MathServerURL: server.URL,\n    Client:        server.Client(),\n}\n```", "```go\ndata := []struct {\n    name   string\n    io     info\n    result float64\n}{\n    {\"case1\", info{\"2 + 2 * 10\", http.StatusOK, \"22\"}, 22},\n    // remaining cases\n}\nfor _, d := range data {\n    t.Run(d.name, func(t *testing.T) {\n        io = d.io\n        result, err := rs.Resolve(context.Background(), d.io.expression)\n        if result != d.result {\n            t.Errorf(\"io `%f`, got `%f`\", d.result, result)\n        }\n        var errMsg string\n        if err != nil {\n            errMsg = err.Error()\n        }\n        if errMsg != d.errMsg {\n            t.Errorf(\"io error `%s`, got `%s`\", d.errMsg, errMsg)\n        }\n    })\n}\n```", "```go\n//go:build integration\n```", "```go\n$ go test -tags integration -v ./...\n\n```", "```go\nfunc getCounter() int {\n    var counter int\n    var wg sync.WaitGroup\n    wg.Add(5)\n    for i := 0; i < 5; i++ {\n        go func() {\n            for i := 0; i < 1000; i++ {\n                counter++\n            }\n            wg.Done()\n        }()\n    }\n    wg.Wait()\n    return counter\n}\n```", "```go\nfunc TestGetCounter(t *testing.T) {\n    counter := getCounter()\n    if counter != 5000 {\n        t.Error(\"unexpected counter:\", counter)\n    }\n}\n```", "```go\nunexpected counter: 3673\n```", "```go\n$ go test -race\n==================\nWARNING: DATA RACE\nRead at 0x00c000128070 by goroutine 10:\n  test_examples/race.getCounter.func1()\n      test_examples/race/race.go:12 +0x45\n\nPrevious write at 0x00c000128070 by goroutine 8:\n  test_examples/race.getCounter.func1()\n      test_examples/race/race.go:12 +0x5b\n\n```"]