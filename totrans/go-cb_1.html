<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 2. String Recipes" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_strings">
<h1><span class="label">Chapter 2. </span>String Recipes</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45195522258240">
<h5>A Note for Early Release Readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 6th chapter of the final book.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:sevans@oreilly.com">sevans@oreilly.com</a>.</p>
</div></aside>
<section data-pdf-bookmark="2.0 Introduction" data-type="sect1"><div class="sect1" id="idm45195522255168">
<h1>2.0 Introduction</h1>
<p>String manipulation is one of the most common activities in any programming language. Most programs deal with text in one way or another, whether directly interacting with users or even communicating with between machines. Text is probably the closest thing we have to a universal medium, and string as data is everywhere. Being able to manipulate string is a critical capability in your arsenal as a programmer.</p>
<p>Go has several packages used for string manipulation. The <code>strconv</code> package focuses on converting to or from strings. The <code>fmt</code> package provides functions to format strings using verbs as replacements, much like in C. The <code>unicode/utf8</code> and <code>unicode/utf16</code> packages have functions used in Unicode encoded strings. The <code>strings</code> package has functions to do many of the string manipulations we see so if you’re not sure what you need, that’s the most likely location to look.</p>
</div></section>
<section data-pdf-bookmark="2.1 Creating strings" data-type="sect1"><div class="sect1" id="idm45195522250816">
<h1>2.1 Creating strings</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195522211984">
<h2>Problem</h2>
<p>You want to create strings.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195522210592">
<h2>Solution</h2>
<p>Use either the double quotes <code>""</code> or the backtick (or backquote) <code>“</code> to create string literals. Use the single quotes <code>”</code> to create character literals.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195522207824">
<h2>Discussion</h2>
<p>In Go, <code>string</code> is a read-only (immutable) slice of bytes. It can be any byte, doesn’t need to be in any encoding or format. This is unlike some other programming languages, where strings are sequences of characters. In Go, a character can be represented by more than a single byte. This is in line with the Unicode standard, which defines a code-point to represent a value within a codespace. A character in this case can be represented by more than a single code-point. In Go, code-points are also called <em>runes</em> and a rune is an alias for the type <code>int32</code> just as a byte is an alias for the type <code>uint8</code> which represents an unsigned 8-bit integer.</p>
<p>As a result if you index a string, you will end up with a byte and not a character. In any case Go doesn’t have a character data type — bytes and runes are used instead. A byte represents ASCII characters and rune represents Unicode characters in UTF-8 encoding. To be clear, it doesn’t mean that there are no characters in Go, just that there is no <code>char</code> data type, just <code>byte</code> and <code>rune</code>.</p>
<p>Characters in Go are created using the single quotes <code>''</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">c</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="sc">'A'</code><code class="w"/></pre>
<p>In this case, the data type of the variable <code>c</code> is <code>int32</code> or a rune, by default. If oyu want it to be a byte, you can explicitly specify the type.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">c</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="sc">'A'</code><code class="w"/></pre>
<p>Strings in Go can be created using either the double quotes <code>""</code> or the backtick <code>``</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"A simple string"</code><code class="w"/></pre>
<p>Strings created using the double quotes can have escape characters in them. For example, a very common escape character is the newline, represented by a backslash followed by an <em>n</em> — <code>\n</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"A simple string\n"</code><code class="w"/></pre>
<p>Another common use of escape characters is to escape a double quote itself so it can be used within a string that’s created with a double quote.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`A \"simple\" string`</code><code class="w"/></pre>
<p>String created using backticks are considered “raw” strings. Raw strings ignore all formatting including escape characters. In fact you can create multi-line string using backticks. For example, this is not possible using double quotes, in fact it’ll be a syntax error.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"</code>
<code class="s">A</code>
<code class="s">simple</code>
<code class="s">string</code>
<code class="s">"</code><code class="w"/></pre>
<p>However if we replace the double quotes with backticks <code>str</code> will be a multi-line string.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`</code>
<code class="s">A</code>
<code class="s">simple</code>
<code class="s">string</code>
<code class="s">`</code><code class="w"/></pre>
<p>This is because whatever comes in between the backticks are not processed by the Go compiler at all (i.e. it is “raw”).</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.2 Converting strings to bytes and bytes to string" data-type="sect1"><div class="sect1" id="idm45195522010640">
<h1>2.2 Converting strings to bytes and bytes to string</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195522009760">
<h2>Problem</h2>
<p>You want to convert string to bytes and bytes to string.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195522008208">
<h2>Solution</h2>
<p>Typecast a string to an array of bytes using <code>[]byte(str)</code> and typecast an array of bytes to a string using <code>string(bytes)</code>.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195522005792">
<h2>Discussion</h2>
<p>Strings are slices of bytes so you can convert a string to an array of bytes directly through typecasting.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"This is a simple string"</code><code class="w"/>
<code class="nx">bytes</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code><code class="w"/></pre>
<p>Converting an array of bytes to a string is also done through typecasting.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">bytes</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">{</code><code class="mi">84</code><code class="p">,</code><code class="w"> </code><code class="mi">104</code><code class="p">,</code><code class="w"> </code><code class="mi">105</code><code class="p">,</code><code class="w"> </code><code class="mi">115</code><code class="p">,</code><code class="w"> </code><code class="mi">32</code><code class="p">,</code><code class="w"> </code><code class="mi">105</code><code class="p">,</code><code class="w"> </code><code class="mi">115</code><code class="p">,</code><code class="w"> </code><code class="mi">32</code><code class="p">,</code><code class="w"> </code><code class="mi">97</code><code class="p">,</code><code class="w"> </code><code class="mi">32</code><code class="p">,</code><code class="w"> </code><code class="mi">115</code><code class="p">,</code><code class="w"> </code><code class="mi">105</code><code class="p">,</code><code class="w"> </code><code class="mi">109</code><code class="p">,</code><code class="w"> </code><code class="mi">112</code><code class="p">,</code><code class="w"> </code><code class="mi">108</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="mi">101</code><code class="p">,</code><code class="w"> </code><code class="mi">32</code><code class="p">,</code><code class="w"> </code><code class="mi">115</code><code class="p">,</code><code class="w"> </code><code class="mi">116</code><code class="p">,</code><code class="w"> </code><code class="mi">114</code><code class="p">,</code><code class="w"> </code><code class="mi">105</code><code class="p">,</code><code class="w"> </code><code class="mi">110</code><code class="p">,</code><code class="w"> </code><code class="mi">103</code><code class="p">}</code><code class="w"/>
<code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">bytes</code><code class="p">)</code><code class="w"/></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.3 Creating strings from other strings and data" data-type="sect1"><div class="sect1" id="idm45195521953296">
<h1>2.3 Creating strings from other strings and data</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195521952416">
<h2>Problem</h2>
<p>You want to create a string from other strings or data.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195521838768">
<h2>Solution</h2>
<p>There are a variety of ways of doing this, including direct concatenation, using <code>strings.Join</code>, using <code>fmt.Sprint</code> and using <code>strings.Builder</code>.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195521835872">
<h2>Discussion</h2>
<p>At times you want to create strings from other strings or data. One and rather straightforward way of doing this is to concatenate strings and other data together.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"The time is "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" now."</code><code class="w"/></pre>
<p>The <code>Now</code> function returns the current time, which is formatted by the <code>Format</code> method returned as a string. When we concatenate the strings, we will get this.</p>
<pre data-type="programlisting">The time is 5:28PM now.</pre>
<p>Another way of doing this is use the <code>Join</code> function in the <code>string</code> package.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Join</code><code class="p">([]</code><code class="kt">string</code><code class="p">{</code><code class="s">"The time is"</code><code class="p">,</code><code class="w"/>
<code class="w">                    </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">),</code><code class="w"/>
<code class="w">                    </code><code class="s">"now."</code><code class="p">},</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/></pre>
<p>This is quite straightforward as well, because the function takes in an array of strings and given the separator, put them together.</p>
<p>So far both ways shown are about putting strings together. Obviously you can convert different data types into string before joining them up, but sometimes you just want Go to do it. For this we have the <code>fmt.Sprint</code> function and its various variants. Let’s look at the simplest and most straightforward variant.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprint</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">),</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/></pre>
<p>This doesn’t seem very different from the <code>Join</code> or the direct concatenation because all 3 parameters are strings. Actually <code>fmt.Sprint</code> and its variants take <code>interface{}</code> parameters, which means it can take in any data type. In other words, you can actually pass in the <code>Time</code> struct that’s returned by <code>Now</code> directly.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprint</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">(),</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/></pre>
<p>A popular variant of <code>fmt.Sprint</code> is the formatted variant i.e. <code>fmt.Sprintf</code>. Using this variant is slightly different — the first parameter is the format string, where you can place different verb formats at different locations within the string. The second parameter onwards are the data values that can be replaced into the verbs.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"The time is %v now."</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">())</code><code class="w"/></pre>
<p>There is no associated verb for a <code>Time</code> struct, so we use the <code>%v</code> which will format the value in the default format.</p>
<p>Finally, the <code>string</code> package also provides another way of creating strings, using the <code>strings.Builder</code>  struct. Using <code>Builder</code> to create strings is a bit more involved, as it requires you to add the data piece by piece. Let’s take a look at using <code>Builder</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">builder</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Builder</code><code class="w"/>
<code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">)</code><code class="w"/>
<code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">))</code><code class="w"/>
<code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">builder</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/></pre>
<p>The idea is simple, we create a <code>Builder</code> struct, then write data to it bit by bit before finally extracting the final string using the <code>String</code> method. The <code>Builder</code> struct has a few more other methods including <code>Write</code> which takes in an array of bytes, <code>WriteByte</code> which takes in a single byte and <code>WriteRune</code> which takes in a single rune. However as you can see, they are all strings or characters. How about other data types? Do we need to convert all other data types to string or byte or rune first? No, because <code>Builder</code> is a <code>Writer</code> (it implements a <code>Write</code> method), you can actually use another way of writing different data types into it.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">builder</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Builder</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="s">"The time is "</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">())</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">builder</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/></pre>
<p>Here we’re using <code>fmt.Fprint</code> to write whatever data type we want into the builder, and extract the final string using <code>String</code>.</p>
<p>We’ve seen quite a few ways of putting a string together using different pieces of data, both string and other types of data. Some are very straightforward (just add them together) whereas others are bit more deliberate. Here’s a look at the performance of these various ways.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="kt">string</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">	</code><code class="s">"fmt"</code><code class="w"/>
<code class="w">	</code><code class="s">"strings"</code><code class="w"/>
<code class="w">	</code><code class="s">"testing"</code><code class="w"/>
<code class="w">	</code><code class="s">"time"</code><code class="w"/>
<code class="p">)</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringConcat</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"The time is "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">" now."</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringJoin</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Join</code><code class="p">([]</code><code class="kt">string</code><code class="p">{</code><code class="s">"The time is"</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="s">"now."</code><code class="p">},</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringSprint</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprint</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">),</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringSprintDiff</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprint</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">(),</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringSprintf</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"The time is %v now."</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">))</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringSprintfDiff</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"The time is %s now."</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">())</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringBuilderFprint</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="kd">var</code><code class="w"> </code><code class="nx">builder</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Builder</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="s">"The time is "</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">))</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprint</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">builder</code><code class="p">,</code><code class="w"> </code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">builder</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkStringBuilderWriteString</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="kd">var</code><code class="w"> </code><code class="nx">builder</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Builder</code><code class="w"/>
<code class="w">		</code><code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="s">"The time is "</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">().</code><code class="nx">Format</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Kitchen</code><code class="p">))</code><code class="w"/>
<code class="w">		</code><code class="nx">builder</code><code class="p">.</code><code class="nx">WriteString</code><code class="p">(</code><code class="s">" now."</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">builder</code><code class="p">.</code><code class="nx">String</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Let’s run the benchmark from the command line.</p>
<pre data-type="programlisting">$ % go test -bench=BenchmarkString -benchmem</pre>
<p>This is the results.</p>
<pre data-type="programlisting">goos: darwin
goarch: arm64
pkg: github.com/sausheong/gocookbook/ch06_string
BenchmarkStringConcat-10                	 5787976	       206.7 ns/op
BenchmarkStringJoin-10                  	 5121637	       235.0 ns/op
BenchmarkStringSprint-10                	 3680838	       323.8 ns/op
BenchmarkStringSprintDiff-10            	 1541514	       779.9 ns/op
BenchmarkStringSprintf-10               	 4032438	       297.8 ns/op
BenchmarkStringSprintfDiff-10           	 1610212	       740.9 ns/op
BenchmarkStringBuilderFprint-10         	 2580783	       464.2 ns/op
BenchmarkStringBuilderWriteString-10    	 4866556	       247.0 ns/op
PASS
ok  	github.com/sausheong/gocookbook/ch06_string	13.025s</pre>
<p>It might come to you as a surprise that the simplest way is really the most performant as well. Using <code>fmt.Sprint</code> and  anything that uses <code>interface{}</code> is simply less efficient.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.4 Converting strings to numbers" data-type="sect1"><div class="sect1" id="idm45195521834768">
<h1>2.4 Converting strings to numbers</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195521131216">
<h2>Problem</h2>
<p>You want to convert string to numbers.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195521129584">
<h2>Solution</h2>
<p>Use the <code>Atoi</code> or the <code>Parse</code> functions in the <code>strconv</code> package to do string conversions. Use functions to convert strings to numbers, and use <code>Itoa</code> or the <code>Format</code> functions to convert numbers to strings.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195521125584">
<h2>Discussion</h2>
<p>The <code>strconv</code> package is true to its name and is a package used mostly for conversion of strings. There are two sets of functions that lets us convert strings to numbers and numbers to string. The <code>Parse</code> functions convert strings to numbers and the <code>Format</code> functions convert numbers to strings. If you’re not sure which ones to use, generally remember that parsing reads strings while formatting creates strings.</p>
<p>Parsing strings into numbers seem to be limited in usage but it can be particularly useful when dealing with text formatted data, for example, JSON or Yaml or even XML. Text formatted data is popular because it is human readable but the drawback is that everything ends up being a string. Parsing the string into something more usable directly, in this case, numbers becomes really useful.</p>
<p>Let’s start with something simple. We want to parse a string that shows an integer and produces an actual integer.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">Atoi</code><code class="p">(</code><code class="s">"123"</code><code class="p">)</code><code class="w"> </code><code class="c1">// equivalent to ParseInt("123", 10, 0)</code><code class="w"/></pre>
<p>The <code>strconv</code> package provides a convenience function to convert a string to an integer. This is quite easy to remember because <code>Atoi</code> basically is converting <em>alphanumeric</em> to <em>integer</em>.</p>
<p>The equivalent of <code>Atoi</code> using the <code>Parse</code> functions is <code>ParseInt(s, 10, 0)</code> where <code>s</code> is the string representing the number.</p>
<p>The <code>ParseInt</code> function as the name suggests, parses a string into an integer. You can specify the base (0, 2 to 36) as well as the bit size (0 to 64). You can use <code>ParseInt</code> for signed or unsigned integers, just place a + or - in front of the number.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseInt</code><code class="p">(</code><code class="s">"123"</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"/></pre>
<p>The <code>ParseFloat</code> function parses a string into a float. The bitsize parameter specifies the precision, 32 for <code>float32</code>, 64 for <code>float64</code> etc.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseFloat</code><code class="p">(</code><code class="s">"1.234"</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/></pre>
<p>In the code above, <code>f</code> is a <code>float64</code> number.</p>
<p><code>ParseBool</code> can be useful when you’re trying to parse a string that represents a boolean value. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseBool</code><code class="p">(</code><code class="s">"TRUE"</code><code class="p">)</code><code class="w"/></pre>
<p>In the code above, <code>b</code> is a boolean with the value <code>true</code>.</p>
<p>All the <code>Parse</code> functions return <code>NumError</code>, including <code>Atoi</code>. <code>NumError</code> provides additional information about the error including the function that was called, the number that was passed in and the reason why it failed.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"Not a number"</code><code class="w"/>
<code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">Atoi</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">e</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">err</code><code class="p">.(</code><code class="o">*</code><code class="nx">strconv</code><code class="p">.</code><code class="nx">NumError</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Func:"</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">Func</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Num:"</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">Num</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Err:"</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">Err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This is what you can see if you run this code.</p>
<pre data-type="programlisting">Func: Atoi
Num: Not a number
Err: invalid syntax
strconv.Atoi: parsing "Not a number": invalid syntax</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.5 Converting  numbers to strings" data-type="sect1"><div class="sect1" id="idm45195520667856">
<h1>2.5 Converting  numbers to strings</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195520393264">
<h2>Problem</h2>
<p>You want to convert numbers to strings.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195520391680">
<h2>Solution</h2>
<p>Use the <code>Itoa</code> or the <code>Format</code> functions in the <code>strconv</code> package to convert numbers to strings.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195520388752">
<h2>Discussion</h2>
<p>We discussed about the <code>strconv</code> package and the <code>Parse</code> functions in the previous recipe. In this recipe we’ll talk about the <code>Format</code> functions and how we can use them to convert numbers to strings.</p>
<p>Formatting numbers into strings is the reverse of parsing strings into numbers. In cases where data needs to be communicated through text formats, formatting numbers can be useful. One frequent usage of formatting numbers into strings is when we need to show more readable numbers to users. For example, instead of showing 1.66666666 to the user, we would want to show 1.67. This is also commonly used when displaying currency.</p>
<p>Let’s start with the simplest example. Just as parsing strings has <code>Atoi</code>, formatting strings has <code>Itoa</code>. As the name suggests, it’s the reverse of <code>Atoi</code> — it converts an integer into a string.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">Itoa</code><code class="p">(</code><code class="mi">123</code><code class="p">)</code><code class="w"> </code><code class="c1">// equivalent to FormatInt(int64(123), 10)</code><code class="w"/></pre>
<p>Notice that <code>Itoa</code> doesn’t return an error. In fact, none of the <code>Format</code> functions return errors. It makes sense — it is always possible to make a number a string, while it’s not the case in the reverse.</p>
<p>As before, <code>Itoa</code> is a convenient function for <code>FormatInt</code>. However we must first ensure the input number parameter is always an <code>int64</code>. <code>FormatInt</code> also requires a base parameter where base is an integer between 2 and 36, both numbers included. This means it can potentially convert binary numbers to string.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatInt</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="mi">123</code><code class="p">),</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/></pre>
<p>The code above returns a string <code>"123"</code>. What if we specify a base of 2?</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatInt</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="mi">123</code><code class="p">),</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/></pre>
<p>This will return a string <code>"1111011"</code>. What this means is that you can use <code>FormatInt</code> to convert a number in one base to another, at least to display as a string.</p>
<p>The <code>FormatFloat</code> function is a bit more complicated that <code>FormatInt</code>. It converts a floating point number to a string according to a format and precision. The formats available in <code>FormatFloat</code> for decimal numbers (base 10) are:</p>
<ul>
<li>
<p><code>f</code> - no exponent</p>
</li>
<li>
<p><code>e</code> and <code>E</code> - with exponent</p>
</li>
<li>
<p><code>g</code> and <code>G</code> - <code>e</code> or <code>E</code> respectively if the exponent is large, else it will be without exponent (like <code>f</code>)</p>
</li>
</ul>
<p>The other formats are <code>b</code> for binary numbers (base 2) and <code>x</code> and <code>X</code> for hexadecimal numbers.</p>
<p>The precision describes the number of digits (excluding the exponents) to be printed out. A precision of value -1 lets Go select the smallest number of digits such that ParseFloat returns the entire number.</p>
<p>Let’s look at some code, it will make things clearer.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mf">123456.123456</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="kt">string</code><code class="w"/>

<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'f'</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"f (prec=-1)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'f'</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"f (prec=4)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'f'</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"f (prec=9)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>

<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'e'</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"\ne (prec=-1)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'E'</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"E (prec=-1)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'e'</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"e (prec=4)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'e'</code><code class="p">,</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"e (prec=9)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>

<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'g'</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"\ng (prec=-1)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'G'</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"G (prec=-1)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="nx">s</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">FormatFloat</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code class="w"> </code><code class="sc">'g'</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"g (prec=4)\t:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/></pre>
<p>We’re using a float value with 64-bit precision, <code>float64</code>, and we will compare the precision of -1 with the precision of 4. In case you didn’t realise, both lower case <em>e</em> and upper case <em>E</em> are exactly the same, except the exponent letter <em>e</em> is in lower or upper case.</p>
<p>When you run the code, this is what you should see.</p>
<pre data-type="programlisting">f (prec=-1)	: 123456.123456
f (prec=4)	: 123456.1235
f (prec=9)	: 123456.123456000

e (prec=-1)	: 1.23456123456e+05
E (prec=-1)	: 1.23456123456E+05
e (prec=4)	: 1.2346e+05
e (prec=9)	: 1.234561235e+05

g (prec=-1)	: 123456.123456
G (prec=-1)	: 123456.123456
g (prec=4)	: 1.235e+05</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.6 Replacing multiple characters in a string" data-type="sect1"><div class="sect1" id="idm45195520387680">
<h1>2.6 Replacing multiple characters in a string</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195520074160">
<h2>Problem</h2>
<p>You want to replace parts in a string with another string.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195519917696">
<h2>Solution</h2>
<p>There are several ways of doing it. You can use the <code>strings.Replace</code> function or <code>strings.ReplaceAll</code> function to replace the selected string. You can also use the <code>strings.Replacer</code> type to create replacers.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195519914832">
<h2>Discussion</h2>
<p>There are several ways we can use to replace parts of a string with another string. The easiest is to use the <code>strings.Replace</code> function.</p>
<p>The <code>strings.Replace</code> function is quite straightforward. Just pass it a string, the old string you want to replace, and the new string you want to replace it with. Let’s take a look at the code, using this quote from <em>Great Expectations</em> by Charles Dickens.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">quote</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`I loved her against reason, against promise,</code>
<code class="s">against peace, against hope, against happiness,</code>
<code class="s">against all discouragement that could be.`</code><code class="w"/></pre>
<p>We run a few replacements using <code>Replace</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">replaced</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">replaced</code><code class="p">)</code><code class="w"/>
<code class="nx">replaced2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">replaced2</code><code class="p">)</code><code class="w"/>
<code class="nx">replacedAll</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">replacedAll</code><code class="p">)</code><code class="w"/></pre>
<p>The last parameter tells <code>Replace</code> the number of matches to replace. If the last parameter is -1, <code>Replace</code> will match every instance.</p>
<pre data-type="programlisting">I loved her with reason, against promise,
against peace, against hope, against happiness,
against all discouragement that could be.

 I loved her with reason, with promise,
against peace, against hope, against happiness,
against all discouragement that could be.

 I loved her with reason, with promise,
with peace, with hope, with happiness,
with all discouragement that could be.</pre>
<p>There is also a <code>ReplaceAll</code> function which is more of a convenience function that calls <code>Replace</code> with the last parameter set to -1.</p>
<p>The <code>Replacer</code> type in the <code>strings</code> package that allows you to make multiple replacements all at the same time. This is a lot more convenient if you need to do a lot of replacements.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">replacer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReplacer</code><code class="p">(</code><code class="s">"her"</code><code class="p">,</code><code class="w"> </code><code class="s">"him"</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"for"</code><code class="p">,</code><code class="w"> </code><code class="s">"all"</code><code class="p">,</code><code class="w"> </code><code class="s">"some"</code><code class="p">)</code><code class="w"/>
<code class="nx">replaced</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">replacer</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">replaced</code><code class="p">)</code><code class="w"/></pre>
<p>You just need to provide a list of replacement strings as the parameters. In the code above, we replaced “her” with “him”, “against” with “for” and “all” with “some”. It will do all the replacements at the same time. If you run the code above you will get the results below.</p>
<pre data-type="programlisting">I loved him for reason, for promise,
for peace, for hope, for happiness,
for some discouragement that could be.</pre>
<p>So is it better to use <code>Replace</code> or create a <code>Replacer</code>? It takes a another line of code to create the replacer, obviously. But how about its performance? Let’s take a look. We’ll start with just replacing 1 word.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkOneReplace</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"her"</code><code class="p">,</code><code class="w"> </code><code class="s">"him"</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkOneReplacer</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">replacer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReplacer</code><code class="p">(</code><code class="s">"her"</code><code class="p">,</code><code class="w"> </code><code class="s">"him"</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">b</code><code class="p">.</code><code class="nx">ResetTimer</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">replacer</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If it’s just one string to replace, <code>Replace</code> is faster. There is just more overhead for a simple replacement.</p>
<pre data-type="programlisting">goos: darwin
goarch: arm64
pkg: github.com/sausheong/gocookbook/ch06_string
BenchmarkOneReplace-10     	 7264310	       156.9 ns/op
BenchmarkOneReplacer-10    	 4336489	       276.0 ns/op
PASS
ok  	github.com/sausheong/gocookbook/ch06_string	3.151s</pre>
<p>Let’s look at if we need to do multiple replacements.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkReplace</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkReplacerCreate</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReplacer</code><code class="p">(</code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkReplacer</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">replacer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">NewReplacer</code><code class="p">(</code><code class="s">"against"</code><code class="p">,</code><code class="w"> </code><code class="s">"with"</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">b</code><code class="p">.</code><code class="nx">ResetTimer</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">replacer</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>We don’t need to create a <code>Replacer</code> each time so we can reuse the replacer multiple times if you want to do the same replacements for different strings. At the same time, if you have a lot of replacements, it’s definitely easier to use a replacer.</p>
<pre data-type="programlisting">goos: darwin
goarch: arm64
pkg: github.com/sausheong/gocookbook/ch06_string
BenchmarkReplace-10           	 2250291	       532.1 ns/op
BenchmarkReplacerCreate-10    	31878366	        37.13 ns/op
BenchmarkReplacer-10          	 4671319	       255.0 ns/op
PASS
ok  	github.com/sausheong/gocookbook/ch06_string	4.547s</pre>
<p>As you can see, with more strings to replace, using <code>Replacer</code> becomes more efficient.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.7 Creating substrings" data-type="sect1"><div class="sect1" id="idm45195519307584">
<h1>2.7 Creating substrings</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195519232688">
<h2>Problem</h2>
<p>You want to create substrings from a string.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195519231072">
<h2>Solution</h2>
<p>Treat a string like an array or a slice and take a substring out of the string.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195519229488">
<h2>Discussion</h2>
<p>In Go, a string is a slice of bytes. As a result if you want to take a substring out of a string, you can just do what you would do with any slice. Let’s take the same quote as in the previous recipes, the quote from <em>Great Expectations</em> by Charles Dickens.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">quote</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`I loved her against reason, against promise,</code>
<code class="s">against peace, against hope, against happiness,</code>
<code class="s">against all discouragement that could be.`</code><code class="w"/></pre>
<p>If you want to extract the words “against reason” from the quote, you can do this.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">quote</code><code class="p">[</code><code class="mi">12</code><code class="p">:</code><code class="mi">26</code><code class="p">]</code><code class="w"/></pre>
<p>This is simple enough, but how do know the position of the words without manually counting letters in the quote? Like in many programming languages, we just need to find the index of the substring.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">strings</code><code class="p">.</code><code class="nx">Index</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against reason"</code><code class="p">)</code><code class="w"/></pre>
<p>The <code>strings.Index</code> function gives us the index of the first substring that matches the second parameter, this case it will be 12. This will give us position of substring. To find the end position of the substring, we simply add the length of the substring to the index.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Index</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against reason"</code><code class="p">)</code><code class="w"/>
<code class="nx">j</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="s">"against reason"</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">quote</code><code class="p">[</code><code class="nx">i</code><code class="p">:</code><code class="nx">j</code><code class="p">])</code><code class="w"/></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.8 Checking if a string contains another string" data-type="sect1"><div class="sect1" id="idm45195518956608">
<h1>2.8 Checking if a string contains another string</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195518999616">
<h2>Problem</h2>
<p>You want to check if a string contains another string.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195518998096">
<h2>Solution</h2>
<p>Use the <code>Contains</code> functions in the <code>strings</code> package. If the string you want to check is a suffix or a prefix, you can also use the <code>HasSuffix</code> or the <code>HasPrefix</code> functions.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195518994640">
<h2>Discussion</h2>
<p>Checking if a string has a substring is quite easy in Go. You can use the <code>strings.Contains</code> function and pass in both the string and substring and it will return true or false accordingly. We’ll use the quote from <em>Great Expectations</em> by Charles Dickens again.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">quote</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`I loved her against reason, against promise,</code>
<code class="s">against peace, against hope, against happiness,</code>
<code class="s">against all discouragement that could be.`</code><code class="w"/></pre>
<p>The <code>Contains</code> function checks if the quote contains the string “against”.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">has</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"against"</code><code class="p">)</code><code class="w"/></pre>
<p>Alternately you can always use <code>strings.Index</code> and if the returned result is &lt; 0 it means the substring is not found in the string. The performance is the same in either function, not surprisingly because <code>Contains</code> is just a convenience function around <code>Index</code>. Another alternative is to use the <code>Count</code> function, which returns the number of times the substring is found in the string, but this is usually a poorer alternative (unless you need to know the count anyway) because the performance is poorer than either.</p>
<p>If you wanted to find out if the substring is the prefix of the string, you can use the <code>HasPrefix</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">strings</code><code class="p">.</code><code class="nx">HasPrefix</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"I loved"</code><code class="p">)</code><code class="w"/></pre>
<p>Of course, you can directly slice the length of the prefix from the string and check it yourself.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">prefix</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"I loved"</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">quote</code><code class="p">[:</code><code class="nb">len</code><code class="p">(</code><code class="nx">prefix</code><code class="p">)]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">prefix</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">...</code><code class="w"> </code><code class="c1">// do whatever you wanted if the string has the prefix</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You can do the same for suffixes as well with the <code>HasSuffix</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">strings</code><code class="p">.</code><code class="nx">HasSuffix</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"could be."</code><code class="p">)</code><code class="w"/></pre>
<p>You can also directly slice the string for the suffix and compare it.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">suffix</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"could be."</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">quote</code><code class="p">[</code><code class="nb">len</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="o">-</code><code class="nb">len</code><code class="p">(</code><code class="nx">suffix</code><code class="p">):]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">suffix</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="o">...</code><code class="w"> </code><code class="c1">// do whatever you wanted if the string has the prefix</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.9 Splitting a string into an array of strings or combining an array of strings into a  string" data-type="sect1"><div class="sect1" id="idm45195518994112">
<h1>2.9 Splitting a string into an array of strings or combining an array of strings into a  string</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195518696528">
<h2>Problem</h2>
<p>You want to create an array of string by splitting up a string or create a string by combining an array of strings.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195518694880">
<h2>Solution</h2>
<p>Use the <code>Split</code> functions in the <code>strings</code> package to split up a string and the <code>Join</code> function to combine the array of strings into a single string.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195518732736">
<h2>Discussion</h2>
<p>Many functions take in an array of strings. You might want to tackle words in a string instead of individual bytes. You might be dealing with data that is delimited by a separator like in delimited text format like CSV or TSV. Whichever case it may me, being able to quickly split up a string into an array of strings is useful.</p>
<p>In Go, you can do this using the <code>strings.Split</code> function. Let’s use the quote from <em>Great Expectations</em> by Charles Dickens again.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">quote</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`I loved her against reason, against promise,</code>
<code class="s">against peace, against hope, against happiness,</code>
<code class="s">against all discouragement that could be.`</code><code class="w"/></pre>
<p>The <code>Split</code> function splits a string into an array of string, given the separator.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">array</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Split</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q"</code><code class="p">,</code><code class="w"> </code><code class="nx">array</code><code class="p">)</code><code class="w"/></pre>
<p>In the code above, we use a space as the separator, so this is what you will see.</p>
<pre data-type="programlisting">["I" "loved" "her" "against" "reason," "against" "promise," "\nagainst" "peace,"
"against" "hope," "against" "happiness," "\nagainst" "all" "discouragement" "that"
"could" "be."]</pre>
<p>You might notice that some elements have the newline character because the original string has it. It’s probably not what you want, so how can we remove the newline characters? Or worse, if you have multiple spaces, your array will look pretty messy with a lot of additional empty string elements. Of course you can clean it up by brute force later on but there is a simpler way. The <code>strings</code> package has a function <code>Fields</code> that can split a string considering one or more consecutive spaces as defined by <code>uniform.isSpace</code>.</p>
<p>Let’s take a look if we use <code>Fields</code> instead of <code>Split</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">array</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Fields</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q"</code><code class="p">,</code><code class="w"> </code><code class="nx">array</code><code class="p">)</code><code class="w"/></pre>
<p>You should see this now.</p>
<pre data-type="programlisting">["I" "loved" "her" "against" "reason," "against" "promise," "against" "peace,"
"against" "hope," "against" "happiness," "against" "all" "discouragement" "that"
"could" "be."]</pre>
<p>The newline characters are gone. How about if we want to remove even the punctuation (in this case, the commas and the full stop at the end of the quote)? This is a bit more complicated, we need to use the <code>FieldsFunc</code> function and pass in a function that will determine that should be part of the separator or not. Let’s take a look.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="kt">rune</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">unicode</code><code class="p">.</code><code class="nx">IsPunct</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">!</code><code class="nx">unicode</code><code class="p">.</code><code class="nx">IsLetter</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">array</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">FieldsFunc</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q"</code><code class="p">,</code><code class="w"> </code><code class="nx">array</code><code class="p">)</code><code class="w"/></pre>
<p>In the code above, we create a function <code>f</code> that considers consecutive punctuations and non-letters to be part of the separator. Then we pass this function into <code>FieldsFunc</code> for it to be executed against the string. This is what we should see.</p>
<pre data-type="programlisting">["I" "loved" "her" "against" "reason" "against" "promise" "against" "peace"
"against" "hope" "against" "happiness" "against" "all" "discouragement" "that"
"could" "be"]</pre>
<p>As you can see, we have also removed the punctuations. The <code>FieldsFunc</code> function is very versatile, I’ve only given a very simple example. If you work a lot with splitting strings, this will be a very powerful function you can use to do many things.</p>
<p>What if we want to just split the string for the first 9 elements and put the rest in single string? The <code>SplitN</code> function does exactly that, with <code>n</code> being the number of elements to have in the resulting array, in this case here it’s 10.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">array</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">SplitN</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">" "</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q"</code><code class="p">,</code><code class="w"> </code><code class="nx">array</code><code class="p">)</code><code class="w"/></pre>
<p>You will see that there are 10 elements in the resulting array.</p>
<pre data-type="programlisting">["I" "loved" "her" "against" "reason," "against" "promise," "\nagainst" "peace,"
"against hope, against happiness, \nagainst all discouragement that could be."]</pre>
<p>Sometimes you want to keep the delimiter after you split the string. Go has a function called <code>SplitAfter</code> that does this.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">array</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">SplitAfter</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%q"</code><code class="p">,</code><code class="w"> </code><code class="nx">array</code><code class="p">)</code><code class="w"/></pre>
<p>As you can see, each element ends with a space (which is the delimiter) except the final element.</p>
<pre data-type="programlisting">["I " "loved " "her " "against " "reason, " "against " "promise, " "\nagainst "
"peace, " "against " "hope, " "against " "happiness, " "\nagainst " "all "
"discouragement " "that " "could " "be."]</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="2.10 Trimming strings" data-type="sect1"><div class="sect1" id="idm45195518731664">
<h1>2.10 Trimming strings</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195518437760">
<h2>Problem</h2>
<p>You want to remove the leading and trailing characters of a string.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195518382208">
<h2>Solution</h2>
<p>Use the <code>Trim</code> functions in the <code>strings</code> package.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195518379840">
<h2>Discussion</h2>
<p>When processing strings it’s quite common to encounter trailing or leading whitespaces or other unnecessary characters. Very often we want to remove these characters before storing or processing the strings further. Because of this, the idea of string trimming is quite common as well. String trimming essentially removes characters from the start or the end of the string, but not within the string.</p>
<p>In Go, there are a number of <code>Trim</code> functions in the <code>strings</code> package that can help us with trimming strings.</p>
<p>Let’s start with the <code>Trim</code> function. It takes in a string and a <em>cutset</em> which is a string consisting of one or more Unicode code points and returns a string with all leading and trailing these code points removed.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">str</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">", and that is all."</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">cutset</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">",. "</code><code class="w"/>
<code class="nx">trimmed</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Trim</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="nx">cutset</code><code class="p">)</code><code class="w"> </code><code class="c1">// "and that is all"</code><code class="w"/></pre>
<p>In the code above, we want to remove the leading comma and whitespace, and also the trailing full stop. To do this we use a cutset consisting of these 3 Unicode code points, so the cutset string ends up to be <code>",. "</code>.</p>
<p>The <code>Trim</code> function removes both trailing and leading characters, but if you want to only remove trailing characters you can use the <code>TrimRight</code> function, or if you want to only remove the leading characters you can use the <code>TrimLeft</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">trimmedLeft</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimLeft</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="nx">cutset</code><code class="p">)</code><code class="w">   </code><code class="c1">// "and that is all."</code><code class="w"/>
<code class="nx">trimmedRight</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimRight</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="nx">cutset</code><code class="p">)</code><code class="w"> </code><code class="c1">// ", and that is all"</code><code class="w"/></pre>
<p>The earlier <code>Trim</code> functions remove any characters in the cutset. However, if you want to remove an entire leading substring (or a prefix) you can use the <code>TrimPrefix</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">trimmedPrefix</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimPrefix</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="s">", and "</code><code class="p">)</code><code class="w">	</code><code class="c1">// "that is all."</code><code class="w"/></pre>
<p>Similarly if you want to remove an entire trailing substring (or a suffix) you can use the <code>TrimSuffix</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">trimmedSuffix</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimSuffix</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="s">" all."</code><code class="p">)</code><code class="w"> </code><code class="c1">// ", and that is"</code><code class="w"/></pre>
<p>The <code>Trim</code> functions allows you to remove any leading or trailing characters or string. However, the most commonly removed characters are usually whitespaces, which can be newlines (<code>\n</code>) or tabs (<code>\r</code>) or carriage returns )<code>\r</code>). For convenience, Go provides a <code>TrimSpace</code> function that simply removes trailing and leading whitespaces.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">trimmed</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimSpace</code><code class="p">(</code><code class="s">"\r\n\t Hello World \t\n\r"</code><code class="p">)</code><code class="w"> </code><code class="c1">// Hello World</code><code class="w"/></pre>
<p>The last set of <code>Trim</code> functions are the <code>TrimFunc</code>, <code>TrimLeftFunc</code> and <code>TrimRightFunc</code> functions. As you would have guessed it from the name, this allows you to substitute the cutset string with a function that will inspect the leading or trailing or both Unicode code points and make sure they satisfy the conditions.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="kt">rune</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">return</code><code class="w"> </code><code class="nx">unicode</code><code class="p">.</code><code class="nx">IsPunct</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="p">!</code><code class="nx">unicode</code><code class="p">.</code><code class="nx">IsLetter</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">trimmed</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">TrimFunc</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">)</code><code class="w"> </code><code class="c1">// "and that is all"</code><code class="w"/></pre>
<p>These <code>TrimFunc</code> functions allow you finer control over string trimming, which can be useful if you have unexpected rules for removing the leading or trailing characters.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.11 Capturing string input from the command line" data-type="sect1"><div class="sect1" id="idm45195518076560">
<h1>2.11 Capturing string input from the command line</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195518075648">
<h2>Problem</h2>
<p>You want to capture user input string data from the command line.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195518074064">
<h2>Solution</h2>
<p>Use the <code>Scan</code> functions in the <code>fmt</code> package to read a single string from standard input. To read a string separated by spaces, use <code>ReadString</code> on a <code>Reader</code> wrapped around <code>os.Stdin</code>.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195518069936">
<h2>Discussion</h2>
<p>If your Go program runs from the command line you might come across a time where you need to get a string input from the user. This is where the <code>Scan</code> function from the <code>fmt</code> package comes in useful.</p>
<p>You can use <code>Scan</code> to get input from the user by creating a variable then passing a reference to that variable into <code>Scan</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="s">"fmt"</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="kd">var</code><code class="w"> </code><code class="nx">input</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Please enter a word: "</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Scan</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">input</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error with user input:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"You entered:"</code><code class="p">,</code><code class="w"> </code><code class="nx">input</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you run the code above, the program will wait for your input at <code>fmt.Scan</code> and will only continue when you enter an input. Once you have entered some data, <code>Scan</code> will store the data into the <code>input</code> variable.</p>
<p>If you run the code above, this is what you should see.</p>
<pre data-type="programlisting">% go run scan.go
Please enter a word: Hello
You entered: Hello</pre>
<p>The documentation do not explicitly mention that you need to pass in a reference to a variable. You can pass in a variable by value and it will compile. However if you do that you will get an error.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Scan</code><code class="p">(</code><code class="nx">input</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error with user input:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you run the code above, you will get this.</p>
<pre data-type="programlisting">% go run scan.go
Please enter a word: error with user input: type not a pointer: string 0</pre>
<p>The <code>Scan</code> function can take in more than one parameter, and each parameter represents a user input that is separated by a space. Let’s do this again with two inputs.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="kd">var</code><code class="w"> </code><code class="nx">input1</code><code class="p">,</code><code class="w"> </code><code class="nx">input2</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Please enter two words: "</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Scan</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">input1</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">input2</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error with user input:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"You entered:"</code><code class="p">,</code><code class="w"> </code><code class="nx">input1</code><code class="p">,</code><code class="w"> </code><code class="s">"and"</code><code class="p">,</code><code class="w"> </code><code class="nx">input2</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you run this, and enter the words <em>Hello</em> and <em>World</em>, they will be captured and stored into <code>input1</code> and <code>input2</code> respectively. If you run the code above you will see this.</p>
<pre data-type="programlisting">% go run scan.go
Please enter two words: Hello World
You entered: Hello and World</pre>
<p>This seems a bit limited. What if you want to capture a string that has spaces in it? For example, you want to get a user to input a sentence. In that case you can use the <code>ReadString</code> function on a <code>Reader</code> that is wrapped around <code>os.Stdin</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">reader</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bufio</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Stdin</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Please enter many words: "</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">input</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">reader</code><code class="p">.</code><code class="nx">ReadString</code><code class="p">(</code><code class="sc">'\n'</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error with user input:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"You entered:"</code><code class="p">,</code><code class="w"> </code><code class="nx">input</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you run the code above, this is what you should see.</p>
<pre data-type="programlisting">% go run scan.go
Please enter many words: Many words here and still more to go
You entered: Many words here and still more to go</pre>
<p>You should know that <code>Scan</code> can be used to get more than just string input from users, it can be used to get numbers and so on.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.12 Escaping and unescaping HTML strings" data-type="sect1"><div class="sect1" id="idm45195518068832">
<h1>2.12 Escaping and unescaping HTML strings</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195517589856">
<h2>Problem</h2>
<p>You want to escape or unescape HTML strings.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195517588272">
<h2>Solution</h2>
<p>Use the <code>EscapeString</code> and <code>UnescapeString</code> functions in the <code>html</code> package to escape or unescape HTML strings.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195517585344">
<h2>Discussion</h2>
<p>HTML is a text-based markup language that structures a web page and its content. It is usually interpreted by a browser and displayed. Much of HTML is described within HTML tags for example, <code>&lt;a&gt;</code> is an anchor tag and <code>&lt;img&gt;</code> is an image tag. Similarly there are other characters like <code>&amp;</code> and <code>"</code> and others that has specific meaning in HTML.</p>
<p>But what if want to show those characters in HTML itself? For example, the ampersand (<code>&amp;</code>) is a commonly used character. The less than and greater than (<code>&lt;</code> and <code>&gt;</code>) are also commonly used. If we don’t intend these symbols to have any meaning in HTML, we need to convert them into HTML character entities. For example:</p>
<ul>
<li>
<p>&lt; (less than) becomes &lt;</p>
</li>
<li>
<p>&gt; (greater than) becomes &gt;</p>
</li>
<li>
<p>&amp; (ampersand) becomes &amp;</p>
</li>
</ul>
<p>And so on. The process of converting HTML characters into entities is called HTML escaping and the reverse is called HTML unescaping.</p>
<p>Go has a pair of functions called <code>EscapeString</code> and <code>UnescapeString</code> in the <code>html</code> package that can be used to escape or unescape HTML.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"&lt;b&gt;Rock &amp; Roll&lt;/b&gt;"</code><code class="w"/>
<code class="nx">escaped</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">html</code><code class="p">.</code><code class="nx">EscapeString</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code><code class="w"> </code><code class="c1">// "&amp;lt;b&amp;gt;Rock &amp;amp; Roll&amp;lt;/b&amp;gt;"</code><code class="w"/></pre>
<p>Unescaping reverts the escaped HTML back to the original string.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">unescaped</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">html</code><code class="p">.</code><code class="nx">UnescapeString</code><code class="p">(</code><code class="nx">escaped</code><code class="p">)</code><code class="w"> </code><code class="c1">// "&lt;b&gt;Rock &amp; Roll&lt;/b&gt;"</code><code class="w"/></pre>
<p>You might notice that there is also a <code>HTMLEscapeString</code> function in the <code>html/template</code> package. The results of both functions are the same.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="2.13 Using regular expressions" data-type="sect1"><div class="sect1" id="idm45195517521024">
<h1>2.13 Using regular expressions</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195517520080">
<h2>Problem</h2>
<p>You want to use regular expressions to do string manipulation.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195517518496">
<h2>Solution</h2>
<p>Use the <code>regex</code> package and parse the regular expression using the <code>Compile</code> function to return a <code>Regexp</code> struct.Then use the <code>Find</code>  functions to match the pattern and return the string.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195517515152">
<h2>Discussion</h2>
<p>Regular expressions are a notation for describing a search pattern in a string. When a particular string is in the set described by a regular expression, the regular expression matches the string. Regular expressions are popular and available in many languages.</p>
<p>Go has an entire standard package dedicated to regular expressions called <code>regex</code>. The syntax of the regular expressions is the same general syntax used by Perl, Python, and other languages.</p>
<p>Using the <code>regex</code> package is quite straightforward. You must first create a <code>Regexp</code> struct from the regular expressions. With this struct you can call any number of <code>Find</code> functions that will return the strings or the index of the strings that matches.</p>
<p>While it looks like there are a lot of <code>Find</code> functions in the <code>regex</code> package, mostly attached as methods to the <code>Regexp</code> struct, there is a general pattern to them. In particular, the ones without <code>All</code> will only return the first match while the ones with <code>All</code> potentially returns all the matches in the string, depending on the <code>n</code> parameter. The ones with <code>String</code> will return strings or slices of strings, while the ones without will return as an array of bytes, <code>[]byte</code>. The ones with <code>Index</code> returns the index of the match.</p>
<p>In the code snippets below we will be using the same quote from <em>Great Expectations</em> by Charles Dickens as with the other recipes in this chapter.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">quote</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">`I loved her against reason, against promise,</code>
<code class="s">against peace, against hope, against happiness,</code>
<code class="s">against all discouragement that could be.`</code><code class="w"/></pre>
<p>Let’s start with creating a <code>Regexp</code> struct that can be used later.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">re</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">regexp</code><code class="p">.</code><code class="nx">Compile</code><code class="p">(</code><code class="s">`against [\w]+`</code><code class="p">)</code><code class="w"/></pre>
<p>The regular expression here is <code><code>against [\w]+</code></code>. We use backticks to create the regular expression string because regular expressions use a lot of backslashes and these would be interpreted differently if we use double quotes. The regular expression we use matches against a pattern within a string that starts with <em>against</em> and has a word after it.</p>
<p>A convenient alternative to <code>Compile</code> is the <code>MustCompile</code> function. This function does exactly the same thing as <code>Compile</code>, except that it doesn’t return an error. Instead, if the regular expression doesn’t compile, the function will panic.</p>
<p>Once we have the regular expression set up, we can use it to find matches. There are a number of <code>Find</code> methods, but we’ll only go through a few in this recipe. One of the most straightforward method is
<code>MatchString</code> which simply tells us if the regular expression has any matches in the string.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">re</code><code class="p">.</code><code class="nx">MatchString</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"> </code><code class="c1">// true</code><code class="w"/></pre>
<p>Sometimes besides checking if the regular expression has any matches, we also want to return the matching string. We can use <code>FindString</code> to do this.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">str</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">FindString</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"> </code><code class="c1">// "against reason"</code><code class="w"/></pre>
<p>Here we find a string from the <code>quote</code> string, using the regular expression we set up earlier. It  returns the first match, so the returned string is <code>against reason</code>. If we want to return all matches, we have to use a method with <code>All</code> in it, like <code>FindAllString</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">strs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">FindAllString</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">strs</code><code class="p">)</code><code class="w"/></pre>
<p>The second parameter in <code>FindAllString</code>, like all <code>All</code> methods, indicates the number of matches we want to be returned. If we want to return all matches, we need to use a negative number, in this case <code>-1</code>. The returned values are an array of strings.</p>
<p>If we run the code above, which also prints out the array of strings, this is what we get.</p>
<pre data-type="programlisting">[against reason against promise against peace against hope against happiness
against all]</pre>
<p>Besides returning the matched strings, sometimes we want to find out the locations of the matches. In this case, we can use the <code>Index</code> functions, for example the <code>FindStringIndex</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">locs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">FindStringIndex</code><code class="p">(</code><code class="nx">quote</code><code class="p">)</code><code class="w"> </code><code class="c1">// [12 26]</code><code class="w"/></pre>
<p>This returns a 2-element slice of integers, which indicates the position of the first match. If we use these 2 integers on the <code>quote</code> itself, we will be able to extract the matching substring.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">quote</code><code class="p">[</code><code class="nx">locs</code><code class="p">[</code><code class="mi">0</code><code class="p">]:</code><code class="nx">locs</code><code class="p">[</code><code class="mi">1</code><code class="p">]]</code><code class="w"> </code><code class="c1">// against reason</code><code class="w"/></pre>
<p>As before, to get all matches, we need to use the <code>All</code> method, so in this case we can use the <code>FindAllStringIndex</code> method.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">allLocs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">FindAllStringIndex</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">allLocs</code><code class="p">)</code><code class="w"/></pre>
<p>This will return a 2-dimensional slice of all matches.</p>
<pre data-type="programlisting">[[12 26] [28 43] [46 59] [61 73] [75 92] [95 106]]</pre>
<p>Besides finding and indexing regular expressions, we can replace the matched strings altogether using <code>ReplaceAllString</code>. This is a simple example.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">replaced</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">ReplaceAllString</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="s">"anything"</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">replaced</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code above, this is what you should see.</p>
<pre data-type="programlisting">I loved her anything, anything,
anything, anything, anything,
anything discouragement that could be.</pre>
<p>Beyond a simple replacement, we can replace the matched string with the output of a function that takes in the matched string and produces another string. Let’s take a look at a quick example.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">replaced</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">ReplaceAllStringFunc</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">ToUpper</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">replaced</code><code class="p">)</code><code class="w"/></pre>
<p>Here we are replacing all the matched strings with the uppercase version of the string by using the <code>strings.ToUpper</code> function. This is the results of running the code.</p>
<pre data-type="programlisting">I loved her AGAINST REASON, AGAINST PROMISE,
AGAINST PEACE, AGAINST HOPE, AGAINST HAPPINESS,
AGAINST ALL discouragement that could be.</pre>
<p>Let’s say instead of making both words in the matched string uppercase, we only want the second word to be uppercase. We can create a simple function to do this.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">in</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">split</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Split</code><code class="p">(</code><code class="nx">in</code><code class="p">,</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">split</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">ToUpper</code><code class="p">(</code><code class="nx">split</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code><code class="w"/>
<code class="w">	</code><code class="k">return</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Join</code><code class="p">(</code><code class="nx">split</code><code class="p">,</code><code class="w"> </code><code class="s">" "</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">replaced</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">ReplaceAllStringFunc</code><code class="p">(</code><code class="nx">quote</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">replaced</code><code class="p">)</code><code class="w"/></pre>
<p>If we run this code, we will get this.</p>
<pre data-type="programlisting">I loved her against REASON, against PROMISE,
against PEACE, against HOPE, against HAPPINESS,
against ALL discouragement that could be.</pre>
<p>Regular expressions are very powerful and used in many places. In Go it can be used for very powerful string manipulation. However, there is a word of caution. The <code>regex</code> package in Go supports the regular expression syntax accepted by RE2. This gaurantees the regular expressions to  run in time linear in the size of the input. As a result, some of the syntax like <code>lookahead</code> and <code>lookbehind</code> are not supported. If you’re more familiar with the syntax supported by PCRE library, you might want to check and make sure your regular expressions work the way you want it to.</p>
</div></section>
</div></section>
</div></section></div></body></html>