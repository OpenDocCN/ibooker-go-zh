- en: 'Chapter 9\. you’re my type: Defined Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0265-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**There’s more to learn about defined types.** In the previous chapter, we
    showed you how to define a type with a struct underlying type. What we *didn’t*
    show you was that you can use *any* type as an underlying type.'
  prefs: []
  type: TYPE_NORMAL
- en: And do you remember methods—the special kind of function that’s associated with
    values of a particular type? We’ve been calling methods on various values throughout
    the book, but we haven’t shown you how to define your *own* methods. In this chapter,
    we’re going to fix all of that. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Type errors in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you live in the US, you are probably used to the quirky system of measurement
    used there. At gas stations, for example, fuel is sold by the gallon, a volume
    nearly four times the size of the liter used in much of the rest of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Steve is an American, renting a car in another country. He pulls into a gas
    station to refuel. He intends to purchase 10 gallons, figuring that will be enough
    to reach his hotel in another city.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0266-01.png)'
  prefs: []
  type: TYPE_IMG
- en: He gets back on the road, but only gets one-fourth of the way to his destination
    before running out of fuel.
  prefs: []
  type: TYPE_NORMAL
- en: If Steve had looked at the labels on the gas pump more closely, he would have
    realized that it was measuring the fuel in liters, not gallons, and that he needed
    to purchase 37.85 liters to get the equivalent of 10 gallons.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0266-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**10 gallons**'
  prefs: []
  type: TYPE_NORMAL
- en: When you have a number, it’s best to be certain what that number is measuring.
    You want to know if it’s liters or gallons, kilograms or pounds, dollars or yen.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0266-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**10 liters**'
  prefs: []
  type: TYPE_NORMAL
- en: Defined types with underlying basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '...does that represent 10 gallons or 10 liters? The person who wrote that declaration
    knows, but no one else does, not for sure.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Go’s defined types to make it clear what a value is to be used for.
    Although defined types most commonly use structs as their underlying types, they
    *can* be based on `int`, `float64`, `string`, `bool`, or any other type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Go defined types most often use structs as their underlying types, but they
    can also be based on ints, strings, booleans, or any other type.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here’s a program that defines two new types, `Liters` and `Gallons`, both with
    an underlying type of `float64`. These are defined at the package level, so that
    they’re available within any function in the current package.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `main` function, we declare a variable with a type of `Gallons`,
    and another with a type of `Liters`. We assign values to each variable, and then
    print them out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0267-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve defined a type, you can do a conversion to that type from any value
    of the underlying type. As with any other conversion, you write the type you want
    to convert to, followed by the value you want to convert in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had wanted, we could have written short variable declarations in the
    code above using type conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0267-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a variable that uses a defined type, you *cannot* assign a value
    of a different defined type to it, even if the other type has the same underlying
    type. This helps protect developers from confusing the two types.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0268-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But you can *convert* between types that have the same underlying type. So `Liters`
    can be converted to `Gallons` and vice versa, because both have an underlying
    type of `float64`. But Go only considers the value of the underlying type when
    doing a conversion; there is no difference between `Gallons(Liters(240.0))` and
    `Gallons(240.0)`. Simply converting raw values from one type to another defeats
    the protection against conversion errors that types are supposed to provide.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0268-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead, you’ll want to perform whatever operations are necessary to convert
    the underlying type value to a value appropriate for the type you’re converting
    to.
  prefs: []
  type: TYPE_NORMAL
- en: A quick web search shows that one liter equals roughly 0.264 gallons, and that
    one gallon equals roughly 3.785 liters. We can multiply by these conversion rates
    to convert from `Gallons` to `Liters`, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0268-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Defined types and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A defined type supports all the same operations as its underlying type. Types
    based on `float64`, for example, support arithmetic operators like `+`, `-`, `*`,
    and `/`, as well as comparison operators like `==`, `>`, and `<`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0269-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A type based on an underlying type of `string`, however, would support `+`,
    `==`, `>`, and `<`, but not `-`, because `-` is not a valid operator for strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0269-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A defined type can be used in operations together with literal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0269-03.png)'
  prefs: []
  type: TYPE_IMG
- en: But defined types *cannot* be used in operations together with values of a different
    type, even if the other type has the same underlying type. Again, this is to protect
    developers from accidentally mixing the two types.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0269-04.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to add a value in `Liters` to a value in `Gallons`, you’ll need
    to convert one type to match the other first.
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0270-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0270-02.png)![image](assets/f0270-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: each snippet from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_6).'
  prefs: []
  type: TYPE_NORMAL
- en: Converting between types using functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we wanted to take a car whose fuel level is measured in `Gallons` and
    refill it at a gas pump that measures in `Liters`. Or take a bus whose fuel is
    measured in `Liters` and refill it at a gas pump that measures in `Gallons`. To
    protect us from inaccurate measurements, Go will give us a compile error if we
    try to combine values of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0271-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to do operations with values of different types, we need to convert
    the types to match first. Previously, we demonstrated multiplying a `Liters` value
    by 0.264 and converted the result to `Gallons`. We also multiplied a `Gallons`
    value by 3.785 and converted the result to `Liters`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0271-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create `ToGallons` and `ToLiters` functions that do the same thing,
    then call them to perform the conversion for us:'
  prefs: []
  type: TYPE_NORMAL
- en: Gasoline isn’t the only liquid we need to measure the volume of. There’s cooking
    oil, bottles of soda, and juice, to name a few. And so there are many more measures
    of volume than just liters and gallons. In the US there are teaspoons, cups, quarts,
    and more. The metric system has other units of measure as well, but the milliliter
    (1/1000 of a liter) is the most commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a new type, `Milliliters`. Like the others, it will use `float64`
    as an underlying type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0272-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’re also going to want a way to convert from `Milliliters` to the other types.
    But if we start adding a function to convert from `Milliliters` to `Gallons`,
    we run into a problem: we can’t have two `ToGallons` functions in the same package!'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0272-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We could rename the two `ToGallons` functions to include the type they’re converting
    from: `LitersToGallons` and `MillilitersToGallons`, respectively. But those names
    would be a pain to write out all the time, and as we start adding functions to
    convert between the other types, it becomes clear this isn’t sustainable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0272-03.png)'
  prefs: []
  type: TYPE_IMG
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: I’ve seen other languages that support function *overloading*: they allow
    you to have multiple functions with the same name, as long as their parameter
    types are different. Doesn’t Go support that?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** The Go maintainers get this question frequently too, and they answer
    it at *[https://golang.org/doc/faq#overloading](https://golang.org/doc/faq#overloading)*:
    “Experience with other languages told us that having a variety of methods with
    the same name but different signatures was occasionally useful but that it could
    also be confusing and fragile in practice.” The Go language is simplified by *not*
    supporting overloading, and so it doesn’t support it. As you’ll see later in the
    book, the Go team made similar decisions in other areas of the language, too;
    when they have to choose between simplicity and adding more features, they generally
    choose simplicity. But that’s okay! As we’ll see shortly, there are other ways
    to get the same benefits...'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0273-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Fixing our function name conflict using methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember way back in [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition),
    we introduced you to *methods*, which are functions associated with values of
    a given type? Among other things, we created a `time.Time` value and called its
    `Year` method, and we created a `strings.Replacer` value and called its `Replace`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0274-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We can define methods of our own to help with our type conversion problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not allowed to have multiple functions named `ToGallons`, so we had to
    write long, cumbersome function names that incorporated the type we were converting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But we *can* have multiple *methods* named `ToGallons`, as long as they’re defined
    on separate types. Not having to worry about name conflicts will let us make our
    method names much shorter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But let’s not get ahead of ourselves. Before we can do anything else, we need
    to know how to define a method...
  prefs: []
  type: TYPE_NORMAL
- en: Defining methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A method definition is very similar to a function definition. In fact, there’s
    really only one difference: you add one extra parameter, a **receiver parameter**,
    in parentheses *before* the function name.'
  prefs: []
  type: TYPE_NORMAL
- en: As with any function parameter, you need to provide a name for the receiver
    parameter, followed by a type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0275-01.png)'
  prefs: []
  type: TYPE_IMG
- en: To call a method you’ve defined, you write the value you’re calling the method
    on, a dot, and the name of the method you’re calling, followed by parentheses.
    The value you’re calling the method on is known as the method **receiver**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The similarity between method calls and method definitions can help you remember
    the syntax: the receiver is listed first when you’re *calling* a method, and the
    receiver parameter is listed first when you’re *defining* a method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0275-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The name of the receiver parameter in the method definition isn’t important,
    but its type is; the method you’re defining becomes associated with all values
    of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Below, we define a type named `MyType`, with an underlying type of `string`.
    Then, we define a method named `sayHi`. Because `sayHi` has a receiver parameter
    with a type of `MyType`, we’ll be able to call the `sayHi` method on any `MyType`
    value. (Most developers would say that `sayHi` is defined “on” `MyType`.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0275-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Once a method is defined on a type, it can be called on any value of that type.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create two different `MyType` values, and call `sayHi` on each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The receiver parameter is (pretty much) just another parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type of the receiver parameter is the type that the method becomes associated
    with. But aside from that, the receiver parameter doesn’t get special treatment
    from Go. You can access its contents within the method block just like you would
    any other function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The code sample below is almost identical to the previous one, except that we’ve
    updated it to print the value of the receiver parameter. You can see the receivers
    in the resulting output.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0276-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Go lets you name a receiver parameter whatever you want, but it’s more readable
    if all the methods you define for a type have receiver parameters with the same
    name.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, Go developers usually use a name consisting of a single letter—the
    first letter of the receiver’s type name, in lowercase. (This is why we used `m`
    as the name for our `MyType` receiver parameter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Go uses receiver parameters instead of the “self” or “this” values seen in
    other languages.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: Can I define new methods on *any* type?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Only types that are defined in the same package where you define the
    method. That means no defining methods for types from someone else’s `security`
    package from your `hacking` package, and no defining new methods on universal
    types like `int` or `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q: But I need to be able to use methods of my own with someone else’s type!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** First you should consider whether a function would work well enough;
    a function can take any type you want as a parameter. But if you *really* need
    a value that has some methods of your own, plus some methods from a type in another
    package, you can make a struct type that embeds the other package’s type as an
    anonymous field. We’ll look at how that works in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q: I’ve seen other languages where a method receiver was available in a method
    block in a special variable named `self` or `this`. Does Go do that?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Go uses receiver parameters instead of `self` and `this`. The big difference
    is that `self` and `this` are set *implicitly*, whereas you *explicitly* declare
    a receiver parameter. Other than that, receiver parameters are used in the same
    way, and there’s no need for Go to reserve `self` or `this` as keywords! (You
    could even name your receiver parameter `this` if you wanted, but don’t do that;
    the convention is to use the first letter of the receiver’s type name instead.)'
  prefs: []
  type: TYPE_NORMAL
- en: A method is (pretty much) just like a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from the fact that they’re called on a receiver, methods are otherwise
    pretty similar to any other function.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other function, you can define additional parameters within parentheses
    following the method name. These parameter variables can be accessed in the method
    block, along with the receiver parameter. When you call the method, you’ll need
    to provide an argument for each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0277-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As with any other function, you can declare one or more return values for a
    method, which will be returned when the method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0277-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As with any other function, a method is considered exported from the current
    package if its name begins with a capital letter, and it’s considered unexported
    if its name begins with a lowercase letter. If you want to use your method outside
    the current package, be sure its name begins with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0277-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Pointer receiver parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s an issue that may look familiar by now. We’ve defined a new `Number`
    type with an underlying type of `int`. We’ve given `Number` a `double` method
    that is supposed to multiply the underlying value of its receiver by two and then
    update the receiver. But we can see from the output that the method receiver isn’t
    actually getting updated.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0279-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Back in [Chapter 3](ch03.html#call_mecolon_functions), we had a `double` *function*
    with a similar problem. Back then, we learned that function parameters receive
    a copy of the values the function is called with, not the original values, and
    that any updates to the copy would be lost when the function exited. To make the
    `double` function work, we had to pass a *pointer* to the value we wanted to update,
    and then update the value at that pointer within the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0279-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve said that receiver parameters are treated no differently than ordinary
    parameters. And like any other parameter, a receiver parameter receives a *copy*
    of the receiver value. If you make changes to the receiver within a method, you’re
    changing the copy, not the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `double` function in [Chapter 3](ch03.html#call_mecolon_functions),
    the solution is to update our `Double` method to use a pointer for its receiver
    parameter. This is done in the same way as any other parameter: we place a `*`
    in front of the receiver type to indicate it’s a pointer type. We’ll also need
    to modify the method block so that it updates the value at the pointer. Once that’s
    done, when we call `Double` on a `Number` value, the `Number` should be updated.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0280-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we *didn’t* have to change the method call at all. When you call
    a method that requires a pointer receiver on a variable with a nonpointer type,
    Go will automatically convert the receiver to a pointer for you. The same is true
    for variables with pointer types; if you call a method requiring a value receiver,
    Go will automatically get the value at the pointer for you and pass that to the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this at work in the code at right. The method named `method` takes
    a value receiver, but we can call it using both direct values and pointers, because
    Go autoconverts if needed. And the method named `pointerMethod` takes a pointer
    receiver, but we can call it on both direct values and pointers, because Go will
    autoconvert if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0280-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By the way, the code at right breaks a convention: for consistency, all of
    your type’s methods can take value receivers, or they can all take pointer receivers,
    but you should avoid mixing the two. We’re only mixing the two kinds here for
    demonstration purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Stuff is Educational!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0282-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here is our `Number` type again, with definitions for a couple methods. Make
    one of the changes below and try to compile the code. Then undo your change and
    try the next one. See what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| If you do this... | ...the code will break because... |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Change a receiver parameter to a type not defined in this package: `func
    (n *~~Number~~int) Double() { *n *= 2 }` | You can only define new methods on
    types that were declared in the current package. Defining a method on a globally
    defined type like `int` will result in a compile error. |'
  prefs: []
  type: TYPE_TB
- en: '| Change the receiver parameter for `Double` to a nonpointer type: `func (n
    ~~*~~Number) Double() { ~~*~~n *= 2 }` | Receiver parameters receive a copy of
    the value the method was called on. If the `Double` function only modifies the
    copy, the original value will be unchanged when `Double` exits. |'
  prefs: []
  type: TYPE_TB
- en: '| Call a method that requires a pointer receiver on a value that’s not in a
    variable: `Number(4).Double()` | When calling a method that takes a pointer receiver,
    Go can automatically convert a value to a pointer to a receiver *if* it’s stored
    in a variable. If it’s not, you’ll get an error. |'
  prefs: []
  type: TYPE_TB
- en: '| Change the receiver parameter for `Display` to a nonpointer type: `func (n
    ~~*~~Number) Display() { fmt.Println(~~*~~n) }` | The code will actually still
    *work* after making this change, but it breaks convention! Receiver parameters
    in the methods for a type can be all pointers, or all values, but it’s best to
    avoid mixing the two. |'
  prefs: []
  type: TYPE_TB
- en: Converting Liters and Milliliters to Gallons using methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we added a `Milliliters` type to our defined types for measuring volume,
    we discovered we couldn’t have `ToGallons` functions for both `Liters` and `Milliliters`.
    To work around this, we had to create functions with lengthy names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: But unlike functions, method names don’t have to be unique, as long as they’re
    defined on different types.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try implementing a `ToGallons` method on the `Liters` type. The code will
    be almost identical to the `LitersToGallons` function, but we’ll make the `Liters`
    value a receiver parameter rather than an ordinary parameter. Then we’ll do the
    same for the `Milliliters` type, converting the `MillilitersToGallons` function
    to a `ToGallons` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re not using pointer types for the receiver parameters. We’re
    not modifying the receivers, and the values don’t consume much memory, so it’s
    fine for the parameter to receive a copy of the value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0283-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In our `main` function, we create a `Liters` value, then call `ToGallons` on
    it. Because the receiver has the type `Liters`, the `ToGallons` method for the
    `Liters` type is called. Likewise, calling `ToGallons` on a `Milliliters` value
    causes the `ToGallons` method for the `Milliliters` type to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Gallons to Liters and Milliliters using methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process is similar when converting the `GallonsToLiters` and `GallonsToMilliliters`
    functions to methods. We just move the `Gallons` parameter to a receiver parameter
    in each.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0284-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0285-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 9](#yoursquore_my_typecolon_defined_types)! You’ve
    added method definitions to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0285-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0286-01.png)'
  prefs: []
  type: TYPE_IMG
