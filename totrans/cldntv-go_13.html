<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Manageability"><div class="chapter" id="chapter_10">&#13;
<h1><span class="label">Chapter 10. </span>Manageability</h1>&#13;
&#13;
<blockquote>&#13;
<p>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it?<sup><a data-type="noteref" id="idm45983620458120-marker" href="ch10.xhtml#idm45983620458120">1</a></sup></p>&#13;
<p data-type="attribution">Brian Kernighan, <cite>The Elements of Programming Style (1978)</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>In a perfect world, you’d never have to deploy a new version of your service or (heaven forbid!) shut down your entire system to fix or modify it to meet new requirements.</p>&#13;
&#13;
<p>Then again, in a perfect world, unicorns would exist and four out of five dentists would recommend we eat pie for breakfast.<sup><a data-type="noteref" id="idm45983620454840-marker" href="ch10.xhtml#idm45983620454840">2</a></sup></p>&#13;
&#13;
<p>Clearly, we don’t live in a perfect world. But while unicorns might never exist,<sup><a data-type="noteref" id="idm45983620452296-marker" href="ch10.xhtml#idm45983620452296">3</a></sup> you don’t have to resign yourself to a world where you have to update your code whenever you need to alter your system’s behavior.</p>&#13;
&#13;
<p>While you’ll probably always have to make code changes to update core logic, it is possible to build your systems so that you—or, critically, somebody else—can change a surprising variety of behaviors without having to recode and redeploy.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="manageability" data-secondary="definition of" id="ch10_term1"/>You may recall that we introduced this important attribute of cloud native systems back&#13;
in <a data-type="xref" href="ch01.xhtml#section_ch01_manageability">“Manageability”</a>, where we defined it as the ease with which a system’s behavior can be modified to keep it secure, running smoothly, and compliant with changing requirements.</p>&#13;
&#13;
<p>While this sounds straightforward, there’s actually quite a bit more to manageability than you might think. It goes far beyond configuration files (though that’s certainly part of it). In this chapter, we’ll discuss what it means to have a manageable system, and we’ll cover some of the techniques and implementations that can allow you to build a system that can change <em>almost</em> as quickly as its requirements.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983620446568">&#13;
<h5>Manageability Is Not Maintainability</h5>&#13;
<p><a data-type="indexterm" data-primary="manageability" data-secondary="maintainability and" id="idm45983620619384"/>It can be said that manageability and maintainability have some “mission overlap” in that they’re both concerned with the ease with which a system can be modified. But where they differ somewhat is exactly <em>how</em> the system is modified:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Manageability</em> describes the ease with which changes can be made to the behavior of a system, typically without having to resort to changing its code. In other words, it’s how easy it is to change to a system <em>from the outside</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Maintainability</em> describes the ease with which a software system or component can be modified to change or add capabilities, correct faults or defects, or improve performance,<sup><a data-type="noteref" id="idm45983620614104-marker" href="ch10.xhtml#idm45983620614104">4</a></sup> usually by making changes to the code. In other words, it’s how easy it is to change a system <em>from the inside</em>.<a data-type="indexterm" data-primary="maintainability" id="idm45983620611496"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="What Is Manageability and Why Should I Care?"><div class="sect1" id="idm45983620610248">&#13;
<h1>What Is Manageability and Why Should I Care?</h1>&#13;
&#13;
<p>When considering manageability, it’s common to think in terms of a single service. Can my service be configured easily? Does it have all the knobs and dials that it might need?</p>&#13;
&#13;
<p>However, this misses the larger point by focusing on the component at the expense of the system. Manageability doesn’t end at the service boundary. For a system to be manageable, the entire system has to be considered.</p>&#13;
&#13;
<p>Take a moment to reconsider manageability with a complex system in mind. Can its behavior be easily modified? Can its components be modified independently of one another? Can they be easily replaced, if necessary? How do we know when that is?</p>&#13;
&#13;
<p>Manageability encompasses all possible dimensions of a system’s behavior. Its functions can be said to fall into four broad categories:<sup><a data-type="noteref" id="idm45983620606648-marker" href="ch10.xhtml#idm45983620606648">5</a></sup></p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="manageability" data-secondary="categories of" data-seealso="configuration" id="idm45983620603640"/><a data-type="indexterm" data-primary="configuration" id="idm45983620602392"/>Configuration and control</dt>&#13;
<dd>&#13;
<p>It’s important that setting up and configuring a system—and each of its components—should be easily configurable for optimal availability and performance. Some systems need regular or real-time control, so having the right “knobs and levers” is absolutely fundamental. This is where we’ll focus most of our attention in this chapter.</p>&#13;
</dd>&#13;
<dt>Monitoring, logging, and alerting</dt>&#13;
<dd>&#13;
<p>These functions keep track of the system’s ability to do its job, and are critical to effective system management. After all, without them, how would we know when our system requires management? As vital as these features are to manageability, we won’t discuss them in this chapter. Instead, they get an entire chapter of their own in <a data-xrefstyle="chap-num-title" data-type="xref" href="ch11.xhtml#chapter_11">Chapter 11, <em>Observability</em></a>.</p>&#13;
</dd>&#13;
<dt>Deployment and updates</dt>&#13;
<dd>&#13;
<p>Even in the absence of code changes, the ability to easily deploy, update, roll back, and scale system components is valuable, especially when there are many systems to manage. Obviously, this is useful during the initial deployment, but it comes into effect throughout a system’s lifetime any time it has to be updated. Fortunately, its lack of external runtimes and singular executable artifacts make this an area in which Go excels.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="service discovery" id="idm45983620595400"/>Service discovery and inventory</dt>&#13;
<dd>&#13;
<p>A key feature of cloud native systems is their distributed nature. It’s critical that components be able to quickly and accurately detect one another, a function called <em>service discovery</em>. Since service discovery is an architectural feature rather than a programmatic one, we won’t go too deeply into it in this book.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Because this is more of a Go book than it is an architecture book,<sup><a data-type="noteref" id="idm45983620592520-marker" href="ch10.xhtml#idm45983620592520">6</a></sup> it focuses largely on service implementations. For that reason only—<em>not because it’s more important</em>—most of this chapter will similarly focus on service-level configuration. Unfortunately, an in-depth discussion of these is beyond the scope of this book.<sup><a data-type="noteref" id="idm45983620591208-marker" href="ch10.xhtml#idm45983620591208">7</a></sup></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="reliability" id="idm45983620590424"/><a data-type="indexterm" data-primary="availability" id="idm45983620589720"/><a data-type="indexterm" data-primary="security" id="idm45983620589048"/><a data-type="indexterm" data-primary="dependability" id="idm45983620588376"/>Managing complex computing systems is generally difficult and time-consuming, and the costs of managing them can far exceed the costs of the underlying hardware and software. By definition, a system designed to be manageable can be managed more efficiently, and therefore more cheaply. Even if you don’t consider management costs, complexity reduction can have a huge impact on the likelihood of human &#13;
<span class="keep-together">error, making</span> it easier and faster to undo when it inevitably creeps in. In that way, &#13;
<span class="keep-together">manageability</span> directly impacts reliability, availability, and security, making it a key ingredient of system dependability.<a data-type="indexterm" data-primary="manageability" data-secondary="definition of" data-startref="ch10_term1" id="idm45983620585688"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Configuring Your Application"><div class="sect1" id="section_ch10_configuration">&#13;
<h1>Configuring Your Application</h1>&#13;
&#13;
<p>The most basic function of manageability is the ability to configure an application. In an ideally configurable application, anything that’s likely to vary between environments—staging, production, developer environments, etc.—will be cleanly separated from the code and be externally definable in some way.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Twelve-Factor App" id="idm45983620581736"/>You may recall that <em>The Twelve-Factor App</em>—a set of twelve rules and guidelines for building web applications that we introduced way back in <a data-type="xref" href="ch06.xhtml#chapter_6">Chapter 6</a>—had quite a bit to say on this subject. In fact, the third of its twelve rules—<a data-type="xref" href="ch06.xhtml#section_ch06_12_factor_app_configuration">“III. Configuration”</a>—was concerned entirely with application configuration, about which &#13;
<span class="keep-together">it says:</span></p>&#13;
<blockquote>&#13;
<p>Store configuration in the environment.</p></blockquote>&#13;
&#13;
<p><a data-type="indexterm" data-primary="configuration" id="ch10_term2"/>As written, <em>The Twelve-Factor App</em> insists that all configurations should be stored in environment variables. There are a plenty of opinions on this, but in the years since its publication the industry seems to have reached a general consensus that what really matters is:</p>&#13;
<dl>&#13;
<dt>Configuration should be strictly separated from the code</dt>&#13;
<dd>&#13;
<p>Configuration—anything that’s likely to vary between environments—should always be cleanly separated from the code. While configuration can vary substantially across deploys, code does not. Configuration shouldn’t be baked into the code. Ever.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Kubernetes" data-secondary="features of" id="idm45983620573208"/>Configurations should be stored in version control</dt>&#13;
<dd>&#13;
<p>Storing configurations in version control—separately from the code—allows you to quickly roll back a configuration change if necessary, and aids system re-creation and restoration. Some deployment frameworks, like Kubernetes, make this distinction naturally and relatively seamless by providing configuration primitives like the ConfigMap.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These days, it’s still quite common to see applications configured mainly by environment variables, but it’s just as common to see command-line flags and configuration files with various formats. Sometimes an application will even support more than one of these options. In the subsequent sections, we’ll review some of these methods, their various pros and cons, and how they can be implemented in Go.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Configuration Good Practice"><div class="sect2" id="section_ch10_good_practice">&#13;
<h2>Configuration Good Practice</h2>&#13;
&#13;
<p>When you’re building an application, you have a lot of options in how you define, implement, and deploy your application configurations. However, in my experience, I’ve found that certain general practices produce better long- and short-term &#13;
<span class="keep-together">outcomes</span>:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="version control" id="idm45983620566088"/>Version control your configurations</dt>&#13;
<dd>&#13;
<p>Yes, I’m repeating myself, but this bears repeating. Configuration files should be stored in version control before being deployed to the system. This makes it possible to review them before deployment, to quickly reference them afterwards, and to quickly roll back a change if necessary. It’s also helpful if (and when) you need to re-create and restore your system.</p>&#13;
</dd>&#13;
<dt>Don’t roll your own format</dt>&#13;
<dd>&#13;
<p>Write your configuration files using a standard format like JSON, YAML, or TOML. We’ll cover some of these later in the chapter. If you <em>must</em> roll your own format, be sure that you’re comfortable with the idea of maintaining it—and forcing any future maintainers to deal with it—forever.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Go" data-secondary="proverbs" id="idm45983620561672"/>Make the zero value useful</dt>&#13;
<dd>&#13;
<p>Don’t use nonzero default values unnecessarily. This is actually a good rule in general; there’s even a “Go proverb” about it.<sup><a data-type="noteref" id="idm45983620384056-marker" href="ch10.xhtml#idm45983620384056">8</a></sup> Whenever possible, the behavior that results from an undefined configuration should be acceptable, reasonable, and unsurprising. A simple, minimal configuration makes errors less likely.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Configuring with Environment Variables"><div class="sect2" id="idm45983620381544">&#13;
<h2>Configuring with Environment Variables</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="environment variable" data-secondary="uses of" id="idm45983620380200"/>As we discussed in <a data-type="xref" href="ch06.xhtml#chapter_6">Chapter 6</a>, and reviewed previously, using environment variables to define configuration values is the method advocated for in <em>The Twelve-Factor App</em>. There’s some merit to this preference: environment variables are universally supported, they ensure that configurations don’t get accidentally checked into the code, and using them generally requires less code than using a configuration file. They’re also perfectly adequate for small applications.</p>&#13;
&#13;
<p>On the other hand, the process of setting and passing environment variables can be ugly, tedious, and verbose. While some applications support defining environment variables in a file, this largely defeats the purpose of using environment variables in the first place.</p>&#13;
&#13;
<p>The implicit nature of environment variables can introduce some challenges as well. Since you can’t easily learn about the existence and behavior of environment &#13;
<span class="keep-together">variables</span> by looking at an existing configuration file or checking the help output, applications that reply on them can sometimes be harder to use, and errors in them harder to debug.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="environment variable" data-secondary="Go and" id="idm45983620374968"/>As with most high-level languages, Go makes environment variables easily accessible. It does this through the standard <code>os</code> package, which provides the <code>os.Getenv</code> function for this purpose:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">name</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"NAME"</code><code class="p">)</code>&#13;
<code class="nx">place</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"CITY"</code><code class="p">)</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%s lives in %s.\n"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">place</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="os.Getenv function" id="idm45983620352456"/><a data-type="indexterm" data-primary="os.LookEnv function" id="idm45983620338792"/>The <code>os.Getenv</code> function retrieves the value of the environment variable named by the key, but if the variable isn’t present, it’ll return an empty string. If you need to distinguish between an empty value and an unset value, Go also provides the <code>os.LookEnv</code> function, which returns both the value and a <code>bool</code> that’s <code>false</code> if the variable isn’t set:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">if</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">LookupEnv</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code> <code class="nx">ok</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%s=%s\n"</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">val</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"%s not set\n"</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This functionality is pretty minimal, but perfectly adequate for many (if not most) purposes. If you’re in need of more sophisticated options, like default values or typed variables, there are several excellent third-party packages that provide this functionality. <a href="https://oreil.ly/bS4RY">Viper (spf13/viper)</a>—which we’ll discuss in <a data-type="xref" href="#section_ch10_viper">“Viper: The Swiss Army Knife of Configuration Packages”</a>—is particularly popular.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Configuring with Command-Line Arguments"><div class="sect2" id="idm45983620276952">&#13;
<h2>Configuring with Command-Line Arguments</h2>&#13;
&#13;
<p>As configuration methods go, command-line arguments are definitely worth considering, at least for smaller, less-complex applications. After all, they’re explicit, and details of their existence and usage are usually available via a <code>--help</code> option.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The standard flag package"><div class="sect3" id="section_ch10_flags_package">&#13;
<h3>The standard flag package</h3>&#13;
&#13;
<p>Go includes the <code>flag</code> package, which is a basic command-line parsing package, in its standard library. While <code>flag</code> isn’t particularly feature-rich, it’s fairly straightforward to use, and—unlike <code>os.Getenv</code>—supports typing out-of-the-box.</p>&#13;
&#13;
<p>Take, for example, the following program, which uses <code>flag</code> to implement a basic command that reads and outputs the values of command-line flags:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"flag"</code>&#13;
    <code class="s">"fmt"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Declare a string flag with a default value "foo"</code>&#13;
    <code class="c1">// and a short description. It returns a string pointer.</code>&#13;
    <code class="nx">strp</code> <code class="o">:=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"string"</code><code class="p">,</code> <code class="s">"foo"</code><code class="p">,</code> <code class="s">"a string"</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Declare number and Boolean flags, similar to the string flag.</code>&#13;
    <code class="nx">intp</code> <code class="o">:=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"number"</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="s">"an integer"</code><code class="p">)</code>&#13;
    <code class="nx">boolp</code> <code class="o">:=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">Bool</code><code class="p">(</code><code class="s">"boolean"</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s">"a boolean"</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Call flag.Parse() to execute command-line parsing.</code>&#13;
    <code class="nx">flag</code><code class="p">.</code><code class="nx">Parse</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Print the parsed options and trailing positional arguments.</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"string:"</code><code class="p">,</code> <code class="o">*</code><code class="nx">strp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"integer:"</code><code class="p">,</code> <code class="o">*</code><code class="nx">intp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"boolean:"</code><code class="p">,</code> <code class="o">*</code><code class="nx">boolp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"args:"</code><code class="p">,</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">Args</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see from the previous code, the <code>flag</code> package allows you to register command-line flags with types, default values, and short descriptions, and to map those flags to variables. We can see a summary of these flags by running the program and passing it the <code>-help</code> flag:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . -help&#13;
Usage of /var/folders/go-build618108403/exe/main:&#13;
  -boolean&#13;
        a boolean&#13;
  -number int&#13;
        an integer (default 42)&#13;
  -string string&#13;
        a string (default "foo")</pre>&#13;
&#13;
<p>The help output presents us with a list of all of the available flags. Exercising all of these flags gives us something like the following:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . -boolean -number 27 -string "A string." Other things.&#13;
string: A string.&#13;
integer: 27&#13;
boolean: true&#13;
args: [Other things.]</pre>&#13;
&#13;
<p>It works! However, the <code>flag</code> package seems to have a couple of issues that limit its usefulness.</p>&#13;
&#13;
<p>First, as you may have noticed, the resulting flag syntax seems a little…nonstandard. Many of us have come to expect command-line interfaces to follow <a href="https://oreil.ly/evqk4">the GNU argument standard,</a> with long-named options prefixed by two dashes (<code>--version</code>) and short, single-letter equivalents (<code>-v</code>).</p>&#13;
&#13;
<p>Second, all <code>flag</code> does is parse flags (though to be fair, it doesn’t claim to do any more than that), and while that’s nice, it’s not as powerful as it could be. It sure would be nice if we could map commands to functions, wouldn’t it?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The Cobra command-line parser"><div class="sect3" id="section_ch10_cobra">&#13;
<h3>The Cobra command-line parser</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Kubernetes" data-secondary="features of" id="idm45983620118360"/><a data-type="indexterm" data-primary="CockroachDB" id="idm45983620117160"/><a data-type="indexterm" data-primary="Docker" id="idm45983620116488"/><a data-type="indexterm" data-primary="Istio" id="idm45983620115816"/><a data-type="indexterm" data-primary="Helm" id="idm45983620115144"/><a data-type="indexterm" data-primary="Cobra package" id="ch10_term3"/>The <code>flags</code> package is perfectly fine if all you need to do is parse flags, but if you’re in the market for something a little more powerful to build your command-line interfaces, you might want to consider <a href="https://oreil.ly/4oCyH">the Cobra package</a>. Cobra has a number of features that make it a popular choice for building fully featured command-line interfaces. It’s used in a number of high-profile projects, including Kubernetes, CockroachDB, Docker, Istio, and Helm.</p>&#13;
&#13;
<p>In addition to providing fully POSIX-compliant flags (short <em>and</em> long versions), Cobra also supports nested subcommands, and automatically generates help (<code>--help</code>) output and autocomplete for various shells. It also integrates with Viper, which we’ll cover in <a data-type="xref" href="#section_ch10_viper">“Viper: The Swiss Army Knife of Configuration Packages”</a>.</p>&#13;
&#13;
<p>Cobra’s primary downside, as you might imagine, is that it’s quite complex relative to the <code>flags</code> package. Using Cobra to implement the program from <a data-type="xref" href="#section_ch10_flags_package">“The standard flag package”</a> looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
    <code class="s">"os"</code>&#13;
    <code class="s">"github.com/spf13/cobra"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">var</code> <code class="nx">strp</code> <code class="kt">string</code>&#13;
<code class="kd">var</code> <code class="nx">intp</code> <code class="kt">int</code>&#13;
<code class="kd">var</code> <code class="nx">boolp</code> <code class="kt">bool</code>&#13;
&#13;
<code class="kd">var</code> <code class="nx">rootCmd</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">{</code>&#13;
    <code class="nx">Use</code><code class="p">:</code>  <code class="s">"flags"</code><code class="p">,</code>&#13;
    <code class="nx">Long</code><code class="p">:</code> <code class="s">"A simple flags experimentation command, built with Cobra."</code><code class="p">,</code>&#13;
    <code class="nx">Run</code><code class="p">:</code>  <code class="nx">flagsFunc</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">StringVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">strp</code><code class="p">,</code> <code class="s">"string"</code><code class="p">,</code> <code class="s">"s"</code><code class="p">,</code> <code class="s">"foo"</code><code class="p">,</code> <code class="s">"a string"</code><code class="p">)</code>&#13;
    <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">IntVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">intp</code><code class="p">,</code> <code class="s">"number"</code><code class="p">,</code> <code class="s">"n"</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="s">"an integer"</code><code class="p">)</code>&#13;
    <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">BoolVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">boolp</code><code class="p">,</code> <code class="s">"boolean"</code><code class="p">,</code> <code class="s">"b"</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s">"a boolean"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">flagsFunc</code><code class="p">(</code><code class="nx">cmd</code> <code class="o">*</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">,</code> <code class="nx">args</code> <code class="p">[]</code><code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"string:"</code><code class="p">,</code> <code class="nx">strp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"integer:"</code><code class="p">,</code> <code class="nx">intp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"boolean:"</code><code class="p">,</code> <code class="nx">boolp</code><code class="p">)</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"args:"</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Execute</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
        <code class="nx">os</code><code class="p">.</code><code class="nx">Exit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In contrast to the <code>flags</code>-package version, which basically just reads some flags and prints the results, the Cobra program has a bit more complexity, with several distinct parts.</p>&#13;
&#13;
<p>First, we declare the target variables with package scope, rather than locally within a function. This is necessary because they have to be accessible to both the <code>init</code> function and the function that implements the command logic proper.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="root command" id="idm45983620103304"/>Next, we create a <code>cobra.Command</code> struct, <code>rootCmd</code>, that represents the <em>root command</em>. A separate <code>cobra.Command</code> instance is used to represent every command and subcommand that the CLI makes available. The <code>Use</code> field spells out the command’s one-line usage message and <code>Long</code> is the long message displayed in the help output. <code>Run</code> is a function of type <code>func(cmd *Command, args []string)</code> that implements the actual work to be done when the command is executed.</p>&#13;
&#13;
<p>Typically, commands are constructed in an <code>init</code> function. In our case, we add three flags—<code>string</code>, <code>number</code>, and <code>boolean</code>—to our root command along with their short flags, default values, and descriptions.</p>&#13;
&#13;
<p>Every command gets an automatically generated help output, which we can retrieve using the <code>--help</code> flag:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . --help&#13;
A simple flags experimentation command, built with Cobra.&#13;
&#13;
Usage:&#13;
  flags [flags]&#13;
&#13;
Flags:&#13;
  -b, --boolean         a boolean&#13;
  -h, --help            help for flags&#13;
  -n, --number int      an integer (default 42)&#13;
  -s, --string string   a string (default "foo")</pre>&#13;
&#13;
<p>This makes sense, and it’s also pretty! But does it run as we expect? Executing the command (using the standard flags style), gives us the following output:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . --boolean --number 27 --string "A string." Other things.&#13;
string: A string.&#13;
integer: 27&#13;
boolean: true&#13;
args: [Other things.]</pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="subcommands" id="idm45983619906424"/>The outputs are identical; we have achieved parity. But this is just a single command. One of the benefits of Cobra is that it also allows <em>subcommands</em>.</p>&#13;
&#13;
<p>What does this mean? Take, for example, the <code>git</code> command. In this example, <code>git</code> would be the root command. By itself, it doesn’t do much, but it has a series of subcommands—<code>git clone</code>, <code>git init</code>, <code>git blame</code>, etc.—that are related but are each distinct operations of their own.</p>&#13;
&#13;
<p>Cobra provides this capability by treating commands as a tree structure. Each command and subcommand (including the root command) are represented by a distinct <code>cobra.Command</code> value. These are attached to one another using the <code>(c *Command) AddCommand(cmds ...*Command)</code> function. We demonstrate this in the following example by turning the <code>flags</code> command into a subcommand of a new root, which we call <code>cng</code> (for <em>Cloud Native Go</em>).</p>&#13;
&#13;
<p>To do this, we first have to rename the original <code>rootCmd</code> to <code>flagsCmd</code>. We add a <code>Short</code> attribute to define its short description in help output, but it’s otherwise identical. But now we need a new root command, so we create that as well:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">flagsCmd</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">{</code>&#13;
    <code class="nx">Use</code><code class="p">:</code>   <code class="s">"flags"</code><code class="p">,</code>&#13;
    <code class="nx">Short</code><code class="p">:</code> <code class="s">"Experiment with flags"</code><code class="p">,</code>&#13;
    <code class="nx">Long</code><code class="p">:</code>  <code class="s">"A simple flags experimentation command, built with Cobra."</code><code class="p">,</code>&#13;
    <code class="nx">Run</code><code class="p">:</code>   <code class="nx">flagsFunc</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">var</code> <code class="nx">rootCmd</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">{</code>&#13;
    <code class="nx">Use</code><code class="p">:</code>  <code class="s">"cng"</code><code class="p">,</code>&#13;
    <code class="nx">Long</code><code class="p">:</code> <code class="s">"A super simple command."</code><code class="p">,</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we have two commands: the root command, <code>cng</code>, and a single subcommand, <code>flags</code>. The next step is to add the <code>flags</code> subcommand to the root command so that it’s immediately beneath the root in the command tree. This is typically done in an <code>init</code> function, which we demonstrate here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">flagsCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">StringVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">strp</code><code class="p">,</code> <code class="s">"string"</code><code class="p">,</code> <code class="s">"s"</code><code class="p">,</code> <code class="s">"foo"</code><code class="p">,</code> <code class="s">"a string"</code><code class="p">)</code>&#13;
    <code class="nx">flagsCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">IntVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">intp</code><code class="p">,</code> <code class="s">"number"</code><code class="p">,</code> <code class="s">"n"</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="s">"an integer"</code><code class="p">)</code>&#13;
    <code class="nx">flagsCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">BoolVarP</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">boolp</code><code class="p">,</code> <code class="s">"boolean"</code><code class="p">,</code> <code class="s">"b"</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="s">"a boolean"</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">AddCommand</code><code class="p">(</code><code class="nx">flagsCmd</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding <code>init</code> function, we keep the three <code>Flags</code> methods, except we now call them on <code>flagsCmd</code>.</p>&#13;
&#13;
<p>What’s new, however, is the <code>AddCommand</code> method, which allows us to add <code>flagsCmd</code> to <code>rootCmd</code> as a subcommand. We can repeat <code>AddCommand</code> as many times as we like with multiple <code>Command</code> values, adding as many subcommands (or sub-subcommands, or sub-sub-subcommands) as we want.</p>&#13;
&#13;
<p>Now that we’ve told Cobra about the new <code>flags</code> subcommand, its information is reflected in the generated help output:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . --help&#13;
A super simple command.&#13;
&#13;
Usage:&#13;
  cng [command]&#13;
&#13;
Available Commands:&#13;
  flags       Experiment with flags&#13;
  help        Help about any command&#13;
&#13;
Flags:&#13;
  -h, --help   help for cng&#13;
&#13;
Use "cng [command] --help" for more information about a command.</pre>&#13;
&#13;
<p>Now, according to this help output, we have a top-level root command named <code>cng</code> that has <em>two</em> available subcommands: our <code>flags</code> command, and an automatically-generated <code>help</code> subcommand that lets a user view any subcommand’s help. For example, <code>help flags</code> provides us with information and instructions for the <code>flags</code> subcommand:</p>&#13;
&#13;
<pre data-type="programlisting">$ go run . help flags&#13;
A simple flags experimentation command, built with Cobra.&#13;
&#13;
Usage:&#13;
  cng flags [flags]&#13;
&#13;
Flags:&#13;
  -b, --boolean         a boolean&#13;
  -h, --help            help for flags&#13;
  -n, --number int      an integer (default 42)&#13;
  -s, --string string   a string (default "foo")</pre>&#13;
&#13;
<p>Kind of neat, huh?</p>&#13;
&#13;
<p>This is a tiny, tiny sample of what the Cobra library is capable of, but it’s more than sufficient to let us to build a robust set of configuration options. If you’re interested in learning more about Cobra and how you can use it to build powerful command-line interfaces, take a look at its <a href="https://oreil.ly/oy7EN">GitHub repository</a> and its <a href="https://oreil.ly/JOeoJ">listing on GoDoc</a>.<a data-type="indexterm" data-primary="Cobra package" data-startref="ch10_term3" id="idm45983619694344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Configuring with Files"><div class="sect2" id="idm45983620118920">&#13;
<h2>Configuring with Files</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="configuration files" id="ch10_term4"/>Last but not least, we have what is probably the most commonly used configuration option: the configuration file.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="environment variable" data-secondary="configuration files and" id="idm45983619690568"/>Configuration files have a lot of advantages over environment variables, particularly for more complex applications. They tend to be more explicit and comprehensible by allowing behaviors to be logically grouped and annotated. Often, understanding how to use a configuration file is just a matter of looking at its structure or an example of its use.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="command-line flags" id="idm45983619688840"/>Configuration files are particularly useful when managing a large number of options, which is an advantage they have over both environment variables and command-line flags. Command-line flags in particular can sometimes result in some pretty long statements that can be tedious and difficult to construct.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="etcd" id="idm45983619687432"/><a data-type="indexterm" data-primary="HashiCorp Consul" id="idm45983619686728"/>Files aren’t the perfect solution though. Depending on your environment, distributing them at scale in a way that maintains parity across a cluster can be a challenge. This situation can be improved by having a single “source of truth,” such as a distributed key/value store like etcd or HashiCorp Consul, or a central source code repository from which the deployment automatically draws its configuration, but this adds complexity and a dependency on another resource.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Kubernetes" data-secondary="applications for" id="idm45983619685176"/>Fortunately, most orchestration platforms provide specialized configuration resources—such as Kubernetes’ <code>ConfigMap</code> object—that largely alleviate the distribution problem.</p>&#13;
&#13;
<p>There are probably dozens of file formats that have been used for configuration over the years, but in recent years, two in particular have stood out: JSON and YAML. In the next few sections, we’ll go into each of these—and how to use them in Go—in a little more detail</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our configuration data structure"><div class="sect3" id="section_ch10_config_data_structure">&#13;
<h3>Our configuration data structure</h3>&#13;
&#13;
<p>Before we proceed with a discussion of file formats and how to decode them, we should discuss the two general ways in which configurations can be unmarshalled:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Configuration keys and values can be mapped to corresponding fields in a specific struct type. For example, a configuration that contains the attribute <code>host: localhost</code>, could be unmarshalled into a struct type that has a <code>Host string</code> field.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuration data can be decoded and unmarshalled into one or more, possibly nested, maps of type <code>map[string]interface{}</code>. This can be convenient when you’re working with arbitrary configurations, but it’s awkward to work with.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you know what your configuration is likely to look like in advance (which you generally do), then the first approach to decoding configurations, mapping them to a data structure created for that purpose, is by far the easiest. Although it’s possible to decode and do useful work with arbitrary configuration schemas, doing so can be very tedious and isn’t advisable for most configuration purposes.</p>&#13;
&#13;
<p>So, for the remainder of this section, our example configurations will correspond to the following <code>Config</code> struct:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Config</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Host</code> <code class="kt">string</code>&#13;
    <code class="nx">Port</code> <code class="kt">uint16</code>&#13;
    <code class="nx">Tags</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><a data-type="indexterm" data-primary="structs" id="idm45983619577112"/>For a struct field to be marshallable or unmarshallable by <em>any</em> encoding package, it <em>must</em> begin with a capital letter to indicate that it’s exported by its package.</p>&#13;
</div>&#13;
&#13;
<p>For each of our examples we’ll start with the <code>Config</code> struct, occasionally enhancing it with format-specific tags or other decorations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with JSON"><div class="sect3" id="idm45983619574360">&#13;
<h3>Working with JSON</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="JavaScript Object Notation" data-see="JSON" id="idm45983619572920"/><a data-type="indexterm" data-primary="JSON" id="ch10_term5"/><a data-type="indexterm" data-primary="JavaScript" id="idm45983619571032"/>JSON (JavaScript Object Notation) was invented in the early 2000s, growing out of the need for a modern data interchange format to replace XML and other formats in use at the time. It’s based on a subset of the JavaScript scripting language, making it both relatively human-readable and efficient for machines to generate and parse, while also offering the semantics for lists and mappings that were absent from XML.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="YAML" id="idm45983619655592"/>As common and successful as JSON is, it does have some drawbacks. It’s generally considered less user-friendly than YAML. Its syntax is especially unforgiving and can be easily broken by a misplaced (or missing) comma, and it doesn’t even support comments.</p>&#13;
&#13;
<p>However, of the formats presented in this chapter, it’s the only one that’s supported in Go’s standard library.</p>&#13;
&#13;
<p>What follows is a very brief introduction into encoding and decoding data to and from JSON. For a somewhat more thorough review, take a look at Andrew Gerrand’s “JSON and Go” on <a href="https://oreil.ly/6Uvl2"><em>The Go Blog</em></a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" class="pagebreak-before less_space" data-pdf-bookmark="Encoding JSON"><div class="sect4" id="section_ch10_encoding_json">&#13;
<h4>Encoding JSON</h4>&#13;
&#13;
<p>The first step to understanding how to decode JSON (or any configuration format) is understanding how to <em>encode</em> it. This may seem strange, particularly in a section about reading configuration files, but encoding is important to the general subject of JSON encoding, and provides a handy means of generating, testing, and debugging your configuration files.<sup><a data-type="noteref" id="idm45983619649368-marker" href="ch10.xhtml#idm45983619649368">9</a></sup></p>&#13;
&#13;
<p>JSON encoding and decoding is supported by Go’s standard <code>encoding/json</code> package, which provides a variety of helper functions useful for encoding, decoding, formatting, validating, and otherwise working with JSON.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="json.Marshal function" id="ch10_term6"/>Among these is the <code>json.Marshal</code> function, which accepts an <code>interface{}</code> value <code>v</code>, and returns a <code>[]byte</code> array containing a JSON-encoded representation of <code>v</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Marshal</code><code class="p">(</code><code class="nx">v</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">([]</code><code class="kt">byte</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>In other words, a value goes in, and JSON comes out.</p>&#13;
&#13;
<p>This function really is as straightforward to use as it looks. For example, if we have an instance of <code>Config</code>, we can pass it to <code>json.Marshal</code> to get its JSON encoding:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">c</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{</code>&#13;
    <code class="nx">Host</code><code class="p">:</code> <code class="s">"localhost"</code><code class="p">,</code>&#13;
    <code class="nx">Port</code><code class="p">:</code> <code class="mi">1313</code><code class="p">,</code>&#13;
    <code class="nx">Tags</code><code class="p">:</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code><code class="s">"env"</code><code class="p">:</code> <code class="s">"dev"</code><code class="p">},</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">bytes</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">json</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">bytes</code><code class="p">))</code></pre>&#13;
&#13;
<p>If everything works as expected, <code>err</code> will be <code>nil</code>, and <code>bytes</code> will be a <code>[]byte</code> value containing the JSON. The <code>fmt.Println</code> output will look something like the &#13;
<span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="nt">"Host"</code><code class="p">:</code><code class="s2">"localhost"</code><code class="p">,</code><code class="nt">"Port"</code><code class="p">:</code><code class="mi">1313</code><code class="p">,</code><code class="nt">"Tags"</code><code class="p">:{</code><code class="nt">"env"</code><code class="p">:</code><code class="s2">"dev"</code><code class="p">}}</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>json.Marshal</code> function traverses the value of <code>v</code> recursively, so any internal structs will be encoded as well as nested JSON.</p>&#13;
</div>&#13;
&#13;
<p>That was pretty painless, but if we’re generating a configuration file it sure would be nice if the text was formatted for human consumption. Fortunately, <code>encoding/json</code> also provides the following <code>json.MarshalIndent</code> function, which returns “pretty-printed” JSON:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">MarshalIndent</code><code class="p">(</code><code class="nx">v</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">prefix</code><code class="p">,</code> <code class="nx">indent</code> <code class="kt">string</code><code class="p">)</code> <code class="p">([]</code><code class="kt">byte</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>As you can see, <code>json.MarshalIndent</code> works a lot like <code>json.Marshal</code>, except that also takes <code>prefix</code> and <code>indent</code> strings, as demonstrated here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">bytes</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">json</code><code class="p">.</code><code class="nx">MarshalIndent</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="s">""</code><code class="p">,</code> <code class="s">"   "</code><code class="p">)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">bytes</code><code class="p">))</code></pre>&#13;
&#13;
<p>The preceding snippet prints exactly what we’d hope to see:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code>&#13;
   <code class="nt">"Host"</code><code class="p">:</code> <code class="s2">"localhost"</code><code class="p">,</code>&#13;
   <code class="nt">"Port"</code><code class="p">:</code> <code class="mi">1313</code><code class="p">,</code>&#13;
   <code class="nt">"Tags"</code><code class="p">:</code> <code class="p">{</code>&#13;
      <code class="nt">"env"</code><code class="p">:</code> <code class="s2">"dev"</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The result is prettily printed JSON, formatted for humans like you and me<sup><a data-type="noteref" id="idm45983619331048-marker" href="ch10.xhtml#idm45983619331048">10</a></sup> to read. This is a very useful method for bootstrapping configuration files!<a data-type="indexterm" data-primary="configuration files" data-startref="ch10_term4" id="idm45983619330536"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Decoding JSON"><div class="sect4" id="section_ch10_decoding_json">&#13;
<h4>Decoding JSON</h4>&#13;
&#13;
<p>Now that we know how to encode a data structure into JSON, let’s take a look at how to decode JSON as an existing data structure.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="json.Unmarshal function" id="ch10_term7"/>To do that, we use the conveniently named <code>json.Unmarshal</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">data</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">,</code> <code class="nx">v</code> <code class="kd">interface</code><code class="p">{})</code> <code class="kt">error</code></pre>&#13;
&#13;
<p>The <code>json.Unmarshal</code> function parses the JSON-encoded text contained in the <code>data</code> array and stores the result in the value pointed to by <code>v</code>. Importantly, if <code>v</code> is <code>nil</code> or isn’t a pointer, <code>json.Unmarshal</code> returns an error.</p>&#13;
&#13;
<p>But, what type should <code>v</code> be, exactly? Ideally, it would be a pointer to a data structure whose fields exactly correspond to the JSON structure. While it’s possible to unmarshal arbitrary JSON into an unstructured map, as we’ll discuss in <a data-type="xref" href="#sidebar_ch10_decoding_arbitrary_json">“Decoding Arbitrary JSON”</a>, this really should only be done if you really don’t have any other choice.</p>&#13;
&#13;
<p>As we’ll see, though, if you have a data type that reflects your JSON’s structure, then <code>json.Unmarshal</code> is able to update it directly. To do this, we first have to create an instance where our decoded data will be stored:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">c</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{}</code></pre>&#13;
&#13;
<p>Now that we have our storage value, we can call <code>json.Unmarshal</code>, to which we pass a <code>[]byte</code> that contains our JSON data and a pointer to <code>c</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">bytes</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">`{"Host":"127.0.0.1","Port":1234,"Tags":{"foo":"bar"}}`</code><code class="p">)</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">bytes</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">c</code><code class="p">)</code></pre>&#13;
&#13;
<p>If <code>bytes</code> contains valid JSON, then <code>err</code> will be <code>nil</code> and the data from <code>bytes</code> will be stored in the struct <code>c</code>. Printing the value of <code>c</code> should now provide output like the &#13;
<span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-type="programlisting">{127.0.0.1 1234 map[foo:bar]}</pre>&#13;
&#13;
<p>Neat! But what happens when the structure of the JSON doesn’t exactly match the Go type? Let’s find out:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">c</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{}</code>&#13;
<code class="nx">bytes</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">`{"Host":"127.0.0.1", "Food":"Pizza"}`</code><code class="p">)</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">bytes</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">c</code><code class="p">)</code></pre>&#13;
&#13;
<p>Interestingly, this snippet doesn’t produce an error as you might expect. Instead, <code>c</code> now contains the following values:</p>&#13;
&#13;
<pre data-type="programlisting">{127.0.0.1 0 map[]}</pre>&#13;
&#13;
<p>It would seem that the value of <code>Host</code> was set, but <code>Food</code>, which has no corresponding value in the <code>Config</code> struct, was ignored. As it turns out, <code>json.Unmarshal</code> will only decode the fields that it can find in the target type. This behavior can actually be quite useful if you want to cherry pick a few specific fields out of a big JSON blob.<a data-type="indexterm" data-primary="json.Unmarshal function" data-startref="ch10_term7" id="idm45983619156248"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch10_decoding_arbitrary_json">&#13;
<h5>Decoding Arbitrary JSON</h5>&#13;
<p>As we briefly mentioned in <a data-type="xref" href="#section_ch10_config_data_structure">“Our configuration data structure”</a>, it’s <em>possible</em> to decode and do useful work with arbitrary JSON, but doing so can be pretty tedious and should only be done if you don’t know the structure of your JSON beforehand.</p>&#13;
&#13;
<p>Take, for example, this entirely arbitrary JSON data:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">bytes</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">`{"Foo":"Bar", "Number":1313, "Tags":{"A":"B"}}`</code><code class="p">)</code></pre>&#13;
&#13;
<p>Without knowing this data’s structure ahead of time, we can actually use <code>json.Unmarshal</code> to decode it into an <code>interface{}</code> value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">f</code> <code class="kd">interface</code><code class="p">{}</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">bytes</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">f</code><code class="p">)</code></pre>&#13;
&#13;
<p>Outputting the new value of <code>f</code> with <code>fmt.Println</code> yields an interesting result:</p>&#13;
&#13;
<pre data-type="programlisting">map[Number:1313 Foo:Bar Tags:map[A:B]]</pre>&#13;
&#13;
<p>It would seem that the underlying value of <code>f</code> is now a map whose keys are strings and values are stored as empty interfaces. It’s functionally identical to a value defined as:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">f</code> <code class="o">:=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{}{</code>&#13;
    <code class="s">"Foo"</code><code class="p">:</code>  <code class="s">"Bar"</code><code class="p">,</code>&#13;
    <code class="s">"Number"</code><code class="p">:</code>  <code class="mi">1313</code><code class="p">,</code>&#13;
    <code class="s">"Tags"</code><code class="p">:</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{}{</code><code class="s">"A"</code><code class="p">:</code> <code class="s">"B"</code><code class="p">},</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But even though its underlying value is a <code>map[string]interface{}</code>, <code>f</code> still has a type of <code>interface{}</code>. We’ll need to use a type assertion to access its values:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">m</code> <code class="o">:=</code> <code class="nx">f</code><code class="p">.(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{})</code>&#13;
&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"&lt;%T&gt; %v\n"</code><code class="p">,</code> <code class="nx">m</code><code class="p">,</code> <code class="nx">m</code><code class="p">)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"&lt;%T&gt; %v\n"</code><code class="p">,</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Foo"</code><code class="p">],</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Foo"</code><code class="p">])</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"&lt;%T&gt; %v\n"</code><code class="p">,</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Number"</code><code class="p">],</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Number"</code><code class="p">])</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"&lt;%T&gt; %v\n"</code><code class="p">,</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Tags"</code><code class="p">],</code> <code class="nx">m</code><code class="p">[</code><code class="s">"Tags"</code><code class="p">])</code></pre>&#13;
&#13;
<p>Executing the previous snippet produces the following output:</p>&#13;
&#13;
<pre data-type="programlisting">&lt;map[string]interface {}&gt; map[Number:1313 Foo:Bar Tags:map[A:B]]&#13;
&lt;string&gt; Bar&#13;
&lt;float64&gt; 1313&#13;
&lt;map[string]interface {}&gt; map[A:B]</pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Field formatting with struct field tags"><div class="sect4" id="section_ch10_field_formatting_with_struct_field_tags">&#13;
<h4>Field formatting with struct field tags</h4>&#13;
&#13;
<p>Under the covers, marshalling works by using reflection to examine a value and generate appropriate JSON for its type. For structs, the struct’s field names are directly used as the default JSON keys, and the struct’s field values become the JSON values. Unmarshalling works essentially the same way, except in reverse.</p>&#13;
&#13;
<p>What happens when you marshal a zero-value struct? Well, as it turns out, when you marshal a <code>Config{}</code> value, for example, this is the JSON you get:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="nt">"Host"</code><code class="p">:</code><code class="s2">""</code><code class="p">,</code><code class="nt">"Port"</code><code class="p">:</code><code class="mi">0</code><code class="p">,</code><code class="nt">"Tags"</code><code class="p">:</code><code class="kc">null</code><code class="p">}</code></pre>&#13;
&#13;
<p>This isn’t all that pretty. Or efficient. Is it really necessary to even output the empty values at all?</p>&#13;
&#13;
<p>Similarly, struct fields have to be exported—and therefore capitalized—to be written or read. Does that mean that we’re stuck with uppercase field names?</p>&#13;
&#13;
<p>Fortunately, the answer to both questions is “no.”</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="struct field tags" id="ch10_term8"/>Go supports the use of <em>struct field tags</em>—short strings that appear in a struct after the type declaration of a field—that allow metadata to be added to specific struct fields. Field tags are most commonly used by encoding packages to modify encoding and decoding behavior at the field level.</p>&#13;
&#13;
<p>Go struct field tags are special strings containing one or more keys/values pairs enclosed in backticks, after a field’s type declaration:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">User</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Name</code> <code class="kt">string</code> <code class="s">`example:"name"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the struct’s <code>Name</code> field is tagged with <code>example:"name"</code>. These tags can be accessed using run-time reflection via the <code>reflect</code> package, but their most common use case is to provide encoding and decoding directives.</p>&#13;
&#13;
<p>The <code>encoding/json</code> package supports several such tags. The general format uses the <code>json</code> key in the struct field’s tag, and a value that specifies the name of the field, possibly followed by a comma-separated list of options. The name may be empty in order to specify options without overriding the default field name.</p>&#13;
&#13;
<p>The available options supported by <code>encoding/json</code> are shown here:</p>&#13;
<dl>&#13;
<dt>Customizing JSON keys</dt>&#13;
<dd>&#13;
<p>By default, a struct field will case-sensitively map to a JSON key of the exact same name. A tag overrides this default name by setting the first (or only) value in the tag’s options list.</p>&#13;
&#13;
<p>Example: <code>CustomKey string `json:"custom_key"`</code></p>&#13;
</dd>&#13;
<dt>Omitting empty values</dt>&#13;
<dd>&#13;
<p>By default, a field will always appear in the JSON, even if it’s empty. Using the <code>omitempty</code> option will cause fields to be skipped if they contain a zero-value. Note the leading comma in front of <code>omitempty</code>!</p>&#13;
&#13;
<p>Example: <code>OmitEmpty string `json:",omitempty"`</code></p>&#13;
</dd>&#13;
<dt>Ignoring a field</dt>&#13;
<dd>&#13;
<p>Fields using the <code>-</code> (dash) option always will be completely ignored during encoding and decoding.</p>&#13;
&#13;
<p>Example: <code>IgnoredName string `json:"-"`</code></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>A struct that uses all of the previous tags might look like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Tagged</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// CustomKey will appear in JSON as the key "custom_key".</code>&#13;
    <code class="nx">CustomKey</code>   <code class="kt">string</code> <code class="s">`json:"custom_key"`</code>&#13;
&#13;
    <code class="c1">// OmitEmpty will appear in JSON as "OmitEmpty" (the default),</code>&#13;
    <code class="c1">// but will only be written if it contains a nonzero value.</code>&#13;
    <code class="nx">OmitEmpty</code>   <code class="kt">string</code> <code class="s">`json:",omitempty"`</code>&#13;
&#13;
    <code class="c1">// IgnoredName will always be ignored.</code>&#13;
    <code class="nx">IgnoredName</code> <code class="kt">string</code> <code class="s">`json:"-"`</code>&#13;
&#13;
    <code class="c1">// TwoThings will appear in JSON as the key "two_things",</code>&#13;
    <code class="c1">// but only if it isn't empty.</code>&#13;
    <code class="nx">TwoThings</code>   <code class="kt">string</code> <code class="s">`json:"two_things,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For more information on how how <code>json.Marshal</code> encodes data, take a look at <a href="https://oreil.ly/5QeJ4">the function’s documentation on golang.org</a>.<a data-type="indexterm" data-primary="JSON" data-startref="ch10_term5" id="idm45983618779512"/><a data-type="indexterm" data-primary="json.Marshal function" data-startref="ch10_term6" id="idm45983618778344"/><a data-type="indexterm" data-primary="struct field tags" data-startref="ch10_term8" id="idm45983618777400"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with YAML"><div class="sect3" id="section_ch10_working_with_yaml">&#13;
<h3>Working with YAML</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="YAML" id="ch10_term9"/>YAML (YAML Ain’t Markup Language<sup><a data-type="noteref" id="idm45983618773656-marker" href="ch10.xhtml#idm45983618773656">11</a></sup>) is an extensible file format that’s popular with projects like Kubernetes that depend on complex, hierarchical configurations. It’s highly expressive, though its syntax can also be a bit brittle, and configurations that use it can start to suffer from readability issues as they scale up.</p>&#13;
&#13;
<p>Unlike JSON, which was originally created as a data interchange format, YAML is largely a configuration language at heart. Interestingly, however, YAML 1.2 is a superset of JSON, and the two formats are largely inter-convertible. YAML does have some advantages over JSON though: it can self-reference, it allows embedded block literals, and it supports comments and complex data types.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Canonical" id="idm45983618771624"/><a data-type="indexterm" data-primary="Go-YAML" id="ch10_term10"/>Unlike JSON, YAML isn’t supported in Go’s core libraries. While there are a &#13;
<span class="keep-together">few YAML</span> packages to choose from, the standard choice is <a href="https://oreil.ly/yhERJ">Go-YAML</a>. Version 1 of Go-YAML started in 2014 as an internal project within &#13;
<span class="keep-together">Canonical</span> to port the well-known <code>libyaml</code> C library to Go. As a project, it’s exceptionally mature and well maintained. Its syntax is also conveniently very similar to &#13;
<span class="keep-together"><code>encoding/json</code>.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Encoding YAML"><div class="sect4" id="idm45983618766184">&#13;
<h4>Encoding YAML</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="yaml.Marshal function" id="ch10_term11"/>Using Go-YAML to encode data is a <em>lot</em> like encoding JSON. Exactly like it. In fact, the signatures for both packages’ <code>Marshal</code> functions are identical. Like its <code>encoding/json</code> equivalent, Go-YAML’s <code>yaml.Marshal</code> function also accepts an <code>interface{}</code> value, and returns its YAML encoding as a <code>[]byte</code> value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Marshal</code><code class="p">(</code><code class="nx">v</code> <code class="kd">interface</code><code class="p">{})</code> <code class="p">([]</code><code class="kt">byte</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>Just as we did in <a data-type="xref" href="#section_ch10_encoding_json">“Encoding JSON”</a>, we demonstrate its use by creating an instance of <code>Config</code>, which we pass to <code>yaml.Marshal</code> to get its YAML encoding:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">c</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{</code>&#13;
    <code class="nx">Host</code><code class="p">:</code> <code class="s">"localhost"</code><code class="p">,</code>&#13;
    <code class="nx">Port</code><code class="p">:</code> <code class="mi">1313</code><code class="p">,</code>&#13;
    <code class="nx">Tags</code><code class="p">:</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code><code class="s">"env"</code><code class="p">:</code> <code class="s">"dev"</code><code class="p">},</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">bytes</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">yaml</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">c</code><code class="p">)</code></pre>&#13;
&#13;
<p>Once again, if everything works as expected, <code>err</code> will be <code>nil</code> and <code>bytes</code> will be a <code>[]byte</code> value containing the YAML. Printing the string value of <code>bytes</code> will provide something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">host</code><code class="p">:</code> <code class="l-Scalar-Plain">localhost</code>&#13;
<code class="nt">port</code><code class="p">:</code> <code class="l-Scalar-Plain">1313</code>&#13;
<code class="nt">tags</code><code class="p">:</code>&#13;
  <code class="nt">env</code><code class="p">:</code> <code class="l-Scalar-Plain">dev</code></pre>&#13;
&#13;
<p>Also, just like the version provided by <code>encoding/json</code>, Go-YAML’s <code>Marshal</code> function traverses the value <code>v</code> recursively. Any composite types that it finds—arrays, slices, maps, and structs—will be encoded appropriately and will be present in the output as nested YAML elements.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Decoding YAML"><div class="sect4" id="idm45983618584248">&#13;
<h4>Decoding YAML</h4>&#13;
&#13;
<p>In keeping with the theme we’ve established with the similarity of the <code>Marshal</code> functions from <code>encoding/json</code> and Go-YAML, the same consistency is evident between the two packages’ <code>Unmarshal</code> functions:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">data</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">,</code> <code class="nx">v</code> <code class="kd">interface</code><code class="p">{})</code> <code class="kt">error</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="yaml.Unmarshal function" id="idm45983618620728"/>Again, the <code>yaml.Unmarshal</code> function parses the YAML-encoded data in the <code>data</code> array and stores the result in the value pointed to by <code>v</code>. If <code>v</code> is <code>nil</code> or not a pointer, <code>yaml.Unmarshal</code> returns an error. As shown here, the similarities are very clear:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Caution: Indent this YAML with spaces, not tabs.</code>&#13;
<code class="nx">bytes</code> <code class="o">:=</code> <code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">`</code>&#13;
<code class="s">host: 127.0.0.1</code>&#13;
<code class="s">port: 1234</code>&#13;
<code class="s">tags:</code>&#13;
<code class="s">    foo: bar</code>&#13;
<code class="s">`</code><code class="p">)</code>&#13;
&#13;
<code class="nx">c</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{}</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">yaml</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">bytes</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">c</code><code class="p">)</code></pre>&#13;
&#13;
<p>Just as we did in <a data-type="xref" href="#section_ch10_decoding_json">“Decoding JSON”</a>, we pass <code>yaml.Unmarshal</code> a pointer to a <code>Config</code> instance, whose fields correspond to the fields found in the YAML. Printing the value of <code>c</code> should (once again) provide output like the following:</p>&#13;
&#13;
<pre data-type="programlisting">{127.0.0.1 1234 map[foo:bar]}</pre>&#13;
&#13;
<p>There are other behavioral similarities between <code>encoding/json</code> and Go-YAML:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Both will ignore attributes in a source document that cannot be mapped to the <code>Unmarshal</code> function. Again, this can be useful if you only care about a subset of the document, but it can be a “gotcha,” too: if you forget to export the struct field, <code>Unmarshal</code> will always silently ignore it, and it’ll never get set.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both are capable of unmarshalling arbitrary data by passing an <code>interface{}</code> value to <code>Unmarshal</code>. However, while <code>json.Unmarshal</code> will provide a <code>map[string]interface{}</code>, <code>yaml.Unmarshal</code> will return a <code>map[interface{}]interface{}</code>. A minor difference, but another potential gotcha!</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Struct field tags for YAML"><div class="sect4" id="idm45983618504344">&#13;
<h4>Struct field tags for YAML</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="struct field tags" id="idm45983618502968"/>In addition to the “standard” struct field tags—custom keys, <code>omitempty</code>, and <code>-</code> (dash)—detailed in <a data-type="xref" href="#section_ch10_field_formatting_with_struct_field_tags">“Field formatting with struct field tags”</a>, Go-YAML supports two additional tags particular to YAML marshal formatting:</p>&#13;
<dl>&#13;
<dt>Flow style</dt>&#13;
<dd>&#13;
<p>Fields using the <code>flow</code> option will be marshalled using <a href="https://oreil.ly/zyUpd">the flow style</a>, which can be useful for structs, sequences, and maps.</p>&#13;
&#13;
<p>Example: <code>Flow map[string]string `yaml:"flow"`</code></p>&#13;
</dd>&#13;
<dt>Inlining structs and maps</dt>&#13;
<dd>&#13;
<p>The <code>inline</code> option causes all of a struct or map fields or keys to be processed as if they were part of the outer struct. For maps, keys must not conflict with the keys of other struct fields.</p>&#13;
&#13;
<p>Example: <code>Inline map[string]string `yaml:",inline"`</code></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>A struct that uses both of these options might look like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">TaggedMore</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Flow will be marshalled using a "flow" style</code>&#13;
    <code class="c1">// (useful for structs, sequences and maps).</code>&#13;
    <code class="nx">Flow</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`yaml:"flow"`</code>&#13;
&#13;
    <code class="c1">// Inlines a struct or a map, causing all of its fields</code>&#13;
    <code class="c1">// or keys to be processed as if they were part of the outer</code>&#13;
    <code class="c1">// struct. For maps, keys must not conflict with the yaml</code>&#13;
    <code class="c1">// keys of other struct fields.</code>&#13;
    <code class="nx">Inline</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`yaml:",inline"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the tagging syntax is also consistent, except that instead of using the <code>json</code> prefix, Go-YAML tags use the <code>yaml</code> prefix.<a data-type="indexterm" data-primary="Go-YAML" data-startref="ch10_term10" id="idm45983618436808"/><a data-type="indexterm" data-primary="yaml.Marshal function" data-startref="ch10_term11" id="idm45983618435928"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Watching for configuration file changes"><div class="sect3" id="section_ch10_watching_files">&#13;
<h3>Watching for configuration file changes</h3>&#13;
&#13;
<p>When working with configuration files, you’ll inevitably be confronted with a situation in which changes have to be made to the configuration of a running program. If it doesn’t explicitly watch for and reload changes, then it’ll generally have to be restarted to reread its configuration, which can be inconvenient at best, and introduce downtime at worst.</p>&#13;
&#13;
<p>At some point, you’re going to have to decide how you want your program to respond to such changes.</p>&#13;
&#13;
<p>The first (and least complex) option is to do nothing, and just expect the program to have to restart when its configuration changes. This is actually a fairly common choice, since it ensures that no trace of the former configuration exists. It also allows a program to “fail fast” when an error is introduced into the configuration file: the program just has to spit out an angry error message and refuse to start.</p>&#13;
&#13;
<p>However, you might prefer to add logic to your program that detects changes in your configuration file (or files) and reloads them appropriately.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Making your configuration reloadable"><div class="sect4" id="idm45983618430648">&#13;
<h4>Making your configuration reloadable</h4>&#13;
&#13;
<p>If you’d like your internal configuration representations to reload whenever the underlying file changes, you’ll have to plan a little ahead.</p>&#13;
&#13;
<p>First, you’ll want to have a single global instance of your configuration struct. For now, we’ll use a <code>Config</code> instance of the kind we introduced in <a data-type="xref" href="#section_ch10_config_data_structure">“Our configuration data structure”</a>. In a slightly larger project, you might even put this in a <code>config</code> package:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">config</code> <code class="nx">Config</code></pre>&#13;
&#13;
<p>Very often you’ll see code in which an explicit <code>config</code> parameter is passed to just about every method and function. I’ve seen this quite a lot; often enough to know that this particular antipattern just makes life harder. Also, because the configuration now lives in N places instead of one, it also tends to make configuration reloading more complicated.</p>&#13;
&#13;
<p>Once we have our <code>config</code> value, we’ll want to add the logic that reads the configuration file and loads it into the struct. Something like the following <code>loadConfiguration</code> function will do just fine:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">loadConfiguration</code><code class="p">(</code><code class="nx">filepath</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="nx">Config</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">dat</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">ioutil</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">filepath</code><code class="p">)</code>   <code class="c1">// Ingest file as []byte</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">Config</code><code class="p">{},</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">config</code> <code class="o">:=</code> <code class="nx">Config</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">err</code> <code class="p">=</code> <code class="nx">yaml</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">(</code><code class="nx">dat</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">config</code><code class="p">)</code>      <code class="c1">// Do the unmarshal</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">Config</code><code class="p">{},</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">config</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Our <code>loadConfiguration</code> function works almost the same way that we discussed in <a data-type="xref" href="#section_ch10_working_with_yaml">“Working with YAML”</a>, except that it uses the <code>ioutil.ReadFile</code> function from the <code>io/ioutil</code> standard library to retrieve the bytes that it passes to <code>yaml.Unmarshal</code>. The choice to use YAML here was entirely arbitrary.<sup><a data-type="noteref" id="idm45983618296888-marker" href="ch10.xhtml#idm45983618296888">12</a></sup> The syntax for a JSON configuration would be practically identical.<a data-type="indexterm" data-primary="YAML" data-startref="ch10_term9" id="idm45983618295752"/></p>&#13;
&#13;
<p>Now that we have logic to load our configuration file into a canonical struct, we need something to call it whenever it gets a notification that the file has changed. For that we have <code>startListening</code>, which monitors an <code>updates</code> channel:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">startListening</code><code class="p">(</code><code class="nx">updates</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">errors</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">{</code>&#13;
        <code class="k">select</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="nx">filepath</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">updates</code><code class="p">:</code>&#13;
            <code class="nx">c</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">loadConfiguration</code><code class="p">(</code><code class="nx">filepath</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="nx">log</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error loading config:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
                <code class="k">continue</code>&#13;
            <code class="p">}</code>&#13;
            <code class="nx">config</code> <code class="p">=</code> <code class="nx">c</code>&#13;
&#13;
        <code class="k">case</code> <code class="nx">err</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">errors</code><code class="p">:</code>&#13;
            <code class="nx">log</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error watching config:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, <code>startListening</code> accepts two channels: <code>updates</code>, which emits the name of a file (presumably the configuration file) when that file changes, and an <code>errors</code> channel.</p>&#13;
&#13;
<p>It watches both channels in a <code>select</code> inside of an infinite loop so that if a configuration file changes, the <code>updates</code> channel sends its name, which is then passed to <code>loadConfiguration</code>. If <code>loadConfiguration</code> doesn’t return a non-<code>nil</code> error, then the <code>Config</code> value it returns replaces the current one.</p>&#13;
&#13;
<p>Stepping back another level, we have an <code>init</code> function that retrieves the channels from a <code>watchConfig</code> function and passes them to <code>startListening</code>, which it runs as a goroutine:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">updates</code><code class="p">,</code> <code class="nx">errors</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">watchConfig</code><code class="p">(</code><code class="s">"config.yaml"</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">go</code> <code class="nx">startListening</code><code class="p">(</code><code class="nx">updates</code><code class="p">,</code> <code class="nx">errors</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But what’s this <code>watchConfig</code> function? Well, we don’t quite know the details yet. We’ll figure that out in the next couple of sections. We do know that it implements some configuration watching logic, and that it has a function signature that looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">watchConfig</code><code class="p">(</code><code class="nx">filepath</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="watchConfig function" id="idm45983618141160"/>The <code>watchConfig</code> function, whatever its implementation, returns two channels—a <code>string</code> channel that sends the path of the updated configuration file, and an <code>error</code> channel that notifies about invalid configurations—and an <code>error</code> value that reports if there’s a fatal error on startup.</p>&#13;
&#13;
<p>The exact implementation of <code>watchConfig</code> can go a couple of different ways, each with its pros and cons. Now let’s take a look at the two most common of those.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Polling for configuration changes"><div class="sect4" id="idm45983618146760">&#13;
<h4>Polling for configuration changes</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="polling" id="ch10_term12"/>Polling, where you check for changes in your configuration file on some regular cadence, is a common way of watching a configuration file. A standard implementation uses a <code>time.Ticker</code> to recalculate a hash of your configuration file every few seconds and reload if the hash changes.</p>&#13;
&#13;
<p>Go makes a number of common hash algorithms available in its <code>crypto</code> package, each of which lives in its own subpackage of <code>crypto</code> and satisfies both the <code>crypto.Hash</code> and <code>io.Writer</code> interfaces.</p>&#13;
&#13;
<p>For example, Go’s standard implementation of <code>SHA256</code> can be found in <code>crypto/sha256</code>. To use it, you use its <code>sha256.New</code> function to get a new <code>sha256.Hash</code> value, into which you then write the data you want to calculate the hash of, just as you would any <code>io.Writer</code>. When that’s complete, you use its <code>Sum</code> method to retrieve the resulting hash sum:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">calculateFileHash</code><code class="p">(</code><code class="nx">filepath</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">string</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">file</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">filepath</code><code class="p">)</code>  <code class="c1">// Open the file for reading</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">defer</code> <code class="nx">file</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code>              <code class="c1">// Be sure to close your file!</code>&#13;
&#13;
    <code class="nx">hash</code> <code class="o">:=</code> <code class="nx">sha256</code><code class="p">.</code><code class="nx">New</code><code class="p">()</code>            <code class="c1">// Use the Hash in crypto/sha256</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">io</code><code class="p">.</code><code class="nx">Copy</code><code class="p">(</code><code class="nx">hash</code><code class="p">,</code> <code class="nx">file</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s">""</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">sum</code> <code class="o">:=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%x"</code><code class="p">,</code> <code class="nx">hash</code><code class="p">.</code><code class="nx">Sum</code><code class="p">(</code><code class="kc">nil</code><code class="p">))</code>  <code class="c1">// Get encoded hash sum</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">sum</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Generating a hash for a configuration has three distinct parts. First, we get a <code>[]byte</code> source in the form of an <code>io.Reader</code>. In this example we use an <code>io.File</code>. Next, we copy those bytes from the <code>io.Reader</code> to our <code>sha256.Hash</code> instance, which we do with a call to <code>io.Copy</code>. Finally, we use the <code>Sum</code> method to retrieve the hash sum from <code>hash</code>.</p>&#13;
&#13;
<p>Now that we have our <code>calculateFileHash</code> function, creating our <code>watchConfig</code> implementation is just a matter of using a <code>time.Ticker</code> to concurrently check it on some cadence, and emit any positive results (or errors) to the appropriate channel:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">watchConfig</code><code class="p">(</code><code class="nx">filepath</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">errs</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">changes</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">)</code>&#13;
    <code class="nx">hash</code> <code class="o">:=</code> <code class="s">""</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">ticker</code> <code class="o">:=</code> <code class="nx">time</code><code class="p">.</code><code class="nx">NewTicker</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
&#13;
        <code class="k">for</code> <code class="k">range</code> <code class="nx">ticker</code><code class="p">.</code><code class="nx">C</code> <code class="p">{</code>&#13;
            <code class="nx">newhash</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">calculateFileHash</code><code class="p">(</code><code class="nx">filepath</code><code class="p">)</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="nx">errs</code> <code class="o">&lt;-</code> <code class="nx">err</code>&#13;
                <code class="k">continue</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">if</code> <code class="nx">hash</code> <code class="o">!=</code> <code class="nx">newhash</code> <code class="p">{</code>&#13;
                <code class="nx">hash</code> <code class="p">=</code> <code class="nx">newhash</code>&#13;
                <code class="nx">changes</code> <code class="o">&lt;-</code> <code class="nx">filepath</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">changes</code><code class="p">,</code> <code class="nx">errs</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The polling approach has some benefits. It’s not especially complex, which is always a big plus, and it works for any operating system. Perhaps most interestingly, because hashing only cares about the configuration’s contents, it even can be generalized to detect changes in places like remote key/value stores that aren’t technically files.</p>&#13;
&#13;
<p>Unfortunately, the polling approach can be a little computationally wasteful, especially for very large or many files. By its nature, it also incurs also a brief delay between the time the file is changed and the detection of that change. If you’re definitely working with local files, it would probably be more efficient to watch OS-level filesystem notifications, which we discuss in the next section.<a data-type="indexterm" data-primary="polling" data-startref="ch10_term12" id="idm45983617797016"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Watching OS filesystem notifications"><div class="sect4" id="idm45983617938056">&#13;
<h4>Watching OS filesystem notifications</h4>&#13;
&#13;
<p>Polling for changes works well enough, but this method has some drawbacks. Depending on your use case, you may find it more efficient to instead monitor OS-level filesystem notifications.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="fsnotify package" id="idm45983617794616"/>Actually doing so, however, is complicated by the fact that each operating system has a different notification mechanism. Fortunately, the <a href="https://oreil.ly/ziw4J">fsnotify</a> package provides a workable abstraction that supports most operating systems.</p>&#13;
&#13;
<p>To use this package to watch one or more files, you use the <code>fsnotify.NewWatcher</code> function to get a new <code>fsnotify.Watcher</code> instance, and use the <code>Add</code> method to register more files to watch. The <code>Watcher</code> provides two channels, <code>Events</code> and <code>Errors</code>, which sends notifications of file events and errors, respectively.</p>&#13;
&#13;
<p>For example, if we wanted to watch our config file, we could do something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">watchConfigNotify</code><code class="p">(</code><code class="nx">filepath</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">,</code> <code class="o">&lt;-</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">changes</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">string</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">watcher</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">fsnotify</code><code class="p">.</code><code class="nx">NewWatcher</code><code class="p">()</code>         <code class="c1">// Get an fsnotify.Watcher</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">err</code> <code class="p">=</code> <code class="nx">watcher</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">filepath</code><code class="p">)</code>                    <code class="c1">// Tell watcher to watch</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>                                <code class="c1">// our config file</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">changes</code> <code class="o">&lt;-</code> <code class="nx">filepath</code>                        <code class="c1">// First is ALWAYS a change</code>&#13;
&#13;
        <code class="k">for</code> <code class="nx">event</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">watcher</code><code class="p">.</code><code class="nx">Events</code> <code class="p">{</code>        <code class="c1">// Range over watcher events</code>&#13;
            <code class="k">if</code> <code class="nx">event</code><code class="p">.</code><code class="nx">Op</code><code class="o">&amp;</code><code class="nx">fsnotify</code><code class="p">.</code><code class="nx">Write</code> <code class="o">==</code> <code class="nx">fsnotify</code><code class="p">.</code><code class="nx">Write</code> <code class="p">{</code>&#13;
                <code class="nx">changes</code> <code class="o">&lt;-</code> <code class="nx">event</code><code class="p">.</code><code class="nx">Name</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">changes</code><code class="p">,</code> <code class="nx">watcher</code><code class="p">.</code><code class="nx">Errors</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note the statement <code>event.Op &amp; fsnotify.Write == fsnotify.Write</code>, which uses a bitwise AND (<code>&amp;</code>) to filter for “write” events. We do this because the <code>fsnotify.Event</code> can potentially include multiple operations, each of which is represented as one bit in an unsigned integer. For example, a simultaneous <code>fsnotify.Write</code> (<code>2</code>, binary <code>0b00010</code>) and <code>fsnotify.Chmod</code> (<code>16</code>, binary <code>0b10000</code>) would result in an <code>event.Op</code> value of <code>18</code> (binary <code>0b10010</code>). Because <code>0b10010 &amp; 0b00010 = 0b00010</code>, the bitwise AND allows us to guarantee that an operation includes a <code>fsnotify.Write</code>.</p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Viper: The Swiss Army Knife of Configuration Packages"><div class="sect2" id="section_ch10_viper">&#13;
<h2>Viper: The Swiss Army Knife of Configuration Packages</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Viper" id="ch10_term13"/><a href="https://oreil.ly/pttZM">Viper (spf13/viper)</a> bills itself as a complete configuration solution for Go applications, and justifiably so. Among other things, it allows application configuration by a variety of mechanisms and formats, including, in order of precedence:</p>&#13;
<dl>&#13;
<dt>Explicitly set values</dt>&#13;
<dd>&#13;
<p>This takes precedence over all other methods, and can be useful during testing.</p>&#13;
</dd>&#13;
<dt>Command-line flags</dt>&#13;
<dd>&#13;
<p>Viper is designed to be a companion to Cobra, which we introduced in <a data-type="xref" href="#section_ch10_cobra">“The Cobra command-line parser”</a>.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="environment variable" data-secondary="Viper and" id="idm45983617625240"/>Environment variables</dt>&#13;
<dd>&#13;
<p>Viper has full support for environment variables. Importantly, Viper treats environment variables as case-sensitive!</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="JSON" id="idm45983617622856"/><a data-type="indexterm" data-primary="YAML" id="idm45983617622152"/><a data-type="indexterm" data-primary="TOML" id="idm45983617621480"/><a data-type="indexterm" data-primary="HCL" id="idm45983617620808"/><a data-type="indexterm" data-primary="INI" id="idm45983617620136"/><a data-type="indexterm" data-primary="envfile" id="idm45983617619464"/><a data-type="indexterm" data-primary="Java Properties" id="idm45983617618792"/>Configuration files, in multiple file formats</dt>&#13;
<dd>&#13;
<p>Out of the box, Viper supports JSON and YAML with the packages we introduced previously; as well as TOML, HCL, INI, envfile, and Java Properties files. It can also write configuration files to help bootstrap your configurations, and even optionally supports live watching and rereading of configuration files.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="etcd" id="idm45983617616488"/><a data-type="indexterm" data-primary="Consul" id="idm45983617615784"/>Remote key/value stores</dt>&#13;
<dd>&#13;
<p>Viper can access key/value stores like etcd or Consul, and can watch them for changes.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It also supports features like default values and typed variables, which the standard packages typically don’t provide.</p>&#13;
&#13;
<p>Keep in mind though, that while Viper does <em>a lot</em>, it’s also a pretty big hammer that brings in a lot of dependencies. If you’re trying to build a slim, streamlined application, Viper may be more than you need.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Explicitly setting values in Viper"><div class="sect3" id="section_ch10_viper_explicit_set">&#13;
<h3>Explicitly setting values in Viper</h3>&#13;
&#13;
<p>Viper allows you to use the <code>viper.Set</code> function to explicitly set values from, for example, command-line flags or the application logic. This can be pretty handy during testing:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="s">"Verbose"</code><code class="p">,</code> <code class="kc">true</code><code class="p">)</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">Set</code><code class="p">(</code><code class="s">"LogFile"</code><code class="p">,</code> <code class="nx">LogFile</code><code class="p">)</code></pre>&#13;
&#13;
<p>Explicitly set values have the highest priority, and override values that would be set by other mechanisms.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with command-line flags in Viper"><div class="sect3" id="section_ch10_viper_flags">&#13;
<h3>Working with command-line flags in Viper</h3>&#13;
&#13;
<p>Viper was designed to be a companion to the <a href="https://oreil.ly/67LFI">Cobra library</a>, which we briefly discussed in the context of constructing command-line interfaces in <a data-type="xref" href="#section_ch10_cobra">“The Cobra command-line parser”</a>. This close integration with Cobra makes it straightforward to bind command-line flags to configuration keys.</p>&#13;
&#13;
<p>Viper provides the <code>viper.BindPFlag</code> function, which allows individual command-line flags to be bound to a named key, and <code>viper.BindPFlags</code>, which binds a full flag set using each flag’s long name as the key.</p>&#13;
&#13;
<p>Because the actual value of the configuration value is set when the binding is accessed, rather than when it’s called, you can call <code>viper.BindPFlag</code> in an <code>init</code> function as we do here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">rootCmd</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">cobra</code><code class="p">.</code><code class="nx">Command</code><code class="p">{</code> <code class="cm">/* omitted for brevity */</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">IntP</code><code class="p">(</code><code class="s">"number"</code><code class="p">,</code> <code class="s">"n"</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="s">"an integer"</code><code class="p">)</code>&#13;
    <code class="nx">viper</code><code class="p">.</code><code class="nx">BindPFlag</code><code class="p">(</code><code class="s">"number"</code><code class="p">,</code> <code class="nx">rootCmd</code><code class="p">.</code><code class="nx">Flags</code><code class="p">().</code><code class="nx">Lookup</code><code class="p">(</code><code class="s">"number"</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding snippet, we declare a <code>&amp;cobra.Command</code> and define an integer flag called “number.” Note that we use the <code>IntP</code> method instead of <code>IntVarP</code>, since there’s no need to store the value of the flag in an external value when Cobra is used in this way. Then, using the <code>viper.BindPFlag</code> function, we bind the “number” flag to a configuration key of the same name.</p>&#13;
&#13;
<p>After it’s been bound (and the command-line flags parsed), the value of the bound key can be retrieved from Viper by using the <code>viper.GetInt</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">n</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetInt</code><code class="p">(</code><code class="s">"number"</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with environment variables in Viper"><div class="sect3" id="section_ch10_viper_envvars">&#13;
<h3>Working with environment variables in Viper</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="environment variable" data-secondary="Viper and" id="idm45983617434328"/>Viper provides several functions for working with environment variables as a configuration source. The first of these is <code>viper.BindEnv</code>, which is used to bind a configuration key to an environment variable:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">BindEnv</code><code class="p">(</code><code class="s">"id"</code><code class="p">)</code>                     <code class="c1">// Bind "id" to var "ID"</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">BindEnv</code><code class="p">(</code><code class="s">"port"</code><code class="p">,</code> <code class="s">"SERVICE_PORT"</code><code class="p">)</code>   <code class="c1">// Bind "port" to var "SERVICE_PORT"</code>&#13;
&#13;
<code class="nx">id</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetInt</code><code class="p">(</code><code class="s">"id"</code><code class="p">)</code>&#13;
<code class="nx">id</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetInt</code><code class="p">(</code><code class="s">"port"</code><code class="p">)</code></pre>&#13;
&#13;
<p>If only a key is provided, <code>viper.BindEnv</code> will bind to the environment variable matching the key. More arguments can be provided to specify one or more environment variables to bind to. In both cases, Viper automatically assumes that the name of the environment variable is in all caps.</p>&#13;
&#13;
<p>Viper provides several additional helper functions for working with environment variables. See <a href="https://oreil.ly/CGpPS">the Viper GoDoc</a> for more details on these.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Working with configuration files in Viper"><div class="sect3" id="section_ch10_viper_config_files">&#13;
<h3>Working with configuration files in Viper</h3>&#13;
&#13;
<p>Out of the box, Viper supports JSON and YAML using the packages we introduced previously; as well as TOML, HCL, INI, envfile, and Java Properties files. It can also write configuration files to help bootstrap your configurations, and even optionally supports live watching and rereading of configuration files.</p>&#13;
&#13;
<p>A discussion of local configuration files may seem unexpected in a book on cloud native, but files are still a commonly used structure in any context. After all, shared filesystems—be they Kubernetes ConfigMaps or NFS mounts—are quite common, and even cloud native services can be deployed by a configuration management system that installs a read-only local copy of a file for all service replicas to read. A configuration file could even be baked or mounted into a container image in a way that looks—as far as a containerized service is concerned—exactly like any other local file.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Reading configuration files"><div class="sect4" id="idm45983617347752">&#13;
<h4>Reading configuration files</h4>&#13;
&#13;
<p>To read configurations from files, Viper just needs to know the names of the files, and where to look for them. Also, it needs to know its type, if that can’t be inferred from a file extension. The <code>viper.ReadInConfig</code> function instructs Viper to find and read the configuration file, potentially returning an <code>error</code> value if something goes wrong. All of those steps are demonstrated here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">SetConfigName</code><code class="p">(</code><code class="s">"config"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Optional if the config has a file extension</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">SetConfigType</code><code class="p">(</code><code class="s">"yaml"</code><code class="p">)</code>&#13;
&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">AddConfigPath</code><code class="p">(</code><code class="s">"/etc/service/"</code><code class="p">)</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">AddConfigPath</code><code class="p">(</code><code class="s">"$HOME/.service"</code><code class="p">)</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">AddConfigPath</code><code class="p">(</code><code class="s">"."</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">ReadInConfig</code><code class="p">();</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nb">panic</code><code class="p">(</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"fatal error reading config: %w"</code><code class="p">,</code> <code class="nx">err</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, Viper can search multiple paths for a configuration file. Unfortunately, at this time, a single Viper instance only supports reading a single configuration file.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Watching and rereading configuration files in Viper"><div class="sect4" id="idm45983617261560">&#13;
<h4>Watching and rereading configuration files in Viper</h4>&#13;
&#13;
<p>Viper natively allows your application to watch a configuration file for modifications and reload when changes are detected, which means that configurations can change without having to restart the server for them to take effect.</p>&#13;
&#13;
<p>By default, this functionality is turned off. The <code>viper.WatchConfig</code> function can be used to enable it. Additionally, the <code>viper.OnConfigChange</code> function allows you to specify a function that’s called whenever the configuration file is updated:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">WatchConfig</code><code class="p">()</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">OnConfigChange</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">e</code> <code class="nx">fsnotify</code><code class="p">.</code><code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Config file changed:"</code><code class="p">,</code> <code class="nx">e</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code>&#13;
<code class="p">})</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Make sure that any calls to <code>viper.AddConfigPath</code> are made <em>before</em> calling <code>viper.WatchConfig</code>.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="indexterm" data-primary="fsnotify package" id="idm45983617181544"/>Interestingly, Viper actually uses the <code>fsnotify/fsnotify</code> package behind the scenes, the same mechanism that we detailed in <a data-type="xref" href="#section_ch10_watching_files">“Watching for configuration file changes”</a>.</p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Using remote key/value stores with Viper"><div class="sect3" id="section_ch10_viper_key_value_stores">&#13;
<h3>Using remote key/value stores with Viper</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="etcd" id="idm45983617177592"/><a data-type="indexterm" data-primary="HashiCorp Consul" id="idm45983617176888"/>Perhaps the most interesting feature of Viper is its ability to read a configuration string written in any supported format from a path in a remote key/value store, like <a href="https://etcd.io">etcd</a> or <a href="https://consul.io">HashiCorp Consul</a>. These values take precedence over default values, but are overridden by configuration values retrieved from disk, command-line flags, or environment variables.</p>&#13;
&#13;
<p>To enable remote support in Viper, you first have to do a blank import of the <code>viper/remote</code> package:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="nx">_</code> <code class="s">"github.com/spf13/viper/remote"</code></pre>&#13;
&#13;
<p>A remote key/value configuration source can then be registered using the <code>viper.AddRemoteProvider</code> method, whose signature is as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">AddRemoteProvider</code><code class="p">(</code><code class="nx">provider</code><code class="p">,</code> <code class="nx">endpoint</code><code class="p">,</code> <code class="nx">path</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">error</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>provider</code> parameter can be one of <code>etcd</code>, <code>consul</code>, or <code>firestore</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>endpoint</code> is the URL of the remote resource. An odd quirk of Viper is that the etcd provider requires the URL to include a scheme (<code>http://ip:port</code>), while Consul requires <em>no scheme</em> (ip:port).</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>path</code> is the path in the key-value store to retrieve the configuration from.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To read a JSON-formatted configuration file from an etcd service, for example, you’ll do something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">AddRemoteProvider</code><code class="p">(</code><code class="s">"etcd"</code><code class="p">,</code> <code class="s">"http://127.0.0.1:4001"</code><code class="p">,</code><code class="s">"/config/service.json"</code><code class="p">)</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">SetConfigType</code><code class="p">(</code><code class="s">"json"</code><code class="p">)</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">ReadRemoteConfig</code><code class="p">()</code></pre>&#13;
&#13;
<p>Note that even though the configuration path includes a file extension, we also use <code>viper.SetConfigType</code> to explicitly define the configuration type. This is because from Viper’s perspective, the resource is just a stream of bytes, so it can’t automatically infer the format.<sup><a data-type="noteref" id="idm45983617110392-marker" href="ch10.xhtml#idm45983617110392">13</a></sup> As of the time of writing, the supported formats are <em>json</em>, <em>toml</em>, <em>yaml</em>, <em>yml</em>, <em>properties</em>, <em>props</em>, <em>prop</em>, <em>env</em>, and <em>dotenv</em>.</p>&#13;
&#13;
<p>Multiple providers may be added, in which case they’re searched in the order in which they were added.</p>&#13;
&#13;
<p>This is just a very basic introduction to what Viper can do with remote key/value stores. For more details about how to use Viper to read from Consul, watch for configuration changes, or read encrypted configurations, take a look at <a href="https://oreil.ly/1iE2y">Viper’s README</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Setting defaults in Viper"><div class="sect3" id="section_ch10_viper_defaults">&#13;
<h3>Setting defaults in Viper</h3>&#13;
&#13;
<p>Unlike all of the other packages we reviewed in this chapter, Viper optionally allows default values to be defined for a key, by way of the <code>SetDefault</code> function.</p>&#13;
&#13;
<p>Default values can sometimes be useful, but care should be taken with this functionality. As mentioned in <a data-type="xref" href="#section_ch10_good_practice">“Configuration Good Practice”</a>, useful zero values are generally preferable to implicit defaults, which can lead to surprising behaviors when thoughtlessly applied.<a data-type="indexterm" data-primary="configuration" data-startref="ch10_term2" id="idm45983617059864"/></p>&#13;
&#13;
<p>A snippet of Viper showing default values in action might look like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">viper</code><code class="p">.</code><code class="nx">BindEnv</code><code class="p">(</code><code class="s">"id"</code><code class="p">)</code>             <code class="c1">// Will be upper-cased automatically</code>&#13;
<code class="nx">viper</code><code class="p">.</code><code class="nx">SetDefault</code><code class="p">(</code><code class="s">"id"</code><code class="p">,</code> <code class="s">"13"</code><code class="p">)</code>    <code class="c1">// Default value is "13"</code>&#13;
&#13;
<code class="nx">id1</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetInt</code><code class="p">(</code><code class="s">"id"</code><code class="p">)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">id1</code><code class="p">)</code>                <code class="c1">// 13</code>&#13;
&#13;
<code class="nx">os</code><code class="p">.</code><code class="nx">Setenv</code><code class="p">(</code><code class="s">"ID"</code><code class="p">,</code> <code class="s">"50"</code><code class="p">)</code>           <code class="c1">// Explicitly set the envvar</code>&#13;
&#13;
<code class="nx">id2</code> <code class="o">:=</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetInt</code><code class="p">(</code><code class="s">"id"</code><code class="p">)</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">id2</code><code class="p">)</code>                <code class="c1">// 50</code></pre>&#13;
&#13;
<p>Default values have the lowest priority, and will only take effect if a key isn’t explicitly set by another mechanism.<a data-type="indexterm" data-primary="Viper" data-startref="ch10_term13" id="idm45983617056232"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Feature Management with Feature Flags"><div class="sect1" id="section_ch10_feature_management">&#13;
<h1>Feature Management with Feature Flags</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="feature toggling" data-see="feature flagging" id="idm45983616983288"/><a data-type="indexterm" data-primary="feature flagging" id="ch10_term14"/><em>Feature flagging</em> (or <em>feature toggling</em><sup><a data-type="noteref" id="idm45983616980664-marker" href="ch10.xhtml#idm45983616980664">14</a></sup>) is a software development pattern designed to increase the speed and safety with which new features can be developed and delivered by allowing specific functionality to be turned on or off during runtime, without having to deploy new code.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="configuration" id="idm45983616979224"/>A feature flag is essentially a conditional in your code that enables or disables a feature based on some external criteria, often (but not always) a configuration setting. By setting the configuration to different values, a developer can, for example, choose to enable an incomplete feature for testing and disable it for other users.</p>&#13;
&#13;
<p>Having the ability to release a product with unfinished features provides a number of powerful benefits.</p>&#13;
&#13;
<p>First, feature flags allow many small incremental versions of software to be delivered without the overhead of branching and merging that comes with using feature branches. In other words, feature flags decouple the release of a feature from its deployment. Combined with the fact that feature flags, by their very nature, require code changes to be integrated as early as possible, which both encourages and facilitates continuous deployment and delivery. As a result, developers get more rapid feedback about their code, which in turn allows smaller, faster, and safer iterations.</p>&#13;
&#13;
<p>Second, not only can feature flags allow features to be more easily tested before they’re deemed ready for release, but they can also do so dynamically. For example, logic can be used to build feedback loops that can be combined with a circuit breaker–like pattern to enable or disable flags automatically under specific &#13;
<span class="keep-together">conditions</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="feature gating" id="idm45983616974760"/><a data-type="indexterm" data-primary="observability" data-secondary="techniques" id="idm45983616974056"/>Finally, logically executing flags can even be used to target feature rollouts to specific subsets of users. This technique, called <em>feature gating</em>, can be used as an alternative to proxy rules for canary deployments and staged or geographically based rollouts. When combined with observability techniques, feature gating can even allow you to more easily execute experiments like A/B testing or targeted tracing that instrument particular slices of user base, or even single customers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The Evolution of a Feature Flag"><div class="sect2" id="idm45983616971976">&#13;
<h2>The Evolution of a Feature Flag</h2>&#13;
&#13;
<p>In this section, we’ll step through the iterative implementation of a feature flag with a function taken directly from the key-value REST service that we built in <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a>. Starting with the baseline function, we’ll progress through several evolutionary stages, from flaglessness all the way to a dynamic feature flag that toggles on for a particular subset of users.</p>&#13;
&#13;
<p>In our scenario, we’ve decided that we want to be able to scale our key-value store, so we want to update the logic so that it’s backed by a fancy distributed data structure instead of a local map.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Generation 0: The Initial Implementation"><div class="sect2" id="section_ch10_generation_0">&#13;
<h2>Generation 0: The Initial Implementation</h2>&#13;
&#13;
<p>For our first iteration, we’ll start with the <code>keyValueGetHandler</code> function from <a data-type="xref" href="ch05.xhtml#section_ch05_implementing_read_function">“Implementing the read function”</a>. You may recall that <code>keyValueGetHandler</code> is an HTTP handler function that satisfies the <code>HandlerFunc</code> interface defined in the <code>net/http</code> package. If you’re a little rusty on what that means, you may want to take a look back at <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>.</p>&#13;
&#13;
<p>The initial handler function, copied almost directly from <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a> (minus some of its error handling, for brevity) is shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">keyValueGetHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">vars</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">Vars</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>                     <code class="c1">// Retrieve "key" from the request</code>&#13;
    <code class="nx">key</code> <code class="o">:=</code> <code class="nx">vars</code><code class="p">[</code><code class="s">"key"</code><code class="p">]</code>&#13;
&#13;
    <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>                  <code class="c1">// Get value for key</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>                         <code class="c1">// Unexpected error!</code>&#13;
        <code class="nx">http</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code>&#13;
            <code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">(),</code>&#13;
            <code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code>                  <code class="c1">// Write the value to the response</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, this function has no feature toggle logic (or indeed anything to toggle <em>to</em>). All it does is retrieve the key from the request variables, use the <code>Get</code> function to retrieve the value associated with that key, and write that value to the response.</p>&#13;
&#13;
<p>In our next implementation, we’ll start testing a new feature: a fancy distributed data structure to replace the local <code>map[string]string</code> that’ll allow the service to scale beyond a single instance.<a data-type="indexterm" data-primary="feature flagging" data-seealso="configurable flag, dynamic feature flag, hard-coded feature flag" data-startref="ch10_term14" id="idm45983616837736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Generation 1: The Hard-Coded Feature Flag"><div class="sect2" id="section_ch10_generation_1">&#13;
<h2>Generation 1: The Hard-Coded Feature Flag</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="hard-coded feature flag" id="ch10_term15"/>In this implementation, we’ll imagine that we’ve built our new and experimental distributed backend, and made it accessible via the <code>NewGet</code> function.</p>&#13;
&#13;
<p>Our first attempt at creating a feature flag introduces a condition that allows us to use a simple Boolean value, <code>useNewStorage</code>, to switch between the two implementations:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Set to true if you're working on the new storage backend</code>&#13;
<code class="kd">const</code> <code class="nx">useNewStorage</code> <code class="kt">bool</code> <code class="p">=</code> <code class="kc">false</code><code class="p">;</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">keyValueGetHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">vars</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">Vars</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>&#13;
    <code class="nx">key</code> <code class="o">:=</code> <code class="nx">vars</code><code class="p">[</code><code class="s">"key"</code><code class="p">]</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">value</code> <code class="kt">string</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">useNewStorage</code> <code class="p">{</code>&#13;
        <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">NewGet</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">http</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code>&#13;
            <code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">(),</code>&#13;
            <code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This first iteration shows some progress, but it’s far from where we want to be. Having the flag condition fixed in the code as a hard-coded value makes it possible to toggle between implementations well enough for local testing, but it won’t be easy to test both together in an automated and continuous manner.</p>&#13;
&#13;
<p>Plus, you’ll have to rebuild and redeploy the service whenever you want to change the algorithm you’re using in a deployed instance, which largely negates the benefits of having a feature flag in the first place.<a data-type="indexterm" data-primary="hard-coded feature flag" data-startref="ch10_term15" id="idm45983616719656"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Practice good feature flag hygiene! If you haven’t updated a feature flag in a while, consider removing it.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Generation 2: The Configurable Flag"><div class="sect2" id="section_ch10_generation_2">&#13;
<h2>Generation 2: The Configurable Flag</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="configurable flag" id="ch10_term16"/>A little time has gone by, and the shortcomings of hard-coded feature flags have become evident. For one thing, it would be really nice if we could use an external mechanism to change the value of the flag so we can test <em>both</em> algorithms in our tests.</p>&#13;
&#13;
<p>In this example, we use Viper to bind and read an environment variable, which we can now use to enable or disable the feature at runtime. The choice of configuration mechanism isn’t really important here. All that matters is that we’re able to externally update the flag without having to rebuild the code:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">keyValueGetHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">vars</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">Vars</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>&#13;
    <code class="nx">key</code> <code class="o">:=</code> <code class="nx">vars</code><code class="p">[</code><code class="s">"key"</code><code class="p">]</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">value</code> <code class="kt">string</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">FeatureEnabled</code><code class="p">(</code><code class="s">"use-new-storage"</code><code class="p">,</code> <code class="nx">r</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">NewGet</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">http</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code>&#13;
            <code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">(),</code>&#13;
            <code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">w</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">FeatureEnabled</code><code class="p">(</code><code class="nx">flag</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="kt">bool</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetBool</code><code class="p">(</code><code class="nx">flag</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In addition to using Viper to read the environment variable that sets the <code>use-new-storage</code> flag, we’ve also introduced a new function: <code>FeatureEnabled</code>. At the moment all this does is perform <code>viper.GetBool(flag)</code>, but more importantly it also concentrates the flag reading logic in a single place. We’ll see exactly what the benefit of this is in the next iteration.</p>&#13;
&#13;
<p>You might be wondering why <code>FeatureEnabled</code> accepts an <code>*http.Request</code>. Well, it doesn’t use it yet, but it’ll make sense in the next iteration.<a data-type="indexterm" data-primary="configurable flag" data-startref="ch10_term16" id="idm45983616554328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Generation 3: Dynamic Feature Flags"><div class="sect2" id="idm45983616553224">&#13;
<h2>Generation 3: Dynamic Feature Flags</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="dynamic feature flag" id="ch10_term17"/>The feature is now deployed, but turned off behind a feature flag. Now we’d like to be able to test it in production on a specific subset of your user base. It’s clear that we’re not going to be able to implement this kind of flag with a configuration setting. Instead, we’ll have to build dynamic flags that can <em>figure out for themselves</em> if they should be set. That means associating flags with functions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Dynamic flags as functions"><div class="sect3" id="idm45983616549896">&#13;
<h3>Dynamic flags as functions</h3>&#13;
&#13;
<p>The first step in building dynamic flag functions is deciding what the signature of the functions will be. While it’s not strictly required, it’s helpful to define this explicitly with a function type like the one shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Enabled</code> <code class="kd">func</code><code class="p">(</code><code class="nx">flag</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">(</code><code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <code>Enabled</code> function type is the prototype for all of our dynamic feature flags functions. Its contract defines a function that accepts the flag name as a <code>string</code> and the <code>*http.Request</code>, and it returns a <code>bool</code> that’s <code>true</code> if the requested flag is enabled.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementing a dynamic flag function"><div class="sect3" id="idm45983616481032">&#13;
<h3>Implementing a dynamic flag function</h3>&#13;
&#13;
<p>Using the contract provided by the <code>Enabled</code> type, we can now implement a function that we can use to determine whether a request is coming from a private network by comparing the request’s remote address against a standard list of IP ranges allocated for private networks:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// The list of CIDR ranges associated with internal networks.</code>&#13;
<code class="kd">var</code> <code class="nx">privateCIDRs</code> <code class="p">[]</code><code class="o">*</code><code class="nx">net</code><code class="p">.</code><code class="nx">IPNet</code>&#13;
&#13;
<code class="c1">// We use an init function to load the privateCIDRs slice.</code>&#13;
<code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">cidr</code> <code class="o">:=</code> <code class="k">range</code> <code class="p">[]</code><code class="kt">string</code><code class="p">{</code>&#13;
        <code class="s">"10.0.0.0/8"</code><code class="p">,</code>&#13;
        <code class="s">"172.16.0.0/12"</code><code class="p">,</code>&#13;
        <code class="s">"192.168.0.0/16"</code><code class="p">,</code>&#13;
    <code class="p">}</code> <code class="p">{</code>&#13;
        <code class="nx">_</code><code class="p">,</code> <code class="nx">block</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">ParseCIDR</code><code class="p">(</code><code class="nx">cidr</code><code class="p">)</code>&#13;
        <code class="nx">privateCIDRs</code> <code class="p">=</code> <code class="nb">append</code><code class="p">(</code><code class="nx">privateCIDRs</code><code class="p">,</code> <code class="nx">block</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// fromPrivateIP receives the flag name (which it ignores) and the</code>&#13;
<code class="c1">// request. If the request's remote IP is in a private range per</code>&#13;
<code class="c1">// RFC1918, it returns true.</code>&#13;
<code class="kd">func</code> <code class="nx">fromPrivateIP</code><code class="p">(</code><code class="nx">flag</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">(</code><code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Grab the host portion of the request's remote address</code>&#13;
    <code class="nx">remoteIP</code><code class="p">,</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">SplitHostPort</code><code class="p">(</code><code class="nx">r</code><code class="p">.</code><code class="nx">RemoteAddr</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">err</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Turn the remote address string into a *net.IPNet</code>&#13;
    <code class="nx">ip</code> <code class="o">:=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">ParseIP</code><code class="p">(</code><code class="nx">remoteIP</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">ip</code> <code class="o">==</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"couldn't parse ip"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Loopbacks are considered "private."</code>&#13;
    <code class="k">if</code> <code class="nx">ip</code><code class="p">.</code><code class="nx">IsLoopback</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">true</code><code class="p">,</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Search the CIDRs list for the IP; return true if found.</code>&#13;
    <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">block</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">privateCIDRs</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="nx">block</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code class="nx">ip</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">return</code> <code class="kc">true</code><code class="p">,</code> <code class="kc">nil</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">false</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the <code>fromPrivateIP</code> function conforms to <code>Enabled</code> by receiving a <code>string</code> value (the flag name) and an <code>*http.Request</code> (specifically, the instance associated with the initiating request). It returns <code>true</code> if the request originates from a &#13;
<span class="keep-together">private</span> IP range (as defined by <a href="https://oreil.ly/lZ5PQ">RFC 1918</a>).</p>&#13;
&#13;
<p>To make this determination, the <code>fromPrivateIP</code> function first retrieves the remote address, which contains the network address that sent the request, from the <code>*http.request</code>. After parsing off the host IP with <code>net.SplitHostPort</code> and using <code>net.ParseIP</code> to parse it into a <code>*net.IP</code> value, it compares the originating IP against each of the private CIDR ranges contained in <code>privateCIDRs</code>, returning <code>true</code> if a match is found.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This function also returns <code>true</code> if the request is traversing a load balancer or reverse proxy. A production-grade implementation will need to be aware of this, and would ideally be <a href="https://oreil.ly/S3btg">proxy protocol-aware</a>.</p>&#13;
</div>&#13;
&#13;
<p>Of course, this function is just an example. I used it because it’s relatively simple, but a similar technique can be used to enable or disable a flag for a geographic region, a fixed percentage of users, or even for a specific customer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The flag function lookup"><div class="sect3" id="idm45983616222760">&#13;
<h3>The flag function lookup</h3>&#13;
&#13;
<p>Now that we have a dynamic flag function in the form of <code>fromPrivateIP</code>, we have to implement some mechanism of associating flags with it, by name. Perhaps the most straightforward way of doing this is to use a map of flag name strings to <code>Enabled</code> functions:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">enabledFunctions</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">Enabled</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">enabledFunctions</code> <code class="p">=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">Enabled</code><code class="p">{}</code>&#13;
    <code class="nx">enabledFunctions</code><code class="p">[</code><code class="s">"use-new-storage"</code><code class="p">]</code> <code class="p">=</code> <code class="nx">fromPrivateIP</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using a map in this manner to indirectly reference functions provides us with a good deal of flexibility. We can even associate a function with multiple flags, if we like. This could be useful if we want a set of related features to always be active under the same conditions.</p>&#13;
&#13;
<p>You may have noticed that we’re using an <code>init</code> function to fill the <code>enabledFunctions</code> map. But wait, didn’t we already have an <code>init</code> function?</p>&#13;
&#13;
<p>Yes, we did, and that’s okay. The <code>init</code> function is special: you’re allowed to have multiple <code>init</code> functions if you like.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The router function"><div class="sect3" id="idm45983616195928">&#13;
<h3>The router function</h3>&#13;
&#13;
<p>Finally, we get to tie everything together.</p>&#13;
&#13;
<p>We do this by refactoring the <code>FeatureEnabled</code> function to look up the appropriate dynamic flag function, call it if it finds it, and return the result:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">FeatureEnabled</code><code class="p">(</code><code class="nx">flag</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="kt">bool</code> <code class="p">{</code>&#13;
    <code class="c1">// Explicit flags take precedence</code>&#13;
    <code class="k">if</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">IsSet</code><code class="p">(</code><code class="nx">flag</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">viper</code><code class="p">.</code><code class="nx">GetBool</code><code class="p">(</code><code class="nx">flag</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Retrieve the flag function, if any. If none exists,</code>&#13;
    <code class="c1">// return false</code>&#13;
    <code class="nx">enabledFunc</code><code class="p">,</code> <code class="nx">exists</code> <code class="o">:=</code> <code class="nx">enabledFunctions</code><code class="p">[</code><code class="nx">flag</code><code class="p">]</code>&#13;
    <code class="k">if</code> <code class="p">!</code><code class="nx">exists</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="kc">false</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// We now have the flag function: call it and return</code>&#13;
    <code class="c1">// the result</code>&#13;
    <code class="nx">result</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">enabledFunc</code><code class="p">(</code><code class="nx">flag</code><code class="p">,</code> <code class="nx">r</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
        <code class="k">return</code> <code class="kc">false</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">result</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At this point, <code>FeatureEnabled</code> has become a full-fledged router function that can dynamically control which code path is live according to explicit feature-flag settings and the output of flag functions. In this implementation, flags that have been explicitly set take precedence over everything else. This allows automated tests to verify both sides of a flagged feature.</p>&#13;
&#13;
<p>Our implementation uses a simple in-memory lookup to determine the behavior of particular flags, but this could just as easily be implemented with a database or other data source, or even a sophisticated managed service like LaunchDarkly. Keep in mind, though, that these solutions do introduce a new dependency.<a data-type="indexterm" data-primary="dynamic feature flag" data-startref="ch10_term17" id="idm45983616011240"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983616010312">&#13;
<h5>Feature Flags as a Service?</h5>&#13;
<p><a data-type="indexterm" data-primary="LaunchDarkly" id="idm45983616009176"/>If you’re interested in implementing some of the more sophisticated dynamic feature flags but (probably wisely) would prefer not to roll your own, <a href="https://oreil.ly/0xKeq">LaunchDarkly</a> provides an excellent “feature flags as a service” service.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983616984360">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Manageability isn’t the most glamorous subject in the cloud native world—or any world, really—but I still really enjoyed how much we got our hands dirty with details in this chapter.</p>&#13;
&#13;
<p>We dug into some of the nuts and bolts of various configuration styles, including environment variables, command-line flags, and variously formatted files. We even went over a couple of strategies for detecting configuration changes to trigger a reload. That’s not to mention Viper, which pretty much does all of that and more.</p>&#13;
&#13;
<p>I do feel like there may be some potential to go a lot deeper on some things, and I might have had it not been for the constraints of time and space. Feature flags and feature management are a pretty big subject, for example, and I definitely would have liked to have been able to explore them a bit more. Some subjects, like deployments and service discovery, we couldn’t even cover at all. I guess we have some things to look forward to in the next edition, right?</p>&#13;
&#13;
<p>As much as I enjoyed this chapter, I’m especially excited about <a data-type="xref" href="ch11.xhtml#chapter_11">Chapter 11</a>, in which we’ll get to dive into observability in general, and OpenTelemetry in particular.</p>&#13;
&#13;
<p>Finally, I’ll leave you with some advice: always be yourself, and remember that luck comes from hard work.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983620458120"><sup><a href="ch10.xhtml#idm45983620458120-marker">1</a></sup> Kernighan, Brian W., and P. J. Plauger. <em>The Elements of Programming Style</em>. McGraw-Hill, 1978.</p><p data-type="footnote" id="idm45983620454840"><sup><a href="ch10.xhtml#idm45983620454840-marker">2</a></sup> Staff, America’s Test Kitchen. <em>Perfect Pie: Your Ultimate Guide to Classic and Modern Pies, Tarts, Galettes, and More</em>. America’s Test Kitchen, 2019. <a href="https://oreil.ly/rl5TP"><em class="hyperlink">https://oreil.ly/rl5TP</em></a>.</p><p data-type="footnote" id="idm45983620452296"><sup><a href="ch10.xhtml#idm45983620452296-marker">3</a></sup> They’re doing some pretty amazing things with genetic engineering. Don’t stop believing.</p><p data-type="footnote" id="idm45983620614104"><sup><a href="ch10.xhtml#idm45983620614104-marker">4</a></sup> “Systems and Software Engineering: Vocabulary.” ISO/IEC/IEEE 24765:2010(E), 15 Dec. 2010. <a href="https://oreil.ly/NInvC"><em class="hyperlink">https://oreil.ly/NInvC</em></a>.</p><p data-type="footnote" id="idm45983620606648"><sup><a href="ch10.xhtml#idm45983620606648-marker">5</a></sup> Radle, Byron, et al. “What Is Manageability?” <em>NI</em>, National Instruments, 5 Mar. 2019. <a href="https://oreil.ly/U3d7Q"><em class="hyperlink">https://oreil.ly/U3d7Q</em></a>.</p><p data-type="footnote" id="idm45983620592520"><sup><a href="ch10.xhtml#idm45983620592520-marker">6</a></sup> Or so I told my editors. Hi, Amelia! Hi, Zan!</p><p data-type="footnote" id="idm45983620591208"><sup><a href="ch10.xhtml#idm45983620591208-marker">7</a></sup> This makes me sad. These are important topics, but we have to focus.</p><p data-type="footnote" id="idm45983620384056"><sup><a href="ch10.xhtml#idm45983620384056-marker">8</a></sup> Pike, Rob. “Go Proverbs.” Gopherfest, 18 Nov. 2015, YouTube. <a href="https://oreil.ly/5bOxW"><em class="hyperlink">https://oreil.ly/5bOxW</em></a>.</p><p data-type="footnote" id="idm45983619649368"><sup><a href="ch10.xhtml#idm45983619649368-marker">9</a></sup> Neat trick, huh?</p><p data-type="footnote" id="idm45983619331048"><sup><a href="ch10.xhtml#idm45983619331048-marker">10</a></sup> Well, like you.</p><p data-type="footnote" id="idm45983618773656"><sup><a href="ch10.xhtml#idm45983618773656-marker">11</a></sup> Seriously, that really is what it stands for.</p><p data-type="footnote" id="idm45983618296888"><sup><a href="ch10.xhtml#idm45983618296888-marker">12</a></sup> Also, I just love JSON <em>so much</em>.</p><p data-type="footnote" id="idm45983617110392"><sup><a href="ch10.xhtml#idm45983617110392-marker">13</a></sup> Or that feature just hasn’t been implemented. I don’t know.</p><p data-type="footnote" id="idm45983616980664"><sup><a href="ch10.xhtml#idm45983616980664-marker">14</a></sup> I’ve also seen “feature switch,” “feature flipper,” “conditional feature,” and more. The industry seems to be settling on “flag” and “toggle,” probably because the other names are just a little silly.</p></div></div></section></div></body></html>