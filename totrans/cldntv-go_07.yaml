- en: Chapter 5\. Building a Cloud Native Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life was simple before World War II. After that, we had systems.^([1](ch05.xhtml#idm45983635901544))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Grace Hopper, OCLC Newsletter (1987)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, our real work finally begins.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll weave together many of the materials discussed throughout [Part II](part02.xhtml#part_2)
    to create a service that will serve as the jumping-off point for the remainder
    of the book. As we go forward, we’ll iterate on what we begin here, adding layers
    of functionality with each chapter until, at the conclusion, we have ourselves
    a true cloud native application.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, it won’t be “production ready”—it will be missing important security
    features, for example—but it will provide a solid foundation for us to build upon.
  prefs: []
  type: TYPE_NORMAL
- en: But what do we build?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Build a Service!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay. So. We need something to build.
  prefs: []
  type: TYPE_NORMAL
- en: It should be conceptually simple, straightforward enough to implement in its
    most basic form, but non-trivial and amenable to scaling and distributing. Something
    that we can iteratively refine over the remainder of the book. I put a lot of
    thought into this, considering different ideas for what our application would
    be, but in the end the answer was obvious.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build ourselves a distributed key-value store.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a Key-Value Store?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key-value store is a kind of nonrelational database that stores data as a
    collection of key-value pairs. They’re very different from the better-known relational
    databases, like Microsoft SQL Server or PostgreSQL, that we know and love.^([2](ch05.xhtml#idm45983635889304))
    Where relational databases structure their data among fixed tables with well-defined
    data types, key-value stores are far simpler, allowing users to associate a unique
    identifier (the key) with an arbitrary value.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, at its heart, a key-value store is really just a map with a
    service endpoint, as shown in [Figure 5-1](#img_ch05_minimal_kvs). They’re the
    simplest possible database.
  prefs: []
  type: TYPE_NORMAL
- en: '![cngo 0501](Images/cngo_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. A key-value store is essentially a map with a service endpoint
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, we’re going to have built a simple, nondistributed
    key-value store that can do all of the things that a (monolithic) key-value store
    should do.
  prefs: []
  type: TYPE_NORMAL
- en: It must be able to store arbitrary key-value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must provide service endpoints that allow a user to put, get, and delete
    key-value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be able to persistently store its data in some fashion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we’d like the service to be idempotent. But why?
  prefs: []
  type: TYPE_NORMAL
- en: What Is Idempotence and Why Does It Matter?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of *idempotence* has its origins in algebra, where it describes
    particular properties of certain mathematical operations. Fortunately, this isn’t
    a math book. We’re not going to talk about that (except in the sidebar at the
    end of this section).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the programming world, an operation (such as a method or service call) is
    idempotent if calling it once has the same effect as calling it multiple times.
    For example, the assignment operation `x=1` is idempotent, because `x` will always
    be `1` no matter how many times you assign it. Similarly, an HTTP `PUT` method
    is idempotent because `PUT`-ting a resource in a place multiple times won’t change
    anything: it won’t get any more `PUT` the second time.^([3](ch05.xhtml#idm45983635871960))
    The operation `x+=1`, however, is not idempotent, because every time that it’s
    called, a new state is produced.'
  prefs: []
  type: TYPE_NORMAL
- en: Less discussed, but also important, is the related property of *nullipotence*,
    in which a function or operation has no side effect at all. For example, the `x=1`
    assignment and an HTTP `PUT` are idempotent but not nullipotent because they trigger
    state changes. Assigning a value to itself, such as `x=x`, is nullipotent because
    no state has changed as a result of it. Similarly, simply reading data, as with
    an HTTP `GET`, usually has no side effects, so it’s also nullipotent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that’s all very nice in theory, but why should we care in the real
    world? Well, as it turns out, designing your service methods to be idempotent
    provides a number of very real benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent operations are safer
  prefs: []
  type: TYPE_NORMAL
- en: What if you make a request to a service, but get no response? You’ll probably
    try again. But what if it heard you the first time?^([4](ch05.xhtml#idm45983635864728))
    If the service method is idempotent, then no harm done. But if it’s not, you could
    have a problem. This scenario is more common than you think. Networks are unreliable.
    Responses can be delayed; packets can get dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent operations are often simpler
  prefs: []
  type: TYPE_NORMAL
- en: 'Idempotent operations are more self-contained and easier to implement. Compare,
    for example, an idempotent `PUT` method that simply adds a key-value pair into
    a backing data store, and a similar but nonidempotent `CREATE` method that returns
    an error if the data store already contains the key. The `PUT` logic is simple:
    receive request, set value. The `CREATE`, on the other hand, requires additional
    layers of error checking and handling, and possibly even distributed locking and
    coordination among any service replicas, making its service harder to scale.'
  prefs: []
  type: TYPE_NORMAL
- en: Idempotent operations are more declarative
  prefs: []
  type: TYPE_NORMAL
- en: 'Building an idempotent API encourages the designer to focus on end-states,
    encouraging the production of methods that are more *declarative*: they allow
    users to tell a service *what needs to be done*, instead of telling it *how to
    do it*. This may seem to be a fine point, but declarative methods—as opposed to
    *imperative methods*—free users from having to deal with low-level constructs,
    allowing them to focus on their goals and minimizing potential side-effects.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, idempotence provides such an advantage, particularly in a cloud native
    context, that some very smart people have even gone so far as to assert that it’s
    a *synonym* for “cloud native.”^([5](ch05.xhtml#idm45983635854008)) I don’t think
    that I’d go quite that far, but I *would* say that if your service aims to be
    cloud native, accepting any less than idempotence is asking for trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The Eventual Goal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These requirements are quite a lot to chew on, but they represent the absolute
    minimum for our key-value store to be usable. Later on we’ll add some important
    basic functionality, like support for multiple users and data encryption in transit.
    More importantly, though, we’ll introduce techniques and technologies that make
    the service more scalable, resilient, and generally capable of surviving and thriving
    in a cruel, uncertain universe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 0: The Core Functionality'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s get started. First things first. Without worrying about user requests
    and persistence, let’s first build the core functions, which can be called later
    from whatever web framework we decide to use.
  prefs: []
  type: TYPE_NORMAL
- en: Storing arbitrary key-value pairs
  prefs: []
  type: TYPE_NORMAL
- en: For now, we can implement this with a simple map, but what kind? For the sake
    of simplicity, we’ll limit ourselves to keys and values that are simple strings,
    though we may choose to allow arbitrary types later. We’ll just use a simple `map[string]string`
    as our core data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Allow put, get, and delete of key-value pairs
  prefs: []
  type: TYPE_NORMAL
- en: In this initial iteration, we’ll create a simple Go API that we can call to
    perform the basic modification operations. Partitioning the functionality in this
    way will make it easier to test and easier to update in future iterations.
  prefs: []
  type: TYPE_NORMAL
- en: Your Super Simple API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is to create our map. The heart of our key-value
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Isn’t it a beauty? So simple. Don’t worry, we’ll make it more complicated later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function that we’ll create is, appropriately, `PUT`, which will be
    used to add records to the store. It does exactly what its name suggests: it accepts
    `key` and `value` strings, and puts them into `store`. `PUT`’s function signature
    includes an `error` return, which we’ll need later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re making the conscious choice to create an idempotent service, `Put`
    doesn’t check to see whether an existing key-value pair is being overwritten,
    so it will happily do so if asked. Multiple executions of `Put` with the same
    parameters will have the same result, regardless of any current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established a basic pattern, writing the `Get` and `Delete`
    operations is just a matter of following through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But look carefully: see how when `Get` returns an error, it doesn’t use `errors.New`?
    Instead it returns the prebuilt `ErrorNoSuchKey` error value. But why? This is
    an example of a *sentinel error*, which allows the consuming service to determine
    exactly what type of error it’s receiving and to respond accordingly. For example,
    it might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have your absolute minimal function set (really, really minimal),
    don’t forget to write tests. We’re not going to do that here, but if you’re feeling
    anxious to move forward (or lazy—lazy works too) you can grab the code from [the
    GitHub repository created for this book](https://oreil.ly/ois1B).
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 1: The Monolith'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a minimally functional key-value API, we can begin building
    a service around it. We have a few different options for how to do this. We could
    use something like GraphQL. There are some decent third-party packages out there
    that we could use, but we don’t have the kind of complex data landscape to necessitate
    it. We could also use remote procedure call (RPC), which is supported by the standard
    `net/rpc` package, or even gRPC, but these require additional overhead for the
    client, and again our data just isn’t complex enough to warrant it.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with representational state transfer (REST). REST isn’t a lot
    of people’s favorite, but it *is* simple, and it’s perfectly adequate for our
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP Server with net/http
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go doesn’t have any web frameworks that are as sophisticated or historied as
    something like Django or Flask. What it does have, however, is a strong set of
    standard libraries that are perfectly adequate for 80% of use cases. Even better:
    they’re designed to be extensible, so there *are* a number of Go web frameworks
    that extend them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s take a look at the standard HTTP handler idiom in Go, in the
    form of a “Hello World” as implemented with `net/http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we define a method, `helloGoHandler`, which satisfies
    the definition of a `http.HandlerFunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `http.ResponseWriter` and a `*http.Request` parameters can be used to construct
    the HTTP response and retrieve the request, respectively. You can use the `http.HandleFunc`
    function to register `helloGoHandler` as the handler function for any request
    that matches a given pattern (the root path, in this example).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve registered our handlers, you can call `ListenAndServe`, which listens
    on the address `addr`. It also accepts a second parameter, set to `nil` in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that `ListenAndServe` is also wrapped in a `log.Fatal` call. This
    is because `ListenAndServe` always stops the execution flow, only returning in
    the event of an error. Therefore, it always returns a non-nil `error`, which we
    always want to log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example is a complete program that can be compiled and run using
    `go run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You’re now running the world’s tiniest web service. Now go
    ahead and test it with `curl` or your favorite web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Building an HTTP Server with gorilla/mux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many web services the `net/http` and `DefaultServeMux` will be perfectly
    sufficient. However, sometimes you’ll need the additional functionality provided
    by a third-party web toolkit. A popular choice is [Gorilla](https://oreil.ly/15sGK),
    which, while being relatively new and less fully developed and resource-rich than
    something like Django or Flask, does build on Go’s standard `net/http` package
    to provide some excellent enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The `gorilla/mux` package—one of several packages provided as part of the Gorilla
    web toolkit—provides an HTTP request router and dispatcher that can fully replace
    `DefaultServeMux`, Go’s default service handler, to add several very useful enhancements
    to request routing and handling. We’re not going to make use of these features
    just yet, but they will come in handy going forward. If you’re curious and/or
    impatient, however, you can take a look at [the `gorilla/mux` documentation](https://oreil.ly/qfIph)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a minimal service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’ve done so, making use of the minimal `gorilla/mux` router is a matter
    of adding an import and one line of code: the initialization of a new router,
    which can be passed to the `handler` parameter of `ListenAndServe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So you should be able to just run this now with `go run`, right? Give it a
    try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that you can’t (yet). Since you’re now using a third-party package—a
    package that lives outside the standard library—you’re going to have to use Go
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing your project with Go modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a package from outside the standard library requires that you make use
    of [Go modules](https://oreil.ly/QJzOi), which were introduced in Go 1.12 to replace
    an essentially nonexistent dependency management system with one that’s explicit
    and actually quite painless to use. All of the operations that you’ll use for
    managing your dependencies will use one of a small handful of `go mod` commands.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you’re going to have to do is initialize your project. Start
    by creating a new, empty directory, `cd` into it, and create (or move) the Go
    file for your service there. Your directory should now contain only a single Go
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the `go mod init` command to initialize the project. Typically, if
    a project will be imported by other projects, it’ll have to be initialized with
    its import path. This is less important for a standalone service like ours, though,
    so you can be a little more lax about the name you choose. I’ll just use `example.com/gorilla`;
    you can use whatever you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You’ll now have an (almost) empty module file, `go.mod`, in your directory:^([6](ch05.xhtml#idm45983635173272))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll want to add our dependencies, which can be done automatically using
    `go mod tidy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check your `go.mod` file, you’ll see that the dependency (and a version
    number) have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Believe it or not, that’s all you need. If your required dependencies change
    in the future you need only run `go mod tidy` again to rebuild the file. Now try
    again to start your service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the service runs in the foreground, your terminal should pause. Calling
    the endpoint with `curl` from another terminal or browsing to it with a browser
    should provide the expected response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Success! But surely you want your service to do more than print a simple string,
    right? Of course you do. Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Variables in URI paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Gorilla web toolkit provides a wealth of additional functionality over
    the standard `net/http` package, but one feature is particularly interesting right
    now: the ability to create paths with variable segments, which can even optionally
    contain a regular expression pattern. Using the `gorilla/mux` package, a programmer
    can define variables using the format `{name}` or `{name:pattern}`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mux.Vars` function conveniently allows the handler function to retrieve
    the variable names and values as a `map[string]string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the next section we’ll use this ability to allow clients to perform operations
    on arbitrary keys.
  prefs: []
  type: TYPE_NORMAL
- en: So many matchers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another feature provided by `gorilla/mux` is that it allows a variety of *matchers*
    to be added to routes that let the programmer add a variety of additional matching
    request criteria. These include (but aren’t limited to) specific domains or subdomains,
    path prefixes, schemes, headers, and even custom matching functions of your own
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matchers can be applied by calling the appropriate function on the `*Route`
    value that’s returned by Gorilla’s `HandleFunc` implementation. Each matcher function
    returns the affected `*Route`, so they can be chained. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See [the `gorilla/mux` documentation](https://oreil.ly/6ztZe) for an exhaustive
    list of available matcher functions.
  prefs: []
  type: TYPE_NORMAL
- en: Building a RESTful Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to use Go’s standard HTTP library, you can use it to create
    a RESTful service that a client can interact with to execute call to the API you
    built in [“Your Super Simple API”](#section_ch05_our_api). Once you’ve done this
    you’ll have implemented the absolute minimal viable key-value store.
  prefs: []
  type: TYPE_NORMAL
- en: Your RESTful methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to do our best to follow RESTful conventions, so our API will consider
    every key-value pair to be a distinct resource with a distinct URI that can be
    operated upon using the various HTTP methods. Each of our three basic operations—Put,
    Get, and Delete—will be requested using a different HTTP method that we summarize
    in [Table 5-1](#table_ch05_restful_methods).
  prefs: []
  type: TYPE_NORMAL
- en: The URI for your key-value pair resources will have the form `/v1/key/{key}`,
    where `{key}` is the unique key string. The `v1` segment indicates the API version.
    This convention is often used to manage API changes, and while this practice is
    by no means required or universal, it can be helpful for managing the impact of
    future changes that could break existing client integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Your RESTful methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Functionality | Method | Possible Statuses |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Put a key-value pair into the store** | `PUT` | `201 (Created)` |'
  prefs: []
  type: TYPE_TB
- en: '| **Read a key-value pair from the store** | `GET` | `200 (OK), 404 (Not Found)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Delete a key-value pair** | `DELETE` | `200 (OK)` |'
  prefs: []
  type: TYPE_TB
- en: In [“Variables in URI paths”](#section_ch05_variables_in_paths), we discussed
    how to use the `gorilla/mux` package to register paths that contain variable segments,
    which will allow you to define a single variable path that handles *all* keys,
    mercifully freeing you from having to register every key independently. Then,
    in [“So many matchers”](#section_ch05_route_matchers), we discussed how to use
    route matchers to direct requests to specific handler functions based on various
    nonpath criteria, which you can use to create a separate handler function for
    each of the five HTTP methods that you’ll be supporting.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the create function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Okay, you now have everything you need to get started! So, let’s go ahead and
    implement the handler function for the creation of key-value pairs. This function
    has to be sure to satisfy several requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It must only match `PUT` requests for `/v1/key/{key}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must call the `Put` method from [“Your Super Simple API”](#section_ch05_our_api).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must respond with a `201 (Created)` when a key-value pair is created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must respond to unexpected errors with a `500 (Internal Server Error)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the previous requirements are implemented in the `keyValuePutHandler`
    function. Note how the key’s value is retrieved from the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your “key-value create” handler function, you can register
    it with your Gorilla request router for the desired path and method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have your service put together, you can run it using `go run .`
    from the project root. Do that now, and send it some requests to see how it responds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use our old friend `curl` to send a `PUT` containing a short snippet
    of text to the `/v1/key-a` endpoint to create a key named `key-a` with a value
    of `Hello,` `key-value store!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this command provides the following output. The complete output was
    quite wordy, so I’ve selected the relevant bits for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first portion, prefixed with a greater-than symbol (`>`), shows some details
    about the request. The last portion, prefixed with a less-than symbol (`<`), gives
    details about the server response.
  prefs: []
  type: TYPE_NORMAL
- en: In this output you can see that you did in fact transmit a `PUT` to the `/v1/key-a`
    endpoint, and that the server responded with a `201 Created`—as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you hit the `/v1/key-a` endpoint with an unsupported `GET` method?
    Assuming that the matcher function is working correctly, you should receive an
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the server responds with a `405 Method Not Allowed` error. Everything
    seems to be working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the read function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your service has a fully functioning `Put` method, it sure would be
    nice if you could read your data back! For our next trick, we’re going to implement
    the `Get` functionality, which has the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It must only match `GET` requests for `/v1/key/{key}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must call the `Get` method from [“Your Super Simple API”](#section_ch05_our_api).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must respond with a `404 (Not Found)` when a requested key doesn’t exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must respond with the requested value and a status `200` if the key exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must respond to unexpected errors with a `500 (Internal Server Error)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the previous requirements are implemented in the `keyValueGetHandler`
    function. Note how the value is written to `w`—the handler function’s `http.ResponseWriter`
    parameter—after it’s retrieved from the key-value API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And now that you have the “get” handler function, you can register it with
    the request router alongside the “put” handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s fire up your newly improved service and see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It works! Now that you can get your values back, you’re able to test for idempotence
    as well. Let’s repeat the requests and make sure that you get the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You do! But what if you want to overwrite the key with a new value? Will the
    subsequent `GET` have the new value? You can test that by changing the value sent
    by your `curl` slightly to be `Hello, again, key-value store!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the `GET` responds back with a `200` status and your new value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to complete your method set you’ll just need to create a handler for
    the `DELETE` method. I’ll leave that as an exercise, though. Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Data Structure Concurrency-Safe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maps in Go are not atomic and are not safe for concurrent use. Unfortunately,
    you now have a service designed to handle concurrent requests that’s wrapped around
    exactly such a map.
  prefs: []
  type: TYPE_NORMAL
- en: So what do you do? Well, typically when a programmer has a data structure that
    needs to be read from and written to by concurrently executing goroutines, they’ll
    use something like a mutex—also known as a lock—to act as a synchronization mechanism.
    By using a mutex in this way, you can ensure that exactly one process has exclusive
    access to a particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you don’t need to implement this yourself:^([7](ch05.xhtml#idm45983634450664))
    Go’s `sync` package provides exactly what you need in the form of `sync.RWMutex`.
    The following statement uses the magic of composition to create an *anonymous
    struct* that contains your map and an embedded `sync.RWMutex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `myMap` struct has all of the methods from the embedded `sync.RWMutex`,
    allowing you to use the `Lock` method to take the write lock when you want to
    write to the `myMap` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If another process has either a read or write lock, then `Lock` will block until
    that lock is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to read from the map, you use the `RLock` method to take the read
    lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Read locks are less restrictive than write locks in that any number of processes
    can simultaneously take read locks. However, `RLock` will block until any open
    write locks are released.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a read-write mutex into your application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to use a `sync.RWMutex` to implement a basic read-write
    mutex, you can go back and work it into the code you created for [“Your Super
    Simple API”](#section_ch05_our_api).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll want to refactor the `store` map.^([8](ch05.xhtml#idm45983634224808))
    You can construct it like `myMap`, i.e., as an anonymous struct that contains
    the map and an embedded `sync.RWMutex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your `store` struct, you can update the `Get` and `Put` functions
    to establish the appropriate locks. Because `Get` only needs to *read* the `store`
    map, it’ll use `RLock` to take a read lock only. `Put`, on the other hand, needs
    to *modify* the map, so it’ll need to use `Lock` to take a write lock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern here is clear: if a function needs to modify the map (`Put`, `Delete`),
    it’ll use `Lock` to take a write lock. If it only needs to read existing data
    (`Get`), it’ll use `RLock` to take a read lock. We leave the creation of the `Delete`
    function as an exercise for the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget to release your locks, and make sure you’re releasing the correct
    lock type!
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 2: Persisting Resource State'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the stickiest challenges with distributed cloud native applications is
    how to handle state.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various techniques for distributing the state of application resources
    between multiple service instances, but for now we’re just going to concern ourselves
    with the minimum viable product and consider two ways of maintaining the state
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: In [“Storing State in a Transaction Log File”](#section_ch05_state_transaction_log),
    you’ll use a file-based *transaction log* to maintain a record of every time a
    resource is modified. If a service crashes, is restarted, or otherwise finds itself
    in an inconsistent state, a transaction log allows a service to reconstruct original
    state simply by replaying the transactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [“Storing State in an External Database”](#section_ch05_state_database),
    you’ll use an external database instead of a file to store a transaction log.
    It might seem redundant to use a database given the nature of the application
    you’re building, but externalizing data into another service designed specifically
    for that purpose is a common means of sharing state between service replicas and
    providing resilience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be wondering why you’re using a transaction log strategy to record the
    events when you could just use the database to store the values themselves. This
    makes sense when you intend to store your data in memory most of the time, only
    accessing your persistence mechanism in the background and at startup time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also affords you another opportunity: given that you’re creating two different
    implementations of a similar functionality—a transaction log written both to a
    file and to a database—you can describe your functionality with an interface that
    both implementations can satisfy. This could come in quite handy, especially if
    you want to be able to choose the implementation according to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s a Transaction Log?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its simplest form, a *transaction log* is just a log file that maintains
    a history of mutating changes executed by the data store. If a service crashes,
    is restarted, or otherwise finds itself in an inconsistent state, a transaction
    log makes it possible to replay the transactions to reconstruct the service’s
    functional state.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction logs are commonly used by database management systems to provide
    a degree of data resilience against crashes or hardware failures. However, while
    this technique can get quite sophisticated, we’ll be keeping ours pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Your transaction log format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get to the code, let’s decide what the transaction log should contain.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that your transaction log will be read only when your service is
    restarted or otherwise needs to recover its state, and that it’ll be read from
    top to bottom, sequentially replaying each event. It follows that your transaction
    log will consist of an ordered list of mutating events. For speed and simplicity,
    a transaction log is also generally append-only, so when a record is deleted from
    your key-value store, for example, a `delete` is recorded in the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given everything we’ve discussed so far, each recorded transaction event will
    need to include the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence number
  prefs: []
  type: TYPE_NORMAL
- en: A unique record ID, in monotonically increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: Event type
  prefs: []
  type: TYPE_NORMAL
- en: A descriptor of the type of action taken; this can be `PUT` or `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs: []
  type: TYPE_NORMAL
- en: A string containing the key affected by this transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs: []
  type: TYPE_NORMAL
- en: If the event is a `PUT`, the value of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Nice and simple. Hopefully we can keep it that way.
  prefs: []
  type: TYPE_NORMAL
- en: Your transaction logger interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we’re going to do is define a `TransactionLogger` interface.
    For now, we’re only going to define two methods: `WritePut` and `WriteDelete`,
    which will be used to write `PUT` and `DELETE` events, respectively, to a transaction
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You’ll no doubt want to add other methods later, but we’ll cross that bridge
    when we come to it. For now, let’s focus on the first implementation and add additional
    methods to the interface as we come across them.
  prefs: []
  type: TYPE_NORMAL
- en: Storing State in a Transaction Log File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first approach we’ll take is to use the most basic (and most common) form
    of transaction log, which is just an append-only log file that maintains a history
    of mutating changes executed by the data store. This file-based implementation
    has some tempting pros, but some pretty significant cons as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: No downstream dependency
  prefs: []
  type: TYPE_NORMAL
- en: There’s no dependency on an external service that could fail or that we can
    lose access to.
  prefs: []
  type: TYPE_NORMAL
- en: Technically straightforward
  prefs: []
  type: TYPE_NORMAL
- en: The logic isn’t especially sophisticated. We can be up and running quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Harder to scale
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need some additional way to distribute your state between nodes when
    you want to scale.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled growth
  prefs: []
  type: TYPE_NORMAL
- en: These logs have to be stored on disk, so you can’t let them grow forever. You’ll
    need some way of compacting them.
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping your transaction logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get to the code, let’s make some design decisions. First, for simplicity,
    the log will be written in plain text; a binary, compressed format might be more
    time- and space-efficient, but we can always optimize later. Second, each entry
    will be written on its own line; this will make it much easier to read the data
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, each transaction will include the four fields listed in [“Your transaction
    log format”](#section_ch05_log_format), delimited by tabs. Once again, these are:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence number
  prefs: []
  type: TYPE_NORMAL
- en: A unique record ID, in monotonically increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: Event type
  prefs: []
  type: TYPE_NORMAL
- en: A descriptor of the type of action taken; this can be `PUT` or `DELETE`.
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs: []
  type: TYPE_NORMAL
- en: A string containing the key affected by this transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs: []
  type: TYPE_NORMAL
- en: If the event is a `PUT`, the value of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established these fundamentals, let’s go ahead and define a
    type, `FileTransactionLogger`, which will implicitly implement the `TransactionLogger`
    interface described in [“Your transaction logger interface”](#section_ch05_eventlogger_interface)
    by defining `WritePut` and `WriteDelete` methods for writing `PUT` and `DELETE`
    events, respectively, to the transaction log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Clearly these methods are a little light on detail, but we’ll flesh them out
    soon!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the event type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking ahead, we probably want the `WritePut` and `WriteDelete` methods to
    operate asynchronously. You could implement that using some kind of `events` channel
    that some concurrent goroutine could read from and perform the log writes. That
    sounds like a nice idea, but if you’re going to do that you’ll need some kind
    of internal representation of an “event.”
  prefs: []
  type: TYPE_NORMAL
- en: 'That shouldn’t give you too much trouble. Incorporating all of the fields that
    we listed in [“Your transaction log format”](#section_ch05_log_format) gives something
    like the `Event` struct, in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Seems straightforward, right? `Sequence` is the sequence number, and `Key` and
    `Value` are self-explanatory. But…what’s an `EventType`? Well, it’s whatever we
    say it is, and we’re going to say that it’s a constant that we can use to refer
    to the different types of events, which we’ve already established will include
    one each for `PUT` and `DELETE` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this might be to just assign some constant `byte` values, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure, this would work, but Go actually provides a better (and more idiomatic)
    way: `iota`. `iota` is a predefined value that can be used in a `constant` declaration
    to construct a series of related constant values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `iota` technique, you don’t have to manually assign values to constants.
    Instead, you can do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This might not be a big deal when you only have two constants like we have here,
    but it can come in handy when you have a number of related constants and don’t
    want to be bothered manually keeping track of which value is assigned to what.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re using `iota` as enumerations in serializations (as we are here), take
    care to only *append* to the list, and don’t reorder or insert values in the middle,
    or you won’t be able to deserialize later.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an idea of what the `TransactionLogger` will look like, as well
    as the two primary write methods. We’ve also defined a struct that describes a
    single event, and created a new `EventType` type and used `iota` to define its
    legal values. Now we’re finally ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your FileTransactionLogger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve made some progress. We know we want a `TransactionLogger` implementation
    with methods for writing events, and we’ve created a description of an event in
    code. But what about the `FileTransactionLogger` itself?
  prefs: []
  type: TYPE_NORMAL
- en: The service will want to keep track of the physical location of the transaction
    log, so it makes sense to have an `os.File` attribute representing that. It’ll
    also need to remember the last sequence number that was assigned so it can correctly
    set each event’s sequence number; that can be kept as an unsigned 64-bit integer
    attribute. That’s great, but how will the `FileTransactionLogger` actually write
    the events?
  prefs: []
  type: TYPE_NORMAL
- en: One possible approach would be to keep an `io.Writer` that the `WritePut` and
    `WriteDelete` methods can operate on directly, but that would be a single-threaded
    approach, so unless you explicitly execute them in goroutines, you may find yourself
    spending more time in I/O than you’d like. Alternatively, you could create a buffer
    from a slice of `Event` values that are processed by a separate goroutine. Definitely
    warmer, but too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all, why go through all of that work when we can just use standard buffered
    channels? Taking our own advice, we end up with a `FileTransactionLogger` and
    `Write` methods that look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You now have your `FileTransactionLogger`, which has a `uint64` value that’s
    used to track the last-used event sequence number, a write-only channel that receives
    `Event` values, and `WritePut` and `WriteDelete` methods that send `Event` values
    into that channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it looks like there might be a part left over: there’s an `Err` method
    there that returns a receive-only error channel. There’s a good reason for that.
    We’ve already mentioned that writes to the transaction log will be done concurrently
    by a goroutine that receives events from the `events` channel. While that makes
    for a more efficient write, it also means that `WritePut` and `WriteDelete` can’t
    simply return an `error` when they encounter a problem, so we provide a dedicated
    error channel to communicate errors instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new FileTransactionLogger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve followed along so far you may have noticed that none of the attributes
    in the `FileTransactionLogger` have been initialized. If you don’t fix this issue,
    it’s going to cause some problems. Go doesn’t have constructors, though, so to
    solve this you need to define a construction function, which you’ll call, for
    lack of a better name,^([9](ch05.xhtml#idm45983633408024)) `NewFileTransactionLogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See how `NewFileTransactionLogger` returns a pointer type, but its return list
    specifies the decidedly nonpointy `TransactionLogger` interface type?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is tricksy: while Go allows pointer types to implement
    an interface, it doesn’t allow pointers to interface types.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewFileTransactionLogger` calls the `os.OpenFile` function to open the file
    specified by the `filename` parameter. You’ll notice it accepts several flags
    that have been binary `OR`-ed together to set its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.O_RDWR`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file in read/write mode.
  prefs: []
  type: TYPE_NORMAL
- en: '`os.O_APPEND`'
  prefs: []
  type: TYPE_NORMAL
- en: Any writes to this file will append, not overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: '`os.O_CREATE`'
  prefs: []
  type: TYPE_NORMAL
- en: If the file doesn’t exist, creates it.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few of these flags besides the three we use here. Take a look
    at [the `os` package documentation](https://pkg.go.dev/os) for a full listing.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a construction function that ensures that the transaction log file
    is correctly created. But what about the channels? We *could* create the channels
    and spawn a goroutine with `NewFileTransactionLogger`, but that feels like we’d
    be adding too much mysterious functionality. Instead, we’ll create a `Run` method.
  prefs: []
  type: TYPE_NORMAL
- en: Appending entries to the transaction log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of yet, there’s nothing reading from the `events` channel, which is less
    than ideal. What’s worse, the channels aren’t even initialized. Let’s change this
    by creating a `Run` method, shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This implementation is incredibly basic. It won’t even correctly handle entries
    with whitespace or multiple lines!
  prefs: []
  type: TYPE_NORMAL
- en: The `Run` function does several important things.
  prefs: []
  type: TYPE_NORMAL
- en: First, it creates a buffered `events` channel. Using a buffered channel in our
    `TransactionLogger` means that calls to `WritePut` and `WriteDelete` won’t block
    as long as the buffer isn’t full. This lets the consuming service handle short
    bursts of events without being slowed by disk I/O. If the buffer does fill up,
    then the write methods will block until the log writing goroutine catches up.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it creates an `errors` channel, which is also buffered, that we’ll use
    to signal any errors that arise in the goroutine that’s responsible for concurrently
    writing events to the transaction log. The buffer value of `1` allows us to send
    an error in a nonblocking manner.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it starts a goroutine that retrieves `Event` values from our `events`
    channel and uses the `fmt.Fprintf` function to write them to the transaction log.
    If `fmt.Fprintf` returns an `error`, the goroutine sends the error to the `errors`
    channel and halts.
  prefs: []
  type: TYPE_NORMAL
- en: Using a bufio.Scanner to play back file transaction logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even the best transaction log is useless if it’s never read.^([10](ch05.xhtml#idm45983633120568))
    But how do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to read the log from the beginning and parse each line; `io.ReadString`
    and `fmt.Sscanf` let you do this with minimal fuss.
  prefs: []
  type: TYPE_NORMAL
- en: Channels, our dependable friends, will let your service stream the results to
    a consumer as it retrieves them. This might be starting to feel routine, but stop
    for a second to appreciate it. In most other languages the path of least resistance
    here would be to read in the entire file, stash it in an array, and finally loop
    over that array to replay the events. Go’s convenient concurrency primitives make
    it almost trivially easy to stream the data to the consumer in a much more space-
    and memory-efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReadEvents` method^([11](ch05.xhtml#idm45983633116792)) demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadEvents` method can really be said to be two functions in one: the
    outer function initializes the file reader, and creates and returns the event
    and error channels. The inner function runs concurrently to ingest the file contents
    line by line and send the results to the channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the `file` attribute of `TransactionLogger` is of type `*os.File`,
    which has a `Read` method that satisfies the `io.Reader` interface. `Read` is
    fairly low-level, but, if you wanted to, you could actually use it to retrieve
    the data. The `bufio` package, however, gives us a better way: the `Scanner` interface,
    which provides a convenient means for reading newline-delimited lines of text.
    We can get a new `Scanner` value by passing an `io.Reader`—an `os.File` in this
    case—to `bufio.NewScanner`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each call to the `scanner.Scan` method advances it to the next line, returning
    `false` if there aren’t any lines left. A subsequent call to `scanner.Text` returns
    the line.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `defer` statements in the inner anonymous goroutine. These ensure that
    the output channels are always closed. Because `defer` is scoped to the function
    they’re declared in, these get called at the end of the goroutine, not `ReadEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall from [“Formatting I/O in Go”](ch03.xhtml#sidebar_ch03_printf)
    that the `fmt.Sscanf` function provides a simple (but sometimes simplistic) means
    of parsing simple strings. Like the other methods in the `fmt` package, the expected
    format is specified using a format string with various “verbs” embedded: two digits
    (`%d`) and two strings (`%s`), separated by tab characters (`\t`). Conveniently,
    `fmt.Sscanf` lets you pass in pointers to the target values for each verb, which
    it can update directly.^([12](ch05.xhtml#idm45983632869720))'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Go’s format strings have a long history dating back to C’s `printf` and `scanf`,
    but they’ve been adopted by many other languages over the years, including C++,
    Java, Perl, PHP, Ruby, and Scala. You may already be familiar with them, but if
    you’re not, take a break now to look at [the `fmt` package documentation](https://pkg.go.dev/fmt).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of each loop the last-used sequence number is updated to the value
    that was just read, and the event is sent on its merry way. A minor point: note
    how the same `Event` value is reused on each iteration rather than creating a
    new one. This is possible because the `outEvent` channel is sending struct values,
    not *pointers* to struct values, so it already provides copies of whatever value
    we send into it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function checks for `Scanner` errors. The `Scan` method returns
    only a single boolean value, which is really convenient for looping. Instead,
    when it encounters an error, `Scan` returns `false` and exposes the error via
    the `Err` method.
  prefs: []
  type: TYPE_NORMAL
- en: Your transaction logger interface (redux)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve implemented a fully functional `FileTransactionLogger`, it’s
    time to look back and see which of the new methods we can use to incorporate into
    the `TransactionLogger` interface. It actually looks like there are quite few
    we might like to keep in any implementation, leaving us with the following final
    form for the `TransactionLogger` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that that’s settled, you can finally start integrating the transaction log
    into your key-value service.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the FileTransactionLogger in your web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FileTransactionLogger` is now complete! All that’s left to do now is to
    integrate it with your web service. The first step of this is to add a new function
    that can create a new `TransactionLogger` value, read in and replay any existing
    events, and call `Run`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add a `TransactionLogger` reference to our `service.go`. You can
    call it `logger` because naming is hard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have that detail out of the way, you can define your initialization
    method, which can look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This function starts as you’d expect: it calls `NewFileTransactionLogger` and
    assigns it to `logger`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is more interesting: it calls `logger.ReadEvents`, and replays
    the results based on the `Event` values received from it. This is done by looping
    over a `select` with cases for both the `events` and `errors` channels. Note how
    the cases in the `select` use the format `case foo, ok = <-ch`. The `bool` returned
    by a channel read in this way will be `false` if the channel in question has been
    closed, setting the value of `ok` and terminating the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: If we get an `Event` value from the `events` channel, we call either `Delete`
    or `Put` as appropriate; if we get an error from the `errors` channel, `err` will
    be set to a non-`nil` value and the `for` loop will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating FileTransactionLogger with your web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the initialization logic is put together, all that’s left to do to
    complete the integration of the `TransactionLogger` is add exactly three function
    calls into the web service. This is fairly straightforward, so we won’t walk through
    it here. But, briefly, you’ll need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initializeTransactionLog` to the `main` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger.WriteDelete` to `keyValueDeleteHandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger.WritePut` to `keyValuePutHandler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll leave the actual integration as an exercise for the reader.^([13](ch05.xhtml#idm45983632511416))
  prefs: []
  type: TYPE_NORMAL
- en: Future improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may have completed a minimal viable implementation of our transaction logger,
    but it still has plenty of issues and opportunities for improvement, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no `Close` method to gracefully close the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service can close with events still in the write buffer: events can get
    lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keys and values aren’t encoded in the transaction log: multiple lines or whitespace
    will fail to parse correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The sizes of keys and values are unbound: huge keys or values can be added,
    filling the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The transaction log is written in plain text: it will take up more disk space
    than it probably needs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The log retains records of deleted values forever: it will grow indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these would be impediments in production. I encourage you to take the
    time to consider—or even implement—solutions to one or more of these points.
  prefs: []
  type: TYPE_NORMAL
- en: Storing State in an External Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Databases, and data, are at the core of many, if not most, business and web
    applications, so it makes perfect sense that Go includes a standard interface
    for SQL (or SQL-like) databases [in its core libraries](https://oreil.ly/NosgK).
  prefs: []
  type: TYPE_NORMAL
- en: But does it make sense to use a SQL database to back our key-value store? After
    all, isn’t it redundant for our data store to just depend on another data store?
    Yes, certainly. But externalizing a service’s data into another service designed
    specifically for that purpose—a database—is a common pattern that allows state
    to be shared between service replicas and provides data resilience. Besides, the
    point is to show how you might interact with a database, not to design the perfect
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’ll be implementing a transaction log backed by an external
    database and satisfying the `TransactionLogger` interface, just as you did in
    [“Storing State in a Transaction Log File”](#section_ch05_state_transaction_log).
    This would certainly work, and even have some benefits as mentioned previously,
    but it comes with some tradeoffs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Externalizes application state
  prefs: []
  type: TYPE_NORMAL
- en: Less need to worry about distributed state and closer to “cloud native.”
  prefs: []
  type: TYPE_NORMAL
- en: Easier to scale
  prefs: []
  type: TYPE_NORMAL
- en: Not having to share data between replicas makes scaling out *easier* (but not
    *easy*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduces a bottleneck
  prefs: []
  type: TYPE_NORMAL
- en: What if you had to scale way up? What if all replicas had to read from the database
    at once?
  prefs: []
  type: TYPE_NORMAL
- en: Introduces an upstream dependency
  prefs: []
  type: TYPE_NORMAL
- en: Creates a dependency on another resource that might fail.
  prefs: []
  type: TYPE_NORMAL
- en: Requires initialization
  prefs: []
  type: TYPE_NORMAL
- en: What if the `Transactions` table doesn’t exist?
  prefs: []
  type: TYPE_NORMAL
- en: Increases complexity
  prefs: []
  type: TYPE_NORMAL
- en: Yet another thing to manage and configure.
  prefs: []
  type: TYPE_NORMAL
- en: Working with databases in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Databases, particularly SQL and SQL-like databases, are everywhere. You can
    try to avoid them, but if you’re building applications with some kind of data
    component, you will at some point have to interact with one.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, the creators of the Go standard library provided [the `database/sql`
    package](https://oreil.ly/YKPZ6), which provides an idiomatic and lightweight
    interface around SQL (and SQL-like) databases. In this section we’ll briefly demonstrate
    how to use this package, and point out some of the gotchas along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the most ubiquitous members of the `database/sql` package is `sql.DB`:
    Go’s primary database abstraction and entry point for creating statements and
    transactions, executing queries, and fetching results. While it doesn’t, as its
    name might suggest, map to any particular concept of a database or schema, it
    does do quite a lot of things for you, including, but not limited to, negotiating
    connections with your database and managing a database connection pool.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get into how you create your `sql.DB` in a bit. But first, we have to
    talk about database drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a database driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the `sql.DB` type provides a common interface for interacting with a SQL
    database, it depends on database drivers to implement the specifics for particular
    database types. At the time of this writing there are 45 drivers listed [in the
    Go repository](https://oreil.ly/QDQIe).
  prefs: []
  type: TYPE_NORMAL
- en: In the following section we’ll be working with a Postgres database, so we’ll
    use the third-party [`lib/pq` Postgres driver implementation](https://oreil.ly/hYW8r).
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a database driver, anonymously import the driver package by aliasing
    its package qualifier to `_`. This triggers any initializers the package might
    have while also informing the compiler that you have no intention of directly
    using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve done this, you’re finally ready to create your `sql.DB` value
    and access the database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your PostgresTransactionLogger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we presented the `TransactionLogger` interface, which provides
    a standard definition for a generic transaction log. You might recall that it
    defined methods for starting the logger, as well as reading and writing events
    to the log, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our goal now is to create a database-backed implementation of `TransactionLogger`.
    Fortunately, much of our work is already done for us. Looking back at [“Implementing
    your FileTransactionLogger”](#section_ch05_implementing_filetransactionlogger)
    for guidance, it looks like we can create a `PostgresTransactionLogger` using
    very similar logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the `WritePut`, `WriteDelete`, and `Err` methods, you can do
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare this to the `FileTransactionLogger` it’s clear that the code
    is nearly identical. All we’ve really changed is:'
  prefs: []
  type: TYPE_NORMAL
- en: Renaming (obviously) the type to `PostgresTransactionLogger`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping the `*os.File` for a `*sql.DB`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing `lastSequence`; you can let the database handle the sequencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new PostgresTransactionLogger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That’s all well and good, but we still haven’t talked about how we create the
    `sql.DB`. I know how you must feel. The suspense is definitely killing me, too.
  prefs: []
  type: TYPE_NORMAL
- en: Much like we did in the `NewFileTransactionLogger` function, we’re going to
    create a construction function for our `PostgresTransactionLogger`, which we’ll
    call (quite predictably) `NewPostgresTransactionLogger`. However, instead of opening
    a file like `NewFileTransactionLogger`, it’ll establish a connection with the
    database, returning an `error` if it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a little bit of a wrinkle, though. Namely, that the setup for a Postgres
    connection takes a lot of parameters. At the bare minimum we need to know the
    host where the database lives, the name of the database, and the user name and
    password. One way to deal with this would be to create a function like the following,
    which simply accepts a bunch of string parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This approach is pretty ugly, though. Plus, what if you wanted an additional
    parameter? Do you chunk it onto the end of the parameter list, breaking any code
    that’s already using this function? Maybe worse, the parameter order isn’t clear
    without looking at the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There has to be a better way. So, instead of this potential horror show, you
    can create a small helper struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the big-bag-of-strings approach, this struct is small, readable, and
    easily extended. To use it, you can create a `PostgresDBParams` variable and pass
    it to your construction function. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The new construction function looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This does quite a few things, but fundamentally it is not very different from
    `NewFileTransactionLogger`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing it does is to use `sql.Open` to retrieve a `*sql.DB` value.
    You’ll note that the connection string passed to `sql.Open` contains several parameters;
    the `lib/pq` package supports many more than the ones listed here. See [the package
    documentation](https://oreil.ly/uIgyN) for a complete listing.
  prefs: []
  type: TYPE_NORMAL
- en: Many drivers, including `lib/pq`, don’t actually create a connection to the
    database immediately, so it uses `db.Ping` to force the driver to establish and
    test a connection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it creates the `PostgresTransactionLogger` and uses that to verify
    that the `transactions` table exists, creating it if necessary. Without this step,
    the `PostgresTransactionLogger` will essentially assume that the table already
    exists, and will fail if it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `verifyTableExists` and `createTable` methods
    aren’t implemented here. This is entirely intentional. As an exercise, you’re
    encouraged to dive into [the `database/sql` docs](https://oreil.ly/xuFlE) and
    think about how you might go about doing that. If you’d prefer not to, you can
    find an implementation in [the GitHub repository](https://oreil.ly/1MEIr) that
    comes with this book.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a construction function that establishes a connection to the database
    and returns a newly created `TransactionLogger`. But, once again, you need to
    get things started. For that, you need to implement the `Run` method that will
    create the `events` and `errors` channels and spawn the event ingestion goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Using db.Exec to execute a SQL INSERT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the `FileTransactionLogger`, you implemented a `Run` method that initialized
    the channels and created the go function responsible for writing to the transaction
    log.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PostgresTransactionLogger` is very similar. However, instead of appending
    a line to a file, the new logger uses `db.Exec` to execute an SQL `INSERT` to
    accomplish the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation of the `Run` method does almost exactly what its `FileTransactionLogger`
    equivalent does: it creates the buffered `events` and `errors` channels, and it
    starts a goroutine that retrieves `Event` values from our `events` channel and
    writes them to the transaction log.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `FileTransactionLogger`, which appends to a file, this goroutine
    uses `db.Exec` to execute a SQL query that appends a row to the `transactions`
    table. The numbered arguments (`$1, $2, $3`) in the query are placeholder query
    parameters, which must be satisfied when the `db.Exec` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Using db.Query to play back postgres transaction logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [“Using a bufio.Scanner to play back file transaction logs”](#section_ch05_scanner_playback),
    you used a `bufio.Scanner` to read previously written transaction log entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Postgres implementation won’t be *quite* as straightforward, but the principle
    is the same: you point at the top of your data source and read until you hit the
    bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the interesting (or at least new) bits are happening in the goroutine.
    Let’s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`query` is a string that contains the SQL query. The query in this code requests
    four columns: `sequence`, `event_type`, `key`, and `value`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Query` sends `query` to the database, and returns values of type `*sql.Rows`
    and `error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defer a call to `rows.Close`. Failing to do so can lead to connection leakage!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rows.Next` lets us iterate over the rows; it returns `false` if there are
    no more rows or if there’s an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rows.Scan` copies the columns in the current row into the values we pointed
    at in the call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We send event `e` to the output channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Err` returns the error, if any, that may have caused `rows.Next` to return
    `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the PostgresTransactionLogger in your web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PostgresTransactionLogger` is pretty much complete. Now let’s go ahead
    and integrate it into the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, since we already had the `FileTransactionLogger` in place, we
    only need to change one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: which becomes…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Yup. That’s it. Really.
  prefs: []
  type: TYPE_NORMAL
- en: Because this represents a complete implementation of the `TransactionLogger`
    interface, everything else stays exactly the same. You can interact with the `PostgresTransactionLogger`
    using exactly the same methods as before.
  prefs: []
  type: TYPE_NORMAL
- en: Future improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the `FileTransactionLogger`, the `PostgresTransactionLogger` represents
    a minimal viable implementation of a transaction logger and has lots of room for
    improvement. Some of the areas for improvement include, but are certainly not
    limited to:'
  prefs: []
  type: TYPE_NORMAL
- en: We assume that the database and table exist, and we’ll get errors if they don’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The connection string is hard-coded. Even the password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s still no `Close` method to clean up open connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service can close with events still in the write buffer: events can get
    lost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The log retains records of deleted values forever: it will grow indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these would be (major) impediments in production. I encourage you to
    take the time to consider—or even implement—solutions to one or more of these
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generation 3: Implementing Transport Layer Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security. Love it or hate it, the simple fact is that security is a critical
    feature of *any* application, cloud native or otherwise. Sadly, security is often
    treated as an afterthought, with potentially catastrophic consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are rich tools and established security best practices for traditional
    environments, but this is less true of cloud native applications, which tend to
    take the form of several small, often ephemeral, microservices. While this architecture
    provides significant flexibility and scalability benefits, it also creates a distinct
    opportunity for would-be attackers: every communication between services is transmitted
    across a network, opening it up to eavesdropping and manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subject of security can take up an entire book of its own,^([14](ch05.xhtml#idm45983631389976))
    so we’ll focus on one common technique: encryption. Encrypting data “in transit”
    (or “on the wire”) is commonly used to guard against eavesdropping and message
    manipulation, and any language worth its salt—including, and especially, Go—will
    make it relatively low-lift to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Transport Layer Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transport Layer Security (TLS) is a cryptographic protocol that’s designed to
    provide communications security over a computer network. Its use is ubiquitous
    and widespread, being applicable to virtually any Internet communications. You’re
    most likely familiar with it (and perhaps using it right now) in the form of HTTPS—also
    known as HTTP over TLS—which uses TLS to encrypt exchanges over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: TLS encrypts messages using *public-key cryptography*, in which both parties
    possess their own *key pair*, which includes a *public key* that’s freely given
    out, and a *private key* that’s known only to its owner, illustrated in [Figure 5-2](#img_ch05_key_exchange).
    Anybody can use a public key to encrypt a message, but it can only be decrypted
    with the corresponding private key. Using this protocol, two parties that wish
    to communicate privately can exchange their public keys, which can then be used
    to secure all subsequent communications in a way that can only be read by the
    owner of the intended recipient, who holds the corresponding private key.^([15](ch05.xhtml#idm45983631362184))
  prefs: []
  type: TYPE_NORMAL
- en: '![cngo 0502](Images/cngo_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. One half of a public key exchange
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Certificates, certificate authorities, and trust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If TLS had a motto, it would be “trust but verify.” Actually, scratch the trust
    part. Verify everything.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not enough for a service to simply provide a public key.^([16](ch05.xhtml#idm45983631356520))
    Instead, every public key is associated with a *digital certificate*, an electronic
    document used to prove the key’s ownership. A certificate shows that the owner
    of the public key is, in fact, the named subject (owner) of the certificate, and
    describes how the key may be used. This allows the recipient to compare the certificate
    against various “trusts” to decide whether it will accept it as valid.
  prefs: []
  type: TYPE_NORMAL
- en: First, the certificate must be digitally signed and authenticated by a *certificate
    authority*, a trusted entity that issues digital certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the subject of the certificate has to match the domain name of the service
    the client is trying to connect to. Among other things, this helps to ensure that
    the certificates you’re receiving are valid and haven’t been swapped out by a
    man-in-the-middle.
  prefs: []
  type: TYPE_NORMAL
- en: Only then will your conversation proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Web browsers or other tools will usually allow you to choose to proceed if a
    certificate can’t be validated. If you’re using self-signed certificates for development,
    for example, that might make sense. But generally speaking, heed the warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Private Key and Certificate Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TLS (and its predecessor, SSL) has been around long enough^([17](ch05.xhtml#idm45983631349192))
    that you’d think that we’d have settled on a single key container format, but
    you’d be wrong. Web searches for “key file format” will return a virtual zoo of
    file extensions: *.csr*, *.key*, *.pkcs12*, *.der*, and *.pem* just to name a
    few.'
  prefs: []
  type: TYPE_NORMAL
- en: Of these, however, *.pem* seems to be the most common. It also happens to be
    the format that’s most easily supported by Go’s `net/http` package, so that’s
    what we’ll be using.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy enhanced mail (PEM) file format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Privacy enhanced mail (PEM) is a common certificate container format, usually
    stored in *.pem* files, but *.cer* or *.crt* (for certificates) and *.key* (for
    public or private keys) are common too. Conveniently, PEM is also base64 encoded
    and therefore viewable in a text editor, and even safe to paste into (for example)
    the body of an email message.^([18](ch05.xhtml#idm45983631338264))
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, *.pem* files will come in a pair, representing a complete key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '*cert.pem*'
  prefs: []
  type: TYPE_NORMAL
- en: The server certificate (including the CA-signed public key).
  prefs: []
  type: TYPE_NORMAL
- en: '*key.pem*'
  prefs: []
  type: TYPE_NORMAL
- en: A private key, not to be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, we’ll assume that your keys are in this configuration. If you
    don’t yet have any keys and need to generate some for development purposes, instructions
    are available in multiple places online. If you already have a key file in some
    other format, converting it is beyond the scope of this book. However, the Internet
    is a magical place, and there are plenty of tutorials online for converting between
    common key formats.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Your Web Service with HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now that we’ve established that security should be taken seriously, and
    that communication via TLS is a bare-minimum first step towards securing our communications,
    how do we go about doing that?
  prefs: []
  type: TYPE_NORMAL
- en: One way might be to put a reverse proxy in front of our service that can handle
    HTTPS requests and forward them to our key-value service as HTTP, but unless the
    two are co-located on the same server, we’re still sending unencrypted messages
    over a network. Plus, the additional service adds some architectural complexity
    that we might prefer to avoid. Perhaps we can have our key-value service serve
    HTTPS?
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, we can. Going all the way back to [“Building an HTTP Server with
    net/http”](#section_ch05_server_with_nethttp), you might recall that the `net/http`
    package contains a function, `ListenAndServe`, which, in its most basic form,
    looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we call `HandleFunc` to add a handler function for the root
    path, followed by `ListenAndServe` to start the service listening and serving.
    For the sake of simplicity, we ignore any errors returned by `ListenAndServe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There aren’t a lot of moving parts here, which is kind of nice. In keeping
    with that philosophy, the designers of `net/http` kindly provided a TLS-enabled
    variant of the `ListenAndServe` function that we’re familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `ListenAndServeTLS` looks and feels almost exactly like `ListenAndServe`
    except that it has two extra parameters: `certFile` and `keyFile`. If you happen
    to have certificate and private key PEM files, then service HTTPS-encrypted connections
    is just a matter of passing the names of those files to `ListenAndServeTLS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This sure looks super convenient, but does it work? Let’s fire up our service
    (using self-signed certificates) and find out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dusting off our old friend `curl`, let’s try inserting a key/value pair. Note
    that we use the `https` scheme in our URL instead of `http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Well, that didn’t go as planned. As we mentioned in [“Certificates, certificate
    authorities, and trust”](#section_ch05_trust), TLS expects any certificates to
    be signed by a certificate authority. It doesn’t like self-signed certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can turn this safety check off in `curl` with the appropriately
    named `--insecure` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We got a sternly worded warning, but it worked!
  prefs: []
  type: TYPE_NORMAL
- en: Transport Layer Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered quite a lot in just a few pages. The topic of security is vast,
    and there’s no way we’re going to do it justice, but we were able to at least
    introduce TLS, and how it can serve as one relatively low-cost, high-return component
    of a larger security strategy.
  prefs: []
  type: TYPE_NORMAL
- en: We were also able to demonstrate how to implement TLS in an Go `net/http` web
    service, and saw how—as long as we have valid certificates—to secure a service’s
    communications without a great deal of effort.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing Your Key-Value Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *container* is a lightweight operating-system-level virtualization^([19](ch05.xhtml#idm45983631128184))
    abstraction that provides processes with a degree of isolation, both from their
    host and from other containers. The concept of the container has been around since
    at least 2000, but it was the introduction of Docker in 2013 that made containers
    accessible to the masses and brought containerization into the mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, containers are not virtual machines:^([20](ch05.xhtml#idm45983631126600))
    they don’t use hypervisors, and they share the host’s kernel rather than carrying
    their own guest operating system. Instead, their isolation is provided by a clever
    application of several Linux kernel features, including `chroot`, cgroups, and
    kernel namespaces. In fact, it can be reasonably argued that containers are nothing
    more than a convenient abstraction, and that there’s actually no such thing as
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Even though they’re not virtual machines,^([21](ch05.xhtml#idm45983631124536))
    containers do provide some virtual-machine-like benefits. The most obvious of
    which is that they allow an application, its dependencies, and much of its environment
    to be packaged within a single distributable artifact—a container image—that can
    be executed on any suitable host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits don’t stop there, however. In case you need them, here’s a few
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: Agility
  prefs: []
  type: TYPE_NORMAL
- en: Unlike virtual machines that are saddled with an entire operating system and
    a colossal memory footprint, containers boast image sizes in the megabyte range
    and startup times that measure in milliseconds. This is particularly true of Go
    applications, whose binaries have few, if any, dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs: []
  type: TYPE_NORMAL
- en: This was hinted at previously, but bears repeating. Containers virtualize CPU,
    memory, storage, and network resources at the operating-system-level, providing
    developers with a sandboxed view of the OS that is logically isolated from other
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Standardization and productivity
  prefs: []
  type: TYPE_NORMAL
- en: Containers let you package an application alongside its dependencies, such as
    specific versions of language runtimes and libraries, as a single distributable
    binary, making your deployments reproducible, predictable, and versionable.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated container orchestration systems like Kubernetes provide a huge
    number of benefits. By containerizing your application(s) you’re taking the first
    step towards being able to take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: There are just four (very) motivating arguments.^([22](ch05.xhtml#idm45983631092424))
    In other words, containerization is super, super useful.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we’ll be using Docker to build our container images. Alternative
    build tools exist, but Docker is the most common containerization tool in use
    today, and the syntax for its build file—termed a *Dockerfile*—lets you use familiar
    shell scripting commands and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, this isn’t a book about Docker or containerization, so our
    discussion will mostly be limited to the bare basics of using Docker with Go.
    If you’re interested in learning more, I suggest picking up a copy of [*Docker:
    Up & Running: Shipping Reliable Containers in Production*](https://oreil.ly/rqGoI)
    by Sean P. Kane and Karl Matthias (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: Docker (Absolute) Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we continue, it’s important to draw a distinction between container images
    and the containers themselves. A *container image* is essentially an executable
    binary that contains your application runtime and its dependencies. When an image
    is run, the resulting process is the *container*. An image can be run many times
    to create multiple (essentially) identical containers.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few pages we’ll create a simple Dockerfile and build and execute
    an image. If you haven’t already, please take a moment and [install the Docker
    Community Edition (CE)](https://oreil.ly/yYwKL).
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dockerfiles are essentially build files that describe the steps required to
    build an image. A very minimal—but complete—example is demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this Dockerfile includes four different commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies a *base image* that this build will extend, and will typically be
    a common Linux distribution, such as `ubuntu` or `alpine`. At build time this
    image is pulled and run, and the subsequent commands applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN`'
  prefs: []
  type: TYPE_NORMAL
- en: Will execute any commands on top of the current image. The result will be used
    for the next step in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  prefs: []
  type: TYPE_NORMAL
- en: Tells Docker which port(s) the container will use. See [“What’s the Difference
    Between Exposing and Publishing Ports?”](#sidebar_ch05_expose_vs_publish) for
    more information on exposing ports.
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD`'
  prefs: []
  type: TYPE_NORMAL
- en: The command to execute when the container is executed. There can only be one
    `CMD` in a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: These are four of the most common Dockerfile instructions of many available.
    For a complete listing see the [official Dockerfile reference](https://oreil.ly/8LGdP).
  prefs: []
  type: TYPE_NORMAL
- en: As you may have inferred, the previous example starts with an existing Linux
    distribution image (Ubuntu 20.04) and installs Nginx, which is executed when the
    container is started.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, the file name of a Dockerfile is *Dockerfile*. Go ahead and create
    a new file named *Dockerfile* and paste the previous example into it.
  prefs: []
  type: TYPE_NORMAL
- en: Building your container image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a simple Dockerfile, you can build it! Make sure that you’re
    in the same directory as your Dockerfile and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will instruct Docker to begin the build process. If everything works correctly
    (and why wouldn’t it?) you’ll see the output as Docker downloads the parent image,
    and runs the `apt` commands. This will probably take a minute or two the first
    time you run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, you’ll see a line that looks something like the following: `Successfully
    tagged my-nginx:latest`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do, you can use the `docker images` command to verify that your image
    is now present. You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If all has gone as planned, you’ll see at least two images listed: our parent
    image `ubuntu:20.04`, and your own `my-nginx:latest` image. Next step: running
    the service container!'
  prefs: []
  type: TYPE_NORMAL
- en: Running your container image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve built your image, you can run it. For that, you’ll use the
    `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This instructs Docker to run a container using your `my-nginx` image. The `--detach`
    flag will cause the container to be run in the background. Using `--publish 8080:80`
    instructs Docker to publish port 8080 on the host bridged to port 80 in the container,
    so any connections to `localhost:8080` will be forwarded to the container’s port
    80\. Finally, the `--name nginx` flag specifies a name for the container; without
    this, a randomly generated name will be assigned instead.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that running this command presents us with a very cryptic line
    containing 65 very cryptic hexadecimal characters. This is the *container ID*,
    which can be used to refer to the container in lieu of its name.
  prefs: []
  type: TYPE_NORMAL
- en: Running your container image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To verify that your container is running and is doing what you expect, you
    can use the `docker ps` command to list all running containers. This should look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output has been edited for brevity (you may notice that it’s
    missing the `COMMAND` and `CREATED` columns). Your output should include seven
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINER ID`'
  prefs: []
  type: TYPE_NORMAL
- en: The first 12 characters of the container ID. You’ll notice it matches the output
    of your `docker run`.
  prefs: []
  type: TYPE_NORMAL
- en: '`IMAGE`'
  prefs: []
  type: TYPE_NORMAL
- en: The name (and tag, if specified) of this container’s source image. No tag implies
    `latest`.
  prefs: []
  type: TYPE_NORMAL
- en: '`COMMAND` (not shown)'
  prefs: []
  type: TYPE_NORMAL
- en: The command running inside the container. Unless overridden in the `docker run`
    this will be the same as the `CMD` instruction in the Dockerfile. In our case
    this will be `nginx -g 'daemon off;'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATED` (not shown)'
  prefs: []
  type: TYPE_NORMAL
- en: How long ago the container was created.
  prefs: []
  type: TYPE_NORMAL
- en: '`STATUS`'
  prefs: []
  type: TYPE_NORMAL
- en: The current state of the container (`up`, `exited`, `restarting`, etc) and how
    long it’s been in that state. If the state changed, then the time will differ
    from `CREATED`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PORTS`'
  prefs: []
  type: TYPE_NORMAL
- en: Lists all exposed and published ports (see [“What’s the Difference Between Exposing
    and Publishing Ports?”](#sidebar_ch05_expose_vs_publish)). In our case, we’ve
    published `0.0.0.0:8080` on the host and mapped it to `80` on the container, so
    that all requests to host port 8080 are forwarded to container port 80.
  prefs: []
  type: TYPE_NORMAL
- en: '`NAMES`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the container. Docker will randomly set this if it’s not explicitly
    defined. Two containers with the same name, regardless of state, cannot exist
    on the same host at the same time. To reuse a name, you’ll first have to `delete`
    the unwanted container.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing a request to a published container port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve gotten this far, then your `docker ps` output should show a container
    named `nginx` that appears to have port 8080 published and forwarding to the container’s
    port 80\. If so, then you’re ready to send a request to your running container.
    But which port should you query?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the Nginx container is listening on port 80\. Can you reach that? Actually,
    no. That port won’t be accessible because it wasn’t published to any network interface
    during the `docker run`. Any attempt to connect to an unpublished container port
    is doomed to failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You haven’t published to port 80, but you *have* published port 8080 and forwarded
    it to the container’s port 80\. You can verify this with our old friend `curl`
    or by browsing to `localhost:8080`. If everything is working correctly you’ll
    be greeted with the familiar Nginx “Welcome” page illustrated in [Figure 5-3](#img_ch05_nginx_welcome).
  prefs: []
  type: TYPE_NORMAL
- en: '![cngo 0503](Images/cngo_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Welcome to nginx!
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Running multiple containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the “killer features” of containerization is this: because all of the
    containers on a host are isolated from one another, it’s possible to run quite
    a lot of them—even ones that contain different technologies and stacks—on the
    same host, with each listening on a different published port. For example, if
    you wanted to run an `httpd` container alongside your already-running `my-nginx`
    container, you could do exactly that.'
  prefs: []
  type: TYPE_NORMAL
- en: “But,” you might say, “both of those containers expose port 80! Won’t they collide?”
  prefs: []
  type: TYPE_NORMAL
- en: Great question, to which the answer is, happily, no. In fact, you can actually
    have as many containers as you want that *expose* the same port—even multiple
    instances of the same image—as long as they don’t attempt to *publish* the same
    port on the same network interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to run the stock `httpd` image, you can run it by
    using the `docker run` command again, as long as you take care to publish to a
    different port (8081, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes as planned, this will spawn a new container listening on the host
    at port 8081\. Go ahead: use `docker ps` and `curl` to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Stopping and deleting your containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ve successfully run your container, you’ll probably need to stop and
    delete it at some point, particularly if you want to rerun a new container using
    the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop a running container, you can use the `docker stop` command, passing
    it either the container name or the first few characters of its container ID (how
    many characters doesn’t matter, as long they can be used to uniquely identify
    the desired container). Using the container ID to stop our `nginx` container looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of a successful `docker stop` is just the name or ID that we passed
    into the command. You can verify that your container has actually been stopped
    using `docker ps --all`, which will show *all* containers, not just the running
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you ran the `httpd` container, it will also be displayed with a status of
    `Up`. You will probably want to stop it as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the status of our `nginx` container has changed to `Exited`,
    followed by its exit code—an exit status of 0 indicates that we were able to execute
    a graceful shutdown—and how long ago the container entered its current status.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve stopped your container you can freely delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can’t delete a running container or an image that’s used by a running container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you use the `docker rm` (or the newer `docker container rm`) command
    to remove your container, again passing it either the container name or the first
    few characters of the ID of the container you want to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As before, the output name or ID indicates success. If you were to go ahead
    and run `docker ps --all` again, you shouldn’t see the container listed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Building Your Key-Value Store Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have the basics down, you can start applying them to containerizing
    our key-value service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Go’s ability to compile into statically linked binaries makes
    it especially well suited for containerization. While most other languages have
    to be built into a parent image that contains the language runtime, like the 486MB
    `openjdk:15` for Java or the 885MB `python:3.9` for Python,^([23](ch05.xhtml#idm45983630908216))
    Go binaries need no runtime at all. They can be placed into a “scratch” image:
    an image, with no parent at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration 1: adding your binary to a FROM scratch image'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To do this, you’ll need a Dockerfile. The following example is a pretty typical
    example of a Dockerfile for a containerized Go binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile is fairly similar to the previous one, except that instead of
    using `apt` to install an application from a repository, it uses `COPY` to retrieve
    a compiled binary from the filesystem it’s being built on. In this case, it assumes
    the presence of a binary named `kvs`. For this to work, we’ll need to build the
    binary first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for your binary to be usable inside a container, it has to meet a
    few criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It has to be compiled (or cross-compiled) for Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to be statically linked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to be named `kvs` (because that’s what the Dockerfile is expecting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can do all of these things in one command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through what this does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CGO_ENABLED=0` tells the compiler to disable `cgo` and statically link any
    C bindings. We won’t go into what this is, other than that it enforces static
    linking, but I encourage you to look at [the `cgo` documentation](https://oreil.ly/XUI8H)
    if you’re curious.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOOS=linux` instructs the compiler to generate a Linux binary, cross-compiling
    if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a` forces the compiler to rebuild any packages that are already up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o kvs` specifies that the binary will be named `kvs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executing the command should yield a statically linked Linux binary. This can
    be verified using the `file` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linux binaries will run in a Linux container, even one running in Docker for
    MacOS or Windows, but won’t run on MacOS or Windows otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now let’s build the container image, and see what comes out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Less than 7MB! That’s roughly two orders of magnitude smaller than the relatively
    massive images for other languages’ runtimes. This can come in quite handy when
    you’re operating at scale and have to pull your image onto a couple hundred nodes
    a few times a day.
  prefs: []
  type: TYPE_NORMAL
- en: 'But does it run? Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Looks like it works!
  prefs: []
  type: TYPE_NORMAL
- en: So now you have a nice, simple Dockerfile that builds an image using a precompiled
    binary. Unfortunately, that means that you have to make sure that you (or your
    CI system) rebuilds the binary fresh for each Docker build. That’s not *too* terrible,
    but it does mean that you need to have Go installed on your build workers. Again,
    not terrible, but we can certainly do better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration 2: using a multi-stage build'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last section, you created a simple Dockerfile that would take an existing
    Linux binary and wrap it in a bare-bones “scratch” image. But what if you could
    perform the *entire* image build—Go compilation and all—in Docker?
  prefs: []
  type: TYPE_NORMAL
- en: One approach might be to use the `golang` image as our parent image. If you
    did that, your Dockerfile could compile your Go code and run the resulting binary
    at deploy time. This could build on hosts that don’t have the Go compiler installed,
    but the resulting image would be saddled with an additional 862MB (the size of
    the `golang:1.16` image) of entirely unnecessary build machinery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach might be to use two Dockerfiles: one for building the binary,
    and another that containerizes the output of the first build. This is a lot closer
    to where you want to be, but it requires two distinct Dockerfiles that need be
    sequentially built or managed by a separate script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way became available with the introduction of multistage Docker builds,
    which allow multiple distinct builds—even with entirely different base images—to
    be chained together so that artifacts from one stage can be selectively copied
    into another, leaving behind everything you don’t want in the final image. To
    use this approach, you define a build with two stages: a “build” stage that generates
    the Go binary, and an “image” stage that uses that binary to produce the final
    image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you use multiple `FROM` statements in our Dockerfile, each defining
    the start of a new stage. Each stage can be arbitrarily named. For example, you
    might name your build stage `build`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have stages with names, you can use the `COPY` instruction in your
    Dockerfile to copy any artifact *from any previous stage*. Your final stage might
    have an instruction like the following, which copies the file `/src/kvs` from
    the `build` stage to the current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting these things together yields a complete, two-stage Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have your complete Dockerfile, you can build it in precisely the
    same way as before. We’ll tag it as `multipart` this time, though, so that you
    can compare the two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This is encouraging! You now have a single Dockerfile that can compile your
    Go code—regardless of whether or not the Go compiler is even installed on the
    build worker—and that drops the resulting statically linked executable binary
    into a `FROM scratch` base to produce a very, very small image containing nothing
    except your key-value store service.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to stop there, though. If you wanted to, you could add other
    stages as well, such as a `test` stage that runs any unit tests prior to the build
    step. We won’t go through that exercise now, however, since it’s more of the same
    thing, but I encourage you to try it for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing Container Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers are intended to be ephemeral, and any container should be designed
    and run with the understanding that it can (and will) be destroyed and recreated
    at any time, taking all of its data with it. To be clear, this is a feature, and
    is very intentional, but sometimes you might *want* your data to outlive your
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ability to mount externally managed files directly into the
    filesystem of an otherwise general-purpose container can decouple configurations
    from images so you don’t have to rebuild them whenever just to change their settings.
    This is a very powerful strategy, and is probably the most common use-case for
    container data externalization. So common in fact that Kubernetes even provides
    a resource type—`ConfigMap`—dedicated to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you might want data generated in a container to exist beyond the
    lifetime of the container. Storing data on the host can be an excellent strategy
    for warming caches, for example. It’s important to keep in mind, however, one
    of the realities of cloud native infrastructure: nothing is permanent, not even
    servers. Don’t store anything on the host that you don’t mind possibly losing
    forever.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, while “pure” Docker limits you to externalizing data directly onto
    local disk,^([24](ch05.xhtml#idm45983630671304)) container orchestration systems
    like Kubernetes provides [various abstractions](https://oreil.ly/vBXfA) that allows
    data to survive the loss of a host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this is supposed to be a book about Go, so we really can’t cover
    Kubernetes in detail here. But if you haven’t already, I strongly encourage you
    to take a long look at the [excellent Kubernetes documentation](https://oreil.ly/wxImg),
    and equally excellent [*Kubernetes: Up and Running*](https://oreil.ly/e6rve) by
    Brendan Burns, Joe Beda, and Kelsey Hightower (O’Reilly).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long chapter, and we touched on a lot of different topics. Consider
    how much we’ve accomplished!
  prefs: []
  type: TYPE_NORMAL
- en: Starting from first principles, we designed and implemented a simple monolithic
    key-value store, using `net/http` and `gorilla/mux` to build a RESTful service
    around functionality provided by a small, independent, and easily testable Go
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We leveraged Go’s powerful interface capabilities to produce two completely
    different transaction logger implementations, one based on local files and using
    `os.File` and the `fmt` and `bufio` packages; the other backed by a Postgres database
    and using the `database/sql` and `github.com/lib/pq` Postgres driver packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed the importance of security in general, covered some of the basics
    of TLS as one part of a larger security strategy, and implemented HTTPS in our
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we covered containerization, one of the core cloud native technologies,
    including how to build images and how to run and manage containers. We even containerized
    not only our application, but we even containerized its build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going forward, we’ll be extending on our key-value service in various ways when
    we introduce new concepts, so stay tuned. Things are about to get even more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.xhtml#idm45983635901544-marker)) Schieber, Philip. “The Wit and Wisdom
    of Grace Hopper.” *OCLC Newsletter*, March/April, 1987, No. 167.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.xhtml#idm45983635889304-marker)) For some definition of “love.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.xhtml#idm45983635871960-marker)) If it does, something is very wrong.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.xhtml#idm45983635864728-marker)) Or, like my son, was only *pretending*
    not to hear you.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.xhtml#idm45983635854008-marker)) “Cloud native is not a synonym for
    microservices… if cloud native has to be a synonym for anything, it would be idempotent,
    which definitely needs a synonym.” —Holly Cummins (Cloud Native London 2018).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.xhtml#idm45983635173272-marker)) Isn’t this exciting?
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch05.xhtml#idm45983634450664-marker)) It’s a good thing too. Mutexes can
    be pretty tedious to implement correctly!
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch05.xhtml#idm45983634224808-marker)) Didn’t I tell you that we’d make
    it more complicated?
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch05.xhtml#idm45983633408024-marker)) That’s a lie. There are probably
    lots of better names.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch05.xhtml#idm45983633120568-marker)) What makes a transaction log “good”
    anyway?
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch05.xhtml#idm45983633116792-marker)) Naming is hard.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch05.xhtml#idm45983632869720-marker)) After all this time, I still think
    that’s pretty neat.
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch05.xhtml#idm45983632511416-marker)) You’re welcome.
  prefs: []
  type: TYPE_NORMAL
- en: ^([14](ch05.xhtml#idm45983631389976-marker)) Ideally written by somebody who
    knows more than I do about security.
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch05.xhtml#idm45983631362184-marker)) This is a gross over-simplification,
    but it’ll do for our purposes. I encourage you to learn more about this and correct
    me, though.
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch05.xhtml#idm45983631356520-marker)) You don’t know where that key has
    been.
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch05.xhtml#idm45983631349192-marker)) SSL 2.0 was released in 1995 and
    TLS 1.0 was released in 1999\. Interestingly, SSL 1.0 had some pretty profound
    security flaws and was never publicly released.
  prefs: []
  type: TYPE_NORMAL
- en: ^([18](ch05.xhtml#idm45983631338264-marker)) Public keys only, please.
  prefs: []
  type: TYPE_NORMAL
- en: ^([19](ch05.xhtml#idm45983631128184-marker)) Containers are not virtual machines.
    They virtualize the operating system instead of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch05.xhtml#idm45983631126600-marker)) Repetition intended. This is an
    important point.
  prefs: []
  type: TYPE_NORMAL
- en: ^([21](ch05.xhtml#idm45983631124536-marker)) Yup. I said it. Again.
  prefs: []
  type: TYPE_NORMAL
- en: ^([22](ch05.xhtml#idm45983631092424-marker)) The initial draft had several more,
    but this chapter is already pretty lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: ^([23](ch05.xhtml#idm45983630908216-marker)) To be fair, these images are “only”
    240MB and 337MB compressed, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: ^([24](ch05.xhtml#idm45983630671304-marker)) I’m intentionally ignoring solutions
    like Amazon’s Elastic Block Store, which can help, but have issues of their own.
  prefs: []
  type: TYPE_NORMAL
