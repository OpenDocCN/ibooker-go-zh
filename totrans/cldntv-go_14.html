<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Observability"><div class="chapter" id="chapter_11">&#13;
<h1><span class="label">Chapter 11. </span>Observability</h1>&#13;
&#13;
<blockquote>&#13;
<p>Data is not information, information is not knowledge, knowledge is not understanding, understanding is not wisdom.<sup><a data-type="noteref" id="idm45983615999816-marker" href="ch11.xhtml#idm45983615999816">1</a></sup></p>&#13;
<p data-type="attribution">Clifford Stoll, <cite>High-Tech Heretic: Reflections of a Computer Contrarian</cite></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="indexterm" data-primary="cloud native" data-secondary="evolution of" id="idm45983615997416"/><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983615996440"/>“Cloud native” is still a pretty new concept, even for computing. As far as <a href="https://oreil.ly/sPxg7">I can tell</a>, the term “cloud native” only started entering our vocabulary just after the founding of the Cloud Native Computing Foundation in the middle of 2015.<sup><a data-type="noteref" id="idm45983615994840-marker" href="ch11.xhtml#idm45983615994840">2</a></sup></p>&#13;
&#13;
<p>As an industry, we’re largely still trying to figure out exactly what “cloud native” means, and with each of the major public cloud providers regularly launching new services—each seeming to offer more abstraction than the last—even what little agreement we have is shifting over time.</p>&#13;
&#13;
<p>One thing is clear, though: the functions (and failures) of the network and hardware layers are being increasingly abstracted and replaced with API calls and events. Every day we move closer to a world of software-defined <em>everything</em>. All of our problems are becoming software problems.</p>&#13;
&#13;
<p>While we certainly sacrifice a fair share of control over the platforms our software runs on, we win <em>big</em> in overall manageability and reliability,<sup><a data-type="noteref" id="idm45983615991304-marker" href="ch11.xhtml#idm45983615991304">3</a></sup> allowing us to focus our limited time and attention on our software. However, this also means that most of our failures now originate from within our own services and the interactions between them. No amount of fancy frameworks or protocols can solve the problem of bad software. As I said way back in <a data-type="xref" href="ch01.xhtml#chapter_1">Chapter 1</a>, a kludgy application in Kubernetes is still kludgy.</p>&#13;
&#13;
<p>Things are complicated in this brave new software-defined, highly distributed world. The software is complicated, the platforms are complicated, together they’re <em>really</em> complicated, and more often than not we have no idea what’s going on. Gaining visibility into our services has become more important than ever, and about the only thing that we <em>do</em> know is that the existing monitoring tools and techniques simply aren’t up to the task. Clearly, we need something new. Not just a new technology, or even a new set of techniques, but an entirely new way of thinking about how we understand our systems.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="What Is Observability?"><div class="sect1" id="idm45983615987448">&#13;
<h1>What Is Observability?</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="observability" data-secondary="definition of" id="idm45983615986008"/>Observability is the subject of an awful lot of buzz right now. It’s kind of a big deal. But what is observability, actually? How is it different from (and how is it like) traditional monitoring and alerting with logs and metrics and tracing? Most importantly, how do we “do observability”?</p>&#13;
&#13;
<p>Observability isn’t just marketing hype, although it’s easy to think that based on all the attention it’s getting.</p>&#13;
&#13;
<p>It’s actually pretty simple. Observability is a system property, no different than resilience or manageability, that reflects how well a system’s internal states can be inferred from knowledge of its external outputs. A system can be considered <em>observable</em> when it’s possible to quickly and consistently ask novel questions about it with minimal prior knowledge and without having to reinstrument or build new code. An observable system lets you ask it questions that you haven’t thought of yet.</p>&#13;
&#13;
<p>Ultimately, observability is more than tooling, despite what some vendors may try to tell you (and sell you). You can’t “buy observability” any more than you can “buy reliability.” No tooling will make your system observable just because you’re using it any more than a hammer will by itself make a bridge structurally sound. The tools can get you partway there, but it’s up to you to apply them correctly.</p>&#13;
&#13;
<p>This is much easier said than done, of course. Building observability into a complex system demands moving past searching for “known unknowns,” and embracing the fact that we often can’t even fully understand its state at a given snapshot in time. Understanding <em>all possible</em> failure (or non-failure) states in a complex system is pretty much impossible. The first step to achieving observability is to stop looking for specific, expected failure modes—the “known unknowns”—as if this isn’t the case.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Why Do We Need Observability?"><div class="sect2" id="idm45983615980344">&#13;
<h2>Why Do We Need Observability?</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="observability" data-secondary="purpose of" id="idm45983615978936"/>Observability is the natural evolution of traditional monitoring, driven by the new challenges introduced by cloud native architectures.</p>&#13;
&#13;
<p>The first of these is simply the pure scale of many modern cloud native systems, which increasingly have too much <em>stuff</em> for our limited human brains with their limited human attention spans to handle. All of the data generated by multiple concurrently operating interconnected systems provides more things than we can reasonably watch, more data than we can reasonably process, and more correlations than we can reasonably make.</p>&#13;
&#13;
<p>More importantly, however, is that the nature of cloud native systems is fundamentally different from the more traditional architectures of not-so-long-ago. Their environmental and functional requirements are different, the way they function—and the way they fail—is different, and the guarantees they need to provide are different.</p>&#13;
&#13;
<p>How do you monitor distributed systems given the ephemerality of modern applications and the environments in which they reside? How can you pinpoint a defect in a single component within the complex web of a highly distributed system? These are the problems that “observability” seeks to address.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="How Is Observability Different from “Traditional” Monitoring?"><div class="sect2" id="idm45983615974792">&#13;
<h2>How Is Observability Different from “Traditional” Monitoring?</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="monitoring" id="idm45983615973544"/>On its face, the line between monitoring and observability seems fuzzy. After all, both are about being able to ask questions of a system. The difference is in the types of questions that are and can be asked.</p>&#13;
&#13;
<p>Traditionally, monitoring focuses on asking questions in the hope of identifying or predicting some expected or previously observed failure modes. In other words, it centers on “known unknowns.” The assumption is that the system is expected to behave—and therefore fail—in a specific, predictable way. When a new failure mode is discovered—usually the hard way—its symptoms are added to the monitoring suite, and the process begins again.</p>&#13;
&#13;
<p>This approach works well enough when a system is fairly simple, but it has some problems. First, asking a new question of a system often means writing and shipping new code. This isn’t flexible, it definitely isn’t scalable, and it’s super annoying.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="failures" data-secondary="causes of" id="idm45983615970664"/>Second, at a certain level of complexity the number of “unknown unknowns” in a system starts to overwhelm the number of “known unknowns.” Failures are more often unpredicted, less often predictable, and are nearly always the outcome of many things going wrong. Monitoring for every possible failure mode becomes effectively impossible.</p>&#13;
&#13;
<p>Monitoring is something you <em>do to a system</em> to find out it isn’t working. Observability techniques, on the other hand, emphasize understanding a system by allowing you to correlate events and behaviors. Observability is a <em>property a system has</em> that lets you ask why it isn’t working.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="The “Three Pillars of Observability”"><div class="sect1" id="section_ch11_three_pillars">&#13;
<h1>The “Three Pillars of Observability”</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Three Pillars of Observability" id="ch11_term2"/><a data-type="indexterm" data-primary="observability" data-secondary="pillars of" data-seealso="logging, metrics, tracing" id="ch11_term1"/>The <em>Three Pillars of Observability</em> is the collective name by which the three most common (and foundational) tools in the observability kit—logging, metrics, and tracing—are sometimes referred. These three parts are, in the order that we’ll be discussing them:</p>&#13;
<dl>&#13;
<dt>Tracing</dt>&#13;
<dd>&#13;
<p><a data-type="indexterm" data-primary="tracing" data-seealso="distributed tracing" id="idm45983615961272"/><a data-type="indexterm" data-primary="trace" id="idm45983615960296"/><a data-type="indexterm" data-primary="distributed tracing" id="idm45983615959624"/>Tracing (or <em>distributed tracing</em>) follows a request as it propagates through a (typically distributed) system, allowing the entire end-to-end request flow to be reconstructed as a <a href="https://oreil.ly/exjvV">directed acyclic graph</a> (DAG) called a <em>trace</em>. Analysis of these traces can provide insight into how a system’s components interact, making it possible to pinpoint failures and performance issues.</p>&#13;
&#13;
<p>Tracing will be discussed in more detail in <a data-type="xref" href="#section_ch11_tracing">“Tracing”</a>.</p>&#13;
</dd>&#13;
<dt>Metrics</dt>&#13;
<dd>&#13;
<p><a data-type="indexterm" data-primary="metrics" id="idm45983615954440"/>Metrics involves the collection of numerical data points representing the state of various aspects of a system at specific points in time. Collections of data points, representing observations of the same subject at various times, are particularly useful for visualization and mathematical analysis, and can be used to highlight trends, identify anomalies, and predict future behavior.</p>&#13;
&#13;
<p>We’ll discuss more about metrics in <a data-type="xref" href="#section_ch11_metrics">“Metrics”</a>.</p>&#13;
</dd>&#13;
<dt>Logging</dt>&#13;
<dd>&#13;
<p><a data-type="indexterm" data-primary="logging" id="idm45983615950808"/><a data-type="indexterm" data-primary="Elasticsearch" id="idm45983615950104"/><a data-type="indexterm" data-primary="logs" id="idm45983615949432"/>Logging is the process of appending records of noteworthy events to an immutable record—the log—for later review or analysis.&#13;
A log can take a variety of forms, from a continuously appended file on disk to a full-text search engine like <a href="https://oreil.ly/Hf4Pn">Elasticsearch</a>. Logs provides valuable, context-rich insight into application-specific events emitted by processes. However, it’s important that log entries are properly structured; not doing so can sharply limit their &#13;
<span class="keep-together">utility</span>.</p>&#13;
&#13;
<p>We’ll dive into logging in more detail in <a data-type="xref" href="#section_ch11_logging">“Logging”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While each of these methods is useful on its own, a truly observable system will interweave them so that each can reference the others. For example, metrics might be used to track down a subset of misbehaving traces, and those traces might highlight logs that could help to find the underlying cause of the behavior.</p>&#13;
&#13;
<p>If you take nothing else away from this chapter, remember that observability is <em>just a system property</em>, like resilience or manageability, and that no tooling, framework, or vendor can “give you” observability. The so-called “Three Pillars” are just techniques that can be used to build in that property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983615943400">&#13;
<h5>The (So-Called) “Three Pillars”</h5>&#13;
<p>This name “Three Pillars of Observability” is often criticized—with good reason, I think—because it’s easy to interpret it as suggesting that they’re how you can “do observability.” But while just having logging, metrics, and tracing won’t necessarily make a system more observable, each of the “three pillars” are powerful tools that, if well understood and used well together, can provide deep insight into the internal state of your system.</p>&#13;
&#13;
<p>Another common criticism is that the term implies that observability is the combination of three very different things, when each of the three tools simply provides a different view of the same thing, which ultimately enhances a singular ability to understand the state of your system. It’s through the integration of these three approaches that it becomes possible to take the first steps towards observability.<a data-type="indexterm" data-primary="observability" data-secondary="pillars of" data-startref="ch11_term1" id="idm45983615940776"/><a data-type="indexterm" data-primary="Three Pillars of Observability" data-startref="ch11_term2" id="idm45983615939528"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="OpenTelemetry"><div class="sect1" id="section_ch11_opentelemetry">&#13;
<h1>OpenTelemetry</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="OTel" data-see="OpenTelemetry" id="idm45983615931112"/><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983615930264"/><a data-type="indexterm" data-primary="CNCF" data-see="Cloud Native Computing Foundation" id="idm45983615929656"/><a data-type="indexterm" data-primary="OpenTelemetry" id="ch11_term3"/>As of the time of writing, OpenTelemetry (or “OTel,” as the cool kids are calling it<sup><a data-type="noteref" id="idm45983615927544-marker" href="ch11.xhtml#idm45983615927544">4</a></sup>) is one of about four dozen “Sandbox” member projects of the Cloud Native Computing Foundation, and arguably one of the most interesting projects in the entire CNCF project catalog.</p>&#13;
&#13;
<p>Unlike most CNCF projects, OpenTelemetry isn’t a service, <em>per se</em>. Rather, it’s an effort to standardize how telemetry data—traces, metrics, and (eventually) logs—are expressed, collected, and transferred. Its <a href="https://oreil.ly/GpGD5">multiple repositories</a> include a collection of specifications, along with APIs and reference implementations in various languages, <a href="https://oreil.ly/vSO7k">including Go</a>.<sup><a data-type="noteref" id="idm45983615924216-marker" href="ch11.xhtml#idm45983615924216">5</a></sup></p>&#13;
&#13;
<p>The instrumentation space is a crowded one, with perhaps dozens of vendors and tools that have come and gone over the years, each with their own unique implementations. OpenTelemetry seeks to unify this space—and all of the vendors and tools within it—around a single vendor-neutral specification that standardizes how telemetry data is collected and sent to backend platforms. There have been other attempts to standardize before. In fact, OpenTelemetry is the merger of two such &#13;
<span class="keep-together">earlier</span> projects: OpenTracing and OpenCensus, which it unifies and extends into a single set of vendor-neutral standards.</p>&#13;
&#13;
<p>In this chapter, we’ll review each of the “three pillars,” their core concepts, and how to use OpenTelemetry to instrument your code and forward the resulting telemetry to a backend of your choice. However, it’s important to note that OpenTelemetry is a <em>big</em> subject that deserves a book of its own to truly do it justice, but I’ll do my best to provide sufficient coverage to at least make it a practical introduction. At the time of this writing, there weren’t any comprehensive resources available about OpenTelemetry, but I’ve gathered what I can from examples and a handful of articles (and a fair amount of digging through the source code).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As I was writing this chapter, I learned that Charity Majors<sup><a data-type="noteref" id="idm45983615919256-marker" href="ch11.xhtml#idm45983615919256">6</a></sup> and Liz Fong-Jones were hard at work on <a href="https://oreil.ly/FZw86"><em>Observability Engineering</em></a>, planned for release by O’Reilly Media in January 2022.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The OpenTelemetry Components"><div class="sect2" id="section_ch11_otel_components">&#13;
<h2>The OpenTelemetry Components</h2>&#13;
&#13;
<p>OpenTelemetry extends and unifies earlier attempts at creating telemetry standards, in part by including abstractions and extension points in the SDK where you can insert your own implementations. This makes it possible to, for example, implement custom exporters that can interface with a vendor of your choice.</p>&#13;
&#13;
<p>To accomplish this level of modularity, OpenTelemetry was designed with the following core components:</p>&#13;
<dl>&#13;
<dt>Specifications</dt>&#13;
<dd>&#13;
<p>The OpenTelemetry specifications describe the requirements and expectations for all OpenTelemetry APIs, SDKs, and data protocols.</p>&#13;
</dd>&#13;
<dt>API</dt>&#13;
<dd>&#13;
<p>Language-specific interfaces and implementations based on the specifications that can be used to add OpenTelemetry to an application.</p>&#13;
</dd>&#13;
<dt>SDK</dt>&#13;
<dd>&#13;
<p>The concrete OpenTelemetry implementations that sit between the APIs and the Exporters, providing functionality like (for example) state tracking and batching data for transmission. An SDK also offers a number of configuration options for behaviors like request filtering and transaction sampling.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Jaeger" id="idm45983615907976"/><a data-type="indexterm" data-primary="Honeycomb" id="idm45983615907272"/><a data-type="indexterm" data-primary="Lightstep" id="idm45983615906600"/>Exporters</dt>&#13;
<dd>&#13;
<p>In-process SDK plug-ins that are capable of sending data to a specific destination, which may be local (such as a log file or <code>stdout</code>), or remote (such as <a href="https://oreil.ly/uMAfg">Jaeger</a>, or a commercial solution like <a href="https://oreil.ly/cBlnX">Honeycomb</a> or <a href="https://oreil.ly/KScdI">Lightstep</a>). Exporters decouple the instrumentation from the backend, making it possible to change destinations without having to reinstrument your code.</p>&#13;
</dd>&#13;
<dt>Collector</dt>&#13;
<dd>&#13;
<p>An optional, but very useful, vendor-agnostic service that can receive and process telemetry data before forwarding it to one or more destinations. It can be run either as a sidecar process alongside your application or as a standalone proxy elsewhere, providing greater flexibility for sending the application telemetry. This can be particularly useful in the kind of tightly controlled environments that are common in the enterprise.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>You may have noticed the absence of an OpenTelemetry backend. Well, there isn’t one. OpenTelemetry is only concerned with the collection, processing, and sending of telemetry data, and relies on you to provide a telemetry backend to receive and store the data.</p>&#13;
&#13;
<p>There are other components as well, but the above can be considered to be OpenTelemetry’s core components. The relationships between them are illustrated in <a data-type="xref" href="#img_ch11_otel_components">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div id="img_ch11_otel_components" class="figure">&#13;
<img src="Images/cngo_1101.png" alt="cngo 1101" width="1438" height="255"/>&#13;
<h6><span class="label">Figure 11-1. </span>A high-level view of  OpenTelemetry’s core components for data instrumentation (API), processing (SDK), and exporting (exporter and collectors); you have to bring your own backend</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="features of" id="idm45983615895896"/><a data-type="indexterm" data-primary="Python" id="idm45983615894696"/><a data-type="indexterm" data-primary="Java" id="idm45983615894024"/><a data-type="indexterm" data-primary="Ruby" id="idm45983615893352"/><a data-type="indexterm" data-primary="Erlang" id="idm45983615892680"/><a data-type="indexterm" data-primary="PHP" id="idm45983615892008"/><a data-type="indexterm" data-primary="JavaScript" id="idm45983615891336"/><a data-type="indexterm" data-primary=".NET" id="idm45983615890664"/><a data-type="indexterm" data-primary="Rust" id="idm45983615889992"/><a data-type="indexterm" data-primary="Swift" id="idm45983615889320"/>Finally, broad language support is a central aim of the project. As of the time of this writing, OpenTelemetry provides APIs and SDKs for Go, Python, Java, Ruby, Erlang, PHP, JavaScript, .NET, Rust, C++, and Swift.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Tracing"><div class="sect1" id="section_ch11_tracing">&#13;
<h1>Tracing</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tracing" id="ch11_term4"/>Throughout this book, we’ve spent a lot of time talking about the benefits of microservices architectures and distributed systems. But the unfortunate reality—as I’m sure has already become clear—is that such architectures also introduce a variety of new and “interesting” problems.</p>&#13;
&#13;
<p>It’s been said that fixing an outage in a distributed system can feel like solving a murder mystery, which is a glib way of saying that when <em>something</em> isn’t working, <em>somewhere</em> in the system, it’s often a challenge just knowing where to start looking for the source of the problem before you can find and fix it.</p>&#13;
&#13;
<p>This is exactly the kind of problem that <em>tracing</em> was invented to solve. By tracking requests as they propagate through the system—even across process, network, and security boundaries—tracing can help you to (for example) pinpoint component failures, identify performance bottlenecks, and analyze service dependencies.<a data-type="indexterm" data-primary="OpenTelemetry" data-startref="ch11_term3" id="idm45983615882216"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Tracing is usually discussed in the context of distributed systems, but a complex monolithic application can also benefit from tracing, especially if it contends for resources like network, disk, or mutexes.</p>&#13;
</div>&#13;
&#13;
<p>In this section, we’ll go into more depth on tracing, its core concepts, and how to use OpenTelemetry to instrument your code and forward the resulting telemetry to a backend of your choice.</p>&#13;
&#13;
<p>Unfortunately, the constraints of time and space permit us to only dig so far into this topic. But if you’d like to learn more about tracing, you might be interested in <a href="https://oreil.ly/vzJMP" class="orm:hideurl"><em>Distributed Tracing in Practice</em></a> by Austin Parker, Daniel Spoonhower, Jonathan Mace,  Ben Sigelman, and Rebecca Isaacs (O’Reilly).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Tracing Concepts"><div class="sect2" id="idm45983615877320">&#13;
<h2>Tracing Concepts</h2>&#13;
&#13;
<p>When discussing tracing, there are two fundamental concepts you need to know about, <em>spans</em> and <em>traces</em>:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="spans" data-seealso="root spans" id="idm45983615874376"/>Spans</dt>&#13;
<dd>&#13;
<p>A span describes a unit of work performed by a request, such as a fork in the execution flow or hop across the network, as it propagates through a system. Each span has an associated name, a start time, and a duration. They can be (and typically are) nested and ordered to model causal relationships.</p>&#13;
</dd>&#13;
<dt>Traces</dt>&#13;
<dd>&#13;
<p><a data-type="indexterm" data-primary="traces" id="idm45983615871032"/><a data-type="indexterm" data-primary="directed acyclic graph (DAG)" id="idm45983615870328"/><a data-type="indexterm" data-primary="DAG (directed acyclic graph)" id="idm45983615869688"/><a data-type="indexterm" data-primary="stack trace" id="idm45983615869000"/>A trace represents all of the events—individually represented as spans—that make up a request as it flows through a system. A trace may be thought of as a directed acyclic graph (DAG) of spans, or more concretely as a “stack trace” in which each span represents the work done by one component.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This relationship between a request trace and spans is illustrated in <a data-type="xref" href="#img_ch11_spans_traces">Figure 11-2</a>, in which we see two different representations of the same request as it flows through five different services to generate five spans.</p>&#13;
&#13;
<figure><div id="img_ch11_spans_traces" class="figure">&#13;
<img src="Images/cngo_1102.png" alt="cngo 1102" width="1420" height="610"/>&#13;
<h6><span class="label">Figure 11-2. </span>Two representations of a trace of a request as it traverses five services, resulting in five spans; the full traces are visualized as a DAG (left), and as a bar diagram (right) with a time axis illustrating start times and durations</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="indexterm" data-primary="root spans" id="idm45983615863704"/>When a request begins in the first (edge) service, it creates the first span—the <em>root span</em>—which will form the first node in the span trace. The root span is automatically assigned a globally unique trace ID, which is passed along with each subsequent hop in the request lifecycle. The next point of instrumentation creates a new span with the provided trace ID, perhaps choosing to insert or otherwise enrich the metadata associated with the request, before sending the trace ID along again with the next request.</p>&#13;
&#13;
<p>Each hop along the flow is represented as one span. When the execution flow reaches the instrumented point at one of these services, a record is emitted with any metadata. These records are usually asynchronously logged to disk before being submitted out of band to a collector, which can then reconstruct the flow of execution based on different records emitted by different parts of the system.</p>&#13;
&#13;
<p><a data-type="xref" href="#img_ch11_spans_traces">Figure 11-2</a> demonstrates the two most common ways of illustrating a trace containing five spans, lettered A through E in the order that they were created. On the left side, the trace is represented in DAG form; the root span A starts at time 0 and lasts for 350ms, until the response is returned for the last service E. On the right, the same data is illustrated as a bar diagram with a time axis, in which the position and length of the bars reflect the start times and durations, respectively.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Tracing with OpenTelemetry"><div class="sect2" id="idm45983615859464">&#13;
<h2>Tracing with OpenTelemetry</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="OpenTelemetry" id="ch11_term4_2"/>Using OpenTelemetry to instrument your code includes two phases: configuration and instrumentation. This is true whether you’re instrumenting for tracing or metrics (or both), although the specifics change slightly between the two. For both tracing and metric instrumentation, the configuration phase is executed exactly once in a program, usually in the <code>main</code> function, and includes the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The first step is to retrieve and configure the appropriate exporters for your target backends. Tracing exporters implement the <code>SpanExporter</code> interface (which in OpenTelemetry v0.17.0 is located in the <code>go.opentelemetry.io/otel/sdk/export/trace</code> package, often aliased to <code>export</code>). As we’ll discuss in <a data-type="xref" href="#section_ch11_tracing_creating_the_exporters">“Creating the tracing exporters”</a>, several stock exporters are included with OpenTelemetry, but custom implementations exist for many telemetry backends.</p>&#13;
</li>&#13;
<li>&#13;
<p>Before instrumenting your code for tracing, the exporters—and any other appropriate configuration options—are passed to the SDK to create the “tracer provider,” which, as we’ll show in <a data-type="xref" href="#section_ch11_tracing_create_provider">“Creating a tracer provider”</a>, will serve as the main entry point for the OpenTelemetry tracing API for the lifetime of your program.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once you’ve created your tracer provider, it’s a good practice to set it as your “global” tracer provider. As we’ll see in <a data-type="xref" href="#section_ch11_tracing_set_global_tracerprovider">“Setting the global tracer provider”</a>, this makes it discoverable via the <code>otel.GetTracerProvider</code> function, which allows libraries and other dependencies that also use the OpenTelemetry API to more easily discover the SDK and emit telemetry data.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Once the configuration is complete, instrumenting your code requires only a few small steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Before you can instrument an operation, you first have to obtain a <code>Tracer</code>, which has the central role of keeping track of trace and span information, from the (usually global) tracer provider. We’ll discuss this in more detail in <a data-type="xref" href="#section_ch11_tracing_obtain_tracer">“Obtaining a tracer”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once you have a handle to your <code>Tracer</code> you can use it to create and start the <code>Span</code> value that is the actual value that you’ll use to instrument your code. We’ll cover this in some detail in <a data-type="xref" href="#section_ch11_tracing_starting_and_ending_spans">“Starting and ending spans”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, you can also choose to add metadata to your spans, including human-readable, timestamped messages called <em>events</em>, and key/value pairs called <em>attributes</em>. We’ll cover span metadata in <a data-type="xref" href="#section_ch11_tracing_span_metadata">“Setting span metadata”</a>.<a data-type="indexterm" data-primary="events" id="idm45983615838776"/><a data-type="indexterm" data-primary="attributes" id="idm45983615838072"/></p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch11_tracing_imports">&#13;
<h5>OpenTelemetry Tracing Imports</h5>&#13;
<p>There are many, many packages in the OpenTelemetry framework. Fortunately, for the purposes of this section, we’ll be able to focus on just a subset of these.</p>&#13;
&#13;
<p>The examples in this section were created using OpenTelemetry v0.17.0, which was the latest release at the time of writing. If you choose to follow along with the code presented in this section, you’ll need to import the following packages from that release:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/exporters/stdout"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/exporters/trace/jaeger"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/label"</code>&#13;
    <code class="nx">export</code> <code class="s">"go.opentelemetry.io/otel/sdk/export/trace"</code>&#13;
    <code class="nx">sdktrace</code> <code class="s">"go.opentelemetry.io/otel/sdk/trace"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/trace"</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>As usual, the complete code examples are available in <a href="https://oreil.ly/SznMj">the GitHub repository</a> associated with this book.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Creating the tracing exporters"><div class="sect3" id="section_ch11_tracing_creating_the_exporters">&#13;
<h3>Creating the tracing exporters</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tracing exporters" data-seealso="Console Exporter, Jaeger Exporter" id="idm45983615815352"/>The first thing you have to do when using OpenTelemetry is create and configure your exporters. Tracing exporters implement the <code>SpanExporter</code> interface, which in OpenTelemetry v0.17.0 lives in the <code>go.opentelemetry.io/otel/sdk/export/trace</code> package, which is often aliased to <code>export</code> to reduce package naming collisions.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="exporters" data-seealso="tracing exporters" id="idm45983615812568"/>You may recall from <a data-type="xref" href="#section_ch11_otel_components">“The OpenTelemetry Components”</a> that OpenTelemetry exporters are in-process plug-ins that know how to convert metric or trace data and send it to a particular destination. This destination may be local (<code>stdout</code> or a log file) or remote (such as Jaeger, or a commercial solution like Honeycomb or Lightstep).</p>&#13;
&#13;
<p>If you want to do anything worthwhile with the instrumentation data you collect, you’ll need at least one exporter. One is usually enough, but you can define as many as you like, should you have the need. Exporters are instantiated and configured once at program startup, before being passed to the OpenTelemetry SDK. This will be covered in more detail in <a data-type="xref" href="#section_ch11_tracing_create_provider">“Creating a tracer provider”</a>.</p>&#13;
&#13;
<p>OpenTelemetry comes with a number of included exporters for both tracing and metrics. Two of these are demonstrated in the following.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The Console Exporter"><div class="sect4" id="idm45983615807560">&#13;
<h4>The Console Exporter</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Console Exporter" id="idm45983615806120"/><a data-type="indexterm" data-primary="JSON" id="idm45983615805416"/>OpenTelemetry’s Console Exporter allows you to write telemetry data as JSON to standard output. This is very handy for debugging or writing to log files. The Console Exporter is noteworthy in that it can also be used to export metric telemetry, as we’ll see in <a data-type="xref" href="#section_ch11_metrics">“Metrics”</a>.</p>&#13;
&#13;
<p>Creating an instance of the Console Exporter is just a matter of calling <code>stdout.NewExporter</code>, which in OpenTelemetry v0.17.0 lives in the <code>go.opentelemetry.io/otel/exporters/stdout</code> package.</p>&#13;
&#13;
<p>Like most exporters’ creation functions, <code>stdout.NewExporter</code>, is a variadic function that can accept zero or more configuration options. We demonstrate with one of these—the option to “pretty-print” its JSON output—here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">stdExporter</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">stdout</code><code class="p">.</code><code class="nx">NewExporter</code><code class="p">(</code>&#13;
    <code class="nx">stdout</code><code class="p">.</code><code class="nx">WithPrettyPrint</code><code class="p">(),</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>In the preceding snippet, we use the <code>stdout.NewExporter</code> function, which returns both our exporter and an <code>error</code> value. We’ll see what its output looks like when we run our example in <a data-type="xref" href="#section_ch11_tracing_all_together">“Putting It All Together: Tracing”</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For more information about the Console Exporter, please refer to its page in the <a href="https://oreil.ly/PEfAI">relevant OpenTelemetry documentation</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The Jaeger Exporter"><div class="sect4" id="idm45983615797720">&#13;
<h4>The Jaeger Exporter</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Jaeger Exporter" id="ch11_term5"/>The Console Exporter may be useful for logging and debugging, but OpenTelemetry also includes a number of exporters designed to forward data to specialized backends, such as the Jaeger Exporter.</p>&#13;
&#13;
<p>The Jaeger Exporter (as its name suggests) knows how to encode tracing telemetry data to the <a href="https://oreil.ly/uMAfg">Jaeger</a> distributed tracing system. You can retrieve an exporter value using the <code>jaeger.NewRawExporter</code> function, as shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">jaegerEndpoint</code> <code class="o">:=</code> <code class="s">"http://localhost:14268/api/traces"</code>&#13;
<code class="nx">serviceName</code> <code class="o">:=</code> <code class="s">"fibonacci"</code>&#13;
&#13;
<code class="nx">jaegerExporter</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">jaeger</code><code class="p">.</code><code class="nx">NewRawExporter</code><code class="p">(</code>&#13;
    <code class="nx">jaeger</code><code class="p">.</code><code class="nx">WithCollectorEndpoint</code><code class="p">(</code><code class="nx">jaegerEndpoint</code><code class="p">),</code>&#13;
    <code class="nx">jaeger</code><code class="p">.</code><code class="nx">WithProcess</code><code class="p">(</code><code class="nx">jaeger</code><code class="p">.</code><code class="nx">Process</code><code class="p">{</code>&#13;
        <code class="nx">ServiceName</code><code class="p">:</code> <code class="nx">serviceName</code><code class="p">,</code>&#13;
    <code class="p">}),</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>In OpenTelemetry v0.17.0, the Jaeger Exporter can be found in the <code>go.opentelemetry.io/otel/exporter/trace/jaeger</code> package.</p>&#13;
&#13;
<p>You may have noticed that <code>jaeger.NewRawExporter</code> works a lot like <code>stdout.NewExporter</code> in that it’s a variadic function that accepts zero or more configuration options, returning an <code>export.SpanExporter</code> (the Jaeger Exporter) and an <code>error</code> value.</p>&#13;
&#13;
<p>The options passed to <code>jaeger.NewRawExporter</code> are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>jaeger.WithCollectorEndpoint</code>, which is used to define the URL that points to the target Jaeger process’s HTTP collector endpoint</p>&#13;
</li>&#13;
<li>&#13;
<p><code>jaeger.WithProcess</code>, which allows you to set information about the exporting process, in this case the service’s name</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are quite a few other configuration options available, but only two are used for the sake of brevity. If you’re interested in more detail, please refer to its page in the <a href="https://oreil.ly/dOpd5">relevant OpenTelemetry documentation</a>.<a data-type="indexterm" data-primary="Jaeger Exporter" data-startref="ch11_term5" id="idm45983615682696"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch11_what_is_jaeger">&#13;
<h5>What Is Jaeger?</h5>&#13;
<p><a data-type="indexterm" data-primary="Jaeger" id="idm45983615679912"/><a data-type="indexterm" data-primary="OpenZipkin" id="idm45983615679208"/><a href="https://oreil.ly/uMAfg">Jaeger</a> is an open source distributed tracing system inspired by Google’s seminal 2010 paper<sup><a data-type="noteref" id="idm45983615677880-marker" href="ch11.xhtml#idm45983615677880">7</a></sup> describing its Dapper distributed systems tracing infrastructure, and the earlier <a href="https://zipkin.io">OpenZipkin</a> project.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Uber Technologies" id="idm45983615674536"/><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983615673832"/>Originally developed (in Go) as an internal project by Uber Technologies, it was released as open source under the Apache license in November 2016. In September of 2017, it became the Cloud Native Computing Foundation’s 12th hosted project, and advanced to graduated status in October 2019.</p>&#13;
&#13;
<p>Among its features is support for multiple storage backends (including in-memory storage for testing setups) and a modern web UI.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Creating a tracer provider"><div class="sect3" id="section_ch11_tracing_create_provider">&#13;
<h3>Creating a tracer provider</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tracer provider" data-seealso="global tracer provider" id="ch11_term6"/>In order to generate traces, you first have to create and initialize a <em>tracer provider</em>, represented in OpenTelemetry by the <code>TracerProvider</code> type. In OpenTelemetry v0.17.0, it lives in the <code>go.opentelemetry.io/otel/sdk/trace</code> package, which is usually aliased to <code>sdktrace</code> to avoid naming collisions.</p>&#13;
&#13;
<p>A <code>TracerProvider</code> is a stateful value that serves as the main entry point for the OpenTelemetry tracing API, including, as we’ll see in the next section, providing access to the <code>Tracer</code> that in turn serves as the provider for new <code>Span</code> values.</p>&#13;
&#13;
<p>To create a tracer provider, we use the <code>sdktrace.NewTracerProvider</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">tp</code> <code class="o">:=</code> <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">NewTracerProvider</code><code class="p">(</code>&#13;
    <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">WithSyncer</code><code class="p">(</code><code class="nx">stdExporter</code><code class="p">),</code>&#13;
    <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">WithSyncer</code><code class="p">(</code><code class="nx">jaegerExporter</code><code class="p">))</code></pre>&#13;
&#13;
<p>In this example, the two exporters that we created in <a data-type="xref" href="#section_ch11_tracing_creating_the_exporters">“Creating the tracing exporters”</a>—<code>stdExporter</code> and <code>jaegerExporter</code>—are provided to <code>sdktrace.NewTracerProvider</code>, instructing the SDK to use them for exporting telemetry data.</p>&#13;
&#13;
<p>There are several other options that can be provided to <code>sdktrace.NewTracerProvider</code>, including defining a <code>Batcher</code> or a <code>SpanProcessor</code>. These are (reluctantly) beyond the scope of this book, but more information on these can be found in the <a href="https://oreil.ly/BaL9M">OpenTelemetry SDK Specification</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Setting the global tracer provider"><div class="sect3" id="section_ch11_tracing_set_global_tracerprovider">&#13;
<h3>Setting the global tracer provider</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="global tracer provider" id="idm45983615614552"/>Once you’ve created your tracer provider, it’s generally a good practice to set it as your global tracer provider via the <code>SetTracerProvider</code> function. In OpenTelemetry v0.17.0, this and all of OpenTelemetry’s global options live in the <code>go.opentelemetry.io/otel</code> package.</p>&#13;
&#13;
<p>Here we set the global tracer provider to be the value of <code>tp</code>, which we created in the previous section:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">otel</code><code class="p">.</code><code class="nx">SetTracerProvider</code><code class="p">(</code><code class="nx">tp</code><code class="p">)</code></pre>&#13;
&#13;
<p>Setting the global tracer provider makes it discoverable via the <code>otel.GetTracerProvider</code> function. This allows libraries and other dependencies that use the OpenTelemetry API to more easily discover the SDK and emit telemetry data:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">gtp</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetTracerProvider</code><code class="p">(</code><code class="nx">tp</code><code class="p">)</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>If you don’t explicitly set a global tracer provider, <code>otel.GetTracerProvider</code> will return a no-op <code>TracerProvider</code> implementation that returns a no-op <code>Tracer</code> that provides no-op <code>Span</code> values.<a data-type="indexterm" data-primary="OpenTelemetry" data-startref="ch11_term4_2" id="idm45983615602664"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Obtaining a tracer"><div class="sect3" id="section_ch11_tracing_obtain_tracer">&#13;
<h3>Obtaining a tracer</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Tracer" id="idm45983615569880"/>In OpenTelemetry, a <code>Tracer</code> is a specialized type that keeps track of trace and span information, including what span is currently active. Before you can instrument an operation you first have to use a (usually global) tracer provider’s <code>Tracer</code> method to obtain a <code>trace.Tracer</code> value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">tr</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetTracerProvider</code><code class="p">().</code><code class="nx">Tracer</code><code class="p">(</code><code class="s">"fibonacci"</code><code class="p">)</code></pre>&#13;
&#13;
<p>TracerProvider’s <code>Tracer</code> method accepts a string parameter to set its name. By convention, Tracers are named after the component they are instrumenting, usually a library or a package.</p>&#13;
&#13;
<p>Now that you have your tracer, your next step will be to use it to create and start a new <code>Span</code> instance.<a data-type="indexterm" data-primary="tracer provider" data-startref="ch11_term6" id="idm45983615515400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Starting and ending spans"><div class="sect3" id="section_ch11_tracing_starting_and_ending_spans">&#13;
<h3>Starting and ending spans</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="spans" id="ch11_term7"/>Once you have a handle to a <code>Tracer</code>, you can use it to create and start new <code>Span</code> values representing named and timed operations within a traced workflow. In other words, a <code>Span</code> value represents the equivalent of one step in a stack trace.</p>&#13;
&#13;
<p>In OpenTelemetry v0.17.0, both the <code>Span</code> and <code>Tracer</code> interfaces can be found in the <code>go.opentelemetry.io/otel/trace</code>. Their relationship can be deduced by a quick review of Tracer’s definition code:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Tracer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Start</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">spanName</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">trace</code><code class="p">.</code><code class="nx">SpanOption</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">trace</code><code class="p">.</code><code class="nx">Span</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Yes, that’s really all there is. Tracer’s only method, <code>Start</code>, accepts three parameters: a <code>context.Context</code> value, which is the mechanism that <code>Tracer</code> uses to keep track of spans; the name of the new span, which by convention is usually the name of the function or component being evaluated; and zero or more span configuration options.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unfortunately, a discussion of the available span configurations is beyond the scope of this book, but if you’re interested, more detail is available in the <a href="https://oreil.ly/ksmfV">relevant Go Documentation</a>.</p>&#13;
</div>&#13;
&#13;
<p>Importantly, <code>Start</code> returns not just the new <code>Span</code>, but also a <code>context.Context</code>. This is a new <code>Context</code> instance derived from the one that was passed in. As we’ll see shortly, this is important when we want to create child <code>Span</code> values.</p>&#13;
&#13;
<p>Now that you have all of the pieces in place, you can begin instrumenting our code. To do this, you request a <code>Span</code> value from your <code>Tracer</code> via its <code>Start</code> method, as shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code> <code class="nx">serviceName</code> <code class="p">=</code> <code class="s">"foo"</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// EXPORTER SETUP OMITTED FOR BREVITY</code>&#13;
&#13;
    <code class="c1">// Retrieve the Tracer from the otel TracerProvider.</code>&#13;
    <code class="nx">tr</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetTracerProvider</code><code class="p">().</code><code class="nx">Tracer</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Start the root span; receive a child context (which now</code>&#13;
    <code class="c1">// contains the trace ID), and a trace.Span.</code>&#13;
    <code class="nx">ctx</code><code class="p">,</code> <code class="nx">sp</code> <code class="o">:=</code> <code class="nx">tr</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(),</code> <code class="s">"main"</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">sp</code><code class="p">.</code><code class="nx">End</code><code class="p">()</code>     <code class="c1">// End completes the span.</code>&#13;
&#13;
    <code class="nx">SomeFunction</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this snippet we use Tracer’s <code>Start</code> method to create and start a new <code>Span</code>, which returns a derived context and our <code>Span</code> value. It’s important to note that we ensure that the <code>Span</code> is ended by calling it in a <code>defer</code>, so that <code>SomeFunction</code> is entirely captured in the root <code>Span</code>.</p>&#13;
&#13;
<p>Of course, we’ll also want to instrument <code>SomeFunction</code>. Since it receives the derived context we got from the original <code>Start</code>, it can now use that <code>Context</code> to create its own subspan:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">SomeFunction</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">tr</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetTracerProvider</code><code class="p">().</code><code class="nx">Tracer</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
    <code class="nx">_</code><code class="p">,</code> <code class="nx">sp</code> <code class="o">:=</code> <code class="nx">tr</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="s">"SomeFunction"</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">sp</code><code class="p">.</code><code class="nx">End</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Do something MAGICAL here!</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The only differences between <code>main</code> and <code>SomeFunction</code> are the names of the spans and the <code>Context</code> values. It’s significant that <code>SomeFunction</code> uses the <code>Context</code> value derived from the original <code>Start</code> call in <code>main</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Setting span metadata"><div class="sect3" id="section_ch11_tracing_span_metadata">&#13;
<h3>Setting span metadata</h3>&#13;
&#13;
<p>Now that you have a <code>Span</code>, what do you do with it?</p>&#13;
&#13;
<p>If you do nothing at all, that’s okay. As long as you’ve remembered to <code>End</code> your <code>Span</code> (preferably in a <code>defer</code> statement) a minimal timeline for your function will be &#13;
<span class="keep-together">collected</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="attributes" id="idm45983615260264"/><a data-type="indexterm" data-primary="events" id="idm45983615259560"/>However, the value of your span can be enhanced with the addition of two types of metadata: <em>attributes</em> and <em>events</em>.<a data-type="indexterm" data-primary="spans" data-startref="ch11_term7" id="idm45983615257816"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Attributes"><div class="sect4" id="idm45983615256680">&#13;
<h4>Attributes</h4>&#13;
&#13;
<p>Attributes are key/value pairs that are associated with spans. They can be used later for aggregating, filtering, and grouping traces.</p>&#13;
&#13;
<p>If known ahead of time, attributes can be added when a span is created by passing them as option parameters to the <code>tr.Start</code> method using the <code>WithAttributes</code> &#13;
<span class="keep-together">function</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="p">,</code> <code class="nx">sp</code> <code class="o">:=</code> <code class="nx">tr</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="s">"attributesAtCreation"</code><code class="p">,</code>&#13;
    <code class="nx">trace</code><code class="p">.</code><code class="nx">WithAttributes</code><code class="p">(</code>&#13;
        <code class="nx">label</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"hello"</code><code class="p">,</code> <code class="s">"world"</code><code class="p">),</code> <code class="nx">label</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"foo"</code><code class="p">,</code> <code class="s">"bar"</code><code class="p">)))</code>&#13;
<code class="k">defer</code> <code class="nx">sp</code><code class="p">.</code><code class="nx">End</code><code class="p">()</code></pre>&#13;
&#13;
<p>Here we call <code>tr.Start</code> to start a new span, passing it our active <code>context.Context</code> value and a name. But <code>Start</code> is also a variadic function that can accept zero or more options, so we opt to use the <code>WithAttributes</code> function to pass two string attributes: <code>hello=world</code> and <code>foo=far</code>.</p>&#13;
&#13;
<p>The <code>WithAttributes</code> function accepts a <code>label.KeyValue</code> type, from OpenTelemetry’s <code>go.opentelemetry.io/otel/label</code> package. Values of this type can be created using the various type methods, such as <code>label.String</code> as above. Methods exist for all Go types (and more). See <a href="https://oreil.ly/AVkTG">the label package’s documentation</a> for more information.</p>&#13;
&#13;
<p>Attributes don’t have to be added at span creation time. They can be added later in a span’s lifecycle as well, as long as the span hasn’t yet been completed:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">answer</code> <code class="o">:=</code> <code class="nx">LifeTheUniverseAndEverything</code><code class="p">()</code>&#13;
<code class="nx">span</code><code class="p">.</code><code class="nx">SetAttributes</code><code class="p">(</code><code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"answer"</code><code class="p">,</code> <code class="nx">answer</code><code class="p">))</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Events"><div class="sect4" id="idm45983615256376">&#13;
<h4>Events</h4>&#13;
&#13;
<p>An <em>event</em> is a timestamped, human-readable message on a span that represents <em>something</em> happening during the span’s lifetime.</p>&#13;
&#13;
<p>For example, if your function requires exclusive access to a resource that’s under a mutex, you might find it useful to add events when you acquire and release the lock:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">span</code><code class="p">.</code><code class="nx">AddEvent</code><code class="p">(</code><code class="s">"Acquiring mutex lock"</code><code class="p">)</code>&#13;
<code class="nx">mutex</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Do something amazing.</code>&#13;
&#13;
<code class="nx">span</code><code class="p">.</code><code class="nx">AddEvent</code><code class="p">(</code><code class="s">"Releasing mutex lock"</code><code class="p">)</code>&#13;
<code class="nx">mutex</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code></pre>&#13;
&#13;
<p>If you like, you can even add attributes to your events:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">span</code><code class="p">.</code><code class="nx">AddEvent</code><code class="p">(</code><code class="s">"Canceled by external signal"</code><code class="p">,</code>&#13;
    <code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"pid"</code><code class="p">,</code> <code class="mi">1234</code><code class="p">),</code>&#13;
    <code class="nx">label</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"signal"</code><code class="p">,</code> <code class="s">"SIGHUP"</code><code class="p">))</code></pre>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Autoinstrumentation"><div class="sect3" id="section_ch11_tracing_autoinstrumentation">&#13;
<h3>Autoinstrumentation</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="autoinstrumentation" id="ch11_term8"/>Autoinstrumentation, broadly, refers to instrumentation code that you didn’t write. This is a useful feature that can spare you from a fair amount of unnecessary bookkeeping.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="OpenTelemetry" id="ch11_term9"/>OpenTelemetry supports autoinstrumentation through various wrappers and helper functions around many popular frameworks and libraries, including ones that we cover in this book, like <code>net/http</code>, <code>gorilla/mux</code>, and <code>grpc</code>.</p>&#13;
&#13;
<p>While using these functionalities doesn’t free you from having to configure OpenTelemetry at startup, they do remove some of the effort associated with having to manage your traces.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Autoinstrumenting net/http and gorilla/mux"><div class="sect4" id="idm45983615043304">&#13;
<h4>Autoinstrumenting net/http and gorilla/mux</h4>&#13;
&#13;
<p>In OpenTelemetry 0.17.0, autoinstrumentation support for both the standard <code>net/http</code> library and <code>gorilla/mux</code>, both of which we first covered in <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a> in the context of building a RESTful web service, is provided by the <code>go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp</code> package.</p>&#13;
&#13;
<p>Its use is refreshingly minimalist. Take, for example, this standard idiom in <code>net/http</code> for registering a handler function to the default mux<sup><a data-type="noteref" id="idm45983615038696-marker" href="ch11.xhtml#idm45983615038696">8</a></sup> and starting the HTTP server:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code> <code class="nx">helloGoHandler</code><code class="p">)</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":3000"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In OpenTelemetry, a handler function can be autoinstrumented by passing it to the <code>otelhttp.NewHandler</code> function, the signature for which is shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">NewHandler</code><code class="p">(</code><code class="nx">handler</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">,</code> <code class="nx">operation</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">Option</code><code class="p">)</code>&#13;
    <code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code></pre>&#13;
&#13;
<p>The <code>otelhttp.NewHandler</code> function accepts and returns a handler function. It works by wrapping the passed handler function in a second handler function that creates a span with the provided name and options, so that the original handler acts like middleware within the returned span-handling function.</p>&#13;
&#13;
<p>A typical application of the <code>otelhttp.NewHandler</code> function is shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">http</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code>&#13;
        <code class="nx">otelhttp</code><code class="p">.</code><code class="nx">NewHandler</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="nx">helloGoHandler</code><code class="p">),</code> <code class="s">"root"</code><code class="p">))</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":3000"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You’ll notice that we have to cast the handler function to a <code>http.HandlerFunc</code> before passing it to <code>otelhttp.NewHandler</code>. This wasn’t necessary before because <code>http.HandleFunc</code> performs this operation automatically before itself calling <code>http.Handle</code>.</p>&#13;
&#13;
<p>If you’re using <code>gorilla/mux</code>, the change is almost the same, except that you’re using the <code>gorilla</code> mux instead of the default mux:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">r</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">NewRouter</code><code class="p">()</code>&#13;
    <code class="nx">r</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code>&#13;
        <code class="nx">otelhttp</code><code class="p">.</code><code class="nx">NewHandler</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="nx">helloGoHandler</code><code class="p">),</code> <code class="s">"root"</code><code class="p">))</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":3000"</code><code class="p">,</code> <code class="nx">r</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You’ll need to repeat this for each handler function you want to instrument, but either way the total amount of code necessary to instrument your entire service is pretty minimal.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Autoinstrumenting gRPC"><div class="sect4" id="idm45983615042680">&#13;
<h4>Autoinstrumenting gRPC</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="OpenTelemetry" data-startref="ch11_term9" id="idm45983614813608"/><a data-type="indexterm" data-primary="gRPC" data-seealso="gRPC interceptors" id="ch11_term10"/>In OpenTelemetry 0.17.0, autoinstrumentation support for gRPC, which we introduced in <a data-type="xref" href="ch08.xhtml#chapter_8">Chapter 8</a> in the context of loosely coupled data interchange, is provided by the <code>go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc</code> package.<sup><a data-type="noteref" id="idm45983614810104-marker" href="ch11.xhtml#idm45983614810104">9</a></sup></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="gRPC interceptors" id="ch11_term11"/>Just like autoinstrumentation for <code>net/http</code>, autoinstrumentation for gRPC is very minimalist, leveraging <em>gRPC interceptors</em>. We haven’t talked about gRPC interceptors at all yet, and unfortunately a full treatment of gRPC interceptors is beyond the scope of this book. They can be described as the gRPC equivalent to middleware in <code>gorilla/mux</code>, which we leveraged in <a data-type="xref" href="ch09.xhtml#section_ch09_load_shedding">“Load shedding”</a> to implement automatic load shedding.</p>&#13;
&#13;
<p>As their name implies, gRPC interceptors can intercept gRPC requests and responses to, for example, inject information into the request, update the response before it’s returned to the client, or to implement a cross-cutting functionality like authorization, logging, or caching.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’d like to learn a little more about gRPC interceptors, the article <a href="https://oreil.ly/R0MGm">“Interceptors in gRPC-Web” on the gRPC blog</a> offers a good introduction to the subject. For a more in-depth coverage, you might want to invest in a copy of <a href="https://oreil.ly/N50q7"><em>gRPC: Up and Running</em></a> by Kasun Indrasiri and Danesh Kuruppu (O’Reilly).</p>&#13;
</div>&#13;
&#13;
<p>Taking a look at a slice of the original service code from <a data-type="xref" href="ch08.xhtml#section_ch08_implementing_grpc_service">“Implementing the gRPC service”</a>, you can see two of the operative functions:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code> <code class="o">:=</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">NewServer</code><code class="p">()</code>&#13;
<code class="nx">pb</code><code class="p">.</code><code class="nx">RegisterKeyValueServer</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">server</code><code class="p">{})</code></pre>&#13;
&#13;
<p>In the above snippet, we create a new gRPC server, and pass that along to our autogenerated code package to register it.</p>&#13;
&#13;
<p>Interceptors can be added to a gRPC server using the <code>grpc.UnaryInterceptor</code> and/or <code>grpc.StreamInterceptor</code>, the former of which is used to intercept unary (standard request–response) service methods, and the latter of which is used for intercepting streaming methods.<a data-type="indexterm" data-primary="gRPC interceptors" data-startref="ch11_term11" id="idm45983614794184"/></p>&#13;
&#13;
<p>To autoinstrument your gRPC server, you use one or both of these functions to add one or more off-the-shelf OpenTelemetry interceptors, depending on the types of requests your service handles:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">s</code> <code class="o">:=</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">NewServer</code><code class="p">(</code>&#13;
    <code class="nx">grpc</code><code class="p">.</code><code class="nx">UnaryInterceptor</code><code class="p">(</code><code class="nx">otelgrpc</code><code class="p">.</code><code class="nx">UnaryServerInterceptor</code><code class="p">()),</code>&#13;
    <code class="nx">grpc</code><code class="p">.</code><code class="nx">StreamInterceptor</code><code class="p">(</code><code class="nx">otelgrpc</code><code class="p">.</code><code class="nx">StreamServerInterceptor</code><code class="p">()),</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">pb</code><code class="p">.</code><code class="nx">RegisterKeyValueServer</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">server</code><code class="p">{})</code></pre>&#13;
&#13;
<p>While the service we built in <a data-type="xref" href="ch08.xhtml#chapter_8">Chapter 8</a> uses exclusively unary methods, the preceding snippet adds interceptors for both unary and stream methods for the sake of &#13;
<span class="keep-together">demonstration</span>.<a data-type="indexterm" data-primary="autoinstrumentation" data-startref="ch11_term8" id="idm45983614695480"/><a data-type="indexterm" data-primary="gRPC" data-startref="ch11_term10" id="idm45983614694504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Getting the current span from context"><div class="sect4" id="idm45983614814488">&#13;
<h4>Getting the current span from context</h4>&#13;
&#13;
<p>If you’re taking advantage of autoinstrumentation, a trace will automatically be created for each request. While convenient, this also means that you don’t have your current <code>Span</code> immediately on hand for you to enhance with application-specific attribute and event metadata. So, what do you do?</p>&#13;
&#13;
<p>Fear not! Since your application framework has conveniently placed the span data inside the current context, the data is easily retrievable:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">printSpanHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">req</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">ctx</code> <code class="o">:=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code>                    <code class="c1">// Get the request Context</code>&#13;
&#13;
    <code class="nx">span</code> <code class="o">:=</code> <code class="nx">trace</code><code class="p">.</code><code class="nx">SpanFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code>      <code class="c1">// Get the current span</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"current span: %v\n"</code><code class="p">,</code> <code class="nx">span</code><code class="p">)</code>  <code class="c1">// Why not print the span?</code>&#13;
<code class="p">}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983614689640">&#13;
<h5>What About the Clients?</h5>&#13;
<p>For a complete distributed tracing experience, tracing metadata has to be forwarded across service boundaries. That means you have to instrument on the client side as well.</p>&#13;
&#13;
<p>The good news is that OpenTelemetry supports autoinstrumentation of <code>http</code> and gRPC clients.</p>&#13;
&#13;
<p>Unfortunately, there isn’t enough space available in this chapter to cover client autoinstrumentation in any detail. Examples of both <code>http</code> and <code>gRPC</code> client autoinstrumentation are available in <a href="https://oreil.ly/SznMj">the GitHub repository associated with this book</a>, however.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Putting It All Together: Tracing"><div class="sect2" id="section_ch11_tracing_all_together">&#13;
<h2>Putting It All Together: Tracing</h2>&#13;
&#13;
<p>Using all the parts that we’ve discussed in this section, let’s now build a small web service. Because we’re going to instrument this service with tracing, the ideal service would make a whole lot of function calls, but would still be pretty small.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Fibonacci service" id="ch11_term12"/>We’re going to build a Fibonacci service. Its requirements are very minimal: it will be able to accept an HTTP GET request, in which the <em>n</em>th Fibonacci number can be requested using parameter <code>n</code> on the GET query string. For example, to request the sixth Fibonacci number, you should be able to <code>curl</code> the service as: <code>http://localhost:3000?n=6</code>.</p>&#13;
&#13;
<p>To do this, we’ll use a total of three functions. Starting from the inside and working our way out, these are:</p>&#13;
<dl>&#13;
<dt>The service API</dt>&#13;
<dd>&#13;
<p>This will do the Fibonacci computation proper—at the request of the service handler—by recursively calling itself, with each call generating its own span.</p>&#13;
</dd>&#13;
<dt>The service handler</dt>&#13;
<dd>&#13;
<p>This is an HTTP handler function as defined by the <code>net/http</code> package, which will be used just like in <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a> to receive the client request, call the service API, and return the result in the response.</p>&#13;
</dd>&#13;
<dt>The main function</dt>&#13;
<dd>&#13;
<p>In the <code>main</code> function, the OpenTelemetry exporters are created and registered, the service handler function is provided to the HTTP framework, and the HTTP server is started.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The Fibonacci service API"><div class="sect3" id="section_ch11_tracing_service_api">&#13;
<h3>The Fibonacci service API</h3>&#13;
&#13;
<p>The service API at the very core of the service is where the actual computation is performed. In this case, it’s a concurrent implementation of the Fibonacci method to calculate the <em>n</em>th Fibonacci number.</p>&#13;
&#13;
<p>Just like any good service API, this function doesn’t know (or care) how it’s being used, so it has no knowledge of HTTP requests or responses:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Fibonacci</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">n</code> <code class="kt">int</code><code class="p">)</code> <code class="kd">chan</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="nx">ch</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">int</code><code class="p">)</code>&#13;
&#13;
    <code class="k">go</code> <code class="kd">func</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="nx">tr</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetTracerProvider</code><code class="p">().</code><code class="nx">Tracer</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
&#13;
        <code class="nx">cctx</code><code class="p">,</code> <code class="nx">sp</code> <code class="o">:=</code> <code class="nx">tr</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code>&#13;
            <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"Fibonacci(%d)"</code><code class="p">,</code> <code class="nx">n</code><code class="p">),</code>&#13;
            <code class="nx">trace</code><code class="p">.</code><code class="nx">WithAttributes</code><code class="p">(</code><code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"n"</code><code class="p">,</code> <code class="nx">n</code><code class="p">)))</code>&#13;
        <code class="k">defer</code> <code class="nx">sp</code><code class="p">.</code><code class="nx">End</code><code class="p">()</code>&#13;
&#13;
        <code class="nx">result</code> <code class="o">:=</code> <code class="mi">1</code>&#13;
        <code class="k">if</code> <code class="nx">n</code> <code class="p">&gt;</code> <code class="mi">1</code> <code class="p">{</code>&#13;
            <code class="nx">a</code> <code class="o">:=</code> <code class="nx">Fibonacci</code><code class="p">(</code><code class="nx">cctx</code><code class="p">,</code> <code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>&#13;
            <code class="nx">b</code> <code class="o">:=</code> <code class="nx">Fibonacci</code><code class="p">(</code><code class="nx">cctx</code><code class="p">,</code> <code class="nx">n</code><code class="o">-</code><code class="mi">2</code><code class="p">)</code>&#13;
            <code class="nx">result</code> <code class="p">=</code> <code class="o">&lt;-</code><code class="nx">a</code> <code class="o">+</code> <code class="o">&lt;-</code><code class="nx">b</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="nx">sp</code><code class="p">.</code><code class="nx">SetAttributes</code><code class="p">(</code><code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"result"</code><code class="p">,</code> <code class="nx">result</code><code class="p">))</code>&#13;
&#13;
        <code class="nx">ch</code> <code class="o">&lt;-</code> <code class="nx">result</code>&#13;
    <code class="p">}()</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">ch</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the <code>Fibonacci</code> function doesn’t know how it’s being used, but it <em>does</em> know about the OpenTelemetry package. Autoinstrumentation can only trace what it wraps. Anything within the API will need to instrument itself.</p>&#13;
&#13;
<p>This function’s use of <code>otel.GetTracerProvider</code> ensures that it’ll get the global &#13;
<span class="keep-together"><code>TracerProvider</code></span>, assuming that it was configured by the consumer. If no global tracer provider has been set, these calls will be no-ops.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For extra credit, take a minute to add support for <code>Context</code> cancellation to the <code>Fibonacci</code> function.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The Fibonacci service handler"><div class="sect3" id="idm45983614416456">&#13;
<h3>The Fibonacci service handler</h3>&#13;
&#13;
<p>This is an HTTP handler function as defined by the <code>net/http</code> package.</p>&#13;
&#13;
<p>It’ll be used in our service just like in <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>: to receive the client request, call the service API, and return the result in the response:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">fibHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">req</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
    <code class="kd">var</code> <code class="nx">n</code> <code class="kt">int</code>&#13;
&#13;
    <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">URL</code><code class="p">.</code><code class="nx">Query</code><code class="p">()[</code><code class="s">"n"</code><code class="p">])</code> <code class="o">!=</code> <code class="mi">1</code> <code class="p">{</code>&#13;
        <code class="nx">err</code> <code class="p">=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"wrong number of arguments"</code><code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="nx">n</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">strconv</code><code class="p">.</code><code class="nx">Atoi</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">URL</code><code class="p">.</code><code class="nx">Query</code><code class="p">()[</code><code class="s">"n"</code><code class="p">][</code><code class="mi">0</code><code class="p">])</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">http</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="s">"couldn't parse index n"</code><code class="p">,</code> <code class="mi">400</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Retrieve the current context from the incoming request</code>&#13;
    <code class="nx">ctx</code> <code class="o">:=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Call the child function, passing it the request context.</code>&#13;
    <code class="nx">result</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">Fibonacci</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="nx">n</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Get the Span associated with the current context and</code>&#13;
    <code class="c1">// attach the parameter and result as attributes.</code>&#13;
    <code class="k">if</code> <code class="nx">sp</code> <code class="o">:=</code> <code class="nx">trace</code><code class="p">.</code><code class="nx">SpanFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code> <code class="nx">sp</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">sp</code><code class="p">.</code><code class="nx">SetAttributes</code><code class="p">(</code>&#13;
            <code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"parameter"</code><code class="p">,</code> <code class="nx">n</code><code class="p">),</code>&#13;
            <code class="nx">label</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"result"</code><code class="p">,</code> <code class="nx">result</code><code class="p">))</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Finally, send the result back in the response.</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintln</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that it doesn’t have to create or end a <code>Span</code>; autoinstrumentation will do that &#13;
<span class="keep-together">for us.</span></p>&#13;
&#13;
<p>It <em>does</em>, however, set some attributes on the current span. To do this, it uses <code>trace.SpanFromContext</code> to retrieve the current span from the request context. Once it has the span, it’s free to add whatever metadata it likes.<a data-type="indexterm" data-primary="Fibonacci service" data-startref="ch11_term12" id="idm45983614222808"/></p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The <code>trace.SpanFromContext</code> function will return <code>nil</code> if it can’t find a <code>Span</code> associated with the <code>Context</code> passed to it.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The service Main function"><div class="sect3" id="idm45983614218808">&#13;
<h3>The service Main function</h3>&#13;
&#13;
<p>At this point, all of the hard work has been done. All we have left to do is configure OpenTelemetry, register the handler function with the default HTTP mux, and start the service:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code> <code class="p">(</code>&#13;
    <code class="nx">jaegerEndpoint</code> <code class="p">=</code> <code class="s">"http://localhost:14268/api/traces"</code>&#13;
    <code class="nx">serviceName</code>    <code class="p">=</code> <code class="s">"fibonacci"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Create and configure the console exporter</code>&#13;
    <code class="nx">stdExporter</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">stdout</code><code class="p">.</code><code class="nx">NewExporter</code><code class="p">(</code>&#13;
        <code class="nx">stdout</code><code class="p">.</code><code class="nx">WithPrettyPrint</code><code class="p">(),</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Create and configure the Jaeger exporter</code>&#13;
    <code class="nx">jaegerExporter</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">jaeger</code><code class="p">.</code><code class="nx">NewRawExporter</code><code class="p">(</code>&#13;
        <code class="nx">jaeger</code><code class="p">.</code><code class="nx">WithCollectorEndpoint</code><code class="p">(</code><code class="nx">jaegerEndpoint</code><code class="p">),</code>&#13;
        <code class="nx">jaeger</code><code class="p">.</code><code class="nx">WithProcess</code><code class="p">(</code><code class="nx">jaeger</code><code class="p">.</code><code class="nx">Process</code><code class="p">{</code>&#13;
            <code class="nx">ServiceName</code><code class="p">:</code> <code class="nx">serviceName</code><code class="p">,</code>&#13;
        <code class="p">}),</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Create and configure the TracerProvider exporter using the</code>&#13;
    <code class="c1">// newly created exporters.</code>&#13;
    <code class="nx">tp</code> <code class="o">:=</code> <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">NewTracerProvider</code><code class="p">(</code>&#13;
        <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">WithSyncer</code><code class="p">(</code><code class="nx">stdExporter</code><code class="p">),</code>&#13;
        <code class="nx">sdktrace</code><code class="p">.</code><code class="nx">WithSyncer</code><code class="p">(</code><code class="nx">jaegerExporter</code><code class="p">))</code>&#13;
&#13;
    <code class="c1">// Now we can register tp as the otel trace provider.</code>&#13;
    <code class="nx">otel</code><code class="p">.</code><code class="nx">SetTracerProvider</code><code class="p">(</code><code class="nx">tp</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Register the autoinstrumented service handler</code>&#13;
    <code class="nx">http</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code>&#13;
        <code class="nx">otelhttp</code><code class="p">.</code><code class="nx">NewHandler</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="nx">fibHandler</code><code class="p">),</code> <code class="s">"root"</code><code class="p">))</code>&#13;
&#13;
    <code class="c1">// Start the service listening on port 3000</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":3000"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the majority of the main method is dedicated to creating our (console and Jaeger) exporters and configuring the tracer provider as we did in <a data-type="xref" href="#section_ch11_tracing_creating_the_exporters">“Creating the tracing exporters”</a>. Note the value of <code>jaegerEndpoint</code>, which assumes that you’ll have a local Jaeger service running. We’ll do that in the next step.</p>&#13;
&#13;
<p>The last two lines are spent autoinstrumenting and registering the handler function and starting the HTTP service, just as we did in <a data-type="xref" href="#section_ch11_tracing_autoinstrumentation">“Autoinstrumentation”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Starting your services"><div class="sect3" id="idm45983613996760">&#13;
<h3>Starting your services</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Jaeger" id="idm45983613995448"/>Before we continue, we’ll want to start a Jaeger service to receive the telemetry data provided by the Jaeger exporter that we included. For a little more background on Jaeger, see <a data-type="xref" href="#sidebar_ch11_what_is_jaeger">“What Is Jaeger?”</a>.</p>&#13;
&#13;
<p>If you have Docker installed, you can start a Jaeger service with the following &#13;
<span class="keep-together">command</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>docker run -d --name jaeger   <code class="se">\</code>&#13;
  -p 16686:16686                <code class="se">\</code>&#13;
  -p 14268:14268                <code class="se">\</code>&#13;
  jaegertracing/all-in-one:1.21</pre>&#13;
&#13;
<p>Once the service is up and running, you’ll be able to access its web interface by browsing to <code>http://localhost:16686</code>. Obviously, there won’t be any data there yet, though.</p>&#13;
&#13;
<p>Now for the fun part: start your service by running its main function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run .</pre>&#13;
&#13;
<p>Your terminal should pause. As usual, you can stop the service with a Ctrl-C.</p>&#13;
&#13;
<p>Finally, in another terminal, you can now send a request to the service:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>curl localhost:3000?n<code class="o">=</code>6&#13;
13</pre>&#13;
&#13;
<p>After a short pause, you should be rewarded with a result. In this case, 13.</p>&#13;
&#13;
<p>Be careful with the value of <code>n</code>. If you make it <code>n</code> too large, it might take the service a long time to respond, or even crash.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Console exporter output"><div class="sect3" id="section_ch11_tracing_console_exporter_output">&#13;
<h3>Console exporter output</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="JSON" id="idm45983613917576"/>Now that you’ve issued a request to your service, take a look at the terminal you used to start your service. You should see several JSON blocks that resemble the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nt">"SpanContext"</code><code class="p">:{</code>&#13;
            <code class="nt">"TraceID"</code><code class="p">:</code><code class="s2">"4253c86eb68783546b8ae3b5e59b4a0c"</code><code class="p">,</code>&#13;
            <code class="nt">"SpanID"</code><code class="p">:</code><code class="s2">"817822981fc2fb30"</code><code class="p">,</code>&#13;
            <code class="nt">"TraceFlags"</code><code class="p">:</code><code class="mi">1</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nt">"ParentSpanID"</code><code class="p">:</code><code class="s2">"0000000000000000"</code><code class="p">,</code>&#13;
        <code class="nt">"SpanKind"</code><code class="p">:</code><code class="mi">1</code><code class="p">,</code>&#13;
        <code class="nt">"Name"</code><code class="p">:</code><code class="s2">"main"</code><code class="p">,</code>&#13;
        <code class="nt">"StartTime"</code><code class="p">:</code><code class="s2">"2020-11-27T13:50:29.739725-05:00"</code><code class="p">,</code>&#13;
        <code class="nt">"EndTime"</code><code class="p">:</code><code class="s2">"2020-11-27T13:50:29.74044542-05:00"</code><code class="p">,</code>&#13;
        <code class="nt">"Attributes"</code><code class="p">:[</code>&#13;
            <code class="p">{</code>&#13;
                <code class="nt">"Key"</code><code class="p">:</code><code class="s2">"n"</code><code class="p">,</code>&#13;
                <code class="nt">"Value"</code><code class="p">:{</code>&#13;
                    <code class="nt">"Type"</code><code class="p">:</code><code class="s2">"INT64"</code><code class="p">,</code>&#13;
                    <code class="nt">"Value"</code><code class="p">:</code><code class="mi">6</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">},</code>&#13;
            <code class="p">{</code>&#13;
                <code class="nt">"Key"</code><code class="p">:</code><code class="s2">"result"</code><code class="p">,</code>&#13;
                <code class="nt">"Value"</code><code class="p">:{</code>&#13;
                    <code class="nt">"Type"</code><code class="p">:</code><code class="s2">"INT64"</code><code class="p">,</code>&#13;
                    <code class="nt">"Value"</code><code class="p">:</code><code class="mi">13</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">],</code>&#13;
        <code class="nt">"ChildSpanCount"</code><code class="p">:</code><code class="mi">1</code><code class="p">,</code>&#13;
        <code class="nt">"InstrumentationLibrary"</code><code class="p">:{</code>&#13;
            <code class="nt">"Name"</code><code class="p">:</code><code class="s2">"fibonacci"</code><code class="p">,</code>&#13;
            <code class="nt">"Version"</code><code class="p">:</code><code class="s2">""</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Console Exporter" id="idm45983613943832"/>These JSON objects are the output of the Console Exporter (which, remember, we’ve configured to pretty-print). There should be one per span, which is quite a few.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="root spans" id="idm45983613814856"/>The preceding example (which has been pruned slightly) is from the root span. As you can see, it includes quite a few interesting bits of data, including its start and end times, and its trace and span IDs. It even includes the two attributes that we explicitly set: the input value <code>n</code>, and the result of our query.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Viewing your results in Jaeger"><div class="sect3" id="idm45983613813384">&#13;
<h3>Viewing your results in Jaeger</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Jaeger" id="idm45983613811976"/>Now that you’ve generated your trace and sent it to Jaeger, it’s time to visualize it. Jaeger just happens to provide a slick web UI for exactly that purpose!</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Fibonacci service" id="idm45983613810712"/>To check it out, browse to <code>http://localhost:16686</code> with your favorite web browser. Select Fibonacci in the Service dropdown, and click the Find traces button. You should be presented with output similar to that shown in <a data-type="xref" href="#img_ch11_jaeger_screenshot1">Figure 11-3</a>.</p>&#13;
&#13;
<p>Each bar in the visualization represents a single span. You can even view a specific span’s data by clicking on it, which reveals the same data that was contained in the (quite verbose) console output that you saw in <a data-type="xref" href="#section_ch11_tracing_console_exporter_output">“Console exporter output”</a>.<a data-type="indexterm" data-primary="tracing" data-startref="ch11_term4" id="idm45983613806840"/></p>&#13;
&#13;
<figure><div id="img_ch11_jaeger_screenshot1" class="figure">&#13;
<img src="Images/cngo_1103.png" alt="cngo 1103" width="1251" height="980"/>&#13;
<h6><span class="label">Figure 11-3. </span>Screenshot of the Jaeger interface, displaying the results of a concurrent Fibonacci call</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Metrics"><div class="sect1" id="section_ch11_metrics">&#13;
<h1>Metrics</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metrics" id="ch11_term13"/>Metrics is the collection of numerical data about a component, process, or activity over time. The number of potential metric sources is vast, and includes (but isn’t limited to) things like computing resources (CPU, memory used, disk and network I/O), infrastructure (instance replica count, autoscaling events), applications (request count, error count), and business metrics (revenue, customer sign-ups, bounce rate, cart abandonment). Of course, these are just a handful of trivial examples. For a complex system, the <em>cardinality</em> can range into the many thousands, or even millions.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="sample" id="idm45983613799752"/><a data-type="indexterm" data-primary="Prometheus" id="idm45983613799048"/><a data-type="indexterm" data-primary="labels" id="idm45983613798376"/>A metric data point, representing one observation of a particular aspect of the target (such as the number of hits an endpoint has received), is called a <em>sample</em>. Each sample has a name, a value, and a millisecond-precision timestamp. Also—at least in modern systems like <a href="https://prometheus.io">Prometheus</a>—a set of key-value pairs called <em>labels</em>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch11_cardinality">&#13;
<h5>Cardinality</h5>&#13;
<p><a data-type="indexterm" data-primary="cardinality" id="idm45983613793960"/><a data-type="indexterm" data-primary="observability" data-secondary="concepts of" data-seealso="cardinality" id="idm45983613793256"/><em>Cardinality</em> is an important concept in observability. It has its origins in set theory, where it’s defined as the number of elements in a set. For example, the set <math alttext="upper A equals StartSet 1 comma 2 comma 3 comma 5 comma 8 EndSet">&#13;
  <mrow>&#13;
    <mi>A</mi>&#13;
    <mo>=</mo>&#13;
    <mo>{</mo>&#13;
    <mn>1</mn>&#13;
    <mo>,</mo>&#13;
    <mn>2</mn>&#13;
    <mo>,</mo>&#13;
    <mn>3</mn>&#13;
    <mo>,</mo>&#13;
    <mn>5</mn>&#13;
    <mo>,</mo>&#13;
    <mn>8</mn>&#13;
    <mo>}</mo>&#13;
  </mrow>&#13;
</math> contains five elements, so <math alttext="upper A">&#13;
  <mi>A</mi>&#13;
</math> therefore has a cardinality of five.</p>&#13;
&#13;
<p>The term was later adopted by database designers to refer to the number of distinct values in a table column.<sup><a data-type="noteref" id="idm45983613782808-marker" href="ch11.xhtml#idm45983613782808">10</a></sup> For example, “eye color” would have a low cardinality, while “username” would be quite high.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="monitoring" id="idm45983613779928"/>More recently, however, the term “cardinality” has been adopted for monitoring, where it’s come to refer to the number of unique combinations of metric names and dimensions—the number of distinct label values attached to a particular metric—in your monitoring system. High cardinality information is critical for observability because it means that the data has many different ways that it can be queried, making it all the more likely that you’ll be able to ask it a question that you’d never thought to ask before.</p>&#13;
</div></aside>&#13;
&#13;
<p><a data-type="indexterm" data-primary="time series" id="idm45983613778296"/>By itself, a single sample is of limited use, but a sequence of successive samples with the same name and labels—a <em>time series</em>—can be incredibly useful. As illustrated in <a data-type="xref" href="#img_ch11_time_series">Figure 11-4</a>, collecting samples as a time series allows metrics to be easily visualized by plotting the data points on a graph, in turn making it easier to see trends or to observe anomalies or outliers.</p>&#13;
&#13;
<figure><div id="img_ch11_time_series" class="figure">&#13;
<img src="Images/cngo_1104.png" alt="cngo 1104" width="507" height="223"/>&#13;
<h6><span class="label">Figure 11-4. </span>Arranging samples as a time series allows them to be graphically visualized</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the above figure, we show a time series of the metric <code>aws.ec2.network_in</code> for one AWS EC2 instance. Time is on the x-axis (specifically, one month spanning November–December 2020). The y-axis represents the instantaneous rate at which the instance is receiving network data at that moment. Visualizing the time series &#13;
<span class="keep-together">this way,</span> it becomes obvious that traffic to the instance spikes each weekday. &#13;
<span class="keep-together">Interestingly</span>, November 25–27—the days spanning the day before to the day after Thanksgiving in the United States—are the exceptions.</p>&#13;
&#13;
<p>The true power of metrics, however, isn’t its ability to be visually represented for human eyes: it’s that its numerical nature makes it particularly amenable to mathematical modeling. For example, you might use trend analysis to detect anomalies or predict future states, which in turn can inform decisions or trigger alerts.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Push Versus Pull Metric Collection"><div class="sect2" id="idm45983613770392">&#13;
<h2>Push Versus Pull Metric Collection</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metric collection" id="idm45983613768984"/>There are two primary architectures in the universe of metrics: push-based and pull-based (so called because of the relationship between the components being monitored and the collector backend).</p>&#13;
&#13;
<p>In push-based metrics, monitored components “push” their data to a central collector backend. In pull-based metrics, the inverse is true: the collector actively retrieves metrics by “pulling” them from HTTP endpoints exposed by the monitored components (or by sidecar services deployed for this purpose, also confusingly called “exporters”; see <a data-type="xref" href="#sidebar_ch11_prometheus_exporters">“Prometheus Exporters”</a>). Both approaches are illustrated in <a data-type="xref" href="#img_ch11_push_vs_pull">Figure 11-5</a>.</p>&#13;
&#13;
<figure><div id="img_ch11_push_vs_pull" class="figure">&#13;
<img src="Images/cngo_1105.png" alt="cngo 1105" width="1049" height="315"/>&#13;
<h6><span class="label">Figure 11-5. </span>Push-based metrics (left) send telemetry directly to a central collector backend; pull-based metrics (right) are actively scraped by the collector from exposed metric endpoints</h6>&#13;
</div></figure>&#13;
&#13;
<p>What follows is a short description of each of these approaches, along with a very limited list of some arguments for and against each approach. Unfortunately, there are bounteous arguments, many quite nuanced—far too nuanced to delve into here—so we’ll have to be content with some of the common ones.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Push-based metric collection"><div class="sect3" id="idm45983613762472">&#13;
<h3>Push-based metric collection</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metric collection" data-secondary="push-based metric collection" id="idm45983613761256"/><a data-type="indexterm" data-primary="push-based metric collection" id="idm45983613760216"/><a data-type="indexterm" data-primary="Ganglia" id="idm45983613759528"/><a data-type="indexterm" data-primary="Graphite" id="idm45983613758856"/><a data-type="indexterm" data-primary="StatsD" id="idm45983613758184"/>In push-based metric collection, an application, either directly or via a parallel agent process, periodically sends data to a central collector backend. Push implementations, like Ganglia, Graphite, and StatsD, tend to be the most common (even default) approach, perhaps in part because the push model tends to be quite a bit easier to reason about.</p>&#13;
&#13;
<p>Push messages are typically unidirectional, being emitted by the monitored components or monitoring agent and sent to a central collector. This places a bit less burden on the network relative to the (bidirectional) pull model, and can reduce the complexity of the network security model, since components don’t have to make a metrics endpoint accessible to the collector. It’s also easier to use the push model to monitor highly ephemeral components such as short-lived containers or serverless functions.</p>&#13;
&#13;
<p>There are some downsides to the push model, though. First, you need to know where to send your request. While there are lots of ways of doing this, each has its downside, ranging from hardcoded addresses (which are hard to change) to DNS lookups or service discovery (which may add unacceptable latency). Scaling can also sometimes be an issue, in that it’s entirely possible for a large number of components to effectively DDoS your collector backend.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Pull-based metric collection"><div class="sect3" id="idm45983613754968">&#13;
<h3>Pull-based metric collection</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metric collection" data-secondary="pull-based metric collection" id="idm45983613753560"/><a data-type="indexterm" data-primary="pull-based metric collection" id="idm45983613752520"/>In the pull-based collection model, the collector backend periodically (on some configurable cadence) scrapes a metric endpoint exposed by a component, or by a proxy deployed for this purpose. Perhaps the best-known example of a pull-based system is <a href="https://prometheus.io">Prometheus</a>.</p>&#13;
&#13;
<p>The pull approach offers some notable advantages. Exposing a metric endpoint decouples the components being observed from the collector itself, which provides all of the benefits of loose coupling. For example, it becomes easier to monitor a service during development, or even manually inspect a component’s health with a web browser. It’s also much easier for a pull model to tell if a target is down.</p>&#13;
&#13;
<p>However, the pull approach has a discovery issue of its own, in that the collector has to somehow know where to find the services it’s supposed to monitor. This can be a bit of a challenge, particularly if your system isn’t using dynamic service discovery. Load balancers are of little help here, either, since each request will be forwarded to a random instance, greatly reducing the effective collection rate (since each of N instance receives 1/N of the pulls) and severely muddying what data is collected (since all of the instances tend to look like a single target). Finally, pull-based collection can make it somewhat harder to monitor very short-lived ephemeral things like serverless functions, necessitating a solution like the push gateway.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before less_space"><div class="sidebar" id="sidebar_ch11_what_is_prometheus">&#13;
<h5>What Is Prometheus?</h5>&#13;
<p><a data-type="indexterm" data-primary="Prometheus" id="idm45983613746648"/><a href="https://prometheus.io">Prometheus</a> is an open source monitoring and alerting toolkit. It uses a pull model over HTTP to scrape metric data, storing it as high-dimensionality values in its time series database.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="PromQL" id="idm45983613744808"/>Prometheus consists of a core server, which is responsible for the acquisition and storage of data, as well as a variety of other optional components, including a push gateway for supporting data pushes by short-lived jobs, and an alertmanager for handling alerts. While Prometheus isn’t intended as a dashboarding solution, it also provides a basic web UI and query language, PromQL, to make data more easily accessible.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="SoundCloud" id="idm45983613743288"/><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983613742584"/>In January of 2015, SoundCloud publicly released Prometheus as an open source project under the Apache license, and in May 2016, Prometheus joined the Cloud Native Computing Foundation as its second hosted project (after Kubernetes). It advanced to graduated status in August 2018.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="But which is better?"><div class="sect3" id="idm45983613741336">&#13;
<h3>But which is better?</h3>&#13;
&#13;
<p>Since the push and pull approaches are, it would seem, polar opposites of one another, it’s common for people to wonder which is better.<sup><a data-type="noteref" id="idm45983613739800-marker" href="ch11.xhtml#idm45983613739800">11</a></sup> That’s a hard question, and as is often the case when comparing technical methodologies, the answer is a resounding “it depends.”</p>&#13;
&#13;
<p>Of course, that’s never stopped a sufficiently motivated programmer from stridently arguing one side or another, but at the end of the day, the “better” approach is the one that satisfies the requirements of your system. Of course (and quite unsatisfyingly) that could be both. We technical types abhor ambiguity, yet it stubbornly insists on existing anyway.</p>&#13;
&#13;
<p>So, I will close this section with the words of Brian Brazil, a core developer of &#13;
<span class="keep-together">Prometheus</span>:</p>&#13;
<blockquote>&#13;
<p>From an engineering standpoint, in reality, the question of push versus pull largely doesn’t matter. In either case, there’s advantages and disadvantages, and with engineering effort, you can work around both cases.<sup><a data-type="noteref" id="idm45983613735976-marker" href="ch11.xhtml#idm45983613735976">12</a></sup></p></blockquote>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Metrics with OpenTelemetry"><div class="sect2" id="idm45983613733432">&#13;
<h2>Metrics with OpenTelemetry</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="OpenTelemetry" id="ch11_term15"/>As of the time of writing, the OpenTelemetry metrics API is still in alpha, so it still has a few rough spots to be ironed out and a few inconsistencies with the tracing API that are yet to be resolved.</p>&#13;
&#13;
<p>That being said, the considerable private and community support behind OpenTelemetry, coupled with its quite impressive rate of development, make it appropriate not just for inclusion in this book, but as the most likely candidate to become the gold standard for metric telemetry for the next several years at least.</p>&#13;
&#13;
<p>For the most part, OpenTelemetry metrics work a lot like traces, but are different enough to possibly cause some confusion. For both tracing and metric instrumentation, the configuration phase is executed exactly once in a program, usually in the <code>main</code> function, and includes the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The first step is to create and configure the appropriate exporter for the target backend. Metric exporters implement the &#13;
<span class="keep-together"><code>metric.Exporter</code></span> interface, which in OpenTelemetry v0.17.0 is located in the <code>go.opentelemetry.io/otel/sdk/export/metric</code> package. As we’ll discuss in <a data-type="xref" href="#section_ch11_metrics_creating_the_exporters">“Creating the metric exporters”</a>, several stock exporters are included with OpenTelemetry, but unlike trace exporters, you can currently only use one metric exporter at a time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Before instrumenting your code for metrics, the exporter is used to define the global “meter provider,” which will serve as your program’s main entry point into the OpenTelemetry metric API throughout its lifetime. As we’ll see in <a data-type="xref" href="#section_ch11_metrics_set_global_provider">“Setting the global meter provider”</a>, this makes the meter exporter discoverable via the <code>otel.GetMeterProvider</code> function, which allows libraries and other dependencies that use the OpenTelemetry API to more easily access the SDK and emit telemetry data.</p>&#13;
</li>&#13;
<li>&#13;
<p>If your metric backend uses a pull-based design like Prometheus, you’ll have to expose a metric endpoint that it can pull from. You’ll see how the Prometheus exporter leverages Go’s standard <code>http</code> package to do this in <a data-type="xref" href="#section_ch11_metrics_expose_endpoint">“Exposing the metrics endpoint”</a>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Once the configuration is complete, instrumenting your code requires only a few small steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p><a data-type="indexterm" data-primary="Meter" id="ch11_term17"/>Before you can instrument an operation, you first have to obtain a <code>Meter</code>, the structure through which all metric collection is configured and reported, from the meter provider. We’ll discuss this in more detail in <a data-type="xref" href="#section_ch11_metrics_obtain_meter">“Obtaining a meter”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, once you have a <code>Meter</code>, you can use it to instrument your code. There are two ways this can be done, either by explicitly recording measurements, or by creating <em>observers</em> that can autonomously and asynchronously collect data. Both of these approaches are covered in <a data-type="xref" href="#section_ch11_metrics_instruments">“Metric instruments”</a>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch11_metric_imports">&#13;
<h5>OpenTelemetry Metrics Imports</h5>&#13;
<p>There are many, many packages in the OpenTelemetry framework. Fortunately, for the purposes of this section, we’ll be able to focus on just a subset of these.</p>&#13;
&#13;
<p>The examples in this section were created using OpenTelemetry v0.17.0, which was the latest release at the time of writing. If you choose to follow along with this section, you’ll need to import the following packages from that release:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"go.opentelemetry.io/otel"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/exporters/metric/prometheus"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/label"</code>&#13;
    <code class="s">"go.opentelemetry.io/otel/metric"</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>As usual, the complete code examples are available in <a href="https://oreil.ly/SznMj">the GitHub repository</a> associated with this book.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Creating the metric exporters"><div class="sect3" id="section_ch11_metrics_creating_the_exporters">&#13;
<h3>Creating the metric exporters</h3>&#13;
&#13;
<p>Just like with tracing, the first thing you have to do when using OpenTelemetry for metrics is create and configure your exporters. Metric exporters implement the &#13;
<span class="keep-together"><code>metric.Exporter</code></span> interface, which in OpenTelemetry v0.17.0 lives in the <code>go.opentelemetry.io/otel/sdk/export/metric</code> package.</p>&#13;
&#13;
<p>The way that you create metric exporters varies a little between implementations, but it’s typical for an exporter to have a <code>NewExportPipeline</code> builder function, at least in the standard OpenTelemetry packages.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Prometheus" data-seealso="Prometheus exporter" id="idm45983613643848"/><a data-type="indexterm" data-primary="Prometheus exporter" id="ch11_term16"/>To get an instance of the Prometheus exporter, for example, you would use the <code>NewExportPipeline</code> function from the <code>go.opentelemetry.io/otel/exporters/metric/prometheus</code> package:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">prometheusExporter</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">prometheus</code><code class="p">.</code><code class="nx">NewExportPipeline</code><code class="p">(</code><code class="nx">prometheus</code><code class="p">.</code><code class="nx">Config</code><code class="p">{})</code></pre>&#13;
&#13;
<p>The above snippet creates the exporter and configures it according the directions specified by the passed <code>prometheus.Config</code> value. Any behaviors not overridden by the <code>Config</code> will use the recommended options.</p>&#13;
&#13;
<p>The <code>prometheus.Config</code> parameter also allows you to specify a variety of custom behaviors. Unfortunately, the specifics are beyond the scope of this book, but if you’re interested the <a href="https://oreil.ly/fKIzt">exporter Config code</a> and the code for <a href="https://oreil.ly/biCJn">the Prometheus Go client</a> are fairly straightforward.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Setting the global meter provider"><div class="sect3" id="section_ch11_metrics_set_global_provider">&#13;
<h3>Setting the global meter provider</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="meter provider" id="idm45983613598184"/>Where OpenTelemetry tracing has the “tracer provider” that provides <code>Tracer</code> values, OpenTelemetry metrics has the <em>meter provider</em>, which provides the <code>Meter</code> values through which all metric collection is configured and reported.</p>&#13;
&#13;
<p>You may recall that when working with tracing exporters, defining the global tracer provider requires two steps: creating and configuring a tracer provider instance, and then setting that instance as the global tracer provider.</p>&#13;
&#13;
<p>The meter provider works a little differently: rather than using one or more exporters to create and define a provider (as is the case with the <code>TracerProvider</code>), a meter provider is typically retrieved <em>from</em> the metric exporter, and then passed directly to the <code>otel.SetMeterProvider</code> function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Get the meter provider from the exporter.</code>&#13;
<code class="nx">mp</code> <code class="o">:=</code> <code class="nx">prometheusExporter</code><code class="p">.</code><code class="nx">MeterProvider</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Set it as the global meter provider.</code>&#13;
<code class="nx">otel</code><code class="p">.</code><code class="nx">SetMeterProvider</code><code class="p">(</code><code class="nx">mp</code><code class="p">)</code></pre>&#13;
&#13;
<p>An unfortunate consequence of this design is that you’re limited to using only one metric exporter at a time, since the meter provider is provided by the exporter instead of the other way around. Obviously, this is a significant deviation from how the tracing API works, and I expect it to change as the OpenTracing metrics API moves into beta.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There’s also a <code>prometheus.InstallNewPipeline</code> convenience function that can be used instead of explicitly calling the &#13;
<span class="keep-together"><code>prometheus.NewExportPipeline</code></span> and <code>otel.SetMeterProvider</code> functions.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Exposing the metrics endpoint"><div class="sect3" id="section_ch11_metrics_expose_endpoint">&#13;
<h3>Exposing the metrics endpoint</h3>&#13;
&#13;
<p>Because Prometheus is pull-based, any telemetry data we want to send it must be exposed through an HTTP endpoint that the collector can scrape.</p>&#13;
&#13;
<p>To do this, we can make use of Go’s standard <code>http</code> package, which, as we’ve shown several times in this book, requires minimal configuration, and is rather straightforward to use.</p>&#13;
&#13;
<p>To review what we first introduced in <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>, starting a minimal HTTP server in Go requires at least two calls:</p>&#13;
&#13;
<ul class="pagebreak-before less_space">&#13;
<li>&#13;
<p><code>http.Handle</code> to register a handler function that implements the <code>http.Handler</code> interface</p>&#13;
</li>&#13;
<li>&#13;
<p><code>http.ListenAndServe</code> to start the server listening</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>But the OpenTelemetry Prometheus exporter has a pretty nifty trick up its sleeve: it implements the <code>http.Handler</code> interface, which allows it to be passed directly to <code>http.Handle</code> to act as a handler function for the metric endpoint! See the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Register the exporter as the handler for the "/metrics" pattern.</code>&#13;
<code class="nx">http</code><code class="p">.</code><code class="nx">Handle</code><code class="p">(</code><code class="s">"/metrics"</code><code class="p">,</code> <code class="nx">prometheusExporter</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Start the HTTP server listening on port 3000.</code>&#13;
<code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":3000"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">))</code></pre>&#13;
&#13;
<p>In this example, we pass the Prometheus exporter directly into <code>http.Handle</code> to register it as the handler for the pattern “/metrics.” It’s hard to get more convenient than that.<a data-type="indexterm" data-primary="OpenTelemetry" data-startref="ch11_term15" id="idm45983613504776"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Ultimately, the name of your metrics endpoint is up to you, but<br/>&#13;
<code>metrics</code> is the most common choice. It’s also where Prometheus looks by default.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch11_prometheus_exporters">&#13;
<h5>Prometheus Exporters</h5>&#13;
<p>It’s relatively straightforward to expose a metrics endpoint if your application is a standard web service written in Go. But what if you want to collect JMX data from a JVM-based application, query metrics from a PostgreSQL database, or system metrics from a deployed Linux or Windows instance?</p>&#13;
&#13;
<p>Unfortunately, not all of the things you’ll want to collect data on are things that you control, and very few of them natively expose their own metrics endpoints.</p>&#13;
&#13;
<p>In this (very common) scenario, the typical pattern is to deploy a <em>Prometheus exporter</em>. A Prometheus exporter (not to be confused with an OpenTelemetry exporter) is a specialized adapter that runs as a service to collect the desired metric data and expose it on a metrics endpoint.</p>&#13;
&#13;
<p>As of the time of writing, there are over 200 different Prometheus exporters <a href="https://oreil.ly/ZppOm">listed in the Prometheus documentation</a>, and many more community-built exporters that aren’t. You can check that page for an up-to-date list, but some of the most popular are:</p>&#13;
<dl class="pagebreak-before less_space">&#13;
<dt><a data-type="indexterm" data-primary="Node Exporter" id="idm45983613495832"/><a href="https://oreil.ly/lq2Rv">Node Exporter</a></dt>&#13;
<dd>&#13;
<p>Exposes hardware and OS metrics exposed by *NIX kernels.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Windows Exporter" id="idm45983613493448"/><a href="https://oreil.ly/2LIFK">Windows Exporter</a></dt>&#13;
<dd>&#13;
<p>Exposes hardware and OS metrics exposed by Windows.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="JMX Exporter" id="idm45983613491064"/><a href="https://oreil.ly/rY0jg">JMX Exporter</a></dt>&#13;
<dd>&#13;
<p>Scrapes and expose MBeans of a <a href="https://oreil.ly/11HLz">JMX</a> target.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="PostgreSQL Exporter" id="idm45983613487960"/><a href="https://oreil.ly/yhZrn">PostgreSQL Exporter</a></dt>&#13;
<dd>&#13;
<p>Retrieves and exposes PostgreSQL server metrics.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Redis Exporter" id="idm45983613485512"/><a href="https://oreil.ly/XRkfl">Redis Exporter</a></dt>&#13;
<dd>&#13;
<p>Retrieves and exposes Redis server metrics.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Blackbox Exporter" id="idm45983613483064"/><a href="https://oreil.ly/VuM0U">Blackbox Exporter</a></dt>&#13;
<dd>&#13;
<p>Allows blackbox probing of endpoints over HTTP, HTTPS, DNS, TCP, or ICMP.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="Push Gateway" id="idm45983613480680"/><a href="https://oreil.ly/JxO3w">Push Gateway</a></dt>&#13;
<dd>&#13;
<p>A metrics cache that lets ephemeral and batch jobs expose their metrics by pushing them to an intermediary. Technically a core component of Prometheus rather than a distinct exporter.<a data-type="indexterm" data-primary="Prometheus exporter" data-seealso="Blackbox Exporter, JMX Exporter, Node Exporter, PostgreSQL Exporter, Push Gateway, Redis Exporter,Windows Exporter" data-startref="ch11_term16" id="idm45983613478520"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Obtaining a meter"><div class="sect3" id="section_ch11_metrics_obtain_meter">&#13;
<h3>Obtaining a meter</h3>&#13;
&#13;
<p>Before you can instrument an operation, you first have to obtain a <code>Meter</code> value from a <code>MeterProvider</code>.</p>&#13;
&#13;
<p>As you’ll see in <a data-type="xref" href="#section_ch11_metrics_instruments">“Metric instruments”</a>, the <code>metric.Meter</code> type, which lives in the <code>go.opentelemetry.io/otel/metric</code> package, is the means by which all metric collection is configured and reported, either as record batches of synchronous measurements or asynchronous observations.</p>&#13;
&#13;
<p>You can retrieve a <code>Meter</code> value as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">meter</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetMeterProvider</code><code class="p">().</code><code class="nx">Meter</code><code class="p">(</code><code class="s">"fibonacci"</code><code class="p">)</code></pre>&#13;
&#13;
<p>You may have noticed that snippet looks almost exactly like the expression used to get a <code>Tracer</code> back in <a data-type="xref" href="#section_ch11_tracing_obtain_tracer">“Obtaining a tracer”</a>. In fact, <code>otel.GetMeterProvider</code> is exactly equivalent to <code>otel.GetTracerProvider</code>, and works pretty much the same way.</p>&#13;
&#13;
<p>The <code>otel.GetMeterProvider</code> function returns the registered global meter provider. If none is registered then a default meter provider is returned that forwards the <code>Meter</code> interface to the first registered <code>Meter</code> value.</p>&#13;
&#13;
<p>The provider’s <code>Meter</code> method returns an instance of the <code>metric.Meter</code> type. It accepts a string parameter representing the instrumentation name, which by convention is named after the library or package it’s instrumenting.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Metric instruments"><div class="sect3" id="section_ch11_metrics_instruments">&#13;
<h3>Metric instruments</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="instruments" data-see="metric instruments" id="idm45983613422088"/><a data-type="indexterm" data-primary="metric instruments" id="idm45983613421112"/>Once you have a <code>Meter</code>, you can create <em>instruments</em>, which you can use to make measurements and to instrument your code. However, just as there are several different types of metrics, there are several types of instruments. The type of instrument you use will depend on the type of measurement you’re making.<a data-type="indexterm" data-primary="Meter" data-startref="ch11_term17" id="idm45983613419176"/></p>&#13;
&#13;
<p>All told, there are 12 <em>kinds</em> of instruments available, each with some combination of <em>synchronicity</em>, <em>accumulation</em> behavior, and data type.</p>&#13;
&#13;
<p>The first of these properties, <em>synchronicity</em>, determines how an instrument collects and transmits data:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Synchronous instruments</em> are explicitly called by the user to record a metric, as we’ll see in <a data-type="xref" href="#section_ch11_metrics_instruments_synchronous">“Synchronous instruments”</a>.<a data-type="indexterm" data-primary="metric instruments" data-secondary="synchronous instruments" id="idm45983613413480"/><a data-type="indexterm" data-primary="synchronous instruments" id="idm45983613412504"/></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Asynchronous instruments</em>, also called <em>observers</em>, can monitor a specific property and are asynchronously called by the SDK during collection. We’ll demonstrate in <a data-type="xref" href="#section_ch11_metrics_instruments_asynchronous">“Asynchronous instruments”</a>.<a data-type="indexterm" data-primary="metric instruments" data-secondary="asynchronous instruments" id="idm45983613409320"/>&#13;
<a data-type="indexterm" data-primary="asynchronous instruments" id="idm45983613408152"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Second, each instrument has an <em>accumulation</em> behavior that describes how it tracks the acquisition of new data:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Additive</em> instruments are used to track a sum that can go arbitrarily up or down, like a gauge. They’re typically used for measured values like temperatures or current memory usage, but also “counts” that can go up and down, like the number of concurrent requests.<a data-type="indexterm" data-primary="metric instruments" data-secondary="additive instruments" id="idm45983613385000"/><a data-type="indexterm" data-primary="additive instruments" id="idm45983613384024"/></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Additive monotonic</em> instruments track <a href="https://oreil.ly/RESQ1">monotonically increasing</a> values that can only increase (or be reset to zero on restart), like a counter. Additive monotonic values are often used for metrics like the number of requests served, tasks completed, or errors.<a data-type="indexterm" data-primary="metric instruments" data-secondary="additive monotonic instruments" id="idm45983613381256"/><a data-type="indexterm" data-primary="additive monotonic instruments" id="idm45983613380248"/></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Grouping</em> instruments are intended for capturing a distribution, like a histogram. A grouping instrument samples observations (usually things like request durations or response sizes) and counts them in configurable buckets. It also provides a sum of all observed values.<a data-type="indexterm" data-primary="metric instruments" data-secondary="grouping instruments" id="idm45983613378168"/><a data-type="indexterm" data-primary="grouping instruments" id="idm45983613377192"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Finally, each of the previous six kinds of instruments has types that support either <code>float64</code> or <code>int64</code> input values, for a total of 12 kinds of instruments. Each has an associated type in the <code>go.opentelemetry.io/otel/metric</code> package, summarized in <a data-type="xref" href="#table_ch11_metrics_instruments">Table 11-1</a>.</p>&#13;
<table id="table_ch11_metrics_instruments">&#13;
<caption><span class="label">Table 11-1. </span>The 12 kinds of OpenTelemetry metric instruments, by synchronicity and accumulation behavior.</caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>Synchronous</th>&#13;
<th>Asynchronous</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Additive</strong></p></td>&#13;
<td><p><code><span class="keep-together">Float64UpDownCounter</span>, &#13;
<span class="keep-together">Int64UpDownCounter</span></code></p></td>&#13;
<td><p><code><span class="keep-together">Float64UpDownSumObserver</span>, &#13;
<span class="keep-together">Int64UpDownSumObserver</span></code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Additive, Monotonic</strong></p></td>&#13;
<td><p><code><span class="keep-together">Float64Counter</span>, &#13;
<span class="keep-together">Int64Counter</span></code></p></td>&#13;
<td><p><code><span class="keep-together">Float64SumObserver</span>, &#13;
<span class="keep-together">Int64SumObserver</span></code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Grouping</strong></p></td>&#13;
<td><p><code><span class="keep-together">Float64ValueRecorder</span>, &#13;
<span class="keep-together">Int64ValueRecorder</span></code></p></td>&#13;
<td><p><code><span class="keep-together">Float64ValueObserver</span>, &#13;
<span class="keep-together">Int64ValueObserver</span></code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Each of the 12 types has an associated constructor function on the <code>metric.Meter</code> type, all with a similar signature. For example, the <code>NewInt64Counter</code> method looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">Meter</code><code class="p">)</code> <code class="nx">NewInt64Counter</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">options</code> <code class="o">...</code><code class="nx">InstrumentOption</code><code class="p">)</code>&#13;
    <code class="p">(</code><code class="nx">Int64Counter</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>All 12 constructor methods accept the name of the metric as a <code>string</code>, and zero or more <code>metric.InstrumentOption</code> values, just like the <code>NewInt64Counter</code> method. Similarly, each returns an instrument value of the appropriate type with the given name and options, and can return an error if the name is empty or otherwise invalid, or if the instrument is duplicate registered.</p>&#13;
&#13;
<p>For example, a function that uses the <code>NewInt64Counter</code> method to get a new &#13;
<span class="keep-together"><code>metric.Int64Counter</code></span> from a <code>metric.Meter</code> value looks something like the &#13;
<span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// The requests counter instrument. As a synchronous instrument,</code>&#13;
<code class="c1">// we'll need to keep it so we can use it later to record data.</code>&#13;
<code class="kd">var</code> <code class="nx">requests</code> <code class="nx">metric</code><code class="p">.</code><code class="nx">Int64Counter</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">buildRequestsCounter</code><code class="p">()</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">err</code> <code class="kt">error</code>&#13;
&#13;
    <code class="c1">// Retrieve the meter from the meter provider.</code>&#13;
    <code class="nx">meter</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetMeterProvider</code><code class="p">().</code><code class="nx">Meter</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Get an Int64Counter for a metric called "fibonacci_requests_total".</code>&#13;
    <code class="nx">requests</code><code class="p">,</code> <code class="nx">err</code> <code class="p">=</code> <code class="nx">meter</code><code class="p">.</code><code class="nx">NewInt64Counter</code><code class="p">(</code><code class="s">"fibonacci_requests_total"</code><code class="p">,</code>&#13;
        <code class="nx">metric</code><code class="p">.</code><code class="nx">WithDescription</code><code class="p">(</code><code class="s">"Total number of Fibonacci requests."</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">err</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note how we retain a reference to the instrument in the form of the <code>requests</code> global variable. For reasons I’ll discuss shortly, this is generally specific to synchronous instruments.</p>&#13;
&#13;
<p>But while the <code>metric.Int64Counter</code> happens to be a synchronous instrument, the takeaway here is that synchronous and asynchronous instruments are both obtained in the same way: via the corresponding <code>Metric</code> constructor method. How they’re used, however, differs significantly, as we’ll see in the subsequent sections.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Synchronous instruments"><div class="sect4" id="section_ch11_metrics_instruments_synchronous">&#13;
<h4>Synchronous instruments</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metric instruments" data-secondary="synchronous instruments" id="ch11_term18_2"/><a data-type="indexterm" data-primary="synchronous instruments" id="ch11_term18"/>The initial steps to using a synchronous instrument—retrieving a meter from the meter provider and creating an instrument—are largely the same for both synchronous and asynchronous instruments. We saw these in the previous section.</p>&#13;
&#13;
<p>However, using synchronous instruments differs from using asynchronous instruments in that they’re explicitly exercised in your code logic when recording a metric, which means you have to be able to refer to your instrument after it’s been created. That’s why the above example uses a global <code>requests</code> variable.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="metric instruments" data-secondary="additive instruments" id="idm45983613233592"/><a data-type="indexterm" data-primary="additive instruments" id="idm45983613232392"/>Perhaps the most common application is to record individual events by incrementing a counter when an event occurs. The additive instruments even have an <code>Add</code> method for this. The following example uses the <code>requests</code> value that we created in the previous example by adding a call to <code>requests.Add</code> to the API’s <code>Fibonacci</code> function that was originally defined in <a data-type="xref" href="#section_ch11_tracing_service_api">“The Fibonacci service API”</a>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Define our labels here so that we can easily reuse them.</code>&#13;
<code class="kd">var</code> <code class="nx">labels</code> <code class="p">=</code> <code class="p">[]</code><code class="nx">label</code><code class="p">.</code><code class="nx">KeyValue</code><code class="p">{</code>&#13;
    <code class="nx">label</code><code class="p">.</code><code class="nx">Key</code><code class="p">(</code><code class="s">"application"</code><code class="p">).</code><code class="nx">String</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">),</code>&#13;
    <code class="nx">label</code><code class="p">.</code><code class="nx">Key</code><code class="p">(</code><code class="s">"container_id"</code><code class="p">).</code><code class="nx">String</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"HOSTNAME"</code><code class="p">)),</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">Fibonacci</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">n</code> <code class="kt">int</code><code class="p">)</code> <code class="kd">chan</code> <code class="kt">int</code> <code class="p">{</code>&#13;
    <code class="c1">// Use the Add method on out metric.Int64Counter instance</code>&#13;
    <code class="c1">// to increment the counter value.</code>&#13;
    <code class="nx">requests</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">labels</code><code class="o">...</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// The rest of the function...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the <code>requests.Add</code> method—which is safe for concurrent use—accepts three parameters:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The first parameter is the current context in the form of a <code>context.Context</code> value. This is common for all of the synchronous instrument methods.</p>&#13;
</li>&#13;
<li>&#13;
<p>The second parameter is the number to increment by. In this case, each call to <code>Fibonacci</code> increases the call counter by one.</p>&#13;
</li>&#13;
<li>&#13;
<p>The third parameter is zero or more <code>label.KeyValue</code> values that represent the labels to associate with the data points. This increases the cardinality of the metrics, which, as discussed in <a data-type="xref" href="#sidebar_ch11_cardinality">“Cardinality”</a>, is incredibly useful.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><a data-type="indexterm" data-primary="data labels" id="idm45983613136184"/>Data labels are a powerful tool that allow you to describe data beyond which service or instance emitted it. They can allow you to ask questions of your data that you hadn’t thought of before.</p>&#13;
</div>&#13;
&#13;
<p>It’s also possible to group multiple metrics and report them as a batch. This works slightly differently than the <code>Add</code> method you saw in the previous example, though. Specifically, for each metric in the batch, you need to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Collect the value or values you want to record.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pass each value to its appropriate instrument’s <code>Measurement</code> method, which returns a <code>metric.Measurement</code> value that wraps your metric and provides some supporting metadata.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pass all of the <code>metric.Measurement</code> values to the <code>meter.RecordBatch</code>, which atomically records the entire batch of measurements.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>These steps are demonstrated in the following example, in which we use the <code>runtime</code> package to retrieve two values—the amount of memory and the number of goroutines used by the process—and emit them to the metrics collector:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">updateMetrics</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Retrieve the meter from the meter provider.</code>&#13;
    <code class="nx">meter</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetMeterProvider</code><code class="p">().</code><code class="nx">Meter</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Create the instruments that we'll use to report memory</code>&#13;
    <code class="c1">// and goroutine values. Error values ignored for brevity.</code>&#13;
    <code class="nx">mem</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">meter</code><code class="p">.</code><code class="nx">NewInt64UpDownCounter</code><code class="p">(</code><code class="s">"memory_usage_bytes"</code><code class="p">,</code>&#13;
        <code class="nx">metric</code><code class="p">.</code><code class="nx">WithDescription</code><code class="p">(</code><code class="s">"Amount of memory used."</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
    <code class="nx">goroutines</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">meter</code><code class="p">.</code><code class="nx">NewInt64UpDownCounter</code><code class="p">(</code><code class="s">"num_goroutines"</code><code class="p">,</code>&#13;
        <code class="nx">metric</code><code class="p">.</code><code class="nx">WithDescription</code><code class="p">(</code><code class="s">"Number of running goroutines."</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">m</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">MemStats</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">{</code>&#13;
        <code class="nx">runtime</code><code class="p">.</code><code class="nx">ReadMemStats</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">m</code><code class="p">)</code>&#13;
&#13;
        <code class="c1">// Report the values to the instruments, and receive</code>&#13;
        <code class="c1">// metric.Measurement values in return.</code>&#13;
        <code class="nx">mMem</code> <code class="o">:=</code> <code class="nx">mem</code><code class="p">.</code><code class="nx">Measurement</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="nx">m</code><code class="p">.</code><code class="nx">Sys</code><code class="p">))</code>&#13;
        <code class="nx">mGoroutines</code> <code class="o">:=</code> <code class="nx">goroutines</code><code class="p">.</code><code class="nx">Measurement</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">NumGoroutine</code><code class="p">()))</code>&#13;
&#13;
        <code class="c1">// Provide the measurements (and teh context and</code>&#13;
        <code class="c1">// labels) to the meter.</code>&#13;
        <code class="nx">meter</code><code class="p">.</code><code class="nx">RecordBatch</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="nx">labels</code><code class="p">,</code> <code class="nx">mMem</code><code class="p">,</code> <code class="nx">mGoroutines</code><code class="p">)</code>&#13;
&#13;
        <code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">5</code> <code class="o">*</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When run as a goroutine, the <code>updateMetrics</code> function executes in two parts: an initial setup, and an infinite loop in which it generates and records measurements.</p>&#13;
&#13;
<p>In the set-up phase, it retrieves the <code>Meter</code>, defines some metric labels, and creates the instruments. All of these values are created exactly once and are reused in the loop. Note that in addition to types, the instruments are created with names and descriptions indicating the metrics they’re instrumenting.</p>&#13;
&#13;
<p>Inside the loop, we first use the <code>runtime.ReadMemStats</code> and <code>runtime.NumGoroutine</code> functions to retrieve the metrics we want to record (the amount of memory used and the number of running goroutines, respectively). With those values, we use the instruments’ <code>Measurement</code> methods to generate <code>metrics.Measurement</code> values for each metric.</p>&#13;
&#13;
<p>With our <code>Measurement</code> values in hand, we pass them into the <code>meter.RecordBatch</code> method—which also accepts the current <code>context.Context</code> and any labels that we want to attach to the metrics—to officially record them.<a data-type="indexterm" data-primary="metric instruments" data-secondary="synchronous instruments" data-startref="ch11_term18_2" id="idm45983612968488"/><a data-type="indexterm" data-primary="synchronous instruments" data-startref="ch11_term18" id="idm45983612967352"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Asynchronous instruments"><div class="sect4" id="section_ch11_metrics_instruments_asynchronous">&#13;
<h4>Asynchronous instruments</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="observers" data-see="asynchronous instruments" id="idm45983612964696"/><a data-type="indexterm" data-primary="metric instruments" data-secondary="asynchronous instruments" id="ch11_term19_2"/><a data-type="indexterm" data-primary="asynchronous instruments" id="ch11_term19"/>Asynchronous instruments, or <em>observers</em>, are created and configured during setup to measure a particular property, and are subsequently called by the SDK during collection. This is especially useful when you have a value you want to monitor without managing your own background recording process.</p>&#13;
&#13;
<p>Just like synchronous instruments, asynchronous instruments are created from a constructor method attached to a <code>metric.Meter</code> instance. In total, there are six such functions: a <code>float64</code> and <code>int64</code> version for each of the three accumulation behaviors. All six have a very similar signature, of which the following is representative:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">m</code> <code class="nx">Meter</code><code class="p">)</code> <code class="nx">NewInt64UpDownSumObserver</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code>&#13;
    <code class="nx">callback</code> <code class="nx">Int64ObserverFunc</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">InstrumentOption</code><code class="p">)</code>&#13;
    <code class="p">(</code><code class="nx">Int64UpDownSumObserver</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>As you can see, the <code>NewInt64UpDownSumObserver</code> accepts the name of the metric as a <code>string</code>, something called a <code>Int64ObserverFunc</code>, and zero or more instrument options (such as the metric description). Although it returns the observer value, this isn’t actually used all that often, though it can return a non-<code>nil</code> error if the name is empty, duplicate registered, or otherwise invalid.</p>&#13;
&#13;
<p>The second parameter—the <em>callback function</em>—is the heart of any asynchronous instrument. Callback functions are asynchronously called by the SDK upon data collection. There are two kinds, one each for <code>int64</code> and <code>float64</code>, but they look, feel, and work essentially the same:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Int64ObserverFunc</code> <code class="kd">func</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">metric</code><code class="p">.</code><code class="nx">Int64ObserverResult</code><code class="p">)</code></pre>&#13;
&#13;
<p>When called by the SDK, the callback functions receive the current <code>context.Context</code>, and either a <code>metric.Float64ObserverResult</code> (for <code>float64</code> observers) or &#13;
<span class="keep-together"><code>metric.Int64ObserverResult</code></span> (for <code>int64</code> observers). Both result types have an <code>Observe</code> method, which you use to report your results.</p>&#13;
&#13;
<p>This is a lot of little details, but they come together fairly seamlessly. The following function does exactly that, defining two observers:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">buildRuntimeObservers</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">meter</code> <code class="o">:=</code> <code class="nx">otel</code><code class="p">.</code><code class="nx">GetMeterProvider</code><code class="p">().</code><code class="nx">Meter</code><code class="p">(</code><code class="nx">serviceName</code><code class="p">)</code>&#13;
    <code class="nx">m</code> <code class="o">:=</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">MemStats</code><code class="p">{}</code>&#13;
&#13;
    <code class="nx">meter</code><code class="p">.</code><code class="nx">NewInt64UpDownSumObserver</code><code class="p">(</code><code class="s">"memory_usage_bytes"</code><code class="p">,</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">_</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">result</code> <code class="nx">metric</code><code class="p">.</code><code class="nx">Int64ObserverResult</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nx">runtime</code><code class="p">.</code><code class="nx">ReadMemStats</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">m</code><code class="p">)</code>&#13;
            <code class="nx">result</code><code class="p">.</code><code class="nx">Observe</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="nx">m</code><code class="p">.</code><code class="nx">Sys</code><code class="p">),</code> <code class="nx">labels</code><code class="o">...</code><code class="p">)</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">metric</code><code class="p">.</code><code class="nx">WithDescription</code><code class="p">(</code><code class="s">"Amount of memory used."</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
&#13;
    <code class="nx">meter</code><code class="p">.</code><code class="nx">NewInt64UpDownSumObserver</code><code class="p">(</code><code class="s">"num_goroutines"</code><code class="p">,</code>&#13;
        <code class="kd">func</code><code class="p">(</code><code class="nx">_</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">result</code> <code class="nx">metric</code><code class="p">.</code><code class="nx">Int64ObserverResult</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nx">result</code><code class="p">.</code><code class="nx">Observe</code><code class="p">(</code><code class="nb">int64</code><code class="p">(</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">NumGoroutine</code><code class="p">()),</code> <code class="nx">labels</code><code class="o">...</code><code class="p">)</code>&#13;
        <code class="p">},</code>&#13;
        <code class="nx">metric</code><code class="p">.</code><code class="nx">WithDescription</code><code class="p">(</code><code class="s">"Number of running goroutines."</code><code class="p">),</code>&#13;
    <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When called by <code>main</code>, the <code>buildRuntimeObservers</code> function defines two asynchronous instruments—<code>memory_usage_bytes</code> and <code>num_goroutines</code>—each with a callback function that works exactly like the data collection in the <code>updateMetrics</code> function that we defined in <a data-type="xref" href="#section_ch11_metrics_instruments_synchronous">“Synchronous instruments”</a>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="callback function" id="idm45983612676680"/>In <code>updateMetrics</code>, however, we used an infinite loop to synchronously report data. As you can see, using an asynchronous approach for non-event data is not only less work to set up and manage, but has fewer moving parts to worry about later, since there isn’t anything else to do once the observers (and their callback functions) are defined and the SDK takes over.<a data-type="indexterm" data-primary="metric instruments" data-secondary="asynchronous instruments" data-startref="ch11_term19_2" id="idm45983612675064"/><a data-type="indexterm" data-primary="asynchronous instruments" data-startref="ch11_term19" id="idm45983612673848"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Putting It All Together: Metrics"><div class="sect2" id="section_ch11_metrics_all_together">&#13;
<h2>Putting It All Together: Metrics</h2>&#13;
&#13;
<p>Now that we have an idea what metrics we’re going to collect and how, we can use them to extend the Fibonacci web service that we put together in <a data-type="xref" href="#section_ch11_tracing_all_together">“Putting It All Together: Tracing”</a>.</p>&#13;
&#13;
<p>The functionality of the service will remain unchanged. As before, it will be able to accept an <code>HTTP GET</code> request, in which the <em>n</em>th Fibonacci number can be requested using parameter <code>n</code> on the <code>GET</code> query string. For example, to request the sixth &#13;
<span class="keep-together">Fibonacci</span> number, you should be able to <code>curl</code> the service as: <code>http://localhost:3000?n=6</code>.</p>&#13;
&#13;
<p>The specific changes we’ll be making, and the metrics that we’ll be collecting, are as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Synchronously recording the API request count by adding the <code>buildRequestsCounter</code> function to <code>main</code> and instrumenting the <code>Fibonacci</code> function in the service API as we described in <a data-type="xref" href="#section_ch11_metrics_instruments_synchronous">“Synchronous instruments”</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Asynchronously recording the processes’ memory used, and number of active goroutines, by adding the <code>buildRuntimeObservers</code> described in <a data-type="xref" href="#section_ch11_metrics_instruments_asynchronous">“Asynchronous instruments”</a> to the <code>main</code> function</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Starting your services"><div class="sect3" id="idm45983612659656">&#13;
<h3>Starting your services</h3>&#13;
&#13;
<p>Once again, start your service by running its main function:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run .</pre>&#13;
&#13;
<p>As before, your terminal should pause. You can stop the service with a Ctrl-C.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Prometheus" id="ch11_term20"/>Next, you’ll start the Prometheus server. But before you do, you’ll need to create a minimal configuration file for it. Prometheus has a <a href="https://oreil.ly/h8A7f">ton of available configuration options</a>, but the following should be perfectly sufficient. Copy and paste it into a file named <code>prometheus.yml</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">scrape_configs</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">job_name</code><code class="p">:</code> <code class="l-Scalar-Plain">fibonacci</code>&#13;
  <code class="nt">scrape_interval</code><code class="p">:</code> <code class="l-Scalar-Plain">5s</code>&#13;
  <code class="nt">static_configs</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">targets</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">'host.docker.internal:3000'</code><code class="p-Indicator">]</code></pre>&#13;
&#13;
<p>This configuration defines a single target named <code>fibonacci</code> that lives at <code>host.docker.internal:3000</code> and will be scraped every five seconds (down from the default of every minute).</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983612641800">&#13;
<h5>What is host.docker.internal?</h5>&#13;
<p><a data-type="indexterm" data-primary="host.docker.internal" id="idm45983612640728"/>The name <code>host.docker.internal</code> is a special DNS name defined in Docker Desktop for both Mac and Windows that resolves to the internal IP address used by the host, allowing the container to interact with host processes.</p>&#13;
&#13;
<p>Importantly, this address is provided for development convenience and won’t work in a production environment outside of Docker Desktop for Mac and Windows (i.e., it’s not supported by default in Docker on Linux).</p>&#13;
</div></aside>&#13;
&#13;
<p>Once you’ve created the file <code>prometheus.yml</code>, you can start Prometheus. The easiest way to do this is a container using Docker:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash">docker run -d --name prometheus                             <code class="se">\</code>&#13;
  -p 9090:9090                                              <code class="se">\</code>&#13;
  -v <code class="s2">"</code><code class="si">${</code><code class="nv">PWD</code><code class="si">}</code><code class="s2">/prometheus.yml:/etc/prometheus/prometheus.yml"</code> <code class="se">\</code>&#13;
  prom/prometheus:v2.23.0</pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>If you’re using Linux for development, you’ll need to add the parameter <code>--add-host=host.docker.internal:host-gateway</code> to the above command. <em>But do not use this in production</em>.</p>&#13;
</div>&#13;
&#13;
<p>Now that your services are both running, you can send a request to the service:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>curl localhost:3000?n<code class="o">=</code>6&#13;
13</pre>&#13;
&#13;
<p>Behind the scenes, OpenTelemetry has just recorded a value for the number of requests (recursive and otherwise) made to its <code>Fibonacci</code> function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Metric endpoint output"><div class="sect3" id="idm45983612659000">&#13;
<h3>Metric endpoint output</h3>&#13;
&#13;
<p>Now that your service is running, you can always examine its exposed metrics directly with a standard curl to its <code>/metrics</code> endpoint:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl localhost:3000/metrics&#13;
# HELP fibonacci_requests_total Total number of Fibonacci requests.&#13;
# TYPE fibonacci_requests_total counter&#13;
fibonacci_requests_total{application="fibonacci",container_id="d35f0bef2ca0"} 25&#13;
# HELP memory_usage_bytes Amount of memory used.&#13;
# TYPE memory_usage_bytes gauge&#13;
memory_usage_bytes{application="fibonacci",container_id="d35f0bef2ca0"}&#13;
  7.5056128e+07&#13;
# HELP num_goroutines Number of running goroutines.&#13;
# TYPE num_goroutines gauge&#13;
num_goroutines{application="fibonacci",container_id="d35f0bef2ca0"} 6</pre>&#13;
&#13;
<p>As you can see, all three of the metrics you’re recording—as well as their types, descriptions, labels, and values—are listed here. Don’t be confused if the value of <code>container_id</code> is empty: that just means you’re not running in a container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Viewing your results in Prometheus"><div class="sect3" id="idm45983612541992">&#13;
<h3>Viewing your results in Prometheus</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Grafana" id="idm45983612540584"/>Now that you’ve started your service, started Prometheus, and run a query or two to the service to seed some data, it’s time to visualize your work in Prometheus. Again, Prometheus isn’t a full-fledged graphing solution (you’ll want to use something like <a href="https://grafana.com">Grafana</a> for that), but it does offer a simple interface for executing arbitrary queries.</p>&#13;
&#13;
<p>You can access this interface by browsing to <code>localhost:9090</code>. You should be presented with a minimalist interface with a search field. To see the value of your metric over time, enter its name in the search field, hit enter, and click the “graph” tab. You should be presented with something like the screenshot in <a data-type="xref" href="#img_ch11_prom_screenshot">Figure 11-6</a>.</p>&#13;
&#13;
<figure><div id="img_ch11_prom_screenshot" class="figure">&#13;
<img src="Images/cngo_1106.png" alt="cngo 1106" width="1137" height="702"/>&#13;
<h6><span class="label">Figure 11-6. </span>Screenshot of the Prometheus interface, displaying the value of the &#13;
<span class="keep-together"><code>fibonacci_requests_total</code></span> metric after three calls to the Fibonacci service</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now that you’re collecting data, take a moment to run a few more queries and see how the graph changes. Maybe even look at some other metrics. Enjoy!<a data-type="indexterm" data-primary="metrics" data-startref="ch11_term13" id="idm45983612531896"/><a data-type="indexterm" data-primary="Prometheus" data-startref="ch11_term20" id="idm45983612530952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Logging"><div class="sect1" id="section_ch11_logging">&#13;
<h1>Logging</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="logs" id="idm45983612515352"/><a data-type="indexterm" data-primary="events" id="idm45983612514648"/>A <em>log</em> is an immutable record of <em>events</em>—discrete occurrences that are worth recording—emitted by an application over time. Traditionally, logs were stored as append-only files, but these days, a log is just as likely to take the form of some kind of searchable data store.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="logging" data-seealso="Zap logging" id="ch11_term21"/>So, what’s there to say about logging, other than that it’s a really good idea that’s been around as long as electronic computing has? It’s the OG of observability methods.</p>&#13;
&#13;
<p>There’s actually quite a bit to say, largely because it’s really, really easy to do logging in a way that makes your life harder than it needs to be.</p>&#13;
&#13;
<p>Of the Three Pillars of Observability, logs are by far the easiest to generate. Since there’s no initial processing involved in outputting a log event, in its simplest form it’s as easy as adding a <code>print</code> statement to your code. This makes logs really good at providing lots and lots of context-rich data about what a component is doing or experiencing.</p>&#13;
&#13;
<p>But this free-form aspect to logging cuts both ways. While it’s possible (and often tempting) to output whatever you think might be useful, the verbose, unstructured logs are difficult to extract usable information from, especially at scale. To get the most out of logging, events should be structured, and that structure doesn’t come for free. It has to be intentionally considered and implemented.</p>&#13;
&#13;
<p>Another, particularly underappreciated, pitfall of logging is that generating lots of events puts significant pressure on disk and/or network I/O. It’s not unusual for half or more of available bandwidth to be consumed this way. What’s more, this pressure tends to scale linearly with load: <code>N</code> users each doing <code>M</code> things translates to <code>N*M</code> log events being emitted, with potentially disastrous consequences for scalability.</p>&#13;
&#13;
<p>Finally, for logs to be meaningfully useful, they have to be processed and stored in a way that makes them accessible. Anybody who’s ever had to manage logs at scale can tell you that it’s notoriously operationally burdensome to self-manage and self-host, and absurdly expensive to have somebody else manage and host.</p>&#13;
&#13;
<p>In the remainder of this section, we’ll first discuss some high-level practices for logging at scale, followed by how to implement them in Go.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Better Logging Practices"><div class="sect2" id="section_ch11_good_logging_practices">&#13;
<h2>Better Logging Practices</h2>&#13;
&#13;
<p>As simple as the act of logging may seem on the face of it, it’s also really easy to log in a way that makes life harder for you and anybody who has to use your logs after you. Awkward logging issues, like having to navigate unstructured logs or higher-than-expected resource consumption, which are annoying in small deployments, become major roadblocks at scale.</p>&#13;
&#13;
<p>As you’ll see, for this reason and others, the best practices around logging tend to focus on maximizing the quality, and minimizing the quantity, of logging data generated and retained.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>It goes without saying that you shouldn’t log sensitive business data or personally identifiable information.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Treat logs as streams of events"><div class="sect3" id="section_ch11_treat_logs_as_streams">&#13;
<h3>Treat logs as streams of events</h3>&#13;
&#13;
<p>How many times have you looked at log output and been confronted with an inscrutable stream of consciousness? How useful was it? Better than nothing, maybe, but probably not by much.</p>&#13;
&#13;
<p>Logs shouldn’t be treated as data sinks to be written to and forgotten until something is literally on fire, and they definitely shouldn’t be a garbage dump where you send random thoughts and observations.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="logs" data-seealso="stream of events" id="idm45983612481608"/><a data-type="indexterm" data-primary="steam of events" id="idm45983612480408"/>Instead, as we saw back in <a data-type="xref" href="ch06.xhtml#chapter_6">Chapter 6</a>, logs should be treated as a <em>stream of events</em>, and should be written, unbuffered, directly to <code>stdout</code> and <code>stderr</code>. Though seemingly simple (and perhaps somewhat counterintuitive), this small change in perspective provides a great deal of freedom.</p>&#13;
&#13;
<p>By moving the responsibility for log management out of the application code, it’s freed from concerns about implementation trivialities like routing or storage of its log events, allowing the executor to decide what happens to them.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="ELK" id="idm45983612476472"/>This approach provides quite a lot of freedom for how you manage and consume your logs. In development, you can keep an eye on your service’s behavior by sending them directly to a local terminal. In production, the execution environment can capture and redirect log events to a log indexing system like ELK or Splunk for review and analysis, or perhaps a data warehouse for long-term storage.</p>&#13;
&#13;
<p>Treat logs as streams of events, and write each event, unbuffered, directly to <code>stdout</code> and <code>stderr</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Structure events for parsing"><div class="sect3" id="section_ch11_logging_structure_events">&#13;
<h3>Structure events for parsing</h3>&#13;
&#13;
<p>Logging, in its simplest and most primitive form, is technically possible using nothing more than <code>fmt.Println</code> statements. The result, however, would be a set of unformatted strings of questionable utility.</p>&#13;
&#13;
<p>Fortunately, it’s more common for programmers to use Go’s standard <code>log</code> library, which is conveniently located and easy to use, and generates helpful timestamps. But how useful would a terabyte or so of log events formatted like the following be?</p>&#13;
&#13;
<pre data-type="programlisting">2020/11/09 02:15:10AM User 12345: GET /help in 23ms&#13;
2020/11/09 02:15:11AM Database error: connection reset by peer</pre>&#13;
&#13;
<p>Certainly, it’s better than nothing, but you’re still confronted with a mostly unstructured string, albeit an unstructured string with a timestamp. You still have to parse the arbitrary text to extract the meaningful bits.</p>&#13;
&#13;
<p>Compare that to the equivalent messages outputted by a structured logger:<sup><a data-type="noteref" id="idm45983612468360-marker" href="ch11.xhtml#idm45983612468360">13</a></sup></p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="nt">"time"</code><code class="p">:</code><code class="mi">1604888110</code><code class="p">,</code> <code class="nt">"level"</code><code class="p">:</code><code class="s2">"info"</code><code class="p">,</code> <code class="nt">"method"</code><code class="p">:</code><code class="s2">"GET"</code><code class="p">,</code> <code class="nt">"path"</code><code class="p">:</code><code class="s2">"/help"</code><code class="p">,</code>&#13;
        <code class="nt">"duration"</code><code class="p">:</code><code class="mi">23</code><code class="p">,</code> <code class="nt">"message"</code><code class="p">:</code><code class="s2">"Access"</code><code class="p">}</code>&#13;
<code class="p">{</code><code class="nt">"time"</code><code class="p">:</code><code class="mi">1604888111</code><code class="p">,</code> <code class="nt">"level"</code><code class="p">:</code><code class="s2">"error"</code><code class="p">,</code> <code class="nt">"error"</code><code class="p">:</code><code class="s2">"connection reset by peer"</code><code class="p">,</code>&#13;
        <code class="nt">"database"</code><code class="p">:</code><code class="s2">"user"</code><code class="p">,</code> <code class="nt">"message"</code><code class="p">:</code><code class="s2">"Database error"</code><code class="p">}</code></pre>&#13;
&#13;
<p>The above log structure places all of the key elements into properties of a JavaScript object, each with:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="timestamp" id="idm45983612416328"/><code>time</code></dt>&#13;
<dd>&#13;
<p>A timestamp, which is a piece of contextual information that’s critical for tracking and correlating issues. Note that the JSON example is also in an easily-parsable format that’s far less computationally expensive to extract meaning from than the first, barely structured example. When you’re processing billions of log events, little things add up.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="log level" id="idm45983612413912"/><code>level</code></dt>&#13;
<dd>&#13;
<p>A log level, which is a label that indicates the level of importance for the log event. Frequently used levels include <code>INFO</code>, <code>WARN</code>, and <code>ERROR</code>. These are also key for filtering out low-priority messages that might not be relevant in production.</p>&#13;
</dd>&#13;
<dt>One or more contextual elements</dt>&#13;
<dd>&#13;
<p>These contain background information that provides insight into the state of the application at the time of the message. The <em>entire point</em> of a log event is to express this context information.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In short, the structured log form is easier, faster, and cheaper to extract meaning from, and the results are far easier to search, filter, and aggregate.</p>&#13;
&#13;
<p>Structure your logs for parsing by computers, not for reading by humans.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Less is (way) more"><div class="sect3" id="section_ch11_less_is_way_more">&#13;
<h3>Less is (way) more</h3>&#13;
&#13;
<p>Logging isn’t free. In fact, it’s very expensive.</p>&#13;
&#13;
<p>Imagine you have a service deployed to a server running in AWS. Nothing fancy, just a standard server with a standard, general-purpose disk capable of a sustained throughput of 16 MiB/second.</p>&#13;
&#13;
<p>Let’s say that your service likes to be thorough, so it fastidiously logs events acknowledging each request, response, database call, calculation status, and various other bits of information, totaling sixteen 1024-byte events for each request the service handles. It’s a little verbose, but nothing too unusual so far.</p>&#13;
&#13;
<p>But this adds up. In a scenario in which the service handles 512 requests per second—a perfectly reasonable number for a highly concurrent service—your service would produce 8192 events/second. At 16 KiB per event, that’s a total of 8 MiB/second of log events, or <em>half of your disk’s I/O capacity</em>. That’s quite a burden.</p>&#13;
&#13;
<p>What if we skip writing to disk and forward events straight to a log-hosting service? Well, the bad news is that we then have to transfer and store our logs, and that gets expensive. If you’re sending the data across the internet to a log provider like Splunk or Datadog, you’ll have to pay your cloud provider a data transfer fee. For AWS, this amounts to US$0.08/GB, which at an average rate of 8 MiB/s—about 1 TiB every day and a half—comes to almost $250,000/year for a single instance. Fifty such instances would run more than $12 million dollars in data transfer costs alone.</p>&#13;
&#13;
<p>Obviously, this example doesn’t take into account fluctuations in load due to hour of day or day of week. But it clearly illustrates that logging can get very expensive very quickly, so log only what’s useful, and be sure to limit log generation in production by using severity thresholds. A “warning” threshold is common.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Dynamic sampling"><div class="sect3" id="section_ch11_logging_dynamic_sampling">&#13;
<h3>Dynamic sampling</h3>&#13;
&#13;
<p>Because the kind of events that are produced by debug events tend to be both high-volume and low-fidelity, it’s pretty standard practice to eliminate them from production output by setting the log level to <code>WARNING</code>. But debug logs aren’t <em>worthless</em>, are they?<sup><a data-type="noteref" id="idm45983612398728-marker" href="ch11.xhtml#idm45983612398728">14</a></sup> As it turns out, they become really useful really fast when you’re trying to chase down the root cause of an outage, which means you have to waste precious incident time turning debug logs on just long enough for you find the problem. Oh, and don’t forget to turn them off afterwards.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="dynamic sampling" id="idm45983612397384"/>However, by <em>dynamically sampling</em> your logs—recording some proportion of events and dropping the rest—you can still have your debug logs—but not too many—available in production, which can help drive down the time to recovery during an &#13;
<span class="keep-together">incident</span>.</p>&#13;
&#13;
<p>Having some debug logs in production can be <em>really</em> useful when things are on fire.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Logging with Go’s Standard log Package"><div class="sect2" id="idm45983612394120">&#13;
<h2>Logging with Go’s Standard log Package</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="logging packages" data-seealso="Go log package, Zap logging" id="idm45983612392552"/><a data-type="indexterm" data-primary="Go" data-secondary="log package" id="ch11_term22"/>Go includes a standard logging package, appropriately named <code>log</code>, that provides some basic logging features. While it’s very bare bones, it still has just about everything you need to put together a basic logging strategy.</p>&#13;
&#13;
<p>Besides importing the <code>log</code> package, using it doesn’t require any kind of setup.</p>&#13;
&#13;
<p>Its most basic functions can be leveraged with a selection of functions very similar to the various <code>fmt</code> print functions you may be familiar with:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Print</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Printf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Println</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code></pre>&#13;
&#13;
<p>You may have noticed what is perhaps the most glaring omission from the <code>log</code> package: that it doesn’t support logging levels. However, what it lacks in functionality, it makes up for in simplicity and ease of use.</p>&#13;
&#13;
<p>Here’s the most basic logging example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="s">"log"</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Hello, World!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When run, it provides the following output:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run .&#13;
2020/11/10 09:15:39 Hello, World!</pre>&#13;
&#13;
<p>As you can see, the <code>log.Print</code> function—like all of the <code>log</code> logging functions—adds a timestamp to its messages without any additional configuration.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The special logging functions"><div class="sect3" id="idm45983612263496">&#13;
<h3>The special logging functions</h3>&#13;
&#13;
<p>Although <code>log</code> sadly doesn’t support log levels, it does offer some other interesting features. Namely, a class of convenience functions that couple outputting log events with another useful action.</p>&#13;
&#13;
<p>The first of these is the <code>log.Fatal</code> functions. There are three of these, each corresponding to a different <code>log.PrintX</code> function, and each equivalent to calling its corresponding print function followed by a call to <code>os.Exit(1)</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Fatal</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Fatalf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Fatalln</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code></pre>&#13;
&#13;
<p>Similarly, <code>log</code> offers a series of <code>log.Panic</code> functions, which are equivalent to calling its corresponding <code>log.PrintX</code> followed by a call to <code>panic</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Panic</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Panicf</code><code class="p">(</code><code class="nx">format</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code>&#13;
<code class="kd">func</code> <code class="nx">Panicln</code><code class="p">(</code><code class="nx">v</code> <code class="o">...</code><code class="kd">interface</code><code class="p">{})</code></pre>&#13;
&#13;
<p>Both of these sets of functions are useful, but they’re not used nearly as often as the <code>log.Print</code> functions, typically in error handling where it makes sense to report the error and halt.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Logging to a custom writer"><div class="sect3" id="idm45983612168680">&#13;
<h3>Logging to a custom writer</h3>&#13;
&#13;
<p>By default, the <code>log</code> package prints to <code>stderr</code>, but what if you want to redirect that output elsewhere? The <code>log.SetOutput</code> function allows you to do exactly that by letting you specify a custom <code>io.Writer</code> to write to.</p>&#13;
&#13;
<p>This allows you to, for example, send your logs to a file if you want to. As we mention in <a data-type="xref" href="#section_ch11_less_is_way_more">“Less is (way) more”</a>, writing logs to files generally isn’t advisable, but it can be useful under certain circumstances.</p>&#13;
&#13;
<p>This is demonstrated in the following using <code>os.OpenFile</code> to open the target file, and using <code>log.SetOutput</code> to define it as the log writer:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"os"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// O_APPEND = Append data to the file when writing</code>&#13;
    <code class="c1">// O_CREATE = Create a new file if none exists</code>&#13;
    <code class="c1">// O_WRONLY = Open the file write-only</code>&#13;
    <code class="nx">flags</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">O_APPEND</code> <code class="p">|</code> <code class="nx">os</code><code class="p">.</code><code class="nx">O_CREATE</code> <code class="p">|</code> <code class="nx">os</code><code class="p">.</code><code class="nx">O_WRONLY</code>&#13;
&#13;
    <code class="nx">file</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">OpenFile</code><code class="p">(</code><code class="s">"log.txt"</code><code class="p">,</code> <code class="nx">flags</code><code class="p">,</code> <code class="mo">0666</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">SetOutput</code><code class="p">(</code><code class="nx">file</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Hello, World!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When run, the following is written to the file <code>log.txt</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run .<code class="p">;</code> tail log.txt&#13;
2020/11/10 09:17:05 Hello, World!</pre>&#13;
&#13;
<p>The fact that <code>log.SetOutput</code> accepts an interface means that a wide variety of destinations can be supported just by satisfying the <code>io.Writer</code> contract. You could even, if you so desired, create an <code>io.Writer</code> implementation that forwards to a log processor like Logstash or a message broker like Kafka. The possibilities are unlimited.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Log flags"><div class="sect3" id="idm45983612052760">&#13;
<h3>Log flags</h3>&#13;
&#13;
<p>The <code>log</code> package also allows you to use constants to enrich log messages with additional context information, such as the filename, line number, date, and time.</p>&#13;
&#13;
<p>For example, adding the following line to our above “Hello, World”:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">log</code><code class="p">.</code><code class="nx">SetFlags</code><code class="p">(</code><code class="nx">log</code><code class="p">.</code><code class="nx">Ldate</code> <code class="p">|</code> <code class="nx">log</code><code class="p">.</code><code class="nx">Ltime</code> <code class="p">|</code> <code class="nx">log</code><code class="p">.</code><code class="nx">Lshortfile</code><code class="p">)</code></pre>&#13;
&#13;
<p>Will result in a log output like the following:</p>&#13;
&#13;
<pre data-type="programlisting">2020/11/10 10:14:36 main.go:7: Hello, World!</pre>&#13;
&#13;
<p>As you can see, it includes the date in the local time zone (<code>log.Ldate</code>), the time in the local time zone (<code>log.Ltime</code>), and the final file name element and line number of the <code>log</code> call (<code>log.Lshortfile</code>).</p>&#13;
&#13;
<p>We don’t get any say over the order in which the log parts appear or the format in which they are presented, but if you want that kind of flexibility, you probably want to use another logging framework, such as Zap.<a data-type="indexterm" data-primary="Go" data-secondary="log package" data-startref="ch11_term22" id="idm45983612006344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The Zap Logging Package"><div class="sect2" id="idm45983612393496">&#13;
<h2>The Zap Logging Package</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Zap logging" id="ch11_term23"/>Of the Three Pillars of Observability, logging is the one that’s least supported by OpenTelemetry. Which is to say that it isn’t supported at all, at least at the time of this writing (though it will be incorporated in time).</p>&#13;
&#13;
<p>So, for now, rather than discuss the OpenTelemetry Logging API, we’ll cover another excellent library: <a href="https://oreil.ly/fjMls">Zap</a>, a JSON-formatted logger designed to allocate memory as infrequently as possible, and to use reflection and string formatting as little as possible.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Logrus" id="idm45983612000536"/>Zap is currently one of the two most popular Go logging packages, alongside <a href="https://oreil.ly/UZt5n">Logrus</a>. Logrus is actually a little more popular, but three main factors drove me to choose Zap for this book instead. First, Zap is known for its speed and low memory impact (which is useful at scale). Second, it has a “structured first” philosophy which, as I asserted in <a data-type="xref" href="#section_ch11_logging_structure_events">“Structure events for parsing”</a>, is incredibly desirable. Finally, Logrus is now in maintenance mode, and isn’t introducing any new features.</p>&#13;
&#13;
<p>How fast is Zap, exactly? It’s really fast. For a minimalist example, <a data-type="xref" href="#table_ch11_zap_benchmarks_no_context">Table 11-2</a> shows comparisons of benchmarks between several common structured logging packages, without including any context or <code>printf</code>-style templating.</p>&#13;
<table id="table_ch11_zap_benchmarks_no_context" class="pagebreak-before less_space" style="width: 90%">&#13;
<caption><span class="label">Table 11-2. </span>Relative benchmarks of structured logging packages for a message with no context or <code>printf</code>-style templating.</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Package</th>&#13;
<th>Time</th>&#13;
<th>Time % to Zap</th>&#13;
<th>Objects Allocated</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Zap</strong></p></td>&#13;
<td><p>&#13;
118 ns/op</p></td>&#13;
<td><p>&#13;
+0%</p></td>&#13;
<td><p>&#13;
0 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Zap (sugared)</strong></p></td>&#13;
<td><p>&#13;
191 ns/op</p></td>&#13;
<td><p>&#13;
+62%</p></td>&#13;
<td><p>&#13;
2 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Zerolog</strong></p></td>&#13;
<td><p>&#13;
93 ns/op</p></td>&#13;
<td><p>&#13;
-21%</p></td>&#13;
<td><p>&#13;
0 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Go-kit</strong></p></td>&#13;
<td><p>&#13;
280 ns/op</p></td>&#13;
<td><p>&#13;
+137%</p></td>&#13;
<td><p>&#13;
11 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Standard library</strong></p></td>&#13;
<td><p>&#13;
499 ns/op</p></td>&#13;
<td><p>&#13;
+323%</p></td>&#13;
<td><p>&#13;
2 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Logrus</strong></p></td>&#13;
<td><p>&#13;
3129 ns/op</p></td>&#13;
<td><p>&#13;
+2552%</p></td>&#13;
<td><p>&#13;
24 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Log15</strong></p></td>&#13;
<td><p>&#13;
3887 ns/op</p></td>&#13;
<td><p>&#13;
+3194%</p></td>&#13;
<td><p>&#13;
23 allocs/op</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>These numbers were developed using <a href="https://oreil.ly/uGbA7">Zap’s own benchmarking suite</a>, but I did examine, update, and execute the benchmarks myself. Of course, as with any benchmarking, take these numbers with a grain of salt. The two standouts here are Go’s own standard <code>log</code> library, which had a runtime about triple Zap’s standard logger, and Logrus, which took a very significant 25 times Zap’s time.</p>&#13;
&#13;
<p>But we’re supposed to use context fields, aren’t we? What does Zap look like then? Well, those results are even more striking.</p>&#13;
<table id="table_ch11_zap_benchmarks_with_context" style="width: 90%">&#13;
<caption><span class="label">Table 11-3. </span>Relative benchmarks of structured logging packages for a message with 10 context fields.</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Package</th>&#13;
<th>Time</th>&#13;
<th>Time % to Zap</th>&#13;
<th>Objects Allocated</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Zap</strong></p></td>&#13;
<td><p>&#13;
862 ns/op</p></td>&#13;
<td><p>&#13;
+0%</p></td>&#13;
<td><p>&#13;
5 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Zap (sugared)</strong></p></td>&#13;
<td><p>&#13;
1250 ns/op</p></td>&#13;
<td><p>&#13;
+45%</p></td>&#13;
<td><p>&#13;
11 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Zerolog</strong></p></td>&#13;
<td><p>&#13;
4021 ns/op</p></td>&#13;
<td><p>&#13;
+366%</p></td>&#13;
<td><p>&#13;
76 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Go-kit</strong></p></td>&#13;
<td><p>&#13;
4542 ns/op</p></td>&#13;
<td><p>&#13;
+427%</p></td>&#13;
<td><p>&#13;
105 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Logrus</strong></p></td>&#13;
<td><p>&#13;
29501 ns/op</p></td>&#13;
<td><p>&#13;
+3322%</p></td>&#13;
<td><p>&#13;
125 allocs/op</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Log15</strong></p></td>&#13;
<td><p>&#13;
29906 ns/op</p></td>&#13;
<td><p>&#13;
+3369%</p></td>&#13;
<td><p>&#13;
122 allocs/op</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Zap’s lead over Logrus has extended to a (very impressive) factor of 33X; the standard <code>log</code> library isn’t included in this table because it doesn’t even support context fields.</p>&#13;
&#13;
<p>Alright then, so how do we use it?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Creating a Zap logger"><div class="sect3" id="idm45983611901768">&#13;
<h3>Creating a Zap logger</h3>&#13;
&#13;
<p>The first step to logging with Zap is to create a <code>zap.Logger</code> value.</p>&#13;
&#13;
<p>Of course, before you do that, you first need to import the Zap package, as follows:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="s">"go.uber.org/zap"</code></pre>&#13;
&#13;
<p>Once you’ve imported Zap, you can build your <code>zap.Logger</code> instance. Zap allows you to configure several aspects of your logging behavior, but the most straightforward way to build a <code>zap.Logger</code> is to use Zap’s opinionated preset constructor functions—<code>zap.NewExample</code>, <code>zap.NewProduction</code>, and <code>zap.NewDevelopment</code>—each of which build a logger via a single function call:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">logger</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">zap</code><code class="p">.</code><code class="nx">NewProduction</code><code class="p">()</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"can't initialize zap logger: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Typically, this will be done in an <code>init</code> function and the <code>zap.Logger</code> value maintained globally. Zap loggers are safe for concurrent use.</p>&#13;
&#13;
<p>The three available presets are usually perfectly fine for small projects, but larger projects and organizations may want a bit more customization. Zap provides the <code>zap.Config</code> struct for exactly this purpose, and while the specifics are beyond the scope of this book, the <a href="https://oreil.ly/q1mHb">Zap documentation</a> describes its use in some detail.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Writing logs with Zap"><div class="sect3" id="idm45983611844040">&#13;
<h3>Writing logs with Zap</h3>&#13;
&#13;
<p>One of the more unique aspects of Zap is that every logger actually has two easily interchangeable forms—standard and “sugared”—that vary somewhat in efficiency and usability.</p>&#13;
&#13;
<p>The standard <code>zap.Logger</code> implementation emphasizes performance and type safety. It’s slightly faster than the <code>SugaredLogger</code> and allocates far less, but it only supports structured logging which does make it a little more awkward to use:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">logger</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">zap</code><code class="p">.</code><code class="nx">NewProduction</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Structured context as strongly typed Field values.</code>&#13;
<code class="nx">logger</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"failed to fetch URL"</code><code class="p">,</code>&#13;
    <code class="nx">zap</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"url"</code><code class="p">,</code> <code class="nx">url</code><code class="p">),</code>&#13;
    <code class="nx">zap</code><code class="p">.</code><code class="nx">Int</code><code class="p">(</code><code class="s">"attempt"</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code>&#13;
    <code class="nx">zap</code><code class="p">.</code><code class="nx">Duration</code><code class="p">(</code><code class="s">"backoff"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">),</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>The output of which will look something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="nt">"level"</code><code class="p">:</code><code class="s2">"info"</code><code class="p">,</code> <code class="nt">"msg"</code><code class="p">:</code><code class="s2">"failed to fetch URL"</code><code class="p">,</code>&#13;
        <code class="nt">"url"</code><code class="p">:</code><code class="s2">"http://example.com"</code><code class="p">,</code> <code class="nt">"attempt"</code><code class="p">:</code><code class="mi">3</code><code class="p">,</code> <code class="nt">"backoff"</code><code class="p">:</code><code class="s2">"1s"</code><code class="p">}</code></pre>&#13;
&#13;
<p>In contexts where performance is good but not absolutely critical (which is most of the time, probably) you can use the <code>SugaredLogger</code>, which is easily obtainable from a standard logger via its <code>Sugar</code> method.</p>&#13;
&#13;
<p>The <code>SugaredLogger</code> still provides structured logging, but its functions for doing so are loosely typed, as opposed to the standard logger’s strong context typing. Despite using runtime reflection behind the scenes, its performance is still very good.</p>&#13;
&#13;
<p>The <code>SugaredLogger</code> even includes <code>printf</code>-style logging methods, for convenience. (Remember, though, that when it comes to logging, context is king.)</p>&#13;
&#13;
<p>All of these features are demonstrated in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="nx">logger</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">zap</code><code class="p">.</code><code class="nx">NewProduction</code><code class="p">()</code>&#13;
<code class="nx">sugar</code> <code class="o">:=</code> <code class="nx">logger</code><code class="p">.</code><code class="nx">Sugar</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Structured context as loosely typed key-value pairs.</code>&#13;
<code class="nx">sugar</code><code class="p">.</code><code class="nx">Infow</code><code class="p">(</code><code class="s">"failed to fetch URL"</code><code class="p">,</code>&#13;
    <code class="s">"url"</code><code class="p">,</code> <code class="nx">url</code><code class="p">,</code>&#13;
    <code class="s">"attempt"</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code>&#13;
    <code class="s">"backoff"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">,</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">sugar</code><code class="p">.</code><code class="nx">Infof</code><code class="p">(</code><code class="s">"failed to fetch URL: %s"</code><code class="p">,</code> <code class="nx">url</code><code class="p">)</code></pre>&#13;
&#13;
<p>The output of which will look something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="nt">"level"</code><code class="p">:</code><code class="s2">"info"</code><code class="p">,</code> <code class="nt">"msg"</code><code class="p">:</code><code class="s2">"failed to fetch URL"</code><code class="p">,</code>&#13;
        <code class="nt">"url"</code><code class="p">:</code><code class="s2">"http://example.com"</code><code class="p">,</code> <code class="nt">"attempt"</code><code class="p">:</code><code class="mi">3</code><code class="p">,</code> <code class="nt">"backoff"</code><code class="p">:</code><code class="s2">"1s"</code><code class="p">}</code>&#13;
<code class="p">{</code><code class="nt">"level"</code><code class="p">:</code><code class="s2">"info"</code><code class="p">,</code> <code class="nt">"msg"</code><code class="p">:</code><code class="s2">"failed to fetch URL: http://example.com"</code><code class="p">}</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Don’t create a new <code>Logger</code> for every function. Instead, create a global instance, or use the <code>zap.L</code> or <code>zap.S</code> functions to get Zap’s global standard or sugared loggers, respectively.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Using dynamic sampling in Zap"><div class="sect3" id="idm45983611843416">&#13;
<h3>Using dynamic sampling in Zap</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="dynamic sampling" id="idm45983611623096"/>You may recall from <a data-type="xref" href="#section_ch11_logging_dynamic_sampling">“Dynamic sampling”</a> that dynamic sampling is a technique in which incoming log entries are sampled by capping recorded events to some maximum number per unit of time.</p>&#13;
&#13;
<p>If done broadly, this technique can be used to manage the CPU and I/O load of your logging while preserving a representative subset of events. If targeted to a particular class of otherwise high-volume and low-fidelity events, such as debug logs, dynamic sampling can ensure their availability for production troubleshooting without consuming too much storage.</p>&#13;
&#13;
<p>Zap supports dynamic sampling, which is configurable using the <code>zap.SamplingConfig</code> structure, shown here:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">SamplingConfig</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// Initial sets the cap on the number of events logged each second.</code>&#13;
    <code class="nx">Initial</code>    <code class="kt">int</code>&#13;
&#13;
    <code class="c1">// Thereafter sets the proportion of events that are logged each second</code>&#13;
    <code class="c1">// after Initial is exceeded. A value of 3 indicates one event in every</code>&#13;
    <code class="c1">// 3 is logged.</code>&#13;
    <code class="nx">Thereafter</code> <code class="kt">int</code>&#13;
&#13;
    <code class="c1">// Hook (if defined) is called after each "log/no log" decision.</code>&#13;
    <code class="nx">Hook</code>       <code class="kd">func</code><code class="p">(</code><code class="nx">zapcore</code><code class="p">.</code><code class="nx">Entry</code><code class="p">,</code> <code class="nx">zapcore</code><code class="p">.</code><code class="nx">SamplingDecision</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using <code>zap.SamplingConfig</code> allows you to define the number of initial events with the same level and message permitted each second (<code>Initial</code>), after which only every <em>n</em>th message (<code>Thereafter</code>) is logged. The rest are dropped.</p>&#13;
&#13;
<p>The following example demonstrates how to build a new <code>zap.Logger</code> using a preconfigured <code>zap.Config</code> instance:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
&#13;
    <code class="s">"go.uber.org/zap"</code>&#13;
    <code class="s">"go.uber.org/zap/zapcore"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">init</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">cfg</code> <code class="o">:=</code> <code class="nx">zap</code><code class="p">.</code><code class="nx">NewDevelopmentConfig</code><code class="p">()</code>&#13;
    <code class="nx">cfg</code><code class="p">.</code><code class="nx">EncoderConfig</code><code class="p">.</code><code class="nx">TimeKey</code> <code class="p">=</code> <code class="s">""</code>          <code class="c1">// Turn off timestamp output</code>&#13;
&#13;
    <code class="nx">cfg</code><code class="p">.</code><code class="nx">Sampling</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">zap</code><code class="p">.</code><code class="nx">SamplingConfig</code><code class="p">{</code>&#13;
        <code class="nx">Initial</code><code class="p">:</code>    <code class="mi">3</code><code class="p">,</code>                      <code class="c1">// Allow first 3 events/second</code>&#13;
        <code class="nx">Thereafter</code><code class="p">:</code> <code class="mi">3</code><code class="p">,</code>                      <code class="c1">// Allows 1 per 3 thereafter</code>&#13;
        <code class="nx">Hook</code><code class="p">:</code> <code class="kd">func</code><code class="p">(</code><code class="nx">e</code> <code class="nx">zapcore</code><code class="p">.</code><code class="nx">Entry</code><code class="p">,</code> <code class="nx">d</code> <code class="nx">zapcore</code><code class="p">.</code><code class="nx">SamplingDecision</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">if</code> <code class="nx">d</code> <code class="o">==</code> <code class="nx">zapcore</code><code class="p">.</code><code class="nx">LogDropped</code> <code class="p">{</code>&#13;
                <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"event dropped..."</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">},</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">logger</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">cfg</code><code class="p">.</code><code class="nx">Build</code><code class="p">()</code>                <code class="c1">// Constructs the new logger</code>&#13;
&#13;
    <code class="nx">zap</code><code class="p">.</code><code class="nx">ReplaceGlobals</code><code class="p">(</code><code class="nx">logger</code><code class="p">)</code>              <code class="c1">// Replace Zap's global logger</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The above example creates a new <code>zap.Logger</code> and sets it as Zap’s global logger. It does this in several steps.</p>&#13;
&#13;
<p>First, the example creates a new <code>zap.Config</code> struct. For convenience, this example uses the predefined <code>zap.NewDevelopmentConfig</code> function, which provides a &#13;
<span class="keep-together"><code>zap.Config</code></span> value that produces human-readable output and a threshold of <code>DebugLevel</code> and above.</p>&#13;
&#13;
<p>If you like, the <code>zap.NewProductionConfig</code> function, which returns a preconfigured <code>zap.Config</code> value with a threshold of <code>InfoLevel</code> and encodes events in JSON. If you really want to, you can even create your own <code>zap.Config</code> from scratch.</p>&#13;
&#13;
<p>Next, the example creates a new <code>zap.SamplingConfig</code> on the <code>zap.Config</code>, which instructs the Zap sampler to keep the first three of any similar events in a given second, and to drop all but every third message thereafter (each second).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>Hook</code> function is invoked after each sampling decision. The example will write a message if it sees that an event has been dropped.</p>&#13;
</div>&#13;
&#13;
<p>Finally, the example uses the Config’s <code>Build</code> method to construct a <code>zap.Logger</code> from the <code>Config</code>, and uses <code>zap.ReplaceGlobals</code> to replace Zap’s global Logger. Zap’s global logger and sugared logger can be accessed by using the <code>zap.L</code> and <code>zap.S</code> functions, respectively.</p>&#13;
&#13;
<p>But does it work as we expect? Well, let’s see:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
        <code class="nx">zap</code><code class="p">.</code><code class="nx">S</code><code class="p">().</code><code class="nx">Infow</code><code class="p">(</code>&#13;
            <code class="s">"Testing sampling"</code><code class="p">,</code>&#13;
            <code class="s">"index"</code><code class="p">,</code> <code class="nx">i</code><code class="p">,</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The above function logs 10 events, but with our sampling configuration we should see only the first 3 events, and then every third after that (6 and 9). Is that what &#13;
<span class="keep-together">we see?</span></p>&#13;
&#13;
<pre data-type="programlisting">$ go run .&#13;
INFO    zap/main.go:39    Testing sampling    {"index": 1}&#13;
INFO    zap/main.go:39    Testing sampling    {"index": 2}&#13;
INFO    zap/main.go:39    Testing sampling    {"index": 3}&#13;
event dropped...&#13;
event dropped...&#13;
INFO    zap/main.go:39    Testing sampling    {"index": 6}&#13;
event dropped...&#13;
event dropped...&#13;
INFO    zap/main.go:39    Testing sampling    {"index": 9}&#13;
event dropped...</pre>&#13;
&#13;
<p>The output is exactly as we expected. Clearly, log sampling is a very powerful technique, and, when used properly, can provide significant value.<a data-type="indexterm" data-primary="logging" data-startref="ch11_term21" id="idm45983611276312"/><a data-type="indexterm" data-primary="Zap logging" data-startref="ch11_term23" id="idm45983611275336"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983612004504">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>There’s a lot of hype around observability, and with its promises to dramatically shorten development feedback loops and generally make complexity manageable again, it’s easy to see why.</p>&#13;
&#13;
<p>I wrote a little at the start of this chapter about observability and its promises, and a little more  about how observability <em>isn’t</em> done. Unfortunately, <em>how to do</em> observability is a really, really big subject, and the limitations of time and space meant that I wasn’t able to say as much about that as I certainly would have liked.<sup><a data-type="noteref" id="idm45983611271368-marker" href="ch11.xhtml#idm45983611271368">15</a></sup> Fortunately, with some pretty great books on the horizon (most notably <a href="https://oreil.ly/Cd1gs" class="orm:hideurl"><em>Observability Engineering</em></a> by Charity Majors and Liz Fong-Jones (O’Reilly)), that void won’t go unfilled for long.</p>&#13;
&#13;
<p>By far, however, most of this chapter was spent talking about the Three Pillars of Observability in turn, specifically how to implement them using <a href="https://oreil.ly/zEgIp">OpenTelemetry</a>, where possible.</p>&#13;
&#13;
<p>All told, this was a challenging chapter. Observability is a vast subject about which not that much is written yet, and, as a result of its newness, the same is true of OpenTelemetry. Even its own documentation is limited and spotty in parts. On the plus side, I got to spend a lot of time in the source code.</p>&#13;
&#13;
<figure class="pagebreak-before fin"><div class="figure">&#13;
<img src="Images/cngo_11in02.png" alt="cngo 11in02" width="982" height="572"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983615999816"><sup><a href="ch11.xhtml#idm45983615999816-marker">1</a></sup> Stoll, Clifford. <em>High-Tech Heretic: Reflections of a Computer Contrarian</em>. Random House, September 2000.</p><p data-type="footnote" id="idm45983615994840"><sup><a href="ch11.xhtml#idm45983615994840-marker">2</a></sup> Interestingly, this was also just after the AWS launched its Lambda functions as a service (FaaS) offering. Coincidence? Maybe.</p><p data-type="footnote" id="idm45983615991304"><sup><a href="ch11.xhtml#idm45983615991304-marker">3</a></sup> Assuming of course that all of our network and platform configurations are correct!</p><p data-type="footnote" id="idm45983615927544"><sup><a href="ch11.xhtml#idm45983615927544-marker">4</a></sup> I’m not one of the cool kids.</p><p data-type="footnote" id="idm45983615924216"><sup><a href="ch11.xhtml#idm45983615924216-marker">5</a></sup> In addition to Go, implementations exist for Python, Java, JavaScript, .NET, C++, Rust, PHP, Erlang/Elixir, Ruby, and Swift.</p><p data-type="footnote" id="idm45983615919256"><sup><a href="ch11.xhtml#idm45983615919256-marker">6</a></sup> If you’ve never seen <a href="https://charity.wtf">Charity Majors’ blog</a>, I recommend that you check it out immediately. It’s one part genius plus one part experience, tied together with rainbows, cartoon unicorns, and a generous helping of rude language.</p><p data-type="footnote" id="idm45983615677880"><sup><a href="ch11.xhtml#idm45983615677880-marker">7</a></sup> Sigelman, Benjamin H., et al. “Dapper, a Large-Scale Distributed Systems Tracing Infrastructure.” <em>Google Technical Report</em>, Apr. 2010. <a href="https://oreil.ly/Vh7Ig"><em class="hyperlink">https://oreil.ly/Vh7Ig</em></a>.</p><p data-type="footnote" id="idm45983615038696"><sup><a href="ch11.xhtml#idm45983615038696-marker">8</a></sup> Recall that the name “mux” is short for “HTTP request multiplexer.”</p><p data-type="footnote" id="idm45983614810104"><sup><a href="ch11.xhtml#idm45983614810104-marker">9</a></sup> That wins the record for longest package name, at least in this book.</p><p data-type="footnote" id="idm45983613782808"><sup><a href="ch11.xhtml#idm45983613782808-marker">10</a></sup> It can <em>also</em> refer to the numerical relationship between two database tables (i.e., <em>one-to-one</em>, <em>one-to-many</em>, or <em>many-to-many</em>), but that definition is arguably less relevant here.</p><p data-type="footnote" id="idm45983613739800"><sup><a href="ch11.xhtml#idm45983613739800-marker">11</a></sup> Whatever “better” means.</p><p data-type="footnote" id="idm45983613735976"><sup><a href="ch11.xhtml#idm45983613735976-marker">12</a></sup> Kiran, Oliver. “Exploring Prometheus Use Cases with Brian Brazil.” <em>The New Stack Makers</em>, 30 Oct. 2016. <a href="https://oreil.ly/YDIek"><em class="hyperlink">https://oreil.ly/YDIek</em></a>.</p><p data-type="footnote" id="idm45983612468360"><sup><a href="ch11.xhtml#idm45983612468360-marker">13</a></sup> Any wrapping in the example is for the benefit of formatting for presentation only. Don’t use line breaks in your log events if you can help it.</p><p data-type="footnote" id="idm45983612398728"><sup><a href="ch11.xhtml#idm45983612398728-marker">14</a></sup> If they are, why are you producing them at all?</p><p data-type="footnote" id="idm45983611271368"><sup><a href="ch11.xhtml#idm45983611271368-marker">15</a></sup> This is a Go book, after all. At least that’s what I keep telling my incredibly patient editors.</p></div></div></section></div></body></html>