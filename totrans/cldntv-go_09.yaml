- en: Chapter 6\. It’s All About Dependability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。一切都关乎可靠性
- en: The most important property of a program is whether it accomplishes the intention
    of its user.^([1](ch06.xhtml#idm45983630648552))
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个程序最重要的特性是它是否实现了用户的意图。^([1](ch06.xhtml#idm45983630648552))
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C.A.R. Hoare, Communications of the ACM (October 1969)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C.A.R. 霍尔，《ACM通讯》（1969年10月）
- en: Professor Sir Charles Antony Richard (Tony) Hoare is a brilliant guy. He invented
    quicksort, authored Hoare Logic for reasoning about the correctness of computer
    programs, and created the formal language “communicating sequential processes”
    (CSP) that inspired Go’s beloved concurrency model. Oh, and he developed the structured
    programming paradigm^([2](ch06.xhtml#idm45983630641848)) that forms the foundation
    of all modern programming languages in common use today. He also invented the
    null reference. Please don’t hold that against him, though. He publicly apologized^([3](ch06.xhtml#idm45983630640824))
    for it in 2009, calling it his “billion-dollar mistake.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·安东尼·理查德（托尼）·霍尔教授是一个非常杰出的人。他发明了快速排序，创立了用于推理计算机程序正确性的霍尔逻辑，并创建了启发Go语言中喜爱的并发模型的形式化语言“通信顺序进程”（CSP）。哦，他还发明了空引用。尽管如此，请不要因此而抱怨他。他在2009年公开道歉^([3](ch06.xhtml#idm45983630640824))，称这是他的“十亿美元错误”。
- en: 'Tony Hoare literally invented programming as we know it. So when he says that
    the single most important property of a program is whether it accomplishes the
    intention of its user, you can take that on some authority. Think about this for
    a second: Hoare specifically (and quite rightly) points out that it’s the intention
    of a program’s *users*—not its *creators*—that dictates whether a program is performing
    correctly. How inconvenient that the intentions of a program’s users aren’t always
    the same as those of its creator!'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 托尼·霍尔（Tony Hoare）可以说是我们所知的编程之父。因此，当他说一个程序最重要的特性是它是否实现了用户的意图时，你可以信以为真。想想这个：霍尔明确地（而且完全正确地）指出，一个程序是否正确执行，取决于程序的*用户*的意图，而不是程序的*创建者*的意图。多么不方便啊，程序的用户的意图并不总是和其创建者的意图一致！
- en: Given this assertion, it stands to reason that a user’s first expectation about
    a program is that *the program works*. But when is a program “working”? This is
    actually a pretty big question, one that lies at the heart of cloud native design.
    The first goal of this chapter is to explore that very idea, and in the process,
    introduce concepts like “dependability” and “reliability” that we can use to better
    describe (and meet) user expectations. Finally, we’ll briefly review a number
    of practices commonly used in cloud native development to ensure that services
    meet the expectations of its users. We’ll discuss each of these in-depth throughout
    the remainder of this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这一断言，一个用户对程序的第一个期望是“程序工作”。但程序何时才算“工作”呢？这实际上是一个相当大的问题，是云原生设计的核心所在。本章的第一个目标是探讨这个观念，并在过程中引入“可靠性”和“可信赖性”等概念，以更好地描述（并满足）用户的期望。最后，我们将简要回顾云原生开发中常用的一些实践，确保服务达到用户的期望。我们将在本书的其余部分深入讨论每一个实践。
- en: What’s the Point of Cloud Native?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生的意义何在？
- en: In [Chapter 1](ch01.xhtml#chapter_1) we spent a few pages defining “cloud native,”
    starting with the Cloud Native Computing Foundation’s definition and working forward
    to the properties of an ideal cloud native service. We spent a few more pages
    talking about the pressures that have driven cloud native to be a thing in the
    first place.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.xhtml#chapter_1)中，我们花了几页的篇幅来定义“云原生”，从云原生计算基金会的定义开始，逐步深入讨论理想的云原生服务的特性。我们还花了几页时间讨论推动云原生成为一种事物的压力。
- en: What we didn’t spend so much time on, however, was the *why* of cloud native.
    Why does the concept of cloud native even exist? Why would we even want our systems
    to be cloud native? What’s its purpose? What makes it so special? Why should I
    care?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有花太多时间去讨论云原生的“为什么”。为什么会有云原生的概念？为什么我们希望系统成为云原生？它的目的是什么？它有什么特别之处？我为什么要关心它？
- en: 'So, why *does* cloud native exist? The answer is actually pretty straightforward:
    it’s all about dependability. In the first part of this chapter, we’ll dig into
    the concept of dependability, what it is, why it’s important, and how it underlies
    all the patterns and techniques that we call cloud native.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*为什么*云原生存在？答案其实非常简单：一切都是为了可靠性。在本章的第一部分，我们将深入探讨可靠性的概念，它是什么，为什么如此重要，以及它如何贯穿我们称之为云原生的所有模式和技术。
- en: It’s All About Dependability
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切关乎可靠性
- en: Holly Cummins, the worldwide development community practice lead for the IBM
    Garage, famously said that “if cloud native has to be a synonym for anything,
    it would be idempotent.”^([4](ch06.xhtml#idm45983630609624)) Cummins is absolutely
    brilliant, and has said a lot of absolutely brilliant things,^([5](ch06.xhtml#idm45983630608616))
    but I think she only has half of the picture on this one. I think that idempotence
    is very important—perhaps even necessary for cloud native—but not sufficient.
    I’ll elaborate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Garage全球开发社区实践主管Holly Cummins曾经说过，“如果云原生必须成为任何东西的同义词，那它就应该是幂等性。”^([4](ch06.xhtml#idm45983630609624))
    Cummins非常聪明，她说了很多非常聪明的话，^([5](ch06.xhtml#idm45983630608616)) 但我认为她在这一点上只掌握了一半的真相。我认为幂等性非常重要——或许甚至是云原生的必要条件，但不足够。我会详细阐述。
- en: The history of software, particularly the network-based kind, has been one of
    struggling to meet the expectations of increasingly sophisticated users. Long
    gone are the days when a service could go down at night “for maintenance.” Users
    today rely heavily on the services they use, and they expect those services to
    be available and to respond promptly to their requests. Remember the last time
    you tried to start a Netflix movie and it took the longest five seconds of your
    life? Yeah, that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的历史，特别是基于网络的软件，一直在努力满足日益复杂用户的期望。已经不再是那些服务可以在晚上“进行维护”的日子了。今天的用户对他们使用的服务依赖很重，并且期望这些服务可用并能迅速响应他们的请求。还记得你上次试图启动Netflix电影，花了你生命中最长的五秒钟吗？是的，就是那样。
- en: Users don’t care that your services have to be maintained. They won’t wait patiently
    while you hunt down that mysterious source of latency. They just want to finish
    binge-watching the second season of Breaking Bad.^([6](ch06.xhtml#idm45983630606248))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户并不关心你的服务需要维护。在你寻找那个神秘的延迟源时，他们不会耐心等待。他们只是想看完《绝命毒师》第二季。^([6](ch06.xhtml#idm45983630606248))
- en: All of the patterns and techniques that we associate with cloud native—*every
    single one*—exist to allow services to be deployed, operated, and maintained at
    scale in unreliable environments, driven by the need to produce dependable services
    that keep users happy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所关联的云原生的所有模式和技术——*每一个*——都存在的目的是允许服务在不可靠的环境中规模化部署、运行和维护，这是为了提供可靠的服务，让用户满意。
- en: In other words, I think that if “cloud native” has to be a synonym for anything,
    it would be “dependability.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果“云原生”必须成为任何东西的同义词，那么它就是“可靠性”。
- en: What Is Dependability and Why Is It So Important?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性是什么，为什么这么重要？
- en: 'I didn’t choose the word “dependability” arbitrarily. It’s actually a core
    concept in the field of *systems engineering*, which is full of some very smart
    people who say some very smart things about the design and management of complex
    systems. The concept of dependability in a computing context was first rigorously
    defined by Jean-Claude Laprie about 35 years ago,^([7](ch06.xhtml#idm45983630599160))
    who defined a system’s dependability according to the expectations of its users.
    Laprie’s original definition has been tweaked and extended over the years by various
    authors, but here’s my favorite:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我并非随意选择“可靠性”这个词。在*系统工程*领域中，这实际上是一个核心概念，这个领域充满了一些非常聪明的人，他们对复杂系统的设计和管理有很多聪明见解。在计算机环境中，可靠性的概念大约35年前由Jean-Claude
    Laprie严格定义过，^([7](ch06.xhtml#idm45983630599160)) 他根据用户的期望来定义系统的可靠性。多年来，Laprie的原始定义已被各种作者调整和扩展，但这是我最喜欢的一种：
- en: The dependability of a computer system is its ability to avoid failures that
    are more frequent or more severe, and outage durations that are longer, than is
    acceptable to the user(s).^([8](ch06.xhtml#idm45983630595768))
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机系统的可靠性指的是其能够避免比用户可接受的更频繁或更严重的故障，以及停机时间比用户认可的更长的情况。^([8](ch06.xhtml#idm45983630595768))
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fundamental Concepts of Computer System Dependability (2001)
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机系统可靠性的基本概念（2001）
- en: In other words, a dependable system consistently does what its users expect
    and can be quickly fixed when it doesn’t.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个可靠的系统始终如用户所期望地执行，并且在出现问题时能够迅速修复。
- en: 'By this definition, a system is dependable only when it can *justifiably* be
    trusted. Obviously, a system can’t be considered dependable if it falls over any
    time one of its components glitch, or if it requires hours to recover from a failure.
    Even if it’s been running for months without interruption, an undependable system
    may still be one bad day away from catastrophe: lucky isn’t dependable.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，系统只有在能够*合理*地被信任时才是可靠的。显然，如果系统的任何组件发生故障就无法被视为可靠，或者如果系统需要数小时才能从故障中恢复，也不能被视为可靠。即使系统连续运行数月而没有中断，一个不可靠的系统仍然可能在一个坏日子之前濒临灾难：侥幸并不可靠。
- en: Unfortunately, it’s hard to objectively gauge “user expectations.” For this
    reason, as illustrated in [Figure 6-1](#img_ch06_dependability_tree), dependability
    is an umbrella concept encompassing several more specific and quantifiable attributes—availability,
    reliability, and maintainability—all of which are subject to similar threats that
    may be overcome by similar means.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，客观衡量“用户期望”是很困难的。因此，如图[6-1](#img_ch06_dependability_tree)所示，可靠性是一个包含多个更具体和可量化属性（可用性、可靠性和可维护性）的总体概念，所有这些属性都面临着类似的威胁，可以通过类似的手段来克服。
- en: '![cngo 0601](Images/cngo_0601.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0601](Images/cngo_0601.png)'
- en: Figure 6-1\. The system attributes and means that contribute to dependability
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 贡献于可靠性的系统属性和手段
- en: 'So while the concept of “dependability” alone might be a little squishy and
    subjective, the attributes that contribute to it are quantitative and measurable
    enough to be useful:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然“可靠性”这个概念本身可能有些模糊和主观，但其贡献的属性是定量和可测量的，足以为实际应用提供帮助：
- en: Availability
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性
- en: The ability of a system to perform its intended function at a random moment
    in time. This is usually expressed as the probability that a request made of the
    system will be successful, defined as uptime divided by total time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在任意时刻执行其预期功能的能力。通常表达为系统接收请求成功的概率，定义为正常运行时间除以总时间。
- en: Reliability
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'The ability of a system to perform its intended function for a given time interval.
    This is often expressed as either the mean time between failures (MTBF: total
    time divided by the number of failures) or failure rate (number of failures divided
    by total time).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在给定时间间隔内执行其预期功能的能力。通常表达为平均无故障时间（MTBF：总时间除以故障次数）或故障率（故障次数除以总时间）。
- en: Maintainability
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性
- en: The ability of a system to undergo modifications and repairs. There are a variety
    of indirect measures for maintainability, ranging from calculations of cyclomatic
    complexity to tracking the amount of time required to change a system’s behavior
    to meet new requirements or to restore it to a functional state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统进行修改和维修的能力。可维护性有多种间接度量方法，从计算圈复杂度到跟踪改变系统行为所需的时间，以满足新要求或将其恢复到功能状态。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: Later authors extended Laprie’s definition of dependability to include several
    security-related properties, including safety, confidentiality, and integrity.
    I’ve reluctantly omitted these, not because security isn’t important (it’s *SO*
    important!), but for brevity. A worthy discussion of security would require an
    entire book of its own.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 后来的作者扩展了拉普里对可靠性的定义，包括几个与安全相关的属性，包括安全性、机密性和完整性。我不情愿地省略了这些内容，不是因为安全不重要（安全非常重要！），而是为了简洁起见。讨论安全问题需要一整本书的篇幅。
- en: 'Dependability: It’s Not Just for Ops Anymore'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性：不仅仅是运维的事情了
- en: Since the introduction of networked services, it’s been the job of developers
    to build services, and of systems administrators (“operations”) to deploy those
    services onto servers and keep them running. This worked well enough for a time,
    but it had the unfortunate side-effect of incentivizing developers to prioritize
    feature development at the expense of stability and operations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自网络服务引入以来，开发人员的工作是构建服务，系统管理员（“运维”）的工作是将这些服务部署到服务器上并保持其运行。这在一段时间内运作得很好，但它不幸地导致开发人员为了功能开发而牺牲了稳定性和运维。
- en: Fortunately, over the past decade or so—coinciding with the DevOps movement—a
    new wave of technologies has become available with the potential to completely
    change the way technologists of all kinds do their jobs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在过去的十年左右，与 DevOps 运动同时出现了一波新技术，这些技术有潜力彻底改变各种技术人员的工作方式。
- en: On the operations side, with the availability of infrastructure and platforms
    as a service (IaaS/PaaS) and tools like Terraform and Ansible, working with infrastructure
    has never been more like writing software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在运维方面，随着基础设施和平台即服务（IaaS/PaaS）以及像 Terraform 和 Ansible 这样的工具的可用性，与基础设施的工作从未像现在这样像编写软件。
- en: On the development side, the popularization of technologies like containers
    and serverless functions has given developers an entire new set of “operations-like”
    capabilities, particularly around virtualization and deployment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发方面，像容器和无服务器函数这样的技术的普及为开发人员提供了整套“操作类”能力，特别是在虚拟化和部署方面。
- en: As a result, the once-stark line between software and infrastructure is getting
    increasingly blurry. One could even argue that with the growing advancement and
    adoption of infrastructure abstractions like virtualization, container orchestration
    frameworks like Kubernetes, and software-defined behavior like service meshes,
    we may even be at the point where they could be said to have merged. Everything
    is software now.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，软件和基础设施之间曾经明显的界限变得日益模糊。甚至可以说，随着虚拟化等基础设施抽象化技术、容器编排框架如 Kubernetes 和服务网格等软件定义行为的不断进步和采纳，它们甚至可能已经融合了。现在一切都是软件。
- en: The ever-increasing demand for service dependability has driven the creation
    of a whole new generation of cloud native technologies. The effects of these new
    technologies and the capabilities they provide has been considerable, and the
    traditional developer and operations roles are changing to suit them. At long
    last, the silos are crumbling, and, increasingly, the rapid production of dependable,
    high-quality services is a fully collaborative effort of all of its designers,
    implementors, and maintainers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对服务可靠性的日益增长需求推动了一整代全新的云原生技术的诞生。这些新技术及其提供的能力产生了显著影响，传统的开发者和运维角色正在适应它们。终于，隔阂正在消失，越来越多的可靠、高质量服务的快速生成成为其所有设计者、实施者和维护者共同努力的结果。
- en: Achieving Dependability
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现可靠性
- en: This is where the rubber meets the road. If you’ve made it this far, congratulations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是实践的时刻。如果你已经走到这一步，恭喜你。
- en: So far we’ve discussed Laprie’s definition of “dependability,” which can be
    (very) loosely paraphrased as “happy users,” and we’ve discussed the attributes—availability,
    reliability, and maintainability—that contribute to it. This is all well and good,
    but without actionable advice for how to achieve dependability the entire discussion
    is purely academic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了拉普里对“可靠性”的定义，可以（非常）松散地解释为“用户满意”，并且我们已经讨论了贡献于此的可用性、可靠性和可维护性属性。这一切都很好，但是如果没有关于如何实现可靠性的可行建议，整个讨论只是纯粹的学术性质。
- en: 'Laprie thought so too, and defined four broad categories of techniques that
    can be used together to improve a system’s dependability (or which, by their absence,
    can reduce it):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拉普里也这样认为，并定义了四大类技术，可以共同用于提高系统的可靠性（或者由于它们的缺乏而降低可靠性）：
- en: Fault prevention
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 故障预防
- en: Fault prevention techniques are used during system construction to prevent the
    occurrence or introduction of faults.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统构建过程中使用故障预防技术，以预防故障的发生或引入。
- en: Fault tolerance
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 故障容忍
- en: Fault tolerance techniques are used during system design and implementation
    to prevent service failures in the presence of faults.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统设计和实施过程中使用故障容忍技术，以防止在存在故障时出现服务故障。
- en: Fault removal
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 故障去除
- en: Fault removal techniques are used to reduce the number and severity of faults.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用故障去除技术来减少故障的数量和严重程度。
- en: Fault forecasting
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 故障预测
- en: Fault forecasting techniques are used to identify the presence, the creation,
    and the consequences of faults.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用故障预测技术来识别故障的存在、产生以及后果。
- en: Interestingly, as illustrated in [Figure 6-2](#img_ch06_means_pyramid), these
    four categories correspond surprisingly well to the five cloud native attributes
    that we introduced all the way back in [Chapter 1](ch01.xhtml#chapter_1).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，正如在[图 6-2](#img_ch06_means_pyramid)中所示，这四个类别与我们在[第 1 章](ch01.xhtml#chapter_1)中介绍的五个云原生属性非常相符。
- en: '![cngo 0602](Images/cngo_0602.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0602](Images/cngo_0602.png)'
- en: Figure 6-2\. The four means of achieving dependability, and their corresponding
    cloud native attributes
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 实现可靠性的四种手段及其对应的云原生属性
- en: 'Fault prevention and fault tolerance make up the bottom two layers of the pyramid,
    corresponding with scalability, loose coupling, and resilience. Designing a system
    for scalability prevents a variety of faults common among cloud native applications,
    and resiliency techniques allow a system to tolerate faults when they do inevitably
    arise. Techniques for loose coupling can be said to fall into both categories,
    preventing and enhancing a service’s fault tolerance. Together these can be said
    to contribute to what Laprie terms *dependability procurement*: the means by which
    a system is provided with the ability to perform its designated function.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 故障预防和容错构成金字塔底部的两个层次，与可伸缩性、松耦合和弹性相对应。设计可伸缩系统可预防云原生应用程序中常见的各种故障，而弹性技术允许系统在故障不可避免地发生时容忍这些故障。松耦合的技术既可以说属于预防，也可以说属于增强服务容错性的技术。这些技术共同促成了Laprie所称的*可靠性采购*：这是系统被赋予执行其指定功能能力的手段。
- en: 'Techniques and designs that contribute to manageability are intended to produce
    a system that can be easily modified, simplifying the process of removing faults
    when they’re identified. Similarly, observability naturally contributes to the
    ability to forecast faults in a system. Together fault removal and forecasting
    techniques contribute to what Laprie termed *dependability validation*: the means
    by which confidence is gained in a system’s ability to perform its designated
    function.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 技术和设计有助于可管理性，旨在生成一个可以轻松修改的系统，简化在识别故障时的排除过程。同样，可观察性自然有助于在系统中预测故障。排除故障和预测技术共同构成了Laprie所称的*可靠性验证*：这是获得对系统执行其指定功能能力的信心的手段。
- en: 'Consider the implications of this relationship: what was a purely academic
    exercise 35 years ago has essentially been rediscovered—apparently independently—as
    a natural consequence of years of accumulated experience building reliable production
    systems. Dependability has come full-circle.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种关系的影响：35年前纯粹是学术练习的东西，现在本质上已经被重新发现——显然是独立地作为多年积累经验的自然结果，用于构建可靠的生产系统。可靠性已经走了一整圈。
- en: In the subsequent sections we’ll explore these relationships more fully and
    preview later chapters, in which we discuss exactly how these two apparently disparate
    systems actually correspond quite closely.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更全面地探讨这些关系，并预览后续章节，在这些章节中我们将详细讨论这两个显然不同的系统如何实际上相对应得非常密切。
- en: Fault Prevention
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障预防
- en: At the base of our “Means of Dependability” pyramid are techniques that focus
    on preventing the occurrence or introduction of faults. As veteran programmers
    can attest, many—if not most—classes of errors and faults can be predicted and
    prevented during the earliest phases of development. As such, many fault prevention
    techniques come into play during the design and implementation of a service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们“可靠性手段”的金字塔底部是专注于预防故障发生或引入的技术。正如资深程序员可以证明的那样，许多——如果不是大多数——类别的错误和故障可以在开发的最早阶段预测和预防。因此，许多故障预防技术在服务的设计和实施过程中发挥作用。
- en: Good programming practices
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 良好的编程实践
- en: Fault prevention is one of the primary goals of software engineering in general,
    and is the explicit goal of any development methodology, from pair programming
    to test-driven development and code review practices. Many such techniques can
    really be grouped into what might be considered to be “good programming practice,”
    about which innumerable excellent books and articles have already been written,
    so we won’t explicitly cover it here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 故障预防是软件工程的主要目标之一，也是任何开发方法论的明确目标，从配对编程到测试驱动开发和代码审查实践。许多这样的技术实际上可以归为“良好的编程实践”，关于这些实践已经有无数优秀的书籍和文章写成，因此我们在这里不会明确涵盖它们。
- en: Language features
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言特性
- en: Your choice of language can also greatly affect your ability to prevent or fix
    faults. Many language features that some programmers have sometimes come to expect,
    such as dynamic typing, pointer arithmetic, manual memory management, and thrown
    exceptions (to name a few) can easily introduce unintended behaviors that are
    difficult to find and fix, and may even be maliciously exploitable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择编程语言也极大地影响您预防或修复故障的能力。一些程序员有时期望的语言特性，如动态类型、指针算术、手动内存管理和抛出异常等，往往会引入意外行为，难以发现和修复，甚至可能被恶意利用。
- en: These kinds of features strongly motivated many of the design decisions for
    Go, resulting in the strongly typed garbage-collected language we have today.
    For a refresher for why Go is particularly well suited for the development of
    cloud native services, take a look back at [Chapter 2](ch02.xhtml#chapter_2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能强烈推动了 Go 的许多设计决策，最终形成了我们今天拥有的强类型垃圾回收语言。要了解为什么 Go 特别适合开发云原生服务，请回顾[第二章](ch02.xhtml#chapter_2)。
- en: Scalability
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: We briefly introduced the concept of scalability way back in [Chapter 1](ch01.xhtml#chapter_1),
    where it was defined as the ability of a system to continue to provide correct
    service in the face of significant changes in demand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第一章](ch01.xhtml#chapter_1)中简要介绍了可扩展性的概念，将其定义为系统在需求显著变化的情况下继续提供正确服务的能力。
- en: In that section we introduced two different approaches to scaling—vertical scaling
    (scaling up) by resizing existing resources, and horizontal scaling (scaling out)
    by adding (or removing) service instances—and some of the pros and cons of each.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一节中，我们介绍了两种不同的扩展方法——通过调整现有资源来进行垂直扩展（向上扩展），以及通过添加（或移除）服务实例来进行水平扩展（向外扩展）——以及每种方法的优缺点。
- en: We’ll go quite a bit deeper into each of these in [Chapter 7](ch07.xhtml#chapter_7),
    especially into the gotchas and downsides. We’ll also talk a lot about the problems
    posed by state.^([11](ch06.xhtml#idm45983630519656)) For now, though, it’ll suffice
    to say that having to scale your service adds quite a bit of overhead, including
    but not limited to cost, complexity, and debugging.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第七章](ch07.xhtml#chapter_7)更深入地探讨这些问题，特别是其中的陷阱和缺点。我们还将大谈关于状态带来的问题。^([11](ch06.xhtml#idm45983630519656))
    不过，现在，简单地说，需要扩展服务会增加相当多的开销，包括但不限于成本、复杂性和调试。
- en: While scaling resources is eventually often inevitable, it’s often better (and
    cheaper!) to resist the temptation to throw hardware at the problem and postpone
    scaling events as long as possible by considering runtime efficiency and algorithmic
    scaling. As such, we’ll cover a number of Go features and tooling that allow us
    to identify and fix common problems like memory leaks and lock contention that
    tend to plague systems at scale.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展资源最终通常是不可避免的，但是抵制诱惑在问题上投入硬件通常更好（也更便宜！），并通过考虑运行时效率和算法扩展尽可能推迟扩展事件。因此，我们将介绍一些
    Go 的功能和工具，这些功能和工具使我们能够识别和修复像内存泄漏和锁争用这样在规模化系统中常见的问题。
- en: Loose coupling
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松耦合
- en: Loose coupling, which we first defined in [“Loose Coupling”](ch01.xhtml#section_ch01_loose_coupling),
    is the system property and design strategy of ensuring that a system’s components
    have as little knowledge of other components as possible. The degree of coupling
    between services can have an enormous—and too often under-appreciated—impact on
    a system’s ability to scale and to isolate and tolerate failures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合，我们在[“松耦合”](ch01.xhtml#section_ch01_loose_coupling)中首次定义，是确保系统组件尽可能少地了解其他组件的系统属性和设计策略。服务之间的耦合程度对系统的扩展能力、隔离和容忍故障有巨大而又常常被低估的影响。
- en: Since the beginning of microservices there have been dissenters who point to
    the difficulty of deploying and maintaining microservice-based systems as evidence
    that such architectures are just too complex to be viable. I don’t agree, but
    I can see where they’re coming from, given how incredibly easy it is to build
    a *distributed monolith*. The hallmark of a distributed monolith is the tight
    coupling between its components, which results in an application saddled with
    all of the complexity of microservices plus the all of the tangled dependencies
    of the typical monolith. If you have to deploy most of your services together,
    or if a failed health check sends cascading failures through your entire system,
    you probably have a distributed monolith.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自从微服务出现以来，就有人持反对意见，认为基于微服务的系统部署和维护过于复杂，这证据表明这样的架构不可行。我不同意，但我理解他们的观点，考虑到构建*分布式单块*是多么容易。分布式单块的特征是其组件之间的紧密耦合，导致应用程序同时具有微服务的所有复杂性和典型单块的所有混乱依赖关系。如果您必须一起部署大部分服务，或者如果健康检查失败会导致整个系统发生级联故障，那么您可能有一个分布式单块。
- en: Building a loosely coupled system is easier said than done, but is possible
    with a little discipline and reasonable boundaries. In [Chapter 8](ch08.xhtml#chapter_8)
    we’ll cover how to use data exchange contracts to establish those boundaries,
    and different synchronous and asynchronous communication models and architectural
    patterns and packages used to implement them and avoid the dreaded distributed
    monolith.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建松耦合的系统说起来容易，做起来不容易，但只要有些纪律和合理的边界是可能的。在[第8章](ch08.xhtml#chapter_8)中，我们将介绍如何使用数据交换合同来建立这些边界，以及不同的同步和异步通信模型以及用于实现它们并避免可怕的分布式单块的架构模式和包。
- en: Fault Tolerance
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容错性
- en: 'Fault tolerance has a number of synonyms—self-repair, self-healing, resilience—that
    all describe a system’s ability to detect errors and prevent them from cascading
    into a full-blown failure. Typically, this consists of two parts: *error detection*,
    in which an error is discovered during normal service, and *recovery*, in which
    the system is returned to a state where it can be activated again.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容错性有许多同义词——自修复、自愈、弹性——它们都描述了系统检测错误并防止其向全面故障演变的能力。通常，这包括两个部分：*错误检测*，在正常服务过程中发现错误；以及*恢复*，将系统恢复到可以再次激活的状态。
- en: 'Perhaps the most common strategy for providing resilience is redundancy: the
    duplication of critical components (having multiple service replicas) or functions
    (retrying service requests). This is a broad and very interesting field with a
    number of subtle gotchas that we’ll dig into in [Chapter 9](ch09.xhtml#chapter_9).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提供弹性的最常见策略可能是冗余：关键组件的复制（具有多个服务副本）或功能（重试服务请求）。这是一个广泛且非常有趣的领域，涉及一些微妙的陷阱，我们将在[第9章](ch09.xhtml#chapter_9)详细探讨。
- en: Fault Removal
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障去除
- en: Fault removal, the third of the four dependability means, is the process of
    reducing the number and severity of faults—latent software flaws that can cause
    errors—before they manifest as errors.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 故障去除，作为四种可靠性手段之一，是在错误显现之前减少故障数量和严重性的过程，即潜在的软件缺陷可能导致错误。
- en: Even under ideal conditions, there are plenty of ways that a system can error
    or otherwise misbehave. It might fail to perform an expected action, or perform
    the wrong action entirely, perhaps maliciously. Just to make things even more
    complicated, conditions aren’t always—or often—ideal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在理想条件下，系统也可能出现多种错误或其他异常行为。它可能未能执行预期的操作，或者完全执行了错误的操作，可能还是恶意的。更复杂的是，条件并非总是——或者说往往不是——理想的。
- en: Many faults can be identified by testing, which allows you to verify that the
    system (or at least its components) behaves as expected under known test conditions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多故障可以通过测试来识别，这允许您验证系统（或至少其组件）在已知的测试条件下的行为是否符合预期。
- en: But what about unknown conditions? Requirements change, and the real world doesn’t
    care about your test conditions. Fortunately, with effort, a system can be designed
    to be manageable enough that its behavior can often be adjusted to keep it secure,
    running smoothly, and compliant with changing requirements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是未知条件呢？需求会变化，现实世界并不在乎你的测试条件。幸运的是，通过努力，可以设计出一个足够可管理的系统，其行为通常可以调整以保持安全运行，顺畅运行，并符合变化的要求。
- en: We’ll briefly discuss these next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将简要讨论这些内容。
- en: Verification and testing
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证和测试
- en: 'There are exactly four ways of finding latent software faults in your code:
    testing, testing, testing, and bad luck.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中找到潜在软件缺陷的确切四种方法：测试、测试、测试和运气不佳。
- en: 'Yes, I joke, but that’s not so far from the truth: if you don’t find your software
    faults, your users will. If you’re lucky. If you’re not, then they’ll be found
    by bad actors seeking to take advantage of them.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我在开玩笑，但这并非毫无道理：如果你找不到你的软件缺陷，你的用户会找到它们。如果你幸运的话。如果不幸的话，那么它们将被寻找到的恶意行为者利用。
- en: 'Bad jokes aside, there are two common approaches to finding software faults
    in development:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，软件开发中发现软件缺陷的两种常见方法：
- en: Static analysis
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析
- en: Automated, rule-based code analysis performed without actually executing programs.
    Static analysis is useful for providing early feedback, enforcing consistent practices,
    and finding common errors and security holes without depending on human knowledge
    or effort.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是在不实际执行程序的情况下进行的自动化、基于规则的代码分析。静态分析有助于提供早期反馈，强制执行一致的实践，并在不依赖人类知识或努力的情况下找出常见错误和安全漏洞。
- en: Dynamic analysis
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析
- en: Verifying the correctness of a system or subsystem by executing it under controlled
    conditions and evaluating its behavior. More commonly referred to simply as “testing.”
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在受控条件下执行系统或子系统并评估其行为来验证其正确性。更普遍地称为“测试”。
- en: Key to software testing is having software that’s *designed for testability*
    by minimizing the *degrees of freedom*—the range of possible states—of its components.
    Highly testable functions have a single purpose, with well-defined inputs and
    outputs and few or no *side effects*; that is, they don’t modify variables outside
    of their scope. If you’ll forgive the nerdiness, this approach minimizes the *search
    space*—the set of all possible solutions—of each function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的关键在于设计为*可测试性*的软件，通过减少其组件的*自由度*——可能状态的范围——来实现。高度可测试的函数具有单一目的，具有明确定义的输入和输出，几乎没有或没有*副作用*；即它们不修改其作用域之外的变量。尽管有些宅男，但这种方法可以最小化每个函数的*搜索空间*——所有可能解决方案的集合。
- en: Testing is a critical step in software development that’s all too often neglected.
    The Go creators understood this and baked unit testing and benchmarking into the
    language itself in the form of the `go test` command and the [testing package](https://oreil.ly/PrhXq).
    Unfortunately, a deep dive into testing theory is well beyond the scope of this
    book, but we’ll do our best to scratch the surface in [Chapter 9](ch09.xhtml#chapter_9).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发中至关重要的步骤，但往往被忽视。Go 的创作者们理解了这一点，并通过`go test`命令和[测试包](https://oreil.ly/PrhXq)将单元测试和基准测试嵌入到语言本身中。不幸的是，深入探讨测试理论远超出了本书的范围，但我们会尽力浅尝其中在[第9章](ch09.xhtml#chapter_9)中。
- en: Manageability
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可管理性
- en: Faults exist when your system doesn’t behave according to requirements. But
    what happens when those requirements change?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统不按照需求行事时，存在缺陷。但是当这些需求改变时会发生什么呢？
- en: Designing for *manageability*, first introduced back in [“Manageability”](ch01.xhtml#section_ch01_manageability),
    allows a system’s behavior to be adjusted without code changes. A manageable system
    essentially has “knobs” that allow real-time control to keep your system secure,
    running smoothly, and compliant with changing requirements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设计*可管理性*，最早在[“可管理性”](ch01.xhtml#section_ch01_manageability)中介绍，允许调整系统行为而无需更改代码。一个可管理的系统基本上有“旋钮”，允许实时控制，以确保系统安全、运行顺畅，并符合变化的需求。
- en: Manageability can take a variety of forms, including (but not limited to!) adjusting
    and configuring resource consumption, applying on-the-fly security remediations,
    *feature flags* that can turn features on or off, or even loading plug-in-defined
    behaviors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可管理性可以采用多种形式，包括（但不限于！）调整和配置资源消耗，应用即时安全补救措施，可以打开或关闭功能的*特性标志*，甚至加载插件定义的行为。
- en: Clearly, manageability is a broad topic. We’ll review a few of the mechanisms
    Go provides for it in [Chapter 10](ch10.xhtml#chapter_10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，可管理性是一个广泛的主题。我们将在[第10章](ch10.xhtml#chapter_10)中回顾Go提供的一些机制。
- en: Fault Forecasting
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障预测
- en: At the peak of our “Means of Dependability” pyramid ([Figure 6-2](#img_ch06_means_pyramid))
    is *fault forecasting*, which builds on the knowledge gained and solutions implemented
    in the levels below it to attempt to estimate the present number, the future incidence,
    and the likely consequence of faults.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“可依赖性手段”金字塔的顶端（[图6-2](#img_ch06_means_pyramid)），*故障预测*建立在下面层次获得的知识和实施的解决方案基础之上，试图估计故障的当前数量、未来发生率及可能的后果。
- en: Too often this consists of guesswork and gut feelings instead, generally resulting
    in unexpected failures when a starting assumption stops being true. More systematic
    approaches include [Failure Mode and Effects Analysis](https://oreil.ly/sNe6P)
    and stress testing, which are very useful for understanding a system’s possible
    failure modes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这往往包括猜测和直觉，通常在起始假设不再成立时导致意外故障。更系统化的方法包括[故障模式和影响分析](https://oreil.ly/sNe6P)和压力测试，这些方法对理解系统可能的故障模式非常有用。
- en: In a system designed for *observability*, which we’ll discuss in depth in [Chapter 11](ch11.xhtml#chapter_11),
    failure mode indicators can be tracked so that they can be forecast and corrected
    before they manifest as errors. Furthermore, when unexpected failures occur—as
    they inevitably will—observable systems allow the underlying faults to be quickly
    identified, isolated, and corrected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计为*可观察性*的系统中，我们将在[第11章](ch11.xhtml#chapter_11)深入讨论，故障模式指标可以被跟踪，以便在它们显现为错误之前进行预测和修正。此外，当意外故障发生时——它们总会发生——可观测的系统允许快速识别、隔离和修正底层故障。
- en: The Continuing Relevance of the Twelve-Factor App
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素应用程序的持续相关性
- en: In the early 2010s, developers at Heroku, a platform as a service (PaaS) company
    and early cloud pioneer, realized that they were seeing web applications being
    developed again and again with the same fundamental flaws.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年代初，Heroku的开发者意识到，他们看到的Web应用程序一遍又一遍地以同样的根本缺陷被开发。
- en: 'Motivated by what they felt were systemic problems in modern application development,
    they drafted *The Twelve-Factor App*. This was a set of twelve rules and guidelines
    constituting a development methodology for building web applications, and by extension,
    cloud native applications (although “cloud native” wasn’t a commonly used term
    at the time). The methodology was for building web applications that: ^([12](ch06.xhtml#idm45983630456168))'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 受现代应用开发中系统性问题的驱使，他们起草了*十二要素应用程序*。这是一套包含十二条规则和指南的开发方法论，用于构建Web应用程序，并扩展到云原生应用程序（尽管当时“云原生”并不是一个常用的术语）。这一方法论是为了构建无需重大更改工具、架构或开发实践即可扩展的Web应用程序。
- en: Use declarative formats for setup automation, to minimize time and cost for
    new developers joining the project
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声明性格式进行设置自动化，以减少新开发者加入项目所需的时间和成本。
- en: Have a clean contract with the underlying operating system, offering maximum
    portability between execution environments
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与底层操作系统有清晰的契约，提供在执行环境之间最大的可移植性。
- en: Are suitable for deployment on modern cloud platforms, obviating the need for
    servers and systems administration
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合部署在现代云平台上，无需服务器和系统管理。
- en: Minimize divergence between development and production, enabling continuous
    deployment for maximum agility
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化开发与生产环境之间的差异，实现最大灵活性的持续部署。
- en: Can scale up without significant changes to tooling, architecture, or development
    practices
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在不显著改变工具、架构或开发实践的情况下进行扩展。
- en: While not fully appreciated when it was first published in 2011, as the complexities
    of cloud native development have become more widely understood (and felt), *The
    Twelve Factor App* and the properties it advocates have started to be cited as
    the bare minimum for any service to be cloud native.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在2011年首次发布时并未完全被重视，随着云原生开发复杂性变得更为广泛理解（和感受到），*十二要素应用程序*及其倡导的属性已开始被引用为任何服务成为云原生的最低标准。
- en: I. Codebase
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I. 代码库
- en: One codebase tracked in revision control, many deploys.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个代码库，在版本控制中跟踪，多次部署。
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用程序
- en: For any given service, there should be exactly one codebase that’s used to produce
    any number of immutable releases for multiple deployments to multiple environments.
    These environments typically include a production site, and one or more staging
    and development sites.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的服务，应有且仅有一个代码库用于生成多个不可变版本，以供部署到多个环境中。这些环境通常包括生产站点以及一个或多个暂存和开发站点。
- en: Having multiple services sharing the same code tends to lead to a blurring of
    the lines between modules, trending in time to something like a monolith, making
    it harder to make changes in one part of the service without affecting another
    part (or another service!) in unexpected ways. Instead, shared code should be
    refactored into libraries that can be individually versioned and included through
    a dependency manager.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个服务共享相同代码往往会导致模块之间的界限模糊，在时间上趋向于像单体应用，使得在不预期的方式下对服务的一个部分进行更改而影响另一个部分（或另一个服务！）变得更加困难。相反，共享代码应重构为可以单独进行版本控制并通过依赖管理器包含的库。
- en: Having a single service spread across multiple repositories, however, makes
    it nearly impossible to automatically apply the build and deploy phases of your
    service’s life cycle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将单个服务分布在多个代码库中几乎不可能自动应用服务生命周期中的构建和部署阶段。
- en: II. Dependencies
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: II. 依赖关系
- en: Explicitly declare and isolate (code) dependencies.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明确声明和隔离（代码）依赖项。
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: 'For any given version of the codebase, `go build`, `go test`, and `go run`
    should be deterministic: they should have the same result, however they’re run,
    and the product should always respond the same way to the same inputs.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码库的任何给定版本，`go build`，`go test`和`go run`应该是确定性的：无论如何运行它们，它们应该具有相同的结果，而且产品对相同的输入应该始终以相同的方式响应。
- en: But what if a dependency—an imported code package or installed system tool beyond
    the programmer’s control—changes in such a way that it breaks the build, introduces
    a bug, or becomes incompatible with the service?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果依赖项——一个程序员无法控制的导入代码包或安装的系统工具——以某种方式发生变化，导致构建失败，引入错误，或与服务不兼容呢？
- en: Most programming languages offer a packaging system for distributing support
    libraries, and Go is no different.^([13](ch06.xhtml#idm45983630435608)) By using
    [Go modules](https://oreil.ly/68ds1) to declare all dependencies, completely and
    exactly, you can ensure that imported packages won’t change out from under you
    and break your build in unexpected ways.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了用于分发支持库的打包系统，Go也不例外。^([13](ch06.xhtml#idm45983630435608)) 通过使用[Go
    模块](https://oreil.ly/68ds1)来完全准确地声明所有依赖关系，您可以确保导入的包不会在不被察觉地改变下破坏您的构建。
- en: To extend this somewhat, services should generally try to avoid using the `os/exec`
    package’s `Command` function to shell out to external tools like ImageMagick or
    `curl`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上来说，服务通常应尽量避免使用`os/exec`包的`Command`函数来外部调用像ImageMagick或`curl`这样的工具。
- en: Yes, your target tool might be available on all (or most) systems, but there’s
    no way to *guarantee* that they both exist and are fully compatible with the service
    everywhere that it might run in the present or future. Ideally, if your service
    requires an external tool, that tool should be *vendored* into the service by
    including it in the service’s repository.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你的目标工具可能在所有（或大多数）系统上都可用，但无法*保证*它们在当前或未来的任何可能运行的地方都存在并且与服务完全兼容。理想情况下，如果您的服务需要外部工具，那么该工具应该通过将其包含在服务的代码库中来*vendored*。
- en: III. Configuration
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: III. 配置
- en: Store configuration in the environment.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将配置存储在环境中。
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: Configuration—anything that’s likely to vary between environments (staging,
    production, developer environments, etc)—should always be cleanly separated from
    the code. Under no circumstances should an application’s configuration be baked
    into the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 配置——在不同环境（测试、生产、开发环境等）之间可能变化的任何内容——应始终与代码清晰分离。在任何情况下，应用程序的配置都不应该被嵌入到代码中。
- en: 'Configuration items may include, but certainly aren’t limited to:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置项可能包括但绝不限于：
- en: URLs or other resource handles to a database or other upstream service dependencies—even
    if it’s not likely to change any time soon.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库或其他上游服务依赖的URL或其他资源句柄——即使它在不久的将来可能不会更改。
- en: Secrets of *any* kind, such as passwords or credentials for external services.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型的机密信息，如外部服务的密码或凭据。
- en: Per-environment values, such as the canonical hostname for the deploy.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境值，例如部署的规范主机名。
- en: A common means of extracting configuration from code is by *externalizing* them
    into some configuration file—often YAML^([14](ch06.xhtml#idm45983630418920))—which
    may or may not be checked into the repository alongside the code. This is certainly
    an improvement over configuration-in-code, but it’s also less than ideal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将配置从代码中 *外部化* 到某个配置文件（通常是 YAML^([14](ch06.xhtml#idm45983630418920))），可以从存储库中随代码一起提交，也可以不提交。这当然比在代码中硬编码配置要好，但也不是理想的解决方案。
- en: First, if your configuration file lives outside of the repository, it’s all
    too easy to accidentally check it in. What’s more, such files tend to proliferate,
    with different versions for different environments living in different places,
    making it hard to see and manage configurations with any consistency.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果配置文件存储在存储库外部，很容易意外地检入。更重要的是，这些文件往往会蔓延，不同环境的不同版本存储在不同的位置，这样会使得难以以一致的方式查看和管理配置。
- en: Alternatively, you *could* have different versions of your configurations for
    each environment in the repository, but this can be unwieldy and tends to lead
    to some awkward repository acrobatics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，*你可以* 在存储库中为每个环境拥有不同版本的配置，但这可能会很笨重，并且往往会导致一些尴尬的存储库操作。
- en: 'Instead of configurations as code or even as external configurations, *The
    Twelve Factor App* recommends that configurations be stored as *environment variables*.
    Using environment variables in this way actually has a lot of advantages:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将配置作为代码或者外部配置，*The Twelve Factor App* 建议将配置存储为 *环境变量*。以这种方式使用环境变量实际上有很多优点：
- en: They are standard and largely OS and language agnostic.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是标准的，并且在大多数操作系统和语言中都是通用的。
- en: That are easy to change between deploys without changing any code.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不修改任何代码的情况下轻松在部署之间进行更改。
- en: They’re very easy to inject into containers.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常容易注入到容器中。
- en: Go has several tools for doing this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有几个用于此目的的工具。
- en: 'The first—and most basic—is the `os` package, which provides the `os.Getenv`
    function for this purpose:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种——也是最基本的——是 `os` 包，它提供了 `os.Getenv` 函数用于此目的：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For more sophisticated configuration options, there are several excellent packages
    available. Of these, [`spf13/viper`](https://oreil.ly/8giE4) seems to be particularly
    popular. A snippet of Viper in action might look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的配置选项，有几个优秀的包可供选择。其中，[`spf13/viper`](https://oreil.ly/8giE4) 似乎特别受欢迎。Viper
    的示例代码可能如下所示：
- en: '[PRE1]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionally, Viper provides a number of features that the standard packages
    do not, such as default values, typed variables, and reading from command-line
    flags, variously formatted configuration files, and even remote configuration
    systems like etcd and Consul.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Viper 提供了许多标准包不具备的功能，例如默认值、类型化变量以及从命令行标志、各种格式的配置文件，甚至是像 etcd 和 Consul 这样的远程配置系统。
- en: We’ll dive more deeply into Viper and other configuration topics in [Chapter 10](ch10.xhtml#chapter_10).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第十章](ch10.xhtml#chapter_10) 深入探讨 Viper 和其他配置主题。
- en: IV. Backing Services
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IV. 后备服务
- en: Treat backing services as attached resources.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将后备服务视为已附加的资源。
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二因素应用
- en: A backing service is any downstream dependency that a service consumes across
    the network as part of its normal operation (see [“Upstream and Downstream Dependencies”](ch01.xhtml#sidebar_ch01_dependencies)).
    A service should make no distinction between backing services of the same type.
    Whether it’s an internal service that’s managed within the same organization or
    a remote service managed by a third party should make no difference.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 后备服务是服务正常运行过程中通过网络消耗的任何下游依赖项（参见 [“上游和下游依赖”](ch01.xhtml#sidebar_ch01_dependencies)）。服务不应区分相同类型的后备服务。无论是由同一组织管理的内部服务，还是由第三方管理的远程服务，都不应该有任何区别。
- en: To the service, each distinct upstream service should be treated as just another
    resource, each addressable by a configurable URL or some other resource handle,
    as illustrated oi [Figure 6-3](#img_ch06_backing_services). All resources should
    be treated as equally subject to the *Fallacies of Distributed Computing* (see
    [Chapter 4](ch04.xhtml#chapter_4) for a refresher, if necessary).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务而言，每个不同的上游服务都应被视为另一个资源，每个都可以通过可配置的 URL 或其他资源句柄进行访问，如图 [6-3](#img_ch06_backing_services)
    所示。所有资源都应被视为同样容易受到 *分布式计算的谬论* 的影响（如果需要，可以参考 [第四章](ch04.xhtml#chapter_4) 进行复习）。
- en: '![cngo 0603](Images/cngo_0603.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0603](Images/cngo_0603.png)'
- en: Figure 6-3\. Each upstream service should be treated as just another resource,
    each addressable by a configurable URL or some other resource handle, each equally
    subject to the Fallacies of Distributed Computing
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 每个上游服务应被视为另一个资源，每个都可通过可配置的 URL 或其他资源句柄进行寻址，每个同样受到分布式计算谬误的影响
- en: In other words, a MySQL database run by your own team’s sysadmins should be
    treated no differently than an AWS-managed RDS instance. The same goes for *any*
    upstream service, whether it’s running in a data center in another hemisphere
    or in a Docker container on the same server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你自己团队的系统管理员运行的 MySQL 数据库应该和 AWS 管理的 RDS 实例没有区别。对于*任何*上游服务，无论它是运行在另一个半球的数据中心还是在同一台服务器上的
    Docker 容器中，都应如此对待。
- en: A service that’s able to swap out any resource at will with another one of the
    same kind—internally managed or otherwise—just by changing a configuration value
    can be more easily deployed to different environments, can be more easily tested,
    and more easily maintained.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改配置值，能够随意将任何资源替换为同类资源（内部管理或其他方式）的服务，可以更轻松地部署到不同的环境中，更容易进行测试，更易于维护。
- en: V. Build, Release, Run
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V. 构建、发布、运行
- en: Strictly separate build and run stages.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 严格区分构建和运行阶段。
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: Each (nondevelopment) deployment—the union of a specific version of the built
    code and a configuration—should be immutable and uniquely labeled. It should be
    possible, if necessary, to precisely recreate a deployment if (heaven forbid)
    it is necessary to roll a deployment back to an earlier version.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个（非开发）部署——特定版本的构建代码和配置的结合——应该是不可变的，并具有唯一的标签。如果有必要，应该能够精确地重新创建一个部署，如果（千万不得已的话）需要将部署回滚到较早版本。
- en: 'Typically, this is accomplished in three distinct stages, illustrated in [Figure 6-4](#img_ch06_build_release_run)
    and described in the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这通过三个明确的阶段完成，如[图 6-4](#img_ch06_build_release_run)所示，并在以下内容中描述：
- en: Build
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 构建
- en: In the build stage, an automated process retrieves a specific version of the
    code, fetches dependencies, and compiles an executable artifact we call a *build*.
    Every build should always have a unique identifier, typically a timestamp or an
    incrementing build number.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段，自动化流程检索特定版本的代码，获取依赖项，并编译一个我们称为*构建*的可执行工件。每个构建应始终具有唯一标识符，通常是时间戳或递增的构建编号。
- en: Release
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 发布
- en: 'In the release stage, a specific build is combined with a configuration specific
    to the target deployment. The resulting *release* is ready for immediate execution
    in the execution environment. Like builds, releases should also have a unique
    identifier. Importantly, producing releases with same version of a build shouldn’t
    involve a rebuild of the code: to ensure environment parity, each environment-specific
    configuration should use the same build artifact.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布阶段，特定的构建与目标部署的配置结合在一起。生成的*发布物*可以立即在执行环境中执行。和构建一样，发布物也应该有一个唯一的标识符。重要的是，使用相同构建版本生成发布物不应该涉及重新构建代码：为了确保环境一致性，每个环境特定的配置应使用相同的构建工件。
- en: Run
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行
- en: In the run stage, the release is delivered to the deployment environment and
    executed by launching the service’s processes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行阶段，发布物被交付到部署环境，并通过启动服务的进程来执行。
- en: Ideally, a new versioned build will be automatically produced whenever new code
    is deployed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每当部署新代码时，都应自动生成一个新版本化的构建。
- en: '![cngo 0604](Images/cngo_0604.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0604](Images/cngo_0604.png)'
- en: Figure 6-4\. The process of deploying a codebase to a (nondevelopment) environment
    should be performed in distinct build, release, and run stages
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 将代码库部署到（非开发）环境的过程应该在明确的构建、发布和运行阶段中执行
- en: VI. Processes
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VI. 进程
- en: Execute the app as one or more stateless processes.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将应用程序作为一个或多个无状态进程执行。
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: Service processes should be stateless and share nothing. Any data that has to
    be persisted should be stored in a stateful backing service, typically a database
    or external cache.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 服务过程应该是无状态的，并且彼此独立。任何需要持久化的数据都应存储在有状态的后端服务中，通常是数据库或外部缓存。
- en: We’ve already spent some time talking about statelessness—and we’ll spend more
    in the next chapter—so we won’t dive into this point any further.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经花了一些时间讨论无状态性——在下一章中我们会更多地讨论这一点，所以我们不会进一步深入这个问题。
- en: However, if you’re interested in reading ahead, feel free to take a look at
    [“State and Statelessness”](ch07.xhtml#section_ch07_state_and_statelessness).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有兴趣提前阅读，可以自由查看[“状态与无状态”](ch07.xhtml#section_ch07_state_and_statelessness)。
- en: VII. Data Isolation
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VII. 数据隔离
- en: Each service manages its own data.
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个服务管理自己的数据。
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cloud Native, Data Isolation
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 云原生，数据隔离
- en: Each service should be entirely *self-contained*. That is, it should manage
    its own data, and make its data accessible only via an API designed for that purpose.
    If this sounds familiar to you, good! This is actually one of the core principles
    of microservices, which we’ll discuss more in [“The Microservices System Architecture”](ch07.xhtml#section_ch07_microservices).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务应该是完全*自包含*的。也就是说，它应该管理自己的数据，并且只能通过专为此目的设计的 API 访问其数据。如果这听起来很熟悉，那很好！实际上，这是微服务的核心原则之一，我们将在[“微服务系统架构”](ch07.xhtml#section_ch07_microservices)中进一步讨论。
- en: Very often this will be implemented as a request-response service like a RESTful
    API or RPC protocol that’s exported by listening to requests coming in on a port,
    but this can also take the form of an asynchronous, event-based service using
    a publish-subscribe messaging pattern. Both of these patterns will be described
    in more detail in [Chapter 8](ch08.xhtml#chapter_8).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，这将被实现为一种请求-响应服务，如 RESTful API 或 RPC 协议，通过监听来自某个端口的请求来导出。但这也可以采用异步、基于事件的服务形式，使用发布-订阅消息模式。这两种模式将在[第
    8 章](ch08.xhtml#chapter_8)中详细描述。
- en: And finally, although this is something you don’t see in the Go world, some
    languages and frameworks allow the runtime injection of an application server
    into the execution environment to create a web-facing service. This practice limits
    testability and portability by breaking data isolation and environment agnosticism,
    and is *very strongly* discouraged.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管在 Go 世界中你不会看到这种情况，但某些语言和框架允许将应用服务器注入到执行环境中，以创建面向 Web 的服务。这种做法通过打破数据隔离和环境不可知性，限制了可测试性和可移植性，*强烈不建议*采用这种做法。
- en: VIII. Scalability
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VIII. 可扩展性
- en: Scale out via the process model.
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过进程模型进行扩展。
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二因素应用
- en: Services should be able to scale horizontally by adding more instances.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应该能够通过增加更多实例来水平扩展。
- en: 'We talk about scalability quite a bit in this book. We even dedicated all of
    [Chapter 7](ch07.xhtml#chapter_7) to it. With good reason: the importance of scalability
    can’t be understated.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中多次谈到可扩展性。我们甚至将整个[第 7 章](ch07.xhtml#chapter_7)专门讨论了这个问题。有充分的理由：可扩展性的重要性不可低估。
- en: Sure, it’s certainly convenient to just beef up the one server your service
    is running on—and that’s fine in the (very) short term—but vertical scaling is
    a losing strategy in the long run. If you’re lucky, you’ll eventually hit a point
    where you simply can’t scale up any more. It’s more likely that your single server
    will either suffer load spikes faster than you can scale up, or just die without
    warning and without a redundant failover.^([16](ch06.xhtml#idm45983630197768))
    Both scenarios end with a lot of unhappy users. We’ll discuss scalability quite
    a bit more in [Chapter 7](ch07.xhtml#chapter_7).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅加强运行服务的一个服务器确实很方便——在（非常）短期内这没问题，但在长期看来，纵向扩展是一种失败的策略。如果幸运的话，你最终会遇到一个无法再扩展的点。更有可能的是，你的单一服务器会在你无法扩展的速度下遭遇负载波动，或者突然死掉，而没有冗余的故障转移。^([16](ch06.xhtml#idm45983630197768))
    这两种情况都会导致大量不满的用户。我们会在[第 7 章](ch07.xhtml#chapter_7)中进一步讨论可扩展性。
- en: IX. Disposability
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IX. 可处置性
- en: Maximize robustness with fast startup and graceful shutdown.
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过快速启动和优雅关闭来最大化健壮性。
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二因素应用
- en: 'Cloud environments are fickle: provisioned servers have a funny way of disappearing
    at odd times. Services should account for this by being *disposable*: service
    instances should be able to be started or stopped—intentionally or not—at any
    time.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境非常靠不住：已经配置好的服务器有时会在奇怪的时间消失。服务应该考虑到这一点，采用*可处置*的方式：服务实例应能够随时启动或停止，无论是否有意。
- en: Services should strive to minimize the time it takes to start up to reduce the
    time it takes for the service to be deployed (or redeployed) to elastically scale.
    Go, having no virtual machine or other significant overhead, is especially good
    at this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应该努力将启动时间最小化，以减少部署（或重新部署）服务的时间，从而实现弹性扩展。由于 Go 语言没有虚拟机或其他重大开销，因此在这方面表现特别出色。
- en: 'Containers provide fast startup time and are also very useful for this, but
    care must be taken to keep image sizes small to minimize the data transfer overhead
    incurred with each initial deploy of a new image. This is another area in which
    Go excels: its self-sufficient binaries can generally be installed into `SCRATCH`
    images, without requiring an external language runtime or other external dependencies.
    We demonstrated this in the previous chapter, in [“Containerizing Your Key-Value
    Store”](ch05.xhtml#section_ch05_containerizing).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供快速的启动时间，并且在这方面也非常有用，但必须注意保持镜像大小小，以最小化每次部署新镜像时产生的数据传输开销。这是另一个Go语言的优点：它的自包含二进制文件通常可以安装到
    `SCRATCH` 镜像中，无需外部语言运行时或其他外部依赖。我们在前一章中已经展示了这一点，在 [“将您的键值存储容器化”](ch05.xhtml#section_ch05_containerizing)
    中。
- en: Services should also be capable of shutting down when they receive a `SIGTERM`
    signal by saving all data that needs to be saved, closing open network connections,
    or finishing any in-progress work that’s left or by returning the current job
    to the work queue.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还应当能够在收到 `SIGTERM` 信号时关闭，方法是保存所有需要保存的数据，关闭打开的网络连接，或完成未完成的工作，或将当前工作返回工作队列。
- en: X. Development/Production Parity
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X. 开发/生产对等性
- en: Keep development, staging, and production as similar as possible.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 开发、演示和生产环境应尽可能保持一致。
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: 'Any possible differences between development and production should be kept
    as small as possible. This includes code differences, of course, but it extends
    well beyond that:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可能的开发与生产之间的差异都应尽可能小。当然，这包括代码差异，但远不止于此：
- en: Code divergence
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分歧
- en: Development branches should be small and short-lived, and should be tested and
    deployed into production as quickly as possible. This minimizes functional differences
    between environments and reduces the risk of both deploys and rollbacks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 开发分支应该小而短命，应尽快进行测试并部署到生产环境中。这可以最小化环境之间的功能差异，并减少部署和回滚的风险。
- en: Stack divergence
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈分歧
- en: Rather than having different components for development and production (say,
    SQLite on OS X versus MySQL on Linux), environments should remain as similar as
    possible. Lightweight containers are an excellent tool for this. This minimizes
    the possibility that inconvenient differences between almost-but-not-quite-the-same
    implementations will emerge to ruin your day.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在开发和生产中使用不同的组件（例如，在OS X上使用SQLite而在Linux上使用MySQL），环境应尽可能保持一致。轻量级容器是实现这一目标的绝佳工具。这可以最大程度地减少因几乎相同但又不完全相同的实现之间的不便差异而可能导致的问题。
- en: Personnel divergence
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 人员分歧
- en: Once it was common to have programmers who wrote code and operators who deployed
    code, but that arrangement created conflicting incentives and counter-productive
    adversarial relationships. Keeping code authors involved in deploying their work
    and responsible for its behavior in production helps break down development/operations
    silos and aligns incentives around stability and velocity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，程序员编写代码，操作员部署代码很常见，但这种安排会造成冲突的激励机制和反生产的对抗性关系。让代码作者参与部署并对其在生产环境中的行为负责有助于打破开发与运维的隔阂，并且能够使稳定性与速度的激励机制保持一致。
- en: Taken together, these approaches help to keep the gap between development and
    production small, which in turn encourages rapid, automated, continuous deployment.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法共同作用，有助于缩小开发与生产之间的差距，从而促进快速、自动化和持续的部署。
- en: XI. Logs
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XI. 日志
- en: Treat logs as event streams.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将日志视为事件流。
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用
- en: Logs—a service’s never-ending stream of consciousness—are incredibly useful
    things, particularly in a distributed environment. By providing visibility into
    the behavior of a running application, good logging can greatly simplify the task
    of locating and diagnosing misbehavior.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 日志——服务的永不停息的意识流——在分布式环境中尤为有用。通过提供对运行应用程序行为的可见性，良好的日志记录可以极大简化定位和诊断错误的任务。
- en: Traditionally, services wrote log events to a file on the local disk. At cloud
    scale, however, this just makes valuable information awkward to find, inconvenient
    to access, and impossible to aggregate. In dynamic, ephemeral environments like
    Kubernetes your service instances (and their log files) may not even exist by
    the time you get around to viewing them.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，服务将日志事件写入本地磁盘上的文件。然而，在云规模下，这只会使有价值的信息难以查找、访问不便且无法聚合。在像Kubernetes这样的动态、短暂的环境中，您的服务实例（及其日志文件）甚至可能在您查看它们之前就已经不存在了。
- en: Instead, a cloud native service should treat log information as nothing more
    than a stream of events, writing each event, unbuffered, directly to `stdout`.
    It shouldn’t concern itself with implementation trivialities like routing or storage
    of its log events, and allow the executor to decide what happens to them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，云原生服务应将日志信息视为一系列事件流，直接将每个事件未经缓冲地写入`stdout`。它不应关注像路由或日志事件存储等实现细节，而是允许执行者决定如何处理它们。
- en: Though seemingly simple (and perhaps somewhat counterintuitive), this small
    change provides a great deal of freedom.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看似简单（甚至有些违反直觉），这一小改动却带来了极大的自由。
- en: During local development, a programmer can watch the event stream in a terminal
    to observe the service’s behavior. In deployment, the output stream can be captured
    by the execution environment and forwarded to one or more destinations, such as
    a log indexing system like Elasticsearch, Logstash, and Kibana (ELK) or Splunk
    for review and analysis, or a data warehouse for long-term storage.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发中，程序员可以在终端中观察事件流以观察服务的行为。在部署中，执行环境可以捕获输出流并转发到一个或多个目的地，例如日志索引系统（如Elasticsearch、Logstash和Kibana（ELK）或Splunk）以进行审查和分析，或数据仓库以进行长期存储。
- en: We’ll discuss logs and logging, in the context of observability, in more detail
    in [Chapter 11](ch11.xhtml#chapter_11).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](ch11.xhtml#chapter_11)更详细地讨论日志和日志记录，以观测性为背景。
- en: XII. Administrative Processes
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XII. 管理流程
- en: Run administrative/management tasks as one-off processes.
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将管理/管理任务作为一次性过程运行。
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Twelve-Factor App
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 十二要素应用程序
- en: Of all of the original Twelve Factors, this is the one that most shows its age.
    For one thing, it explicitly advocates shelling into an environment to manually
    execute tasks.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有原始的十二要素中，这是唯一明显显露其年龄的要素。首先，它明确提倡进入环境手动执行任务。
- en: 'To be clear: *making manual changes to a server instance creates snowflakes.
    This is a bad thing.* See [“Special Snowflakes”](#sidebar_ch06_snowflakes).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 明确一点：*对服务器实例进行手动更改会创建特定的个体（即“特别的雪花”）。这是不好的。*参见[“特别的雪花”](#sidebar_ch06_snowflakes)。
- en: Assuming you even have an environment that you can shell into, you should assume
    that it can (and eventually will) be destroyed and re-created any moment.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您拥有可以进入的环境，您应该假定它可以（并最终会）随时被销毁并重新创建。
- en: 'Ignoring all of that for a moment, let’s distill the point to its original
    intent: administrative and management tasks should be run as one-off processes.
    This could be interpreted in two ways, each requiring its own approach:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不考虑这一切，让我们将重点放在其最初的意图上：管理和管理任务应作为一次性过程运行。这可以有两种解释，每种都需要采用不同的方法：
- en: If your task is an administrative process, like a data repair job or database
    migration, it should be run as a short-lived process. Containers and functions
    are excellent vehicles for such purposes.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的任务是一个类似于数据修复或数据库迁移的管理流程，应将其作为短暂的过程运行。容器和函数是这类目的的极好载体。
- en: If your change is an update to your service or execution environment, you should
    instead modify your service or environment construction/configuration scripts,
    respectively.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的更改是对服务或执行环境的更新，则应修改相应的服务或环境构建/配置脚本。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter we considered the question “what’s the point of cloud native?”
    The common answer is “a computer system that works in the cloud.” But “work” can
    mean anything. Surely we can do better.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们考虑了“云原生的意义是什么？”这个问题。通常的答案是“在云中工作的计算机系统。”但“工作”可以指任何事情。我们当然可以做得更好。
- en: 'So we went back to thinkers like Tony Hoare and J-C Laprie, who provided the
    first part of the answer: *dependability*. That is, to paraphrase, computer systems
    that behave in ways that users find acceptable, despite living in a fundamentally
    unreliable environment.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们回到像托尼·霍尔和J-C·拉普里这样的思想家，他们提供了答案的第一部分：*可靠性*。换句话说，计算机系统应该以用户可接受的方式运行，尽管处于基本不可靠的环境中。
- en: 'Obviously, that’s more easily said than done, so we reviewed three schools
    of thought regarding how to achieve it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，说起来容易，做起来难，所以我们审视了三种关于如何实现它的思考方法：
- en: Laprie’s academic “means of dependability,” which include preventing, tolerating,
    removing, and forecasting faults
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laprie学术中的“可靠性手段”，包括预防、容忍、排除和故障预测。
- en: Adam Wiggins’ *Twelve Factor App*, which took a more prescriptive (and slightly
    dated, in spots) approach
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚当·威金斯的《十二要素应用》，它采用了更具规范性（在某些地方略显过时）的方法。
- en: Our own “cloud native attributes,” based on the Cloud Native Computing Foundation’s
    definition of “cloud native,” that we introduced in [Chapter 1](ch01.xhtml#chapter_1)
    and organized this entire book around
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自己的“云原生属性”，基于云原生计算基金会对“云原生”的定义，我们在[第1章](ch01.xhtml#chapter_1)中介绍，并围绕整本书组织。
- en: Although this chapter was essentially a short survey of theory, there’s a lot
    of important, foundational information here that describes the motivations and
    means used to achieve what we call “cloud native.”
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章本质上只是对理论的简短调查，但这里有许多重要的基础信息，描述了我们所称的“云原生”的动机和手段。
- en: ^([1](ch06.xhtml#idm45983630648552-marker)) Hoare, C.A.R. “An Axiomatic Basis
    for Computer Programming.”. *Communications of the ACM*, vol. 12, no. 10, October
    1969, pp. 576–583\. [*https://oreil.ly/jOwO9*](https://oreil.ly/jOwO9).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm45983630648552-marker)) C.A.R.霍尔。《计算机程序设计的公理基础》。*ACM通讯*，1969年10月，第12卷，第10期，第576-583页。[*https://oreil.ly/jOwO9*](https://oreil.ly/jOwO9).
- en: ^([2](ch06.xhtml#idm45983630641848-marker)) When Edsger W. Dijkstra coined the
    expression “GOTO considered harmful,” he was referencing Hoare’s work in structured
    programming.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#idm45983630641848-marker)) 当艾德斯格·W·迪科斯特拉（Edsger W. Dijkstra）创造出“GOTO被认为有害”这个表达时，他正是在引用霍尔在结构化编程中的工作。
- en: '^([3](ch06.xhtml#idm45983630640824-marker)) Hoare, Tony. “Null References:
    The Billion Dollar Mistake.” *InfoQ.com*. 25 August 2009\. [*https://oreil.ly/4QWS8*](https://oreil.ly/4QWS8).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#idm45983630640824-marker)) 托尼·霍尔。《空引用：十亿美元的错误》。*InfoQ.com*。2009年8月25日。[*https://oreil.ly/4QWS8*](https://oreil.ly/4QWS8).
- en: ^([4](ch06.xhtml#idm45983630609624-marker)) *Cloud Native Is About Culture,
    Not Containers*. Cummins, Holly. Cloud Native London 2018.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.xhtml#idm45983630609624-marker)) *云原生关乎文化，而非容器*。霍莉·卡明斯。云原生伦敦2018年。
- en: ^([5](ch06.xhtml#idm45983630608616-marker)) If you ever have a chance to see
    her speak, I strongly recommend you take it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.xhtml#idm45983630608616-marker)) 如果你有机会听她演讲，我强烈推荐你抓住机会。
- en: ^([6](ch06.xhtml#idm45983630606248-marker)) Remember what Walt did to Jane that
    time? That was so messed up.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.xhtml#idm45983630606248-marker)) 记得沃尔特那时对简的所作所为吗？真是太乱了。
- en: '^([7](ch06.xhtml#idm45983630599160-marker)) Laprie, J-C. “Dependable Computing
    and Fault Tolerance: Concepts and Terminology.” *FTCS-15 The 15th Int’l Symposium
    on Fault-Tolerant Computing*, June 1985, pp. 2–11\. [*https://oreil.ly/UZFFY*](https://oreil.ly/UZFFY).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.xhtml#idm45983630599160-marker)) J-C·拉普里。《可靠计算与容错：概念与术语》。第15届容错计算国际研讨会（FTCS-15），1985年6月，第2-11页。[*https://oreil.ly/UZFFY*](https://oreil.ly/UZFFY).
- en: ^([8](ch06.xhtml#idm45983630595768-marker)) A. Avižienis, J. Laprie, and B.
    Randell. “Fundamental Concepts of Computer System Dependability.” *Research Report
    No. 1145, LAAS-CNRS*, April 2001\. [*https://oreil.ly/4YXd1*](https://oreil.ly/4YXd1).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.xhtml#idm45983630595768-marker)) A·阿维兹涅斯、J·拉普里和B·兰德尔。《计算机系统可靠性基本概念》。LAAS-CNRS研究报告1145号，2001年4月。[*https://oreil.ly/4YXd1*](https://oreil.ly/4YXd1).
- en: '^([9](ch06.xhtml#idm45983630572776-marker)) If you haven’t, start with [*Site
    Reliability Engineering: How Google Runs Production Systems*](https://oreil.ly/OJn99).
    It really is very good.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '^([9](ch06.xhtml#idm45983630572776-marker)) 如果你还没有，从[*Site Reliability Engineering:
    How Google Runs Production Systems*](https://oreil.ly/OJn99)开始。真的非常好。'
- en: ^([10](ch06.xhtml#idm45983630567896-marker)) Many organizations use service-level
    objectives (SLOs) for precisely this purpose.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch06.xhtml#idm45983630567896-marker)) 许多组织使用服务水平目标（SLO）来达到精确的目的。
- en: ^([11](ch06.xhtml#idm45983630519656-marker)) Application state is hard, and
    when done wrong it’s poison to scalability.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch06.xhtml#idm45983630519656-marker)) 应用状态很难，如果做得不对，对可伸缩性是一种毒药。
- en: ^([12](ch06.xhtml#idm45983630456168-marker)) Wiggins, Adam. *The Twelve-Factor
    App.* 2011\. [*https://12factor.net*](https://12factor.net).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch06.xhtml#idm45983630456168-marker)) 亚当·威金斯的《十二要素应用》。2011年。[*https://12factor.net*](https://12factor.net).
- en: ^([13](ch06.xhtml#idm45983630435608-marker)) Although it was for too long!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch06.xhtml#idm45983630435608-marker)) 尽管那已经太久了！
- en: ^([14](ch06.xhtml#idm45983630418920-marker)) The world’s worst configuration
    language (except for all the other ones).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch06.xhtml#idm45983630418920-marker)) 世界上最糟糕的配置语言（除了其他所有的）。
- en: ^([15](ch06.xhtml#idm45983630247848-marker)) Wiggins, Adam. “Port Binding.”
    *The Twelve-Factor App.* 2011\. [*https://oreil.ly/bp8lC*](https://oreil.ly/bp8lC).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch06.xhtml#idm45983630247848-marker)) 亚当·威金斯。“端口绑定。” *十二要素应用.* 2011\.
    [*https://oreil.ly/bp8lC*](https://oreil.ly/bp8lC).
- en: ^([16](ch06.xhtml#idm45983630197768-marker)) Probably at three in the morning.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch06.xhtml#idm45983630197768-marker)) 可能是在凌晨三点钟。
- en: ^([17](ch06.xhtml#idm45983630143304-marker)) “Baking” is a term sometimes used
    to refer to the process of creating a new container or server image.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch06.xhtml#idm45983630143304-marker)) “烘焙”有时用来指代创建新容器或服务器镜像的过程。
