- en: 'Chapter 3\. call me: Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。请打电话给我：函数
- en: '![image](assets/f0079-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0079-01.png)'
- en: '**You’ve been missing out**. You’ve been calling functions like a pro. But
    the only functions you could call were the ones Go defined for you. Now, it’s
    your turn. We’re going to show you how to create your own functions. We’ll learn
    how to declare functions with and without parameters. We’ll declare functions
    that return a single value, and we’ll learn how to return multiple values so that
    we can indicate when there’s been an error. And we’ll learn about **pointers**,
    which allow us to make more memory-efficient function calls.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**你一直都在错过**。你已经像专业人士一样调用函数了。但是你能调用的函数只有 Go 为你定义的那些。现在轮到你了。我们将向你展示如何创建自己的函数。我们将学习如何声明带有和不带参数的函数。我们将声明返回单个值的函数，并学习如何返回多个值，以便在发生错误时指示。我们还将学习**指针**，它们允许我们进行更高效的内存管理。'
- en: Some repetitive code
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些重复的代码
- en: Suppose we need to calculate the amount of paint needed to cover several walls.
    The manufacturer says each liter of paint covers 10 square meters. So, we’ll need
    to multiply each wall’s width (in meters) by its height to get its area, and then
    divide that by 10 to get the number of liters of paint needed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要计算涂料涂抹若干墙壁所需的量。制造商称每升涂料可以覆盖 10 平方米。因此，我们需要将每堵墙的宽度（以米为单位）乘以其高度，得到其面积，然后除以
    10 得到所需的涂料升数。
- en: '![image](assets/f0080-01.png)![image](assets/f0080-02.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0080-01.png)![图片](assets/f0080-02.png)'
- en: 'This works, but it has a couple problems:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做虽然可行，但存在几个问题：
- en: The calculations seem to be off by a tiny fraction, and are printing oddly precise
    floating-point values. We really only need a couple decimal places of precision.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算结果似乎有微小的误差，并且打印出来的浮点数值显得异常精确。我们实际上只需要几位小数的精度。
- en: There’s a fair amount of repeated code, even now. This will get worse as we
    add more walls.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使现在也有相当多的重复代码。随着我们添加更多的墙壁，这个问题会变得更糟。
- en: Both items will take a little explanation to address, so let’s just look at
    the first issue for now...
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个问题都需要一些解释，所以现在先来看看第一个问题...
- en: The calculations are slightly off because ordinary floating-point arithmetic
    on computers is ever-so-slightly inaccurate. (Usually by a few quadrillionths.)
    The reasons are a little too complicated to get into here, but this problem isn’t
    exclusive to Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算略有偏差，因为计算机上的普通浮点数算术略微不精确。（通常是几百万亿分之几。）造成这种情况的原因有点复杂，这里不便深究，但这个问题并非 Go 所独有。
- en: But as long as we round the numbers to a reasonable degree of precision before
    displaying them, we should be fine. Let’s take a brief detour to look at a function
    that will help us do that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但只要我们在显示之前将数字四舍五入到一个合理的精度，那就没问题。让我们稍作停顿，看看一个可以帮助我们做到这一点的函数。
- en: '![image](assets/common3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: Formatting output with Printf and Sprintf
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Printf 和 Sprintf 格式化输出
- en: '![image](assets/common3.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: 'Floating-point numbers in Go are kept with a high degree of precision. This
    can be cumbersome when you want to display them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的浮点数保持着高度的精确度。当你想要显示它们时，这可能会有些麻烦：
- en: '![image](assets/f0081-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0081-01.png)'
- en: To deal with these sorts of formatting issues, the `fmt` package provides the
    `Printf` function. `Printf` stands for “**print**, with **f**ormatting.” It takes
    a string and inserts one or more values into it, formatted in specific ways. Then
    it prints the resulting string.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这类格式化问题，`fmt` 包提供了 `Printf` 函数。`Printf` 代表“**打印**，带有**格式化**”。它接受一个字符串，并在其中插入一个或多个值，以特定的方式格式化。然后打印出结果字符串。
- en: '![image](assets/f0081-02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0081-02.png)'
- en: The `Sprintf` function (also part of the `fmt` package) works just like `Printf`,
    except that it returns a formatted string instead of printing it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprintf` 函数（也是 `fmt` 包的一部分）与 `Printf` 函数的工作方式几乎一样，唯一的区别是它返回格式化后的字符串而不是直接打印出来。'
- en: '![image](assets/f0081-03.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0081-03.png)'
- en: 'It looks like `Printf` and `Sprintf` *can* help us limit our displayed values
    to the correct number of places. The question is, *how*? First, to be able to
    use the `Printf` function effectively, we’ll need to learn about two of its features:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `Printf` 和 `Sprintf` *可以* 帮助我们限制所显示的值的正确位数。问题在于，*如何*？首先，为了能够有效地使用 `Printf`
    函数，我们需要了解它的两个特性：
- en: Formatting verbs (the `%0.2f` in the strings above is a verb)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化动词（上述字符串中的 `%0.2f` 是一个动词）
- en: Value widths (that’s the `0.2` in the middle of the verb)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的宽度（这是动词中间的 `0.2`）
- en: Formatting verbs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化动词
- en: '![image](assets/common3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: The first argument to `Printf` is a string that will be used to format the output.
    Most of it is formatted exactly as it appears in the string. Any percent signs
    (`%`), however, will be treated as the start of a **formatting verb**, a section
    of the string that will be substituted with a value in a particular format. The
    remaining arguments are used as values with those verbs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Printf` 的第一个参数是一个字符串，将用于格式化输出。大部分字符串的格式化方式与其显示的方式完全一样。然而，任何百分号（`%`）都将被视为格式化动词的开始，这部分字符串将被替换为特定格式的值。其余的参数被用作这些动词的值。'
- en: '![image](assets/f0082-01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0082-01.png)'
- en: 'The letter following the percent sign indicates which verb to use. The most
    common verbs are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 百分号后面的字母表示要使用的动词。最常见的动词包括：
- en: '| Verb | Output |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | 输出 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| %f | Floating-point number |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| %f | 浮点数 |'
- en: '| %d | Decimal integer |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| %d | 十进制整数 |'
- en: '| %s | String |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| %s | 字符串 |'
- en: '| %t | Boolean (`true` or `false`) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| %t | 布尔值（`true` 或 `false`） |'
- en: '| %v | Any value (chooses an appropriate format based on the supplied value’s
    type) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| %v | 任意值（根据提供的值的类型选择适当的格式） |'
- en: '| %#v | Any value, formatted as it would appear in Go program code |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| %#v | 任意值，格式化为 Go 程序代码中的形式 |'
- en: '| %T | Type of the supplied value (`int`, `string`, etc.) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| %T | 提供的值的类型（`int`、`string`等） |'
- en: '| %% | A literal percent sign |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| %% | 字面上的百分号 |'
- en: '![image](assets/f0082-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0082-02.png)'
- en: Notice, by the way, that we are making sure to add a newline at the end of each
    formatting string using the `\n` escape sequence. This is because unlike `Println`,
    `Printf` does not automatically add a newline for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我们确保在每个格式化字符串的末尾添加一个换行符 `\n` 转义序列。这是因为与 `Println` 不同，`Printf` 不会为我们自动添加换行符。
- en: '![image](assets/common3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/common3.png)'
- en: We want to point out the `%#v` formatting verb in particular. Because it prints
    values the way they would appear in Go code, rather than how they normally appear,
    `%#v` can show you some values that would otherwise be hidden in your output.
    In this code, for example, `%#v` reveals an empty string, a tab character, and
    a newline, all of which were invisible when printed with `%v`. We’ll use `%#v`
    more, later in the book!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别想指出 `%#v` 格式化动词。因为它打印值的方式类似于它们在 Go 代码中的显示方式，而不是它们通常的显示方式，因此 `%#v` 可以显示出在
    `%v` 中隐藏的一些值。例如，在这段代码中，`%#v` 显示了一个空字符串、一个制表符和一个换行符，这些在使用 `%v` 打印时是看不到的。我们将在本书的后续部分更多地使用
    `%#v`！
- en: '![image](assets/f0083-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0083-01.png)'
- en: Formatting value widths
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化值的宽度
- en: So the `%f` formatting verb is for floating-point numbers. We can use `%f` in
    our program to format the amount of paint needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`%f` 格式化动词适用于浮点数。我们可以在我们的程序中使用 `%f` 格式化所需的油漆量。
- en: '![image](assets/f0083-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0083-02.png)'
- en: It looks like our value is being rounded to a reasonable number. But it’s still
    showing six places after the decimal point, which is really too much for our current
    purpose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的值被四舍五入到一个合理的数字。但是它仍然显示小数点后的六位，这对于我们当前的目的来说实在太多了。
- en: For situations like this, formatting verbs let you specify the *width* of the
    formatted value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的情况，格式化动词允许您指定格式化值的*宽度*。
- en: Let’s say we want to format some data in a plain-text table. We need to ensure
    the formatted value fills a minimum number of spaces, so that the columns align
    properly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在一个纯文本表格中格式化一些数据。我们需要确保格式化后的值填充到最小的空格数，以便列对齐。
- en: You can specify the minimum width after the percent sign for a formatting verb.
    If the argument matching that verb is shorter than the minimum width, it will
    be padded with spaces until the minimum width is reached.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在百分号后指定格式化动词的最小宽度。如果与该动词匹配的参数比最小宽度短，它将填充空格，直到达到最小宽度。
- en: '![image](assets/f0083-03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0083-03.png)'
- en: Formatting fractional number widths
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化小数位数的宽度
- en: '![image](assets/common3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/common3.png)'
- en: 'And now we come to the part that’s important for today’s task: you can use
    value widths to specify the precision (the number of displayed digits) for floating-point
    numbers. Here’s the format:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了今天任务中重要的部分：您可以使用值的宽度来指定浮点数的精度（显示的数字位数）。这是格式：
- en: '![image](assets/f0084-01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0084-01.png)'
- en: The minimum width of the entire number includes decimal places and the decimal
    point. If it’s included, shorter numbers will be padded with spaces at the start
    until this width is reached. If it’s omitted, no spaces will ever be added.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数字的最小宽度包括小数位和小数点。如果包括小数点，则较短的数字将在开始处用空格填充，直到达到这个宽度。如果省略小数点，则永远不会添加空格。
- en: The width after the decimal point is the number of decimal places to show. If
    a more precise number is given, it will be rounded (up or down) to fit in the
    given number of decimal places.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点后的宽度是要显示的小数位数。如果给出了更精确的数字，它将四舍五入（向上或向下）以适应给定的小数位数。
- en: 'Here’s a quick demonstration of various width values in action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里快速演示了各种宽度值的效果：
- en: '![image](assets/f0084-02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0084-02.png)'
- en: That last format, `"%.2f"`, will let us take floating-point numbers of any precision
    and round them to two decimal places. (It also won’t do any unnecessary padding.)
    Let’s try it with the overly precise values from our program to calculate paint
    volumes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述格式`"%.2f"`，可以将任意精度的浮点数四舍五入到两位小数。（它也不会添加任何不必要的填充。）让我们尝试一下，用我们程序中过于精确的值来计算油漆体积。
- en: '![image](assets/f0084-03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0084-03.png)'
- en: That’s much more readable. It looks like the `Printf` function can format our
    numbers for us. Let’s get back to our paint calculator program, and apply what
    we’ve learned there.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更易读了。看起来`Printf`函数可以为我们格式化数字。让我们回到我们的油漆计算器程序，并应用我们在那里学到的东西。
- en: '![image](assets/common4.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/common4.png)'
- en: Using Printf in our paint calculator
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的油漆计算器中使用Printf
- en: Now we have a `Printf` verb, `"%.2f"`, that will let us round a floating-point
    number to two decimal places. Let’s update our paint quantity calculation program
    to use it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Printf`动词`"%.2f"`，它将允许我们将浮点数四舍五入到两位小数。让我们更新我们的油漆数量计算程序来使用它。
- en: '![image](assets/f0085-01.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0085-01.png)'
- en: At last, we have reasonable-looking output! The tiny imprecisions introduced
    by floating-point arithmetic have been rounded away.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了合理的输出！浮点运算引入的微小不精确性已被四舍五入消除。
- en: '![image](assets/f0085-02.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0085-02.png)'
- en: '**Good point. Go lets us declare our own functions, so perhaps we should move
    this code into a function**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**好主意。Go允许我们声明自己的函数，因此也许我们应该将这段代码移到一个函数中**。'
- en: 'As we mentioned way back at the start of [Chapter 1](ch01.html#letapsos_get_going_syntax_basics),
    a function is a group of one or more lines of code that you can call from other
    places in your program. And our program has two groups of lines that look very
    similar:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第一章](ch01.html#letapsos_get_going_syntax_basics)开头提到的，函数是一组或多组可以从程序中的其他位置调用的代码行。我们的程序有两组看起来非常相似的行：
- en: '![image](assets/f0085-03.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0085-03.png)'
- en: Let’s see if we can convert these two sections of code into a single function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否将这两个代码部分转换为一个单一的函数。
- en: Declaring functions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数
- en: 'A simple function declaration might look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的函数声明可能看起来像这样：
- en: '![image](assets/f0086-01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0086-01.png)'
- en: A declaration begins with the `func` keyword, followed by the name you want
    the function to have, a pair of parentheses `()`, and then a block containing
    the function’s code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 声明以`func`关键字开头，后跟您希望函数具有的名称，一对括号`()`，然后是包含函数代码的块。
- en: Once you’ve declared a function, you can call it elsewhere in your package simply
    by typing its name, followed by a pair of parentheses. When you do, the code in
    the function’s block will be run.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了函数，你可以在包的其他地方简单地输入其名称，后跟一对括号，即可调用它。这样做时，函数块中的代码将被执行。
- en: '![image](assets/f0086-02.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0086-02.png)'
- en: Notice that when we call `sayHi`, we’re not typing the package name and a dot
    before the function name. When you call a function that’s defined in the current
    package, you should not specify the package name. (Typing `main.sayHi()` would
    result in a compile error.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用`sayHi`时，我们不需要输入包名和点号再输入函数名。当调用当前包中定义的函数时，不应指定包名。（键入`main.sayHi()`将导致编译错误。）
- en: 'The rules for function names are the same as the rules for variable names:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称的规则与变量名称的规则相同：
- en: A name must begin with a letter, followed by any number of additional letters
    and numbers. (You’ll get a compile error if you break this rule.)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须以字母开头，后跟任意数量的其他字母和数字。（如果违反此规则，将会得到编译错误。）
- en: Functions whose name begins with a capital letter are *exported*, and can be
    used outside the current package. If you only need to use a function inside the
    current package, you should start its name with a lowercase letter.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名以大写字母开头的函数是*导出*的，可以在当前包之外使用。如果只需在当前包内使用函数，应以小写字母开头命名。
- en: Names with multiple words should use `camelCase`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个单词的名称应使用`camelCase`。
- en: '![image](assets/f0086-03.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0086-03.png)'
- en: Declaring function parameters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数参数
- en: If you want calls to your function to include arguments, you’ll need to declare
    one or more parameters. A **parameter** is a variable, local to a function, whose
    value is set when the function is called.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望调用函数时包含参数，必须声明一个或多个参数。**参数**是函数内部局部变量，在调用函数时设置其值。
- en: '![image](assets/f0087-01.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0087-01.png)'
- en: You can declare one or more parameters between the parentheses in the function
    declaration, separated by commas. As with any variable, you’ll need to provide
    a name followed by a type (`float64`, `bool`, etc.) for each parameter you declare.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在函数声明的括号内部声明一个或多个参数，用逗号分隔。与任何变量一样，需要为每个声明的参数提供一个名称，后跟一个类型（`float64`、`bool`等）。
- en: '**A parameter is a variable, local to a function, whose value is set when the
    function is called.**'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**参数是函数内部局部变量，在调用函数时设置其值。**'
- en: If a function has parameters defined, then you’ll need to pass a matching set
    of arguments when calling it. When the function is run, each parameter will be
    set to a copy of the value in the corresponding argument. Those parameter values
    are then used within the code in the function block.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数定义了参数，则在调用函数时需要传递匹配的参数集。运行函数时，每个参数将设置为对应参数中值的副本。然后在函数块中使用这些参数值。
- en: '![image](assets/f0087-02.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0087-02.png)'
- en: Using functions in our paint calculator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的油漆计算器中使用函数
- en: Now that we know how to declare our own functions, let’s see if we can get rid
    of the repetition in our paint calculator.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何声明自己的函数了，让我们看看能否消除油漆计算器中的重复。
- en: '![image](assets/f0088-01.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0088-01.png)'
- en: We’ll move the code to calculate the amount of paint to a function named `paintNeeded`.
    We’ll get rid of the separate `width` and `height` variables, and instead take
    those as function parameters. Then, in our `main` function, we’ll just call `paintNeeded`
    for each wall we need to paint.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码移到名为`paintNeeded`的函数中来计算油漆的量。我们将不再使用单独的`width`和`height`变量，而是将它们作为函数参数传入。然后，在我们的`main`函数中，我们只需为需要涂料的每面墙调用`paintNeeded`函数。
- en: '![image](assets/f0088-02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0088-02.png)'
- en: No more repeated code, and if we want to calculate the paint needed for additional
    walls, we just add more calls to `paintNeeded`. This is much cleaner!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不再重复的代码，如果我们想要计算额外墙壁所需的涂料，只需添加更多对`paintNeeded`的调用。这样更加清晰！
- en: Functions and variable scope
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和变量作用域
- en: 'Our `paintNeeded` function declares an `area` variable within its function
    block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`paintNeeded`函数在其函数块内声明了一个`area`变量：
- en: '![image](assets/f0090-01.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0090-01.png)'
- en: 'As with conditional and loop blocks, variables declared within a function block
    are only in scope within that function block. So if we were to try to access the
    `area` variable outside of the `paintNeeded` function, we’d get a compile error:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与条件和循环块一样，函数块内声明的变量仅在该函数块内可见。因此，如果我们尝试在`paintNeeded`函数外部访问`area`变量，将会得到编译错误：
- en: '![image](assets/f0090-02.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0090-02.png)'
- en: But, also as with conditional and loop blocks, variables declared *outside*
    a function block will be in scope within that block. That means we can declare
    a variable at the package level, and access it within any function in that package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与条件和循环块一样，声明在函数块*外部*的变量将在该块内可见。这意味着我们可以在包级别声明一个变量，并在该包中的任何函数中访问它。
- en: '![image](assets/f0090-03.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0090-03.png)'
- en: Function return values
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数返回值
- en: Suppose we wanted to total the amount of paint needed for all the walls we’re
    going to paint. We can’t do that with our current `paintNeeded` function; it just
    prints the amount and then discards it!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算所有需要涂料的墙壁的总量。我们无法使用当前的`paintNeeded`函数来实现这一点；它只是打印出量然后将其丢弃！
- en: '![image](assets/f0091-01.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0091-01.png)'
- en: So instead, let’s revise the `paintNeeded` function to return a value. Then,
    whoever calls it can print the amount, do additional calculations with it, or
    do whatever else they need.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们修改`paintNeeded`函数来返回一个值。然后，调用它的人可以打印这个量，进行额外的计算，或者做其他他们需要做的事情。
- en: Functions always return values of a specific type (and only that type). To declare
    that a function returns a value, add the type of that return value following the
    parameters in the function declaration. Then use the `return` keyword in the function
    block, followed by the value you want to return.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数总是返回特定类型的值（仅限该类型）。要声明函数返回一个值，需在函数声明的参数后面添加返回值类型。然后在函数块中使用`return`关键字，后跟你想要返回的值。
- en: '![image](assets/f0091-02.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0091-02.png)'
- en: Callers of the function can then assign the return value to a variable, pass
    it directly to another function, or do whatever else they need to do with it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的人可以将返回值分配给变量，直接传递给另一个函数，或者以其他方式处理它们。
- en: '![image](assets/f0091-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0091-03.png)'
- en: When a `return` statement runs, the function exits immediately, without running
    any code that follows it. You can use this together with an `if` statement to
    exit the function in conditions where there’s no point in running the remaining
    code (due to an error or some other condition).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当`return`语句执行时，函数立即退出，不再运行其后面的任何代码。你可以结合`if`语句使用它，在条件下退出函数，避免运行剩余的代码（由于错误或其他条件）。
- en: '![image](assets/f0092-01.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0092-01.png)'
- en: That means that it’s possible to have code that never runs under any circumstances,
    if you include a `return` statement that isn’t part of an `if` block. This almost
    certainly indicates a bug in the code, so Go helps you detect this situation by
    requiring that any function that declares a return type must end with a `return`
    statement. Ending with any other statement will cause a compile error.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你包括一个不属于`if`块的`return`语句，可能有代码在任何情况下都不会运行。这几乎肯定表明代码中存在错误，因此 Go 通过要求任何声明返回类型的函数必须以`return`语句结束来帮助你检测这种情况。以其他任何语句结尾都会导致编译错误。
- en: '![image](assets/f0092-02.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0092-02.png)'
- en: You’ll also get a compile error if the type of your return value doesn’t match
    the declared return type.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的返回值类型与声明的返回类型不匹配，你也会得到编译错误。
- en: '![image](assets/f0092-03.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0092-03.png)'
- en: Using a return value in our paint calculator
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的涂料计算器中使用返回值
- en: Now that we know how to use function return values, let’s see if we can update
    our paint program to print the total amount of paint needed in addition to the
    amount needed for each wall.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用函数返回值了，让我们看看是否能更新我们的涂料程序，除了每面墙需要的量之外，还打印总共需要的涂料量。
- en: We’ll update the `paintNeeded` function to return the amount needed. We’ll use
    that return value in the `main` function, both to print the amount for the current
    wall, and to add to a `total` variable that tracks the total amount of paint needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新`paintNeeded`函数以返回所需的量。我们将在`main`函数中使用该返回值，既用于打印当前墙壁的量，又用于添加到`total`变量，以跟踪所需的总涂料量。
- en: '![image](assets/f0093-01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0093-01.png)'
- en: It works! Returning the value allowed our `main` function to decide what to
    do with the calculated amount, rather than relying on the `paintNeeded` function
    to print it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它奏效了！返回值使我们的`main`函数能够决定如何处理计算出的量，而不是依赖于`paintNeeded`函数来打印它。
- en: Breaking Stuff is Educational!
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏事物是教育性的！
- en: '![image](assets/f0094-01.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0094-01.png)'
- en: Here’s our updated version of the `paintNeeded` function that returns a value.
    Try making one of the changes below and try to compile it. Then undo your change
    and try the next one. See what happens!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们更新后的`paintNeeded`函数版本，它返回一个值。尝试进行以下变更之一并尝试编译它。然后撤销您的更改并尝试下一个。看看会发生什么！
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| If you do this... | ...it will break because... |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 如果你这样做... | ...它会崩溃，因为... |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Remove the `return` statement: `func paintNeeded(width float64, height float64)
    float64 { area := width * height ~~return area / 10.0~~ }` | If your function
    declares a return type, Go requires that it include a `return` statement. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 移除`return`语句：`func paintNeeded(width float64, height float64) float64 { area
    := width * height ~~return area / 10.0~~ }` | 如果函数声明了返回类型，Go 要求它包含一个`return`语句。
    |'
- en: '| Add a line *after* the `return` statement: `func paintNeeded(width float64,
    height float64) float64 { area := width * height return area / 10.0 fmt.Println(area
    / 10.0) }` | If your function declares a return type, Go requires that its last
    statement be a `return` statement. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 在`return`语句*之后*添加一行：`func paintNeeded(width float64, height float64) float64
    { area := width * height return area / 10.0 fmt.Println(area / 10.0) }` | 如果函数声明了返回类型，Go要求其最后一个语句必须是一个`return`语句。
    |'
- en: '| Remove the return type declaration: `func paintNeeded(width float64, height
    float64) float64 { area := width * height return area / 10.0 }` | Go doesn’t allow
    you to return a value you haven’t declared. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 删除返回类型声明：`func paintNeeded(width float64, height float64) float64 { area
    := width * height return area / 10.0 }` | Go不允许返回未声明的值。 |'
- en: '| Change the type of value being returned: `func paintNeeded(width float64,
    height float64) float64 { area := width * height return int(area / 10.0) }` |
    Go requires that the type of the returned value match the declared type. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 更改返回值的类型：`func paintNeeded(width float64, height float64) float64 { area
    := width * height return int(area / 10.0) }` | Go要求返回值的类型与声明的类型匹配。 |'
- en: The paintNeeded function needs error handling
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`paintNeeded`函数需要错误处理'
- en: '![image](assets/f0095-01.png)![image](assets/f0095-02.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0095-01.png)![image](assets/f0095-02.png)'
- en: It looks like the `paintNeeded` function had no idea the argument passed to
    it was invalid. It went right ahead and used that invalid argument in its calculations,
    and returned an invalid result. This is a problem—even if you knew a store where
    you could purchase a negative number of liters of paint, would you really want
    to apply that to your house? We need a way of detecting invalid arguments and
    reporting an error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`paintNeeded`似乎不知道传递给它的参数是无效的。它继续在计算中使用了这个无效的参数，并返回了一个无效的结果。这是一个问题——即使你知道一个商店可以购买负数升的油漆，你真的想把它应用到你的房子上吗？我们需要一种方法来检测无效的参数并报告错误。
- en: In [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition), we saw a
    couple different functions that, in addition to their main return value, also
    return a second value indicating whether there was an error. The `strconv.Atoi`
    function, for example, attempted to convert a string to an integer. If the conversion
    was successful, it returned an error value of `nil`, meaning our program could
    proceed. But if the error value *wasn’t* `nil`, it meant the string couldn’t be
    converted to a number. In that event, we chose to print the error value and exit
    the program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html#which_code_runs_nextquestcolon_condition)中，我们看到了几个不同的函数，除了它们的主要返回值外，还返回一个指示是否存在错误的第二个值。例如，`strconv.Atoi`函数尝试将字符串转换为整数。如果转换成功，它将返回一个`nil`的错误值，表示我们的程序可以继续执行。但如果错误值不是`nil`，则表示字符串无法转换为数字。在这种情况下，我们选择打印错误值并退出程序。
- en: '![image](assets/f0095-03.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0095-03.png)'
- en: 'If we want to do the same when calling the `paintNeeded` function, we’re going
    to need two things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在调用`paintNeeded`函数时想要做同样的事情，我们将需要两样东西：
- en: The ability to create a value representing an error
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表示错误的值的能力
- en: The ability to return an additional value from `paintNeeded`
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`paintNeeded`的额外值的能力
- en: Let’s get started figuring this out!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始弄清楚这个问题吧！
- en: Error values
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误值
- en: Before we can return an error value from our `paintNeeded` function, we need
    an error value to return. An error value is any value with a method named `Error`
    that returns a string. The simplest way to create one is to pass a string to the
    `errors` package’s `New` function, which will return a new error value. If you
    call the `Error` method on that error value, you’ll get the string you passed
    to `errors.New`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够从`paintNeeded`函数中返回一个错误值之前，我们需要一个错误值来返回。错误值是指具有名为`Error`并返回字符串的方法的任何值。创建一个最简单的方法是将字符串传递给`errors`包的`New`函数，它将返回一个新的错误值。如果你在该错误值上调用`Error`方法，你将得到你传递给`errors.New`的字符串。
- en: '![image](assets/f0096-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0096-01.png)'
- en: But if you’re passing the error value to a function in the `fmt` or `log` packages,
    you probably don’t need to call its `Error` method. Functions in `fmt` and `log`
    have been written to check whether the values passed to them have `Error` methods,
    and print the return value of `Error` if they do.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你将错误值传递给`fmt`或`log`包中的函数，你可能不需要调用它的`Error`方法。`fmt`和`log`中的函数已经被编写成检查传递给它们的值是否具有`Error`方法，并在需要时打印`Error`的返回值。
- en: '![image](assets/f0096-02.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0096-02.png)'
- en: If you need to format numbers or other values for use in your error message,
    you can use the `fmt.Errorf` function. It inserts values into a format string
    just like `fmt.Printf` or `fmt.Sprintf`, but instead of printing or returning
    a `string`, it returns an error value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要格式化数字或其他值以在错误消息中使用，可以使用`fmt.Errorf`函数。它将值插入到格式字符串中，类似于`fmt.Printf`或`fmt.Sprintf`，但不是打印或返回一个字符串，而是返回一个错误值。
- en: '![image](assets/f0096-03.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0096-03.png)'
- en: Declaring multiple return values
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明多个返回值
- en: Now we need a way to specify that our `paintNeeded` function will return an
    error value along with the amount of paint needed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一种方式来指定我们的`paintNeeded`函数将返回一个错误值和所需油漆的量。
- en: To declare multiple return values for a function, place the return value types
    in a *second* set of parentheses in the function declaration (after the parentheses
    for the function parameters), separated with commas. (The parentheses around the
    return values are optional when there’s only one return value, but are required
    if there’s more than one return value.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数声明多个返回值，请在函数声明中的第二组括号中放置返回值类型（在函数参数的括号之后），用逗号分隔。（如果只有一个返回值，返回值周围的括号是可选的，但如果有多个返回值，则是必需的。）
- en: From then on, when calling that function, you’ll need to account for the additional
    return values, usually by assigning them to additional variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，当调用该函数时，你需要考虑额外的返回值，通常是通过将它们赋值给额外的变量来处理。
- en: '![image](assets/f0097-01.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0097-01.png)'
- en: If it makes the purpose of the return values clearer, you can supply names for
    each one, similar to parameter names. The main purpose of named return values
    is as documentation for programmers reading the code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为返回值提供名称可以使其更清晰，类似于参数名称。命名返回值的主要目的是作为程序员阅读代码的文档。
- en: '![image](assets/f0097-02.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0097-02.png)'
- en: Using multiple return values with our paintNeeded function
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个返回值与我们的`paintNeeded`函数
- en: As we saw on the previous page, it’s possible to return multiple values of any
    type. But the most common use for multiple return values is to return a primary
    return value, followed by an additional value indicating whether the function
    encountered an error. The additional value is usually set to `nil` if there were
    no problems, or an error value if an error occurred.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一页看到的那样，可以返回任意类型的多个值。但多返回值的最常见用途是返回主要的返回值，后面跟着一个额外的值，指示函数是否遇到错误。如果没有问题，额外的值通常设为`nil`，如果发生错误则设为错误值。
- en: We’ll follow that convention with our `paintNeeded` function as well. We’ll
    declare that it returns two values, a `float64` and an `error`. (Error values
    have a type of `error`.) The first thing we’ll do in the function block is to
    check whether the parameters are valid. If either the `width` or `height` parameter
    is less than `0`, we’ll return a paint amount of `0` (which is meaningless, but
    we do have to return something), and an error value that we generate by calling
    `fmt.Errorf`. Checking for errors at the start of the function allows us to easily
    skip the rest of the function’s code by calling `return` if there’s a problem.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循`paintNeeded`函数的这一约定。我们声明它返回两个值，一个`float64`和一个`error`。（错误值的类型是`error`。）在函数块中的第一件事是检查参数是否有效。如果`width`或`height`参数小于`0`，我们将返回油漆量为`0`（这是无意义的，但我们必须返回一些东西），并且通过调用`fmt.Errorf`生成一个错误值。在函数开始时检查错误使我们可以通过调用`return`轻松地跳过函数代码的其余部分，如果有问题的话。
- en: If there were no problems with the parameters, we proceed to calculate and return
    the paint amount just like before. The only other difference in the function code
    is that we return a second value of `nil` along with the paint amount, to indicate
    there were no errors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数没有问题，我们将像以前一样继续计算和返回油漆量。函数代码中的唯一区别是，我们返回第二个值`nil`与油漆量一起，以表示没有错误。
- en: '![image](assets/f0098-01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0098-01.png)'
- en: In the `main` function, we add a second variable to record the error value from
    `paintNeeded`. We print the error (if any), and then print the paint amount.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们添加第二个变量来记录来自`paintNeeded`的错误值。我们打印错误（如果有的话），然后打印油漆量。
- en: If we pass an invalid argument to `paintNeeded`, we’ll get an error return value,
    and print that error. But we also get `0` as the amount of paint. (As we said,
    this value is meaningless when there’s an error, but we had to use *something*
    for the first return value.) So we wind up printing the message “0.00 liters needed”!
    We’ll need to fix that...
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`paintNeeded`传递一个无效的参数，我们将得到一个错误返回值，并打印该错误。但我们还会得到`0`作为涂料量。（正如我们所说，当有错误时，这个值是无意义的，但我们必须对第一个返回值使用*某些东西*。）因此，我们最终打印出了消息“0.00
    升液体需要”！我们需要修复这个问题...
- en: Always handle errors!
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总是处理错误！
- en: When we pass an invalid argument to `paintNeeded`, we get an error value back,
    which we print for the user to see. But we also get an (invalid) amount of paint,
    which we print as well!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向`paintNeeded`传递无效的参数时，我们会得到一个错误值，我们将其打印供用户查看。但我们还得到了一个（无效的）涂料量，我们也将其打印了出来！
- en: '![image](assets/f0099-01.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0099-01.png)'
- en: When a function returns an error value, it usually has to return a primary return
    value as well. But any other return values that accompany an error value should
    be considered unreliable, and ignored.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回一个错误值时，通常也必须返回一个主要的返回值。但是伴随错误值返回的任何其他返回值应被视为不可靠，并被忽略。
- en: When you call a function that returns an error value, it’s important to test
    whether that value is `nil` before proceeding. If it’s anything other than `nil`,
    it means there’s an error that must be handled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个返回错误值的函数时，重要的是在继续之前测试该值是否为`nil`。如果它不是`nil`，意味着有一个必须处理的错误。
- en: '*How* the error should be handled depends on the situation. In the case of
    our `paintNeeded` function, it might be best to simply skip the current calculation
    and proceed with the rest of the program:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*如何*处理错误取决于具体情况。在我们的`paintNeeded`函数的情况下，最好只是跳过当前计算，并继续执行程序的其余部分：'
- en: '![image](assets/f0099-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0099-02.png)'
- en: But since this is such a short program, you could instead call `log.Fatal` to
    display the error message and exit the program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于这是一个如此简短的程序，你可以调用`log.Fatal`来显示错误消息并退出程序。
- en: '![image](assets/f0099-03.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0099-03.png)'
- en: The important thing to remember is that you should always check the return values
    to see whether there *is* an error. What you do with the error at that point is
    up to you!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，你应该始终检查返回值，看看是否*有*错误。在那一点上，你对错误的处理方式由你决定！
- en: Breaking Stuff is Educational!
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解东西是教育性的！
- en: '![image](assets/f0100-01.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0100-01.png)'
- en: Here’s a program that calculates the square root of a number. But if a negative
    number is passed to the `squareRoot` function, it will return an error value.
    Make one of the changes below and try to compile it. Then undo your change and
    try the next one. See what happens!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算数字平方根的程序。但是如果将负数传递给`squareRoot`函数，它将返回一个错误值。做出以下一种修改并尝试编译它。然后撤销你的修改并尝试下一种。看看会发生什么！
- en: '[PRE1]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| If you do this... | ...it will break because... |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 如果你这样做... | ...它会破解因为... |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Remove one of the arguments to `return`: `return math.Sqrt(number)~~, nil~~`
    | The number of arguments to `return` must always match the number of return values
    in the function declaration. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 移除一个`return`的参数：`return math.Sqrt(number)~~, nil~~` | `return`语句中的参数数量必须始终与函数声明中的返回值数量匹配。
    |'
- en: '| Remove one of the variables the return values are assigned to: `root~~, err~~
    := squareRoot(-9.3)` | If you use any of the return values from a function, Go
    requires you to use all of them. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 移除其中一个变量的返回值赋值：`root~~, err~~ := squareRoot(-9.3)` | 如果你使用了函数的任何返回值，Go 要求你使用所有的返回值。
    |'
- en: '| Remove the code that uses one of the return values: `root, err := squareRoot(-9.3)
    ~~if err != nil {~~ ~~fmt.Println(err)~~ ~~} else {~~ fmt.Printf("%0.3f", root)
    ~~}~~` | Go requires that you use every variable you declare. This is actually
    a really useful feature when it comes to error return values, because it helps
    keep you from accidentally ignoring an error. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 移除使用其中一个返回值的代码：`root, err := squareRoot(-9.3) ~~if err != nil {~~ ~~fmt.Println(err)~~
    ~~} else {~~ fmt.Printf("%0.3f", root) ~~}~~` | Go 要求你使用你声明的每一个变量。这实际上是一个非常有用的特性，特别是在处理错误返回值时，它有助于防止意外忽略错误。
    |'
- en: Pool Puzzle
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池难题
- en: '![image](assets/f0101-01.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0101-01.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in the code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make code that will run
    and produce the output shown.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从池中选择代码片段，并将它们放入代码中的空白行中。**不要**重复使用同一个片段，并且不需要使用所有片段。你的**目标**是编写能够运行并产生所示输出的代码。
- en: '![image](assets/f0101-02.png)![image](assets/f0101-03.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0101-02.png)![image](assets/f0101-03.png)'
- en: '**Note: each snippet from the pool can only be used once!**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个池中的片段只能使用一次！**'
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_2).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 答案在 [“池谜题解答”](#pool_puzzle_solution_2)。'
- en: Function parameters receive copies of the arguments
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数接收参数的副本
- en: As we mentioned, when you call a function that has parameters declared, you
    need to provide arguments to the call. The value in each argument is *copied*
    to the corresponding parameter variable. (Programming languages that do this are
    sometimes called “pass-by-value.”)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，当你调用声明了参数的函数时，需要为调用提供参数。每个参数中的值都被*复制*到对应的参数变量中。（执行此操作的编程语言有时被称为“传值”。）
- en: '**Go is a “pass-by-value” language; function parameters receive a copy of the
    arguments from the function call.**'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Go 是一种“传值”语言；函数参数接收函数调用中参数的一个副本。**'
- en: This is fine in most cases. But if you want to pass a variable’s value to a
    function and have it *change* the value in some way, you’ll run into trouble.
    The function can only change the *copy* of the value in its parameter, not the
    original. So any changes you make within the function won’t be visible outside
    it!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下这没问题。但是如果你想将变量的值传递给函数，并以某种方式*更改*该值，你会遇到麻烦。函数只能更改其参数中值的*副本*，而不能更改原始值。因此，在函数内部进行的任何更改都不会在函数外部可见！
- en: Here’s an updated version of the `double` function we showed earlier. It takes
    a number, multiplies it by 2, and prints the result. (It uses the `*=` operator,
    which works just like `+=` , but it multiplies the value the variable holds instead
    of adding to it.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前展示的 `double` 函数的更新版本。它接受一个数字，将其乘以 2，并打印结果。（它使用 `*=` 运算符，工作方式与 `+=` 相同，但它将变量的值乘以而不是加上。）
- en: '![image](assets/f0102-01.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0102-01.png)'
- en: Suppose we wanted to move the statement that prints the doubled value from the
    `double` function back to the function that calls it, though. It won’t work, because
    `double` only alters its *copy* of the value. Back in the calling function, when
    we try to print, we’ll get the original value, not the doubled one!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将打印加倍值的语句从 `double` 函数移回调用它的函数中。这是行不通的，因为 `double` 只会修改它的*值副本*。回到调用函数时，我们将得到原始值，而不是加倍后的值！
- en: '![image](assets/f0102-02.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0102-02.png)'
- en: We need a way to allow a function to alter the original value a variable holds,
    rather than a copy. To learn how to do that, we’ll need to make one more detour
    away from functions, to learn about *pointers*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法，允许函数改变变量原始值，而不是副本。为了学会如何做到这一点，我们需要再次偏离函数，学习关于*指针*的内容。
- en: '![image](assets/common3.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/common3.png)'
- en: Pointers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: '![image](assets/common3.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/common3.png)'
- en: You can get the *address* of a variable using `&` (an ampersand), which is Go’s
    “address of” operator. For example, this code initializes a variable, prints its
    value, and then prints the variable’s address...
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `&`（一个&符号）来获取变量的*地址*，这是 Go 的“地址”运算符。例如，这段代码初始化一个变量，打印其值，然后打印变量的地址...
- en: '![image](assets/f0103-01.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0103-01.png)'
- en: We can get addresses for variables of any type. Notice that the address differs
    for each variable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取任何类型变量的地址。请注意，每个变量的地址都是不同的。
- en: '![image](assets/f0103-02.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0103-02.png)'
- en: And what are these “addresses,” exactly? Well, if you want to find a particular
    house in a crowded city, you use its address...
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些“地址”究竟是什么？嗯，如果你想在拥挤的城市中找到特定的房子，你会使用它的地址...
- en: '![image](assets/f0103-03.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0103-03.png)'
- en: 'Just like a city, the memory your computer sets aside for your program is a
    crowded place. It’s full of variable values: booleans, integers, strings, and
    more. Just like the address of a house, if you have the address of a variable,
    you can use it to find the value that variable contains.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 就像城市一样，计算机为程序设置的内存是一个拥挤的地方。它充满了变量值：布尔值、整数、字符串等。就像房屋的地址一样，如果你有一个变量的地址，你可以用它来找到该变量包含的值。
- en: '![image](assets/f0103-04.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0103-04.png)'
- en: Values that represent the address of a variable are known as **pointers**, because
    they *point* to the location where the variable can be found.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 代表变量地址的值被称为**指针**，因为它们*指向*变量所在的位置。
- en: '![image](assets/f0103-05.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0103-05.png)'
- en: Pointer types
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针类型
- en: '![image](assets/common3.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: The type of a pointer is written with a `*` symbol, followed by the type of
    the variable the pointer points to. The type of a pointer to an `int` variable,
    for example, would be written `*int` (you can read that aloud as “pointer to `int`”).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的类型写作`*`符号，后面跟着指针指向的变量的类型。例如，指向`int`变量的指针的类型会写作`*int`（你可以把它读作“pointer to `int`”）。
- en: 'We can use the `reflect.TypeOf` function to show us the types of our pointers
    from the previous program:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`reflect.TypeOf`函数来显示上一个程序中指针的类型：
- en: '![image](assets/f0104-01.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0104-01.png)'
- en: We can declare variables that hold pointers. A pointer variable can only hold
    pointers to one type of value, so a variable might only hold `*int` pointers,
    only `*float64` pointers, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明变量来持有指针。指针变量只能持有同一类型值的指针，因此一个变量可能只能持有`*int`指针，只能持有`*float64`指针，等等。
- en: '![image](assets/f0104-02.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0104-02.png)'
- en: 'As with other types, if you’ll be assigning a value to the pointer variable
    right away, you can use a short variable declaration instead:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，如果你将立即给指针变量赋值，可以使用简短的变量声明：
- en: '![image](assets/f0104-03.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0104-03.png)'
- en: Getting or changing the value at a pointer
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取或更改指针指向的值
- en: '![image](assets/common3.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: You can get the value of the variable a pointer refers to by typing the `*`
    operator right before the pointer in your code. To get the value at `myIntPointer`,
    for example, you’d type `*myIntPointer`. (There’s no official consensus on how
    to read `*` aloud, but we like to pronounce it as “value at,” so `*myIntPointer`
    is “value at `myIntPointer`.”)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在代码中指定`*`操作符之前的指针来获取指针引用的变量的值。例如，要获取`myIntPointer`的值，你可以输入`*myIntPointer`。（关于如何读取`*`没有官方共识，但我们喜欢将其发音为“value
    at”，所以`*myIntPointer`就是“value at `myIntPointer`”。）
- en: '![image](assets/f0105-01.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0105-01.png)'
- en: 'The `*` operator can also be used to update the value at a pointer:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`操作符也可以用来更新指针指向的值：'
- en: '![image](assets/f0105-02.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0105-02.png)'
- en: In the code above, `*myIntPointer = 8` accesses the variable at `myIntPointer`
    (that is, the `myInt` variable) and assigns a new value to it. So not only is
    the value of `*myIntPointer` updated, but `myInt` is as well.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`*myIntPointer = 8` 访问了`myIntPointer`指向的变量（即`myInt`变量），并给它赋了一个新值。因此不仅更新了`*myIntPointer`的值，也更新了`myInt`的值。
- en: Code Magnets
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁
- en: '![image](assets/f0106-01.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0106-01.png)'
- en: A Go program that uses a pointer variable is scrambled up on the fridge. Can
    you reconstruct the code snippets to make a working program that will produce
    the given output?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用指针变量的Go程序在冰箱上被打乱了。你能重组代码片段，使之成为一个可以产生给定输出的工作程序吗？
- en: The program should declare `myInt` as an integer variable, and `myIntPointer`
    as a variable that holds an integer pointer. Then it should assign a value to
    `myInt`, and assign a pointer to `myInt` as the value of `myIntPointer`. Finally,
    it should print the value at `myIntPointer`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该将`myInt`声明为整数变量，将`myIntPointer`声明为整数指针变量。然后应该给`myInt`赋一个值，并将`myInt`的指针赋给`myIntPointer`。最后，应该打印`myIntPointer`的值。
- en: '![image](assets/f0106-02.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0106-02.png)'
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_3).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](assets/arrow.png) 答案在[“代码磁铁解决方案”](#code_magnets_solution_3)。'
- en: Using pointers with functions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针与函数
- en: '![image](assets/common3.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common3.png)'
- en: It’s possible to return pointers from functions; just declare that the function’s
    return type is a pointer type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从函数中返回指针；只需声明函数的返回类型为指针类型即可。
- en: '![image](assets/f0107-01.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0107-01.png)'
- en: (By the way, unlike in some other languages in Go, it’s okay to return a pointer
    to a variable that’s local to a function. Even though that variable is no longer
    in scope, as long as you still have the pointer, Go will ensure you can still
    access the value.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，与其他一些语言不同，在Go中，返回一个指向函数内部局部变量的指针是可以的。尽管该变量不再在作用域内，只要你仍然拥有指针，Go就会确保你仍然可以访问该值。）
- en: You can also pass pointers to functions as arguments. Just specify that the
    type of one or more parameters should be a pointer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将指针作为参数传递给函数。只需指定一个或多个参数的类型应为指针类型。
- en: '![image](assets/f0107-02.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0107-02.png)'
- en: Make sure you only use pointers as arguments, if that’s what the function declares
    it will take. If you try to pass a value directly to a function that’s expecting
    a pointer, you’ll get a compile error.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 确保只有在函数声明它将接受指针时才使用指针作为参数。如果尝试将一个值直接传递给期望指针的函数，会导致编译错误。
- en: '![image](assets/f0107-03.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0107-03.png)'
- en: Now you know the basics of using pointers in Go. We’re ready to end our detour,
    and fix our `double` function!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解如何在Go语言中使用指针的基础知识。我们已经准备结束我们的迂回，并修复我们的`double`函数！
- en: '![image](assets/common4.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/common4.png)'
- en: Fixing our “double” function using pointers
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针修复我们的“double”函数
- en: We have a `double` function that takes an `int` value and multiplies it by 2\.
    We want to be able to pass a value in and have that value doubled. But, as we
    learned, Go is a pass-by-value language, meaning that function parameters receive
    a *copy* of any arguments from the caller. Our function is doubling its copy of
    the value and leaving the original untouched!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`double`函数，它接受一个`int`值并将其乘以2。我们希望能够传递一个值并使该值加倍。但是正如我们所学到的，Go语言是按值传递的，这意味着函数参数接收来自调用者的任何参数的*副本*。我们的函数将其值加倍并保持原始值不变！
- en: '![image](assets/f0108-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0108-01.png)'
- en: Here’s where our detour to learn about pointers is going to be useful. If we
    pass a pointer to the function and then alter the value at that pointer, the changes
    will still be effective outside the function!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们为了学习指针而进行的迂回之处。如果我们向函数传递一个指针，然后在该指针处更改值，这些更改仍将在函数外部生效！
- en: We only need to make a few small changes to get this working. In the `double`
    function, we need to update the type of the `number` parameter to take a `*int`
    rather than an `int`. Then we’ll need to change the function code to update the
    value at the `number` pointer, rather than updating a variable directly. Finally,
    in the `main` function, we just need to update our call to `double` to pass a
    pointer rather than a direct value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做一些小改动就能让它正常工作。在`double`函数中，我们需要更新`number`参数的类型，使其接受`*int`而不是`int`。然后我们需要修改函数代码以更新`number`指针的值，而不是直接更新一个变量。最后，在`main`函数中，我们只需要更新对`double`的调用，传递一个指针而不是直接值。
- en: '![image](assets/f0108-02.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0108-02.png)'
- en: When we run this updated code, a pointer to the `amount` variable will be passed
    to the `double` function. The `double` function will take the value at that pointer
    and double it, thereby changing the value in the `amount` variable. When we return
    to the `main` function and print the `amount` variable, we’ll see our doubled
    value!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个更新后的代码时，将会传递指向`amount`变量的指针给`double`函数。`double`函数将会取该指针处的值并将其加倍，从而改变`amount`变量的值。当我们返回`main`函数并打印`amount`变量时，我们将看到我们加倍后的值！
- en: You’ve learned a lot about writing your own functions in this chapter. The benefits
    of some of these features may not be clear right now. Don’t worry—as our programs
    get more complex in later chapters, we’ll be making good use of everything you’ve
    learned!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了如何编写自己的函数。这些功能的一些好处现在可能还不太明显。别担心——随着我们在后面章节中编写更复杂的程序，你所学到的一切将会派上用场！
- en: Your Go Toolbox
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的Go工具箱
- en: '![image](assets/f0110-01.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0110-01.png)'
- en: '**That’s it for [Chapter 3](#call_mecolon_functions)! You’ve added function
    declarations and pointers to your toolbox.**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**至此，[第三章](#call_mecolon_functions)就结束了！你已经在工具箱中添加了函数声明和指针。**'
- en: '![image](assets/f0110-02.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0110-02.png)'
- en: Pool Puzzle Solution
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池子难题解决方案
- en: '![image](assets/f0112-01.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0112-01.png)'
- en: Code Magnets Solution
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码磁铁解决方案
- en: '![image](assets/f0112-02.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0112-02.png)'
