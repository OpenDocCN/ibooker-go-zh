<html><head></head><body><section data-pdf-bookmark="Chapter 3. gRPC Communication Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_03">&#13;
<h1><span class="label">Chapter 3. </span>gRPC Communication Patterns</h1>&#13;
&#13;
&#13;
<p><a data-primary="communication patterns" data-type="indexterm" id="ix_ch03-asciidoc0"/>In the first couple of chapters, you learned the basics of gRPC’s inter-process communication techniques and got some hands-on experience in building a simple gRPC-based application. So far what we have done is define a service interface, implement a service, run a gRPC server, and invoke service operations remotely through a gRPC client application. The communication pattern between the client and the server is a simple request–response style communication, where you get a single response for a single request. However, with gRPC, you can leverage different inter-process communication patterns (or RPC styles) other than the simple request–response pattern.</p>&#13;
&#13;
<p>In this chapter, we’ll explore four fundamental communication patterns used in gRPC-based applications: unary RPC (simple RPC), server-side streaming, client-side streaming, and bidirectional streaming. We’ll use some real-world use cases to showcase each pattern, define a service definition using a gRPC IDL, and implement both the service and client side using Go.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><strong>Go and Java Code Samples</strong></p>&#13;
&#13;
<p>To maintain consistency, all the code samples in this chapter are written using Go. But if you are a Java developer, you can also find the complete Java code samples for the same use cases in the source code repository for this book.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple RPC (Unary RPC)" data-type="sect1"><div class="sect1" id="idm46536643918312">&#13;
<h1>Simple RPC (Unary RPC)</h1>&#13;
&#13;
<p><a data-primary="communication patterns" data-secondary="simple RPC" data-type="indexterm" id="ix_ch03-asciidoc1"/><a data-primary="RPC (remote procedure call)" data-secondary="simple" data-type="indexterm" id="ix_ch03-asciidoc2"/><a data-primary="simple RPC" data-type="indexterm" id="ix_ch03-asciidoc3"/><a data-primary="unary RPC" data-type="indexterm" id="ix_ch03-asciidoc4"/>Let’s begin our discussion on gRPC communication patterns with the simplest RPC style, <em>simple RPC</em>, which is also known as <em>unary RPC</em>. In simple RPC, when a client invokes a remote function of a server, the client sends a single request to the server and gets a single response that is sent along with status details and trailing metadata. In fact, this is exactly the same communication pattern that you learned in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.html#grpc_ch_01">1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ch_02">2</a>. Let’s try to understand the simple RPC pattern further with a real-world use case.</p>&#13;
&#13;
<p>Suppose we need to build an <code>OrderManagement</code> service for an online retail application based on gRPC. One of the methods that we have to implement as part of this service is a <code>getOrder</code> method, where the client can retrieve an existing order by providing the order ID. As shown in <a data-type="xref" href="#simple_unary_rpc">Figure 3-1</a>, the client is sending a single request with the order ID and the service responds with a single response that contains the order information. Hence, it follows the simple RPC pattern.</p>&#13;
&#13;
<figure><div class="figure" id="simple_unary_rpc">&#13;
<img alt="Simple/unary RPC" src="assets/grpc_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Simple/unary RPC</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s proceed to the implementation of this pattern. The first step is to create the service definition for the <code>OrderManagement</code> service with the <code>getOrder</code> method. As shown in the code snippet in <a data-type="xref" href="#EX3-1">Example 3-1</a>, we can define the service definition using protocol buffers, and the <code>getOrder</code> remote method takes a single request order ID and responds with a single response, which comprises the <code>Order</code> message. The <code>Order</code> message has the required structure to represent the order in this use case.</p>&#13;
<div data-type="example" id="EX3-1">&#13;
<h5><span class="label">Example 3-1. </span>Service definition of OrderManagement with getOrder method that uses simple RPC pattern</h5>&#13;
&#13;
<pre data-code-language="protobuf" data-type="programlisting"><code class="na">syntax</code><code> </code><code class="o">=</code><code> </code><code class="s">"proto3"</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="k">import</code><code> </code><code class="s">"google/protobuf/wrappers.proto"</code><code class="p">;</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO1-1" id="co_grpc_communication_patterns_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code class="kn">package</code><code> </code><code class="nn">ecommerce</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="kd">service</code><code> </code><code class="n">OrderManagement</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">rpc</code><code> </code><code class="n">getOrder</code><code class="p">(</code><code class="n">google.protobuf.StringValue</code><code class="p">)</code><code> </code><code class="k">returns</code><code> </code><code class="p">(</code><code class="n">Order</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO1-2" id="co_grpc_communication_patterns_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="kd">message</code><code> </code><code class="nc">Order</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO1-3" id="co_grpc_communication_patterns_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="na">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="k">repeated</code><code> </code><code class="kt">string</code><code> </code><code class="na">items</code><code> </code><code class="o">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO1-4" id="co_grpc_communication_patterns_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="na">description</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">float</code><code> </code><code class="na">price</code><code> </code><code class="o">=</code><code> </code><code class="mi">4</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="na">destination</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO1-1" id="callout_grpc_communication_patterns_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use this package to leverage the well-known types such as <code>StringValue</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO1-2" id="callout_grpc_communication_patterns_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Remote method for retrieving an order.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO1-3" id="callout_grpc_communication_patterns_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Define the <code>Order</code> type.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO1-4" id="callout_grpc_communication_patterns_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>repeated</code> is used to represent the fields that can be repeated any number of times including zero in a message. Here one order message can have any number of items.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Then, using the gRPC service definition proto file, you can generate the server skeleton code and implement the logic of the <code>getOrder</code> method. In the code snippet in <a data-type="xref" href="#EX3-2">Example 3-2</a>, what we have shown is the Go implementation of the <code>OrderManagement</code> service. As the input of the <code>getOrder</code> method, you get a single order ID (<code>String</code>) as the request and you can simply find the order from the server side and respond with an <code>Order</code> message (<code>Order</code> struct). The <code>Order</code> message can be returned along with a nil error to tell gRPC that we’ve finished dealing with the RPC and the <code>Order</code> can be returned to the client.</p>&#13;
<div data-type="example" id="EX3-2">&#13;
<h5><span class="label">Example 3-2. </span>Service implementation of OrderManagement with getOrder in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// server/main.go</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">server</code><code class="p">)</code> <code class="nx">GetOrder</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code>&#13;
	<code class="nx">orderId</code> <code class="o">*</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">pb</code><code class="p">.</code><code class="nx">Order</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
     <code class="c1">// Service Implementation.</code>&#13;
	<code class="nx">ord</code> <code class="o">:=</code> <code class="nx">orderMap</code><code class="p">[</code><code class="nx">orderId</code><code class="p">.</code><code class="nx">Value</code><code class="p">]</code>&#13;
	<code class="k">return</code> <code class="o">&amp;</code><code class="nx">ord</code><code class="p">,</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The low-level details of the complete message flow of a gRPC server and client are explained in <a data-type="xref" href="ch04.html#ch_04">Chapter 4</a>. In addition to the method parameters that we have specified for the <code>getOrder</code> method in your service definition, you can observe that there is another <code>Context</code> parameter passed to the method in the preceding Go implementation of the <code>OrderManagement</code> service. <code>Context</code> carries some of the constructs such as deadlines and cancellations that are used to control gRPC behavior. We’ll discuss those concepts in detail in <a data-type="xref" href="ch05.html#ch_05">Chapter 5</a>.</p>&#13;
</div>&#13;
&#13;
<p>Now let’s implement the client-side logic to invoke the <code>getOrder</code> method remotely. As with the server-side implementation, you can generate code for the preferred language to create the client-side stub and then use that stub to invoke the service. In <a data-type="xref" href="#EX3-3">Example 3-3</a>, we have used a Go gRPC client to invoke the <code>OrderManagement</code> service. The first steps, of course, are to set up the connection to the server and initiate the client stub to invoke the service. Then you can simply invoke the client stub’s <code>getOrder</code> method to invoke the remote method. As the response, you get an <code>Order</code> message that contains the order information that we define using protocol buffers in our service definition.</p>&#13;
<div data-type="example" id="EX3-3">&#13;
<h5><span class="label">Example 3-3. </span>Client implementation to invoke remote method getOrder using Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Setting up a connection to the server.</code>&#13;
<code class="o">...</code>&#13;
<code class="nx">orderMgtClient</code> <code class="o">:=</code> <code class="nx">pb</code><code class="p">.</code><code class="nx">NewOrderManagementClient</code><code class="p">(</code><code class="nx">conn</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
&#13;
<code class="c1">// Get Order</code>&#13;
<code class="nx">retrievedOrder</code> <code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">orderMgtClient</code><code class="p">.</code><code class="nx">GetOrder</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code>&#13;
       <code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code> <code class="s">"106"</code><code class="p">})</code>&#13;
<code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"GetOrder Response -&gt; : "</code><code class="p">,</code> <code class="nx">retrievedOrder</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>The simple RPC pattern is quite straightforward to implement and fits well for most inter-process communication use cases. The implementation is quite similar across multiple programming languages, and you can find the source code for Go and Java in the sample source code repository of the book.<a data-startref="ix_ch03-asciidoc4" data-type="indexterm" id="idm46536643628696"/><a data-startref="ix_ch03-asciidoc3" data-type="indexterm" id="idm46536643628088"/><a data-startref="ix_ch03-asciidoc2" data-type="indexterm" id="idm46536643627480"/><a data-startref="ix_ch03-asciidoc1" data-type="indexterm" id="idm46536643626840"/></p>&#13;
&#13;
<p>Now, since you have a good understanding of the simple RPC communication pattern, let’s move on to <em>server-streaming RPC</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Server-Streaming RPC" data-type="sect1"><div class="sect1" id="idm46536643917688">&#13;
<h1>Server-Streaming RPC</h1>&#13;
&#13;
<p><a data-primary="communication patterns" data-secondary="server-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc5"/><a data-primary="RPC (remote procedure call)" data-secondary="server-streaming" data-type="indexterm" id="ix_ch03-asciidoc6"/><a data-primary="server-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc7"/><a data-primary="streaming" data-secondary="server-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc8"/>In simple RPC you always had a single request and single response in the communication between the gRPC server and gRPC client. In server-side streaming RPC, the server sends back a sequence of responses after getting the client’s request message. <a data-primary="stream" data-secondary="defined" data-type="indexterm" id="idm46536643618664"/>This sequence of multiple responses is known as a “stream.” After sending all the server responses, the server marks the end of the stream by sending the server’s status details as trailing metadata to the client.</p>&#13;
&#13;
<p>Let’s take a real-world use case to understand server-side streaming further. In our <code>OrderManagement</code> service suppose that we need to build an order search capability where we can provide a search term and get the matching results (<a data-type="xref" href="#server_streaming_rpc">Figure 3-2</a>). Rather than sending all the matching orders at once, the <code>OrderManagement</code> service can send the orders as and when they are found. This means the order service client will receive multiple response messages for a single request that it has sent.</p>&#13;
&#13;
<figure><div class="figure" id="server_streaming_rpc">&#13;
<img alt="Server-streaming RPC" src="assets/grpc_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Server-streaming RPC</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s include a <code>searchOrder</code> method in our gRPC service definition of the <code>OrderManagement</code> service. As shown in <a data-type="xref" href="#EX3-4">Example 3-4</a>, the method definition is quite similar to simple RPC, but as the return parameter, you have to specify a <em>stream</em> of orders by using <code>returns (stream Order)</code> in the proto file of the service definition.</p>&#13;
<div data-type="example" id="EX3-4">&#13;
<h5><span class="label">Example 3-4. </span>Service definition with server-side streaming RPC</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">syntax</code><code> </code><code class="p">=</code><code> </code><code class="s">"proto3"</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="kn">import</code><code> </code><code class="s">"google/protobuf/wrappers.proto"</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="kn">package</code><code> </code><code class="nx">ecommerce</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="nx">service</code><code> </code><code class="nx">OrderManagement</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="o">...</code><code>&#13;
</code><code>    </code><code class="nx">rpc</code><code> </code><code class="nx">searchOrders</code><code class="p">(</code><code class="nx">google</code><code class="p">.</code><code class="nx">protobuf</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">)</code><code> </code><code class="nx">returns</code><code> </code><code class="p">(</code><code class="nx">stream</code><code> </code><code class="nx">Order</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO2-1" id="co_grpc_communication_patterns_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="o">...</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">message</code><code> </code><code class="nx">Order</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">id</code><code> </code><code class="p">=</code><code> </code><code class="mi">1</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="nx">repeated</code><code> </code><code class="kt">string</code><code> </code><code class="nx">items</code><code> </code><code class="p">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">description</code><code> </code><code class="p">=</code><code> </code><code class="mi">3</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">float</code><code> </code><code class="nx">price</code><code> </code><code class="p">=</code><code> </code><code class="mi">4</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">destination</code><code> </code><code class="p">=</code><code> </code><code class="mi">5</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO2-1" id="callout_grpc_communication_patterns_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Defining server-side streaming by returning a <code>stream</code> of <code>Order</code> messages.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>From the service definition, you can generate the server-side code and then by implementing the generated interfaces you build the logic of the <code>searchOrder</code> method of the <code>OrderManagement</code> gRPC service. In the Go implementation shown in <a data-type="xref" href="#EX3-5">Example 3-5</a>, the <code>SearchOrders</code> method has two parameters: <code>searchQuery</code>, a string value, and a special parameter <code>OrderManagement_SearchOrdersServer</code> to write our responses to. <code>OrderManagement_SearchOrdersServer</code> acts as a reference object to the stream that we can write multiple responses to. The business logic here is to find the matching orders and send them one by one via the stream. When a new order is found, it is written to the stream using the <code>Send(…)</code> method of the stream reference object. Once all the responses are written to the stream you can mark the end of the stream by returning <code>nil</code>, and the server status and other trailing metadata will be sent to the client.</p>&#13;
<div data-type="example" id="EX3-5">&#13;
<h5><span class="label">Example 3-5. </span>Service implementation of OrderManagement with searchOrders in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code> </code><code class="p">(</code><code class="nx">s</code><code> </code><code class="o">*</code><code class="nx">server</code><code class="p">)</code><code> </code><code class="nx">SearchOrders</code><code class="p">(</code><code class="nx">searchQuery</code><code> </code><code class="o">*</code><code class="nx">wrappers</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">,</code><code>&#13;
</code><code>	</code><code class="nx">stream</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">OrderManagement_SearchOrdersServer</code><code class="p">)</code><code> </code><code class="kt">error</code><code> </code><code class="p">{</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="k">for</code><code> </code><code class="nx">key</code><code class="p">,</code><code> </code><code class="nx">order</code><code> </code><code class="o">:=</code><code> </code><code class="k">range</code><code> </code><code class="nx">orderMap</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code><code> </code><code class="nx">order</code><code class="p">)</code><code>&#13;
</code><code>		</code><code class="k">for</code><code> </code><code class="nx">_</code><code class="p">,</code><code> </code><code class="nx">itemStr</code><code> </code><code class="o">:=</code><code> </code><code class="k">range</code><code> </code><code class="nx">order</code><code class="p">.</code><code class="nx">Items</code><code> </code><code class="p">{</code><code>&#13;
</code><code>			</code><code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="nx">itemStr</code><code class="p">)</code><code>&#13;
</code><code>			</code><code class="k">if</code><code> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Contains</code><code class="p">(</code><code>&#13;
</code><code>				</code><code class="nx">itemStr</code><code class="p">,</code><code> </code><code class="nx">searchQuery</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO3-1" id="co_grpc_communication_patterns_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
				</code><code class="c1">// Send the matching orders in a stream&#13;
</code><code>				</code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">stream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">order</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO3-2" id="co_grpc_communication_patterns_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
				</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>				   </code><code class="k">return</code><code> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code>&#13;
</code><code>					    </code><code class="s">"error sending message to stream : %v"</code><code class="p">,</code><code>&#13;
</code><code>						    </code><code class="nx">err</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO3-3" id="co_grpc_communication_patterns_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
				</code><code class="p">}</code><code>&#13;
</code><code>				</code><code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Matching Order Found : "</code><code> </code><code class="o">+</code><code> </code><code class="nx">key</code><code class="p">)</code><code>&#13;
</code><code>				</code><code class="k">break</code><code>&#13;
</code><code>			</code><code class="p">}</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>	</code><code class="k">return</code><code> </code><code class="kc">nil</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO3-1" id="callout_grpc_communication_patterns_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Find matching orders.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO3-2" id="callout_grpc_communication_patterns_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Send matching order through the stream.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO3-3" id="callout_grpc_communication_patterns_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Check for possible errors that could occur when streaming messages to the client.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The remote method invocation from the client side is quite similar to simple RPC. However, here you have to process multiple responses as the server writes multiple responses to the stream. So in the Go implementation of the gRPC client (<a data-type="xref" href="#EX3-6">Example 3-6</a>), we retrieve messages from the client-side stream using the <code>Recv()</code> method and keep doing so until we reach the end of the stream.</p>&#13;
<div data-type="example" id="EX3-6">&#13;
<h5><span class="label">Example 3-6. </span>Client implementation of OrderManagement with searchOrders in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Setting up a connection to the server.&#13;
</code><code class="o">...</code><code>&#13;
</code><code>	</code><code class="nx">c</code><code> </code><code class="o">:=</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">NewOrderManagementClient</code><code class="p">(</code><code class="nx">conn</code><code class="p">)</code><code>&#13;
</code><code class="o">...</code><code>&#13;
</code><code>     </code><code class="nx">searchStream</code><code class="p">,</code><code> </code><code class="nx">_</code><code> </code><code class="o">:=</code><code> </code><code class="nx">c</code><code class="p">.</code><code class="nx">SearchOrders</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code>&#13;
</code><code>     	</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code> </code><code class="s">"Google"</code><code class="p">}</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO4-1" id="co_grpc_communication_patterns_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
	</code><code class="k">for</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">searchOrder</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">searchStream</code><code class="p">.</code><code class="nx">Recv</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO4-2" id="co_grpc_communication_patterns_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
		</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">==</code><code> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO4-3" id="co_grpc_communication_patterns_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
			</code><code class="k">break</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>           </code><code class="c1">// handle other possible errors&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Print</code><code class="p">(</code><code class="s">"Search Result : "</code><code class="p">,</code><code> </code><code class="nx">searchOrder</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO4-1" id="callout_grpc_communication_patterns_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>SearchOrders</code> function returns a client stream of <code>OrderManagement_SearchOrders​Client</code>, which has a <code>Recv</code> method.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO4-2" id="callout_grpc_communication_patterns_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Calling the client stream’s <code>Recv()</code> method to retrieve <code>Order</code> responses one by one.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO4-3" id="callout_grpc_communication_patterns_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>When the end of the stream is found <code>Recv</code> returns an <code>io.EOF</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Now let’s look at client-streaming RPC, which is pretty much the opposite of server-streaming RPC. <a data-startref="ix_ch03-asciidoc8" data-type="indexterm" id="idm46536643173608"/><a data-startref="ix_ch03-asciidoc7" data-type="indexterm" id="idm46536643134168"/><a data-startref="ix_ch03-asciidoc6" data-type="indexterm" id="idm46536643133560"/><a data-startref="ix_ch03-asciidoc5" data-type="indexterm" id="idm46536643132952"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Client-Streaming RPC" data-type="sect1"><div class="sect1" id="idm46536643624664">&#13;
<h1>Client-Streaming RPC</h1>&#13;
&#13;
<p><a data-primary="client-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc9"/><a data-primary="communication patterns" data-secondary="client-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc10"/><a data-primary="RPC (remote procedure call)" data-secondary="client-streaming" data-type="indexterm" id="ix_ch03-asciidoc11"/><a data-primary="streaming" data-secondary="client-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc12"/>In client-streaming RPC, the client sends multiple messages to the server instead of a single request. The server sends back a single response to the client. However, the server does not necessarily have to wait until it receives all the messages from the client side to send a response. Based on this logic you may send the response after reading one or a few messages from the stream or after reading all the messages.</p>&#13;
&#13;
<p>Let’s further extend our <code>OrderManagement</code> service to understand client-streaming RPC. Suppose you want to include a new method, <code>updateOrders</code>, in the <code>OrderManagement</code> service to update a set of orders (<a data-type="xref" href="#client_streaming_rpc">Figure 3-3</a>). Here we want to send the order list as a stream of messages to the server and server will process that stream and send a message with the status of the orders that are updated.</p>&#13;
&#13;
<figure><div class="figure" id="client_streaming_rpc">&#13;
<img alt="Client Streaming RPC" src="assets/grpc_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Client-streaming RPC</h6>&#13;
</div></figure>&#13;
&#13;
<p>Then we can include the <code>updateOrders</code> method in our service definition of the <code>OrderManagement</code> service as shown in <a data-type="xref" href="#EX3-7">Example 3-7</a>. You can simply use <code>stream order</code> as the method parameter of <code>updateOrders</code> to denote that <code>updateOrders</code> will get multiple messages as the input from the client. As the server only sends a single response, the return value is a single string message.</p>&#13;
<div data-type="example" id="EX3-7">&#13;
<h5><span class="label">Example 3-7. </span>Service definition with client-side streaming RPC</h5>&#13;
&#13;
<pre data-code-language="proto" data-type="programlisting"><code class="na">syntax</code> <code class="o">=</code> <code class="s">"proto3"</code><code class="p">;</code>&#13;
&#13;
<code class="k">import</code> <code class="s">"google/protobuf/wrappers.proto"</code><code class="p">;</code>&#13;
&#13;
<code class="kn">package</code> <code class="nn">ecommerce</code><code class="p">;</code>&#13;
&#13;
<code class="kd">service</code> <code class="n">OrderManagement</code> <code class="p">{</code>&#13;
<code class="o">...</code>&#13;
    <code class="k">rpc</code> <code class="n">updateOrders</code><code class="p">(</code><code class="n">stream</code> <code class="n">Order</code><code class="p">)</code> <code class="k">returns</code> <code class="p">(</code><code class="n">google.protobuf.StringValue</code><code class="p">);</code>&#13;
<code class="o">...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">message</code> <code class="nc">Order</code> <code class="p">{</code>&#13;
    <code class="kt">string</code> <code class="na">id</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
    <code class="k">repeated</code> <code class="kt">string</code> <code class="na">items</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
    <code class="kt">string</code> <code class="na">description</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>&#13;
    <code class="kt">float</code> <code class="na">price</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>&#13;
    <code class="kt">string</code> <code class="na">destination</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Once we update the service definition, we can generate the server- and client-side code. At the server side, you need to implement the generated method interface of the <code>UpdateOrders</code> method of the <code>OrderManagement</code> service. In the Go implementation shown in <a data-type="xref" href="#EX3-8">Example 3-8</a>, <code>UpdateOrders</code> has an <code>OrderManagement_UpdateOrdersServer</code> parameter, which is the reference object to the incoming message stream from the client. Therefore, you can read messages via that object by calling the <code>Recv()</code> method. Depending on the business logic, you may read a few messages or all the messages until the end of the stream. The service can send its response simply by calling the <code>SendAndClose</code> method of the <code>OrderManagement_UpdateOrdersServer</code> object, which also marks the end of the stream for server-side messages. If the server decides to prematurely stop reading from the client’s stream, the server should cancel the client stream so the client knows to stop producing messages.</p>&#13;
<div data-type="example" id="EX3-8">&#13;
<h5><span class="label">Example 3-8. </span>Service implementation of OrderManagement with updateOrders method in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code> </code><code class="p">(</code><code class="nx">s</code><code> </code><code class="o">*</code><code class="nx">server</code><code class="p">)</code><code> </code><code class="nx">UpdateOrders</code><code class="p">(</code><code class="nx">stream</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">OrderManagement_UpdateOrdersServer</code><code class="p">)</code><code> </code><code class="kt">error</code><code> </code><code class="p">{</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="nx">ordersStr</code><code> </code><code class="o">:=</code><code> </code><code class="s">"Updated Order IDs : "</code><code>&#13;
</code><code>	</code><code class="k">for</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">order</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">stream</code><code class="p">.</code><code class="nx">Recv</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO5-1" id="co_grpc_communication_patterns_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
		</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">==</code><code> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO5-2" id="co_grpc_communication_patterns_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
			</code><code class="c1">// Finished reading the order stream.&#13;
</code><code>			</code><code class="k">return</code><code> </code><code class="nx">stream</code><code class="p">.</code><code class="nx">SendAndClose</code><code class="p">(</code><code>&#13;
</code><code>				</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code> </code><code class="s">"Orders processed "</code><code>&#13;
</code><code>				</code><code class="o">+</code><code> </code><code class="nx">ordersStr</code><code class="p">}</code><code class="p">)</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>		</code><code class="c1">// Update order&#13;
</code><code>		</code><code class="nx">orderMap</code><code class="p">[</code><code class="nx">order</code><code class="p">.</code><code class="nx">Id</code><code class="p">]</code><code> </code><code class="p">=</code><code> </code><code class="o">*</code><code class="nx">order</code><code>&#13;
</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Order ID "</code><code class="p">,</code><code> </code><code class="nx">order</code><code class="p">.</code><code class="nx">Id</code><code class="p">,</code><code> </code><code class="s">": Updated"</code><code class="p">)</code><code>&#13;
</code><code>		</code><code class="nx">ordersStr</code><code> </code><code class="o">+=</code><code> </code><code class="nx">order</code><code class="p">.</code><code class="nx">Id</code><code> </code><code class="o">+</code><code> </code><code class="s">", "</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO5-1" id="callout_grpc_communication_patterns_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read message from the client stream.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO5-2" id="callout_grpc_communication_patterns_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Check for end of stream.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Now let’s look at the client-side implementation of the client-streaming RPC use case. As shown in the following Go implementation (<a data-type="xref" href="#EX3-9">Example 3-9</a>), the client can send multiple messages via the client-side stream reference using the <code>updateStream.Send</code> method. Once all the messages are streamed the client can mark the end of the stream and receive the response from the service. This is done using the <code>CloseAndRecv</code> method of the stream reference.</p>&#13;
<div data-type="example" id="EX3-9">&#13;
<h5><span class="label">Example 3-9. </span>Client implementation of OrderManagement with updateOrders method in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Setting up a connection to the server.&#13;
</code><code class="o">...</code><code>&#13;
</code><code>	</code><code class="nx">c</code><code> </code><code class="o">:=</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">NewOrderManagementClient</code><code class="p">(</code><code class="nx">conn</code><code class="p">)</code><code>&#13;
</code><code class="o">...</code><code>&#13;
</code><code>     </code><code class="nx">updateStream</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">client</code><code class="p">.</code><code class="nx">UpdateOrders</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO6-1" id="co_grpc_communication_patterns_CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO6-2" id="co_grpc_communication_patterns_CO6-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.UpdateOrders(_) = _, %v"</code><code class="p">,</code><code> </code><code class="nx">client</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="c1">// Updating order 1&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">updateStream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">updOrder1</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO6-3" id="co_grpc_communication_patterns_CO6-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code>&#13;
</code><code>			</code><code class="nx">updateStream</code><code class="p">,</code><code> </code><code class="nx">updOrder1</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO6-4" id="co_grpc_communication_patterns_CO6-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="c1">// Updating order 2&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">updateStream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">updOrder2</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code>&#13;
</code><code>			</code><code class="nx">updateStream</code><code class="p">,</code><code> </code><code class="nx">updOrder2</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="c1">// Updating order 3&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">updateStream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">updOrder3</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code>&#13;
</code><code>			</code><code class="nx">updateStream</code><code class="p">,</code><code> </code><code class="nx">updOrder3</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="nx">updateRes</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">updateStream</code><code class="p">.</code><code class="nx">CloseAndRecv</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO6-5" id="co_grpc_communication_patterns_CO6-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.CloseAndRecv() got error %v, want %v"</code><code class="p">,</code><code>&#13;
</code><code>			</code><code class="nx">updateStream</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">,</code><code> </code><code class="kc">nil</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>	</code><code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Update Orders Res : %s"</code><code class="p">,</code><code> </code><code class="nx">updateRes</code><code class="p">)</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO6-1" id="callout_grpc_communication_patterns_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Invoking <code>UpdateOrders</code> remote method.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO6-2" id="callout_grpc_communication_patterns_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Handling errors related to <code>UpdateOrders</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO6-3" id="callout_grpc_communication_patterns_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Sending order update via client stream.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO6-4" id="callout_grpc_communication_patterns_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Handling errors when sending messages to stream.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO6-5" id="callout_grpc_communication_patterns_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Closing the stream and receiving the response.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As a result of this function invocation, you get the response message of the service.&#13;
Since now you have a good understanding of both server-streaming and client-streaming RPC, let’s move on to bidirectional-streaming RPC, which is sort of a combination of the RPC styles that we discussed.<a data-startref="ix_ch03-asciidoc12" data-type="indexterm" id="idm46536642662200"/><a data-startref="ix_ch03-asciidoc11" data-type="indexterm" id="idm46536642661496"/><a data-startref="ix_ch03-asciidoc10" data-type="indexterm" id="idm46536642660824"/><a data-startref="ix_ch03-asciidoc9" data-type="indexterm" id="idm46536642660152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bidirectional-Streaming RPC" data-type="sect1"><div class="sect1" id="idm46536643131752">&#13;
<h1>Bidirectional-Streaming RPC</h1>&#13;
&#13;
<p><a data-primary="bidirectional-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc13"/><a data-primary="communication patterns" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc14"/><a data-primary="RPC (remote procedure call)" data-secondary="bidirectional-streaming" data-type="indexterm" id="ix_ch03-asciidoc15"/><a data-primary="streaming" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc16"/>In bidirectional-streaming RPC, the client is sending a request to the server as a stream of messages. The server also responds with a stream of messages. The call has to be initiated from the client side, but after that, the communication is completely based on the application logic of the gRPC client and the server.&#13;
Let’s look at an example to understand bidirectional-streaming RPC in detail. As illustrated in <a data-type="xref" href="#bidirectional_streaming_rpc">Figure 3-4</a>, in our <code>OrderManagement</code> service use case, suppose we need order processing functionality where you can send a continuous set of orders (the stream of orders) and process them into combined shipments based on the delivery location (i.e., orders are organized into shipments based on the delivery destination).</p>&#13;
&#13;
<figure><div class="figure" id="bidirectional_streaming_rpc">&#13;
<img alt="Bidirectional-streaming RPC" src="assets/grpc_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Bidirectional-streaming RPC</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can identify the following key steps of this business use case:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The client application initiates the business use case by setting up the connection with the server and sending call metadata (headers).</p>&#13;
</li>&#13;
<li>&#13;
<p>Once the connection setup is completed, the client application sends a continuous set of order IDs that need to be processed by the <code>OrderManagement</code> service.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each order ID is sent to the server as a separate gRPC message.</p>&#13;
</li>&#13;
<li>&#13;
<p>The service processes each order for the specified order ID and organizes them into combined shipments based on the delivery location of the order.</p>&#13;
</li>&#13;
<li>&#13;
<p>A combined shipment may contain multiple orders that should be delivered to the same destination.</p>&#13;
</li>&#13;
<li>&#13;
<p>Orders are processed in batches. When the batch size is reached, all the currently created combined shipments will be sent back to the client.</p>&#13;
</li>&#13;
<li>&#13;
<p>For example, an ordered stream of four where two orders addressed to location X and two to location Y can be denoted as X, Y, X, Y. And if the batch size is three, then the created combined orders should be shipment [X, X], shipment [Y], shipment [Y]. These combined shipments are also sent as a stream back to the client.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The key idea behind this business use case is that once the RPC method is invoked either the client or service can send messages at any arbitrary time. (This also includes the end of stream markings from either of the parties.)</p>&#13;
&#13;
<p><a data-primary="bidirectional-streaming RPC" data-secondary="service definition for" data-type="indexterm" id="ix_ch03-asciidoc17"/><a data-primary="service definition" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc18"/>Now, let’s move on to the service definition for the preceding use case. As shown in <a data-type="xref" href="#EX3-10">Example 3-10</a>, we can define a <code>processOrders</code> method so that it takes a stream of strings as the method parameter to represent the order ID stream and a stream of <code>CombinedShipments</code> as the return parameter of the method. So, by declaring both the method parameter and return parameters as a <code>stream</code>, you can define a bidirectional-streaming RPC method. The combined shipment message is also declared in the service definition and it contains a list of order elements.</p>&#13;
<div data-type="example" id="EX3-10">&#13;
<h5><span class="label">Example 3-10. </span>Service definition for bidirectional-streaming RPC</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">syntax</code><code> </code><code class="p">=</code><code> </code><code class="s">"proto3"</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="kn">import</code><code> </code><code class="s">"google/protobuf/wrappers.proto"</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="kn">package</code><code> </code><code class="nx">ecommerce</code><code class="p">;</code><code>&#13;
</code><code>&#13;
</code><code class="nx">service</code><code> </code><code class="nx">OrderManagement</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="o">...</code><code>&#13;
</code><code>    </code><code class="nx">rpc</code><code> </code><code class="nx">processOrders</code><code class="p">(</code><code class="nx">stream</code><code> </code><code class="nx">google</code><code class="p">.</code><code class="nx">protobuf</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="nx">returns</code><code> </code><code class="p">(</code><code class="nx">stream</code><code> </code><code class="nx">CombinedShipment</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO7-1" id="co_grpc_communication_patterns_CO7-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">message</code><code> </code><code class="nx">Order</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO7-2" id="co_grpc_communication_patterns_CO7-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code class="kt">string</code><code> </code><code class="nx">id</code><code> </code><code class="p">=</code><code> </code><code class="mi">1</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="nx">repeated</code><code> </code><code class="kt">string</code><code> </code><code class="nx">items</code><code> </code><code class="p">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">description</code><code> </code><code class="p">=</code><code> </code><code class="mi">3</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">float</code><code> </code><code class="nx">price</code><code> </code><code class="p">=</code><code> </code><code class="mi">4</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">destination</code><code> </code><code class="p">=</code><code> </code><code class="mi">5</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">message</code><code> </code><code class="nx">CombinedShipment</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO7-3" id="co_grpc_communication_patterns_CO7-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="kt">string</code><code> </code><code class="nx">id</code><code> </code><code class="p">=</code><code> </code><code class="mi">1</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="kt">string</code><code> </code><code class="nx">status</code><code> </code><code class="p">=</code><code> </code><code class="mi">2</code><code class="p">;</code><code>&#13;
</code><code>    </code><code class="nx">repeated</code><code> </code><code class="nx">Order</code><code> </code><code class="nx">ordersList</code><code> </code><code class="p">=</code><code> </code><code class="mi">3</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO7-1" id="callout_grpc_communication_patterns_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Both method parameters and return parameters are declared as streams in bidirectional RPC.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO7-2" id="callout_grpc_communication_patterns_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Structure of the <code>Order</code> message.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO7-3" id="callout_grpc_communication_patterns_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Structure of the <code>CombinedShipment</code> message.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Then we can generate the server-side code from the updated service definition. The service should implement the <code>processOrders</code> method of the <code>OrderManagement</code> service. In the Go implementation shown in <a data-type="xref" href="#EX3-11">Example 3-11</a>, <code>processOrders</code> has an <code>OrderManagement_ProcessOrdersServer</code> parameter, which is the reference object to the message stream between the client and the service. Using this stream object, the service can read the client’s messages that are streamed to the server as well as write the stream server’s messages back to the client. Using that stream reference object, the incoming message stream can be read using the <code>Recv()</code> method. In the <code>processOrders</code> method, the service can keep on reading the incoming message stream while writing to the same stream using <code>Send</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To simplify the demonstration, some of the logic of <a data-type="xref" href="#EX3-10">Example 3-10</a> is not shown. You can find the full code example in this book’s source code repository.</p>&#13;
</div>&#13;
<div data-type="example" id="EX3-11">&#13;
<h5><span class="label">Example 3-11. </span>Service implementation of OrderManagement with processOrders method in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code> </code><code class="p">(</code><code class="nx">s</code><code> </code><code class="o">*</code><code class="nx">server</code><code class="p">)</code><code> </code><code class="nx">ProcessOrders</code><code class="p">(</code><code>&#13;
</code><code>	</code><code class="nx">stream</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">OrderManagement_ProcessOrdersServer</code><code class="p">)</code><code> </code><code class="kt">error</code><code> </code><code class="p">{</code><code>&#13;
</code><code>	</code><code class="o">...</code><code>&#13;
</code><code>	</code><code class="k">for</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">orderId</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">stream</code><code class="p">.</code><code class="nx">Recv</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO8-1" id="co_grpc_communication_patterns_CO8-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
		</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">==</code><code> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code> </code><code class="p">{</code><code>            </code><a class="co" href="#callout_grpc_communication_patterns_CO8-2" id="co_grpc_communication_patterns_CO8-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
			</code><code class="o">...</code><code>&#13;
</code><code>			</code><code class="k">for</code><code> </code><code class="nx">_</code><code class="p">,</code><code> </code><code class="nx">comb</code><code> </code><code class="o">:=</code><code> </code><code class="k">range</code><code> </code><code class="nx">combinedShipmentMap</code><code> </code><code class="p">{</code><code>&#13;
</code><code>				</code><code class="nx">stream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">comb</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO8-3" id="co_grpc_communication_patterns_CO8-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
			</code><code class="p">}</code><code>&#13;
</code><code>			</code><code class="k">return</code><code> </code><code class="kc">nil</code><code>               </code><a class="co" href="#callout_grpc_communication_patterns_CO8-4" id="co_grpc_communication_patterns_CO8-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
		</code><code class="p">}</code><code>&#13;
</code><code>		</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>			</code><code class="k">return</code><code> </code><code class="nx">err</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>		</code><code class="c1">// Logic to organize orders into shipments,&#13;
</code><code>		</code><code class="c1">// based on the destination.&#13;
</code><code>		</code><code class="o">...</code><code>&#13;
</code><code>		</code><code class="c1">//&#13;
</code><code>&#13;
</code><code>		</code><code class="k">if</code><code> </code><code class="nx">batchMarker</code><code> </code><code class="o">==</code><code> </code><code class="nx">orderBatchSize</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO8-5" id="co_grpc_communication_patterns_CO8-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
			</code><code class="c1">// Stream combined orders to the client in batches&#13;
</code><code>			</code><code class="k">for</code><code> </code><code class="nx">_</code><code class="p">,</code><code> </code><code class="nx">comb</code><code> </code><code class="o">:=</code><code> </code><code class="k">range</code><code> </code><code class="nx">combinedShipmentMap</code><code> </code><code class="p">{</code><code>&#13;
</code><code>				</code><code class="c1">// Send combined shipment to the client&#13;
</code><code>				</code><code class="nx">stream</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">comb</code><code class="p">)</code><code>      </code><a class="co" href="#callout_grpc_communication_patterns_CO8-6" id="co_grpc_communication_patterns_CO8-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
			</code><code class="p">}</code><code>&#13;
</code><code>			</code><code class="nx">batchMarker</code><code> </code><code class="p">=</code><code> </code><code class="mi">0</code><code>&#13;
</code><code>			</code><code class="nx">combinedShipmentMap</code><code> </code><code class="p">=</code><code> </code><code class="nb">make</code><code class="p">(</code><code>&#13;
</code><code>				</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">pb</code><code class="p">.</code><code class="nx">CombinedShipment</code><code class="p">)</code><code>&#13;
</code><code>		</code><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
</code><code>			</code><code class="nx">batchMarker</code><code class="o">++</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-1" id="callout_grpc_communication_patterns_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read order IDs from the incoming stream.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-2" id="callout_grpc_communication_patterns_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Keep reading until the end of the stream is found.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-3" id="callout_grpc_communication_patterns_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>When the end of the stream is found send all the remaining combined shipments to the client.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-4" id="callout_grpc_communication_patterns_CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Server-side end of the stream is marked by returning <code>nil</code>.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-5" id="callout_grpc_communication_patterns_CO8-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Orders are processed in batches. When the batch size is met, all the created combined shipments are streamed to the client.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO8-6" id="callout_grpc_communication_patterns_CO8-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Writing the combined shipment to the stream.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Here we process incoming orders based on the ID, and when a new combined shipment is created the service writes it to the same stream (unlike client-streaming RPC where we write and close the stream with <code>SendAndClose</code>.). The end of the stream at the server side is marked when we return <code>nil</code> when the client’s end of the stream is found.<a data-startref="ix_ch03-asciidoc18" data-type="indexterm" id="idm46536642145848"/><a data-startref="ix_ch03-asciidoc17" data-type="indexterm" id="idm46536642145240"/></p>&#13;
&#13;
<p><a data-primary="bidirectional-streaming RPC" data-secondary="client-side implementation" data-type="indexterm" id="ix_ch03-asciidoc19"/><a data-primary="client" data-secondary="bidirectional-streaming RPC" data-type="indexterm" id="ix_ch03-asciidoc20"/>The client-side implementation (<a data-type="xref" href="#EX3-12">Example 3-12</a>) is also quite similar to the previous examples. When the client invokes the method <code>processOrders</code> via the <code>OrderManagement</code> client object, it gets a reference to the stream (<code>streamProcOrder</code>) that is used in sending messages to the server as well as reading messages from the server.</p>&#13;
<div data-type="example" id="EX3-12">&#13;
<h5><span class="label">Example 3-12. </span>Client implementation of OrderManagement with processOrders method in Go</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Process Order&#13;
</code><code class="nx">streamProcOrder</code><code class="p">,</code><code> </code><code class="nx">_</code><code> </code><code class="o">:=</code><code> </code><code class="nx">c</code><code class="p">.</code><code class="nx">ProcessOrders</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-1" id="co_grpc_communication_patterns_CO9-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code>&#13;
</code><code>		</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code class="s">"102"</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-2" id="co_grpc_communication_patterns_CO9-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code> </code><code class="nx">client</code><code class="p">,</code><code> </code><code class="s">"102"</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code>&#13;
</code><code>		</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code class="s">"103"</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code> </code><code class="nx">client</code><code class="p">,</code><code> </code><code class="s">"103"</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code>&#13;
</code><code>		</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code class="s">"104"</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code> </code><code class="nx">client</code><code class="p">,</code><code> </code><code class="s">"104"</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="nx">channel</code><code> </code><code class="o">:=</code><code> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code> </code><code class="kd">struct</code><code class="p">{</code><code class="p">}</code><code class="p">)</code><code>  </code><a class="co" href="#callout_grpc_communication_patterns_CO9-3" id="co_grpc_communication_patterns_CO9-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="k">go</code><code> </code><code class="nx">asncClientBidirectionalRPC</code><code class="p">(</code><code class="nx">streamProcOrder</code><code class="p">,</code><code> </code><code class="nx">channel</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-4" id="co_grpc_communication_patterns_CO9-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Millisecond</code><code> </code><code class="o">*</code><code> </code><code class="mi">1000</code><code class="p">)</code><code>     </code><a class="co" href="#callout_grpc_communication_patterns_CO9-5" id="co_grpc_communication_patterns_CO9-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
&#13;
	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">Send</code><code class="p">(</code><code>&#13;
</code><code>		</code><code class="o">&amp;</code><code class="nx">wrapper</code><code class="p">.</code><code class="nx">StringValue</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code><code class="s">"101"</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"%v.Send(%v) = %v"</code><code class="p">,</code><code> </code><code class="nx">client</code><code class="p">,</code><code> </code><code class="s">"101"</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>	</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">CloseSend</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-6" id="co_grpc_communication_patterns_CO9-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="o">&lt;-</code><code> </code><code class="nx">channel</code><code>&#13;
</code><code>&#13;
</code><code class="kd">func</code><code> </code><code class="nx">asncClientBidirectionalRPC</code><code> </code><code class="p">(</code><code>&#13;
</code><code>	    </code><code class="nx">streamProcOrder</code><code> </code><code class="nx">pb</code><code class="p">.</code><code class="nx">OrderManagement_ProcessOrdersClient</code><code class="p">,</code><code>&#13;
</code><code>	    </code><code class="nx">c</code><code> </code><code class="kd">chan</code><code> </code><code class="kd">struct</code><code class="p">{</code><code class="p">}</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>	</code><code class="k">for</code><code> </code><code class="p">{</code><code>&#13;
</code><code>		</code><code class="nx">combinedShipment</code><code class="p">,</code><code> </code><code class="nx">errProcOrder</code><code> </code><code class="o">:=</code><code> </code><code class="nx">streamProcOrder</code><code class="p">.</code><code class="nx">Recv</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-7" id="co_grpc_communication_patterns_CO9-7"><img alt="7" src="assets/7.png"/></a><code>&#13;
		</code><code class="k">if</code><code> </code><code class="nx">errProcOrder</code><code> </code><code class="o">==</code><code> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_grpc_communication_patterns_CO9-8" id="co_grpc_communication_patterns_CO9-8"><img alt="8" src="assets/8.png"/></a><code>&#13;
			</code><code class="k">break</code><code>&#13;
</code><code>		</code><code class="p">}</code><code>&#13;
</code><code>		</code><code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Combined shipment : "</code><code class="p">,</code><code> </code><code class="nx">combinedShipment</code><code class="p">.</code><code class="nx">OrdersList</code><code class="p">)</code><code>&#13;
</code><code>	</code><code class="p">}</code><code>&#13;
</code><code>	</code><code class="o">&lt;-</code><code class="nx">c</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-1" id="callout_grpc_communication_patterns_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Invoke the remote method and obtain the stream reference for writing and reading from the client side.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-2" id="callout_grpc_communication_patterns_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Send a message to the service.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-3" id="callout_grpc_communication_patterns_CO9-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create a channel to use for Goroutines.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-4" id="callout_grpc_communication_patterns_CO9-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Invoke the function using Goroutines to read the messages in parallel from the service.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-5" id="callout_grpc_communication_patterns_CO9-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Mimic a delay when sending some messages to the service.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-6" id="callout_grpc_communication_patterns_CO9-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Mark the end of stream for the client stream (order IDs).</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-7" id="callout_grpc_communication_patterns_CO9-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Read service’s messages on the client side.</p></dd>&#13;
<dt><a class="co" href="#co_grpc_communication_patterns_CO9-8" id="callout_grpc_communication_patterns_CO9-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Condition to detect the end of the stream.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The client can send messages to the service and close the stream at any arbitrary time.&#13;
The same applies for reading as well. <a data-primary="Goroutines" data-type="indexterm" id="idm46536641978312"/>In the prior example, we execute the client message writing and message reading logic in two concurrent threads using the Go language’s&#13;
<em>Goroutines</em> terminology.</p>&#13;
<div data-type="tip"><h1>Goroutines</h1>&#13;
<p>In Go, Goroutines are functions or methods that run concurrently with other functions or methods. They can be thought of as lightweight threads.</p>&#13;
</div>&#13;
&#13;
<p>So, the client can read and write to the same stream concurrently and both incoming and outgoing streams operate independently. What we have shown is a somewhat complex use case to showcase the power of bidirectional  RPC. It’s important to understand that the client and server can read and write in any order—the streams operate completely independently. Therefore, it is completely up to the client and service to decide the communication pattern between the client and service once the initial connection is established.<a data-startref="ix_ch03-asciidoc20" data-type="indexterm" id="idm46536641974360"/><a data-startref="ix_ch03-asciidoc19" data-type="indexterm" id="idm46536641973656"/></p>&#13;
&#13;
<p>With that, we have covered all the possible communication patterns that we can use to build interactions with gRPC-based applications. There is no hard-and-fast rule when it comes to selecting a communication pattern, but it’s always good to analyze the business use case and then select the most appropriate pattern.</p>&#13;
&#13;
<p>Before we conclude this discussion on gRPC communication patterns, it’s important to take a look at how gRPC is used for microservices communication.<a data-startref="ix_ch03-asciidoc16" data-type="indexterm" id="idm46536641971688"/><a data-startref="ix_ch03-asciidoc15" data-type="indexterm" id="idm46536641970984"/><a data-startref="ix_ch03-asciidoc14" data-type="indexterm" id="idm46536641970312"/><a data-startref="ix_ch03-asciidoc13" data-type="indexterm" id="idm46536641969640"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using gRPC for Microservices Communication" data-type="sect1"><div class="sect1" id="using_grpc_for_microservices_communication">&#13;
<h1>Using gRPC for Microservices Communication</h1>&#13;
&#13;
<p><a data-primary="communication patterns" data-secondary="using gRPC for microservices communication" data-type="indexterm" id="ix_ch03-asciidoc21"/><a data-primary="microservices architecture" data-secondary="using gRPC for communication" data-type="indexterm" id="ix_ch03-asciidoc22"/>One of the main usages of gRPC is to implement microservices and their inter-service communication. In microservices inter-service communication, gRPC is used along with other communication protocols and usually gRPC services are implemented as polyglot services (implemented with different programming languages).&#13;
To understand this further, let’s take a real-world scenario (<a data-type="xref" href="#a_common_microservices_deployment_pattern_with_grpc_and_other_protocols">Figure 3-5</a>) of an online retail system, which is an extended version of what we have discussed so far.</p>&#13;
&#13;
<p>In this scenario, we have a number of microservices serving specific business capabilities of the online relation system. There are services such as the <code>Product</code> service, which is implemented as a gRPC service, and there are composite services such as the <code>Catalog</code> service, which calls multiple downstream services to build its business <span class="keep-together">capability.</span> As we discussed in <a data-type="xref" href="ch01.html#grpc_ch_01">Chapter 1</a>, for most of the synchronous message passing scenarios, we can use gRPC. When you have certain asynchronous messaging scenarios that may require persistent messaging, then you can use event brokers or message brokers, such as <a href="https://kafka.apache.org">Kafka</a>, <a href="https://activemq.apache.org">Active MQ</a>, <a href="https://www.rabbitmq.com">RabbitMQ</a>, and <a href="http://nats.io">NATS</a>. When you have to expose certain business functionalities to the external world, then you can use the conventional REST/OpenAPI-based services or the GraphQL service. Thus services such as <code>Catalog</code> and <code>Checkout</code> are consuming gRPC-based backend services, and also exposing RESTful or GraphQL-based external-facing interfaces.</p>&#13;
&#13;
<figure><div class="figure" id="a_common_microservices_deployment_pattern_with_grpc_and_other_protocols">&#13;
<img alt="A common microservice deployment pattern with gRPC and other protocols" src="assets/grpc_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>A common microservices deployment pattern with gRPC and other protocols</h6>&#13;
</div></figure>&#13;
&#13;
<p>In most of the real-world use cases, these external-facing services are exposed through an API gateway. That is the place where you apply various nonfunctional capabilities such as security, throttling, versioning, and so on. Most such APIs leverage protocols such as REST or GraphQL. Although it’s not very common, you may also expose gRPC as an external-facing service, as long as the API gateway supports exposing gRPC interfaces. The API gateway implements cross-cutting functionality such as authentication, logging, versioning, throttling, and load balancing. By using an API gateway with your gRPC APIs, you are able to deploy this functionality outside of your core gRPC services.&#13;
One of the other important aspects of this architecture is that we can leverage multiple programming languages but share the same service contract between then (i.e., code generation from the same gRPC service <span class="keep-together">definition).</span> This allows us to pick the appropriate implementation technology based on the business capability of the service.<a data-startref="ix_ch03-asciidoc22" data-type="indexterm" id="idm46536641577608"/><a data-startref="ix_ch03-asciidoc21" data-type="indexterm" id="idm46536641576904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46536642658200">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>gRPC offers a diverse set of RPC communication styles for building inter-process communication between gRPC-based applications. In this chapter, we explored four main communication patterns. Simple RPC is the most basic one; it is pretty much a simple request–response style remote procedure invocation. Server-streaming RPC allows you to send multiple messages from the service to the consumer after the first invocation of the remote method, while client streaming allows you to send multiple messages from the client to the service. We delve into the details of how we can implement each of these patterns using some real-world use cases.</p>&#13;
&#13;
<p>The knowledge you gained in this chapter is quite useful for implementing any gRPC use case so that you can select the most appropriate communication pattern for your business. While this chapter gave you a solid understanding of gRPC communication patterns, the low-level communication details that are transparent to the user were not covered in this chapter. In the next chapter, we will dive deep into how low-level communication takes place when we have gRPC-based inter-process communication.<a data-startref="ix_ch03-asciidoc0" data-type="indexterm" id="idm46536641573384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>