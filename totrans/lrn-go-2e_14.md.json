["```go\nfunc logic(ctx context.Context, info string) (string, error) {\n    // do some interesting stuff here\n    return \"\", nil\n}\n```", "```go\nfunc Middleware(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n        ctx := req.Context()\n        // wrap the context with stuff -- you'll see how soon!\n        req = req.WithContext(ctx)\n        handler.ServeHTTP(rw, req)\n    })\n}\n```", "```go\nfunc handler(rw http.ResponseWriter, req *http.Request) {\n    ctx := req.Context()\n    err := req.ParseForm()\n    if err != nil {\n        rw.WriteHeader(http.StatusInternalServerError)\n        rw.Write([]byte(err.Error()))\n        return\n    }\n    data := req.FormValue(\"data\")\n    result, err := logic(ctx, data)\n    if err != nil {\n        rw.WriteHeader(http.StatusInternalServerError)\n        rw.Write([]byte(err.Error()))\n        return\n    }\n    rw.Write([]byte(result))\n}\n```", "```go\ntype ServiceCaller struct {\n    client *http.Client\n}\n\nfunc (sc ServiceCaller) callAnotherService(ctx context.Context, data string)\n                                          (string, error) {\n    req, err := http.NewRequestWithContext(ctx, http.MethodGet,\n                \"http://example.com?data=\"+data, nil)\n    if err != nil {\n        return \"\", err\n    }\n    resp, err := sc.client.Do(req)\n    if err != nil {\n        return \"\", err\n    }\n    defer resp.Body.Close()\n    if resp.StatusCode != http.StatusOK {\n        return \"\", fmt.Errorf(\"Unexpected status code %d\",\n                              resp.StatusCode)\n    }\n    // do the rest of the stuff to process the response\n    id, err := processResponse(resp.Body)\n    return id, err\n}\n```", "```go\nctx := context.Background()\nif myVal, ok := ctx.Value(myKey).(int); !ok {\n    fmt.Println(\"no value\")\n} else {\n    fmt.Println(\"value:\", myVal)\n}\n```", "```go\ntype userKey int\n```", "```go\nconst (\n    _ userKey = iota\n    key\n)\n```", "```go\nfunc ContextWithUser(ctx context.Context, user string) context.Context {\n    return context.WithValue(ctx, key, user)\n}\n\nfunc UserFromContext(ctx context.Context) (string, bool) {\n    user, ok := ctx.Value(key).(string)\n    return user, ok\n}\n```", "```go\ntype userKey struct{}\n```", "```go\nfunc ContextWithUser(ctx context.Context, user string) context.Context {\n    return context.WithValue(ctx, userKey{}, user)\n}\n\nfunc UserFromContext(ctx context.Context) (string, bool) {\n    user, ok := ctx.Value(userKey{}).(string)\n    return user, ok\n}\n```", "```go\n// a real implementation would be signed to make sure\n// the user didn't spoof their identity\nfunc extractUser(req *http.Request) (string, error) {\n    userCookie, err := req.Cookie(\"identity\")\n    if err != nil {\n        return \"\", err\n    }\n    return userCookie.Value, nil\n}\n\nfunc Middleware(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n        user, err := extractUser(req)\n        if err != nil {\n            rw.WriteHeader(http.StatusUnauthorized)\n            rw.Write([]byte(\"unauthorized\"))\n            return\n        }\n        ctx := req.Context()\n        ctx = ContextWithUser(ctx, user)\n        req = req.WithContext(ctx)\n        h.ServeHTTP(rw, req)\n    })\n}\n```", "```go\nfunc (c Controller) DoLogic(rw http.ResponseWriter, req *http.Request) {\n    ctx := req.Context()\n    user, ok := identity.UserFromContext(ctx)\n    if !ok {\n        rw.WriteHeader(http.StatusInternalServerError)\n        return\n    }\n    data := req.URL.Query().Get(\"data\")\n    result, err := c.Logic.BusinessLogic(ctx, user, data)\n    if err != nil {\n        rw.WriteHeader(http.StatusInternalServerError)\n        rw.Write([]byte(err.Error()))\n        return\n    }\n    rw.Write([]byte(result))\n}\n```", "```go\npackage tracker\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/google/uuid\"\n)\n\ntype guidKey int\n\nconst key guidKey = 1\n\nfunc contextWithGUID(ctx context.Context, guid string) context.Context {\n    return context.WithValue(ctx, key, guid)\n}\n\nfunc guidFromContext(ctx context.Context) (string, bool) {\n    g, ok := ctx.Value(key).(string)\n    return g, ok\n}\n\nfunc Middleware(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n        ctx := req.Context()\n        if guid := req.Header.Get(\"X-GUID\"); guid != \"\" {\n            ctx = contextWithGUID(ctx, guid)\n        } else {\n            ctx = contextWithGUID(ctx, uuid.New().String())\n        }\n        req = req.WithContext(ctx)\n        h.ServeHTTP(rw, req)\n    })\n}\n\ntype Logger struct{}\n\nfunc (Logger) Log(ctx context.Context, message string) {\n    if guid, ok := guidFromContext(ctx); ok {\n        message = fmt.Sprintf(\"GUID: %s - %s\", guid, message)\n    }\n    // do logging\n    fmt.Println(message)\n}\n\nfunc Request(req *http.Request) *http.Request {\n    ctx := req.Context()\n    if guid, ok := guidFromContext(ctx); ok {\n        req.Header.Add(\"X-GUID\", guid)\n    }\n    return req\n}\n```", "```go\ntype Logger interface {\n    Log(context.Context, string)\n}\n\ntype RequestDecorator func(*http.Request) *http.Request\n\ntype LogicImpl struct {\n    RequestDecorator RequestDecorator\n    Logger           Logger\n    Remote           string\n}\n```", "```go\nfunc (l LogicImpl) Process(ctx context.Context, data string) (string, error) {\n    l.Logger.Log(ctx, \"starting Process with \"+data)\n    req, err := http.NewRequestWithContext(ctx,\n        http.MethodGet, l.Remote+\"/second?query=\"+data, nil)\n    if err != nil {\n        l.Logger.Log(ctx, \"error building remote request:\"+err.Error())\n        return \"\", err\n    }\n    req = l.RequestDecorator(req)\n    resp, err := http.DefaultClient.Do(req)\n    // process the response...\n}\n```", "```go\ncontroller := Controller{\n    Logic: LogicImpl{\n        RequestDecorator: tracker.Request,\n        Logger:           tracker.Logger{},\n        Remote:           \"http://localhost:4000\",\n    },\n}\n```", "```go\nctx, cancelFunc := context.WithCancel(context.Background())\ndefer cancelFunc()\n```", "```go\nctx, cancelFunc := context.WithCancel(context.Background())\ndefer cancelFunc()\nch := make(chan string)\nvar wg sync.WaitGroup\nwg.Add(2)\n```", "```go\n    go func() {\n        defer wg.Done()\n        for {\n            // return one of these status code at random\n            resp, err := makeRequest(ctx,\n                \"http://httpbin.org/status/200,200,200,500\")\n            if err != nil {\n                fmt.Println(\"error in status goroutine:\", err)\n                cancelFunc()\n                return\n            }\n            if resp.StatusCode == http.StatusInternalServerError {\n                fmt.Println(\"bad status, exiting\")\n                cancelFunc()\n                return\n            }\n            select {\n            case ch <- \"success from status\":\n            case <-ctx.Done():\n            }\n            time.Sleep(1 * time.Second)\n        }\n    }()\n```", "```go\n    go func() {\n        defer wg.Done()\n        for {\n            // return after a 1 second delay\n            resp, err := makeRequest(ctx, \"http://httpbin.org/delay/1\")\n            if err != nil {\n                fmt.Println(\"error in delay goroutine:\", err)\n                cancelFunc()\n                return\n            }\n            select {\n            case ch <- \"success from delay: \" + resp.Header.Get(\"date\"):\n            case <-ctx.Done():\n            }\n        }\n    }()\n```", "```go\nloop:\n    for {\n        select {\n        case s := <-ch:\n            fmt.Println(\"in main:\", s)\n        case <-ctx.Done():\n            fmt.Println(\"in main: cancelled!\")\n            break loop\n        }\n    }\n    wg.Wait()\n```", "```go\nin main: success from status\nin main: success from delay: Thu, 16 Feb 2023 03:53:57 GMT\nin main: success from status\nin main: success from delay: Thu, 16 Feb 2023 03:53:58 GMT\nbad status, exiting\nin main: cancelled!\nerror in delay goroutine: Get \"http://httpbin.org/delay/1\": context canceled\n```", "```go\nctx, cancelFunc := context.WithCancelCause(context.Background())\ndefer cancelFunc(nil)\n```", "```go\nresp, err := makeRequest(ctx, \"http://httpbin.org/status/200,200,200,500\")\nif err != nil {\n    cancelFunc(fmt.Errorf(\"in status goroutine: %w\", err))\n    return\n}\nif resp.StatusCode == http.StatusInternalServerError {\n    cancelFunc(errors.New(\"bad status\"))\n    return\n}\nch <- \"success from status\"\ntime.Sleep(1 * time.Second)\n```", "```go\nresp, err := makeRequest(ctx, \"http://httpbin.org/delay/1\")\nif err != nil {\n    fmt.Println(\"in delay goroutine:\", err)\n    cancelFunc(fmt.Errorf(\"in delay goroutine: %w\", err))\n    return\n}\nch <- \"success from delay: \" + resp.Header.Get(\"date\")\n```", "```go\nloop:\n    for {\n        select {\n        case s := <-ch:\n            fmt.Println(\"in main:\", s)\n        case <-ctx.Done():\n            fmt.Println(\"in main: cancelled with error\", context.Cause(ctx))\n            break loop\n        }\n    }\n    wg.Wait()\n    fmt.Println(\"context cause:\", context.Cause(ctx))\n```", "```go\nin main: success from status\nin main: success from delay: Thu, 16 Feb 2023 04:11:49 GMT\nin main: cancelled with error bad status\nin delay goroutine: Get \"http://httpbin.org/delay/1\": context canceled\ncontext cause: bad status\n```", "```go\nctx := context.Background()\nparent, cancel := context.WithTimeout(ctx, 2*time.Second)\ndefer cancel()\nchild, cancel2 := context.WithTimeout(parent, 3*time.Second)\ndefer cancel2()\nstart := time.Now()\n<-child.Done()\nend := time.Now()\nfmt.Println(end.Sub(start).Truncate(time.Second))\n```", "```go\n2s\n```", "```go\nctx, cancelFuncParent := context.WithTimeout(context.Background(), 3*time.Second)\ndefer cancelFuncParent()\nctx, cancelFunc := context.WithCancelCause(ctx)\ndefer cancelFunc(nil)\n```", "```go\nfmt.Println(\"in main: cancelled with cause:\", context.Cause(ctx),\n    \"err:\", ctx.Err())\n```", "```go\nin main: success from status\nin main: success from delay: Sun, 19 Feb 2023 04:36:44 GMT\nin main: success from status\nin main: success from status\nin main: success from delay: Sun, 19 Feb 2023 04:36:45 GMT\nin main: cancelled with cause: context deadline exceeded\n    err: context deadline exceeded\nin delay goroutine: Get \"http://httpbin.org/delay/1\":\n    context deadline exceeded\ncontext cause: context deadline exceeded\n```", "```go\nin main: success from status\nin main: success from status\nin main: success from delay: Sun, 19 Feb 2023 04:37:14 GMT\nin main: cancelled with cause: bad status err: context canceled\nin delay goroutine: Get \"http://httpbin.org/delay/1\": context canceled\ncontext cause: bad status\n```", "```go\nfunc longRunningComputation(ctx context.Context, data string) (string, error) {\n    for {\n        // do some processing\n        // insert this if statement periodically\n        // to check if the context has been cancelled\n        if err := context.Cause(ctx); err != nil {\n            // return a partial value if it makes sense,\n            // or a default one if it doesn't\n            return \"\", err\n        }\n        // do some more processing and loop again\n    }\n}\n```", "```go\ni := 0\nfor {\n    if err := context.Cause(ctx); err != nil {\n        fmt.Println(\"cancelled after\", i, \"iterations\")\n        return sum.Text('g', 100), err\n    }\n    var diff big.Float\n    diff.SetInt64(4)\n    diff.Quo(&diff, &d)\n    if i%2 == 0 {\n        sum.Add(&sum, &diff)\n    } else {\n        sum.Sub(&sum, &diff)\n    }\n    d.Add(&d, two)\n    i++\n}\n```", "```go\n    func Log(ctx context.Context, level Level, message string) {\n        var inLevel Level\n        // TODO get a logging level out of the context and assign it to inLevel\n        if level == Debug && inLevel == Debug {\n            fmt.Println(message)\n        }\n        if level == Info && (inLevel == Debug || inLevel == Info) {\n            fmt.Println(message)\n        }\n    }\n    ```"]