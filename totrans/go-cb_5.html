<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 6. Data Structure Recipes" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_data_structures">
<h1><span class="label">Chapter 6. </span>Data Structure Recipes</h1>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45195510197584">
<h5>A Note for Early Release Readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
<p>This will be the 13th chapter of the final book.</p>
<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:sevans@oreilly.com">sevans@oreilly.com</a>.</p>
</div></aside>
<section data-pdf-bookmark="6.0 Introduction" data-type="sect1"><div class="sect1" id="idm45195510194512">
<h1>6.0 Introduction</h1>
<p>Go has 4 basic types of data structures — arrays, slices, maps and structs. We have a separate chapter on structs altogether so we’ll discuss that separately. In this chapter we’ll be discussing arrays, slices and maps only. We’ll start off with some background information on them before getting into specific recipes on using them.</p>
<section data-pdf-bookmark="Array" data-type="sect2"><div class="sect2" id="idm45195510192784">
<h2>Array</h2>
<p>Arrays are data structures that represent an ordered sequence of elements of the same type. Array sizes are static, they are set when the array is defined and cannot be changed subsequently. Arrays are  values. This is an important difference because in some languages an array is like a pointer to the first item in the array. This means if we pass an array to a function we will be passing a copy of the array and this could be expensive.</p>
</div></section>
<section data-pdf-bookmark="Slice" data-type="sect2"><div class="sect2" id="idm45195510191200">
<h2>Slice</h2>
<p>Slices are data structures that also represent an ordered sequence of elements. In fact slices are built on top of arrays and are used much more often than arrays because of its flexibility. Slices have no fixed length. Internally, a slice is a struct that consists of a pointer to an array, the length of the segment of the array, and the capacity of the underlying array.</p>
</div></section>
<section data-pdf-bookmark="Map" data-type="sect2"><div class="sect2" id="idm45195510189616">
<h2>Map</h2>
<p>Maps are data structures that associate the values of one type (called the <em>key</em>) with values of another type (called the <em>value</em>). Such data structures are very common in many other programming languages, called in different names like hash table, hash map and dictionary. Internally, a map is a pointer to <code>runtime.hmap</code> structure.</p>
<p>It’s important to understand that these 3 data structures are the basic building blocks of all other data structures, but they are also fundamentally very different from each other. In short, arrays are fixed length order lists that are values. Slices are structs that has the first element that is a pointer to an array. Maps are pointers to an internal hashmap struct.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="6.1 Creating arrays or slices" data-type="sect1"><div class="sect1" id="idm45195510186336">
<h1>6.1 Creating arrays or slices</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195510185440">
<h2>Problem</h2>
<p>You want to create arrays or slices.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195510183856">
<h2>Solution</h2>
<p>There are many ways of creating arrays or slices including directly from literals, or from another array, or using <code>make</code>.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195510181728">
<h2>Discussion</h2>
<p>Arrays and slices are very different constructs but conceptually they are very similar. As a result, creating arrays and slices are also very similar.</p>
<section data-pdf-bookmark="Defining arrays" data-type="sect3"><div class="sect3" id="idm45195510180240">
<h3>Defining arrays</h3>
<p>You can define an array by declaring the size of the array in square brackets, followed by the data type of the elements. Arrays and slices can only have elements of the same type. You can also initialize the array during the declaration by putting the elements in curly brackets.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">numbers</code><code class="w"> </code><code class="p">[</code><code class="mi">10</code><code class="p">]</code><code class="kt">int</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/>
<code class="nx">rhyme</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code><code class="s">"twinkle"</code><code class="p">,</code><code class="w"> </code><code class="s">"twinkle"</code><code class="p">,</code><code class="w"> </code><code class="s">"little"</code><code class="p">,</code><code class="w"> </code><code class="s">"star"</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">rhyme</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code snippet above, this is what you will see.</p>
<pre data-type="programlisting">[0 0 0 0 0 0 0 0 0 0]
[twinkle twinkle little star]</pre>
<p>The default values for an int or float array is 0. Note that the size of the array cannot be changed once it’s created, but the elements can be changed.</p>
</div></section>
<section data-pdf-bookmark="Defining slices" data-type="sect3"><div class="sect3" id="idm45195510116112">
<h3>Defining slices</h3>
<p>Slices are constructs that are built on top of arrays. Most of the time when you need to deal with ordered lists, you would normally use slices because they are more flexible and also much cheaper to use, especially if the underlying array is large.</p>
<p>Slices are defined exactly the same way, except you don’t provide the size of the slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">integers</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">sheep</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"baa"</code><code class="p">,</code><code class="w"> </code><code class="s">"baa"</code><code class="p">,</code><code class="w"> </code><code class="s">"black"</code><code class="p">,</code><code class="w"> </code><code class="s">"sheep"</code><code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sheep</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code snippet above, this is what you will see.</p>
<pre data-type="programlisting">[]
[baa baa black sheep]</pre>
<p>We can also create slices through the <code>make</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">integers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/></pre>
<p>If you use <code>make</code>, you need to provide the type, the length and an optional capacity. If you don’t provide the capacity, it will default to the given length. This is what you will see if you run the snippet above.</p>
<pre data-type="programlisting">[0 0 0 0 0 0 0 0 0 0]</pre>
<p>As you can see, <code>make</code> initializes the slice as well.</p>
<p>To find out the length of an array or a slice, you can use the <code>len</code> function. To find out the capacity of an array or a slice, you can use the <code>cap</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">integers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">([]</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">15</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"length:"</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">integers</code><code class="p">))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"capacity:"</code><code class="p">,</code><code class="w"> </code><code class="nb">cap</code><code class="p">(</code><code class="nx">integers</code><code class="p">))</code><code class="w"/></pre>
<p>The <code>make</code> function above allocates an array of 15 integers, then creates a slice with length of 10 and capacity of 15 that points at the first 10 elements of the array.</p>
<p>If you run the code above, this is what you get.</p>
<pre data-type="programlisting">[0 0 0 0 0 0 0 0 0 0]
length: 10
capacity: 15</pre>
<p>We can also create new slices with the <code>new</code> method.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">ints</code><code class="w"> </code><code class="o">*</code><code class="p">[]</code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">new</code><code class="p">([]</code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ints</code><code class="p">)</code><code class="w"/></pre>
<p>The <code>new</code> method doesn’t return the slice directly, it only returns a pointer to the slice. It also doesn’t initialize the slice, instead it just zeros it. You can see what you get when you run the code above.</p>
<pre data-type="programlisting">&amp;[]</pre>
<p>We can’t create new arrays using the <code>make</code> function, but we can create new arrays using the <code>new</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">ints</code><code class="w"> </code><code class="o">*</code><code class="p">[</code><code class="mi">10</code><code class="p">]</code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">new</code><code class="p">([</code><code class="mi">10</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ints</code><code class="p">)</code><code class="w"/></pre>
<p>What we get is a pointer to an array as below.</p>
<pre data-type="programlisting">&amp;[0 0 0 0 0 0 0 0 0 0]</pre>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="6.2 Accessing arrays or slices" data-type="sect1"><div class="sect1" id="idm45195510114944">
<h1>6.2 Accessing arrays or slices</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195509816624">
<h2>Problem</h2>
<p>You want to access elements in an array of a slice.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195509813472">
<h2>Solution</h2>
<p>There are a few ways to access elements in an array or a slice. Arrays and slices are ordered lists so elements in them can be accessed by their index. The elements can be access through a single index or through a range of indices. You can also access them by iterating through the elements.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195509811888">
<h2>Discussion</h2>
<p>Accessing arrays and slices are almost the same. As they are ordered lists, we can access an element of an array or a slice through its index.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">59</code><code class="p">}</code><code class="w"/></pre>
<p>Given the slice above, the 4th element in the slice, given the index 3 (we start with 0) is 25 and can be accessed using the name of variable, followed by square brackets, and indicating the index within the square brackets.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="w"> </code><code class="c1">// 26</code><code class="w"/></pre>
<p>We can also access a range of number by using the starting index, followed by a colon <code>:</code> and the ending index. The ending index is not included and this results in a slice (of course).</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">:</code><code class="mi">4</code><code class="p">]</code><code class="w"> </code><code class="c1">// [159, 26]</code><code class="w"/></pre>
<p>If we don’t have a starting index, the slice will start at 0.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="p">[:</code><code class="mi">4</code><code class="p">]</code><code class="w"> </code><code class="c1">// [3 14 159 26]</code><code class="w"/></pre>
<p>If we don’t have an ending index, the slice will end with the last element of the original slice (or array).</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="w"> </code><code class="c1">// [159 265 53 59]</code><code class="w"/></pre>
<p>Needless to say if you don’t have either a starting or ending index, the whole original slice is returned. While this sounds silly, there is a valid use for this — it simply converts an array into a slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[</code><code class="mi">6</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">59</code><code class="p">}</code><code class="w"> </code><code class="c1">// an array</code><code class="w"/>
<code class="nx">numbers</code><code class="p">[:]</code><code class="w"> </code><code class="c1">// this is a slice</code><code class="w"/></pre>
<p>We can also access elements in an array or a slice by iterating through the array or slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">numbers</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">[</code><code class="nx">i</code><code class="p">])</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This uses a normal <code>for</code> loop, iterating through the length of the slice, incrementing the count at every loop. The resulting output is as below.</p>
<pre data-type="programlisting">3
14
159
25
53
59</pre>
<p>This uses a <code>for …​ range</code> loop and returns the index <code>i</code> and the value <code>v</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">numbers</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"i: %d, v: %d\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The resulting output is as below</p>
<pre data-type="programlisting">i: 0, v: 3
i: 1, v: 14
i: 2, v: 159
i: 3, v: 25
i: 4, v: 53
i: 5, v: 59</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="6.3 Modifying arrays or slices" data-type="sect1"><div class="sect1" id="idm45195509810816">
<h1>6.3 Modifying arrays or slices</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195509480448">
<h2>Problem</h2>
<p>You want to add, insert or remove elements in an array or a slice.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195509478864">
<h2>Solution</h2>
<p>There are a few ways to modify elements in an array or a slice. Elements can be appended to the end of the slice, inserted at a particular index, removed or modified.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195509477280">
<h2>Discussion</h2>
<p>Besides accessing the elements in an array or slice, you would also want to add, modify or remove elements in a slice. While you cannot add or remove elements in an array, you can always modify its elements.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1000</code><code class="w"/></pre>
<p>When you modify the element at the given index, it will change the array or slice accordingly. In this case, when you run the code, you will get this.</p>
<pre data-type="programlisting">[3 14 1000 26 53 58 97]</pre>
<section data-pdf-bookmark="Appending" data-type="sect3"><div class="sect3" id="idm45195509416352">
<h3>Appending</h3>
<p>Arrays cannot change its size, so appending or adding elements to an array is out of question. Appending to slices is quite straightforward though. We can just use the <code>append</code> function, passing it the slice and the new element and we will be returned with a new slice that has the appended element.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">,</code><code class="w"> </code><code class="mi">97</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code above, you will get this.</p>
<pre data-type="programlisting">[3 14 159 26 53 58 97]</pre>
<p>You cannot append an element of a different type to the slice. However you can append multiple items to the slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">,</code><code class="w"> </code><code class="mi">97</code><code class="p">,</code><code class="w"> </code><code class="mi">932</code><code class="p">,</code><code class="w"> </code><code class="mi">38</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">626</code><code class="p">)</code><code class="w"/></pre>
<p>This means you can actually append a slice (or an array) to another slice by using the slice unpacking notation <code>…​</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">nums</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">97</code><code class="p">,</code><code class="w"> </code><code class="mi">932</code><code class="p">,</code><code class="w"> </code><code class="mi">38</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">626</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">,</code><code class="w"> </code><code class="nx">nums</code><code class="o">...</code><code class="p">)</code><code class="w"/></pre>
<p>However, appending both an element and an unpacked slice at the same time is not allowed. You can only choose to append multiple elements or an unpacked slice, but not both at the same time.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">,</code><code class="w"> </code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="nx">nums</code><code class="o">...</code><code class="p">)</code><code class="w"> </code><code class="c1">// this will produce an error</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="Inserting" data-type="sect3"><div class="sect3" id="idm45195509415888">
<h3>Inserting</h3>
<p>While appending adds an element to the end of the slice, inserting means adding an element anywhere in between elements in a slice. Again, this only applies to slices because array sizes are fixed.</p>
<p>There is no built-in function for insertion, unlike <code>append</code> but we can still use <code>append</code> for the task. Let’s say we want to insert the number 1000 between elements at index 2 and 3.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">[:</code><code class="mi">2</code><code class="o">+</code><code class="mi">1</code><code class="p">],</code><code class="w"> </code><code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="o">...</code><code class="p">)</code><code class="w"/>
<code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1000</code><code class="w"/></pre>
<p>First, we need to create a slice from the start of the original slice, to the index 2 plus 1. This will reserve a space for the new element we want to add. Next we append this slice to another slice that begins at the index 2 to the end of the original slice, using the unpack notation. With this, we have created a new element between the index 2 and 3. Finally, we set the new element, 1000, at index 2.</p>
<p>As as result we will get this new slice.</p>
<pre data-type="programlisting">[3 14 1000 159 26 53 58]</pre>
<p>What if we want to add an element to the beginning of the slice? Let’s say we want to add the integer 2000 to the beginning of the slice. This is quite simple, we simply append the value, in the form of a slice, to the unpacked values of the original slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">([]</code><code class="kt">int</code><code class="p">{</code><code class="mi">2000</code><code class="p">},</code><code class="w"> </code><code class="nx">numbers</code><code class="o">...</code><code class="p">)</code><code class="w"/></pre>
<p>That was the case with inserting a single element. What if we want to insert another slice in between another slice? Let’s say we want to insert the slice <code>[]int{1000, 2000, 3000, 4000}</code> in between our <code>numbers</code> slice.</p>
<p>There are a few ways of doing this, but we’ll stick with using <code>append</code>, which is one of the shortest way.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">inserted</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1000</code><code class="p">,</code><code class="w"> </code><code class="mi">2000</code><code class="p">,</code><code class="w"> </code><code class="mi">3000</code><code class="p">,</code><code class="w"> </code><code class="mi">4000</code><code class="p">}</code><code class="w"/>

<code class="nx">tail</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">append</code><code class="p">([]</code><code class="kt">int</code><code class="p">{},</code><code class="w"> </code><code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">:]</code><code class="o">...</code><code class="p">)</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">[:</code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="nx">inserted</code><code class="o">...</code><code class="p">)</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">,</code><code class="w"> </code><code class="nx">tail</code><code class="o">...</code><code class="p">)</code><code class="w"/>

<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/></pre>
<p>First of all, we need to create another slice, <code>tail</code> to store the <em>tail</em> part of the original slice. We can’t simply slice it and store into another variable (this is called <em>shallow copy</em>), because remember — slices are not arrays, they are a pointer to a part of the array, and its length. If we slice <code>numbers</code> and store it in <code>tail</code>, when we change <code>numbers</code>, <code>tail</code> will also change, and that is not what we want. Instead, we want to create a new slice by appending it to an empty slice of ints.</p>
<p>Now that we have put the tail aside, we append the head of <code>numbers</code> to the unpacked <code>inserted</code>. Finally we append <code>numbers</code> (which now consist of the head of the original slice, and <code>inserted</code>) and the <code>tail</code>. This is what we should get.</p>
<pre data-type="programlisting">[3 14 1000 2000 3000 4000 159 26 53 58]</pre>
</div></section>
<section data-pdf-bookmark="Removing" data-type="sect3"><div class="sect3" id="idm45195509207840">
<h3>Removing</h3>
<p>Removing elements from a slice is very easy. If it’s at the start or end of the slice, you simply re-slice it accordingly to remove either the start or the end of the slice.</p>
<p>Let’s take out the first element of the slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">numbers</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code><code class="w"> </code><code class="c1">// remove element 0</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/></pre>
<p>When you run the code above, you will get this.</p>
<pre data-type="programlisting">[14 159 26 53 58]</pre>
<p>Now let’s take out the last element of the slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">numbers</code><code class="p">[:</code><code class="nb">len</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="c1">// remove last element</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/></pre>
<p>When you run the code above, you will get this.</p>
<pre data-type="programlisting">[3 14 159 26 53]</pre>
<p>Removing elements in between is quite straightforward too. You simply append the head of the original slice with the tail of the original slice, removing whatever is in between. In this case, we want to remove the element at index 2.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">numbers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">,</code><code class="w"> </code><code class="mi">58</code><code class="p">}</code><code class="w"/>
<code class="nx">numbers</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">numbers</code><code class="p">[:</code><code class="mi">2</code><code class="p">],</code><code class="w"> </code><code class="nx">numbers</code><code class="p">[</code><code class="mi">3</code><code class="p">:]</code><code class="o">...</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">numbers</code><code class="p">)</code><code class="w"/></pre>
<p>When we run the code above, we get this.</p>
<pre data-type="programlisting">[3 14 26 53 58]</pre>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="6.4 Making arrays and slices safe for concurrent use" data-type="sect1"><div class="sect1" id="idm45195508718304">
<h1>6.4 Making arrays and slices safe for concurrent use</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195508717392">
<h2>Problem</h2>
<p>You want to make arrays and slices safe for concurrent use by multiple goroutines.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195508715808">
<h2>Solution</h2>
<p>Use a mutex from the <code>sync</code> library to safeguard the array or slice. Lock the array or slice before modifying it, and unlock it after modifications are made.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195508713776">
<h2>Discussion</h2>
<p>Arrays and slices are not safe for concurrent use. If you are going to share a slice or array between goroutines, you need to make it safe from race conditions. Go provides a <code>sync</code> package that can be used for this, in particular <code>Mutex</code>.</p>
<p>Let’s take a look first at how a race condition can come about. Race conditions occur when a shared resource is used by multiple goroutines trying to access it at the same time.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">shared</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">}</code><code class="w"/>

<code class="c1">// increase each element by 1</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">increase</code><code class="p">(</code><code class="nx">num</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[+%d a] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">shared</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">20</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Microsecond</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[+%d b] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// decrease each element by 1</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">decrease</code><code class="p">(</code><code class="nx">num</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[-%d a] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">shared</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">10</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Microsecond</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[-%d b] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>In the example above, we have a slice of integers named <code>shared</code>, that is used by 2 functions named <code>increase</code> and <code>decrease</code>. These 2 functions simply takes each element in the shared slice and increases or decreases it by 1 respectively. However before we increase or decrease the element, we wait for a very short period of time, with the <code>increase</code> function waiting for a longer time. This simulates the differences in timing between multiple goroutines. We print out the <code>shared</code> slice before we start modifying the shared element and also after we modify it to show the state of the shared slice before and after.</p>
<p>We call the <code>increase</code> and <code>decrease functions from +main</code> and we make each call to the functions a separate goroutine. At the end of the program we wait a bit to let all the goroutines finish up (else all goroutines will end when the program ends).</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">5</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="k">go</code><code class="w"> </code><code class="nx">increase</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">5</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="k">go</code><code class="w"> </code><code class="nx">decrease</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">2</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When we run the program, you will see something like this.</p>
<pre data-type="programlisting">[-4 a] : [1 2 3 4 5 6]
[-1 a] : [0 2 3 4 5 6]
[-2 a] : [0 1 3 4 5 6]
[-3 a] : [0 1 2 4 5 6]
[+0 a] : [-2 1 2 3 5 6]
[+1 a] : [-3 -1 2 3 4 6]
[-4 b] : [-2 -2 1 3 4 5]
[+3 a] : [-2 -2 0 3 4 5]
[+4 a] : [-1 -1 -1 1 4 5]
[-1 b] : [1 0 0 0 1 4]
[-2 b] : [1 0 0 0 1 3]
[-3 b] : [1 0 0 0 1 2]
[+2 a] : [1 0 0 0 1 2]
[-0 a] : [2 2 1 1 1 2]
[+0 b] : [1 2 3 2 1 3]
[-0 b] : [1 2 3 3 2 2]
[+1 b] : [1 2 3 4 4 3]
[+3 b] : [1 2 3 4 4 4]
[+4 b] : [1 2 3 4 4 5]
[+2 b] : [1 2 3 4 5 6]</pre>
<p>If you run it multiple times it will be a bit different each time. You will notice that even though we spin out a goroutine in sequence (sending in the sequence number to <code>modify</code> each time), the sequence that actually executes is random, which is an expected behavior. What we wouldn’t expect is that the goroutines overlap each other and the shared slice is incremented or decremented depending on which goroutine accesses it first.</p>
<p>For example, if we look at the first line in the output <code>[-4 a] : [1 2 3 4 5 6]</code> is printed before the loop to decrease each element is called. Subsequently after the loop the line that is printed is <code>[-4 b] : [-2 -2 1 3 4 5]</code> and you can see the first 3 elements are not what is expected!</p>
<p>Also you can will realise that the overlap even happens within the loop for increasing or decreasing the element.</p>
<p>How can we prevent such race conditions? Go has the <code>sync</code> package in the standard library that provides us with a <em>mutex</em> or a mutual exclusion lock.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">shared</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">4</code><code class="p">,</code><code class="w"> </code><code class="mi">5</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">}</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">mutex</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">Mutex</code><code class="w"/>

<code class="c1">// increase each element by 1</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">increaseWithMutex</code><code class="p">(</code><code class="nx">num</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">mutex</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[+%d a] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">shared</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">20</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Microsecond</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[+%d b] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">mutex</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="c1">// decrease each element by 1</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">decreaseWithMutex</code><code class="p">(</code><code class="nx">num</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">mutex</code><code class="p">.</code><code class="nx">Lock</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[-%d a] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">shared</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">10</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Microsecond</code><code class="p">)</code><code class="w"/>
<code class="w">		</code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">shared</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"[-%d b] : %v\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">shared</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="nx">mutex</code><code class="p">.</code><code class="nx">Unlock</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<pre>Using it is quite simple. Firstly we need to declare a mutex. Then, we call +Lock+ on the mutex before we start modifying the shared slice. This will lock up the shared slice such that nothing else can use it. When we're done, we call +Unlock+ to unlock the mutex.</pre>
<p>Here’s the output if you call these functions from <code>main</code> as before.</p>
<pre data-type="programlisting">[-4 a] : [1 2 3 4 5 6]
[-4 b] : [0 1 2 3 4 5]
[+0 a] : [0 1 2 3 4 5]
[+0 b] : [1 2 3 4 5 6]
[+1 a] : [1 2 3 4 5 6]
[+1 b] : [2 3 4 5 6 7]
[+2 a] : [2 3 4 5 6 7]
[+2 b] : [3 4 5 6 7 8]
[+3 a] : [3 4 5 6 7 8]
[+3 b] : [4 5 6 7 8 9]
[+4 a] : [4 5 6 7 8 9]
[+4 b] : [5 6 7 8 9 10]
[-0 a] : [5 6 7 8 9 10]
[-0 b] : [4 5 6 7 8 9]
[-1 a] : [4 5 6 7 8 9]
[-1 b] : [3 4 5 6 7 8]
[-2 a] : [3 4 5 6 7 8]
[-2 b] : [2 3 4 5 6 7]
[-3 a] : [2 3 4 5 6 7]
[-3 b] : [1 2 3 4 5 6]</pre>
<p>The results are a lot more organized. The goroutines no longer overlap, the increase and decrease of elements are orderly and consistent.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="6.5 Sorting arrays of slices" data-type="sect1"><div class="sect1" id="idm45195508227392">
<h1>6.5 Sorting arrays of slices</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195507937808">
<h2>Problem</h2>
<p>You want to sort elements in an array or slice.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195507936336">
<h2>Solution</h2>
<p>For <code>int</code>, <code>float64</code> and <code>string</code> arrays or slices you can use <code>sort.Ints</code>, <code>sort.Float64s</code> and <code>sort.Strings</code>. You can also use a custom comparator by using <code>sort.Slice</code>. For structs, you can create a sortable interface by implementing the <code>sort.Interface</code> interface and then using <code>sort.Sort</code> to sort the array or slice.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195507930752">
<h2>Discussion</h2>
<p>Arrays and slices are ordered sequence of elements. However this doesn’t mean they are sorted in any way, it only means the elements are always laid out in the same sequence. To sort the arrays or slices, we can use the various functions in the <code>sort</code> package.</p>
<p>For <code>int</code>, <code>float64</code> and <code>string</code> we can use the corresponding <code>sort.Ints</code>, <code>sort.Float64s</code> and <code>sort.Strings</code> functions.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">integers</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">3</code><code class="p">,</code><code class="w"> </code><code class="mi">14</code><code class="p">,</code><code class="w"> </code><code class="mi">159</code><code class="p">,</code><code class="w"> </code><code class="mi">26</code><code class="p">,</code><code class="w"> </code><code class="mi">53</code><code class="p">}</code><code class="w"/>
<code class="nx">floats</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">float64</code><code class="p">{</code><code class="mf">3.14</code><code class="p">,</code><code class="w"> </code><code class="mf">1.41</code><code class="p">,</code><code class="w"> </code><code class="mf">1.73</code><code class="p">,</code><code class="w"> </code><code class="mf">2.72</code><code class="p">,</code><code class="w"> </code><code class="mf">4.53</code><code class="p">}</code><code class="w"/>
<code class="nx">strings</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="s">"the"</code><code class="p">,</code><code class="w"> </code><code class="s">"quick"</code><code class="p">,</code><code class="w"> </code><code class="s">"brown"</code><code class="p">,</code><code class="w"> </code><code class="s">"fox"</code><code class="p">,</code><code class="w"> </code><code class="s">"jumped"</code><code class="p">}</code><code class="w"/>

<code class="nx">sort</code><code class="p">.</code><code class="nx">Ints</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/>
<code class="nx">sort</code><code class="p">.</code><code class="nx">Float64s</code><code class="p">(</code><code class="nx">floats</code><code class="p">)</code><code class="w"/>
<code class="nx">sort</code><code class="p">.</code><code class="nx">Strings</code><code class="p">(</code><code class="nx">strings</code><code class="p">)</code><code class="w"/>

<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">floats</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">strings</code><code class="p">)</code><code class="w"/></pre>
<p>If we run the code above, this is what we will see.</p>
<pre data-type="programlisting">[3 14 26 53 159]
[1.41 1.73 2.72 3.14 4.53]
[brown fox jumped quick the]</pre>
<p>This is sorted in ascending order. What if we want to sort it in descending order? There is no ready-made function to sort in descending order, but we want easily use a simple <code>for</code> loop to reverse the sorted slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="o">/</code><code class="mi">2</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">--</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">opp</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">i</code><code class="w"/>
<code class="w">    </code><code class="nx">integers</code><code class="p">[</code><code class="nx">i</code><code class="p">],</code><code class="w"> </code><code class="nx">integers</code><code class="p">[</code><code class="nx">opp</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">integers</code><code class="p">[</code><code class="nx">opp</code><code class="p">],</code><code class="w"> </code><code class="nx">integers</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">integers</code><code class="p">)</code><code class="w"/></pre>
<p>We simply find the middle of the slice, and then using a loop, we exchange the elements with their opposite side, starting from that middle. If we run the snippet above, this is what you will get.</p>
<pre data-type="programlisting">[159 53 26 14 3]</pre>
<p>We can also use the <code>sort.Slice</code> function, passing in our own <code>less</code> function.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">sort</code><code class="p">.</code><code class="nx">Slice</code><code class="p">(</code><code class="nx">floats</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">floats</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="nx">floats</code><code class="p">[</code><code class="nx">j</code><code class="p">]</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">floats</code><code class="p">)</code><code class="w"/></pre>
<p>This will product the output.</p>
<pre data-type="programlisting">[4.53 3.14 2.72 1.73 1.41]</pre>
<p>The <code>less</code> function, which is the second parameter in the <code>sort.Slice</code> function, takes in 2 parameters <code>i</code> and <code>j</code>, indices of the consecutive elements of the slice. It’s supposed to return true if the element at <code>i</code> is less than the element at <code>j</code> when sorting.</p>
<p>What if the elements are the same? Using <code>sort.Slice</code> means the elements order might be reversed from their original order (or remain the same). If you want the order to be consistently the same as the original, you can use <code>sort.SliceStable</code>.</p>
<p>The <code>sort.Slice</code> function works with slices with any types, so this means you can also sort custom structs.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="nx">Person</code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Alice"</code><code class="p">,</code><code class="w"> </code><code class="mi">22</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">18</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Charlie"</code><code class="p">,</code><code class="w"> </code><code class="mi">23</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Dave"</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Eve"</code><code class="p">,</code><code class="w"> </code><code class="mi">31</code><code class="p">},</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">sort</code><code class="p">.</code><code class="nx">Slice</code><code class="p">(</code><code class="nx">people</code><code class="p">,</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">return</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Age</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="nx">j</code><code class="p">].</code><code class="nx">Age</code><code class="w"/>
<code class="p">})</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">people</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code above you will the output below, with the <code>people</code> slice sorted according to the ages of the people.</p>
<pre data-type="programlisting">[{Bob 18} {Alice 22} {Charlie 23} {Dave 27} {Eve 31}]</pre>
<p>Another way of sorting structs is by implementing the <code>sort.Interface</code>. Let’s see how we can do this for the <code>Person</code> struct.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">Name</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">	</code><code class="nx">Age</code><code class="w">  </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">ByAge</code><code class="w"> </code><code class="p">[]</code><code class="nx">Person</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="nx">ByAge</code><code class="p">)</code><code class="w"> </code><code class="nx">Len</code><code class="p">()</code><code class="w"> </code><code class="kt">int</code><code class="w">           </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="nx">ByAge</code><code class="p">)</code><code class="w"> </code><code class="nx">Less</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="k">return</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Age</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">j</code><code class="p">].</code><code class="nx">Age</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="w"> </code><code class="nx">ByAge</code><code class="p">)</code><code class="w"> </code><code class="nx">Swap</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w">      </code><code class="p">{</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">],</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">j</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">j</code><code class="p">],</code><code class="w"> </code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>
<p>We want to sort a slice of structs, so we need to associate the interface functions to the slice, not the struct. We create a type named <code>ByAge</code> that is a slice of <code>Person</code> structs. Next, we associate the <code>Len</code>, <code>Less</code> and <code>Swap</code> functions to <code>ByAge</code>, making it a struct that implements <code>sort.Interface</code>. The <code>Less</code> method here is the same as the one we used in the <code>sort.Slice</code> function above.</p>
<p>Using this is quite simple. We cast <code>people</code> to <code>ByAge</code>, and pass that into <code>sort.Sort</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="nx">Person</code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Alice"</code><code class="p">,</code><code class="w"> </code><code class="mi">22</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="mi">18</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Charlie"</code><code class="p">,</code><code class="w"> </code><code class="mi">23</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Dave"</code><code class="p">,</code><code class="w"> </code><code class="mi">27</code><code class="p">},</code><code class="w"/>
<code class="w">	</code><code class="p">{</code><code class="s">"Eve"</code><code class="p">,</code><code class="w"> </code><code class="mi">31</code><code class="p">},</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">sort</code><code class="p">.</code><code class="nx">Sort</code><code class="p">(</code><code class="nx">ByAge</code><code class="p">(</code><code class="nx">people</code><code class="p">))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">people</code><code class="p">)</code><code class="w"/></pre>
<p>If you run the code above, you will see the same results as below.</p>
<pre data-type="programlisting">[{Bob 18} {Alice 22} {Charlie 23} {Dave 27} {Eve 31}]</pre>
<p>Implementing <code>sort.Interface</code> is a bit long-winded, but there are certainly some advantages. For one, we can use the <code>sort.Reverse</code> to sort by descending order.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">sort</code><code class="p">.</code><code class="nx">Sort</code><code class="p">(</code><code class="nx">sort</code><code class="p">.</code><code class="nx">Reverse</code><code class="p">(</code><code class="nx">ByAge</code><code class="p">(</code><code class="nx">people</code><code class="p">)))</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">people</code><code class="p">)</code><code class="w"/></pre>
<p>This produces the following output.</p>
<pre data-type="programlisting">[{Eve 31} {Dave 27} {Charlie 23} {Alice 22} {Bob 18}]</pre>
<p>You can also use the <code>sort.IsSorted</code> function to check if the slice is already sorted.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">sort</code><code class="p">.</code><code class="nx">IsSorted</code><code class="p">(</code><code class="nx">ByAge</code><code class="p">(</code><code class="nx">people</code><code class="p">))</code><code class="w"> </code><code class="c1">// true if it's sorted</code><code class="w"/></pre>
<p>The biggest advantage though, is using <code>sort.Interface</code> is a lot more performant than using <code>sort.Slice</code>. Let’s do a simple benchmark.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkSortSlice</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">f</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">j</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="k">return</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">Age</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="nx">j</code><code class="p">].</code><code class="nx">Age</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="w">	</code><code class="nx">b</code><code class="p">.</code><code class="nx">ResetTimer</code><code class="p">()</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">sort</code><code class="p">.</code><code class="nx">Slice</code><code class="p">(</code><code class="nx">people</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">)</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkSortInterface</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">N</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">		</code><code class="nx">sort</code><code class="p">.</code><code class="nx">Sort</code><code class="p">(</code><code class="nx">ByAge</code><code class="p">(</code><code class="nx">people</code><code class="p">))</code><code class="w"/>
<code class="w">	</code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Here’s the results of the benchmark.</p>
<pre data-type="programlisting">$ go test -bench=BenchmarkSort
goos: darwin
goarch: arm64
pkg: github.com/sausheong/gocookbook/ch14_data_structures
BenchmarkSortSlice-10     	 9376766	       108.9 ns/op
BenchmarkSortInterface-10  	26790697	        44.33 ns/op
PASS
ok  	github.com/sausheong/gocookbook/ch14_data_structures	2.901s</pre>
<p>As you can see, using the <code>sort.Interface</code> is more efficient. This is because <code>sort.Slice</code> uses <code>interface{}</code> as the first parameter. This means it takes in any structs but is less efficient.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="6.6 Creating maps" data-type="sect1"><div class="sect1" id="idm45195507929680">
<h1>6.6 Creating maps</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195506933568">
<h2>Problem</h2>
<p>You want to create new maps.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195506931952">
<h2>Solution</h2>
<p>Use the <code>map</code> keyword to declare it, and then use the <code>make</code> function to initialize it. Maps must be intialized before use.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195506929504">
<h2>Discussion</h2>
<p>To create a map, we can use the <code>map</code> keyword.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">people</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="w"/></pre>
<p>The snippet above declares a map named <code>people</code>, that maps a key of type string to a value of type int. The <code>people</code> map can’t be used yet since its zero-value is nil. To use it we need to initialize it with the <code>make</code> method.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>
<p>If it looks silly to you that you have to repeat <code>map[string]int</code> in both the declaration and initialization, you should look at doing both at the same time.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">)</code><code class="w"/></pre>
<p>This is will create an empty map. To populate the map you can map a string to an int.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="p">[</code><code class="s">"Alice"</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">22</code><code class="w"/></pre>
<p>You can also initialize the map this way.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="s">"Alice"</code><code class="p">:</code><code class="w">   </code><code class="mi">22</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Bob"</code><code class="p">:</code><code class="w">     </code><code class="mi">18</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Charlie"</code><code class="p">:</code><code class="w"> </code><code class="mi">23</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Dave"</code><code class="p">:</code><code class="w">    </code><code class="mi">27</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Eve"</code><code class="p">:</code><code class="w">     </code><code class="mi">31</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>If you print the map out, this is how it will look.</p>
<pre data-type="programlisting">map[Alice:22 Bob:18 Charlie:23 Dave:27 Eve:31]</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="6.7 Accessing maps" data-type="sect1"><div class="sect1" id="idm45195506666160">
<h1>6.7 Accessing maps</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195506713824">
<h2>Problem</h2>
<p>You want to access keys and values in a map.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195506712208">
<h2>Solution</h2>
<p>Use the key within square brackets to access the value in a map. You can also use a <code>for …​ range</code> loop to iterate through map.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195506710208">
<h2>Discussion</h2>
<p>Accessing the values given a key is straightforward. Just use the key within square brackets to access the values.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int</code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="s">"Alice"</code><code class="p">:</code><code class="w">   </code><code class="mi">22</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Bob"</code><code class="p">:</code><code class="w">     </code><code class="mi">18</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Charlie"</code><code class="p">:</code><code class="w"> </code><code class="mi">23</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Dave"</code><code class="p">:</code><code class="w">    </code><code class="mi">27</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="s">"Eve"</code><code class="p">:</code><code class="w">     </code><code class="mi">31</code><code class="p">,</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="nx">people</code><code class="p">[</code><code class="s">"Alice"</code><code class="p">]</code><code class="w"> </code><code class="c1">// 22</code><code class="w"/></pre>
<p>What if the key doesn’t exist? Nothing happens, Go simply returns the zero-value of the value type. In our case the zero value of an integer is 0, so if we do this.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="p">[</code><code class="s">"Nemo"</code><code class="p">]</code><code class="w"> </code><code class="c1">// 0</code><code class="w"/></pre>
<p>It will simply returns a 0. This might not be what we’re looking for (especially if 0 is a valid response) so there is a mechanism to check if the key exists or not.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">age</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="s">"Nemo"</code><code class="p">]</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="c1">// do whatever you want if the value exists</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The <em>comma, ok</em> pattern is commonly used in many cases, and can be used here to check if the key exists in the map. The use is obvious, if the key exists, <code>ok</code> becomes true, else if is be false. The <code>ok</code> is not a keyword though, you can use any variable name, it’s using the multiple value assignment. The value is still returned but since you know the key doesn’t exist and it’s just a zero-value, you would probably not use it.</p>
<p>We can also use a <code>for …​ range</code> loop to iterate through a map, just like what we did with arrays and slices, except instead of getting the index and the element, we get the key and the value.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">k</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">people</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Running the code above will give us this output.</p>
<pre data-type="programlisting">Alice 22
Bob 18
Charlie 23
Dave 27
Eve 31</pre>
<p>If you just want the keys, you can just leave out the the second value you get from the range.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">k</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">people</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">k</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>You will get this output.</p>
<pre data-type="programlisting">Alice
Bob
Charlie
Dave
Eve</pre>
<p>How about if we want just the values? There is no special way of getting just the values, you have to use the same mechanism, and put them all in a slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">values</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">people</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">values</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">values</code><code class="p">,</code><code class="w"> </code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">values</code><code class="p">)</code><code class="w"/></pre>
<p>You will get this output.</p>
<pre data-type="programlisting">[22 18 23 27 31]</pre>
</div></section>
</div></section>
<section data-pdf-bookmark="6.8 Modifying maps" data-type="sect1"><div class="sect1" id="idm45195506709136">
<h1>6.8 Modifying maps</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195506364816">
<h2>Problem</h2>
<p>You want to modify or remove elements in a map.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195506363200">
<h2>Solution</h2>
<p>Use the <code>delete</code> function to remove key-value pairs from a map. To modify the value, just re-assign the value.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195506361056">
<h2>Discussion</h2>
<p>Modifying a value is simply overriding the existing value.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nx">people</code><code class="p">[</code><code class="s">"Alice"</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">23</code><code class="w"/></pre>
<p>The value of <code>people["Alice"]</code> will become 23.</p>
<p>To remove a key, Go provides a built-in function named <code>delete</code>.</p>
<pre data-code-language="go" data-type="programlisting"><code class="nb">delete</code><code class="p">(</code><code class="nx">people</code><code class="p">,</code><code class="w"> </code><code class="s">"Alice"</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">people</code><code class="p">)</code><code class="w"/></pre>
<p>This will be the output.</p>
<pre data-type="programlisting">map[Bob:18 Charlie:23 Dave:27 Eve:31]</pre>
<p>What happens if you try to delete a key that doesn’t exist? Nothing happens.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="6.9 Sorting maps" data-type="sect1"><div class="sect1" id="idm45195506303264">
<h1>6.9 Sorting maps</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45195506302320">
<h2>Problem</h2>
<p>You want sort a map by its keys.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45195506276336">
<h2>Solution</h2>
<p>Get the keys of the map in a slice and sort that slice. Then using the sorted slice of keys, iterate through map again.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45195506274624">
<h2>Discussion</h2>
<p>Maps are unordered. This means each time you iterate through a map, the order of the key-value pairs might not be the same as the previous time. So how can we ensure that it’s the same each time?</p>
<p>First, we extract the keys out into a slice.</p>
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">keys</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">k</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">people</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">keys</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">keys</code><code class="p">,</code><code class="w"> </code><code class="nx">k</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Then we sort the keys accordingly. In this case we want to sort by descending order.</p>
<pre data-code-language="go" data-type="programlisting"><code class="c1">// sort keys by descending order</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">keys</code><code class="p">)</code><code class="o">/</code><code class="mi">2</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">--</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">opp</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">keys</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">i</code><code class="w"/>
<code class="w">	</code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">],</code><code class="w"> </code><code class="nx">keys</code><code class="p">[</code><code class="nx">opp</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">keys</code><code class="p">[</code><code class="nx">opp</code><code class="p">],</code><code class="w"> </code><code class="nx">keys</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Finally we can access the map by the descending order of the keys.</p>
<pre data-code-language="go" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">key</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">keys</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">	</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code><code class="w"> </code><code class="nx">people</code><code class="p">[</code><code class="nx">key</code><code class="p">])</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>When we run the code, we will see this.</p>
<pre data-type="programlisting">Eve 31
Dave 27
Charlie 23
Bob 18
Alice 22</pre>
</div></section>
</div></section>
</div></section></div>

<div id="sbo-rt-content"><section class="abouttheauthor" data-pdf-bookmark="About the Author" data-type="colophon" epub:type="colophon"><div class="colophon" id="idm45195510198608">
<h1>About the Author</h1>
<p><strong>Chang Sau Sheong</strong> has been in the software development industry for more than 27 years, 
    and has been involved in building software products in many industries and using various 
    technologies. He is an active member of the software development communities for Java, Ruby 
    previously and now focuses mostly on Go, running meetups and giving talks in conferences all 
    around the world. He also runs the GopherCon Singapore, one of the largest community-led 
    developer conferences in Southeast Asia, and has been doing so since 2017. Sau Sheong has 
    written 4 programming books, 3 in Ruby and the last one in Go.</p>
</div></section></div></body></html>