- en: Chapter 6\. Secured gRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 安全的gRPC
- en: gRPC-based applications communicate with each other remotely over the network.
    This requires each gRPC application to expose its entry point to others who need
    to communicate with it. From a security point of view, this is not a good thing.
    The more entry points we have, the broader the attack surface, and the higher
    the risk of being attacked. Therefore, securing communication and securing the
    entry points is essential for any real-world use case. Every gRPC application
    must be able to handle encrypted messages, encrypt all internode communications,
    and authenticate and sign all messages, etc.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于gRPC的应用程序在网络上远程通信。这要求每个gRPC应用程序向需要与其通信的其他应用程序公开其入口点。从安全性的角度来看，这并不是一件好事。我们拥有的入口点越多，攻击面就越广，被攻击的风险就越高。因此，保护通信并保护入口点对于任何真实世界的使用案例都是至关重要的。每个gRPC应用程序必须能够处理加密消息，加密所有节点间的通信，并验证和签署所有消息等。
- en: In this chapter, we’ll cover a set of security fundamentals and patterns to
    address the challenge we face in enabling application-level security. In simple
    terms, we are going to explore how we can secure communication channels between
    microservices and authenticate and control access by users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一组安全基础知识和模式，以解决在启用应用级安全时面临的挑战。简单来说，我们将探讨如何保护微服务之间的通信通道，并验证和控制用户的访问权限。
- en: So let’s start with securing the communication channel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从保护通信通道开始。
- en: Authenticating a gRPC Channel with TLS
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TLS验证gRPC通道
- en: '*Transport Level Security* (TLS) aims to provide privacy and data integrity
    between two communicating applications. Here, it’s about providing a secure connection
    between gRPC client and server applications. According to the [Transport Level
    Security Protocol Specification](https://oreil.ly/n4iIE), when the connection
    between a client and a server is secure, it should have one or more of the following
    properties:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层安全* (TLS) 旨在为两个通信应用程序提供隐私和数据完整性保护。在这里，它关注的是为gRPC客户端和服务器应用程序之间提供安全连接。根据[传输层安全协议规范](https://oreil.ly/n4iIE)，当客户端和服务器之间的连接是安全的时，它应具有以下一个或多个属性：'
- en: The connection is private
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是私密的
- en: Symmetric cryptography is used for data encryption. It is a type of encryption
    where only one key (a secret key) is used to both encrypt and decrypt. These keys
    are generated uniquely for each connection based on a shared secret that was negotiated
    at the start of the session.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据加密使用对称加密技术。这是一种加密类型，其中仅使用一个密钥（秘密密钥）进行加密和解密。这些密钥根据会话开始时协商的共享秘密生成，对每个连接都是唯一的。
- en: The connection is reliable
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是可靠的
- en: This occurs because each message includes a message integrity check to prevent
    undetected loss or alteration of the data during transmission.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每条消息都包含消息完整性检查，以防止在传输过程中发生未检测到的数据丢失或更改。
- en: So it is important to send data through a secure connection. Securing gRPC connections
    with TLS is not a difficult task, because this authentication mechanism is built
    into the gRPC library. It also promotes the use of TLS to authenticate and encrypt
    exchanges.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过安全连接发送数据非常重要。使用TLS保护gRPC连接并不困难，因为这种认证机制已内置于gRPC库中。它还推广了TLS的使用，用于验证和加密交换。
- en: How, then, do we enable transport-level security in gRPC connections? Secure
    data transfer between a client and server can be implemented as either one way
    or two way (this is also known as mutual TLS, or mTLS). In the following sections,
    we’ll discuss how to enable security in each of these ways.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在gRPC连接中启用传输层安全呢？客户端和服务器之间的安全数据传输可以实现为单向或双向（也称为双向TLS或mTLS）。在接下来的部分中，我们将讨论如何以这些方式启用安全性。
- en: Enabling a One-Way Secured Connection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用单向安全连接
- en: In a one-way connection, only the client validates the server to ensure that
    it receives data from the intended server. When establishing the connection between
    the client and the server, the server shares its public certificate with the client,
    who then validates the received certificate. This is done through a certificate
    authority (CA), for CA-signed certificates. Once the certificate is validated,
    the client sends the data encrypted using the secret key.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在单向连接中，只有客户端验证服务器，以确保它从预期的服务器接收数据。在建立客户端和服务器之间的连接时，服务器会向客户端共享其公共证书，客户端然后验证接收到的证书。对于由证书颁发机构（CA）签名的证书，这是通过证书颁发机构（CA）完成的。一旦证书验证通过，客户端就使用密钥加密发送数据。
- en: The CA is a trusted entity that manages and issues security certificates and
    public keys that are used for secure communication in a public network. Certificates
    signed or issued by this trusted entity are known as CA-signed certificates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CA 是一个受信任的实体，负责管理和签发用于公共网络中安全通信的安全证书和公钥。由该受信任实体签署或颁发的证书称为 CA 签名证书。
- en: 'To enable TLS, first we need to create the following certificates and keys:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 TLS，首先我们需要创建以下证书和密钥：
- en: '`server.key`'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.key`'
- en: A private RSA key to sign and authenticate the public key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用于签署和验证公共密钥的私有 RSA 密钥。
- en: '`server.pem/server.crt`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.pem/server.crt`'
- en: Self-signed X.509 public keys for distribution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名的 X.509 公钥用于分发。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The acronym *RSA* stands for the names of three inventors: Rivest, Shamir,
    and Adleman. RSA is one of the most popular public-key cryptosystems, being widely
    used in secure data transmission. In RSA, a public key (that can be known by everyone)
    is used to encrypt data. A private key is then used to decrypt data. The idea
    is that messages encrypted with the public key can only be decrypted in a reasonable
    amount of time by using the private key.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写 *RSA* 代表三位发明者的名字：Rivest、Shamir 和 Adleman。RSA 是最流行的公钥密码系统之一，在安全数据传输中被广泛使用。在
    RSA 中，公钥（可被所有人知道）用于加密数据。然后使用私钥解密数据。其思想是只有使用私钥才能在合理的时间内解密用公钥加密的消息。
- en: To generate the keys, we can use the OpenSSL tool, which is an open source toolkit
    for the TLS and Secure Socket Layer (SSL) protocols. It has support for generating
    private keys with different sizes and pass phrases, public certificates, etc.
    There are other tools like [mkcert](https://mkcert.dev) and [certstrap](https://oreil.ly/Mu4Q6),
    which can also be used to generate the keys and certificates easily.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成这些密钥，我们可以使用 OpenSSL 工具，这是一个开源工具包，用于 TLS 和安全套接字层（SSL）协议。它支持生成不同大小和密码短语的私钥、公共证书等。还有其他工具如
    [mkcert](https://mkcert.dev) 和 [certstrap](https://oreil.ly/Mu4Q6)，也可以用来轻松生成密钥和证书。
- en: We won’t describe here how to generate keys that are self-signed certificates,
    as step-by-step details on generating those keys and certificates are described
    in the README file in the source code repository.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在此描述如何生成自签名证书的密钥，因为在源代码仓库的 README 文件中已经详细描述了生成这些密钥和证书的逐步详细过程。
- en: Assume we created both a private key and public certificate. Let’s use them
    and secure communication between the gRPC server and client for our online product
    management system discussed in Chapters [1](ch01.html#grpc_ch_01) and [2](ch02.html#ch_02).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经创建了私钥和公共证书。让我们使用它们，为我们在第 [1](ch01.html#grpc_ch_01) 和 [2](ch02.html#ch_02)
    章讨论的在线产品管理系统中的 gRPC 服务器和客户端之间的通信进行安全保护。
- en: Enabling a one-way secured connection in a gRPC server
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 gRPC 服务器中的单向安全连接
- en: This is the simplest way to encrypt communication between client and server.
    Here the server needs to be initialized with a public/private key pair. We are
    going to explain how it is done using our gRPC Go server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加密客户端和服务器通信的最简单方法。这里服务器需要用公共/私有密钥对初始化。我们将解释如何在我们的 gRPC Go 服务器中执行这个过程。
- en: To enable a secured Go server, let’s update the main function of the server
    implementation, as shown in [Example 6-1](#EX6-1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在安全 Go 服务器中启用安全连接，让我们根据 [示例 6-1](#EX6-1) 更新服务器实现的主函数。
- en: Example 6-1\. gRPC secured server implementation for hosting ProductInfo service
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 用于托管 ProductInfo 服务的 gRPC 安全服务器实现
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO1-1)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO1-1)'
- en: Read and parse a public/private key pair and create a certificate to enable
    TLS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和解析公共/私有密钥对，并创建证书以启用 TLS。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO1-2)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO1-2)'
- en: Enable TLS for all incoming connections by adding certificates as TLS server
    credentials.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加证书作为 TLS 服务器凭据，为所有传入连接启用 TLS。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO1-3)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO1-3)'
- en: Create a new gRPC server instance by passing TLS server credentials.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递 TLS 服务器凭据创建一个新的 gRPC 服务器实例。
- en: '[![4](assets/4.png)](#co_secured_grpc_CO1-4)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secured_grpc_CO1-4)'
- en: Register the implemented service to the newly created gRPC server by calling
    generated APIs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用生成的 API，将实现的服务注册到新创建的 gRPC 服务器。
- en: '[![5](assets/5.png)](#co_secured_grpc_CO1-5)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secured_grpc_CO1-5)'
- en: Create a TCP listener on the port (50051).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口（50051）上创建一个 TCP 监听器。
- en: '[![6](assets/6.png)](#co_secured_grpc_CO1-6)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_secured_grpc_CO1-6)'
- en: Bind the gRPC server to the listener and start listening to incoming messages
    on the port (50051).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将 gRPC 服务器绑定到侦听器并开始侦听端口（50051）上的传入消息。
- en: Now we have modified the server to accept requests from clients who can verify
    the server certificate. Let’s modify our client code to talk with this server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了服务器，使其接受可以验证服务器证书的客户端的请求。让我们修改我们的客户端代码，与这个服务器通信。
- en: Enabling a one-way secured connection in a gRPC client
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 gRPC 客户端启用单向安全连接
- en: In order to get the client connected, the client needs to have the server’s
    self-certified public key. We can modify our Go client code to connect with the
    server as shown in [Example 6-2](#EX6-2).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端连接成功，客户端需要服务器的自签名公钥。我们可以修改我们的 Go 客户端代码，以连接示例 [6-2](#EX6-2) 中的服务器。
- en: Example 6-2\. gRPC secured client application
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2. gRPC 安全客户端应用程序
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO2-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO2-1)'
- en: Read and parse a public certificate and create a certificate to enable TLS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和解析公共证书并创建证书以启用 TLS。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO2-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO2-2)'
- en: Add transport credentials as a `DialOption`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将传输凭证添加为 `DialOption`。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO2-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO2-3)'
- en: Set up a secure connection with the server, passing dial options.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拨号选项与服务器建立安全连接。
- en: '[![4](assets/4.png)](#co_secured_grpc_CO2-5)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secured_grpc_CO2-5)'
- en: Pass the connection and create a stub. This stub instance contains all the remote
    methods to invoke the server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传递连接并创建存根。该存根实例包含所有远程方法，以调用服务器。
- en: '[![5](assets/5.png)](#co_secured_grpc_CO2-4)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secured_grpc_CO2-4)'
- en: Close the connection when everything is done.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都完成时，关闭连接。
- en: This is a fairly straightforward process. We only need to add three lines and
    modify one from the original code. First, we create a credential object from the
    server public key file, then pass the transport credentials into the gRPC dialer.
    This will initiate the TLS handshake every time the client sets up a connection
    between the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单直接的过程。我们只需从原始代码中添加三行并修改一行。首先，我们从服务器公钥文件创建一个凭证对象，然后将传输凭证传递给 gRPC 拨号器。这将在每次客户端建立与服务器之间的连接时启动
    TLS 握手。
- en: In one-way TLS, we only authenticate server identity. Let’s authenticate both
    parties (the client and the server) in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在单向 TLS 中，我们只验证服务器身份。让我们在下一节中同时验证双方（客户端和服务器）。
- en: Enabling an mTLS Secured Connection
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 mTLS 安全连接
- en: 'The main intent of an mTLS connection between client and server is to have
    control of clients who connect to the server. Unlike a one-way TLS connection,
    the server is configured to accept connections from a limited group of verified
    clients. Here both parties share their public certificates with each other and
    validate the other party. The basic flow of connection is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的 mTLS 连接的主要目的是控制连接到服务器的客户端。与单向 TLS 连接不同，服务器配置为接受来自一组经过验证的客户端的连接。在这种连接中，双方都彼此分享其公共证书并验证对方。连接的基本流程如下：
- en: Client sends a request to access protected information from the server.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送请求以访问服务器上的受保护信息。
- en: The server sends its X.509 certificate to the client.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器向客户端发送其 X.509 证书。
- en: Client validates the received certificate through a CA for CA-signed certificates.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端通过 CA 验证接收到的证书以验证 CA 签名的证书。
- en: If the verification is successful, the client sends its certificate to the server.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果验证成功，客户端将其证书发送给服务器。
- en: Server also verifies the client certificate through the CA.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器还通过 CA 验证客户端的证书。
- en: Once it is successful, the server gives permission to access protected data.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功，服务器允许访问受保护的数据。
- en: To enable mTLS in our example, we need to figure out how to deal with client
    and server certificates. We need to create a CA with self-signed certificates,
    we need to create certificate-signing requests for both client and server, and
    we need to sign them using our CA. As in the previous one-way secured connection,
    we can use the OpenSSL tool to generate keys and certificates.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的示例中启用 mTLS，我们需要解决如何处理客户端和服务器证书的问题。我们需要创建一个带有自签名证书的 CA，为客户端和服务器分别创建证书签名请求，并使用我们的
    CA 签名它们。与之前的单向安全连接一样，我们可以使用 OpenSSL 工具生成密钥和证书。
- en: 'Assume we have all the required certificates to enable mTLS for client-server
    communication. If you generated them correctly, you will have the following keys
    and certificates created in your workspace:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有所有必需的证书来启用客户端与服务器的 mTLS 通信。如果您正确生成了它们，您的工作空间中将创建以下密钥和证书：
- en: server.key
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: server.key
- en: Private RSA key of the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的私有 RSA 密钥。
- en: server.crt
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: server.crt
- en: Public certificate of the server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的公共证书。
- en: client.key
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: client.key
- en: Private RSA key of the client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的私有 RSA 密钥。
- en: client.crt
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: client.crt
- en: Public certificate of the client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的公共证书。
- en: ca.crt
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ca.crt
- en: Public certificate of a CA used to sign all public certificates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 用于签署所有公共证书的 CA 的公共证书。
- en: Let’s first modify the server code of our example to create X.509 key pairs
    directly and create a certificate pool based on the CA public key.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先修改示例中的服务器代码，直接创建 X.509 密钥对，并基于 CA 公钥创建证书池。
- en: Enabling mTLS in a gRPC server
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 gRPC 服务器中启用 mTLS
- en: To enable mTLS in the Go server, let’s update the main function of the server
    implementation as shown in [Example 6-3](#EX6-3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 服务器中启用 mTLS，请按照[示例 6-3](#EX6-3)中显示的方式更新服务器实现的主函数。
- en: Example 6-3\. gRPC secured server implementation for hosting ProductInfo service
    in Go
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 用于在 Go 中托管 ProductInfo 服务的 gRPC 安全服务器实现
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO3-1)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO3-1)'
- en: Create X.509 key pairs directly from the server certificate and key.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从服务器证书和密钥创建 X.509 密钥对。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO3-2)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO3-2)'
- en: Create a certificate pool from the CA.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CA 创建证书池。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO3-3)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO3-3)'
- en: Append the client certificates from the CA to the certificate pool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将来自 CA 的客户端证书附加到证书池。
- en: '[![4](assets/4.png)](#co_secured_grpc_CO3-4)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secured_grpc_CO3-4)'
- en: Enable TLS for all incoming connections by creating TLS credentials.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建 TLS 凭据为所有传入连接启用 TLS。
- en: '[![5](assets/5.png)](#co_secured_grpc_CO3-5)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secured_grpc_CO3-5)'
- en: Create a new gRPC server instance by passing TLS server credentials.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递 TLS 服务器凭据创建新的 gRPC 服务器实例。
- en: '[![6](assets/6.png)](#co_secured_grpc_CO3-6)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_secured_grpc_CO3-6)'
- en: Register the gRPC service to the newly created gRPC server by calling generated
    APIs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用生成的 API 将 gRPC 服务注册到新创建的 gRPC 服务器。
- en: '[![7](assets/7.png)](#co_secured_grpc_CO3-7)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_secured_grpc_CO3-7)'
- en: Create a TCP listener on the port (50051).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在端口（50051）上创建 TCP 监听器。
- en: '[![8](assets/8.png)](#co_secured_grpc_CO3-8)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_secured_grpc_CO3-8)'
- en: Bind the gRPC server to the listener and start listening to the incoming messages
    on the port (50051).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 gRPC 服务器绑定到侦听器，并开始在端口（50051）上监听传入的消息。
- en: Now we have modified the server to accept requests from verified clients. Let’s
    modify our client code to talk with this server.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了服务器以接受来自验证客户端的请求。让我们修改我们的客户端代码以与此服务器通信。
- en: Enabling mTLS in a gRPC client
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 gRPC 客户端中启用 mTLS
- en: In order to get the client connected, the client needs to follow similar steps
    as the server. We can modify our Go client code as shown in [Example 6-4](#EX6-4).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端连接，客户端需要按照与服务器类似的步骤进行修改。我们可以修改我们的 Go 客户端代码，如[示例 6-4](#EX6-4)所示。
- en: Example 6-4\. gRPC secured client application in Go
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 在 Go 中的 gRPC 安全客户端应用程序
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO4-1)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO4-1)'
- en: Create X.509 key pairs directly from the server certificate and key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 直接从服务器证书和密钥创建 X.509 密钥对。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO4-2)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO4-2)'
- en: Create a certificate pool from the CA.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CA 创建证书池。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO4-3)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO4-3)'
- en: Append the client certificates from the CA to the certificate pool.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将来自 CA 的客户端证书附加到证书池。
- en: '[![4](assets/4.png)](#co_secured_grpc_CO4-4)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secured_grpc_CO4-4)'
- en: Add transport credentials as connection options. Here the `ServerName` must
    be equal to the `Common Name` on the certificate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将传输凭据作为连接选项添加。这里的 `ServerName` 必须等于证书上的 `Common Name`。
- en: '[![5](assets/5.png)](#co_secured_grpc_CO4-5)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secured_grpc_CO4-5)'
- en: Set up a secure connection with the server, passing options.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递选项与服务器建立安全连接。
- en: '[![6](assets/6.png)](#co_secured_grpc_CO4-7)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_secured_grpc_CO4-7)'
- en: Pass the connection and create a stub. This stub instance contains all the remote
    methods to invoke the server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将连接传递并创建一个存根。该存根实例包含调用服务器的所有远程方法。
- en: '[![7](assets/7.png)](#co_secured_grpc_CO4-6)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_secured_grpc_CO4-6)'
- en: Close the connection when everything is done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切完成后关闭连接。
- en: Now we have secured the communication channel between the client and server
    of the gRPC application using both basic one-way TLS and mTLS. The next step is
    to enable authentication on a per-call basis, which means credentials are attached
    to the call. Each client call has authentication credentials and the server side
    checks the credentials of the call and makes a decision whether to allow the client
    to call or deny.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用基本的单向 TLS 和 mTLS 保护了 gRPC 应用程序的客户端和服务器之间的通信通道。下一步是在每个调用的基础上启用身份验证，这意味着凭据将附加到调用中。每个客户端调用都有身份验证凭据，服务器端检查调用的凭据，并决定是否允许客户端调用或拒绝。
- en: Authenticating gRPC Calls
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证 gRPC 调用
- en: gRPC is designed to use serious authentication mechanisms. In the previous section,
    we covered how to encrypt data exchanged between the client and server using TLS.
    Now, we’re going to talk about how to verify the identity of the caller and apply
    access control using different call credential techniques like token-based authentication,
    etc.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 设计用于使用严格的身份验证机制。在前一节中，我们介绍了如何使用 TLS 加密客户端和服务器之间交换的数据。现在，我们将讨论如何验证调用者的身份，并使用不同的调用凭据技术（如基于令牌的身份验证等）应用访问控制。
- en: In order to facilitate verification of the caller, gRPC provides the capability
    for the client to inject his or her credentials (like username and password) on
    every call. The gRPC server has the ability to intercept a request from the client
    and check these credentials for every incoming call.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便验证调用者，gRPC 提供了客户端在每个调用中注入其凭据（如用户名和密码）的能力。gRPC 服务器能够拦截来自客户端的请求，并为每个传入的调用检查这些凭据。
- en: First, we will review a simple authentication scenario to explain how authentication
    works per client call.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾一个简单的身份验证场景，以解释每个客户端调用如何工作的身份验证。
- en: Using Basic Authentication
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本身份验证
- en: '*Basic authentication* is the simplest authentication mechanism. In this mechanism,
    the client sends requests with the `Authorization` header with a value that starts
    with the word `Basic` followed by a space and a base64-encoded string `username:password`.
    For example, if the username is `admin` and the password is `admin`, the header
    value looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*基本身份验证* 是最简单的身份验证机制。在这种机制中，客户端发送带有 `Authorization` 头的请求，该头的值以单词 `Basic` 开头，后跟一个空格和一个
    base64 编码的字符串 `username:password`。例如，如果用户名是 `admin`，密码是 `admin`，则头的值如下所示：'
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In general, gRPC doesn’t encourage us to use a username/password for authenticating
    to services. This is because a username/password doesn’t have control in time
    as opposed to other tokens (JSON Web Tokens [JWTs], OAuth2 access tokens). This
    means when we generate a token, we can specify how long it is valid. But for a
    username/password, we cannot specify a validity period. It is valid until we change
    the password. If you need to enable basic authentication in your application,
    it’s advised that you share basic credentials in a secure connection between client
    and server. We pick basic authentication because it is easier to explain how authentication
    works in gRPC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，gRPC 不鼓励我们使用用户名/密码来验证服务。这是因为与其他令牌（JSON Web Tokens [JWTs]、OAuth2 访问令牌）相比，用户名/密码在时间上没有控制。这意味着当我们生成一个令牌时，我们可以指定其有效期。但是对于用户名/密码，我们无法指定有效期。它的有效性会一直持续，直到我们修改密码。如果您需要在应用程序中启用基本身份验证，建议在客户端和服务器之间的安全连接中共享基本凭据。我们选择基本身份验证是因为这样更容易解释
    gRPC 中身份验证的工作原理。
- en: Let’s first discuss how to inject user credentials (in basic authentication)
    into the call. Since there is no built-in support for basic authentication in
    gRPC, we need to add it as custom credentials to the client context. In Go, we
    can easily do this by defining a credential struct and implementing the `PerRPCCredentials`
    interface as shown in [Example 6-5](#EX6-5).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论如何将用户凭据（在基本身份验证中）注入到调用中。由于 gRPC 中没有基本身份验证的内置支持，我们需要将其作为自定义凭据添加到客户端上下文中。在
    Go 中，我们可以通过定义一个凭据结构体并实现 `PerRPCCredentials` 接口来轻松实现此操作，如 [示例 6-5](#EX6-5) 所示。
- en: Example 6-5\. Implement PerRPCCredentials interface to pass custom credentials
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5. 实现 PerRPCCredentials 接口以传递自定义凭据
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO5-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO5-1)'
- en: Define a struct to hold the collection on fields you want to inject in your
    RPC calls (in our case, it is user credentials like username and password).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个结构体来保存您想要在 RPC 调用中注入的字段集合（在我们的情况下，这些是像用户名和密码这样的用户凭据）。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO5-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO5-2)'
- en: Implement the `GetRequestMetadata` method and convert user credentials to request
    metadata. In our case, “Authorization” is the key and the value is “Basic” followed
    by base64 (<username>:<password>).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`GetRequestMetadata`方法并将用户凭据转换为请求元数据。在我们的情况下，“Authorization”是键，其值是“Basic”后跟base64编码（<用户名>:<密码>）。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO5-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO5-3)'
- en: Specify whether channel security is required to pass these credentials. As mentioned
    earlier, it is advisable to use channel security.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 指定是否需要通过这些凭据传递通道安全性。如前所述，建议使用通道安全性。
- en: Once we implement a credentials object, we need to initiate it with valid credentials
    and pass it when creating the connection as shown in [Example 6-6](#EX6-6).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了凭据对象，我们需要使用有效的凭据初始化它，并在创建连接时传递，如[示例 6-6](#EX6-6)所示。
- en: Example 6-6\. gRPC secured client application with basic authentication
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 带有基本身份验证的gRPC安全客户端应用程序
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO6-1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO6-1)'
- en: Initialize the `auth` variable with valid user credentials (username and password).
    The `auth` variable holds the values we are going to use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有效的用户凭据（用户名和密码）初始化`auth`变量。`auth`变量保存我们将要使用的值。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO6-2)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO6-2)'
- en: Pass the `auth` variable to the `grpc.WithPerRPCCredentials` function. The `grpc.WithPerRPCCredentials()`
    function takes an interface as a parameter. Since we define our authentication
    structure to comply with the interface, we can pass our variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将`auth`变量传递给`grpc.WithPerRPCCredentials`函数。`grpc.WithPerRPCCredentials()`函数接受一个接口作为参数。由于我们定义了符合该接口的认证结构，我们可以传递我们的变量。
- en: Now the client is pushing extra metadata during its calls to the server, but
    the server does not care. So we need to tell the server to check metadata. Let’s
    update our server to read the metadata as shown in [Example 6-7](#EX6-7).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端在其调用期间推送额外的元数据，但服务器不关心。因此，我们需要告诉服务器检查元数据。让我们更新我们的服务器以读取如[示例 6-7](#EX6-7)所示的元数据。
- en: Example 6-7\. gRPC secured server with basic user credential validation
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 使用基本用户凭据验证的gRPC安全服务器
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO7-1)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO7-1)'
- en: Add a new server option (`grpc.ServerOption`) with the TLS server certificate.
    `grpc.UnaryInterceptor` is a function where we add an interceptor to intercept
    all requests from the client. We pass a reference to a function (`ensureValidBasicCredentials`)
    so the interceptor passes all client requests to that function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TLS服务器证书初始化新的服务器选项（`grpc.ServerOption`）。`grpc.UnaryInterceptor`是一个函数，我们在其中添加拦截器以拦截来自客户端的所有请求。我们将引用传递给一个函数（`ensureValidBasicCredentials`），因此拦截器将所有客户端请求传递给该函数。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO7-2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO7-2)'
- en: Define a function called `ensureValidBasicCredentials` to validate caller identity.
    Here, the `context.Context` object contains the metadata we need and that will
    exist during the lifetime of the request.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`ensureValidBasicCredentials`的函数来验证调用者身份。在这里，`context.Context`对象包含我们需要的元数据，并且在请求的生命周期内将存在。
- en: '[![3](assets/3.png)](#co_secured_grpc_CO7-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secured_grpc_CO7-3)'
- en: Extract the metadata from the context, get the value of the `authentication`,
    and validate the credentials. The keys within `metadata.MD` are normalized to
    lowercase. So we need to check the value for the lowercase key.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从上下文中提取元数据，获取`authentication`的值，并验证凭据。`metadata.MD`中的键被规范化为小写。因此，我们需要检查小写键的值。
- en: Now the server is validating client identity in each call. This is a very simple
    example. You can have complex authentication logic inside the server interceptor
    to validate client identity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器在每次调用中验证客户端身份。这是一个非常简单的例子。您可以在服务器拦截器内部具有复杂的认证逻辑来验证客户端身份。
- en: Since you have a basic understanding of how client authentication works, per
    request, let’s talk about commonly used and recommended token-based authentication
    (OAuth 2.0).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经对客户端认证工作原理有基本了解，让我们来讨论常用和推荐的基于令牌的认证（OAuth 2.0）。
- en: Using OAuth 2.0
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0
- en: '[OAuth 2.0](https://oauth.net/2) is a framework for access delegation. It allows
    users to grant limited access to services on their behalf, rather than giving
    them total access like with a username and password. Here we are not going to
    discuss OAuth 2.0 in detail. It is helpful if you have some basic knowledge about
    how OAuth 2.0 works to enable it in your application.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[OAuth 2.0](https://oauth.net/2) 是一个访问委托框架。它允许用户代表他们授予对服务的有限访问权限，而不像使用用户名和密码那样给予他们总访问权限。在这里我们不打算详细讨论
    OAuth 2.0。如果您对 OAuth 2.0 的工作原理有一些基本的了解，则有助于在您的应用程序中启用它。'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the OAuth 2.0 flow, there are four main characters: the client, the authorization
    server, the resource server, and the resource owner. The *client* wants to access
    the resource in a resource server. To access the resource, the client needs to
    get a token (which is an arbitrary string) from the *authorization server*. This
    token must be of a proper length and should not be predictable. Once the client
    receives the token, the client can send a request to the *resource server* with
    the token. The resource server then talks to the corresponding authorization server
    and validates the token. If it is validated by this *resource owner*, the client
    can access the resource.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OAuth 2.0 流程中，有四个主要角色：客户端、授权服务器、资源服务器和资源所有者。*客户端*希望访问资源服务器中的资源。为了访问资源，客户端需要从*授权服务器*获取一个令牌（这是一个任意字符串）。这个令牌必须是适当长度的，并且不可预测。一旦客户端收到令牌，客户端可以使用这个令牌向*资源服务器*发送请求。资源服务器随后与相应的授权服务器交流并验证令牌。如果这个*资源所有者*验证通过，客户端就可以访问资源。
- en: gRPC has built-in support to enable OAuth 2.0 in a gRPC application. Let’s first
    discuss how to inject a token into the call. Since we don’t have an authorization
    server in our example, we are going to hardcode an arbitrary string for the token
    value. [Example 6-8](#EX6-8) illustrates how to add an OAuth token to a client
    request.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 具有内置支持，可以在 gRPC 应用程序中启用 OAuth 2.0。让我们首先讨论如何将令牌注入到调用中。由于我们的示例中没有授权服务器，我们将为令牌值硬编码一个任意的字符串。[示例 6-8](#EX6-8)展示了如何向客户端请求添加
    OAuth 令牌。
- en: Example 6-8\. gRPC secured client application with OAuth token in Go
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 在 Go 中使用 OAuth 令牌的 gRPC 安全客户端应用程序
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO8-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO8-1)'
- en: Set up the credentials for the connection. We need to provide an OAuth2 token
    value to create the credentials. Here we use a hardcoded string value for the
    token.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 设置连接的凭据。我们需要提供一个 OAuth2 令牌值来创建凭据。这里我们使用一个硬编码的字符串值作为令牌。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO8-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO8-2)'
- en: Configure gRPC dial options to apply a single OAuth token for all RPC calls
    on the same connection. If you want to apply an OAuth token per call, then you
    need to configure the gRPC call with `CallOption`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 gRPC 拨号选项，以在同一连接上的所有 RPC 调用中应用单个 OAuth 令牌。如果要每次调用应用一个 OAuth 令牌，则需要使用 `CallOption`
    配置 gRPC 调用。
- en: Note that we also enable channel security because OAuth requires the underlying
    transport to be secure. Inside gRPC, the provided token is prefixed with the token
    type and attached to the metadata with the key `authorization`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还启用了通道安全，因为 OAuth 要求底层传输是安全的。在 gRPC 内部，提供的令牌被前缀为令牌类型，并附加到具有键`authorization`的元数据中。
- en: In the server, we add a similar interceptor to check and validate the client
    token that comes with the request as shown in [Example 6-9](#EX6-9).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们添加了类似的拦截器来检查和验证客户端请求中带有的令牌，如[示例 6-9](#EX6-9)所示。
- en: Example 6-9\. gRPC secured server with OAuth user token validation
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 使用 OAuth 用户令牌验证的 gRPC 安全服务器
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO9-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO9-1)'
- en: Add the new server option (`grpc.ServerOption`) along with the TLS server certificate.
    With the `grpc.UnaryInterceptor` function, we add an interceptor to intercept
    all requests from the client.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的服务器选项（`grpc.ServerOption`）以及 TLS 服务器证书。通过 `grpc.UnaryInterceptor` 函数，我们添加一个拦截器来拦截来自客户端的所有请求。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO9-2)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO9-2)'
- en: Define a function called `ensureValidToken` to validate the token. If the token
    is missing or invalid, the interceptor blocks the execution and gives an error.
    Otherwise, the interceptor invokes the next handler passing the context and interface.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为`ensureValidToken`的函数来验证令牌。如果令牌丢失或无效，拦截器将阻止执行并返回错误。否则，拦截器调用下一个处理程序，传递上下文和接口。
- en: It is possible to configure token validation for all RPCs using an interceptor.
    A server may configure either a `grpc.UnaryInterceptor` or a `grpc.StreamInterceptor`
    depending on the service type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用拦截器为所有 RPC 配置令牌验证。服务器可以根据服务类型配置 `grpc.UnaryInterceptor` 或 `grpc.StreamInterceptor`。
- en: Similar to OAuth 2.0 authentication, gRPC also supports JSON Web Token (JWT)-based
    authentication. In the next section, we’ll discuss what changes we need to make
    to enable JWT-based authentication.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 OAuth 2.0 认证，gRPC 也支持基于 JSON Web Token（JWT）的认证。在接下来的章节中，我们将讨论如何进行配置以启用基于
    JWT 的认证。
- en: Using JWT
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JWT
- en: JWT defines a container to transport identity information between the client
    and server. A signed JWT can be used as a self-contained access token, which means
    the resource server doesn’t need to talk to the authentication server to validate
    the client token. It can validate the token by validating the signature. The client
    requests access from the authentication server, which verifies the client’s credentials,
    creates a JWT, and sends it to the client. The client application with JWT allows
    access to resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 定义了一个容器，用于在客户端和服务器之间传输身份信息。签名的 JWT 可以用作自包含的访问令牌，这意味着资源服务器无需与认证服务器交互来验证客户端令牌。它可以通过验证签名来验证令牌。客户端从认证服务器请求访问权限，认证服务器验证客户端凭据，创建一个
    JWT 并将其发送给客户端。带有 JWT 的客户端应用允许访问资源。
- en: gRPC has built-in support for JWT. If you have the JWT file from the authentication
    server, you need to pass that token file and create JWT credentials. The code
    snippet in [Example 6-10](#EX6-10) illustrates how to create JWT credentials from
    the JWT token file (*token.json*) and pass them as `DialOptions` in a Go client
    application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 对 JWT 有内置支持。如果您从认证服务器获取了 JWT 文件，则需要传递该令牌文件并创建 JWT 凭据。[示例 6-10](#EX6-10)
    中的代码片段演示了如何从 JWT 令牌文件（*token.json*）创建 JWT 凭据，并将其作为 `DialOptions` 传递给 Go 客户端应用程序。
- en: Example 6-10\. Setting up a connection using a JWT in a Go client application
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 在 Go 客户端应用程序中使用 JWT 设置连接
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO10-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO10-1)'
- en: Call `oauth.NewJWTAccessFromFile` to initialize a `credentials.PerRPCCredentials`.
    We need to provide a valid token file to create the credentials.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `oauth.NewJWTAccessFromFile` 来初始化 `credentials.PerRPCCredentials`。我们需要提供一个有效的令牌文件来创建凭据。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO10-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO10-2)'
- en: Configure a gRPC dial with `DialOption WithPerRPCCredentials` to apply a JWT
    token for all RPC calls on the same connection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DialOption WithPerRPCCredentials` 配置 gRPC 拨号，以在同一连接上为所有 RPC 调用应用 JWT 令牌。
- en: In addition to these authentication techniques, we can add any authentication
    mechanism by extending RPC credentials on the client side and adding a new interceptor
    on the server side. gRPC also provides special built-in support for calling gRPC
    services deployed in Google Cloud. in the next section, we’ll discuss how to call
    those services.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些认证技术外，我们还可以通过在客户端扩展 RPC 凭据并在服务器端添加新的拦截器来添加任何认证机制。gRPC 还为调用部署在 Google Cloud
    中的 gRPC 服务提供了特殊的内置支持。在接下来的章节中，我们将讨论如何调用这些服务。
- en: Using Google Token-Based Authentication
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Google 基于令牌的认证
- en: Identifying the users and deciding whether to let them use the services deployed
    on the Google Cloud Platform is controlled by the Extensible Service Proxy (ESP).
    ESP supports multiple authentication methods, including Firebase, Auth0, and Google
    ID tokens. In each case, the client needs to provide a valid JWT in their requests.
    In order to generate authenticating JWTs, we must create a service account for
    each deployed service.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户身份验证以及决定是否允许他们使用部署在 Google 云平台上的服务是由可扩展服务代理（ESP）控制的。ESP 支持多种认证方法，包括 Firebase、Auth0
    和 Google ID 令牌。在每种情况下，客户端需要在其请求中提供有效的 JWT。为了生成认证 JWT，我们必须为每个部署的服务创建一个服务账号。
- en: Once we have the JWT token for the service, we can call the service method by
    sending the token along with the request. We can create the channel passing the
    credentials as shown in [Example 6-11](#EX6-11).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了服务的 JWT 令牌，我们可以在请求中发送令牌来调用服务方法。我们可以创建通道并传递凭据，如 [示例 6-11](#EX6-11) 所示。
- en: Example 6-11\. Setting up a connection with a Google endpoint in a Go client
    application
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 在 Go 客户端应用程序中设置与 Google 终端点的连接
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_secured_grpc_CO11-1)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secured_grpc_CO11-1)'
- en: Call `oauth.NewServiceAccountFromFile` to initialize `credentials.PerRPCCredentials`.
    We need to provide a valid token file to create the credentials.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `oauth.NewServiceAccountFromFile` 来初始化 `credentials.PerRPCCredentials`。我们需要提供一个有效的令牌文件来创建凭证。
- en: '[![2](assets/2.png)](#co_secured_grpc_CO11-2)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secured_grpc_CO11-2)'
- en: Similar to authentication mechanisms discussed earlier, we configure a gRPC
    dial with `DialOption WithPerRPCCredentials` to apply the authentication token
    as metadata for all RPC calls on the same connection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的认证机制类似，我们配置了一个 gRPC 连接的 `DialOption WithPerRPCCredentials`，以便将认证令牌作为元数据应用于同一连接上的所有
    RPC 调用。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When building a production-ready gRPC application, it is essential to have at
    least minimum security requirements for the gRPC application to ensure secure
    communication between the client and server. The gRPC library is designed to work
    with different kinds of authentication mechanisms and capable of extending support
    by adding a custom authentication mechanism. This makes it easy to safely use
    gRPC to talk to other systems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个生产就绪的 gRPC 应用程序时，至少需要满足 gRPC 应用程序的最低安全要求，以确保客户端和服务器之间的安全通信。gRPC 库设计用于与不同类型的认证机制一起工作，并能够通过添加自定义认证机制来扩展支持。这使得安全地使用
    gRPC 与其他系统进行通信变得简单。
- en: There are two types of credential supports in gRPC, channel and call. Channel
    credentials are attached to the channels such as TLS, etc. Call credentials are
    attached to the call, such as OAuth 2.0 tokens, basic authentication, etc. We
    even can apply both credential types to the gRPC application. For example, we
    can have TLS enable the connection between client and server and also attach credentials
    to each RPC call made on the connection.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 支持两种类型的凭证：通道凭证和调用凭证。通道凭证附加到通道上，如 TLS 等。调用凭证附加到调用上，如 OAuth 2.0 令牌、基本认证等。我们甚至可以将这两种凭证类型应用到
    gRPC 应用程序中。例如，我们可以启用 TLS 连接客户端和服务器之间的连接，并且还可以将凭证附加到在该连接上进行的每个 RPC 调用。
- en: In this chapter, you learned how to enable both credential types to your gRPC
    application. In the next chapter, we’ll expand on the concepts and technologies
    you’ve learned to build and run real-world gRPC applications in production. We’ll
    also discuss how to write test cases for service and client applications, how
    to deploy an application on Docker and Kubernetes, and how to observe the system
    when it runs in production.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何为您的 gRPC 应用程序启用这两种凭证类型。在下一章中，我们将扩展您学到的概念和技术，以便在生产环境中构建和运行真实的 gRPC
    应用程序。我们还将讨论如何为服务和客户端应用程序编写测试用例，如何在 Docker 和 Kubernetes 上部署应用程序，以及在生产环境中运行时如何观察系统。
