<html><head></head><body><section data-pdf-bookmark="Chapter 10. Optimization Examples" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch-opt">&#13;
<h1><span class="label">Chapter 10. </span>Optimization Examples</h1>&#13;
&#13;
&#13;
<p><a data-primary="optimization examples" data-type="indexterm" id="ix_ch10-asciidoc0"/>It’s finally time to collect all the tools, skills, and knowledge you gathered from the previous chapters and apply some optimizations! In this chapter, we will try to reinforce the pragmatic optimization flow by going through some examples.</p>&#13;
&#13;
<p>We will attempt to optimize the naive implementation of the <code>Sum</code> from <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>. I will show you how the TFBO (from <a data-type="xref" href="ch03.html#ch-conq-eff-flow">“Efficiency-Aware Development Flow”</a>) can be applied to three different sets of efficiency requirements.<a data-primary="Adamczewski, Bartosz, on optimizations/pessimizations" data-type="indexterm" id="idm45606823784576"/></p>&#13;
<blockquote>&#13;
<p>Optimizations/pessimizations don’t generalize very well. It all depends on the code, so measure each time and don’t cast absolute judgments.</p>&#13;
<p data-type="attribution">Bartosz Adamczewski, <a href="https://oreil.ly/oW3ND">Tweet</a> (2022)</p></blockquote>&#13;
&#13;
<p>We will use our optimization stories as a foundation for some optimization patterns summarized in the next chapter. Learning about thousands of optimization cases that happened in the past is not very useful. Every case is different. The compiler and language change, so any “brute-force” attempt to try those thousands of optimizations one by one is not pragmatic.<sup><a data-type="noteref" href="ch10.html#idm45606823780656" id="idm45606823780656-marker">1</a></sup> Instead, I have focused on equipping you with the knowledge, tools, and practices that will let you find a more efficient solution to your problem!</p>&#13;
<div data-type="tip">&#13;
<p>Please don’t focus on particular optimizations, e.g., the specific algorithmic or code changes I applied. Instead, try to follow how I came up with those changes, how I found what piece of code to optimize first, and how I assessed the change.</p>&#13;
</div>&#13;
&#13;
<p>We will start in <a data-type="xref" data-xrefstyle="select:nopage" href="#ch-opt-sum">“Sum Examples”</a> by introducing the three problems. Then we will take the <code>Sum</code> and perform the optimizations in <a data-type="xref" href="#ch-opt-latency-example">“Optimizing Latency”</a>, <a data-type="xref" href="#ch-opt-mem-example">“Optimizing Memory Usage”</a>, and <a data-type="xref" href="#ch-opt-latency-concurrency-example">“Optimizing Latency Using Concurrency”</a>. Finally, we will mention some other ways we could solve our &#13;
<span class="keep-together">goals in</span> <a data-type="xref" href="#ch-opt-bonus">“Bonus: Thinking Out of the Box”</a>. Let’s go!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sum Examples" data-type="sect1"><div class="sect1" id="ch-opt-sum">&#13;
<h1>Sum Examples</h1>&#13;
&#13;
<p><a data-primary="optimization examples" data-secondary="Sum examples" data-type="indexterm" id="ix_ch10-asciidoc1"/>In <a data-type="xref" href="ch04.html#ch-hardware">Chapter 4</a>, we introduced a simple <code>Sum</code> implementation in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> that sums large numbers of integers provided in a file.<sup><a data-type="noteref" href="ch10.html#idm45606823764528" id="idm45606823764528-marker">2</a></sup> Let’s leverage all the learning you have gained and use it to optimize <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>. As we learned in <a data-type="xref" href="ch03.html#ch-conq-req">“Resource-Aware Efficiency Requirements”</a>, we can’t “just” optimize—we have to have some goal in mind. In this section, we will repeat the efficiency optimization flow three times, each time with different requirements:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Lower latency with a maximum of one CPU used</p>&#13;
</li>&#13;
<li>&#13;
<p>Minimal amount of memory</p>&#13;
</li>&#13;
<li>&#13;
<p>Even lower latency with four CPU cores available for the workload</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The terms <em>lower</em> or <em>minimal</em> are not very professional. Ideally, we have some more specific numbers to aim for, in a written form like a RAER. A quick Big O analysis can tell us that the <code>Sum</code> runtime complexity is at least O(<em>N</em>)—we have to revisit all lines at least once to compute the sum. Thus, the absolute latency goal, like “<code>Sum</code> has to be faster than 100 milliseconds,” won’t work as its problem space depends on the input. We can always find big enough input that violates any latency goals.</p>&#13;
&#13;
<p>One way to address this is to specify the maximum possible input with some assumptions and latency goals. The second is to define the required runtime complexity as a function that depends on input—so throughput. Let’s do the latter and specify the amortized latency function for the <code>Sum</code>. We can do the same with memory. So let’s be more specific. Imagine that, for my hardware, a system design stakeholder came up with the following required goals for the <code>Sum</code> in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Maximum latency of 10 nanoseconds per line (10 * <em>N</em> nanoseconds) with maximum one CPU used</p>&#13;
</li>&#13;
<li>&#13;
<p>Latency as above and a maximum of 10 KB of memory allocated on the heap for any input</p>&#13;
</li>&#13;
<li>&#13;
<p>Maximum latency of 2.5 nanoseconds per line (2.5 * <em>N</em> nanoseconds) with maximum four CPU used</p>&#13;
</li>&#13;
</ul>&#13;
<div class="tip4" data-type="tip"><h1>What If We Can’t Match This Goal?</h1>&#13;
<p>It might be the case that the goals we initially aimed for will be hard to achieve due to underestimation of the problem, new requirements, or new knowledge. This is fine. In many cases, we can try to renegotiate the goals. For example, as we dissected in <a data-type="xref" href="ch03.html#ch-conq-opt-levels">“Optimization Design Levels”</a>, every optimization beyond a certain point costs more and more in time, effort, risk, and readability, so it might be cheaper to add more machines, CPUs, or RAM to the problem. The key is to estimate those costs roughly and help stakeholders decide what’s best for them.</p>&#13;
</div>&#13;
&#13;
<p>Following the TFBO flow, before we optimize, we first have to benchmark. Fortunately, we already discussed designs of benchmarks for the <code>Sum</code> code in <a data-type="xref" href="ch08.html#ch-obs-micro-go">“Go Benchmarks”</a>, so we can go ahead and use <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> for our benchmarks. I used the command presented in <a data-type="xref" href="#code-sum-bench-cmd">Example 10-1</a> to perform 5 10-second benchmarks with a 2 million integer input file and limited to 1 CPU.</p>&#13;
<div data-type="example" id="code-sum-bench-cmd">&#13;
<h5><span class="label">Example 10-1. </span>The command to invoke the benchmark</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nb">export</code> <code class="nv">ver</code><code class="o">=</code>v1 <code class="o">&amp;&amp;</code> go <code class="nb">test</code> -run <code class="s1">'^$'</code> -bench <code class="s1">'^BenchmarkSum$'</code> <code class="se">\</code>&#13;
    -benchtime 10s -count <code class="m">5</code> -cpu <code class="m">1</code> -benchmem <code class="se">\</code>&#13;
    -cpuprofile<code class="o">=</code><code class="si">${</code><code class="nv">ver</code><code class="si">}</code>.cpu.pprof -memprofile<code class="o">=</code><code class="si">${</code><code class="nv">ver</code><code class="si">}</code>.mem.pprof <code class="p">|</code> tee <code class="si">${</code><code class="nv">ver</code><code class="si">}</code>.txt</pre></div>&#13;
&#13;
<p>With <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>, the preceding benchmark yielded the following results: 101 ms, 60.8 MB space allocated, and 1.60 million allocations per operation. Therefore, we will use that as our baseline.<a data-startref="ix_ch10-asciidoc1" data-type="indexterm" id="idm45606823698752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing Latency" data-type="sect1"><div class="sect1" id="ch-opt-latency-example">&#13;
<h1>Optimizing Latency</h1>&#13;
&#13;
<p><a data-primary="latency" data-secondary="optimization" data-type="indexterm" id="ix_ch10-asciidoc2"/><a data-primary="optimization examples" data-secondary="latency optimization" data-type="indexterm" id="ix_ch10-asciidoc3"/>Our requirements are clear. We need to make the <code>Sum</code> function in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> faster to achieve a throughput of at least 10 * <em>N</em> nanoseconds. The baseline results give us &#13;
<span class="keep-together">50 * <em>N</em></span> nanoseconds. Time to see if there are any quick optimizations!</p>&#13;
<div class="less_space pagebreak-before" data-type="note" epub:type="note">&#13;
<p>In <a data-type="xref" href="ch07.html#ch-hw-complexity">“Complexity Analysis”</a>, I shared a detailed complexity of the <code>Sum</code> function that clearly outlines the problems and &#13;
<span class="keep-together">bottlenecks.</span> However, I used information from this section to define that. For now, let’s forget that we discussed such complexity and try to find all the information from scratch.</p>&#13;
</div>&#13;
&#13;
<p>The best way is to perform a bottleneck analysis using the profiles explained in <a data-type="xref" href="ch09.html#ch-observability3">Chapter 9</a>. I captured the CPU profile on every benchmark with <a data-type="xref" href="ch08.html#code-sum-go-bench-all">Example 8-4</a>, so I could quickly bring the Flame Graph of the CPU time, as presented in <a data-type="xref" href="#img-opt-lat-v1">Figure 10-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-v1">&#13;
<img alt="efgo 1001" src="assets/efgo_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Flame Graph view of <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>Profiling gives us a great overview of the situation. We see four clear major contributors to the CPU time usage:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>bytes.Split</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>strconv.ParseInt</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Runtime function <code>runtime.slicebytetostr...</code>, which ends with <code>runtime.malloc</code>, meaning we spent a lot of CPU time allocating memory</p>&#13;
</li>&#13;
<li>&#13;
<p>Runtime function <code>runtime.gcBgMarkWorker</code>, which indicates GC runs</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p class="less_space pagebreak-before">The CPU profile gives us a list of functions we can go through and potentially cut out some CPU usage. However, as we learned in <a data-type="xref" href="ch09.html#ch-obs-pprof-latency">“Off-CPU Time”</a>, the CPU time might not be a bottleneck here. Therefore, we must first confirm if our function here is CPU bound, I/O bound, or mixed.</p>&#13;
&#13;
<p>One way of doing this is by manually reading the source code. We can see that the only external medium used in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> is a file, which we use to read bytes from. The rest of the code should only perform computations using the memory and CPU.</p>&#13;
&#13;
<p>This makes this code a mixed-bound job, but how mixed? Should we start with file reads optimization or CPU time?</p>&#13;
&#13;
<p>The best way to find this out is the data-driven way. Let’s check both CPU and off-CPU latency thanks to the full goroutine profile (<code>fgprof</code>) discussed in <a data-type="xref" href="ch09.html#ch-obs-pprof-latency">“Off-CPU Time”</a>. To collect it in the Go benchmark, I quickly wrapped our benchmark from <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> with the <code>fgprof</code> profile in <a data-type="xref" href="#code-sum-go-bench-fgprof">Example 10-2</a>.</p>&#13;
<div data-type="example" id="code-sum-go-bench-fgprof">&#13;
<h5><span class="label">Example 10-2. </span>Go benchmark with <code>fgprof</code> profiling</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// BenchmarkSum_fgprof recommended run options:</code><code class="w">&#13;
</code><code class="c1">// $ export ver=v1fg &amp;&amp; go test -run '^$' -bench '^BenchmarkSum_fgprof' \</code><code class="w">&#13;
</code><code class="c1">//    -benchtime 60s  -cpu 1 | tee ${ver}.txt </code><a class="co" href="#callout_optimization_examples_CO1-1" id="co_optimization_examples_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">BenchmarkSum_fgprof</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">testing</code><code class="p">.</code><code class="nx">B</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Create</code><code class="p">(</code><code class="s">"fgprof.pprof"</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">testutil</code><code class="p">.</code><code class="nx">Ok</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">testutil</code><code class="p">.</code><code class="nx">Ok</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><code class="p">}</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">closeFn</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fgprof</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">fgprof</code><code class="p">.</code><code class="nx">FormatPprof</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">BenchmarkSum</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO1-2" id="co_optimization_examples_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
    </code><code class="nx">testutil</code><code class="p">.</code><code class="nx">Ok</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">closeFn</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO1-1" id="callout_optimization_examples_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>To get more reliable results, we have to measure for longer than five seconds. Let’s measure for 60 seconds to be sure.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO1-2" id="callout_optimization_examples_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>To reuse code and have better reliability, we can execute the same <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> benchmark, just wrapped with the <code>fgprof</code> profile.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The resulting <code>fgprof.pprof</code> profile after 60 seconds is presented in <a data-type="xref" href="#img-opt-lat-v1-fgprof">Figure 10-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-v1-fgprof">&#13;
<img alt="efgo 1002" src="assets/efgo_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Flame Graph view of <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> CPU and off-CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>The full goroutine profile confirms that our workload is a mix of I/O (5%<sup><a data-type="noteref" href="ch10.html#idm45606823492960" id="idm45606823492960-marker">3</a></sup>) and CPU time (majority). So while we have to worry about latency introduced by file I/O at some point, we can optimize CPU time first. So let’s go ahead and focus on the biggest bottleneck first: the <code>bytes.Split</code> function that takes almost 36% of the <code>Sum</code> CPU time, as seen in <a data-type="xref" href="#img-opt-lat-v1">Figure 10-1</a>.</p>&#13;
<div data-type="tip"><h1>Optimize One Thing at a Time</h1>&#13;
<p>Thanks to <a data-type="xref" href="#img-opt-lat-v1">Figure 10-1</a>, we found four main bottlenecks. However, I have chosen to focus on the biggest one in our first optimization in <a data-type="xref" href="#code-sum2">Example 10-3</a>.</p>&#13;
&#13;
<p>It is important to iterate one optimization at a time. It feels slower than if we would try to optimize all we know about now, but in practice, it is more effective. Each optimization might affect the other and introduce more unknowns. We can draw more reliable conclusions, e.g., compare the contributions percentage between profiles. Furthermore, why eliminate four bottlenecks if optimizing first might be enough to match our requirements?</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing bytes.Split" data-type="sect2"><div class="sect2" id="ch-opt-latency-example-split">&#13;
<h2>Optimizing bytes.Split</h2>&#13;
&#13;
<p><a data-primary="bytes.Split, optimizing" data-type="indexterm" id="ix_ch10-asciidoc4"/><a data-primary="latency" data-secondary="optimizing bytes.Split" data-type="indexterm" id="ix_ch10-asciidoc5"/><a data-primary="optimization examples" data-secondary="optimizing bytes.Split" data-type="indexterm" id="ix_ch10-asciidoc6"/>To figure out where the CPU time is spent in <code>bytes.Split</code>, we have to try to understand what this function does and how. By <a href="https://oreil.ly/UqAg8">definition</a>, it splits a large byte slice into smaller slices based on the potentially multicharacter separator <code>sep</code>. Let’s quickly look at the <a data-type="xref" href="#img-opt-lat-v1">Figure 10-1</a> profile and focus on that function using the <code>Refine</code> options. This would show <a href="https://oreil.ly/DQrCS"><code>bytes.Index</code></a>, and &#13;
<span class="keep-together">impact allocations</span> and garbage collections with functions like <code>makeslice</code> and &#13;
<span class="keep-together"><code>runtime.gcWriteBarrierDX</code>.</span> Furthermore, we could quickly look into the Go source code for the <a href="https://oreil.ly/pCMH1"><code>genSplit</code></a> used by <code>bytes.Split</code> to check how it’s implemented. This should give us a few warning signals. There might be things that <code>bytes.Split</code> does but might not be necessary for our case:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>genSplit</code> goes through the slices first <a href="https://oreil.ly/Wq6F4">to count how many slices we expect</a> to have.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>genSplit</code> allocates <a href="https://oreil.ly/YzXdr">a two-dimensional byte slice</a> to put the results in. This is scary because for a large 7.2 MB byte slice with 2 million lines, it will allocate a slice with 2 million elements. A memory profile confirms that a lot of memory is allocated by this line.<sup><a data-type="noteref" href="ch10.html#idm45606823466592" id="idm45606823466592-marker">4</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>Then it will iterate two million times using the <a href="https://oreil.ly/8diMw"><code>bytes.Index</code></a> function we saw in the profile. That is two million times we will go and gather bytes until the next separator.</p>&#13;
</li>&#13;
<li>&#13;
<p>The separator in <code>bytes.Split</code> is a multicharacter, which requires a more complicated algorithm. Yet we need a simple, single-line newline separator.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Unfortunately, such an analysis of the mature standard library functions might be difficult for more beginner Go developers. What parts of this CPU time or memory usage are excessive, and what aren’t?</p>&#13;
&#13;
<p>What always helps me to answer this question is to go back to the algorithm design phase and try to design my own simplest splitting-lines algorithm tailored for the <code>Sum</code> problem. When we understand what a simple, efficient algorithm could look like and we are happy with it, we can then start challenging existing implementations. It turns out there is a very simple flow that might work for <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>. Let’s go through it in <a data-type="xref" href="#code-sum2">Example 10-3</a>.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="code-sum2">&#13;
<h5><span class="label">Example 10-3. </span><code>Sum2</code> is <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> with optimized CPU bottleneck of <code>bytes.Split</code></h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">Sum2</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO2-1" id="co_optimization_examples_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO2-2" id="co_optimization_examples_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
            </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseInt</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO2-1" id="callout_optimization_examples_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We record the index of the last seen newline, plus one, to tell where the next line starts.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO2-2" id="callout_optimization_examples_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Compared to <code>bytes.Split</code>, we can hardcode a new line as our separator. In one loop iteration, while reusing the <code>b</code> byte slice, we can find the full line, parse the integer, and perform the sum. This algorithm is also often called “in place.”</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Before we come to any conclusion, we have to first check if our new algorithm works functionally. After successfully verifying it using the unit test, I ran <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> with the <code>Sum2</code> function instead of <code>Sum</code> to assess its efficiency. The results are optimistic, with 50 ms and 12.8 MB worth of allocations. Compared to <code>bytes.Split</code>, we could perform 50% less work while using 78% less memory. Knowing that <code>bytes.Split</code> was responsible for ~36% of CPU time and 78.6% of memory allocations, such an improvement tells us we completely removed this bottleneck from our code!</p>&#13;
<div data-type="note" epub:type="note"><h1>Standard Functions Might Not Be Perfect for All Cases</h1>&#13;
<p>The preceding example of working optimization asks why the <code>bytes.Split</code> function wasn’t optimal for us. Can’t the Go community optimize it?</p>&#13;
&#13;
<p>The answer is that <code>bytes.Split</code> and other standard or custom functions you might import on the internet could be not as efficient as the tailored algorithm for your requirements. Such a popular function has to be, first of all, reliable for many edge cases that you might not have (e.g., multicharacter separator). Those are often optimized for cases that might be more involved and complex than our own.</p>&#13;
&#13;
<p>It doesn’t mean we have to rewrite all imported functions now. No, we should just be aware of the possibility of easy efficiency gains by providing a tailored implementation for critical paths. Still, we should use known and battle-tested code like a standard library. In most cases, it’s good enough!</p>&#13;
</div>&#13;
&#13;
<p>Is our <a data-type="xref" href="#code-sum2">Example 10-3</a> optimization our final one? Not quite—while we improved the throughput, we are at the 25 * <em>N</em> nanoseconds mark, still far from our goal.<a data-startref="ix_ch10-asciidoc6" data-type="indexterm" id="idm45606823204224"/><a data-startref="ix_ch10-asciidoc5" data-type="indexterm" id="idm45606823203616"/><a data-startref="ix_ch10-asciidoc4" data-type="indexterm" id="idm45606823203008"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing runtime.slicebytetostring" data-type="sect2"><div class="sect2" id="ch-opt-latency-example-strcopy">&#13;
<h2>Optimizing runtime.slicebytetostring</h2>&#13;
&#13;
<p><a data-primary="latency" data-secondary="optimizing runtime.slicebytetostring" data-type="indexterm" id="ix_ch10-asciidoc7"/><a data-primary="optimization examples" data-secondary="optimizing runtime.slicebytetostring" data-type="indexterm" id="ix_ch10-asciidoc8"/><a data-primary="runtime.slicebytetostring" data-type="indexterm" id="ix_ch10-asciidoc9"/>The CPU profile from the <a data-type="xref" href="#code-sum2">Example 10-3</a> benchmark should give us a clue about the next bottleneck, shown in <a data-type="xref" href="#img-opt-lat-v2">Figure 10-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-v2">&#13;
<img alt="efgo 1003" src="assets/efgo_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Flame Graph view of <a data-type="xref" href="#code-sum2">Example 10-3</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>As the next bottleneck, let’s take this odd <code>runtime.slicebytetostring</code> function that spends most of its CPU time allocating memory. If we look for it in the Source or Peek view, it points us to the <code>num, err := strconv.ParseInt(string(b[last:i]), 10, 64)</code> line in <a data-type="xref" href="#code-sum2">Example 10-3</a>. Since this CPU time contribution is not accounted for to <code>strconv.ParseInt</code> (a separate segment), it tells us that it has to be executed before we invoke <code>strconv ParseInt</code>, yet in the same code line. The only dynamically executed things are the <code>b</code> byte slice subslicing and conversion to string. On further inspection, we can tell that the string conversion is expensive here.<sup><a data-type="noteref" href="ch10.html#idm45606823189696" id="idm45606823189696-marker">5</a></sup></p>&#13;
&#13;
<p>What’s interesting is that <a href="https://oreil.ly/7dv5w"><code>string</code></a> is essentially a special <a href="https://oreil.ly/fYwwq"><code>byte</code> slice</a> with no <code>Cap</code> field (capacity in <code>string</code> is always equal to length). As a result, at first it might be surprising that the Go compiler spends so much time and memory on this. The reason is that <code>string(&lt;byte slice&gt;)</code> is equivalent to creating a new byte slice with the same number of elements, copying all bytes to a new byte, and then returning the string from it. The main reason for copying is that, by design, <a href="https://oreil.ly/I4fER"><code>string</code> type is immutable</a>, so every function can use it without worrying about potential races. There is, however, a relatively safe way to convert <code>[]byte</code> to <code>string</code>. Let’s do that in <a data-type="xref" href="#code-sum3">Example 10-4</a>.</p>&#13;
<div data-type="example" id="code-sum3">&#13;
<h5><span class="label">Example 10-4. </span><code>Sum3</code> is <a data-type="xref" href="#code-sum2">Example 10-3</a> with optimized CPU bottleneck of string conversion</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// import "unsafe"</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">zeroCopyToString</code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="o">*</code><code class="p">(</code><code class="p">(</code><code class="o">*</code><code class="kt">string</code><code class="p">)</code><code class="p">(</code><code class="nx">unsafe</code><code class="p">.</code><code class="nx">Pointer</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">b</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO3-1" id="co_optimization_examples_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">Sum3</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">zeroCopyToString</code><code class="p">(</code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">]</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">64</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO3-1" id="callout_optimization_examples_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We can use the <code>unsafe</code> package to remove the type information from <code>b</code> and form an <code>unsafe.Pointer</code>. Then we can dynamically cast this to different types, e.g., <code>string</code>. It is unsafe because if the structures do not share the same layout, we might have memory safety problems or nondeterministic values. Yet the layout is shared between <code>[]byte</code> and <code>string</code>, so it’s safe for us. It is used in production in many projects, including Prometheus, known as <a href="https://oreil.ly/QmqCn"><code>yoloString</code></a>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The <code>zeroCopyToString</code> allows us to convert file bytes to string required by <code>ParseInt</code> with almost no overhead. After functional tests, we can confirm this by using the same benchmark with the <code>Sum3</code> function again. The benefit is clear—<code>Sum3</code> takes 25.5 ms for 2 million integers and 7.2 MB of allocated space. This means it is 49.2% faster than <a data-type="xref" href="#code-sum2">Example 10-3</a> when it comes to CPU time. The memory usage is also better, with our program allocating almost precisely the size of the input file—no more, no less.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Deliberate Trade-offs</h1>&#13;
<p>With unsafe, no-copy bytes to string conversion, we enter a deliberate optimization area. We introduced potentially unsafe code and added more nontrivial complexity to our code. While we clearly named our function <code>zeroCopyToString</code>, we have to justify and use such optimization only if necessary. In our case, it helps us reach our efficiency goals, so we can accept these drawbacks.</p>&#13;
</div>&#13;
&#13;
<p>Are we fast enough? Not yet. We are almost there with 12.7 * <em>N</em> nanoseconds throughput. Let’s see if we can optimize something more.<a data-startref="ix_ch10-asciidoc9" data-type="indexterm" id="idm45606823122576"/><a data-startref="ix_ch10-asciidoc8" data-type="indexterm" id="idm45606823121872"/><a data-startref="ix_ch10-asciidoc7" data-type="indexterm" id="idm45606823121200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing strconv.Parse" data-type="sect2"><div class="sect2" id="ch-opt-latency-example-parse">&#13;
<h2>Optimizing strconv.Parse</h2>&#13;
&#13;
<p><a data-primary="latency" data-secondary="optimizing strconv.Parse" data-type="indexterm" id="ix_ch10-asciidoc10"/><a data-primary="optimization examples" data-secondary="optimizing strconv.Parse" data-type="indexterm" id="ix_ch10-asciidoc11"/><a data-primary="strconv.Parse" data-type="indexterm" id="ix_ch10-asciidoc12"/>Again, let’s look at the newest CPU profile from the <a data-type="xref" href="#code-sum3">Example 10-4</a> benchmark to see the latest bottleneck we could try to check, as shown in <a data-type="xref" href="#img-opt-lat-v3">Figure 10-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-v3">&#13;
<img alt="efgo 1004" src="assets/efgo_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Flame Graph view of <a data-type="xref" href="#code-sum3">Example 10-4</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>With <code>strconv.Parse</code> using 72.6%, we can gain a lot if we can improve its CPU time. Similar to <code>bytes.Split</code>, we should check its profile and <a href="https://oreil.ly/owR53">implementation</a>. Following both paths, we can immediately outline a couple of elements that feel like excessive work:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We check for an empty string twice, in <a href="https://oreil.ly/gqJpb"><code>ParseInt</code></a> and &#13;
<span class="keep-together"><a href="https://oreil.ly/BB9Ie"><code>ParseUint</code></a>.</span> Both are visible as nontrivial CPU time used in our profile.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ParseInt</code> allows us to parse to integers with different bases and bit sizes. We don’t need this generic functionality or extra input to check our <code>Sum3</code> code. We only care about 64-bit integers of base 10.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>One solution here is similar to <code>bytes.Split</code>: finding or implementing our own &#13;
<span class="keep-together"><code>ParseInt</code></span> function that focuses on efficiency—does what we need and nothing more. The standard library offers the <a href="https://oreil.ly/CpZeF"><code>strconv.Atoi</code> function</a>, which looks promising. However, it still requires strings as input, which forces us to use unsafe package code. Instead, let’s try to come up with our own quick implementation. After a few iterations of testing and microbenchmarking my new <code>ParseInt</code> function,<sup><a data-type="noteref" href="ch10.html#idm45606822879264" id="idm45606822879264-marker">6</a></sup> we can come up with the fourth iteration of our sum functionality, presented in <a data-type="xref" href="#code-sum4">Example 10-5</a>.</p>&#13;
<div data-type="example" id="code-sum4">&#13;
<h5><span class="label">Example 10-5. </span><code>Sum4</code> is <a data-type="xref" href="#code-sum3">Example 10-4</a> with optimized CPU bottleneck of string conversion</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">input</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">n</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">factor</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">int64</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">k</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">input</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="sc">'-'</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">factor</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">k</code><code class="o">++</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">input</code><code class="p">)</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mi">1</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="nx">k</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">--</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">input</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="sc">'0'</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="nx">input</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="sc">'9'</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">           </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Newf</code><code class="p">(</code><code class="s">"not a valid integer: %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">input</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="nx">n</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">factor</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nb">int64</code><code class="p">(</code><code class="nx">input</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="o">-</code><code class="sc">'0'</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">factor</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">func</code><code class="w"> </code><code class="nx">Sum4</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">continue</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">])</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre></div>&#13;
&#13;
<p>The side effect of our integer parsing optimization is that we can tailor our <code>ParseInt</code> to parse from a byte slice, not a string. As a result, we can simplify our code and avoid unsafe <code>zeroCopyToString</code> conversion. After tests and benchmarks, we see that <code>Sum4</code> achieves 13.6 ms, 46.66% less than <a data-type="xref" href="#code-sum3">Example 10-4</a>, with the same memory allocations. The full comparison of our sum functions is presented in <a data-type="xref" href="#code-sum-go-bench-benchstat-v4">Example 10-6</a> using our beloved <code>benchstat</code> tool.</p>&#13;
<div data-type="example" id="code-sum-go-bench-benchstat-v4">&#13;
<h5><span class="label">Example 10-6. </span>Running <code>benchstat</code> on the results from all four iterations with a two million line file</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting"><code>$ benchstat v1.txt v2.txt v3.txt v4.txt&#13;
name \ (time/op)  v1.txt       v2.txt       v3.txt       v4.txt&#13;
Sum                101ms ± 0%    50ms ± 2%   25ms ± 0%   14ms ± 0% </code><a class="co" href="#callout_optimization_examples_CO4-1" id="co_optimization_examples_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
name \ (alloc/op) v1.txt       v2.txt       v3.txt       v4.txt&#13;
Sum               60.8MB ± 0%  12.8MB ± 0%  7.2MB ± 0%  7.2MB ± 0%&#13;
&#13;
name \ (allocs/op) v1.txt       v2.txt       v3.txt       v4.txt&#13;
Sum                1.60M ± 0%   1.60M ± 0%  0.00M ± 0%  0.00M ± 0%</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO4-1" id="callout_optimization_examples_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Notice that <code>benchstat</code> can round some numbers for easier comparison with the large number from <em>v1.txt</em>. The <em>v4.txt</em> result is 13.6 ms, not 14 ms, which can make a difference in throughput calculations.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>It seems like our hard work paid off. With the current results, we achieved 6.9 * <em>N</em> nanoseconds throughput, which is more than enough to fulfill our first goal. However, we only checked it with two million integers. Are we sure the same throughput can be maintained with larger or smaller input sizes? Our Big O runtime complexity O(<em>N</em>) would suggest so, but I ran the same benchmark with 10 million integers just in case. The 67.8 ms result gives the 6.78 * <em>N</em> nanoseconds throughput. This more or less confirms our throughput number.</p>&#13;
&#13;
<p>The code in <a data-type="xref" href="#code-sum4">Example 10-5</a> is not the fastest or most memory-efficient solution possible. There might be more optimizations to the algorithm or code to improve things further. For example, if we profile <a data-type="xref" href="#code-sum4">Example 10-5</a>, we would see a relatively new segment, indicating 14% of total CPU time used. It’s <code>os.ReadFile</code> code that wasn’t so visible on past profiles, given other bottlenecks and something we didn’t touch with our optimizations. We will mention its potential optimization in <a data-type="xref" href="ch11.html#ch-basic-prealloc">“Pre-Allocate If You Can”</a>. We could also try concurrency (which we will do in <a data-type="xref" href="#ch-opt-latency-concurrency-example">“Optimizing Latency Using Concurrency”</a>). However, with one CPU, we cannot expect a lot of gains here.</p>&#13;
&#13;
<p>What’s important is that there is no need to improve anything else in this iteration, as we achieved our goal. We can stop the work and claim success! Fortunately, we did not need to add magic or dangerous nonportable tricks to our optimization flow. Only readable and easier deliberate optimizations were required<a data-startref="ix_ch10-asciidoc12" data-type="indexterm" id="idm45606822375696"/><a data-startref="ix_ch10-asciidoc11" data-type="indexterm" id="idm45606822375088"/><a data-startref="ix_ch10-asciidoc10" data-type="indexterm" id="idm45606822374480"/>.<a data-startref="ix_ch10-asciidoc3" data-type="indexterm" id="idm45606822373744"/><a data-startref="ix_ch10-asciidoc2" data-type="indexterm" id="idm45606822373136"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing Memory Usage" data-type="sect1"><div class="sect1" id="ch-opt-mem-example">&#13;
<h1>Optimizing Memory Usage</h1>&#13;
&#13;
<p><a data-primary="memory resource" data-secondary="optimization examples" data-type="indexterm" id="ix_ch10-asciidoc13"/><a data-primary="optimization examples" data-secondary="optimizing memory usage" data-type="indexterm" id="ix_ch10-asciidoc14"/>In the second scenario, our goal is focused on memory consumption while maintaining the same throughput. Imagine we have a new business customer for our software with <code>Sum</code> functionality that needs to run on an IoT device with little RAM available for this program. As a result, the requirement is to have a streaming algorithm: no matter the input size, it can only use 10 KB of heap memory in a single moment.</p>&#13;
&#13;
<p>Such a requirement might look extreme at first glance, given the naive code in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> has a quite large space complexity. If a 10 million line, 36 MB file requires 304 MB of heap memory for <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>, how can we ensure the same file (or bigger!) can take a maximum of 10 KB of memory? Before we start to worry, let’s analyze what we can do on this subject.</p>&#13;
&#13;
<p>Fortunately, we already did some optimization work that improved memory allocations as a side effect. Since the latency goal still applies, let’s start with <code>Sum4</code> in <a data-type="xref" href="#code-sum4">Example 10-5</a>, which fulfills that. The space complexity of <code>Sum4</code> seems to be around O(<em>N</em>). It still depends on the input size and is far from our 10 KB goal.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving to Streaming Algorithm" data-type="sect2"><div class="sect2" id="ch-opt-mem-example-stream">&#13;
<h2>Moving to Streaming Algorithm</h2>&#13;
&#13;
<p><a data-primary="memory resource" data-secondary="moving to streaming algorithm" data-type="indexterm" id="ix_ch10-asciidoc15"/><a data-primary="optimization examples" data-secondary="moving to streaming algorithm" data-type="indexterm" id="ix_ch10-asciidoc16"/><a data-primary="streaming algorithm, moving to" data-type="indexterm" id="ix_ch10-asciidoc17"/>Let’s pull up the heap profile from the <code>Sum4</code> benchmark in <a data-type="xref" href="#img-opt-mem-v4">Figure 10-5</a> to figure out what we can improve.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-mem-v4">&#13;
<img alt="efgo 1005" src="assets/efgo_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span>Flame Graph view of <a data-type="xref" href="#code-sum4">Example 10-5</a> heap allocations with function granularity (<code>alloc_space</code>)</h6>&#13;
</div></figure>&#13;
&#13;
<p>The memory profile is very boring. The first line allocates 99.6% of memory in <a data-type="xref" href="#code-sum4">Example 10-5</a>. We essentially read the whole file into memory so we can iterate over the bytes in memory. Even if we waste some allocation elsewhere, we can’t see it because of excessive allocation from <code>os.ReadFile</code>. Is there anything we can do about that?</p>&#13;
&#13;
<p>During our algorithm, we must go through all the bytes in the file; thus, we have to read all bytes eventually. However, we don’t need to read all of them to memory at the same time. Technically, we only need a byte slice big enough to hold all digits for an integer to be parsed. This means we can try to design <a href="https://oreil.ly/Dr3MB">the external memory algorithm</a> to stream bytes in chunks. We can try using the existing bytes scanner from the standard library—the <a href="https://oreil.ly/CqiG7"><code>bufio.Scanner</code></a>. For example, <code>Sum5</code> in the <a data-type="xref" href="#code-sum5">Example 10-7</a> implementation uses it to scan enough memory to read and parse a line.</p>&#13;
<div data-type="example" id="code-sum5">&#13;
<h5><span class="label">Example 10-7. </span><code>Sum5</code> is <a data-type="xref" href="#code-sum4">Example 10-5</a> with <code>bufio.Scanner</code></h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">Sum5</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO5-1" id="co_optimization_examples_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">errcapture</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">,</code><code class="w"> </code><code class="s">"close file"</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO5-2" id="co_optimization_examples_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
&#13;
    </code><code class="nx">scanner</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bufio</code><code class="p">.</code><code class="nx">NewScanner</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">scanner</code><code class="p">.</code><code class="nx">Scan</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO5-3" id="co_optimization_examples_CO5-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
        </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">scanner</code><code class="p">.</code><code class="nx">Bytes</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="nx">scanner</code><code class="p">.</code><code class="nx">Err</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO5-4" id="co_optimization_examples_CO5-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO5-1" id="callout_optimization_examples_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Instead of reading the whole file into memory, we open the file descriptor here.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO5-2" id="callout_optimization_examples_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We have to make sure the file is closed after the computation so as not to leak resources. We use <code>errcapture</code> to get notified about potential errors in the deferred file <code>Close</code>.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO5-3" id="callout_optimization_examples_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The scanner <code>.Scan()</code> method tells us if we hit the end of the file. It returns true if we still have bytes to result in splitting. The split is based on the provided function in the <code>.Split</code> method. By default, <a href="https://oreil.ly/YUpLU"><code>ScanLines</code></a> is what we want.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO5-4" id="callout_optimization_examples_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Don’t forget to check the scanner error! With such iterator interfaces, it’s very easy to forget to check its error.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>To assess efficiency, now focusing more on memory, we can use the same <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> with <code>Sum5</code>. However, given our past optimizations, we’ve moved dangerously close to what can be reasonably measured within the accuracy and overhead of our tools for input files on the order of a million lines. If we got into microsecond latencies, our measurements might be skewed, given limits in the instrumentation accuracy and benchmarking tool overheads. So let’s increase the file to 10 million lines. The benchmarked <code>Sum4</code> in <a data-type="xref" href="#code-sum4">Example 10-5</a> for that input results in 67.8 ms and 36 MB of memory allocated per operation. The <code>Sum5</code> with the scanner outputs 157.1 ms and 4.33 KB per operation.</p>&#13;
&#13;
<p>In terms of memory usage, this is great. If we look at the implementation, the scanner <a href="https://oreil.ly/jbpJc">allocates an initial 4 KB</a> and uses it for reading the line. It increases this if needed when the line is longer, but our file doesn’t have numbers longer than 10 digits, so it stays at 4 KB. Unfortunately, the scanner isn’t fast enough for our latency requirement. With a 131% slowdown to <code>Sum4</code>, we hit 15.6 * <em>N</em> nanoseconds latency, which is too slow. We have to optimize latency again, knowing we still have around 6 KB to allocate to stay within the 10 KB memory goal.<a data-startref="ix_ch10-asciidoc17" data-type="indexterm" id="idm45606822116576"/><a data-startref="ix_ch10-asciidoc16" data-type="indexterm" id="idm45606822115872"/><a data-startref="ix_ch10-asciidoc15" data-type="indexterm" id="idm45606822115200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing bufio.Scanner" data-type="sect2"><div class="sect2" id="idm45606822114304">&#13;
<h2>Optimizing bufio.Scanner</h2>&#13;
&#13;
<p><a data-primary="bufio.Scanner, optimizing" data-type="indexterm" id="ix_ch10-asciidoc18"/><a data-primary="memory resource" data-secondary="optimizing bufio.Scanner" data-type="indexterm" id="ix_ch10-asciidoc19"/><a data-primary="optimization examples" data-secondary="optimizing bufio.Scanner" data-type="indexterm" id="ix_ch10-asciidoc20"/>What can we improve? As usual, it’s time to check the source code and profile of <a data-type="xref" href="#code-sum5">Example 10-7</a> in <a data-type="xref" href="#img-opt-lat-v5">Figure 10-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-v5">&#13;
<img alt="efgo 1006" src="assets/efgo_1006.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>Graph view of <a data-type="xref" href="#code-sum5">Example 10-7</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>The commentary on the <code>Scanner</code> structure in the standard library gives us a hint. It tells us that “<a href="https://oreil.ly/6eXZE"><code>Scanner</code> is for safe, simple jobs”</a>. The <code>ScanLines</code> is the main bottleneck here, and we can swap the implementation with a more efficient one. For example, the original function removes <a href="https://oreil.ly/wwUbC">carriage return (CR) control characters</a>, which wastes cycles for us as our input does not have them. I managed to provide optimized <code>ScanLines</code>, which improves the latency by 20.5% to 125 ms, which is still too slow.</p>&#13;
&#13;
<p>Similar to previous optimizations, it might be worth writing a custom streamed scanning implementation instead of <code>bufio.Scanner</code>. The <code>Sum6</code> in <a data-type="xref" href="#code-sum6">Example 10-8</a> presents a potential solution.</p>&#13;
<div data-type="example" id="code-sum6">&#13;
<h5><span class="label">Example 10-8. </span><code>Sum6</code> is <a data-type="xref" href="#code-sum4">Example 10-5</a> with buffered read</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">Sum6</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">errcapture</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">,</code><code class="w"> </code><code class="s">"close file"</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">buf</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="o">*</code><code class="mi">1024</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-1" id="co_optimization_examples_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
    </code><code class="k">return</code><code class="w"> </code><code class="nx">Sum6Reader</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">buf</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">Sum6Reader</code><code class="p">(</code><code class="nx">r</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">,</code><code class="w"> </code><code class="nx">buf</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-2" id="co_optimization_examples_CO6-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
    </code><code class="kd">var</code><code class="w"> </code><code class="nx">offset</code><code class="p">,</code><code class="w"> </code><code class="nx">n</code><code class="w"> </code><code class="kt">int</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">n</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">Read</code><code class="p">(</code><code class="nx">buf</code><code class="p">[</code><code class="nx">offset</code><code class="p">:</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-3" id="co_optimization_examples_CO6-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">EOF</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-4" id="co_optimization_examples_CO6-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
            </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">n</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">offset</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-5" id="co_optimization_examples_CO6-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
&#13;
        </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">buf</code><code class="p">[</code><code class="p">:</code><code class="nx">n</code><code class="p">]</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-6" id="co_optimization_examples_CO6-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
            </code><code class="k">if</code><code class="w"> </code><code class="nx">buf</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">buf</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">]</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">offset</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">n</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">last</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">offset</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">_</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">copy</code><code class="p">(</code><code class="nx">buf</code><code class="p">,</code><code class="w"> </code><code class="nx">buf</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">n</code><code class="p">]</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO6-7" id="co_optimization_examples_CO6-7"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
        </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-1" id="callout_optimization_examples_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We create a single 8 KB buffer of bytes we will use for reading. I chose 8 KB and not 10 KB to leave some headroom within our 10 KB limit. The 8 KB also feels like a great number given the OS page is 4 KB, so we know it will need only 2 pages.</p>&#13;
&#13;
<p>This buffer assumes that no integer is larger than ~8,000 digits. We can make it much smaller, even down to 10, as we know our input file does not have numbers with more than 9 digits (plus the newline). However, this would make the algorithm much slower due to the certain waste explained in the next steps. Additionally, even without waste reading, 8 KB is faster than reading 8 bytes 1,024 times due to overhead.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-2" id="callout_optimization_examples_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This time, let’s separate functionality behind the convenient <code>io.Reader</code> interface. This will allow us to reuse <code>Sum6Reader</code> in the future.<sup><a data-type="noteref" href="ch10.html#idm45606821709296" id="idm45606821709296-marker">7</a></sup></p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-3" id="callout_optimization_examples_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>In each iteration, we read the next 8 KB, minus <code>offset</code> bytes from a file. We start reading more file bytes after <code>offset</code> bytes to leave potential room for digits we didn’t parse yet. This can happen if we read bytes that split some numbers into parts, e.g., we read <code>...\n12</code> and <code>34/n...</code> in two different chunks.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-4" id="callout_optimization_examples_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>In the error handling, we excluded the <code>io.EOF</code> sentinel error, which indicated we hit the end of the file. That’s not an error for us—we still want to process the remaining bytes.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-5" id="callout_optimization_examples_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The number of bytes we have to process from the buffer is exactly <code>n + offset</code>, where <code>n</code> is the number of bytes read from a file. The end of file <code>n</code> can be smaller than what we asked for (length of the <code>buf</code>).</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-6" id="callout_optimization_examples_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>We iterate over <code>n</code> bytes in the <code>buf</code> buffer.<sup><a data-type="noteref" href="ch10.html#idm45606821736720" id="idm45606821736720-marker">8</a></sup> Notice that we don’t iterate over the whole slice because in an <code>err == io.EOF</code> situation, we might read less than 10 KB of bytes, so we need to process only <code>n</code> of them. We process all lines found in our 10 KB buffer in each loop iteration.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO6-7" id="callout_optimization_examples_CO6-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>We calculate <code>offset</code>, and if there is a need for one, we shift the remaining bytes to the front. This creates a small waste in CPU, but we don’t allocate anything additional. Benchmarks will tell us if this is fine or not.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Our <code>Sum6</code> code got a bit bigger and more complex, so hopefully, it gives good efficiency results to justify the complexity. Indeed, after the benchmark, we see it takes 69 ms and 8.34 KB. Just in case, let’s put <a data-type="xref" href="#code-sum6">Example 10-8</a> to the extra test by computing an even larger file—100 million lines. With bigger input, <code>Sum6</code> yields 693 ms and around 8 KB. This gives us a 6.9 * <em>N</em> nanoseconds latency (runtime complexity) and space (heap) complexity of ~8 KB, which satisfies our goal.</p>&#13;
&#13;
<p>Careful readers might still be wondering if I didn’t miss anything. Why is space complexity 8 KB, not 8 + <em>x</em> KB? There are some additional bytes allocated for 10 million line files and even more bytes for larger ones. How do we know that at some point for a hundred-times larger file, the memory allocation would not exceed 10 KB?</p>&#13;
&#13;
<p>If we are very strict and tight on that 10 KB allocation goal, we can try to figure out what happens. The most important thing is to validate that there is nothing that grows allocation with the file size. This time the memory profile is also invaluable, but to understand things fully, let’s ensure we record all allocations by adding <code>runtime.MemProfileRate = 1</code> in our <code>BenchmarkSum</code> benchmark. The resulting profile is presented in <a data-type="xref" href="#img-opt-mem-v6">Figure 10-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-mem-v6">&#13;
<img alt="efgo 1007" src="assets/efgo_1007.png"/>&#13;
<h6><span class="label">Figure 10-7. </span>Flame Graph view of <a data-type="xref" href="#code-sum6">Example 10-8</a> memory with function granularity and profile rate 1</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can see more allocations from the <code>pprof</code> package than our function. This indicates a relatively large allocation overhead by the profiling itself! Still, it does not prove that <code>Sum</code> does not allocate anything else on the heap than our 8 KB buffer. The Source view turns out to be helpful, presented in <a data-type="xref" href="#img-opt-mem-source-v6">Figure 10-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-mem-source-v6">&#13;
<img alt="efgo 1008" src="assets/efgo_1008.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>Source view of <a data-type="xref" href="#code-sum6">Example 10-8</a> memory with profile rate 1 after benchmark with 1,000 iterations and 10 MB input file</h6>&#13;
</div></figure>&#13;
&#13;
<p>It shows that <code>Sum6</code> has only one heap allocation point. We can also benchmark without CPU profiling, which now gives stable 8,328 heap allocated bytes for any input size.</p>&#13;
&#13;
<p>Success! Our goal is met, and we can move to the last task. The overview of each iteration’s achieved result is shown in <a data-type="xref" href="#code-sum-go-bench-benchstat-v6">Example 10-9</a><a data-startref="ix_ch10-asciidoc20" data-type="indexterm" id="idm45606821596064"/><a data-startref="ix_ch10-asciidoc19" data-type="indexterm" id="idm45606821595456"/><a data-startref="ix_ch10-asciidoc18" data-type="indexterm" id="idm45606821594848"/>.<a data-startref="ix_ch10-asciidoc14" data-type="indexterm" id="idm45606821594112"/><a data-startref="ix_ch10-asciidoc13" data-type="indexterm" id="idm45606821593504"/></p>&#13;
<div data-type="example" id="code-sum-go-bench-benchstat-v6">&#13;
<h5><span class="label">Example 10-9. </span>Running <code>benchstat</code> on the results from all 3 iterations with a 10 million line file</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">$ benchstat v1.txt v2.txt v3.txt v4.txt&#13;
name \ (time/op)   v4-10M.txt   v5-10M.txt    v6-10M.txt&#13;
Sum                67.8ms ± 3%  157.1ms ± 2%  69.4ms ± 1%&#13;
&#13;
name \ (alloc/op) v4-10M.txt   v5-10M.txt    v6-10M.txt&#13;
Sum               36.0MB ± 0%    0.0MB ± 3%   0.0MB ± 0%&#13;
&#13;
name \ (allocs/op)  v4-10M.txt   v5-10M.txt    v6-10M.txt&#13;
Sum                 5.00 ± 0%     4.00 ± 0%    4.00 ± 0%</pre></div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing Latency Using Concurrency" data-type="sect1"><div class="sect1" id="ch-opt-latency-concurrency-example">&#13;
<h1>Optimizing Latency Using Concurrency</h1>&#13;
&#13;
<p><a data-primary="concurrency" data-secondary="optimizing latency using" data-type="indexterm" id="ix_ch10-asciidoc21"/><a data-primary="latency" data-secondary="optimizing using concurrency" data-type="indexterm" id="ix_ch10-asciidoc22"/><a data-primary="latency optimization" data-secondary="using concurrency" data-type="indexterm" id="ix_ch10-asciidoc23"/><a data-primary="optimization examples" data-secondary="optimizing latency using concurrency" data-type="indexterm" id="ix_ch10-asciidoc24"/>Hopefully, you are ready for the last challenge: getting our latency down even more to the 2.5 nanoseconds per line level. This time we have four CPU cores available, so we can try introducing some concurrency patterns to achieve it.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch04.html#ch-hw-concurrency-when">“When to Use Concurrency”</a>, we mentioned the clear need for concurrency to employ asynchronous programming or event handling in our code. We talked about relatively easy gains where our Go program does a lot of I/O operations. However, in this section, I would love to show you how to improve the speed of our <code>Sum</code> in the <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> code using concurrency with two typical pitfalls. Because of the tight latency requirement, let’s take an already optimized version of <code>Sum</code>. Given we don’t have any memory requirements, and <code>Sum4</code> in <a data-type="xref" href="#code-sum4">Example 10-5</a> is only a little slower than <code>Sum6</code>, yet has a smaller amount of lines, let’s take that as a start.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Naive Concurrency" data-type="sect2"><div class="sect2" id="idm45606821576272">&#13;
<h2>A Naive Concurrency</h2>&#13;
&#13;
<p><a data-primary="latency optimization" data-secondary="naive concurrency" data-type="indexterm" id="ix_ch10-asciidoc25"/>As usual, let’s pull out the <a data-type="xref" href="#code-sum4">Example 10-5</a> CPU profile, shown in <a data-type="xref" href="#img-opt-lat-v4">Figure 10-9</a>.</p>&#13;
&#13;
<figure class="width-90"><div class="figure" id="img-opt-lat-v4">&#13;
<img alt="efgo 1009" src="assets/efgo_1009.png"/>&#13;
<h6><span class="label">Figure 10-9. </span>Graph view of <a data-type="xref" href="#code-sum4">Example 10-5</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you might have noticed, most of <a data-type="xref" href="#code-sum4">Example 10-5</a> CPU time comes from <code>ParseInt</code> (47.7%). Since we’re back to reading the whole file at the beginning of the program, the rest of the program is strictly CPU bound. As a result, with only one CPU we couldn’t expect better latency with <a href="https://oreil.ly/rsLff">the concurrency</a>. However, given that within this task we have four CPU cores available, our task now is to find a way to evenly split the work of parsing the file’s contents with as little coordination<sup><a data-type="noteref" href="ch10.html#idm45606821549792" id="idm45606821549792-marker">9</a></sup> between goroutines as possible. Let’s explore three example approaches to optimize <a data-type="xref" href="#code-sum4">Example 10-5</a> with concurrency.</p>&#13;
&#13;
<p>The first thing we have to do is find computations we can do independently at the same time—computations that do not affect each other. Because the sum is commutative, it does not matter in what order numbers are added. The naive, concurrent implementation could parse the integer from the string and add the result atomically to the shared variable. Let’s explore this rather simple solution in <a data-type="xref" href="#code-sum-concurrent1">Example 10-10</a>.</p>&#13;
<div data-type="example" id="code-sum-concurrent1">&#13;
<h5><span class="label">Example 10-10. </span>Naive concurrent optimization to <a data-type="xref" href="#code-sum4">Example 10-5</a> that spins a new goroutine for each line to compute</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">ConcurrentSum1</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">continue</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">line</code><code class="w"> </code><code class="p">[]</code><code class="kt">byte</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">line</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">                </code><code class="c1">// TODO(bwplotka): Return err using other channel.</code><code class="w"/>&#13;
<code class="w">                </code><code class="k">return</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">atomic</code><code class="p">.</code><code class="nx">AddInt64</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="nx">num</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}(</code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">])</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/></pre></div>&#13;
&#13;
<p>After the successful functional test, it’s time for benchmarking. Similar to previous steps, we can reuse the same <a data-type="xref" href="ch08.html#code-sum-go-bench3">Example 8-13</a> by simply replacing <code>Sum</code> with <code>ConcurrentSum1</code>. I also changed the <code>-cpu</code> flag to 4 to unlock the four CPU cores. Unfortunately, the results are not very promising—for a 2 million line input, it takes about 540 ms and 151 MB of allocated space per operation! Almost 40 times more time than the simpler, noncurrent <a data-type="xref" href="#code-sum4">Example 10-5</a>.<a data-startref="ix_ch10-asciidoc25" data-type="indexterm" id="idm45606821301408"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Worker Approach with Distribution" data-type="sect2"><div class="sect2" id="idm45606821300704">&#13;
<h2>A Worker Approach with Distribution</h2>&#13;
&#13;
<p><a data-primary="latency optimization" data-secondary="worker approach with distribution" data-type="indexterm" id="ix_ch10-asciidoc26"/>Let’s check the CPU profile in <a data-type="xref" href="#img-opt-lat-vc1">Figure 10-10</a> to learn why.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-vc1">&#13;
<img alt="efgo 1010" src="assets/efgo_1010.png"/>&#13;
<h6><span class="label">Figure 10-10. </span>Flame Graph view of <a data-type="xref" href="#code-sum-concurrent1">Example 10-10</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>The Flame Graph clearly shows the goroutine creation and scheduling overhead indicated by blocks called <code>runtime.schedule</code> and <code>runtime.newproc</code>. There are three main reasons why <a data-type="xref" href="#code-sum-concurrent1">Example 10-10</a> is too naive and not recommended for our case:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The concurrent work (parsing and adding) is too fast to justify the goroutine overhead (both in memory and CPU usage).</p>&#13;
</li>&#13;
<li>&#13;
<p>For larger datasets, we create potentially millions of goroutines. While goroutines are relatively cheap and we can have hundreds of them, there is always a limit, given only four CPU cores to execute. So you can imagine the delay of the scheduler that tries to fairly schedule millions of goroutines on four CPU cores.</p>&#13;
</li>&#13;
<li>&#13;
<p>Our program will have a nondeterministic performance depending on the number of lines in the file. We can potentially hit a problem of unbounded concurrency since we will spam as many goroutines as the external file has lines (something outside our program control).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>That is not what we want, so let’s improve our concurrent implementation. There are many ways we could go from here, but let’s try to address all three problems we notice. We can solve problem number one by assigning more work to each goroutine. We can do that thanks to the fact that addition is also associative and cumulative. We can essentially group work into multiple lines, parse and add numbers in each goroutine, and add partial results to the total sum. Doing that automatically helps with problem number two. Grouping work means we will schedule fewer goroutines. The question is, what is the best number of lines in a group? Two? Four? A hundred?</p>&#13;
&#13;
<p>The answer most likely depends on the number of goroutines we want in our process and the number of CPUs available. There is also problem number three—unbounded concurrency. The typical solution here is to use a worker pattern (sometimes called goroutine pooling). In this pattern, we agree on a number of goroutines up front, and we schedule all of them at once. Then we can create another goroutine that will distribute the work evenly. Let’s see an example implementation of that algorithm in <a data-type="xref" href="#code-sum-concurrent2">Example 10-11</a>. Can you predict if this implementation will be faster?</p>&#13;
<div data-type="example" id="code-sum-concurrent2">&#13;
<h5><span class="label">Example 10-11. </span>Concurrent optimization of <a data-type="xref" href="#code-sum4">Example 10-5</a> that maintains a finite set of goroutines that computes a group of lines. Lines are distributed using another goroutine.</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">ConcurrentSum2</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">workers</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="p">(</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">wg</code><code class="w">     </code><code class="p">=</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="p">{</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">workCh</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="mi">10</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">workers</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="kd">var</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="kt">int</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">workCh</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">i</code><code class="p">]</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">&#13;
</code><code class="w">      </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">        </code><code class="nb">close</code><code class="p">(</code><code class="nx">workCh</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO7-1" id="co_optimization_examples_CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
        </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">workers</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="nx">sum</code><code class="w"> </code><code class="kt">int64</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="nx">line</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">workCh</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO7-2" id="co_optimization_examples_CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
                </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">line</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                    </code><code class="c1">// TODO(bwplotka): Return err using other channel.</code><code class="w">&#13;
</code><code class="w">                    </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">                </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">                </code><code class="nx">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">atomic</code><code class="p">.</code><code class="nx">AddInt64</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="nx">sum</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO7-1" id="callout_optimization_examples_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Remember, the sender is usually responsible for the closing channel. Even if our flow does not depend on it, it’s a good practice to always close channels after use.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO7-2" id="callout_optimization_examples_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Beware of common mistakes. The <code>for _, line := range &lt;-workCh</code> would sometimes compile as well, and it looks logical, but it’s wrong. It will wait for the first message from the <code>workCh</code> channel and iterate over single bytes from the received byte slice. Instead, we want to iterate over messages.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Tests pass, so we can start benchmarking. Unfortunately, on average, this implementation with 4 goroutines takes 207 ms to complete a single operation (using 7 MB of space). Still, this is 15 times slower than simpler, sequential <a data-type="xref" href="#code-sum4">Example 10-5</a>.<a data-startref="ix_ch10-asciidoc26" data-type="indexterm" id="idm45606821183792"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Worker Approach Without Coordination (Sharding)" data-type="sect2"><div class="sect2" id="idm45606821182832">&#13;
<h2>A Worker Approach Without Coordination (Sharding)</h2>&#13;
&#13;
<p><a data-primary="latency optimization" data-secondary="worker approach without coordination" data-type="indexterm" id="ix_ch10-asciidoc27"/><a data-primary="sharding" data-secondary="worker approach without coordination" data-type="indexterm" id="ix_ch10-asciidoc28"/>What’s wrong this time? Let’s investigate the CPU profile presented in <a data-type="xref" href="#img-opt-lat-vc2">Figure 10-11</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-vc2">&#13;
<img alt="efgo 1011" src="assets/efgo_1011.png"/>&#13;
<h6><span class="label">Figure 10-11. </span>Flame Graph view of <a data-type="xref" href="#code-sum-concurrent2">Example 10-11</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you see a profile like this, it should immediately tell you that the concurrency overhead is again too large. We still don’t see the actual work, like parsing integers, since this work has outnumbered the overhead. This time the overhead is caused by three elements:</p>&#13;
<dl>&#13;
<dt><code>runtime.schedule</code></dt>&#13;
<dd>&#13;
<p>The runtime code responsible for scheduling goroutines.</p>&#13;
</dd>&#13;
<dt><code>runtime.chansend</code></dt>&#13;
<dd>&#13;
<p>In our case, waiting on the lock to send to our single channel.</p>&#13;
</dd>&#13;
<dt><code>runtime.chanrecv</code></dt>&#13;
<dd>&#13;
<p>The same as <code>chansend</code> but waiting on a read from the receive channel.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>As a result, parsing and additions are faster than the communication overhead. Essentially, coordination and distribution of the work take more CPU resources than the work itself.</p>&#13;
&#13;
<p>We have multiple options for improvement here. In our case, we can try to remove the effort of distributing the work. We can accomplish this via a coordination-free algorithm that will shard (split) the workload evenly across all goroutines. It’s coordination free because there is no communication to agree on which part of the work is assigned to each goroutine. We can do that thanks to the fact that the file size is known up front, so we can use some sort of heuristic to assign each part of the file with multiple lines to each goroutine worker. Let’s see how this could be implemented in <a data-type="xref" href="#code-sum-concurrent3">Example 10-12</a>.</p>&#13;
<div data-type="example" id="code-sum-concurrent3">&#13;
<h5><span class="label">Example 10-12. </span>Concurrent optimization of <a data-type="xref" href="#code-sum4">Example 10-5</a> that maintains a finite set of goroutines that computes groups of lines. Lines are sharded without coordination.</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">ConcurrentSum3</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">workers</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">b</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ReadFile</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="p">(</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">bytesPerWorker</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">workers</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">resultCh</code><code class="w">       </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">workers</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="c1">// Coordination-free algorithm, which shards</code><code class="w">&#13;
</code><code class="w">            </code><code class="c1">// buffered file deterministically.</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">begin</code><code class="p">,</code><code class="w"> </code><code class="nx">end</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">shardedRange</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">bytesPerWorker</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO8-1" id="co_optimization_examples_CO8-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
            </code><code class="kd">var</code><code class="w"> </code><code class="nx">sum</code><code class="w"> </code><code class="kt">int64</code><code class="w">&#13;
</code><code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="nx">last</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">begin</code><code class="p">;</code><code class="w"> </code><code class="nx">begin</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">end</code><code class="p">;</code><code class="w"> </code><code class="nx">begin</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">if</code><code class="w"> </code><code class="nx">b</code><code class="p">[</code><code class="nx">begin</code><code class="p">]</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="sc">'\n'</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                    </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">                </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">                </code><code class="nx">num</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ParseInt</code><code class="p">(</code><code class="nx">b</code><code class="p">[</code><code class="nx">last</code><code class="p">:</code><code class="nx">begin</code><code class="p">]</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">                </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                    </code><code class="c1">// TODO(bwplotka): Return err using other channel.</code><code class="w">&#13;
</code><code class="w">                    </code><code class="k">continue</code><code class="w">&#13;
</code><code class="w">                </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">                </code><code class="nx">sum</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="nx">num</code><code class="w">&#13;
</code><code class="w">                </code><code class="nx">last</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">begin</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">resultCh</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">sum</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">workers</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">resultCh</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nb">close</code><code class="p">(</code><code class="nx">resultCh</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO8-1" id="callout_optimization_examples_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>shardedRange</code> is not supplied for clarity. This function takes the size of the input file and splits into <code>bytesPerWorker</code> shards (four in our case). Then it gives each worker the <code>i</code>-th shard. You can see the full code <a href="https://oreil.ly/By9wO">here</a>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Tests pass too, so we confirmed that <a data-type="xref" href="#code-sum-concurrent3">Example 10-12</a> is functionally correct. But is it faster? Yes! The benchmark shows 7 ms and 7 MB per operation, which is almost twice as fast as sequential <a data-type="xref" href="#code-sum4">Example 10-5</a>. Unfortunately, this puts us in 3.4 * <em>N</em> nanoseconds throughput, which is failing our goal of 2.5 * <em>N</em>.<a data-startref="ix_ch10-asciidoc28" data-type="indexterm" id="idm45606821149728"/><a data-startref="ix_ch10-asciidoc27" data-type="indexterm" id="idm45606821148992"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Streamed, Sharded Worker Approach" data-type="sect2"><div class="sect2" id="idm45606821148320">&#13;
<h2>A Streamed, Sharded Worker Approach</h2>&#13;
&#13;
<p><a data-primary="latency optimization" data-secondary="streamed, sharded worker approach" data-type="indexterm" id="ix_ch10-asciidoc29"/><a data-primary="sharding" data-secondary="streamed, sharded worker approach" data-type="indexterm" id="ix_ch10-asciidoc30"/>Let’s profile in <a data-type="xref" href="#img-opt-lat-vc3">Figure 10-12</a> one more time to check if we can improve anything easily.</p>&#13;
&#13;
<p>The CPU profile shows that the work done by our goroutines takes the most CPU time. However, ~10% of CPU time is spent reading all bytes, which we can also try to do concurrently. This effort does not look promising at first glance. However, even if we would remove all 10% of the CPU time, 10% better throughput gives us only the 3.1 * <em>N</em> nanoseconds number, so not enough.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-lat-vc3">&#13;
<img alt="efgo 1012" src="assets/efgo_1012.png"/>&#13;
<h6><span class="label">Figure 10-12. </span>Flame Graph view of <a data-type="xref" href="#code-sum-concurrent3">Example 10-12</a> CPU time with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is where we have to be vigilant, though. As you can imagine, reading files is not a CPU-bound job, so perhaps the actual real time spend on that 10% of CPU time makes <code>os.ReadFile</code> a bigger bottleneck, thus a better option for us to optimize. As in <a data-type="xref" href="#ch-opt-latency-example">“Optimizing Latency”</a>, let’s perform a benchmark wrapped with the <code>fgprof</code> profile! The resulting full goroutine profile is presented in <a data-type="xref" href="#img-opt-fgprof-vc3">Figure 10-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-opt-fgprof-vc3">&#13;
<img alt="efgo 1013" src="assets/efgo_1013.png"/>&#13;
<h6><span class="label">Figure 10-13. </span>Flame Graph view of <a data-type="xref" href="#code-sum-concurrent3">Example 10-12</a> full goroutine profile with function granularity</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>fgprof</code> profile shows that a lot can be gained in latency if we try to read files concurrently, as it currently takes around 50% of the real time! This is way more promising, so let’s try to move file reads to worker goroutines. The example implementation is shown in <a data-type="xref" href="#code-sum-concurrent4">Example 10-13</a>.</p>&#13;
<div data-type="example" id="code-sum-concurrent4">&#13;
<h5><span class="label">Example 10-13. </span>Concurrent optimization of <a data-type="xref" href="#code-sum-concurrent3">Example 10-12</a> that also reads from a file concurrently using separate buffers</h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">ConcurrentSum4</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">workers</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">ret</code><code class="w"> </code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">errcapture</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">,</code><code class="w"> </code><code class="s">"close file"</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">s</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">Stat</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="p">(</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">size</code><code class="w">           </code><code class="p">=</code><code class="w"> </code><code class="nb">int</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">Size</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">bytesPerWorker</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">size</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">workers</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">resultCh</code><code class="w">       </code><code class="p">=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">int64</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">bytesPerWorker</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"can't have less bytes per goroutine than 10"</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">workers</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">begin</code><code class="p">,</code><code class="w"> </code><code class="nx">end</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">shardedRangeFromReaderAt</code><code class="p">(</code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">bytesPerWorker</code><code class="p">,</code><code class="w"> </code><code class="nx">size</code><code class="p">,</code><code class="w"> </code><code class="nx">f</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">r</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">NewSectionReader</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nb">int64</code><code class="p">(</code><code class="nx">begin</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="nb">int64</code><code class="p">(</code><code class="nx">end</code><code class="o">-</code><code class="nx">begin</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO9-1" id="co_optimization_examples_CO9-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
            </code><code class="nx">b</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="p">[</code><code class="p">]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="o">*</code><code class="mi">1024</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">sum</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Sum6Reader</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO9-2" id="co_optimization_examples_CO9-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">                </code><code class="c1">// TODO(bwplotka): Return err using other channel.</code><code class="w">&#13;
</code><code class="w">            </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">            </code><code class="nx">resultCh</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="nx">sum</code><code class="w">&#13;
</code><code class="w">        </code><code class="p">}</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">workers</code><code class="p">;</code><code class="w"> </code><code class="nx">i</code><code class="o">++</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="nx">ret</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">resultCh</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nb">close</code><code class="p">(</code><code class="nx">resultCh</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO9-1" id="callout_optimization_examples_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Instead of splitting the bytes from the input file in memory, we tell each goroutine what bytes from the file it can read. We can do this thanks to the <a href="https://oreil.ly/j4cQd"><code>SectionReader</code></a>, which returns a reader that only allows reading from a particular section. There is a small complexity in <a href="https://oreil.ly/PwNty"><code>shardedRangeFrom​Rea⁠derAt</code></a> to make sure we read all lines (we don’t know where the newlines in a file are), but it can be done in the relatively easy algorithm presented here.</p></dd>&#13;
<dt><a class="co" href="#co_optimization_examples_CO9-2" id="callout_optimization_examples_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We can reuse <a data-type="xref" href="#code-sum6">Example 10-8</a> for this job as it knows how to use any <code>io.Reader</code> implementation, so in our example, both <code>*os.File</code> and <code>*io.SectionReader</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Let’s assess the efficiency of that code. Finally, after all this work, <a data-type="xref" href="#code-sum-concurrent4">Example 10-13</a> yields an astonishing 4.5 ms per operation for 2 million lines, and 23 ms for 10 million lines. This takes us into ~2.3 * <em>N</em> nanosecond throughput, which satisfies our goal! A full comparison of latencies and memory allocations for successful iterations is presented in <a data-type="xref" href="#code-sum-go-bench-benchstat-vc4">Example 10-14</a>.</p>&#13;
<div data-type="example" id="code-sum-go-bench-benchstat-vc4">&#13;
<h5><span class="label">Example 10-14. </span>Running <code>benchstat</code> on the results from all four iterations with a two million line file</h5>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">name \ (time/op)   v4-4core.txt  vc3.txt      vc4.txt&#13;
Sum-4              13.3ms ± 1%   6.9ms ± 6%   4.5ms ± 3%&#13;
&#13;
name \ (alloc/op)  v4-4core.txt  vc3.txt      vc4.txt&#13;
Sum-4              7.20MB ± 0%   7.20MB ± 0%  0.03MB ± 0%</pre></div>&#13;
&#13;
<p>To summarize, we went through three exercises showcasing the optimization flow focused on different goals. I also have some possible concurrency patterns that allow utilizing our multicore machines. Generally, I hope you saw how critical benchmarking and profiling were throughout this journey! Sometimes the results might surprise you, so always seek confirmation of your ideas<a data-startref="ix_ch10-asciidoc30" data-type="indexterm" id="idm45606820029200"/><a data-startref="ix_ch10-asciidoc29" data-type="indexterm" id="idm45606820014720"/>.<a data-startref="ix_ch10-asciidoc24" data-type="indexterm" id="idm45606821088208"/><a data-startref="ix_ch10-asciidoc23" data-type="indexterm" id="idm45606821087600"/><a data-startref="ix_ch10-asciidoc22" data-type="indexterm" id="idm45606819990416"/><a data-startref="ix_ch10-asciidoc21" data-type="indexterm" id="idm45606819989808"/></p>&#13;
&#13;
<p>There is, however, another way to solve those exercises in an innovative way that might work for certain use cases. Sometimes it allows us to avoid the huge optimization effort we did in the past three sections. Let’s take a look!</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bonus: Thinking Out of the Box" data-type="sect1"><div class="sect1" id="ch-opt-bonus">&#13;
<h1>Bonus: Thinking Out of the Box</h1>&#13;
&#13;
<p><a data-primary="optimization examples" data-secondary="alternative methods" data-type="indexterm" id="idm45606819987232"/>Given the challenging goals we set in this chapter, I spent a lot of time optimizing and explaining optimization for the naive <code>Sum</code> implementation in <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a>. This showed you some optimization ideas, practices, and generally a mental model I use during optimization efforts. But hard optimization work is not always an answer—there are numerous ways to reach our goals.</p>&#13;
&#13;
<p>For example, what if I told you there is a way to get amortized runtime complexity of a few nanoseconds and zero allocations (and just four more code lines)? Let’s see <a data-type="xref" href="#code-sum7">Example 10-15</a>.</p>&#13;
<div data-type="example" id="code-sum7">&#13;
<h5><span class="label">Example 10-15. </span>Adding simplest caching to <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a></h5>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">var</code><code class="w"> </code><code class="nx">sumByFile</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">int64</code><code class="p">{</code><code class="p">}</code><code class="w"> </code><a class="co" href="#callout_optimization_examples_CO10-1" id="co_optimization_examples_CO10-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
&#13;
</code><code class="kd">func</code><code class="w"> </code><code class="nx">Sum7</code><code class="p">(</code><code class="nx">fileName</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int64</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">s</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sumByFile</code><code class="p">[</code><code class="nx">fileName</code><code class="p">]</code><code class="p">;</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">s</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Sum</code><code class="p">(</code><code class="nx">fileName</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="nx">sumByFile</code><code class="p">[</code><code class="nx">fileName</code><code class="p">]</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">ret</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">ret</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_optimization_examples_CO10-1" id="callout_optimization_examples_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>sumByFile</code> represents the simplest storage for cache. There are tons of more production read-caching implementations you can consider as well. We can write our own that will be goroutine safe. If we need more involved eviction policies, I would recommend <a href="https://oreil.ly/nnYoM">HashiCorp’s golang-lru</a> and the even more optimized <a href="https://oreil.ly/QNshi">Dgraph’s ristretto</a>. For distributed systems, you should use distributed caching services like <a href="https://oreil.ly/fudbQ">Memcached</a>, <a href="https://oreil.ly/1ovP1">Redis</a>, or peer-to-peer caching solutions like &#13;
<span class="keep-together"><a href="https://oreil.ly/vJONo">groupcache</a>.</span></p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="fix_tracking">The functional test passes, and the benchmarks show amazing results—for 100 million line files, we see 228 ns and 0 bytes allocated! This example is, of course, a very trivial one. It’s unlikely our optimization journey is always as easy as that. Simple caching is limited and can’t be used if the file input constantly changes. But what if we can?</p>&#13;
&#13;
<p>Think smart, not hard. It might be the case that we don’t need to optimize <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> because the same input files are constantly used. Caching a single sum value for each file is cheap—even if we would have a million of those files, we can cache all using a few megabytes. If that’s not the case, perhaps the file content often repeats, but the filename is unique. In that case, we could calculate the checksum of the file and cache based on that. It would be faster than parsing all lines into integers.</p>&#13;
&#13;
<p class="fix_tracking">Focus on the goal and be smart and innovative. For example, a hard, week-long, deep optimization effort might not be worth it if there is some smart solution that avoids that work!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45606820125632">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We did it! We optimized the initial naive implementation of <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> using the TFBO flow from <a data-type="xref" href="ch03.html#ch-conq-eff-flow">“Efficiency-Aware Development Flow”</a>. Guided by the requirements, we managed to improve the <code>Sum</code> code significantly:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We improved the runtime complexity from around 50.5 * <em>N</em> nanoseconds (where N is a number of lines) to 2.25 * <em>N</em>. This means around 22 times faster latency, even though both naive and most optimized algorithms are linear (we optimized O(<em>N</em>) constants).</p>&#13;
</li>&#13;
<li>&#13;
<p>We improved the space complexity from around 30.4 * <em>N</em> bytes to 8 KB, which means our code had O(<em>N</em>) asymptotic complexity but now has constant space complexity. This means the new <code>Sum</code> code will be much more predictable for the users and more friendly for the garbage collector.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To sum up, sometimes efficiency problems require a long and careful optimization process, as we did for <code>Sum</code>. On the other hand, sometimes, you can find quick and pragmatic optimization ideas that fulfill your goals quickly. Nevertheless, we all learned a lot from the exercises in this chapter (including me!).<a data-startref="ix_ch10-asciidoc0" data-type="indexterm" id="idm45606820171232"/></p>&#13;
&#13;
<p>Let’s move to the last chapter of this book, where we will summarize some learning and patterns we saw during our exercises in this chapter, and what I have seen in the community from my experience.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45606823780656"><sup><a href="ch10.html#idm45606823780656-marker">1</a></sup> For example, I already know about a <a href="https://oreil.ly/IZxm7"><code>strconv.ParseInt</code> optimization</a> coming to Go 1.20, which would change the memory efficiency of the naive <a data-type="xref" href="ch04.html#code-sum">Example 4-1</a> without any optimization from my side.</p><p data-type="footnote" id="idm45606823764528"><sup><a href="ch10.html#idm45606823764528-marker">2</a></sup> If you are interested in what input files I used, see <a href="https://oreil.ly/0SMxA">the code I used</a> for generating the input.</p><p data-type="footnote" id="idm45606823492960"><sup><a href="ch10.html#idm45606823492960-marker">3</a></sup> There is a small segment in <a data-type="xref" href="#img-opt-lat-v1-fgprof">Figure 10-2</a> that shows <code>ioutil.ReadFile</code> latency with 0.38% of all samples. When we unfold the <code>ReadFile</code>, the <code>syscall.Read</code> (which we could assume is an I/O latency) takes 0.25%, given the <code>sum.BenchmarkSum_fgprof</code> contributes to 4.67% of overall wall time (the rest is taken by benchmarking and CPU profiling). The (0.25 * 100%)/4.67 is equal to 5.4%.</p><p data-type="footnote" id="idm45606823466592"><sup><a href="ch10.html#idm45606823466592-marker">4</a></sup> We can further inspect that using <a data-type="xref" href="ch09.html#ch-obs-pprof-heap">“Heap”</a> profile, which would in my tests show us that 78.6% of the total 60.8 MB of allocation per operation is taken by <code>bytes.Split</code>!</p><p data-type="footnote" id="idm45606823189696"><sup><a href="ch10.html#idm45606823189696-marker">5</a></sup> We can deduce that from the <code>runtime.slicebytetostring</code> function name in the profile. We can also split this line into three lines (string conversion in one, subslicing in the second, and invoking the parsing function in the third) and profile again to be sure.</p><p data-type="footnote" id="idm45606822879264"><sup><a href="ch10.html#idm45606822879264-marker">6</a></sup> In benchmarks, I also found that my <code>ParseInt</code> is also faster by 10% to <code>strconv.Atoi</code> for the <code>Sum</code> test data.</p><p data-type="footnote" id="idm45606821709296"><sup><a href="ch10.html#idm45606821709296-marker">7</a></sup> Interestingly enough, just adding a new function call and interface slows down the program by 7% per operation on my machine, proving that we are on a very high efficiency level already. However, given reusability, perhaps we can afford that slowdown.</p><p data-type="footnote" id="idm45606821736720"><sup><a href="ch10.html#idm45606821736720-marker">8</a></sup> As an interesting fact, if we replace this line with a technically simpler loop like <code>for i := 0; i &lt; n; i++ {</code>, the code is 5% slower! Don’t take it as a rule (always measure!), as it probably depends on your workload, but it’s interesting to see the <code>range</code> loop (without a second argument) be more efficient here.</p><p data-type="footnote" id="idm45606821549792"><sup><a href="ch10.html#idm45606821549792-marker">9</a></sup> We discussed synchronization primitives in <a data-type="xref" href="ch04.html#ch-hw-concurrency">“Go Runtime Scheduler”</a>.</p></div></div></section></body></html>