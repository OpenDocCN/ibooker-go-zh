- en: Chapter 7\. Data-Driven Efficiency Assessment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 数据驱动的效率评估
- en: You learned how to observe our Go program using different observability signals
    in the previous chapter. We discussed how to transform those signals to numeric
    values, or metrics, to effectively observe and assess the latency and resource
    consumption of the program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学会了如何使用不同的可观察信号来观察我们的Go程序。我们讨论了如何将这些信号转换为数值，或者说指标，以有效地观察和评估程序的延迟和资源消耗。
- en: 'Unfortunately, knowing how to measure the current or maximum consumption or
    latency for running a program does not guarantee the correct assessment of the
    overall program efficiency for our application. What we are missing here is the
    experiment part, which might be the most challenging part of optimization generally:
    how to trigger situations that are worth measuring with the observability tools
    mentioned in [Chapter 6](ch06.html#ch-observability)!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，知道如何测量运行程序的当前或最大消耗或延迟，并不能保证正确评估应用程序的整体效率。我们在这里缺少的是实验部分，这可能是优化中最具挑战性的部分：如何使用第六章提到的可观察工具触发值得测量的情况！
- en: The Definition of Measuring
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量的定义
- en: 'I find the verb “to measure” very imprecise. I have seen this word overused
    to describe two things: the process of performing an experiment and gathering
    numeric data from it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现“测量”这个动词非常不精确。我看到这个词被过度使用来描述两件事情：执行实验的过程和从中收集数值数据。
- en: In this book, every time you read about the “measuring” process, I follow the
    definition used in [metrology (the science of measurement)](https://oreil.ly/5PRMp).
    I precisely mean the process of using the instruments to quantify what is happening
    now (e.g., the latency of the event, or how much memory it required) or what happened
    in a given time window. Everything that leads to this event that we measure (simulated
    by us in a benchmark or occurring naturally) is a separate topic, discussed in
    this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，每当你读到“测量”过程时，我都遵循[计量学（测量科学）](https://oreil.ly/5PRMp)中使用的定义。我确切地指的是使用仪器来量化当前发生的事情（例如事件的延迟，或者所需的内存量）或者在给定时间窗口内发生的事情。导致我们测量的事件（我们在基准测试中模拟的或自然发生的）是一个单独的话题，在本章中进行讨论。
- en: In this chapter, I will introduce you to the art of experimentation and measurement
    for efficiency purposes. I will mainly focus on data-driven assessment, more commonly
    known as benchmarking. This chapter will help you understand the best practices
    before we jump to writing benchmarking code in [Chapter 8](ch08.html#ch-benchmarking).
    These practices will also be invaluable in [Chapter 9](ch09.html#ch-observability3),
    which focuses on profiling.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍实验和测量效率的艺术。我将主要关注数据驱动的评估，通常称为基准测试。在我们跳到[第8章](ch08.html#ch-benchmarking)编写基准测试代码之前，这章将帮助你理解最佳实践。这些实践在[第9章](ch09.html#ch-observability3)中同样非常重要，该章重点讨论性能分析。
- en: I start with complexity analysis as a less empirical way of assessing the efficiency
    of our solutions. Then, I will explain benchmarking in [“The Art of Benchmarking”](#ch-obs-bench-intro).
    We will compare it to functional testing and clarify the common stereotype that
    claims “benchmarks always lie.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从复杂性分析开始，这是一种较少依赖经验的评估解决方案效率的方式。然后，我将解释《[基准测试的艺术](#ch-obs-bench-intro)》中的基准测试。我们将其与功能测试进行比较，并澄清一个普遍的成见：“基准测试总是虚假的”。
- en: Later in [“Reliability of Experiments”](#ch-obs-rel), we will move to the reliability
    aspect of our experiments for both benchmarking and profiling purposes. I will
    provide the ground rules to avoid wasting time (or money) by gathering bad data
    and making wrong conclusions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 后续在[“实验的可靠性”](#ch-obs-rel)中，我们将讨论实验的可靠性，无论是基准测试还是性能分析。我将提供基本规则，以避免因收集糟糕数据而浪费时间（或金钱），并做出错误的结论。
- en: Finally, in [“Benchmarking Levels”](#ch-obs-benchmarking), I will introduce
    you to the full landscape of benchmark strategies. In the previous chapters, I
    already used benchmarks to provide data that explained the behavior of CPU or
    memory resources. For example, in [“Consistent Tooling”](ch02.html#ch-go-tooling),
    I mentioned that the Go tooling provides a standard benchmarking framework. But
    the benchmarking skill I want to teach you in this chapter goes beyond that, and
    it is just one tool of many discussed in [“Microbenchmarks”](ch08.html#ch-obs-micro).
    There are many different ways of assessing the efficiency of our Go code. Knowing
    when to use what is key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[“基准测试水平”](#ch-obs-benchmarking)中，我将向您介绍完整的基准测试策略。在前几章中，我已经使用基准测试来提供解释 CPU
    或内存资源行为的数据。例如，在[“一致的工具”](ch02.html#ch-go-tooling)中，我提到 Go 工具提供了一个标准的基准测试框架。但是，我想在本章教给您的基准测试技能超越此框架，它只是在[“微基准测试”](ch08.html#ch-obs-micro)中讨论的众多工具之一。有许多不同的方法来评估我们
    Go 代码的效率。了解何时使用何种方法至关重要。
- en: Let’s start by introducing the benchmarking tests and what the critical aspects
    of those are.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍基准测试以及这些测试的关键方面开始。
- en: Complexity Analysis
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性分析
- en: We don’t always have the luxury of having empirical data that guides us through
    the efficiency of a certain solution. Your idea of a better system or algorithm
    might not be implemented yet and would require a lot of effort to do so before
    we could benchmark it. Additionally, I mentioned the need for complexity estimation
    in [“Example of Defining RAER”](ch03.html#example-defining-raer).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并非总能拥有指导我们通过某种解决方案效率的经验数据的奢侈。你对更好的系统或算法的想法可能尚未实施，并且在我们进行基准测试之前，需要大量的努力才能实现它。此外，我提到了在[“定义
    RAER 的示例”](ch03.html#example-defining-raer)中对复杂性估计的需求。
- en: This might feel contradictory to what we learned in [“Optimization Challenges”](ch03.html#ch-conq-challenges)
    (“programmers are notoriously bad at estimating exact resource consumption”),
    but sometimes engineers rely on theoretical analysis to assess the program. One
    example is when we assess optimizations on the algorithm level (from [“Optimization
    Design Levels”](ch03.html#ch-conq-opt-levels)). Developers and scientists often
    use complexity analysis to compare and decide what algorithm might fit better
    to solve certain problems with certain constraints. More specifically, they use
    asymptotic notations (commonly known as “Big O” complexities). Most likely, you
    have heard about them, as they are commonly asked about during any software engineering
    interview.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与我们在[“优化挑战”](ch03.html#ch-conq-challenges)中学到的内容相矛盾（“程序员在估计确切资源消耗时声名狼藉”），但有时工程师依赖理论分析来评估程序。一个例子是当我们在算法级别评估优化时（来自[“优化设计级别”](ch03.html#ch-conq-opt-levels)）。开发人员和科学家经常使用复杂性分析来比较并决定哪种算法可能更适合解决某些带有特定约束条件的问题。更具体地说，他们使用渐近符号（通常称为“大
    O”复杂性）。很可能，您已经听说过它们，因为它们在任何软件工程面试中都经常被询问。
- en: However, to fully understand asymptotic notations, you must know what “estimated”
    efficiency complexity means and what it looks like!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要完全理解渐近符号，您必须了解“估算”效率复杂性意味着什么，以及它是什么样子！
- en: “Estimated” Efficiency Complexity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “估算”效率复杂性
- en: I mentioned in [“Resource-Aware Efficiency Requirements”](ch03.html#ch-conq-req)
    that we can represent the CPU time or consumption of any resources as a mathematical
    function related to specific input parameters. Typically, we talk about *runtime*
    complexity, which tells us about the CPU time required to perform a certain operation
    using a particular piece of code and environment. However, we also have *space*
    complexity, which can describe the required memory, disk space, or other space
    requirements for that operation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“资源感知效率要求”](ch03.html#ch-conq-req)中提到，我们可以将 CPU 时间或任何资源的消耗表示为与特定输入参数相关的数学函数。通常，我们谈论*运行时*复杂性，它告诉我们使用特定代码和环境执行某个操作所需的
    CPU 时间。然而，我们还有*空间*复杂性，它可以描述执行该操作所需的内存、磁盘空间或其他空间需求。
- en: 'For example, let’s take our `Sum` function from [Example 4-1](ch04.html#code-sum).
    I can prove that such code has estimated space complexity (representing heap allocations)
    of the following function, where *N* is a number of integers in the input file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以我们的`Sum`函数为例，来自[示例 4-1](ch04.html#code-sum)。我可以证明这样的代码具有估算的空间复杂性（表示堆分配），其函数如下，其中
    *N* 是输入文件中的整数数量：
- en: <math><mrow><mi>s</mi> <mi>p</mi> <mi>a</mi> <mi>c</mi> <mi>e</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mn>848</mn> <mo>+</mo> <mn>3</mn>
    <mo>.</mo> <mn>6</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>24</mn>
    <mo>+</mo> <mn>24</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mo>+</mo> <mo>(</mo>
    <mn>2</mn> <mo>.</mo> <mn>8</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi>
    <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo> <mn>872</mn> <mo>+</mo> <mn>30</mn>
    <mo>.</mo> <mn>4</mn> <mo>*</mo> <mi>N</mi> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi>
    <mi>s</mi></mrow></math>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mi>s</mi> <mi>p</mi> <mi>a</mi> <mi>c</mi> <mi>e</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mo>=</mo> <mo>(</mo> <mn>848</mn> <mo>+</mo> <mn>3</mn>
    <mo>.</mo> <mn>6</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mo>+</mo> <mo>(</mo> <mn>24</mn>
    <mo>+</mo> <mn>24</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mo>+</mo> <mo>(</mo>
    <mn>2</mn> <mo>.</mo> <mn>8</mn> <mo>*</mo> <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi>
    <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo> <mn>872</mn> <mo>+</mo> <mn>30</mn>
    <mo>.</mo> <mn>4</mn> <mo>*</mo> <mi>N</mi> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi>
    <mi>s</mi></mrow></math>
- en: Knowing detailed complexity is great, but typically it’s impossible or hard
    to find the true complexity function because there are too many variables. We
    can, however, try to estimate those, especially for more deterministic resources
    like memory allocation, by simplifying the variables. For example, the preceding
    equation is only an estimation with a simplified function that takes only one
    parameter—the number of integers. Of course, this code also depends on the size
    of integers, but I assumed the integer is ~3.6 bytes long (statistic from my test
    input).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 知道详细的复杂性很重要，但通常找到真正的复杂性函数是不可能或很困难的，因为涉及的变量太多。然而，我们可以尝试估计这些变量，特别是对于像内存分配这样更确定的资源，可以通过简化变量来进行。例如，前述方程只是一个估算，采用了一个仅有一个参数——整数的数量。当然，这个代码还取决于整数的大小，但我假设整数约为3.6字节长（这是从我的测试输入统计得出的数据）。
- en: “Estimated” Complexity
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “估计”复杂性
- en: As I try to teach you in this book—be precise with the wording.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在这本书中试图教给你的那样——在措辞上要准确。
- en: I was so wrong for all those years, thinking that complexity always means Big
    O asymptotic complexity. Turns out [the complexity exists too](https://oreil.ly/LG5qb)
    and can be very useful in some cases. At least we should be aware it exists!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我这些年来一直误以为复杂性总是指大O渐近复杂性，其实[复杂性也存在](https://oreil.ly/LG5qb)，在某些情况下非常有用。至少我们应该意识到它的存在！
- en: Unfortunately, it’s easy to confuse it with asymptotic complexity, so I would
    propose calling the one that cares about constants—the “estimated” complexity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，很容易将其与渐近复杂性混淆，因此我建议称关注常数的那种为“估计”复杂性。
- en: How did I find this complexity equation? It wasn’t trivial. I had to analyze
    the source code, do some stack escape analysis, run multiple benchmarks, and use
    profiling (so all the things you will learn in this and the next two chapters)
    to discover those complexities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我是如何找到这个复杂性方程的？这并不是一件简单的事情。我不得不分析源代码，进行一些栈逃逸分析，运行多个基准测试，并使用性能分析（你将在本章和下两章学到的所有内容）来发现这些复杂性。
- en: This Is Just an Example!
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这只是一个例子！
- en: Don’t worry. To assess or optimize your code, you don’t need to perform such
    detailed complexity analysis, especially in such detail. I did this to show it’s
    possible and what it gives, but there are more pragmatic ways to assess efficiency
    quickly and find out the next optimizations. You will see example flows in [Chapter 10](ch10.html#ch-opt).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心。要评估或优化您的代码，您不需要进行如此详细的复杂性分析，特别是这么详细的分析。我这样做是为了表明这是可能的，并且可以得到什么结果，但是还有更多务实的方法可以快速评估效率并找出下一个优化点。您将在[第10章](ch10.html#ch-opt)中看到示例流程。
- en: Funny enough, at the end of the TFBO flow, when you optimized one part of your
    program a lot, you might have a detailed awareness of the problem space so that
    you could find such complexity quickly. However, doing this for every version
    of your code would be wasteful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 搞笑的是，在TFBO流程的末端，当你大幅优化程序的某一部分时，你可能对问题空间有了详细的认识，以至于你能够迅速找到这样的复杂性。然而，对你代码的每个版本都这样做则是浪费的。
- en: It might be useful to explain the process of gathering the complexity and mapping
    it to the source code, as shown in [Example 7-1](#code-sum-compl).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解释收集复杂性并将其映射到源代码的过程可能很有用，如[例子 7-1](#code-sum-compl)所示。
- en: Example 7-1\. Complexity analysis of [Example 4-1](ch04.html#code-sum)
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例7-1\. [例子 4-1](ch04.html#code-sum)的复杂性分析
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_data_driven_efficiency_assessment_CO1-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_data_driven_efficiency_assessment_CO1-1)'
- en: We can attach the 848 + 3.6 * *N* part of the complexity equation to the operation
    of reading the file content into memory. The test input I used is very stable—the
    integers have a different number of digits, but on average they have 2.6 digits.
    Adding a new line (`\n`) character means every line has approximately 3.6 bytes.
    Since `ReadFile` returns a byte array with the content of the input file, we can
    say that our program requires exactly 3.6 * *N* bytes for the byte array pointed
    to by the `b` slice. The constant amount of 848 bytes comes from various objects
    allocated on the heap in the `os.ReadFile` function—for example, the slice value
    for `b` (24 bytes), which escaped the stack. To discover that constant, it was
    enough to benchmark with an empty file and profile it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将复杂方程中的848 + 3.6 * *N*部分与将文件内容读入内存的操作相关联。我使用的测试输入非常稳定——整数的位数不同，但平均有2.6位数字。每行添加一个新行（`\n`）字符意味着每行大约有3.6字节。由于`ReadFile`返回的是包含输入文件内容的字节数组，因此我们可以说我们的程序对于由`b`切片指向的字节数组需要确切的3.6
    * *N*字节。848字节的常量来自于在`os.ReadFile`函数中分配的各种对象，例如为`b`切片分配的切片值（24字节），这些逃逸出堆。通过空文件进行基准测试并进行分析即可发现这个常量。
- en: '[![2](assets/2.png)](#co_data_driven_efficiency_assessment_CO1-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_data_driven_efficiency_assessment_CO1-2)'
- en: As you will learn in [Chapter 10](ch10.html#ch-opt), the `bytes.Split` is quite
    expensive when it comes to both allocations and runtime latency. However, we can
    attribute most of the allocations to this part, so to the 24 + 24 * *N* complexity
    part. It’s the “majority” because it’s the largest constant (24) multiplied by
    the input size. The reason is the allocation needed to return the [`[][]byte`](https://oreil.ly/Be0OF)
    data structure. While we don’t copy the underlying byte arrays (we share it with
    the buffer from `os.ReadFile)`, the *N* allocated empty `[]byte` slices require
    24 * *N* of the heap in total, plus the 24 for the `[][]byte` slice header. This
    is a huge allocation if *N* is on the order of billions (22 GB for a billion integers).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第10章](ch10.html#ch-opt)中了解的那样，`bytes.Split`在分配和运行时延迟方面都相当昂贵。然而，我们可以将大部分分配归因于此部分，因此复杂度的24
    + 24 * *N*部分。这是“主要”部分，因为它是最大的常量（24）乘以输入大小。原因是为了返回[`[][]byte`](https://oreil.ly/Be0OF)数据结构而进行的分配。虽然我们不会复制底层字节数组（我们与从`os.ReadFile`中共享缓冲区），但是为分配的空的`[]byte`切片总共需要24
    * *N*的堆，再加上`[][]byte`切片头部的24字节。如果*N*数量级为十亿级别，这将是一个巨大的分配（22GB用于十亿个整数）。
- en: '[![3](assets/3.png)](#co_data_driven_efficiency_assessment_CO1-3)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_data_driven_efficiency_assessment_CO1-3)'
- en: Finally, as we learned in [“Values, Pointers, and Memory Blocks”](ch05.html#ch-hw-allocations)
    and as we will uncover in [“Optimizing runtime.slicebytetostring”](ch10.html#ch-opt-latency-example-strcopy),
    we allocate on this line a lot too. It’s not visible at first, but the memory
    required for `string(line)` (which is always a copy) is escaping to heap.^([1](ch07.html#idm45606830136704))
    This attributes to the 2.8 * *N* part of the complexity because we do this conversion
    N times for 2.6 digits on average. The source of the remaining 0.2 * *N* is unknown.^([2](ch07.html#idm45606830134048))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们在[“数值、指针和内存块”](ch05.html#ch-hw-allocations)中学到的，并且正如我们将在[“优化 runtime.slicebytetostring”](ch10.html#ch-opt-latency-example-strcopy)中揭示的那样，我们在这一行上也有很多分配。一开始并不明显，但`string(line)`所需的内存（始终是副本）正在逃逸到堆中。^([1](ch07.html#idm45606830136704))
    这是复杂度中2.8 * *N*的一部分，因为我们平均会为2.6位数字进行N次此类转换。剩下的0.2 * *N*的来源是未知的。^([2](ch07.html#idm45606830134048))
- en: I hope that with this analysis, you see what complexity means. Perhaps you already
    see how useful it is to know. Maybe you already see many optimization opportunities,
    which we will try in [Chapter 10](ch10.html#ch-opt)!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过这个分析，你能明白复杂度的含义。也许你已经看到这种知识的有用性。也许你已经看到了许多我们将在[第10章](ch10.html#ch-opt)中尝试的优化机会！
- en: Asymptotic Complexity with Big O Notation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐进复杂度与大O符号
- en: 'The asymptotic complexity ignores the overheads of the implementation, particularly
    hardware or environment. Instead, it focuses on [asymptotic mathematical analysis](https://oreil.ly/MR0Jz):
    how fast runtime or space demands grow in relation to the input size. This allows
    algorithm classifications based on their scalability, which usually matters for
    the researchers who search for algorithms solving complex problems (which usually
    require enormous inputs). For example, in [Figure 7-1](#img-opt-bigo), we see
    a small overview of typical functions and an opinionated assessment of what’s
    typically bad and what’s good complexity for the algorithm. Note that “bad” complexity
    here doesn’t mean there are algorithms that do better—there are some problems
    that can’t be done in a faster way.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 渐近复杂度忽略了实现的开销，特别是硬件或环境方面的。相反，它专注于渐近数学分析：运行时间或空间需求与输入大小的增长速度。这允许基于可伸缩性对算法进行分类，这通常对于研究复杂问题的算法的研究者非常重要（这些问题通常需要大量输入）。例如，在
    [图 7-1](#img-opt-bigo) 中，我们看到了典型函数的简要概述，并对算法的典型复杂度进行了评论。请注意，这里的“坏”复杂度并不意味着没有更好的算法——有些问题无法以更快的方式解决。
- en: '![efgo 0701](assets/efgo_0701.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0701](assets/efgo_0701.png)'
- en: Figure 7-1\. Big O complexity chart from [*https://www.bigocheatsheet.com*](https://www.bigocheatsheet.com).
    Shading indicates the opinionated rates of efficiency for usual problems.
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1. 来自 [*https://www.bigocheatsheet.com*](https://www.bigocheatsheet.com)
    的大 O 复杂度图表。阴影表示通常问题的效率评估。
- en: We usually use Big O notation to represent asymptotic complexity. To my knowledge,
    it was Donald Knuth who attempted to clearly define three notations (O, Ω, Θ)^([3](ch07.html#idm45606830118784))
    in [his article from 1976](https://oreil.ly/yeFpW).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用大 O 符号来表示渐近复杂度。据我所知，唐纳德·克努斯在他 1976 年的文章中尝试清晰地定义了三个符号（O, Ω, Θ）([3](ch07.html#idm45606830118784))。
- en: Verbally, O(f(n)) can be read as “order at most f(n)”; Ω(f(n)) as “order at
    least f(n)”; Θ(f(n)) as “order exactly f(n)”.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 口头上，O(f(n)) 可以理解为“最多为 f(n) 的阶数”；Ω(f(n)) 可以理解为“至少为 f(n) 的阶数”；Θ(f(n)) 可以理解为“正好为
    f(n) 的阶数”。
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Donald Knuth, [“Big Omicron and Big Omega and Big Theta”](https://oreil.ly/yeFpW)
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 唐纳德·克努斯，《“大欧米伽、大欧米伽和大 Theta”》（https://oreil.ly/yeFpW）
- en: 'The phrase “in order of f(*N*)” means that we are not interested in the exact
    complexity numbers but rather the approximation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 短语“按照 f(*N*) 的顺序”意味着我们对精确的复杂度数字不感兴趣，而更关注近似值：
- en: The upper bound (O)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上界（O）
- en: Big Oh means the function can’t be asymptotically worse than `f(n)`. It is also
    sometimes used to reflect the worst-case scenario if other input characteristics
    matter (e.g., in a sorting problem, we usually talk about a number of elements,
    but sometimes it matters if the input is already sorted).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大 Oh 意味着该函数的渐近复杂度不能比 `f(n)` 更差。有时也用于反映最坏情况，如果其他输入特征重要（例如，在排序问题中，我们通常讨论元素的数量，但有时输入已经排序也很重要）。
- en: The tight bound (Θ)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密界限（Θ）
- en: Big Theta represents the exact asymptotic function or, sometimes, the average,
    typical case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大 O 记号代表确切的渐近函数，有时也代表平均典型情况。
- en: The lower bound (Ω)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下界（Ω）
- en: Big Omega means the function can’t be asymptotically better than `f(n)`. It
    also sometimes represents the best case.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大 Omega 意味着该函数的渐近复杂度不能比 `f(n)` 更好。有时也代表最佳情况。
- en: For example, the [quicksort](https://oreil.ly/a2jhF) sorting algorithm has the
    best and average runtime complexity (depending on how input is sorted and where
    we choose the pivot point) of the *N* * log*N*, so *Ω*(*N* * log*N*) and *Θ*(*N*
    * log*N*), even though the worst case is *O*(*N*²).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[快速排序](https://oreil.ly/a2jhF) 排序算法根据输入的排序方式和选择的枢轴点，最佳和平均运行时间复杂度为 *N* * log*N*，因此
    *Ω*(*N* * log*N*) 和 *Θ*(*N* * log*N*)，尽管最坏情况是 *O*(*N*²)。
- en: The Industry Is Not Always Using Big O Notation Properly
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业并非总是正确使用大 O 符号。
- en: Generally, during interviews, discussions, and tutorials, you would see people
    using Big Oh (*O*) where Big Theta (*Θ*) should be used to describe a typical
    case. For example, we often say quicksort is *O*(*N* * log*N*), which is not true,
    but in many instances we would accept that answer. Perhaps people try to make
    this space more accessible by simplifying this topic. I will try to be more precise
    here, but you can always swap *Θ* with *O* (but not in the opposite direction).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在面试、讨论和教程中，您会看到人们使用大 Oh（*O*）来描述典型情况下应使用大 Theta（*Θ*）。例如，我们经常说快速排序是 *O*(*N*
    * log*N*)，这并不正确，但在许多情况下，我们会接受这个答案。也许人们试图通过简化这个话题来使其更易理解。我将在这里尽量更准确，但您始终可以用 *Θ*
    替换 *O*（但不能反过来）。
- en: 'For our algorithm in [Example 4-1](ch04.html#code-sum), the asymptotic space
    complexity is linear:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在 [示例 4-1](ch04.html#code-sum) 中的算法，渐近空间复杂度是线性的：
- en: <math><mrow><mi>s</mi> <mi>p</mi> <mi>a</mi> <mi>c</mi> <mi>e</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>872</mn> <mo>+</mo> <mn>30</mn> <mo>.</mo>
    <mn>4</mn> <mo>*</mo> <mi>N</mi> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi>
    <mo>=</mo> <mi>Θ</mi> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mi>Θ</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo>
    <mi>Θ</mi> <mo>(</mo> <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi>
    <mi>s</mi></mrow></math>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mi>s</mi> <mi>p</mi> <mi>a</mi> <mi>c</mi> <mi>e</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mo>=</mo> <mn>872</mn> <mo>+</mo> <mn>30</mn> <mo>.</mo>
    <mn>4</mn> <mo>*</mo> <mi>N</mi> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi>
    <mo>=</mo> <mi>Θ</mi> <mo>(</mo> <mn>1</mn> <mo>)</mo> <mo>+</mo> <mi>Θ</mi> <mo>(</mo>
    <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi> <mi>s</mi> <mo>=</mo>
    <mi>Θ</mi> <mo>(</mo> <mi>N</mi> <mo>)</mo> <mi>b</mi> <mi>y</mi> <mi>t</mi> <mi>e</mi>
    <mi>s</mi></mrow></math>
- en: In asymptotic analysis, constants like 1, 872, and 30.2 do not matter, even
    though in practice, it might matter if our code allocates 1 MB (*Θ*(*N*)) or 30.4
    MB.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在渐近分析中，像 1、872 和 30.2 这样的常数并不重要，尽管在实践中，如果我们的代码分配了 1 MB（*Θ*(*N*)）或 30.4 MB，这可能会有所影响。
- en: 'Note that we don’t need precise complexity to figure out the asymptotic one.
    That’s the point: precise complexity depends on too many variables, especially
    when it comes to runtime complexity. Generally, we can learn to find the theoretical
    asymptotic complexity based on algorithm pseudocode or description. It takes some
    practice, but imagine we don’t have [Example 7-1](#code-sum-compl) implemented;
    instead, we design an algorithm. For example, the naive algorithm for the sum
    of all integers in the file can be described as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要精确的复杂度来找出渐近复杂度。这就是问题的关键：精确的复杂度取决于太多变量，特别是当涉及运行时间复杂度时。通常，我们可以根据算法伪代码或描述来学习找到理论上的渐近复杂度。这需要一些实践，但是想象一下，如果我们没有实现
    [示例 7-1](#code-sum-compl)，而是设计了一个算法。例如，文件中所有整数的朴素求和算法可以描述如下：
- en: We read the file’s content into memory, which has *Θ*(*N*) of asymptotic space
    complexity, where *N* is the number of integers or lines. As we read N lines,
    this also has *Θ*(*N*) runtime complexity.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将文件内容读入内存，其渐近空间复杂度为 *Θ*(*N*)，其中 *N* 是整数或行数的数量。由于我们读取了 N 行，这也具有 *Θ*(*N*) 的运行时间复杂度。
- en: We split the content into subslices. If we do it in place, this means *Θ*(*N*).
    Otherwise, in theory, it is *Θ*(1). This is an interesting one, as we saw in precise
    complexity that despite doing this in place, the overhead is 24 * *N*, which suggests
    *Θ*(*N*). In both cases, the runtime complexity is *Θ*(*N*), as we have to go
    through all lines.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将内容分割成子切片。如果我们原地执行，这意味着 *Θ*(*N*)。否则，从理论上讲，它是 *Θ*(1)。这是一个有趣的案例，正如我们在精确复杂度中看到的那样，尽管在原地执行，开销为
    24 * *N*，这表明 *Θ*(*N*)。在这两种情况下，运行时间复杂度都是 *Θ*(*N*)，因为我们必须遍历所有行。
- en: 'For every subslice (space complexity *Θ*(1) and runtime *Θ*(*N*)):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个子切片（空间复杂度 *Θ*(1) 和运行时间 *Θ*(*N*)）：
- en: We parse the integer. Technically this needs no extra space on the heap, assuming
    the integers can be kept on the stack. The runtime of this should also be *Θ*(1)
    if we relate to the number of lines and the number of digits is limited.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们解析整数。从技术上讲，这不需要额外的堆空间，假设整数可以保留在堆栈上。如果我们关联到行数和数字限制在范围内，其运行时间也应该是 *Θ*(1)。
- en: 'We add the parsed value into a temporary variable containing a partial sum:
    *Θ*(1) runtime and *Θ*(1) space.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将解析的值添加到一个包含部分和的临时变量中：*Θ*(1) 的运行时间和 *Θ*(1) 的空间。
- en: With such analysis, we can tell that the space complexity is *Θ*(*N*) + *Θ*(1)
    + *Θ*(*N*) * *Θ*(1), so *Θ*(*N*). I also mentioned runtime complexity in step
    2, which combines into *Θ*(*N*) + *Θ*(*N*) + *Θ*(*N*) * *Θ*(1), so also linear
    *Θ*(*N*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的分析，我们可以得出空间复杂度为 *Θ*(*N*) + *Θ*(1) + *Θ*(*N*) * *Θ*(1)，因此为 *Θ*(*N*)。我在第二步还提到了运行时间复杂度，合并后为
    *Θ*(*N*) + *Θ*(*N*) + *Θ*(*N*) * *Θ*(1)，因此也是线性的 *Θ*(*N*)。
- en: Generally, such a `Sum` algorithm is fairly easy to assess asymptotically, but
    this is not trivial in many cases. It takes some practice and experience. I would
    love it if some automatic tools detected such complexity. There were interesting
    [attempts](https://oreil.ly/0h9ff) in the past, but in practice, they are too
    expensive.^([4](ch07.html#idm45606830040464)) Perhaps there is a way to implement
    some algorithm that assesses pseudocode for its complexity, but it’s our job now!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这样一个`Sum`算法在渐进上是相当容易评估的，但在许多情况下并不是微不足道的。这需要一些实践和经验。如果有自动工具能够检测到这样的复杂性，我会感到非常高兴。过去有一些有趣的[尝试](https://oreil.ly/0h9ff)，但实际上它们的代价太高了。^([4](ch07.html#idm45606830040464))也许有一种方法可以实现某种算法来评估伪代码的复杂性，但这现在是我们的工作！
- en: Practical Applications
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用实例
- en: Frankly speaking, I was always skeptical about the “complexity” topic. Perhaps
    I missed the lectures about it at my university,^([5](ch07.html#idm45606830034224))
    but I was always disappointed when somebody asked me to determine the complexity
    of some algorithm. I was convinced that it is only used to trick candidates during
    technical interviews and has almost no use in practical software development.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，我一直对“复杂性”这个话题持怀疑态度。也许我在大学时错过了关于它的讲座，^([5](ch07.html#idm45606830034224))但每当有人让我确定某个算法的复杂性时，我总是感到失望。我相信这只是在技术面试中用来捉弄候选人的伎俩，在实际软件开发中几乎没有任何用处。
- en: The first problem was imprecision—when people asked me to determine complexity,
    they meant asymptotic complexity in Big O notation. Furthermore, what’s the point
    of Big O if, during paid work, I could usually search an element in the array
    with the linear algorithm instead of a hashmap, and still the code would be fast
    enough in most cases? Moreover, more experienced developers were rejecting my
    merge requests because my fancy linked list with better insertion complexity could
    be just a simpler array with `appends`. Finally, I was learning about all those
    fast algorithms with incredible asymptotic complexity that are not used in practice
    because of hidden constant costs or other caveats.^([6](ch07.html#idm45606830032352))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是不精确——当人们问我要确定复杂性时，他们指的是大 O 符号的渐进复杂性。此外，在付费工作期间，如果我通常可以使用线性算法而不是哈希映射在数组中搜索元素，代码仍然足够快吗？此外，更有经验的开发人员因为我的复杂的链表与更好的插入复杂性可能只是一个更简单的数组带有`appends`而拒绝我的合并请求。最后，我了解了所有那些因隐藏常数成本或其他注意事项而在实践中未使用的具有令人难以置信的渐进复杂性的快速算法。^([6](ch07.html#idm45606830032352))
- en: I think most of my frustration came from misunderstandings and misuses stemming
    from the industry’s stereotypes and simplifications. I am especially surprised
    that [not a few engineers](https://oreil.ly/1yxqH) are willing to perform such
    “estimated” complexity. Perhaps we often feel demotivated or overwhelmed by how
    hard it is to estimate beyond asymptotic complexity. For me, reading old programming
    books was eye-opening—some of them use both complexities in most of their optimization
    examples!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我的大部分挫败感来源于对行业刻板印象和简化的误解和误用。我特别惊讶的是，[不少工程师](https://oreil.ly/1yxqH)竟然愿意进行这种“估算”复杂性。也许我们常常因为估计超越渐进复杂性的困难而感到失落或不知所措。对我来说，阅读旧的编程书籍是一种启发——它们在大多数优化示例中都使用了这两种复杂性！
- en: The main `for` loop of the program is executed `N-1` times, and contains an
    inner loop that is itself executed `N` times; the total time required by the program
    will therefore be dominated by a term proportional to `N^2`. The Pascal running
    time of Fragment A1 was observed to by approximately 47.0N^2 microseconds.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 程序的主`for`循环执行了`N-1`次，并包含一个内部循环，内部循环本身执行了`N`次；因此，程序所需的总时间将受到与`N^2`成比例的项的主导。观察到片段
    A1 的帕斯卡运行时间约为 47.0N^2 微秒。
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jon Louis Bentley, *Writing Efficient Programs*
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乔恩·路易斯·本特利，《编写高效程序》
- en: When you try to assess or optimize algorithm and code that requires better efficiency,
    being aware of its estimated complexity and asymptotic complexity has a real value.
    Let’s go through some use cases.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试评估或优化需要更高效率的算法和代码时，了解其预估复杂性和渐进复杂性是有实际价值的。让我们看一些使用案例。
- en: If you know precise complexity, you don’t need to measure to know expected resource
    requirements
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果您了解精确的复杂性，您无需测量即可知道预期的资源需求
- en: In practice, we rarely have precise complexity from the start, but imagine someone
    giving us such complexity. This gives an enormous win for tasks like capacity
    planning, where you need to find out the cost of running your system under various
    loads (e.g., different inputs).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们很少从一开始就有精确的复杂度，但想象一下有人给我们这样的复杂度。这在像容量规划这样需要了解在各种负载（例如不同输入）下运行系统成本的任务中是一个巨大的胜利。
- en: 'For example, how much memory does the naive implementation of `Sum` use in
    [Example 7-1](#code-sum-compl)? It turns out that without any benchmark, I could
    use the space complexity of 872 + 30.4 * *N* bytes to tell that for various input
    sizes, for example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 7-1](#code-sum-compl)中`Sum`的朴素实现使用了多少内存？事实证明，即使没有任何基准测试，我也可以使用 872 +
    30.4 * *N* 字节的空间复杂度来告诉，例如：
- en: For 1 million integers, my code would need 30,400,872 bytes, so 30.4 MB if we
    use the [1,000 multiplier, not the 1,024](https://oreil.ly/SYcm8).^([7](ch07.html#idm45606830017600))
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一百万个整数，我的代码将需要 30,400,872 字节，即 30.4 MB，如果我们使用[1,000 倍数，而不是 1,024](https://oreil.ly/SYcm8)。^([7](ch07.html#idm45606830017600))
- en: For 2 million integers, it would need 60.8 MB.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两百万个整数，它将需要 60.8 MB。
- en: This can be confirmed if we would perform a quick microbenchmark (don’t worry,
    I will explain how to perform benchmarks here and in [Chapter 8](ch08.html#ch-benchmarking)).
    Results are presented in [Example 7-2](#code-sum-bench2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行快速微基准测试（别担心，我会在这里和[第 8 章](ch08.html#ch-benchmarking)中解释如何进行基准测试），结果将呈现在[示例
    7-2](#code-sum-bench2)中。
- en: Example 7-2\. Benchmark allocation result for [Example 4-1](ch04.html#code-sum)
    with one million elements and two million elements input, respectively
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[示例 4-1 的基准分配结果](ch04.html#code-sum)分别具有一百万个元素和两百万个元素的输入。'
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Based on just those two results, our space complexity is fairly accurate.^([8](ch07.html#idm45606829986592))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两个结果，我们的空间复杂度相当准确。^([8](ch07.html#idm45606829986592))
- en: It’s unlikely you can always find the full, accurate, real complexity. However,
    usually it’s enough to have a very high-level estimation of this complexity, e.g.,
    30 * *N* bytes would be detailed enough space complexity for our `Sum` function
    in [Example 7-1](#code-sum-compl).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你不太可能总是能找到完整、准确的实际复杂度。但通常对此复杂度进行非常高水平的估计就足够了，例如，`Sum` 函数在[示例 7-1](#code-sum-compl)中的空间复杂度为
    30 * *N* 字节足够详细。
- en: It tells us if there is any easy optimization to our code
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它告诉我们代码是否存在任何简单的优化方法。
- en: Sometimes we don’t need detailed empirical data to know we have efficiency problems.^([9](ch07.html#idm45606830003600))
    This is great because such techniques can tell us how easy it is to optimize our
    program further. Such a quick efficiency assessment is something I would love
    you to know before we move into heavy benchmarking.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不需要详细的经验数据就能知道我们存在效率问题。^([9](ch07.html#idm45606830003600))这很棒，因为这些技术可以告诉我们优化我们程序的难易程度。在我们进入重型基准测试之前，了解这样一个快速的效率评估对我来说是非常重要的。
- en: For example, when I wrote the naive implementation of the `Sum` in [Example 4-1](ch04.html#code-sum),
    I expected to write an algorithm with *Θ*(*N*) space (asymptotic) complexity.
    However, I expected it to have around 3.5 * *N* of the real complexity because
    I read the whole file content to memory. Only when I ran benchmarks that gave
    me output like [Example 7-2](#code-sum-bench2) did I realize how poor my naive
    implementation was, with almost 10 times more memory usage than expected (30.5
    MB). This expected estimation of the real complexity versus the resulting one
    is typically a good indication that there might be some trivial optimization if
    we have to improve the efficiency.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我在[示例 4-1](ch04.html#code-sum)中编写`Sum`的朴素实现时，我预计会编写一个具有*Θ*(*N*)空间复杂度（渐近）的算法。然而，我预计它的实际复杂度大约是
    3.5 * *N*，因为我将整个文件内容读入了内存。只有当我运行像[示例 7-2](#code-sum-bench2)这样的基准测试后，我才意识到我的朴素实现是多么糟糕，内存使用几乎比预期多了
    10 倍（30.5 MB）。这种对实际复杂度的预期估计与实际结果之间的差异通常是我们需要改进效率时的一个很好的指示。
- en: Secondly, if my algorithm space Big O complexity is linear, it is already a
    bad sign for such simple functionality. My algorithm will use an extreme amount
    of memory for huge inputs. Depending on requirements, that might be fine or it
    might mean real issues if we want to scale this application.^([10](ch07.html#idm45606829995728))
    If not a problem right now, the maximum expected input size should be acknowledged
    and documented as it might be a surprise to somebody who will be using this function
    in the future!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果我的算法空间复杂度为线性，对于如此简单的功能来说已经是一个坏迹象。我的算法将为大量输入使用极大量的内存。根据要求，这可能没问题，或者如果我们希望扩展这个应用程序，这可能意味着真正的问题。^([10](ch07.html#idm45606829995728))如果现在不是问题，应该承认和记录最大预期输入大小，因为这可能对将来使用此函数的人来说会有所惊讶！
- en: Finally, suppose the measurements are totally off the expected complexity of
    the algorithm. In that case, it might signal a [memory leak](https://oreil.ly/ZNB5s),
    which is often easy to fix if you have the right tools (as we will discuss in
    [“Don’t Leak Resources”](ch11.html#ch-basic-leaks)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设测量结果完全偏离算法预期的复杂性。这可能表明存在[内存泄漏](https://oreil.ly/ZNB5s)，如果你有正确的工具（正如我们将在[“不泄露资源”](ch11.html#ch-basic-leaks)中讨论的那样），通常很容易修复。
- en: Three Clear Indications We Are Wasting Memory Space
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个明确表明我们在浪费内存空间的迹象
- en: The difference between the theoretical space complexity (asymptotic and estimated)
    and the reality measured with a benchmark can immediately tell you if something
    is not as expected.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论空间复杂度（渐进和估计）与使用基准测试测量得到的实际空间复杂度之间的差异可以立即告诉你是否有意外情况。
- en: Significant space complexity depending on the user (or caller) input is a bad
    sign that might mean future scalability problems.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户（或调用者）输入相关的显著空间复杂度是一个坏迹象，可能意味着未来可能存在的可扩展性问题。
- en: If, with time, the total memory used by the program constantly grows and never
    goes down, it most likely indicates a memory leak.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序使用的总内存随时间不断增长而且从不减少，很可能表明存在内存泄漏问题。
- en: It helps us assess ideas for a better algorithm as an optimization
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它帮助我们评估作为优化算法的更好想法
- en: 'Another amazing use case for complexities is quickly assessing algorithmic
    optimizations without implementing them. For our `Sum` example, we don’t need
    extreme algorithmic skills to know that we don’t need to buffer the whole file
    in memory. If we want to save memory, we should be able to have a small buffer
    for parsing purposes. Let’s describe an improved algorithm:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性优化的另一个惊人用例是快速评估算法优化而不实现它们。对于我们的`Sum`示例，我们不需要极端的算法技能来知道我们不需要在内存中缓冲整个文件。如果我们想节省内存，我们应该能够有一个用于解析目的的小缓冲区。让我们描述一个改进的算法：
- en: We open the input file without reading anything.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开输入文件而不读取任何内容。
- en: We create a 4 KB buffer, so we need at least 4 KB of memory, which is still
    a constant amount (*Θ*(1)).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个4 KB的缓冲区，因此我们至少需要4 KB的内存，这仍然是一个恒定的量（*Θ*(1)）。
- en: 'We read the file in 4 KB chunks. For every chunk:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以4 KB的块读取文件。对于每个块：
- en: We parse the number.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们解析数字。
- en: We add it to a temporary partial sum.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其添加到临时部分和。
- en: Such an improved algorithm, in theory, should give us the space complexity of
    ~4 KB, so *O*(1). As a result, our [Example 4-1](ch04.html#code-sum) could use
    7,800 times less space for 1 million integers! So we can tell without implementation
    that such optimization on an algorithmic level would be very beneficial, and you
    will see it in action in [“Optimizing Memory Usage”](ch10.html#ch-opt-mem-example).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这样改进的算法应该给出约4 KB的空间复杂度，因此*O*(1)。因此，我们的[示例 4-1](ch04.html#code-sum)对100万个整数可以使用少7,800倍的空间！因此，我们可以在不实现的情况下说，算法级别的这种优化将非常有益，并且你将在[“优化内存使用”](ch10.html#ch-opt-mem-example)中看到其效果。
- en: Doing such complexity analysis can quickly assess your ideas for improvement
    without needing the full TFBO loop!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这种复杂性分析可以快速评估你的改进想法，而不需要完整的TFBO循环！
- en: Worse Is Sometimes Better!
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有时候更糟糕也是更好的！
- en: If we decide to implement the algorithm with better asymptotic or theoretical
    complexity, don’t forget to assess it at the code level using benchmarks! When
    designing an algorithm, we often optimize for asymptotic complexity, but when
    we write code, we optimize the constants of that asymptotic complexity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用更好的渐进或理论复杂性来实现算法，请不要忘记使用基准代码级别进行评估！在设计算法时，我们通常会优化渐进复杂性，但在编写代码时，我们优化这种渐进复杂性的常数。
- en: Without good measurements, you might implement a good algorithm in terms of
    Big O complexity, but with the inefficient code, make efficiency optimizations
    instead of improvement!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有良好的测量，你可能会按照大 O 复杂度实现一个好算法，但由于代码效率低下，做效率优化而不是改进！
- en: It tells us where the bottleneck is and what part of the algorithm is critical
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它告诉我们瓶颈在哪里，算法的哪个部分是关键的。
- en: Finally, a quick look at the detailed space complexity, especially when mapped
    to the source code as in [Example 7-1](#code-sum-compl), is a great way to determine
    the efficiency bottleneck. We can see that the constant 24 is the biggest one,
    and it comes from the `bytes.Split` function that we will optimize first in [Chapter 10](ch10.html#ch-opt).
    In practice, however, profiling can yield data-driven results much faster, so
    we will focus on this method in [Chapter 9](ch09.html#ch-observability3).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，特别是当映射到源代码中，详细的空间复杂度如 [示例 7-1](#code-sum-compl) ，是确定效率瓶颈的绝佳方式。我们可以看到，常数 24
    是其中最大的，它来自于 `bytes.Split` 函数，我们将在 [第 10 章](ch10.html#ch-opt) 中首先进行优化。然而，在实践中，性能分析可以更快地产生数据驱动的结果，因此我们将在
    [第 9 章](ch09.html#ch-observability3) 中重点关注这种方法。
- en: To sum up, the wider knowledge about the complexity and ability to mix basic
    measurements with theoretical asymptotic taught me that complexities could be
    useful. It can be an excellent tool for more theoretical efficiency assessment
    if used correctly. However, as you can see, the real value is when we mix empirical
    measurements with theory. With this in mind, let’s learn more about benchmarking!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，对复杂性的广泛知识以及将基本测量与理论渐近结合起来的能力教会了我，复杂性可能是有用的。如果正确使用，它可以是更理论效率评估的优秀工具。然而，正如你所见，真正的价值在于我们将经验测量与理论结合起来时。记住这一点，让我们更深入地了解基准测试！
- en: The Art of Benchmarking
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试的艺术
- en: Assessing efficiency is essential in the TFBO flow, represented by step 4 in
    [Figure 3-5](ch03.html#img-opt-flow). Such evaluation of our code, algorithm,
    or system is generally a complex problem, achievable in many ways. For example,
    we discussed assessing efficiency on the algorithm level through research, static
    analysis, and Big O notations for runtime complexity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TFBO 流程中评估效率是至关重要的，如图 3-5 中的第 4 步 [Figure 3-5](ch03.html#img-opt-flow) 所示。通过研究、静态分析和
    Big O 表示法对运行时复杂度的算法级别进行效率评估通常是一个复杂的问题，有多种实现方式。
- en: We can assess a lot by performing a theoretical analysis and estimating code
    efficiency. Still, in many cases, the most reliable way is to get our hands dirty,
    run some code, and see things in action. As we learned in [“Optimization Challenges”](ch03.html#ch-conq-challenges),
    we are bad at estimating the resource consumption of our code, so empirical assessments
    allow us to reduce the number of guesses in our evaluations.^([11](ch07.html#idm45606829937408))
    Ideally, we assume nothing and verify the efficiency using special testing processes
    that test efficiency instead of correctness. We call those tests *benchmarks*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行理论分析和估计代码效率，我们可以评估很多内容。然而，在许多情况下，最可靠的方法是亲自动手，运行一些代码并看看实际情况。正如我们在 [“优化挑战”](ch03.html#ch-conq-challenges)
    中所学到的，我们不擅长估算我们代码的资源消耗，因此经验评估允许我们在评估中减少猜测的数量。^([11](ch07.html#idm45606829937408))
    理想情况下，我们什么都不假设，并使用专门测试过程验证效率，这些测试专注于效率而不是正确性。我们称这些测试为 *基准测试* 。
- en: Benchmarking Versus Stress and Load Tests
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试与压力和负载测试
- en: There are many alternative names for benchmarking, such as stress tests, performance
    tests, and load tests. However, since they generally mean the same, for consistency,
    I will use benchmarking in this book.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基准测试有许多替代名称，如压力测试、性能测试和负载测试。然而，它们通常指的是同样的内容，为保持一致性，本书中将统一使用基准测试这一术语。
- en: 'Generally, benchmarking is an effective efficiency assessment method for our
    software or systems. In abstract, the process of benchmarking is composed of four
    core parts, which we describe logically as a simple function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基准测试是我们软件或系统的有效效率评估方法。抽象地说，基准测试的过程由四个核心部分组成，我们将其逻辑描述为一个简单函数：
- en: <math><mrow><mi>B</mi> <mi>e</mi> <mi>n</mi> <mi>c</mi> <mi>h</mi> <mi>m</mi>
    <mi>a</mi> <mi>r</mi> <mi>k</mi> <mo>=</mo> <mi>N</mi> <mo>*</mo> <mo>(</mo> <mi>E</mi>
    <mi>x</mi> <mi>p</mi> <mi>e</mi> <mi>r</mi> <mi>i</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mo>+</mo> <mi>M</mi> <mi>e</mi> <mi>a</mi> <mi>s</mi> <mi>u</mi> <mi>r</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo> <mo>+</mo>
    <mi>C</mi> <mi>o</mi> <mi>m</mi> <mi>p</mi> <mi>a</mi> <mi>r</mi> <mi>i</mi> <mi>s</mi>
    <mi>o</mi> <mi>n</mi></mrow></math>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <math><mrow><mi>B</mi> <mi>e</mi> <mi>n</mi> <mi>c</mi> <mi>h</mi> <mi>m</mi>
    <mi>a</mi> <mi>r</mi> <mi>k</mi> <mo>=</mo> <mi>N</mi> <mo>*</mo> <mo>(</mo> <mi>E</mi>
    <mi>x</mi> <mi>p</mi> <mi>e</mi> <mi>r</mi> <mi>i</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mo>+</mo> <mi>M</mi> <mi>e</mi> <mi>a</mi> <mi>s</mi> <mi>u</mi> <mi>r</mi>
    <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo> <mo>+</mo>
    <mi>C</mi> <mi>o</mi> <mi>m</mi> <mi>p</mi> <mi>a</mi> <mi>r</mi> <mi>i</mi> <mi>s</mi>
    <mi>o</mi> <mi>n</mi></mrow></math>
- en: 'At the core of any benchmarking, we have the experimentations and measurements
    cycle:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何基准测试的核心是实验和测量周期：
- en: Experiment
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实验
- en: The act of simulating a specific functionality of our software to learn about
    its efficiency behavior. We can scope that experiment to a single Go function
    or Go structure or even complex, distributed systems. For example, if your team
    develops the web server, it might mean starting a web server and performing a
    single HTTP request with realistic data that the user would use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟软件特定功能以了解其效率行为的行为。我们可以将实验范围限定到单个 Go 函数或 Go 结构，甚至是复杂的分布式系统。例如，如果您的团队开发 Web
    服务器，这可能意味着启动 Web 服务器并执行具有真实数据的单个 HTTP 请求，用户可能会使用这些数据。
- en: Measurement
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 测量
- en: In [Chapter 6](ch06.html#ch-observability), we discussed getting accurate measurements
    for latency and the consumption of various resources. It’s vital to reliably observe
    our software during the entire experiment to make meaningful conclusions when
    it ends. For our web server example, this might mean measuring the latency of
    the operations on various levels (e.g., client and server latencies), as well
    as the memory consumption of our web server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](ch06.html#ch-observability)中，我们讨论了如何准确测量延迟和各种资源的消耗。在整个实验过程中可靠地观察我们的软件是至关重要的，以便在实验结束时得出有意义的结论。以我们的
    Web 服务器为例，这可能意味着测量不同层次上操作的延迟（例如客户端和服务器的延迟），以及我们的 Web 服务器的内存消耗。
- en: 'Now the unique part of our benchmarking process is that the experiment and
    measurements cycle has to be performed *N* times with the comparison phase at
    the end:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基准测试过程中独特的部分是，实验和测量周期必须执行*N*次，并在最后进行比较阶段。
- en: The number of test iterations (N)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试迭代次数（N）
- en: '*N* is the number of test iterations we must perform to build enough confidence
    in the results. The exact number of runs depends on many factors, which we will
    discuss in [“Reliability of Experiments”](#ch-obs-rel). Generally, the more iterations
    we do, the better. In many cases, we have to balance between higher confidence
    and cost or wait time of a too large number of iterations.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*是我们必须执行的测试迭代次数，以在结果方面建立足够的信心。运行的确切次数取决于许多因素，我们将在[“实验的可靠性”](#ch-obs-rel)中讨论这些因素。一般来说，我们需要在更高的信心和成本或等待时间之间取得平衡，以避免过多的迭代次数。'
- en: Comparison
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 比较
- en: Finally, in the benchmarking definition, we have [the comparison aspect](https://oreil.ly/kzNR3),
    which allows us to learn what’s improving the efficiency of our software, what’s
    hindering it, and how far we are from the expectations (RAER).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在基准测试的定义中，我们有[比较方面](https://oreil.ly/kzNR3)，这使我们能够了解我们的软件效率的提升、阻碍以及与期望（RAER）的距离。
- en: In many ways, you might notice that benchmarking is similar to the testing we
    do to verify correctness (referred to later as functional testing). As a result,
    many testing practices apply to benchmarking. Let’s look at that next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，您可能会注意到基准测试与我们进行的验证正确性的测试（后文称为功能测试）相似。因此，许多测试实践也适用于基准测试。接下来让我们来看看这一点。
- en: Comparison to Functional Testing
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与功能测试比较
- en: 'Comparison to something we are familiar with is one of the best ways to learn.
    So, let’s compare benchmarking to functional testing. Is there anything we can
    reuse in terms of methodology or practices? You will learn in this chapter that
    we can share many things between functional tests and benchmarking. For example,
    there are a few similar aspects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们熟悉的某些东西进行比较是学习的最佳方式之一。因此，让我们比较基准测试和功能测试。在方法论或实践方面是否有什么可以重用的东西？在本章中，您将了解到功能测试和基准测试之间可以共享许多内容。例如，有一些相似的方面：
- en: Best practices for forming test cases (e.g., [edge cases](https://oreil.ly/Sw9qB)),
    [table-driven testing](https://oreil.ly/Q3bXD), and regression testing
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为形成测试用例的最佳实践（例如，[边缘案例](https://oreil.ly/Sw9qB)）、[表驱动测试](https://oreil.ly/Q3bXD)和回归测试
- en: Splitting tests into [unit, integration, e2e](https://oreil.ly/tvaMk), and testing
    in production (more on that in [“Benchmarking Levels”](#ch-obs-benchmarking))
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试分割成[unit, integration, e2e](https://oreil.ly/tvaMk)，并在生产中进行测试（更多信息请参见[“基准测试级别”](#ch-obs-benchmarking)）
- en: Automation for continuous testing
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续测试的自动化
- en: 'Unfortunately, we have to also be aware of significant differences. With benchmarks:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们也必须意识到重大差异。通过基准：
- en: We have to have different [test cases and test data](https://oreil.ly/me3cM).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须有不同的[测试用例和测试数据](https://oreil.ly/me3cM)。
- en: It might be tempting, but we cannot reuse the same test data (input parameters,
    potential fake, test data in a database, etc.) as we used for our unit or integrations
    tests meant for correctness tests. This is because the goals are different. In
    correctness tests, we tend to focus on different [edge cases](https://oreil.ly/Sw9qB)
    from a functional perspective (e.g., failure modes). Whereas in efficiency tests,
    the edge cases are usually focused on triggering different efficiency issues (e.g.,
    big requests versus many small requests). We will discuss these in [“Reproducing
    Production”](#ch-obs-rel-repro).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很诱人，但我们不能重复使用与用于正确性测试的单元或集成测试相同的测试数据（输入参数、潜在伪造、数据库中的测试数据等）。这是因为目标不同。在正确性测试中，我们倾向于从功能角度考虑不同的[边缘案例](https://oreil.ly/Sw9qB)（例如，故障模式）。而在效率测试中，边缘案例通常专注于触发不同的效率问题（例如，大请求与许多小请求）。我们将在[“重现生产”](#ch-obs-rel-repro)中讨论这些内容。
- en: 'For most systems, though, the programmer should monitor the program on input
    data that is typical of the data the program will encounter in production. Note
    that usual test data often does not meet this requirement: while test data is
    chosen to exercise all parts of the code, profiling [and benchmarking] data should
    be chosen for its “typicality.”'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于大多数系统而言，程序员应当监控输入数据以符合程序将在生产中遇到的数据。请注意，通常的测试数据通常不符合此要求：虽然测试数据被选择以执行代码的所有部分，但是分析[和基准]数据应被选择为其“典型性”。
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jon Louis Bentley, *Writing Efficient Programs*
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 乔恩·路易斯·本特利，《编写高效程序》
- en: Embrace the performance nondeterminism
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 拥抱性能非确定性
- en: Modern software and hardware consist of layers of complex optimizations. This
    can cause nondeterministic conditions to change while performing our benchmarks,
    which might mean that the results will also be nondeterministic. We will expand
    on this in [“Reliability of Experiments”](#ch-obs-rel), but this is why we usually
    repeat test iteration cycles hundreds if not thousands of times (our *N* component)
    to increase confidence in our observations. The main goal here is to figure out
    how repeatable our benchmark is. If the variance is too high, we know we cannot
    trust the results and must mitigate the variance. This is why we rely on statistics
    in our benchmarks, which helps a lot, but also makes it easy to mislead others
    and ourselves.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件和硬件由复杂优化层组成。这可能导致在执行基准测试时出现非确定性条件的变化，这可能意味着结果也将是不确定的。我们将在[“实验的可靠性”](#ch-obs-rel)中进一步扩展，但这就是为什么我们通常重复测试迭代周期数百次，甚至成千上万次（我们的*N*组件），以增加对我们观察的信心。这里的主要目标是确定我们的基准测试有多重复。如果方差过高，我们知道我们不能信任结果，必须降低方差。这就是为什么我们在基准测试中依赖统计数据的原因，这确实很有帮助，但也很容易误导他人和自己。
- en: 'Repeatability: Ensuring that the same operations are benchmarked on all configurations
    and that metrics are repeatable over many test runs. Rule of thumb is a variation
    of up to 5% is generally acceptable.'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可重复性：确保在所有配置上进行基准测试相同操作，并且度量在多次测试运行中可重复。经验法则是变异率高达5%通常是可以接受的。
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Bob Cramblitt, [“Lies, Damned Lies, and Benchmarks: What Makes a Good Performance
    Metric”](https://oreil.ly/ghvJ7)'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 鲍勃·克兰布里特，《谎言、该死的谎言和基准测试：什么构成一个良好的性能度量》
- en: It is more expensive to write and run
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和运行起来更加昂贵
- en: As you can imagine, the number of iterations we have to perform increases the
    running cost and complexity of performing the benchmark, both the compute cost
    and developer time spent on creating those and waiting. But that is not the only
    additional cost compared to correctness tests. To trigger efficiency problems,
    especially for large systems load tests, we have to exhaust different systems
    capacities, which means buying a lot of computing power just for the sake of tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以想象的那样，我们需要执行的迭代次数增加了运行成本和基准测试的复杂性，包括计算成本和开发人员用于创建这些基准测试和等待的时间。但与正确性测试相比，这并不是唯一的额外成本。为了触发效率问题，特别是对于大型系统的负载测试，我们必须耗尽不同系统的容量，这意味着仅仅为了测试而购买大量的计算能力。
- en: This is why we have to focus on a pragmatic optimization process where we only
    care about efficiency where necessary. There are also ways to be smart and avoid
    full-scale macrobenchmarks by using tactical microbenchmarks of isolated functions,
    as discussed in [“Benchmarking Levels”](#ch-obs-benchmarking).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们必须专注于实用的优化过程，只关心必要的效率。还有一些方法可以通过使用战术性的、隔离功能的微基准测试，而避免使用全面的宏基准测试，正如在[“基准测试水平”](#ch-obs-benchmarking)中讨论的那样。
- en: Expectations are less specific
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 期望不那么具体
- en: Correctness tests always end up with some assertions. For example, in Go tests,
    we check if the result of the functions has the expected value. If not, we use
    `t.Error` or `t.Fail` to indicate the test should fail (or one-liners like [`testutil.Ok`](https://oreil.ly/ncVhq)
    or [`testutil.Equals`](https://oreil.ly/uH1F5)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性测试总是以一些断言结束。例如，在Go测试中，我们检查函数的结果是否具有预期值。如果不是，我们使用`t.Error`或`t.Fail`来指示测试应该失败（或者使用一行代码，例如[`testutil.Ok`](https://oreil.ly/ncVhq)或[`testutil.Equals`](https://oreil.ly/uH1F5)）。
- en: It would be amazing if we could do the same when benchmarking—asserting if the
    latency and resource consumption are not exceeding the RAER. Unfortunately, we
    cannot just do `if maxMemoryConsumption < 200 * 1024 * 1024` at the end of a microbenchmark.
    The typical high variance of the results, challenges in isolating the latency
    and resource consumption to just one functionality we test, and other problems
    mentioned in [“Reliability of Experiments”](#ch-obs-rel) make it hard to automate
    the assertion process. Typically, there has to be human or very complex anomaly
    detection or assertion software to understand whether the results are acceptable.
    Hopefully, we will see more tools that make it easier in the future.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在进行基准测试时也能做到同样就太棒了——断言延迟和资源消耗是否未超过RAER。不幸的是，在微基准测试的结尾并不能简单地执行`if maxMemoryConsumption
    < 200 * 1024 * 1024`。结果的高变异性，难以将延迟和资源消耗隔离到我们测试的单个功能中，以及其他在[“实验可靠性”](#ch-obs-rel)中提到的问题，使得自动化断言过程变得困难。通常情况下，必须依靠人工或非常复杂的异常检测或断言软件来判断结果是否可接受。希望在未来会看到更多使这一过程变得更加简便的工具。
- en: To make things harder, we might have a RAER for bigger APIs and functionalities.
    But if the RAER says the latency of the whole HTTP request should be lower than
    the 20s, what does that mean for the single Go function involved in this request
    (out of thousands)? How much latency should we expect in microbenchmarks used
    by this function? There is no good answer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加难度，我们可能会对更大的API和功能性引入RAER。但是，如果RAER说整个HTTP请求的延迟应低于20秒，这对于涉及此请求的单个Go函数（成千上万个函数中的一个）意味着什么？我们在使用该函数的微基准测试中应该期待多少延迟？这个问题没有一个确切的答案。
- en: We Focus More on Relative Results than Absolute Numbers!
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们更关注相对结果而不是绝对数字！
- en: In benchmarks, we usually don’t assert absolute values. Instead, we focus on
    comparing results to some baseline (e.g., the previous benchmark before our code
    change). This way, we know if we improved or negatively affected the efficiency
    of a single component without looking at the big picture. This is usually enough
    on the unit microbenchmarks level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试中，我们通常不断言绝对值。相反，我们专注于将结果与某些基准（例如，在我们代码更改之前的先前基准）进行比较。通过这种方式，我们可以知道是否改进或对单个组件的效率产生了负面影响，而不必关注整体情况。这通常足够在单元微基准测试级别上使用。
- en: With the basic concept of benchmarking explained, let’s address the elephant
    in the room in the next section—the stereotype that associates benchmarks with
    lies. Unfortunately, there are [solid reasons for this relation](https://oreil.ly/yotxL).
    Let’s unpack this and see how we can tell if we can trust the benchmarks that
    we or others do.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了基准测试的基本概念之后，让我们在下一节中解决其中的一个悬而未决问题——将基准测试与谎言联系在一起的刻板印象。不幸的是，对于这种关系，存在[充分的理由](https://oreil.ly/yotxL)。让我们深入探讨一下，看看我们如何判断我们或他人进行的基准测试是否可信。
- en: Benchmarks Lie
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试会说谎
- en: 'There is an extension to a [famous phrase](https://oreil.ly/xULP5) that states
    that we can order the following words from the best to worst: “lies, damn lies,
    and benchmarks.”'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个扩展到一个[著名短语](https://oreil.ly/xULP5)的说法指出，我们可以按从最好到最差的顺序排列以下词语：“谎言、该死的谎言和基准测试”。
- en: 'This interest in performance has not gone unnoticed by the computer vendors.
    Just about every vendor promotes their product as being faster or having better
    “bang for the buck.” All of this performance marketing begs the question: “How
    can these competitors all be the fastest?” The truth is that computer performance
    is a complex phenomenon, and who is fastest all depends upon the particular simplifications
    being employed to present a particular simplistic conclusion.'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对性能的兴趣并未被计算机供应商忽视。几乎每个供应商都宣传其产品更快或者“性价比更高”。所有这些性能营销都引发了一个问题：“这些竞争对手怎么都声称自己是最快的呢？”事实上，计算机性能是一个复杂的现象，谁最快完全取决于用来得出特定简化结论的具体方法。
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alexander Carlton, [“Lies, Damn Lies, and Benchmarks”](https://oreil.ly/WClsq)
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亚历山大·卡尔顿，[“谎言、该死的谎言和基准测试”](https://oreil.ly/WClsq)
- en: Cheating in benchmarks is indeed widespread. The efficiency results through
    benchmarks have significant importance in a competitive market. Users have too
    many choices to make, so simplifying the comparison to a simple question, “which
    is the fastest solution?” or “which one is the most scalable?” is common among
    decision-makers. As a result, benchmarking became [a gamification system that
    is cheated on](https://oreil.ly/4NAVh). The fact that efficiency assessment is
    very complex to get right and expensive to reproduce makes it easy to get away
    with a misleading conclusion. There are many examples of companies, vendors, and
    individuals lying in benchmarks.^([12](ch07.html#idm45606829843312)) However,
    it is essential to highlight that not all cases are done intentionally or with
    malicious intent. For better or worse, in most cases, the author did not purposely
    report misleading results. It’s only natural to get tricked by [statistical fallacies](https://oreil.ly/jPxnA)
    and paradoxes that are counterintuitive to the human brain.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试中作弊确实很普遍。在竞争激烈的市场中，基准测试的效率结果具有重要意义。用户面对太多选择，所以简化比较到一个简单的问题，“哪个是最快的解决方案？”或“哪一个最具可伸缩性？”是决策者的共同做法。因此，基准测试演变成了[一个被欺骗的游戏化系统](https://oreil.ly/4NAVh)。事实上，效率评估非常复杂且昂贵，因此误导性结论很容易逃脱追究。有很多公司、供应商和个人在基准测试中撒谎。^([12](ch07.html#idm45606829843312))
    然而，需要强调的是，并非所有情况都是有意或者恶意的。在大多数情况下，作者并非故意报告误导性结果。对于人类大脑来说，被[统计谬误](https://oreil.ly/jPxnA)和悖论误导是再正常不过的了。
- en: Benchmarks Don’t Lie; We Just Misinterpret the Results!
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试不会说谎；我们只是误解了结果！
- en: There are many ways we can make wrong conclusions from benchmarks. If done accidentally,
    it can have severe consequences—usually a big waste of time and money. If done
    intentionally…​well, lies have short legs. :)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方式会导致我们从基准测试中得出错误的结论。如果无意中发生，后果可能很严重——通常会造成大量时间和金钱的浪费。如果是有意为之……好吧，谎言终究难以长久。
- en: We can be misled by benchmarks due to human mistakes, benchmarks performed under
    conditions irrelevant to us and our problem, or simply statistical error. The
    benchmark results themselves don’t lie; we might have just measured the wrong
    thing!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会因为人为错误、在与我们及我们问题无关的条件下进行的基准测试，或者简单的统计误差而被基准测试误导。基准测试结果本身并不会说谎；我们可能只是在测量错误的东西！
- en: The solution is to be a mindful consumer or developer of those benchmarks, plus
    learn the basics of data science. We will discuss common mistakes and solutions
    in [“Reliability of Experiments”](#ch-obs-rel).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是成为那些基准测试的审慎消费者或开发者，并学习数据科学的基础知识。我们将在[“实验的可靠性”](#ch-obs-rel)中讨论常见的错误和解决方案。
- en: To overcome some biases that are naturally happening in the benchmarks, industries
    often come up with some standards and certifications. For example, to ensure fair
    fuel economy efficiency assessments, [all light-duty vehicles in the US are required
    to have their economy results tested by the US Environmental Protection Agency
    (EPA)](https://oreil.ly/gKOc2). Similarly, in Europe, in response to the 40% gap
    between the fuel economy carmakers’ tests and reality, [the EU adopted the Worldwide
    Harmonized Light-Duty Vehicle Test Cycle and Procedure](https://oreil.ly/LPUXj).
    For hardware and software, many independent organizations design consistent benchmarks
    for specific requirements. [SPEC](https://oreil.ly/tkV6O) and [Percona HammerDB](https://oreil.ly/ngRKu)
    are two examples out of many.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服基准测试中自然发生的一些偏见，行业经常提出一些标准和认证。例如，为了确保公平的燃油经济效率评估，[美国所有轻型车辆都要求由美国环境保护署（EPA）进行燃油经济结果测试](https://oreil.ly/gKOc2)。类似地，在欧洲，为了应对汽车制造商测试和实际情况之间的40%差距，[欧盟采用了全球统一轻型车辆测试循环和程序](https://oreil.ly/LPUXj)。对于硬件和软件，许多独立组织设计了特定要求的一致基准测试。[SPEC](https://oreil.ly/tkV6O)和[Percona
    HammerDB](https://oreil.ly/ngRKu)是众多例子中的两个。
- en: To overcome both lies and honest mistakes, we must focus on understanding what
    factors make benchmarks unreliable and what we can do to improve that quality.
    It’s foundational knowledge explaining many benchmark practices we will discuss
    in [Chapter 8](ch08.html#ch-benchmarking). Let’s do that in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要克服谎言和诚实错误，我们必须专注于理解什么因素使基准测试不可靠，以及我们可以做些什么来提高质量。这是解释我们将在[第8章](ch08.html#ch-benchmarking)讨论的许多基准实践的基础知识。让我们在下一节中做这件事。
- en: Reliability of Experiments
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验的可靠性
- en: The TFBO cycle takes time. No matter on what level we assess and optimize efficiency,
    in all cases, it is necessary to spend a nontrivial amount of time on implementing
    benchmarks, executing them, interpreting results, finding bottlenecks, and trying
    new optimizations. It is frustrating if all or part of our efforts are wasted
    due to unreliable assessments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TFBO周期需要时间。无论我们在哪个级别评估和优化效率，都需要花费大量时间来实施基准测试、执行它们、解释结果、查找瓶颈并尝试新的优化。如果我们的所有或部分努力由于不可靠的评估而被浪费，这是令人沮丧的。
- en: As mentioned when explaining benchmarking lies, there are many reasons why benchmarks
    are prone to misleading us. There are a set of common challenges it’s useful to
    be aware of.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在解释基准测试谎言时提到的那样，有许多原因会导致基准测试误导我们。有一组常见的挑战值得我们注意。
- en: The Same Applies to Bottleneck Analysis!
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓶颈分析也是如此！
- en: In this chapter, we might be discussing benchmarks, so experiments mainly allow
    us to measure our efficiency (latency or resource consumption), but similar reliability
    concerns can be applied to other experiments or measurements around efficiency.
    For example, profiling our Go programs to find bottlenecks, discussed in [Chapter 9](ch09.html#ch-observability3).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们可能会讨论基准测试，因此实验主要允许我们衡量我们的效率（延迟或资源消耗），但类似的可靠性问题也适用于围绕效率的其他实验或测量。例如，我们对Go程序进行剖析以找出瓶颈，详细讨论在[第9章](ch09.html#ch-observability3)。
- en: 'We can outline three common challenges to the reliability of benchmarks: human
    errors, the relevance of our experiments to the production environment, and the
    nondeterministic efficiency of modern computers. Let’s go through these in the
    next sections.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以概述基准测试可靠性面临的三个常见挑战：人为错误、我们的实验与生产环境的相关性，以及现代计算机的非确定性效率。我们将在接下来的几节中详细讨论这些问题。
- en: Human Errors
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人为错误
- en: Optimizations and benchmarking routines, as it stands today, involve a lot of
    manual work from developers. We need to run experiments with different algorithms
    and code, while caring about reproducing production and performance nondeterminism.
    Due to the manual nature, this is prone to human error.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 优化和基准测试例程，正如今天的情况所示，涉及开发人员大量的手动工作。我们需要运行具有不同算法和代码的实验，同时关注再现生产和性能的非确定性。由于手动性质，这容易出现人为错误。
- en: It’s easy to get lost in what optimizations we already tried, what code you
    added for debugging purposes, and what is meant to be saved. It is also easy to
    get confused about what version of code the benchmarking results belong to and
    what assumptions you already proved wrong.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易迷失在我们已经尝试过的优化、为调试目的添加的代码和需要保存的内容之间。同样，很容易混淆代码版本与基准测试结果归属以及您已经证明错误的假设。
- en: Many problems with our benchmarks tend to be caused by our sloppiness and lack
    of organization. Unfortunately, I am guilty of many of those mistakes too! For
    example, when I thought I was benchmarking optimization X, I discarded it after
    seeing no significant difference in benchmarking results. Only some hours later
    did I notice I tested the wrong code, and optimization X was helpful!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的许多基准测试问题往往是由于粗心和缺乏组织引起的。不幸的是，我也犯了许多这些错误！例如，当我以为我在基准测试优化X时，我在看到基准测试结果没有显著差异后就放弃了它。几个小时后，我才注意到我测试了错误的代码，而优化X是有帮助的！
- en: 'Fortunately, there are some ways to reduce those risks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些方法可以减少这些风险：
- en: Keep it simple.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 保持简单。
- en: Try to iterate with code changes related to efficiency in the smallest iterations
    possible. If you try to optimize multiple elements of your code simultaneously,
    it most likely will obfuscate your benchmark results. You might miss that one
    of those optimizations limits the efficiency of the aspect you are interested
    in.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能用最小的迭代次数进行与效率相关的代码更改。如果你试图同时优化代码的多个元素，很可能会混淆你的基准测试结果。你可能会忽略其中一个优化会限制你感兴趣的方面的效率。
- en: Similarly, try to isolate complex parts into smaller separate parts you can
    optimize and assess separately (divide and conquer).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，尝试将复杂的部分隔离为可以单独优化和分析的较小部分（分而治之）。
- en: Know what version of software you are benchmarking.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你正在进行基准测试的软件版本。
- en: It might be trivial, but it’s worth repeating—use [software versioning](https://oreil.ly/P0eoP)!
    If you try different optimizations, commit them in separate commits and distribute
    them across separate branches so you can get back to previous versions if needed.
    Don’t lose your optimization effort by forgetting to commit your work at the end
    of the day.^([13](ch07.html#idm45606829807072))
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能微不足道，但值得重复——使用[软件版本控制](https://oreil.ly/P0eoP)！如果你尝试不同的优化，将它们分别提交并分布在不同的分支中，这样你就可以在需要时回到以前的版本。不要因为忘记在一天结束时提交你的工作而丧失你的优化努力。^([13](ch07.html#idm45606829807072))
- en: This also means you have to be strict about what version of code you just benchmarked.
    Even a small reorder of seemingly unrelated statements might impact your code’s
    efficiency, so always benchmark your programs in atomic iterations. This also
    includes all dependencies your code needs, for example, those outlined in your
    *go.mod* file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你必须严格控制刚刚基准测试过的代码版本。即使是对看似无关的语句进行小小的重排，也可能影响代码的效率，因此请始终在原子迭代中基准测试你的程序。这也包括你的代码所需的所有依赖项，例如在你的*go.mod*文件中列出的依赖。
- en: Know what version of benchmark you are using.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你正在使用的基准测试版本。
- en: Furthermore, remember to version the code of the benchmark test itself! Avoid
    comparing results between different benchmark implementations, even if the change
    was minor (adding an extra check).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，记得对基准测试本身的代码进行版本控制！避免比较不同基准测试实现的结果，即使变更很小（增加额外的检查）。
- en: Scripting scripts to execute those benchmarks with the same configuration and
    versioning those is also a great way not to get lost. In [Chapter 8](ch08.html#ch-benchmarking),
    I mention some best practices around declarative ways to share benchmark options
    for your future self and others on your team.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本来执行这些基准测试，并对它们进行相同的配置和版本控制，这也是不迷失的好方法。在[第8章](ch08.html#ch-benchmarking)中，我提到了一些关于以声明方式共享基准测试选项的最佳实践，以便你将来自己和团队的其他成员使用。
- en: Keep your work well organized and structured.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的工作组织良好和结构化。
- en: Make notes, design your own consistent workflow, and be explicit in what version
    of code you experimented with. Track the dependency versions, and track all benchmarking
    results explicitly in a consistent way. Finally, be clear in communicating your
    findings with others.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记录笔记，设计自己的一致工作流程，并明确你试验的代码版本。跟踪依赖版本，并以一致的方式明确跟踪所有基准测试结果。最后，清楚地与他人沟通你的发现。
- en: Your code should also be clean during different code attempts. Keep all best
    practices like [DRY](https://oreil.ly/S887r), don’t keep commented out code, isolate
    state between tests, etc.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码在不同的代码尝试中也应该保持干净。保持所有最佳实践，如[DRY](https://oreil.ly/S887r)，不要保留注释掉的代码，隔离测试之间的状态等。
- en: Be skeptical about “too good to be true” benchmarking results.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对“看似太好而不可信”的基准测试结果保持怀疑态度。
- en: If you can’t explain why your code is suddenly quicker or uses fewer resources,
    you most certainly did something wrong while benchmarking. It is tempting to celebrate,
    accept it, and move on without double-checking.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法解释为什么您的代码突然运行更快或者使用更少的资源，那么您肯定在基准测试时做错了什么。很诱人地庆祝，接受它并继续前进，而不进行双重检查是不明智的。
- en: Check common issues like if your benchmark test cases trigger errors instead
    of successful runs (mentioned in [“Test Your Benchmark for Correctness!”](ch08.html#ch-obs-micro-corr)),
    or perhaps the compiler optimized your microbenchmark away (discussed in [“Compiler
    Optimizations Versus Benchmark”](ch08.html#ch-obs-micro-comp)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 检查常见问题，例如您的基准测试用例是否触发错误而不是成功运行（见[“为正确性测试您的基准！”](ch08.html#ch-obs-micro-corr)）或者编译器是否优化了您的微基准测试（见[“编译器优化与基准测试”](ch08.html#ch-obs-micro-comp)）。
- en: A little bit of laziness in our work is healthy.^([14](ch07.html#idm45606829792768))
    However, laziness at the wrong moment might significantly increase the number
    of unknowns and risks to the already difficult subject of program efficiency optimizations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作中稍微有些懒散是健康的。^([14](ch07.html#idm45606829792768)) 然而，在错误的时刻懒惰可能会显著增加未知因素和风险，使程序效率优化变得更加困难。
- en: Now let’s look at the second key element of reliable benchmarks, relevance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看可靠基准测试的第二个关键元素，即相关性。
- en: Reproducing Production
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制生产环境
- en: It might be obvious, but we don’t optimize software so it can run faster or
    consume fewer resources on our development machine.^([15](ch07.html#idm45606829782464))
    We optimize to ensure the software has efficient enough execution for the target
    destinations that matter for our business, so-called *production*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是显而易见的，但我们并不是为了在我们的开发机器上运行得更快或者消耗更少的资源而优化软件。我们优化的目的是确保软件在对我们业务重要的目标地点上具有足够高效的执行能力，也就是所谓的*生产*。
- en: 'Production might mean a production server environment you deploy if you build
    a backend application, or a customer device like a PC, laptop, or smartphone if
    you build an end-user application. Therefore, we can significantly improve the
    quality of our efficiency assessment for all benchmarks by enhancing their relevance.
    We can do that by trying our best to simulate (reproduce) situations and environmental
    conditions of production. Particularly:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境可能意味着您部署的生产服务器环境（如果您构建后端应用程序），或者客户设备，如PC、笔记本电脑或智能手机（如果您构建面向最终用户的应用程序）。因此，通过增强其相关性来显著提高所有基准的效率评估的质量是完全可行的。我们可以通过尽力模拟（复制）生产的情况和环境条件来实现这一点。特别是：
- en: Production conditions
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 生产条件
- en: The characteristics of a production environment. For example, how much RAM and
    what kind of CPU the production machines will have dedicated for our program.
    What OS version does it have? What versions and kinds of dependencies will our
    program use?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境的特性。例如，生产机器将为我们的程序专门分配多少RAM和何种类型的CPU？它使用哪个操作系统版本？我们的程序将使用哪些版本和类型的依赖关系？
- en: Production workload
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生产工作负载
- en: The data our program will work with and the behavior of the user traffic it
    has to handle.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将处理的数据以及必须处理的用户流量的行为。
- en: Perhaps the first thing we should do is to gather requirements around the software
    target destination, ideally in written form in our RAER. Without it, we can’t
    correctly assess the efficiency of our software. Similarly, if you see benchmarks
    done by a vendor or independent entity, you should check if the benchmark conditions
    match your production and requirements. Typically, they don’t, and to fully trust
    it, we should try to reproduce such a benchmark on our side.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们应该首先做的是围绕软件目标目的地收集需求，最好以书面形式记录在我们的RAER中。如果没有它，我们无法正确评估我们软件的效率。同样，如果您看到供应商或独立实体完成的基准测试，请检查基准条件是否与您的生产和要求相匹配。通常情况下，它们并不匹配，为了完全信任它，我们应该尝试在我们这边复制这样的基准测试。
- en: 'Assuming we roughly know what the target production for our software looks
    like, we might start designing our benchmark flow, test data, and cases. The bad
    news is that it’s impossible to fully reproduce every aspect of production in
    our development or testing environment. There will always be differences and unknowns.
    There are many reasons why production will be different:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们大致知道我们软件的目标生产环境是什么样的，我们可以开始设计我们的基准流程、测试数据和用例。坏消息是，在我们的开发或测试环境中，完全复制生产的每一个方面是不可能的。总会存在差异和未知因素。生产环境将会有很多不同的原因：
- en: Even if we run the same kind and version of the OS as production, it is impossible
    to reproduce the dynamic state of the OS, which impacts efficiency. In fact, we
    cannot fully reproduce this state between two runs on the same local machine!
    This challenge is often called nondeterministic performance, and we will discuss
    it in [“Performance Nondeterminism”](#ch-obs-rel-unkn).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们运行与生产环境相同类型和版本的操作系统，也无法复制操作系统的动态状态，这会影响效率。事实上，在同一台本地机器上的两次运行之间，我们无法完全复制这种状态！这个挑战通常被称为非确定性性能，并且我们将在[“性能的非确定性”](#ch-obs-rel-unkn)中讨论它。
- en: It’s often too expensive to reproduce all kinds of production workloads that
    can happen (e.g., forking all production traffic and putting it through testing
    clusters).
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常复制所有可能发生的生产工作负载会太昂贵（例如，复制所有生产流量并将其通过测试集群进行分叉）。
- en: When developing an end-user application, there are too many permutations of
    different hardware, dependency software versions, and situations. For example,
    imagine you create an Android app—tons of smartphone models could potentially
    run your software, even if we would limit ourselves to smartphones made in the
    last two years.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发终端用户应用程序时，存在太多不同的硬件、依赖软件版本和情况的排列组合。例如，想象一下您创建了一个Android应用程序——即使我们限制自己只使用过去两年内制造的智能手机，仍然有大量智能手机型号可能运行您的软件。
- en: The good news is that we don’t need to reproduce all aspects of production.
    Instead, it’s often enough to represent key characteristics of the products that
    might limit our workloads. We might know about it from the start of development—but
    with time, experiments, and macrobenchmarks (see [“Macrobenchmarks”](ch08.html#ch-obs-macro)),
    or even production—you will learn what matters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们不需要复制生产环境的所有方面。相反，通常足以表示可能限制我们工作负载的产品的关键特性。我们可能从开发的起始阶段就了解到这一点——但是随着时间、实验和宏观基准测试（参见[“宏观基准测试”](ch08.html#ch-obs-macro)）甚至生产，您将了解哪些是重要的。
- en: 'For example, imagine you develop Go code responsible for uploading local files
    to a remote server, and the users notice unacceptable latency when uploading a
    large file. Based on that, our benchmark to reproduce this should:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，你开发了负责将本地文件上传到远程服务器的 Go 代码，用户在上传大文件时注意到不可接受的延迟。基于此，我们用于复制这一问题的基准应该是：
- en: Focus on test cases that involve big files. Don’t try to optimize a large number
    of small files, all different error cases, and potential encryption layers if
    that doesn’t represent what production users are using the most. Instead, be pragmatic
    and focus with benchmarks on what your goal is now.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于涉及大文件的测试用例。不要试图优化大量不同的小文件、所有不同的错误情况以及潜在的加密层，如果这些不代表大多数生产用户正在使用的内容。相反，务实地专注于基准测试，关注您当前的目标。
- en: Be mindful that your local benchmarks are not reproducing potential network
    latencies and behavior you will see in production. A bug in your code might cause
    resource leaks only in case of a slow network, which might be hard to reproduce
    on your machine. For these optimizations, it’s worth moving with benchmarks to
    different levels, as explained in [“Benchmarking Levels”](#ch-obs-benchmarking).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，您的本地基准测试并未复制可能在生产环境中看到的潜在网络延迟和行为。您代码中的一个 bug 可能仅在网络缓慢时导致资源泄漏，这可能在您的机器上很难复制。为了进行这些优化，值得根据[“基准测试级别”](#ch-obs-benchmarking)中所述，将基准测试移动到不同的级别。
- en: Simulating the “characteristics” of production does not necessarily mean the
    same dataset and workload that will exist on production! For our earlier example,
    you don’t need to create 200 GB test files and benchmark your program with them.
    In many cases, you can start with relatively large files like 5 MB, then 10 MB,
    and together with complexity analysis, deduce what will happen at the 200 GB level.
    This will allow you to optimize those cases much faster and cheaper.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟生产的“特性”并不一定意味着与生产中存在的相同数据集和工作负载！对于我们之前的例子，您不需要创建200GB的测试文件并使用它们来基准测试您的程序。在许多情况下，您可以从相对较大的文件开始，例如5MB，然后是10MB，并结合复杂性分析，推断出在200GB级别会发生什么。这将使您能够更快、更便宜地优化这些情况。
- en: Typically it would be too difficult and inefficient to attempt to exactly reproduce
    a specific workload. A benchmark is usually an abstraction of a workload. It is
    necessary, in this process of abstracting a workload into a benchmark, to capture
    the essential aspects of the workload and represent them in a way that maps accurately.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常情况下，尝试精确复制特定工作负载将会过于困难和低效。基准测试通常是工作负载的一种抽象。在将工作负载抽象为基准测试的过程中，需要捕捉工作负载的关键方面，并以准确映射的方式表示它们。
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alexander Carlton, “Lies, Damn Lies, and Benchmarks”
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亚历山大·卡尔顿，《谎言、该死的谎言和基准测试》
- en: To sum up, when trying to assess the efficiency or reproduce efficiency regressions,
    be mindful of the differences between your testing setup and production. Not all
    of them are worth reproducing, but the first step is to know about those differences
    and how they can impact the reliability of our benchmarks! Let’s now look at what
    else we can do to improve the confidence of our benchmarking experiments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当试图评估效率或复现效率退化时，请注意您的测试设置与生产环境之间的差异。并非所有差异都值得复现，但首要步骤是了解这些差异及其如何影响我们基准测试的可靠性！现在让我们看看还能做些什么来提高基准测试实验的信心。
- en: Performance Nondeterminism
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能的非确定性
- en: Perhaps the biggest challenge with efficiency optimizations is the “nondeterministic
    performance” of modern computers. It means so-called noise, so the variance in
    our experiment results is because of the high complexity of all layers that impacts
    the efficiency we learned about in Chapters [4](ch04.html#ch-hardware) and [5](ch05.html#ch-hardware2).
    As a result, efficiency characteristics are often unpredictable and highly fragile
    to environmental side effects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 效率优化中可能面临的最大挑战是现代计算机的“非确定性性能”。这意味着所谓的噪音，也就是我们实验结果的变化性，是由于影响我们在第 [4](ch04.html#ch-hardware)
    章和第 [5](ch05.html#ch-hardware2) 章学到的效率的各层高复杂性。因此，效率特性通常是不可预测的，极易受环境副作用的影响。
- en: For example, let’s consider a single statement in the Go code, an `a += 4`.
    No matter what conditions this code is executed in, assuming we are the only user
    of memory used by the `a` variable, the result of `a += 4` is always deterministic—a
    value of `a` plus `4`. This is because, in almost all cases, it is hard to impact
    correctness. You can put the computer in extreme heat or cold, you can shake it,
    you can schedule millions of simultaneous processes in the OS, and you can use
    any version of CPU that exists with any supported type of operating system that
    supports that hardware. Unless you do something extreme like influencing the electric
    signal in the memory, or you put the computer out of power, that `a += 4` operation
    will always give us the same result.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑 Go 代码中的单个语句，`a += 4`。不管这段代码在什么条件下执行，假设我们是唯一使用 `a` 变量的内存的用户，`a += 4`
    的结果始终是确定性的——`a` 的值加上 `4`。这是因为，在几乎所有情况下，很难影响正确性。您可以让计算机极度加热或冷却，可以摇晃它，可以在操作系统中安排数百万个同时进程，并且可以使用支持该硬件的任何支持类型的操作系统的任何
    CPU 版本。除非您做一些极端的事情，如影响内存中的电信号，或者让计算机停电，否则 `a += 4` 操作始终会给我们相同的结果。
- en: Now let’s imagine we are interested to learn how our `a += 4` operation contributes
    to the latency in the bigger program. At first glance, the latency assessment
    should be simple—this requires a single CPU instruction (e.g., [`ADDQ`](https://oreil.ly/Vv83D))
    and a single CPU register, so the amortized cost should be as fast as your CPU
    frequency, so, for example, an average of 0.3 ns for 3 GHz CPU.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，我们有兴趣了解我们的 `a += 4` 操作如何影响更大程序的延迟。乍一看，延迟评估应该很简单——这只需要一个 CPU 指令（例如，[`ADDQ`](https://oreil.ly/Vv83D)）和一个
    CPU 寄存器，因此摊销成本应该与您的 CPU 频率一样快，例如，对于 3 GHz CPU 的平均值为 0.3 纳秒。
- en: In practice, however, overheads are never amortized and never static within
    a single run, making that statement latency highly nondeterministic. As we learned
    in [Chapter 4](ch04.html#ch-hardware), if we don’t have the data in the registers,
    the CPU has to fetch it from L-caches, which might take one nanosecond. If L-caches
    contain data the CPU needs, our single statement might take 50 ns. Suppose the
    OS is busy running millions of other processes; our single statement might take
    milliseconds. Notice that we are talking about a single instruction! On a larger
    scale, if this noise builds, we can accumulate variance measurable in seconds.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际应用中，开销永远无法摊销，并且在单次运行中从不静态，使该语句的延迟高度不确定。正如我们在 [第 4 章](ch04.html#ch-hardware)
    中学到的，如果寄存器中没有数据，CPU 必须从 L 缓存中获取，可能需要一纳秒。如果 L 缓存中包含 CPU 需要的数据，我们的单个语句可能需要 50 纳秒。假设操作系统正忙于运行数百万其他进程，则我们的单个语句可能需要毫秒级的时间。请注意，我们正在讨论的是单个指令！从更大的尺度来看，如果这种噪声累积，我们可以积累以秒计量的可测量差异。
- en: Be mindful. Almost everything can impact the latency of our operations. Busy
    OS, different versions of hardware elements, and even differences in manufactured
    CPUs from the same company might mean different latency measurements. Ambient
    temperature near a laptop’s CPU or battery modes can trigger thermal scaling of
    our CPU frequency up and down. In extreme cases, even screaming at your computer
    can impact the efficiency!^([16](ch07.html#idm45606829739808)) The more complexity
    and layers we have when running our programs, the more fragile our efficiency
    measurements. Similar problems apply to remote devices, personal computers, and
    public cloud providers (e.g., AWS or Google) that use shared infrastructure with
    virtualization like containers or virtual machines.^([17](ch07.html#idm45606829737312))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心。几乎所有的东西都可能影响我们操作的延迟。繁忙的操作系统、硬件元件的不同版本，甚至是同一公司制造的不同CPU可能导致不同的延迟测量。靠近笔记本电脑CPU或电池模式的环境温度可以触发CPU频率的热调节，上下波动。在极端情况下，甚至对着电脑大声喊叫都可能影响效率！^([16](ch07.html#idm45606829739808))
    运行程序时，我们拥有的复杂性和层次越多，效率测量就越脆弱。远程设备、个人电脑以及使用像容器或虚拟机这样的共享基础设施的公共云提供商（例如AWS或Google），同样存在类似的问题。^([17](ch07.html#idm45606829737312))
- en: The fragility of efficiency assessment is so common that we have to expect it
    in every benchmarking attempt. Therefore, we have to embrace it and embed mitigations
    to those risks into our tools.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 效率评估的脆弱性如此普遍，以至于我们必须在每次基准测试尝试中都预期它。因此，我们必须接受它，并将对这些风险的缓解嵌入到我们的工具中。
- en: The first thing you might want to do before mitigating nondeterministic performance
    is to check if this problem impacts your benchmarks. Verify the repeatability
    of your test by calculating the variance of your results (e.g., using standard
    deviation). I will explain a good tool for that in [“Understanding the Results”](ch08.html#ch-obs-micro-res),
    but often you can see it in plain sight.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在减少非确定性性能之前，您可能想要做的第一件事是检查此问题是否影响您的基准测试。通过计算结果的方差（例如，使用标准偏差）来验证测试的可重复性。我将在[“理解结果”](ch08.html#ch-obs-micro-res)中解释一个好工具，但通常您可以在眼前就看到它。
- en: For example, if you run the experiment once and see it finish in 4.05 seconds,
    and other runs vary from 3.01 to 6.5 seconds, your efficiency assessment might
    not be accurate. On the other hand, if the variance is low, you can be more confident
    about the relevance of your benchmarks. Thus, check the repeatability of your
    benchmark first.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您运行实验一次，看到它在4.05秒内完成，而其他运行时间从3.01到6.5秒不等，您的效率评估可能不准确。另一方面，如果方差很小，您可以更加自信地确认您的基准测试的相关性。因此，首先检查您基准测试的可重复性。
- en: Don’t Overuse the Statistics
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度使用统计学
- en: It is tempting to accept high variance and either remove the extreme results
    (outliers) or take the mean (average) of all your results. You can apply very
    complex statistics to find some efficiency numbers with [some probability](https://oreil.ly/594nD).
    Increasing benchmark runs can also make your average numbers more stable, thus
    giving you a bit more confidence.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 诱人的是接受高方差，要么去除极端结果（异常值），要么取所有结果的平均值。您可以应用非常复杂的统计学方法来找到某些概率下的效率数字 [（链接）](https://oreil.ly/594nD)。增加基准运行次数也可以使您的平均数更稳定，因此您更有信心。
- en: In practice, there are better ways to try first to mitigate stability. Statistics
    are great where we can’t perform a stable measurement, or we can’t verify all
    samples (e.g., we cannot poll all humans on Earth to find out how many smartphones
    are used). While benchmarking, we have more control over stability than we might
    initially think.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实践中，有更好的方法来首先减少不稳定性。统计学在我们无法进行稳定测量或无法验证所有样本（例如，我们不能对全球所有人类进行轮询以了解使用的智能手机数量）时非常有用。在进行基准测试时，我们对稳定性的控制比最初想象的要多。
- en: 'There are many best practices we can follow to ensure our efficiency measurements
    will be more reliable by reducing the potential nondeterministic performance effects:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循许多最佳实践，以确保我们的效率测量更可靠，减少潜在的非确定性性能影响：
- en: Ensure the stable state of the machine you benchmark on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在进行基准测试的机器处于稳定状态。
- en: 'For most benchmarks that rely on comparisons, it matters less what conditions
    we benchmark in as long as they are stable (the state of the machine does not
    change during or between benchmarks). Unfortunately, three mechanics typically
    get in the way of machine stability:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数依赖比较的基准测试来说，重要的不是我们进行基准测试的条件，只要它们是稳定的（机器状态在基准测试期间或之间不变）。不幸的是，通常有三种因素会妨碍机器的稳定性：
- en: Background threads
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 后台线程
- en: As you learned in [Chapter 4](ch04.html#ch-hardware), it’s hard to isolate processes
    on machines. Even a single, seemingly small process can make your OS and hardware
    busy enough to change your efficiency measurements. For example, you might be
    surprised how much memory and CPU time one browser tab or Slack application might
    use. On public clouds, it’s even more hidden as we might see processes impacting
    us from different virtual OSes we don’t own.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第 4 章](ch04.html#ch-hardware)中学到的那样，难以在机器上隔离进程。即使是一个看似很小的单个进程也足以让你的操作系统和硬件变得忙碌，从而改变你的效率测量结果。例如，你可能会对一个浏览器标签或
    Slack 应用程序使用了多少内存和 CPU 时间感到惊讶。在公共云上，这种影响可能更为隐蔽，因为我们可能会看到来自我们不拥有的不同虚拟操作系统的进程对我们产生影响。
- en: Thermal scaling
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 热量调节
- en: The temperature of high-end CPUs increases significantly under load. The CPUs
    are designed to sustain relatively hot temperatures like 80–110°C, but there are
    limits. If the fans cannot cool the hardware fast enough, the OS or the firmware
    will limit the CPU cycles to avoid component meltdown. Especially with remote
    devices like laptops or smartphones, it’s easy to trigger thermal scaling when
    the ambient temperature is high, your device is in the sunlight, or something
    is obstructing the cooling fans.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 高端 CPU 在负载下温度显著上升。CPU 被设计为可以承受如 80–110°C 这样的相对高温，但也有其极限。如果风扇不能迅速冷却硬件，操作系统或固件将限制
    CPU 周期，以避免组件熔化。特别是在像笔记本电脑或智能手机这样的远程设备上，当环境温度较高、设备暴露在阳光下或者散热风扇被遮挡时，很容易触发热量调节。
- en: Power management
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 电源管理
- en: Similarly, devices can limit the hardware speed to reduce power consumption.
    This is typically seen on laptops and smartphones with battery-saving modes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，设备可以限制硬件速度以降低功耗。这通常在带有省电模式的笔记本电脑和智能手机上可见。
- en: Be extra vigilant on shared infrastructure.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享基础设施上要格外谨慎。
- en: Buying a dedicated virtual machine on a stable cloud provider for benchmarking
    is not a bad idea. We mentioned noisy neighbor problems, but if done right, the
    cloud can be sometimes more durable than your desktop machine running various
    interactive software during benchmarks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在稳定的云提供商上购买专用虚拟机进行基准测试并不是一个坏主意。我们提到了“吵闹的邻居”问题，但如果操作得当，云有时比你的桌面机器更能够在基准测试期间运行各种交互式软件。
- en: When using cloud resources, ensure you choose the best possible, strict Quality
    of Service (QoS) contract with the provider. For example, avoid cheaper [burstable](https://oreil.ly/Nu5C6)
    or preemptible virtual machines, which by design are prone to infrastructure instabilities
    and noisy neighbors.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云资源时，请确保选择与供应商签订最佳可能的、严格的服务质量（QoS）合同。例如，避免选择更便宜的[突发型](https://oreil.ly/Nu5C6)或可预留的虚拟机，这些设计上容易受到基础设施不稳定性和“吵闹的邻居”的影响。
- en: Avoid Continuous Integration (CI) pipelines, especially those from free tiers
    like [GitHub Action](https://oreil.ly/RcKXR) or other providers. While they remain
    a convenient and cheap option, they are designed for correctness testing that
    has to eventually finish (not as fast as physically possible) and scale dynamically
    to the user demands to minimize costs. This doesn’t provide strict and stable
    resource allocations required for benchmarks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用持续集成（CI）流水线，特别是那些来自免费层次（如[GitHub Action](https://oreil.ly/RcKXR)或其他提供者）的流水线。尽管它们仍然是方便和廉价的选择，但它们设计用于必须最终完成的正确性测试（而不是尽可能快地完成），并动态扩展以满足用户需求以最小化成本。这无法提供基准测试所需的严格和稳定的资源分配。
- en: Be mindful of benchmark machine limits.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意基准机器的限制。
- en: Be aware of your machine spec. For example, if your laptop has only 6 CPU cores
    (12 virtual cores with Hyper-Threading), don’t implement benchmark cases that
    require the `GOMAXPROCS` to be larger than the CPUs you have available for test.
    Furthermore, it might make sense to benchmark with only four CPUs for six physical
    core CPUs on your general-purpose machine to ensure spare room for OS and background
    processes.^([19](ch07.html#idm45606829694064))
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意你的机器规格。例如，如果你的笔记本电脑只有 6 个 CPU 核心（使用超线程技术可以达到 12 个虚拟核心），不要实施需要比你可用于测试的 CPU
    数量更多的基准测试用例。此外，对于通用机器上的六个物理核心 CPU，可能有意义的是仅使用四个 CPU 进行基准测试，以确保为操作系统和后台进程留出空间。^([19](ch07.html#idm45606829694064))
- en: Similarly, be mindful of the limits of other resources, like memory. For example,
    don’t run benchmarks that use close to a maximum capacity of RAM, as memory pressure,
    faster garbage collection, and memory trashing might slow down all threads on
    the machine, including the OS!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，要注意其他资源（如内存）的限制。例如，不要运行接近最大内存容量的基准测试，因为内存压力、更快的垃圾回收和内存碎片可能会减慢机器上所有线程的速度，包括操作系统！
- en: Run the experiment longer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将实验运行更长时间。
- en: One of the easiest ways to reduce variance between benchmark runs is to run
    the benchmark a bit longer. This allows us to minimize the benchmarking overhead
    that we might see at the beginning of our benchmarks (e.g., CPU cache warm-up
    phase). This also statistically gives us more confidence that the average latency
    or resource consumption metric shows the authentic pattern of the current efficiency
    level. This method takes time and depends on nontrivial statistics, prone to statistical
    fallacies, so use it with care and ideally try the suggestions mentioned before.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 减少基准测试运行之间方差的最简单方法之一是稍微延长基准测试时间。这使我们能够最小化我们可能在基准测试开始阶段看到的基准测试开销（例如，CPU缓存预热阶段）。这在统计上也给了我们更多的信心，表明平均延迟或资源消耗指标显示了当前效率水平的真实模式。这种方法需要时间，并依赖于非平凡的统计学，易于统计谬误，因此请谨慎使用，并最好尝试之前提到的建议。
- en: To sum up, be mindful of potential human errors that can lead to confusion.
    Do care about the relevance of your experiments to the production end goal you
    and your development team have. Finally, measure the repeatability of your experiments
    to assess if you can rely on their results. Of course, there will always be some
    discrepancy between benchmark runs or between benchmark runs and production setup.
    Still, with these recommendations, you should be able to reduce them to a safe
    2–5% variance level.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，请注意可能导致混淆的潜在人为错误。确保你的实验与你和你的开发团队的生产最终目标相关。最后，测量你的实验的可重复性，以评估是否可以依赖它们的结果。当然，基准测试运行之间或基准测试运行与生产设置之间总会存在一些差异。然而，遵循这些建议，你应该能够将它们降低到安全的2-5%的方差水平以下。
- en: Perhaps you came to this chapter to learn how to perform Go benchmarks. I can’t
    wait to explain to you step-by-step how to perform those in the next chapter!
    However, the Go benchmarks are not all we have in our empirical assessment arsenal.
    Therefore, it’s essential to learn when to choose the Go benchmarks and when to
    fall back on different benchmarking methods. I will outline that in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你来到这一章是为了学习如何进行Go基准测试。我迫不及待地希望在下一章为你逐步解释如何进行这些测试！然而，Go基准测试并不是我们在经验评估工具中拥有的全部。因此，学会何时选择Go基准测试，何时退而求其次使用不同的基准测试方法是至关重要的。我将在下一节中概述这一点。
- en: Benchmarking Levels
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试级别
- en: In [Chapter 6](ch06.html#ch-observability), we discussed finding latency and
    resource usage metrics that will allow us reliable measurements. But in the previous
    section, we learned that this might be only half of the success. By definition,
    benchmarking requires an experimentation stage that will trigger a certain situation
    or state of the application, which is valuable to measure.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#ch-observability)中，我们讨论了寻找延迟和资源使用度量标准，这些标准将允许我们进行可靠的测量。但在前一节中，我们了解到这可能只是成功的一半。按照定义，基准测试需要一个实验阶段，这将触发应用程序的某种情况或状态，这对于测量是有价值的。
- en: 'There is something simpler worth mentioning before we start with experiments.
    The naive and probably simplest solution to assess the efficiency of, e.g., a
    new release of our software, is to give it to our customers and collect our metrics
    during the “production” use. This is great because we don’t need to simulate or
    reproduce anything. Essentially the customer is performing the “experiment” part
    on our software, and we just measure their experience. We could call it “monitoring”
    at the source or “production monitoring.” Unfortunately, there are some challenges:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实验之前，有一点值得一提。评估我们软件新版本效率的天真且可能最简单的解决方案是将其提供给我们的客户，并在“生产”使用过程中收集我们的指标数据。这非常好，因为我们不需要模拟或重现任何东西。本质上，客户在我们的软件上执行“实验”部分，我们只是测量他们的体验。我们可以称之为“源头监控”或“生产监控”。不幸的是，这里存在一些挑战：
- en: Computer systems are complex. As we learned in [“Reproducing Production”](#ch-obs-rel-repro),
    the efficiency depends on many environmental factors. To truly assess whether
    our new software versions have better or worse efficiency, we must know about
    all those “measurement” conditions. However, it is not economical to gather all
    this information when it runs on client machines.^([21](ch07.html#idm45606829669440))
    Without it, we cannot derive any meaningful conclusions. On top of that, many
    users would opt out of any reporting capabilities, meaning we are even more unaware
    of what happened.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机系统是复杂的。正如我们在 [“复制生产环境”](#ch-obs-rel-repro) 中所学到的，效率取决于许多环境因素。要真正评估我们的新软件版本是否具有更好或更差的效率，我们必须了解所有这些“测量”条件。然而，当它在客户机器上运行时，收集所有这些信息是不经济的。^([21](ch07.html#idm45606829669440))
    没有这些信息，我们无法得出任何有意义的结论。此外，许多用户会选择退出任何报告功能，这意味着我们对发生的事情知之甚少。
- en: Even if we gather that observability information, it isn’t guaranteed that a
    situation causing problems will ever occur again. There is no guarantee that the
    customer will perform all the steps to reproduce the old problem. Statistically,
    all meaningful situations will happen at some point, but that eventual timing
    is too long in practice. For example, imagine that one HTTP request to a particular
    `/compute` path was causing efficiency problems. We fixed it and deployed it to
    production. What if no one used this particular path for the next two weeks? The
    feedback loop can be very long here.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们收集了可观察性信息，也不能保证问题再次发生。不能保证客户会执行复制旧问题的所有步骤。统计上讲，所有有意义的情况总会发生，但实际上这种情况发生的时间间隔太长。例如，假设一个特定路径
    `/compute` 的 HTTP 请求导致效率问题。我们修复了并部署到生产环境。但如果在接下来的两周内没有人使用这条路径会怎样呢？这里的反馈循环可能会非常长。
- en: Feedback Loop
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反馈循环
- en: The feedback loop is a cycle that starts from the moment of making changes to
    our code and ends with observations around these changes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈循环是一个从修改代码开始并以围绕这些变化的观察结束的循环。
- en: The longer this loop is, the more expensive development is. The frustration
    of developers is also often underestimated. In extreme cases, it will inevitably
    result in developers taking shortcuts by ignoring important testing or benchmarking
    practices.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 反馈循环越长，开发成本就越高。开发人员的沮丧情绪也经常被低估。在极端情况下，开发人员会不可避免地采取捷径，忽略重要的测试或基准测试实践。
- en: To overcome this, we must invest in practices that will give us as much reliable
    feedback as possible in the shortest time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要克服这一点，我们必须投资于能够在最短时间内提供尽可能可靠反馈的实践。
- en: Finally, it is often too late if we rely on our users to “benchmark” our software.
    If it’s too slow, we might have already lost their trust. This can be mitigated
    by [canary rollouts](https://oreil.ly/seUXz) and feature flags,^([22](ch07.html#idm45606829659856))
    but still, ideally, we catch efficiency issues before releasing our software to
    production.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们依赖用户来“基准测试”我们的软件，通常为时已晚。如果太慢，我们可能已经失去了他们的信任。可以通过 [金丝雀发布](https://oreil.ly/seUXz)
    和功能标志来缓解这一问题，^([22](ch07.html#idm45606829659856)) 但理想情况下，我们在将软件发布到生产环境之前就能捕捉到效率问题。
- en: Production monitoring is critical, especially when your software runs 24 hours,
    7 days a week. Even more, manual monitoring, like observing efficiency trends
    and user feedback in your bug tracker, is also useful for the last step of efficiency
    assessment. Things do slip through the testing strategies we are discussing here,
    so it makes sense to keep production monitoring as a last verification resort.
    But as a standalone efficiency assessment, production monitoring is quite limited.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 生产监控至关重要，特别是当您的软件每周 7 天、每天 24 小时运行时。此外，像在您的错误跟踪器中观察效率趋势和用户反馈这样的手动监控，在效率评估的最后一步也是有用的。我们在这里讨论的测试策略确实会有漏洞，因此保持生产监控作为最后的验证手段是有意义的。但作为独立的效率评估，生产监控是相当有限的。
- en: Fortunately, we have more testing options that help to verify efficiency. Without
    further ado, let’s go through the different levels of efficiency testing. If we
    would put all of them on a single graph that compares them based on the required
    effort to implement and maintain and the effectiveness of the individual test,
    it could look like [Figure 7-2](#img-obs-meas).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有更多的测试选项来验证效率。话不多说，让我们来看看不同级别的效率测试。如果我们把它们都放在一个单一的图表上，根据实施和维护所需的努力以及各个测试的有效性进行比较，它可能看起来像
    [图 7-2](#img-obs-meas)。
- en: '![efgo 0702](assets/efgo_0702.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![efgo 0702](assets/efgo_0702.png)'
- en: Figure 7-2\. Types of efficiency and correctness test methods with respect to
    difficulty to set up and maintain them (horizontal axis) versus how effective
    a singular test of a given type is in practice (vertical axis)
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2。关于设置和维护难度（水平轴）与实际上一个给定类型的测试效果有多有效（垂直轴）的效率和正确性测试方法的类型。
- en: Which of the methods presented in [Figure 7-2](#img-obs-meas) are used by mature
    software projects and companies? The answer is all of them. Let me explain.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-2](#img-obs-meas)中展示的方法哪些被成熟的软件项目和公司使用？答案是所有方法。让我解释一下。
- en: Benchmarking in Production
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产环境中的基准测试
- en: Following [testing in production practice](https://oreil.ly/5NUiw), we could
    use a live production system to assess efficiency. It might mean hiring “test
    drivers” (beta users) who will run our software on their devices and create real
    usage and report issues. Benchmarking in production is also very useful when your
    company sells the software you develop as a SaaS. For these cases, it is as easy
    as creating automation (e.g., a batch job or microservice) that periodically or
    after every rollout benchmarks the cluster using a predefined set of test cases
    that mimic real user functionalities (e.g., HTTP requests that simulate user traffic).
    Especially since you control the production environment, you can mitigate the
    downsides of production monitoring. You can be aware of environmental conditions,
    revert quickly, use feature flags, perform canary deployments, and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在[生产环境测试实践](https://oreil.ly/5NUiw)之后，我们可以使用实际的生产系统来评估效率。这可能意味着雇佣“测试驱动者”（即Beta用户），他们将在其设备上运行我们的软件，创建真实的使用情况并报告问题。在你的公司将开发的软件作为SaaS销售时，生产环境中的基准测试也非常有用。对于这些情况，只需创建自动化（例如批处理作业或微服务），定期或每次发布后，使用预定义的测试用例集来进行基准测试，这些测试用例模拟真实用户功能（例如模拟用户流量的HTTP请求）。尤其是由于你控制生产环境，你可以减轻生产监控的缺点。你可以了解环境条件，快速回退，使用功能标志，进行金丝雀发布等等。
- en: Benchmarking in Production Has Limited Use
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产环境中的基准测试有限的使用
- en: 'Unfortunately, there are many challenges to this testing practice:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种测试实践面临许多挑战：
- en: It’s easier when you run your software as a SaaS. Otherwise, it’s much harder
    as the developers can’t quickly revert or fix potential impacts.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你将软件作为SaaS运行时，这一切都会更容易。否则，情况会变得更加困难，因为开发人员无法快速回退或修复潜在的影响。
- en: You have to ensure Quality of Service (QoS). This means you cannot do benchmarking
    with extreme payloads, as you need to ensure you don’t impact—e.g., cause Denial
    of Service (DoS)—your production environment.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须确保服务质量（QoS）。这意味着你不能使用极端的负载进行基准测试，因为你需要确保不会影响——例如，导致拒绝服务（DoS）——你的生产环境。
- en: The feedback loop is quite long for developers in such a model. For example,
    you need to release your software fully to benchmark it.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种模型中，开发人员的反馈循环相当长。例如，你需要完全发布你的软件才能对其进行基准测试。
- en: On the other hand, if you are fine with those limitations, as presented in [Figure 7-2](#img-obs-meas),
    benchmarking in production might be the most effective and reliable testing strategy.
    It is ultimately the closest we can get to real production usage, which reduces
    the risk of inaccurate results. The effort of creating and maintaining such tests
    is relatively small, assuming we already have production monitoring. We don’t
    need to simulate data, environment, dependencies, etc. We can reuse the existing
    monitoring tools you need to keep the cluster up.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你可以接受这些限制，正如在[图7-2](#img-obs-meas)中所示，生产环境中的基准测试可能是最有效和可靠的测试策略。这最终是我们能够接近真实生产使用的最佳方法，从而降低不准确结果的风险。创建和维护这类测试的工作量相对较小，假设我们已经有了生产监控。我们不需要模拟数据，环境，依赖关系等。我们可以重用现有的监控工具，这样你需要保持集群运行。
- en: Macrobenchmarks
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏观基准测试
- en: Testing or benchmarking in production is reliable, but spotting problems at
    that point is expensive. That’s why the industry introduced testing in earlier
    stages of development. The benefit is that we can assess the efficiency with just
    prototypes, which can be produced much quicker. We call the tests on this level
    “macrobenchmarks.”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中测试或基准测试是可靠的，但在那时发现问题是昂贵的。这就是为什么行业在开发的早期阶段引入了测试的原因。其好处是我们可以仅通过原型评估效率，而原型可以更快地生成。我们称这个级别上的测试为“宏观基准测试”。
- en: Macrobenchmarks provide a great balance between good reliability of such tests
    and faster feedback loop compared to benchmarking in production. In practice,
    it means building your Go program and benchmarking it in a simulated environment
    with all required dependencies. For example, for client-side applications, it
    might mean buying some example client devices (e.g., smartphones if we build the
    mobile application). Then for some application releases, reinstall your Go program
    on those devices and thoroughly benchmark it (ideally with some automated suite).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与在生产中进行基准测试相比，宏基准测试在测试可靠性和反馈速度之间提供了很好的平衡。实际上，这意味着在模拟环境中构建你的Go程序，并在那些需要的所有依赖项中进行基准测试。例如，对于客户端应用程序，这可能意味着购买一些示例客户设备（例如，如果我们构建移动应用程序，则可能是智能手机）。然后，在某些应用程序发布中，重新安装你的Go程序到这些设备上，并彻底进行基准测试（最好使用一些自动化套件）。
- en: For SaaS-like use cases, it might mean creating copies of production clusters,
    commonly called “testing” or “staging” environments. Then, to assess efficiency,
    build your Go program, deploy how you would in production, and benchmark it. We
    will also discuss more straightforward methods like using an [`e2e` framework](https://oreil.ly/f0IJo)
    that you can run on a single development machine without complex orchestration
    systems like Kubernetes. I will explain those two methods briefly in [“Macrobenchmarks”](ch08.html#ch-obs-macro).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类似SaaS的使用案例，这可能意味着创建生产集群的副本，通常称为“测试”或“暂存”环境。然后，为了评估效率，在这些环境中构建你的Go程序，部署方式与生产环境相同，并对其进行基准测试。我们还将简要讨论更简单的方法，例如使用[`e2e`框架](https://oreil.ly/f0IJo)，你可以在单个开发机器上运行，而无需像Kubernetes这样复杂的编排系统。我将在[“宏基准测试”](ch08.html#ch-obs-macro)中简要解释这两种方法。
- en: 'There are many benefits of macrobenchmarking:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 宏基准测试有很多好处：
- en: They are highly reliable and effective (yet not as much as benchmarking in production).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常可靠和有效（但不如在生产中进行基准测试那么多）。
- en: You can delegate such macrobenchmarking to independent QA engineers because
    you can treat your Go program as a “closed box” (previously known as a “black
    box”—no need to understand how it is implemented).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这样的宏基准测试委托给独立的QA工程师，因为你可以将你的Go程序视为一个“封闭的盒子”（以前被称为“黑盒子”——不需要理解它是如何实现的）。
- en: You don’t impact production with anything you do.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会对生产产生任何影响。
- en: The downside of this approach, as shown in [Figure 7-2](#img-obs-meas), is the
    effort of building and maintaining such a benchmark suite. Typically, it means
    complex configuration or code to automate all of it. Additionally, in many cases,
    any functional changes to our Go program mean we must rebuild parts of the complex
    macrobenchmarking system. As a result, such macrobenchmarks are viable for more
    mature projects with stable APIs. On top of that, the feedback loop is still quite
    long. We also must limit how many benchmarks we can do at once. Naturally, we
    have a limited number of those testing clusters that we share with other team
    members for cost efficiency. This means we have to coordinate those benchmarks.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[图7-2](#img-obs-meas)中所示，这种方法的缺点在于构建和维护这样一个基准测试套件所需的工作量。通常，这意味着复杂的配置或代码来自动化所有这些工作。此外，在许多情况下，我们Go程序的任何功能更改意味着我们必须重新构建复杂的宏基准测试系统的部分。因此，这样的宏基准测试适用于具有稳定API的更成熟项目。此外，反馈周期仍然相当长。我们还必须限制同时进行的基准测试数量。自然而然地，我们有一定数量的测试集群，与其他团队成员共享以节约成本。这意味着我们必须协调这些基准测试。
- en: Microbenchmarks
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微基准测试
- en: 'Fortunately, there is a way to have more agile benchmarks! We can follow the
    pattern of [divide and conquer](https://oreil.ly/ZFxiG) for optimizations. Instead
    of looking at the efficiency of the whole system or the Go program, we treat our
    program in an open box (previously known as a “white box”) manner and divide program
    functionality into smaller parts. We can then use the profiling we will learn
    in [Chapter 9](ch09.html#ch-observability3) to identify parts that contribute
    the most to the efficiency of the whole solution (e.g., use the most CPU or memory
    resource or add the most to the latency). We can then assess the efficiency of
    the program’s most “expensive” part by writing small unit tests like microbenchmarks
    just for this small part in isolation. The Go language provides a native benchmarking
    framework that you can run with the same tool as unit tests: `go test`. We will
    discuss using this practice in [“Microbenchmarks”](ch08.html#ch-obs-micro).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一种更敏捷的基准测试方法！我们可以遵循[分而治之](https://oreil.ly/ZFxiG)的优化模式。与其查看整个系统或Go程序的效率，我们可以以开放式盒子（以前称为“白盒子”）的方式处理我们的程序，并将程序功能划分为较小的部分。然后，我们可以使用我们将在[第9章](ch09.html#ch-observability3)中学到的性能分析来识别对整体解决方案效率贡献最大的部分（例如，使用最多的CPU或内存资源或对延迟增加最多）。然后，我们可以通过编写小的单元测试，例如微基准测试，只针对这个小部分在隔离状态下评估程序的效率。Go语言提供了一个本地基准测试框架，您可以使用与单元测试相同的工具运行：`go
    test`。我们将在[“微基准测试”](ch08.html#ch-obs-micro)中讨论使用这种实践。
- en: Microbenchmarks are probably the most fun to write because they are very agile
    and provide rapid feedback about the efficiency of our Go function, algorithm,
    or structure. You can quickly run those benchmarks on your (even small!) developer
    machine, often without going out of your favorite IDE. You can implement such
    a benchmark test in 10 minutes, execute it in the next 20 minutes, and then tear
    it down or change it entirely. It is cheap to make, cheap to iterate, like a unit
    test. You can also treat it as a more reusable development tool—write more complex
    microbenchmarks that will work as acceptance benchmarks for a small part of the
    code the whole team can use.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 微基准测试可能是最有趣的写作，因为它们非常敏捷，并且可以快速反馈我们的Go函数、算法或结构的效率。您可以快速在您喜爱的IDE中运行这些基准测试，甚至是在您的（即使是小型的！）开发者机器上。您可以在10分钟内实现这样的基准测试，接下来的20分钟内执行它，然后拆除或完全更改它。这种方法成本低廉，迭代便宜，就像单元测试一样。您还可以将其视为更可重复使用的开发工具——编写更复杂的微基准测试，作为整个团队可以使用的小部分代码的验收基准。
- en: Unfortunately, with agility comes many trade-offs. For example, suppose you
    wrongly identify the efficiency bottleneck of your program. In that case, you
    might be celebrating that your local microbenchmarks for some parts of the program
    take only 200 ms. However, when your program is deployed, it might still cause
    efficiency problems (and violate the RAER). On top of that, some problems are
    only visible when you run all the code components together (similar to integration
    tests). The choice of test data is also nontrivial. In many cases, it is impossible
    to mimic dependencies in a way that makes sense to reproduce certain efficiency
    problems, so we have to make some assumptions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，敏捷性带来了许多权衡。例如，假设您错误地识别了程序的效率瓶颈。在这种情况下，您可能会因为程序的某些部分的本地微基准测试仅花费了200毫秒而感到高兴。然而，当您的程序部署后，它可能仍然会导致效率问题（并违反RAER）。此外，有些问题只有在运行所有代码组件时才能看到（类似于集成测试）。测试数据的选择也是非常重要的。在许多情况下，我们无法模仿依赖关系，使其能够重现某些效率问题，因此我们必须做一些假设。
- en: When Microbenchmarking, Don’t Forget About the Big Picture
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在进行微基准测试时，请不要忘记大局
- en: It is not uncommon to perform easy, deliberate optimizations on the part of
    code that is a bottleneck and see a major improvement. For example, after optimization,
    our microbenchmarks might indicate that instead of 400 MB, our function now allocates
    only 2 MB per operation. After thinking about that part of the code, you might
    have plenty of other ideas about optimizations for that 2 MB of allocations! So
    you might be tempted to learn and optimize that.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中的瓶颈部分进行简单而有意的优化并看到明显改善并不罕见。例如，在优化后，我们的微基准测试可能表明，我们的函数现在每次操作只分配了2 MB，而不是400
    MB。思考了代码的这部分后，您可能会有很多其他关于优化这2 MB分配的想法！因此，您可能会想要学习和优化它。
- en: This is a risk. It’s easy to fixate on raw numbers from a single microbenchmark
    and go into the optimization rabbit hole, introducing more complexity and spending
    valuable engineering time.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个风险。很容易固守单个微基准的原始数字并深入优化的兔子洞，引入更多复杂性并消耗宝贵的工程时间。
- en: In this case, we should most likely be happy with the massive, 200x improvement,
    and do all it takes to get it deployed. If we want to further improve the performance
    of the path we were looking at, it’s not unlikely that the bottleneck of the code
    path we were testing has now moved somewhere else!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们最有可能对庞大的200倍提升感到满意，并采取一切措施使其部署。如果我们希望进一步提高我们所关注的路径的性能，则我们所测试的代码路径的瓶颈现在可能已经转移到其他地方！
- en: What Level Should You Use?
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您应该使用哪个级别？
- en: 'As you might have already noticed, there is no “best” benchmark type. Each
    stage has its purpose and is needed. Every solid software project should eventually
    have some microbenchmarks, have some macro ones, and potentially benchmark some
    portion of functionalities in production. This can be confirmed by just looking
    at some open source projects. There are many examples, but just to pick two:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的那样，没有“最佳”的基准测试类型。每个阶段都有其目的并且是必需的。每个扎实的软件项目最终都应该有一些微基准测试，有一些宏基准测试，并可能在生产中对某些功能部分进行基准测试。这可以通过查看一些开源项目来确认。有许多示例，但只需选择两个：
- en: The [Prometheus project](https://oreil.ly/FwnBN) has dozens of microbenchmarks
    and a semiautomated, dedicated [macrobenchmark suite](https://oreil.ly/QqwrL)
    that deploys instances of the Prometheus program in Google Cloud and benchmarks
    them. Many Prometheus users also test and gather efficiency data directly from
    production clusters.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Prometheus项目](https://oreil.ly/FwnBN)有数十个微基准测试和半自动的[专用宏基准套件](https://oreil.ly/QqwrL)，在Google
    Cloud中部署Prometheus程序实例并对其进行基准测试。许多Prometheus用户还直接从生产集群中测试和收集效率数据。'
- en: The [Vitess project](https://oreil.ly/tcGNV) uses [microbenchmarks written in
    Go](https://oreil.ly/cLr6f) as well. On top of that, the Vitess project maintains
    [macrobenchmarks](https://oreil.ly/pxtPO). Amazingly, it builds automation that
    runs both types of benchmarks nightly, with results reported on [the dedicated
    website](https://oreil.ly/8RMw6). This is an exceptional best-practice example.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Vitess项目](https://oreil.ly/tcGNV)也使用[用Go编写的微基准](https://oreil.ly/cLr6f)。此外，Vitess项目还保持[宏基准测试](https://oreil.ly/pxtPO)。令人惊讶的是，它构建了每晚运行两种类型基准测试并在[专用网站](https://oreil.ly/8RMw6)上报告结果的自动化。这是一个卓越的最佳实践示例。'
- en: What benchmarks to add to the software projects you work on, and when, depends
    on needs and maturity. Be pragmatic with adding benchmarks. No software needs
    numerous benchmarks in the early development cycle. When APIs are unstable and
    detailed requirements are changing, the benchmark will need to change as well.
    In fact, it can be harmful to the project if we spend time on writing (and later
    maintaining) benchmarks for a project that hasn’t yet functionally proven its
    usefulness.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您要在您所工作的软件项目中添加哪些基准测试以及何时添加基于需求和成熟度而定。在早期开发周期中，向项目添加大量基准测试是不实际的。当API不稳定且详细需求正在变化时，基准测试也需要相应更改。事实上，如果我们花时间编写（以及后来维护）尚未在功能上证明其有用性的项目的基准测试，这可能对项目有害。
- en: 'Follow this (intelligently) lazy approach instead:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种（聪明的）懒惰方法：
- en: If the stakeholder is unhappy with visible efficiency problems, perform the
    bottleneck analysis explained in [Chapter 9](ch09.html#ch-observability3) on production
    and add microbenchmarks (see [“Microbenchmarks”](ch08.html#ch-obs-micro)) to the
    part that is a bottleneck. When optimized, another part will likely be a bottleneck,
    so new tests must be added. Do this until you are happy with the efficiency, or
    it’s too difficult or expensive to optimize the program further. It will grow
    organically.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果利益相关者对可见的效率问题感到不满，请对生产中解释的[第9章](ch09.html#ch-observability3)执行瓶颈分析，并将微基准（见[“微基准”](ch08.html#ch-obs-micro)）添加到成为瓶颈的部分。优化后，可能会出现另一个瓶颈部分，因此必须添加新测试。一直做到您对效率感到满意，或者进一步优化程序变得太困难或昂贵。它将有机生长。
- en: When a formal RAER is established, it might be useful to ensure that you test
    efficiency more end to end. Then you might want to invest in the manual, then
    automatic, macrobenchmarks (see [“Macrobenchmarks”](ch08.html#ch-obs-macro)).
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当建立正式的RAER时，确保您更终端地测试效率可能会很有用。然后您可能希望投资于手动，然后自动的宏基准（见[“宏基准”](ch08.html#ch-obs-macro)）。
- en: If you truly care about accurate and pragmatic tests, and you control your “production”
    environment (applicable for SaaS software), consider benchmarking in production.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你真的关心准确和务实的测试，并且控制你的“生产”环境（适用于SaaS软件），请考虑在生产环境中进行基准测试。
- en: Don’t Worry About “Benchmark” Code Coverage!
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要担心“基准”代码覆盖率！
- en: For functional testing, it’s popular to measure the quality of the project by
    ensuring the [test code coverage](https://oreil.ly/Sfde9) is high.^([23](ch07.html#idm45606829590720))
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能测试，通过确保[测试代码覆盖率](https://oreil.ly/Sfde9)较高来衡量项目质量是很流行的。^([23](ch07.html#idm45606829590720))
- en: Never try to measure how many parts of your program have benchmarks! Ideally,
    you should only implement benchmarks for the critical places you want to optimize
    because the data indicates they are (or were) the bottleneck.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要试图衡量你的程序有多少部分有基准测试！理想情况下，你只应该为你想要优化的关键位置实施基准测试，因为数据表明它们（或曾经是）瓶颈。
- en: With this theory, you should know what benchmarking levels are available to
    you and why there is no silver bullet. Still, benchmarks are in the code of our
    software efficiency story, and the Go language is no different here. We can’t
    optimize without experimenting and measuring. However, be mindful of the time
    spent in this phase. Writing, maintaining, and performing benchmarks takes time,
    so follow the lazy approach and add benchmarks on an appropriate level on demand
    and only if needed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理论，你应该知道你可以使用哪些基准测试水平，以及为什么没有银弹。尽管如此，基准测试已经成为我们软件效率故事的一部分，Go语言在这里也不例外。我们无法在没有实验和测量的情况下进行优化。然而，在这个阶段花费的时间要注意。编写、维护和执行基准测试需要时间，所以按需遵循懒惰的方法，在适当的级别和只有在需要时添加基准测试。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The reliability issues of these tests are perhaps one of the biggest reasons
    developers, product managers, and stakeholders de-scope efficiency efforts. Where
    do you think I found all those little best practices to improve reliability? At
    the beginning of my engineering career, I spent numerous hours on careful load
    testing and benchmarks with my team, only to realize it meant nothing as we missed
    a critical element of the environment. For example, our synthetic workloads were
    not providing a realistic load.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试的可靠性问题也许是开发人员、产品经理和利益相关者将效率努力降低到最低程度的最大原因之一。你认为我在哪里找到所有这些小的最佳实践来提高可靠性呢？在我工程职业生涯的开始阶段，我与我的团队花了大量时间进行仔细的负载测试和基准测试，只是意识到这对环境的关键因素意味着什么。例如，我们的合成工作负载并未提供真实的负载。
- en: Such cases can discourage even professional developers and product managers.
    Unfortunately, this is where we typically prefer to pay more for waste computing
    rather than invest in optimization efforts. That’s why it’s critically important
    to ensure the experiment, load tests, and scale tests we do are as reliable as
    possible to achieve our efficiency goals faster!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况甚至会使专业开发人员和产品经理感到沮丧。不幸的是，我们通常更倾向于为计算浪费支付更多而不是投资于优化工作。这就是为什么确保我们进行的实验、负载测试和规模测试尽可能可靠以更快地实现我们的效率目标至关重要的原因！
- en: In this chapter, you learned the foundations behind reliable efficiency assessment
    through empirical experiments we call benchmarks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了通过我们称之为基准测试的经验性实验来建立可靠效率评估的基础。
- en: We discussed the basic complexity analysis that can help optimize our journey.
    I mentioned the difference between benchmark testing and functional testing and
    why benchmarks lie if we misinterpret them. You learned common reliability problems
    that I found truly important during experimentation cycles and the levels of benchmarks
    commonly spotted in the industry.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了基本的复杂性分析，它可以帮助优化我们的旅程。我提到了基准测试和功能测试之间的区别，以及为什么如果我们误解它们，基准测试会误导我们。你学到了在实验周期中真正重要的常见可靠性问题，以及行业中常见的基准测试水平。
- en: We are finally ready to learn how to implement those benchmarks on all levels
    mentioned above, so let’s jump right into it!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好学习如何在上述所有层面上实施这些基准测试，所以让我们立刻开始吧！
- en: ^([1](ch07.html#idm45606830136704-marker)) This is fixed for this particular
    `ParseInt` function in Go 1.20 thanks to an amazing [improvement](https://oreil.ly/KLIVM),
    but you might be surprised by it in any other function!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm45606830136704-marker)) 这对于Go 1.20中的这个特定的`ParseInt`函数来说已经固定了，得益于一个惊人的[改进](https://oreil.ly/KLIVM)，但你可能会在任何其他函数中感到惊讶！
- en: ^([2](ch07.html#idm45606830134048-marker)) It only shows up when we do lots
    of string copies in our programs. Perhaps it comes from some internal byte pools?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm45606830134048-marker)) 只有在我们的程序中进行大量字符串复制时才会出现。也许它来自一些内部的字节池？
- en: ^([3](ch07.html#idm45606830118784-marker)) Those “O-notations” are respectively
    called Big O or Oh, Omega, and Theta. He also defines “o-notations” (o, ω), which
    [means strict upper or lower bound](https://oreil.ly/S44PO), so “this function
    grows slower than `f(N)`, but not exactly `f(N)`.” In practice, we don’t use o-notations
    very often.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#idm45606830118784-marker)) 这些“O-notations”分别被称为大O或Oh、Omega和Theta。他还定义了“o-notations”（o，ω），意思是[严格的上限或下限](https://oreil.ly/S44PO)，因此“这个函数增长比`f(N)`慢，但不完全是`f(N)`”。在实践中，我们并不经常使用o-notations。
- en: ^([4](ch07.html#idm45606830040464-marker)) I would categorize them as “brute
    force”—they do many benchmarks with different inputs and try to approximate the
    growth function.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.html#idm45606830040464-marker)) 我会将它们归类为“蛮力”——它们会对不同的输入进行许多基准测试，并尝试逼近增长函数。
- en: ^([5](ch07.html#idm45606830034224-marker)) I wouldn’t be surprised—I had a full-time
    job in IT from the second year of my computer science studies.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch07.html#idm45606830034224-marker)) 我不会感到惊讶——我在大学第二年就开始了全职IT工作。
- en: ^([6](ch07.html#idm45606830032352-marker)) For example, quicksort has worse
    complexity than other algorithms, yet on average it is the fastest. Or the matrix
    multiplication algorithm like [Coppersmith-Winograd](https://oreil.ly/q9jhn) has
    a big constant coefficient hidden by the Big O notation, which makes it only worth
    doing for matrices that are too big for our modern computers.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch07.html#idm45606830032352-marker)) 例如，快速排序的复杂度比其他算法更糟糕，但平均而言它是最快的。或者像[Coppersmith-Winograd](https://oreil.ly/q9jhn)这样的矩阵乘法算法有一个被大O符号隐藏的大常数系数，这使得它只对我们现代计算机来说太大的矩阵值得做。
- en: '^([7](ch07.html#idm45606830017600-marker)) Be careful: different tools use
    different conversions; e.g., `pprof` uses the 1,024 multiplier, and the `benchstat`
    uses the 1,000 multiplier.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch07.html#idm45606830017600-marker)) 小心：不同的工具使用不同的转换；例如，`pprof`使用1,024的乘数，而`benchstat`使用1,000的乘数。
- en: ^([8](ch07.html#idm45606829986592-marker)) I was very surprised that we can
    construct such accurate space complexity and have such accurate memory benchmarking
    and profiling up to every byte on the heap. Kudos to the Go community and `pprof`
    community for that hard work!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch07.html#idm45606829986592-marker)) 我非常惊讶我们可以构建如此准确的空间复杂度，并对堆上的每个字节进行如此准确的内存基准测试和分析。感谢Go社区和`pprof`社区为此辛勤工作！
- en: ^([9](ch07.html#idm45606830003600-marker)) This does not mean we should immediately
    fix those! Instead, always optimize if you know the problem will affect your goals,
    e.g., user satisfaction or RAER requirements.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch07.html#idm45606830003600-marker)) 这并不意味着我们应该立即修复这些问题！相反，如果你知道问题会影响你的目标，比如用户满意度或RAER要求，那么始终进行优化。
- en: ^([10](ch07.html#idm45606829995728-marker)) Sometimes, there are relatively
    easy ways to change our code to stream and use [external memory](https://oreil.ly/p6YDD)
    algorithms that ensure stable memory usage.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch07.html#idm45606829995728-marker)) 有时，有相对简单的方法可以改变我们的代码以流式传输并使用[外部内存](https://oreil.ly/p6YDD)算法，以确保内存使用稳定。
- en: ^([11](ch07.html#idm45606829937408-marker)) Unfortunately, we still have to
    guess a little bit—more on that in [“Reliability of Experiments”](#ch-obs-rel).
    Nothing will get us 100% assurance. Yet benchmarking is probably the best we have
    as developers for ensuring the software we develop is efficient enough.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch07.html#idm45606829937408-marker)) 不幸的是，我们仍然必须有些猜测——更多内容请参见[“实验的可靠性”](#ch-obs-rel)。没有什么能给我们100%的保证。然而，对于我们开发者来说，基准测试可能是确保我们开发的软件足够高效的最佳方式。
- en: ^([12](ch07.html#idm45606829843312-marker)) For example, [car makers cheating
    on emission benchmarks](https://oreil.ly/WNF1z) and [phone vendors cheating on
    hardware benchmarks](https://oreil.ly/sf80C) (which sometimes results with a ban
    from the popular [Geekbench](https://oreil.ly/8M4ey) listing). In the software
    world, we have a constant battle between various vendors through [unfair benchmarks](https://oreil.ly/RmytC).
    Whoever creates them is often one of the fastest on the results list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch07.html#idm45606829843312-marker)) 例如，[汽车制造商在排放基准上作弊](https://oreil.ly/WNF1z)和[手机厂商在硬件基准上作弊](https://oreil.ly/sf80C)（有时会导致被流行的[Geekbench](https://oreil.ly/8M4ey)列出禁止）。在软件世界中，我们通过[不公平的基准测试](https://oreil.ly/RmytC)进行各种供应商之间的持续战斗。谁创建它们往往是结果列表中最快的之一。
- en: ^([13](ch07.html#idm45606829807072-marker)) Some good IDEs also have additional
    [local history](https://oreil.ly/Ytdi0) if you forgot to commit your changes in
    your `git` repository.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch07.html#idm45606829807072-marker)) 一些优秀的 IDE 还具有额外的 [本地历史记录](https://oreil.ly/Ytdi0)，如果你忘记在
    `git` 仓库中提交更改。
- en: ^([14](ch07.html#idm45606829792768-marker)) [Laziness is actually good](https://oreil.ly/u8IDm)
    for engineers! But it has to be pragmatic, productive, and reasonable laziness
    toward the efficiency of our work, not purely based on our emotions in the given
    moment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch07.html#idm45606829792768-marker)) [懒惰实际上对工程师是有好处的](https://oreil.ly/u8IDm)！但它必须是务实的、高效的、合理的懒惰，而不是纯粹基于我们当时的情绪。
- en: ^([15](ch07.html#idm45606829782464-marker)) Unless we write software for fellow
    developers that runs on similar hardware.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch07.html#idm45606829782464-marker)) 除非我们为运行在类似硬件上的其他开发人员编写软件。
- en: ^([16](ch07.html#idm45606829739808-marker)) The engineer Brendan Gregg [demonstrated](https://oreil.ly/vI8Rl)
    how screaming at server hard drive disks severely impacts their I/O latency due
    to vibrations.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch07.html#idm45606829739808-marker)) 工程师 Brendan Gregg [演示了](https://oreil.ly/vI8Rl)
    大声喊叫对服务器硬盘的 I/O 延迟产生严重影响，因为振动的缘故。
- en: ^([17](ch07.html#idm45606829737312-marker)) The situation where one workload
    from a totally different virtual machine impacts our workload is commonly called
    [a noisy neighbor situation](https://oreil.ly/cLRrD). It is a serious issue that
    cloud providers continuously fight, with better or worse results depending on
    the offering and provider.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch07.html#idm45606829737312-marker)) 一个完全不同虚拟机的工作负载影响我们工作负载的情况通常被称为 [noisy
    neighbor situation](https://oreil.ly/cLRrD)。这是一个严重的问题，云提供商不断努力应对，具体效果取决于服务和提供者。
- en: ^([18](ch07.html#idm45606829707312-marker)) This is why you won’t see me explaining
    the microbenchmark options like [RunParallel](https://oreil.ly/S74VY). In general,
    running multiple benchmark functions in parallel can distort the results. Therefore,
    I recommend avoiding this option.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch07.html#idm45606829707312-marker)) 这就是为什么你不会看到我解释类似 [RunParallel](https://oreil.ly/S74VY)
    的微基准选项。一般来说，同时运行多个基准函数可能会扭曲结果。因此，我建议避免使用此选项。
- en: ^([19](ch07.html#idm45606829694064-marker)) You can also fully dedicate CPU
    cores to your benchmark; consider the [`cpuset` tool](https://oreil.ly/dCLzw).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch07.html#idm45606829694064-marker)) 您还可以将 CPU 核心完全用于您的基准测试；考虑使用 [`cpuset`
    工具](https://oreil.ly/dCLzw)。
- en: ^([20](ch07.html#idm45606829685792-marker)) I had this problem when writing
    [Chapter 10](ch10.html#ch-opt). I ran some benchmarks in one go on a relatively
    cold day. Next week there was a heat wave in the UK. I could not continue my optimization
    effort while reusing the past benchmarking results on such a hot day, as all my
    code was running 10% slower! I had to redo all the experiments to compare the
    implementations fairly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch07.html#idm45606829685792-marker)) 我在撰写 [第10章](ch10.html#ch-opt) 时遇到了这个问题。我在一个相对寒冷的日子一次性运行了一些基准测试。下周英国却遭遇了热浪。在如此炎热的日子里，我无法继续利用过去的基准测试结果进行优化工作，因为我的所有代码运行速度慢了10%！我不得不重新做所有的实验，以公平地比较实现方式。
- en: ^([21](ch07.html#idm45606829669440-marker)) In some way, this is why selling
    your product as a SaaS is so appealing in software. Your “production” is on your
    premises, making it easier to control the experience of the users and validate
    some efficiency optimizations.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch07.html#idm45606829669440-marker)) 从某种意义上说，这就是为什么将产品作为 SaaS 销售在软件领域如此吸引人。你的“生产”在你的地盘上，更容易控制用户体验并验证一些效率优化。
- en: ^([22](ch07.html#idm45606829659856-marker)) Feature flags are configuration
    options that can be changed dynamically without restarting the service—typically
    through an HTTP call. This allows reverting new functionality quicker, which helps
    with testing or benchmarking in production. For feature flags I rely on the excellent
    [`go-flagz`](https://oreil.ly/rfuh2) library. I would also pay close attention
    to the new CNCF project [OpenFeature](https://oreil.ly/7Bsiw), which is meant
    to provide more standard interface in this space.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch07.html#idm45606829659856-marker)) 功能标志是可以通过 HTTP 调用动态更改的配置选项，而无需重新启动服务。这使得可以更快地回滚新功能，有助于在生产环境中进行测试或基准测试。对于功能标志，我依赖于优秀的
    [`go-flagz`](https://oreil.ly/rfuh2) 库。我还会密切关注新的 CNCF 项目 [OpenFeature](https://oreil.ly/7Bsiw)，旨在在此领域提供更标准的接口。
- en: ^([23](ch07.html#idm45606829590720-marker)) I am personally not a big fan of
    this approach. Not every part of the code is equally important to test, and not
    everything is worth testing. On top of that, [engineers tend to gamify this system](https://oreil.ly/NnjCD)
    by writing tests only to improve the coverage, instead on focusing on finding
    potential problems with the code in the fastest possible way (reducing cost of
    development).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch07.html#idm45606829590720-marker)) 我个人对这种方法并不是特别喜欢。并非代码的每个部分都同样重要进行测试，也不是每个东西都值得测试。此外，[工程师们倾向于将这个系统变成游戏](https://oreil.ly/NnjCD)，只是为了提高覆盖率编写测试，而不是专注于以最快的方式找出代码中的潜在问题（降低开发成本）。
