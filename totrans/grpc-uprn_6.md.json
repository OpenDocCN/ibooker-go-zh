["```go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"errors\"\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials\"\n  \"log\"\n  \"net\"\n)\n\nvar (\n  port = \":50051\"\n  crtFile = \"server.crt\"\n  keyFile = \"server.key\"\n)\n\nfunc main() {\n  cert, err := tls.LoadX509KeyPair(crtFile,keyFile) ![1](assets/1.png)\n  if err != nil {\n     log.Fatalf(\"failed to load key pair: %s\", err)\n  }\n  opts := []grpc.ServerOption{\n     grpc.Creds(credentials.NewServerTLSFromCert(&cert)) ![2](assets/2.png)\n  }\n\n  s := grpc.NewServer(opts...) ![3](assets/3.png)\n  pb.RegisterProductInfoServer(s, &server{}) ![4](assets/4.png)\n\n  lis, err := net.Listen(\"tcp\", port) ![5](assets/5.png)\n  if err != nil {\n     log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  if err := s.Serve(lis); err != nil { ![6](assets/6.png)\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc/credentials\"\n  \"google.golang.org/grpc\"\n)\n\nvar (\n  address = \"localhost:50051\"\n  hostname = \"localhost\n  crtFile = \"server.crt\"\n)\n\nfunc main() {\n  creds, err := credentials.NewClientTLSFromFile(crtFile, hostname) ![1](assets/1.png) if err != nil {\n     log.Fatalf(\"failed to load credentials: %v\", err)\n  }\n  opts := []grpc.DialOption{\n     grpc.WithTransportCredentials(creds), ![2](assets/2.png) }\n\n  conn, err := grpc.Dial(address, opts...) ![3](assets/3.png) if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close() ![5](assets/5.png)\n  c := pb.NewProductInfoClient(conn) ![4](assets/4.png)\n\n  .... // Skip RPC method invocation. }\n```", "```go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"errors\"\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials\"\n  \"io/ioutil\"\n  \"log\"\n  \"net\"\n)\n\nvar (\n  port = \":50051\"\n  crtFile = \"server.crt\"\n  keyFile = \"server.key\"\n  caFile = \"ca.crt\"\n)\n\nfunc main() {\n  certificate, err := tls.LoadX509KeyPair(crtFile, keyFile) ![1](assets/1.png)\n  if err != nil {\n     log.Fatalf(\"failed to load key pair: %s\", err)\n  }\n\n  certPool := x509.NewCertPool() ![2](assets/2.png)\n  ca, err := ioutil.ReadFile(caFile)\n  if err != nil {\n     log.Fatalf(\"could not read ca certificate: %s\", err)\n  }\n\n  if ok := certPool.AppendCertsFromPEM(ca); !ok { ![3](assets/3.png)\n     log.Fatalf(\"failed to append ca certificate\")\n  }\n\n  opts := []grpc.ServerOption{\n     // Enable TLS for all incoming connections.\n     grpc.Creds( ![4](assets/4.png)\n        credentials.NewTLS(&tls.Config {\n           ClientAuth:   tls.RequireAndVerifyClientCert,\n           Certificates: []tls.Certificate{certificate},\n           ClientCAs:    certPool,\n           },\n        )),\n  }\n\n  s := grpc.NewServer(opts...) ![5](assets/5.png)\n  pb.RegisterProductInfoServer(s, &server{}) ![6](assets/6.png)\n\n  lis, err := net.Listen(\"tcp\", port) ![7](assets/7.png)\n  if err != nil {\n     log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  if err := s.Serve(lis); err != nil { ![8](assets/8.png)\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"io/ioutil\"\n  \"log\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials\"\n)\n\nvar (\n  address = \"localhost:50051\"\n  hostname = \"localhost\"\n  crtFile = \"client.crt\"\n  keyFile = \"client.key\"\n  caFile = \"ca.crt\"\n)\n\nfunc main() {\n  certificate, err := tls.LoadX509KeyPair(crtFile, keyFile) ![1](assets/1.png)\n  if err != nil {\n     log.Fatalf(\"could not load client key pair: %s\", err)\n  }\n\n  certPool := x509.NewCertPool() ![2](assets/2.png)\n  ca, err := ioutil.ReadFile(caFile)\n  if err != nil {\n     log.Fatalf(\"could not read ca certificate: %s\", err)\n  }\n\n  if ok := certPool.AppendCertsFromPEM(ca); !ok { ![3](assets/3.png)\n     log.Fatalf(\"failed to append ca certs\")\n  }\n\n  opts := []grpc.DialOption{\n     grpc.WithTransportCredentials( credentials.NewTLS(&tls.Config{ ![4](assets/4.png)\n        ServerName:   hostname, // NOTE: this is required!\n        Certificates: []tls.Certificate{certificate},\n        RootCAs:      certPool,\n     })),\n  }\n\n  conn, err := grpc.Dial(address, opts...) ![5](assets/5.png)\n  if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()![7](assets/7.png)\n  c := pb.NewProductInfoClient(conn) ![6](assets/6.png)\n\n  .... // Skip RPC method invocation. }\n```", "```go\nAuthorization: Basic YWRtaW46YWRtaW4=\n```", "```go\ntype basicAuth struct { ![1](assets/1.png)\n  username string\n  password string\n}\n\nfunc (b basicAuth) GetRequestMetadata(ctx context.Context,\n  in ...string)  (map[string]string, error) { ![2](assets/2.png)\n  auth := b.username + \":\" + b.password\n  enc := base64.StdEncoding.EncodeToString([]byte(auth))\n  return map[string]string{\n     \"authorization\": \"Basic \" + enc,\n  }, nil\n}\n\nfunc (b basicAuth) RequireTransportSecurity() bool { ![3](assets/3.png)\n  return true\n}\n```", "```go\npackage main\n\nimport (\n  \"log\"\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc/credentials\"\n  \"google.golang.org/grpc\"\n)\n\nvar (\n  address = \"localhost:50051\"\n  hostname = \"localhost\"\n  crtFile = \"server.crt\"\n)\n\nfunc main() {\n  creds, err := credentials.NewClientTLSFromFile(crtFile, hostname)\n  if err != nil {\n     log.Fatalf(\"failed to load credentials: %v\", err)\n  }\n\n  auth := basicAuth{ ![1](assets/1.png)\n    username: \"admin\",\n    password: \"admin\",\n  }\n\n  opts := []grpc.DialOption{\n     grpc.WithPerRPCCredentials(auth), ![2](assets/2.png)\n     grpc.WithTransportCredentials(creds),\n  }\n\n  conn, err := grpc.Dial(address, opts...)\n  if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n  c := pb.NewProductInfoClient(conn)\n\n  .... // Skip RPC method invocation. }\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"crypto/tls\"\n  \"encoding/base64\"\n  \"errors\"\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/codes\"\n  \"google.golang.org/grpc/credentials\"\n  \"google.golang.org/grpc/metadata\"\n  \"google.golang.org/grpc/status\"\n  \"log\"\n  \"net\"\n  \"path/filepath\"\n  \"strings\"\n)\n\nvar (\n  port = \":50051\"\n  crtFile = \"server.crt\"\n  keyFile = \"server.key\"\n  errMissingMetadata = status.Errorf(codes.InvalidArgument, \"missing metadata\")\n  errInvalidToken    = status.Errorf(codes.Unauthenticated, \"invalid credentials\")\n)\n\ntype server struct {\n  productMap map[string]*pb.Product\n}\n\nfunc main() {\n  cert, err := tls.LoadX509KeyPair(crtFile, keyFile)\n  if err != nil {\n     log.Fatalf(\"failed to load key pair: %s\", err)\n  }\n  opts := []grpc.ServerOption{\n     // Enable TLS for all incoming connections.\n     grpc.Creds(credentials.NewServerTLSFromCert(&cert)),\n\n     grpc.UnaryInterceptor(ensureValidBasicCredentials), ![1](assets/1.png)\n  }\n\n  s := grpc.NewServer(opts...)\n  pb.RegisterProductInfoServer(s, &server{})\n\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n     log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  if err := s.Serve(lis); err != nil {\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n\nfunc valid(authorization []string) bool {\n  if len(authorization) < 1 {\n     return false\n  }\n  token := strings.TrimPrefix(authorization[0], \"Basic \")\n  return token == base64.StdEncoding.EncodeToString([]byte(\"admin:admin\"))\n}\n\nfunc ensureValidBasicCredentials(ctx context.Context, req interface{}, info\n*grpc.UnaryServerInfo,\n     handler grpc.UnaryHandler) (interface{}, error) { ![2](assets/2.png)\n  md, ok := metadata.FromIncomingContext(ctx) ![3](assets/3.png)\n  if !ok {\n     return nil, errMissingMetadata\n  }\n  if !valid(md[\"authorization\"]) {\n     return nil, errInvalidToken\n  }\n  // Continue execution of handler after ensuring a valid token.\n  return handler(ctx, req)\n}\n```", "```go\npackage main\n\nimport (\n  \"google.golang.org/grpc/credentials\"\n  \"google.golang.org/grpc/credentials/oauth\"\n  \"log\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"golang.org/x/oauth2\"\n  \"google.golang.org/grpc\"\n)\n\nvar (\n  address = \"localhost:50051\"\n  hostname = \"localhost\"\n  crtFile = \"server.crt\"\n)\n\nfunc main() {\n  auth := oauth.NewOauthAccess(fetchToken()) ![1](assets/1.png)\n\n  creds, err := credentials.NewClientTLSFromFile(crtFile, hostname)\n  if err != nil {\n     log.Fatalf(\"failed to load credentials: %v\", err)\n  }\n\n  opts := []grpc.DialOption{\n     grpc.WithPerRPCCredentials(auth), ![2](assets/2.png)\n     grpc.WithTransportCredentials(creds),\n  }\n\n  conn, err := grpc.Dial(address, opts...)\n  if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n  c := pb.NewProductInfoClient(conn)\n\n  .... // Skip RPC method invocation. }\n\nfunc fetchToken() *oauth2.Token {\n  return &oauth2.Token{\n     AccessToken: \"some-secret-token\",\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"crypto/tls\"\n  \"errors\"\n  \"log\"\n  \"net\"\n  \"strings\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/codes\"\n  \"google.golang.org/grpc/credentials\"\n  \"google.golang.org/grpc/metadata\"\n  \"google.golang.org/grpc/status\"\n)\n\n// server is used to implement ecommerce/product_info. type server struct {\n  productMap map[string]*pb.Product\n}\n\nvar (\n  port = \":50051\"\n  crtFile = \"server.crt\"\n  keyFile = \"server.key\"\n  errMissingMetadata = status.Errorf(codes.InvalidArgument, \"missing metadata\")\n  errInvalidToken    = status.Errorf(codes.Unauthenticated, \"invalid token\")\n)\n\nfunc main() {\n  cert, err := tls.LoadX509KeyPair(crtFile, keyFile)\n  if err != nil {\n     log.Fatalf(\"failed to load key pair: %s\", err)\n  }\n  opts := []grpc.ServerOption{\n     grpc.Creds(credentials.NewServerTLSFromCert(&cert)),\n     grpc.UnaryInterceptor(ensureValidToken), ![1](assets/1.png)\n  }\n\n  s := grpc.NewServer(opts...)\n  pb.RegisterProductInfoServer(s, &server{})\n\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n     log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  if err := s.Serve(lis); err != nil {\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n\nfunc valid(authorization []string) bool {\n  if len(authorization) < 1 {\n     return false\n  }\n  token := strings.TrimPrefix(authorization[0], \"Bearer \")\n  return token == \"some-secret-token\"\n}\n\nfunc ensureValidToken(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo,\n     handler grpc.UnaryHandler) (interface{}, error) { ![2](assets/2.png)\n  md, ok := metadata.FromIncomingContext(ctx)\n  if !ok {\n     return nil, errMissingMetadata\n  }\n  if !valid(md[\"authorization\"]) {\n     return nil, errInvalidToken\n  }\n  return handler(ctx, req)\n}\n```", "```go\njwtCreds, err := oauth.NewJWTAccessFromFile(“token.json”) ![1](assets/1.png)\nif err != nil {\n  log.Fatalf(\"Failed to create JWT credentials: %v\", err)\n}\n\ncreds, err := credentials.NewClientTLSFromFile(\"server.crt\",\n     \"localhost\")\nif err != nil {\n    log.Fatalf(\"failed to load credentials: %v\", err)\n}\nopts := []grpc.DialOption{\n  grpc.WithPerRPCCredentials(jwtCreds),\n  // transport credentials.\n  grpc.WithTransportCredentials(creds), ![2](assets/2.png)\n}\n\n// Set up a connection to the server. conn, err := grpc.Dial(address, opts...)\nif err != nil {\n  log.Fatalf(\"did not connect: %v\", err)\n}\n  .... // Skip Stub generation and RPC method invocation.\n```", "```go\nperRPC, err := oauth.NewServiceAccountFromFile(\"service-account.json\", scope) ![1](assets/1.png)\nif err != nil {\n  log.Fatalf(\"Failed to create JWT credentials: %v\", err)\n}\n\npool, _ := x509.SystemCertPool()\ncreds := credentials.NewClientTLSFromCert(pool, \"\")\n\nopts := []grpc.DialOption{\n  grpc.WithPerRPCCredentials(perRPC),\n  grpc.WithTransportCredentials(creds), ![2](assets/2.png)\n}\n\nconn, err := grpc.Dial(address, opts...)\nif err != nil {\n  log.Fatalf(\"did not connect: %v\", err)\n}\n.... // Skip Stub generation and RPC method invocation.\n```"]