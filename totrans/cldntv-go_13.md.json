["```go\nname := os.Getenv(\"NAME\")\nplace := os.Getenv(\"CITY\")\n\nfmt.Printf(\"%s lives in %s.\\n\", name, place)\n```", "```go\nif val, ok := os.LookupEnv(key); ok {\n    fmt.Printf(\"%s=%s\\n\", key, val)\n} else {\n    fmt.Printf(\"%s not set\\n\", key)\n}\n```", "```go\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Declare a string flag with a default value \"foo\"\n    // and a short description. It returns a string pointer.\n    strp := flag.String(\"string\", \"foo\", \"a string\")\n\n    // Declare number and Boolean flags, similar to the string flag.\n    intp := flag.Int(\"number\", 42, \"an integer\")\n    boolp := flag.Bool(\"boolean\", false, \"a boolean\")\n\n    // Call flag.Parse() to execute command-line parsing.\n    flag.Parse()\n\n    // Print the parsed options and trailing positional arguments.\n    fmt.Println(\"string:\", *strp)\n    fmt.Println(\"integer:\", *intp)\n    fmt.Println(\"boolean:\", *boolp)\n    fmt.Println(\"args:\", flag.Args())\n}\n```", "```go\n$ go run . -help\nUsage of /var/folders/go-build618108403/exe/main:\n  -boolean\n        a boolean\n  -number int\n        an integer (default 42)\n  -string string\n        a string (default \"foo\")\n```", "```go\n$ go run . -boolean -number 27 -string \"A string.\" Other things.\nstring: A string.\ninteger: 27\nboolean: true\nargs: [Other things.]\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"github.com/spf13/cobra\"\n)\n\nvar strp string\nvar intp int\nvar boolp bool\n\nvar rootCmd = &cobra.Command{\n    Use:  \"flags\",\n    Long: \"A simple flags experimentation command, built with Cobra.\",\n    Run:  flagsFunc,\n}\n\nfunc init() {\n    rootCmd.Flags().StringVarP(&strp, \"string\", \"s\", \"foo\", \"a string\")\n    rootCmd.Flags().IntVarP(&intp, \"number\", \"n\", 42, \"an integer\")\n    rootCmd.Flags().BoolVarP(&boolp, \"boolean\", \"b\", false, \"a boolean\")\n}\n\nfunc flagsFunc(cmd *cobra.Command, args []string) {\n    fmt.Println(\"string:\", strp)\n    fmt.Println(\"integer:\", intp)\n    fmt.Println(\"boolean:\", boolp)\n    fmt.Println(\"args:\", args)\n}\n\nfunc main() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n```", "```go\n$ go run . --help\nA simple flags experimentation command, built with Cobra.\n\nUsage:\n  flags [flags]\n\nFlags:\n  -b, --boolean         a boolean\n  -h, --help            help for flags\n  -n, --number int      an integer (default 42)\n  -s, --string string   a string (default \"foo\")\n```", "```go\n$ go run . --boolean --number 27 --string \"A string.\" Other things.\nstring: A string.\ninteger: 27\nboolean: true\nargs: [Other things.]\n```", "```go\nvar flagsCmd = &cobra.Command{\n    Use:   \"flags\",\n    Short: \"Experiment with flags\",\n    Long:  \"A simple flags experimentation command, built with Cobra.\",\n    Run:   flagsFunc,\n}\n\nvar rootCmd = &cobra.Command{\n    Use:  \"cng\",\n    Long: \"A super simple command.\",\n}\n```", "```go\nfunc init() {\n    flagsCmd.Flags().StringVarP(&strp, \"string\", \"s\", \"foo\", \"a string\")\n    flagsCmd.Flags().IntVarP(&intp, \"number\", \"n\", 42, \"an integer\")\n    flagsCmd.Flags().BoolVarP(&boolp, \"boolean\", \"b\", false, \"a boolean\")\n\n    rootCmd.AddCommand(flagsCmd)\n}\n```", "```go\n$ go run . --help\nA super simple command.\n\nUsage:\n  cng [command]\n\nAvailable Commands:\n  flags       Experiment with flags\n  help        Help about any command\n\nFlags:\n  -h, --help   help for cng\n\nUse \"cng [command] --help\" for more information about a command.\n```", "```go\n$ go run . help flags\nA simple flags experimentation command, built with Cobra.\n\nUsage:\n  cng flags [flags]\n\nFlags:\n  -b, --boolean         a boolean\n  -h, --help            help for flags\n  -n, --number int      an integer (default 42)\n  -s, --string string   a string (default \"foo\")\n```", "```go\ntype Config struct {\n    Host string\n    Port uint16\n    Tags map[string]string\n}\n```", "```go\nfunc Marshal(v interface{}) ([]byte, error)\n```", "```go\nc := Config{\n    Host: \"localhost\",\n    Port: 1313,\n    Tags: map[string]string{\"env\": \"dev\"},\n}\n\nbytes, err := json.Marshal(c)\n\nfmt.Println(string(bytes))\n```", "```go\n{\"Host\":\"localhost\",\"Port\":1313,\"Tags\":{\"env\":\"dev\"}}\n```", "```go\nfunc MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)\n```", "```go\nbytes, err := json.MarshalIndent(c, \"\", \"   \")\nfmt.Println(string(bytes))\n```", "```go\n{\n   \"Host\": \"localhost\",\n   \"Port\": 1313,\n   \"Tags\": {\n      \"env\": \"dev\"\n   }\n}\n```", "```go\nfunc Unmarshal(data []byte, v interface{}) error\n```", "```go\nc := Config{}\n```", "```go\nbytes := []byte(`{\"Host\":\"127.0.0.1\",\"Port\":1234,\"Tags\":{\"foo\":\"bar\"}}`)\nerr := json.Unmarshal(bytes, &c)\n```", "```go\n{127.0.0.1 1234 map[foo:bar]}\n```", "```go\nc := Config{}\nbytes := []byte(`{\"Host\":\"127.0.0.1\", \"Food\":\"Pizza\"}`)\nerr := json.Unmarshal(bytes, &c)\n```", "```go\n{127.0.0.1 0 map[]}\n```", "```go\n{\"Host\":\"\",\"Port\":0,\"Tags\":null}\n```", "```go\ntype User struct {\n    Name string `example:\"name\"`\n}\n```", "```go\ntype Tagged struct {\n    // CustomKey will appear in JSON as the key \"custom_key\".\n    CustomKey   string `json:\"custom_key\"`\n\n    // OmitEmpty will appear in JSON as \"OmitEmpty\" (the default),\n    // but will only be written if it contains a nonzero value.\n    OmitEmpty   string `json:\",omitempty\"`\n\n    // IgnoredName will always be ignored.\n    IgnoredName string `json:\"-\"`\n\n    // TwoThings will appear in JSON as the key \"two_things\",\n    // but only if it isn't empty.\n    TwoThings   string `json:\"two_things,omitempty\"`\n}\n```", "```go\nfunc Marshal(v interface{}) ([]byte, error)\n```", "```go\nc := Config{\n    Host: \"localhost\",\n    Port: 1313,\n    Tags: map[string]string{\"env\": \"dev\"},\n}\n\nbytes, err := yaml.Marshal(c)\n```", "```go\nhost: localhost\nport: 1313\ntags:\n  env: dev\n```", "```go\nfunc Unmarshal(data []byte, v interface{}) error\n```", "```go\n// Caution: Indent this YAML with spaces, not tabs.\nbytes := []byte(`\nhost: 127.0.0.1\nport: 1234\ntags:\n foo: bar\n`)\n\nc := Config{}\nerr := yaml.Unmarshal(bytes, &c)\n```", "```go\n{127.0.0.1 1234 map[foo:bar]}\n```", "```go\ntype TaggedMore struct {\n    // Flow will be marshalled using a \"flow\" style\n    // (useful for structs, sequences and maps).\n    Flow map[string]string `yaml:\"flow\"`\n\n    // Inlines a struct or a map, causing all of its fields\n    // or keys to be processed as if they were part of the outer\n    // struct. For maps, keys must not conflict with the yaml\n    // keys of other struct fields.\n    Inline map[string]string `yaml:\",inline\"`\n}\n```", "```go\nvar config Config\n```", "```go\nfunc loadConfiguration(filepath string) (Config, error) {\n    dat, err := ioutil.ReadFile(filepath)   // Ingest file as []byte\n    if err != nil {\n        return Config{}, err\n    }\n\n    config := Config{}\n\n    err = yaml.Unmarshal(dat, &config)      // Do the unmarshal\n    if err != nil {\n        return Config{}, err\n    }\n\n    return config, nil\n}\n```", "```go\nfunc startListening(updates <-chan string, errors <-chan error) {\n    for {\n        select {\n        case filepath := <-updates:\n            c, err := loadConfiguration(filepath)\n            if err != nil {\n                log.Println(\"error loading config:\", err)\n                continue\n            }\n            config = c\n\n        case err := <-errors:\n            log.Println(\"error watching config:\", err)\n        }\n    }\n}\n```", "```go\nfunc init() {\n    updates, errors, err := watchConfig(\"config.yaml\")\n    if err != nil {\n        panic(err)\n    }\n\n    go startListening(updates, errors)\n}\n```", "```go\nfunc watchConfig(filepath string) (<-chan string, <-chan error, error)\n```", "```go\nfunc calculateFileHash(filepath string) (string, error) {\n    file, err := os.Open(filepath)  // Open the file for reading\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()              // Be sure to close your file!\n\n    hash := sha256.New()            // Use the Hash in crypto/sha256\n\n    if _, err := io.Copy(hash, file); err != nil {\n        return \"\", err\n    }\n\n    sum := fmt.Sprintf(\"%x\", hash.Sum(nil))  // Get encoded hash sum\n\n    return sum, nil\n}\n```", "```go\nfunc watchConfig(filepath string) (<-chan string, <-chan error, error) {\n    errs := make(chan error)\n    changes := make(chan string)\n    hash := \"\"\n\n    go func() {\n        ticker := time.NewTicker(time.Second)\n\n        for range ticker.C {\n            newhash, err := calculateFileHash(filepath)\n            if err != nil {\n                errs <- err\n                continue\n            }\n\n            if hash != newhash {\n                hash = newhash\n                changes <- filepath\n            }\n        }\n    }()\n\n    return changes, errs, nil\n}\n```", "```go\nfunc watchConfigNotify(filepath string) (<-chan string, <-chan error, error) {\n    changes := make(chan string)\n\n    watcher, err := fsnotify.NewWatcher()         // Get an fsnotify.Watcher\n    if err != nil {\n        return nil, nil, err\n    }\n\n    err = watcher.Add(filepath)                    // Tell watcher to watch\n    if err != nil {                                // our config file\n        return nil, nil, err\n    }\n\n    go func() {\n        changes <- filepath                        // First is ALWAYS a change\n\n        for event := range watcher.Events {        // Range over watcher events\n            if event.Op&fsnotify.Write == fsnotify.Write {\n                changes <- event.Name\n            }\n        }\n    }()\n\n    return changes, watcher.Errors, nil\n}\n```", "```go\nviper.Set(\"Verbose\", true)\nviper.Set(\"LogFile\", LogFile)\n```", "```go\nvar rootCmd = &cobra.Command{ /* omitted for brevity */ }\n\nfunc init() {\n    rootCmd.Flags().IntP(\"number\", \"n\", 42, \"an integer\")\n    viper.BindPFlag(\"number\", rootCmd.Flags().Lookup(\"number\"))\n}\n```", "```go\nn := viper.GetInt(\"number\")\n```", "```go\nviper.BindEnv(\"id\")                     // Bind \"id\" to var \"ID\"\nviper.BindEnv(\"port\", \"SERVICE_PORT\")   // Bind \"port\" to var \"SERVICE_PORT\"\n\nid := viper.GetInt(\"id\")\nid := viper.GetInt(\"port\")\n```", "```go\nviper.SetConfigName(\"config\")\n\n// Optional if the config has a file extension\nviper.SetConfigType(\"yaml\")\n\nviper.AddConfigPath(\"/etc/service/\")\nviper.AddConfigPath(\"$HOME/.service\")\nviper.AddConfigPath(\".\")\n\nif err := viper.ReadInConfig(); err != nil {\n    panic(fmt.Errorf(\"fatal error reading config: %w\", err))\n}\n```", "```go\nviper.WatchConfig()\nviper.OnConfigChange(func(e fsnotify.Event) {\n    fmt.Println(\"Config file changed:\", e.Name)\n})\n```", "```go\nimport _ \"github.com/spf13/viper/remote\"\n```", "```go\nfunc AddRemoteProvider(provider, endpoint, path string) error\n```", "```go\nviper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/service.json\")\nviper.SetConfigType(\"json\")\nerr := viper.ReadRemoteConfig()\n```", "```go\nviper.BindEnv(\"id\")             // Will be upper-cased automatically\nviper.SetDefault(\"id\", \"13\")    // Default value is \"13\"\n\nid1 := viper.GetInt(\"id\")\nfmt.Println(id1)                // 13\n\nos.Setenv(\"ID\", \"50\")           // Explicitly set the envvar\n\nid2 := viper.GetInt(\"id\")\nfmt.Println(id2)                // 50\n```", "```go\nfunc keyValueGetHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)                     // Retrieve \"key\" from the request\n    key := vars[\"key\"]\n\n    value, err := Get(key)                  // Get value for key\n    if err != nil {                         // Unexpected error!\n        http.Error(w,\n            err.Error(),\n            http.StatusInternalServerError)\n        return\n    }\n\n    w.Write([]byte(value))                  // Write the value to the response\n}\n```", "```go\n// Set to true if you're working on the new storage backend\nconst useNewStorage bool = false;\n\nfunc keyValueGetHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    key := vars[\"key\"]\n\n    var value string\n    var err error\n\n    if useNewStorage {\n        value, err = NewGet(key)\n    } else {\n        value, err = Get(key)\n    }\n\n    if err != nil {\n        http.Error(w,\n            err.Error(),\n            http.StatusInternalServerError)\n        return\n    }\n\n    w.Write([]byte(value))\n}\n```", "```go\nfunc keyValueGetHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    key := vars[\"key\"]\n\n    var value string\n    var err error\n\n    if FeatureEnabled(\"use-new-storage\", r) {\n        value, err = NewGet(key)\n    } else {\n        value, err = Get(key)\n    }\n\n    if err != nil {\n        http.Error(w,\n            err.Error(),\n            http.StatusInternalServerError)\n        return\n    }\n\n    w.Write([]byte(value))\n}\n\nfunc FeatureEnabled(flag string, r *http.Request) bool {\n    return viper.GetBool(flag)\n}\n```", "```go\ntype Enabled func(flag string, r *http.Request) (bool, error)\n```", "```go\n// The list of CIDR ranges associated with internal networks.\nvar privateCIDRs []*net.IPNet\n\n// We use an init function to load the privateCIDRs slice.\nfunc init() {\n    for _, cidr := range []string{\n        \"10.0.0.0/8\",\n        \"172.16.0.0/12\",\n        \"192.168.0.0/16\",\n    } {\n        _, block, _ := net.ParseCIDR(cidr)\n        privateCIDRs = append(privateCIDRs, block)\n    }\n}\n\n// fromPrivateIP receives the flag name (which it ignores) and the\n// request. If the request's remote IP is in a private range per\n// RFC1918, it returns true.\nfunc fromPrivateIP(flag string, r *http.Request) (bool, error) {\n    // Grab the host portion of the request's remote address\n    remoteIP, _, err := net.SplitHostPort(r.RemoteAddr)\n    if err != nil {\n        return false, err\n    }\n\n    // Turn the remote address string into a *net.IPNet\n    ip := net.ParseIP(remoteIP)\n    if ip == nil {\n        return false, errors.New(\"couldn't parse ip\")\n    }\n\n    // Loopbacks are considered \"private.\"\n    if ip.IsLoopback() {\n        return true, nil\n    }\n\n    // Search the CIDRs list for the IP; return true if found.\n    for _, block := range privateCIDRs {\n        if block.Contains(ip) {\n            return true, nil\n        }\n    }\n\n    return false, nil\n}\n```", "```go\nvar enabledFunctions map[string]Enabled\n\nfunc init() {\n    enabledFunctions = map[string]Enabled{}\n    enabledFunctions[\"use-new-storage\"] = fromPrivateIP\n}\n```", "```go\nfunc FeatureEnabled(flag string, r *http.Request) bool {\n    // Explicit flags take precedence\n    if viper.IsSet(flag) {\n        return viper.GetBool(flag)\n    }\n\n    // Retrieve the flag function, if any. If none exists,\n    // return false\n    enabledFunc, exists := enabledFunctions[flag]\n    if !exists {\n        return false\n    }\n\n    // We now have the flag function: call it and return\n    // the result\n    result, err := enabledFunc(flag, r)\n    if err != nil {\n        log.Println(err)\n        return false\n    }\n\n    return result\n}\n```"]