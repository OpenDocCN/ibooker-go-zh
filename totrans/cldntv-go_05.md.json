["```go\nand := true && false\nfmt.Println(and)        // \"false\"\n\nor := true || false\nfmt.Println(or)         // \"true\"\n\nnot := !true\nfmt.Println(not)        // \"false\"\n```", "```go\nvar x complex64 = 3.1415i\nfmt.Println(x)                  // \"(0+3.1415i)\"\n```", "```go\n// The interpreted form\n\"Hello\\nworld!\\n\"\n\n// The raw form\n`Hello\nworld!`\n```", "```go\nvar name type = expression\n```", "```go\nname := expression\n```", "```go\nvar i int\nvar f float64\nvar b bool\nvar s string\n```", "```go\nfmt.Printf(\"integer: %d\\n\", i)   // integer: 0\nfmt.Printf(\"float: %f\\n\", f)     // float: 0.000000\nfmt.Printf(\"boolean: %t\\n\", b)   // boolean: false\nfmt.Printf(\"string: %q\\n\", s)    // string: \"\"\n```", "```go\nstr := \"world\"\n\n_, err := fmt.Printf(\"Hello %s\\n\", str)\nif err != nil {\n    // Do something\n}\n```", "```go\nimport _ \"github.com/lib/pq\"\n```", "```go\nconst language string = \"Go\"\n\nvar favorite bool = true\n\nfunc main() {\n    const text = \"Does %s rule? %t!\"\n    var output = fmt.Sprintf(text, language, favorite)\n\n    fmt.Println(output)   // \"Does Go rule? true!\"\n}\n```", "```go\nvar a [3]int                    // Zero-value array of type [3]int\nfmt.Println(a)                  // \"[0 0 0]\"\nfmt.Println(a[1])               // \"0\"\n\na[1] = 42                       // Update second index\nfmt.Println(a)                  // \"[0 42 0]\"\nfmt.Println(a[1])               // \"42\"\n\ni := a[1]\nfmt.Println(i)                  // \"42\"\n```", "```go\nb := [3]int{2, 4, 6}\n```", "```go\nb := [...]int{2, 4, 6}\n```", "```go\nfmt.Println(len(b))             // \"3\"\nfmt.Println(b[len(b)-1])        // \"6\"\n```", "```go\nn := make([]int, 3)         // Create an int slice with 3 elements\n\nfmt.Println(n)              // \"[0 0 0]\"\nfmt.Println(len(n))         // \"3\"; len works for slices and arrays\n\nn[0] = 8\nn[1] = 16\nn[2] = 32\n\nfmt.Println(n)              // \"[8 16 32]\"\n```", "```go\nm := []int{1}               // A literal []int declaration\nfmt.Println(m)              // \"[1]\"\n```", "```go\nm = append(m, 2)            // Append 2 to m\nfmt.Println(m)              // \"[1 2]\"\n```", "```go\nm = append(m, 2)            // Append to m from the previous snippet\nfmt.Println(m)              // \"[1 2]\"\n\nm = append(m, 3, 4)\nfmt.Println(m)              // \"[1 2 3 4]\"\n\nm = append(m, m...)         // Append m to itself\nfmt.Println(m)              // \"[1 2 3 4 1 2 3 4]\"\n```", "```go\ns0 := []int{0, 1, 2, 3, 4, 5, 6}    // A slice literal\nfmt.Println(s0)                     // \"[0 1 2 3 4 5 6]\"\n```", "```go\ns1 := s0[:4]\nfmt.Println(s1)                     // \"[0 1 2 3]\"\n\ns2 := s0[3:]\nfmt.Println(s2)                     // \"[3 4 5 6]\"\n```", "```go\ns0[3] = 42                          // Change reflected in all 3 slices\nfmt.Println(s0)                     // \"[0 1 2 42 4 5 6]\"\nfmt.Println(s1)                     // \"[0 1 2 42]\"\nfmt.Println(s2)                     // \"[42 4 5 6]\"\n```", "```go\ns := \"foö\"          // Unicode: f=0x66 o=0x6F ö=0xC3B6\nr := []rune(s)\nb := []byte(s)\n```", "```go\nfmt.Printf(\"%7T %v\\n\", s, s)    // \"string foö\"\nfmt.Printf(\"%7T %v\\n\", r, r)    // \"[]int32 [102 111 246]\"\nfmt.Printf(\"%7T %v\\n\", b, b)    // \"[]uint8 [102 111 195 182]\"\n```", "```go\nfreezing := make(map[string]float32)    // Empty map of string to float32\n\nfreezing[\"celsius\"] = 0.0\nfreezing[\"fahrenheit\"] = 32.0\nfreezing[\"kelvin\"] = 273.2\n\nfmt.Println(freezing[\"kelvin\"])         // \"273.2\"\nfmt.Println(len(freezing))              // \"3\"\n\ndelete(freezing, \"kelvin\")              // Delete \"kelvin\"\nfmt.Println(len(freezing))              // \"2\"\n```", "```go\nfreezing := map[string]float32{\n    \"celsius\":    0.0,\n    \"fahrenheit\": 32.0,\n    \"kelvin\":     273.2,                // The trailing comma is required!\n}\n```", "```go\nfoo := freezing[\"no-such-key\"]          // Get non-existent key\nfmt.Println(foo)                        // \"0\" (float32 zero value)\n```", "```go\nnewton, ok := freezing[\"newton\"]        // What about the Newton scale?\nfmt.Println(newton)                     // \"0\"\nfmt.Println(ok)                         // \"false\"\n```", "```go\nvar a int = 10\n\nvar p *int = &a         // p of type *int points to a\nfmt.Println(p)          // \"0x0001\"\nfmt.Println(*p)         // \"10\"\n\n*p = 20                 // indirectly update a\nfmt.Println(a)          // \"20\"\n```", "```go\nvar n *int\nvar x, y int\n\nfmt.Println(n)              // \"<nil>\"\nfmt.Println(n == nil)       // \"true\" (n is nil)\n\nfmt.Println(x == y)         // \"true\" (x and y are both zero)\nfmt.Println(&x == &x)       // \"true\" (*x is equal to itself)\nfmt.Println(&x == &y)       // \"false\" (different vars)\nfmt.Println(&x == nil)      // \"false\" (*x is not nil)\n```", "```go\nsum := 0\n\nfor i := 0; i < 10; i++ {\n    sum += 1\n}\n\nfmt.Println(sum)        // \"10\"\n```", "```go\nsum, i := 0, 0\n\nfor i < 10 {            // Equivalent to: for ; i < 10;\n    sum += i\n    i++\n}\n\nfmt.Println(i, sum)     // \"10 45\"\n```", "```go\nfmt.Println(\"For ever...\")\n\nfor {\n    fmt.Println(\"...and ever\")\n}\n```", "```go\ns := []int{2, 4, 8, 16, 32}     // A slice of ints\n\nfor i, v := range s {           // range gets each index/value\n    fmt.Println(i, \"->\", v)     // Output index and its value\n}\n```", "```go\n0 -> 2\n1 -> 4\n2 -> 8\n3 -> 16\n4 -> 32\n```", "```go\na := []int{0, 2, 4, 6, 8}\nsum := 0\n\nfor _, v := range a {\n    sum += v\n}\n\nfmt.Println(sum)    // \"20\"\n```", "```go\nm := map[int]string{\n    1: \"January\",\n    2: \"February\",\n    3: \"March\",\n    4: \"April\",\n}\n\nfor k, v := range m {\n    fmt.Println(k, \"->\", v)\n}\n```", "```go\n3 -> March\n4 -> April\n1 -> January\n2 -> February\n```", "```go\nif 7 % 2 == 0 {\n    fmt.Println(\"7 is even\")\n} else {\n    fmt.Println(\"7 is odd\")\n}\n```", "```go\nif _, err := os.Open(\"foo.ext\"); err != nil {\n    fmt.Println(err)\n} else {\n    fmt.Println(\"All is fine.\")\n}\n```", "```go\n_, err := os.Open(\"foo.go\")\nif err != nil {\n    fmt.Println(err)\n} else {\n    fmt.Println(\"All is fine.\")\n}\n```", "```go\ni := 0\n\nswitch i % 3 {\ncase 0:\n    fmt.Println(\"Zero\")\n    fallthrough\ncase 1:\n    fmt.Println(\"One\")\ncase 2:\n    fmt.Println(\"Two\")\ndefault:\n    fmt.Println(\"Huh?\")\n}\n```", "```go\nZero\nOne\n```", "```go\nhour := time.Now().Hour()\n\nswitch {\ncase hour >= 5 && hour < 9:\n    fmt.Println(\"I'm writing\")\ncase hour >= 9 && hour < 18:\n    fmt.Println(\"I'm working\")\ndefault:\n    fmt.Println(\"I'm sleeping\")\n}\n```", "```go\nswitch hour := time.Now().Hour(); {  // Empty expression means \"true\"\ncase hour >= 5 && hour < 9:\n    fmt.Println(\"I'm writing\")\ncase hour >= 9 && hour < 18:\n    fmt.Println(\"I'm working\")\ndefault:\n    fmt.Println(\"I'm sleeping\")\n}\n```", "```go\nfile, err := os.Open(\"somefile.ext\")\nif err != nil {\n    log.Fatal(err)\n    return err\n}\n```", "```go\ntype error interface {\n    Error() string\n}\n```", "```go\ne1 := errors.New(\"error 42\")\ne2 := fmt.Errorf(\"error %d\", 42)\n```", "```go\ntype NestedError struct {\n    Message string\n    Err     error\n}\n\nfunc (e *NestedError) Error() string {\n    return fmt.Sprintf(\"%s\\n  contains: %s\", e.Message, e.Err.Error())\n}\n```", "```go\nfunc add(x int, y int) int {\n    return x + y\n}\n\nfunc main() {\n    sum := add(10, 5)\n    fmt.Println(sum)        // \"15\"\n}\n```", "```go\nfunc foo(i int, j int, a string, b string) { /* ... */ }\nfunc foo(i, j int, a, b string)            { /* ... */ }\n```", "```go\nfunc swap(x, y string) (string, string) {\n    return y, x\n}\n```", "```go\na, b := swap(\"foo\", \"bar\")\n```", "```go\nfunc factorial(n int) int {\n    if n < 1 {\n        return 1\n    }\n    return n * factorial(n-1)\n}\n\nfunc main() {\n    fmt.Println(factorial(11))      // \"39916800\"\n}\n```", "```go\nfunc main() {\n    defer fmt.Println(\"cruel world\")\n\n    fmt.Println(\"goodbye\")\n}\n```", "```go\ngoodbye\ncruel world\n```", "```go\nfunc main() {\n    file, err := os.Create(\"/tmp/foo.txt\")  // Create an empty file\n    defer closeFile(file)                   // Ensure closeFile(file) is called\n    if err != nil {\n        return\n    }\n\n    _, err = fmt.Fprintln(file, \"Your mother was a hamster\")\n    if err != nil {\n        return\n    }\n\n    fmt.Println(\"File written to successfully\")\n}\n\nfunc closeFile(f *os.File) {\n    if err := f.Close(); err != nil {\n        fmt.Println(\"Error closing file:\", err.Error())\n    } else {\n        fmt.Println(\"File closed successfully\")\n    }\n}\n```", "```go\nFile written to successfully\nFile closed successfully\n```", "```go\nfunc main() {\n    defer fmt.Println(\"world\")\n    defer fmt.Println(\"cruel\")\n    defer fmt.Println(\"goodbye\")\n}\n```", "```go\ngoodbye\ncruel\nworld\n```", "```go\nfunc main() {\n    x := 5\n\n    zeroByValue(x)\n    fmt.Println(x)              // \"5\"\n\n    zeroByReference(&x)\n    fmt.Println(x)              // \"0\"\n}\n\nfunc zeroByValue(x int) {\n    x = 0\n}\n\nfunc zeroByReference(x *int) {\n    *x = 0                      // Dereference x and set it to 0\n}\n```", "```go\nfunc update(m map[string]int) {\n    m[\"c\"] = 2\n}\n\nfunc main() {\n    m := map[string]int{ \"a\" : 0, \"b\" : 1}\n\n    fmt.Println(m)                  // \"map[a:0 b:1]\"\n\n    update(m)\n\n    fmt.Println(m)                  // \"map[a:0 b:1 c:2]\"\n}\n```", "```go\nfunc Printf(format string, a ...interface{}) (n int, err error)\n```", "```go\nconst name, age = \"Kim\", 22\nfmt.Printf(\"%s is %d years old.\\n\", name, age)\n```", "```go\nfunc product(factors ...int) int {\n    p := 1\n\n    for _, n := range factors {\n        p *= n\n    }\n\n    return p\n}\n\nfunc main() {\n    fmt.Println(product(2, 2, 2))   // \"8\"\n}\n```", "```go\nm := []int{3, 3, 3}\nfmt.Println(product(m...))   // \"27\"\n```", "```go\nfunc sum(x, y int) int     { return x + y }\nfunc product(x, y int) int { return x * y }\n\nfunc main() {\n    var f func(int, int) int    // Function variables have types\n\n    f = sum\n    fmt.Println(f(3, 5))        // \"8\"\n\n    f = product                 // Legal: product has same type as sum\n    fmt.Println(f(3, 5))        // \"15\"\n}\n```", "```go\nfunc incrementer() func() int {\n    i := 0\n\n    return func() int {    // Return an anonymous function\n        i++                // \"Closes over\" parent function's i\n        return i\n    }\n}\n```", "```go\nfunc main() {\n    increment := incrementer()\n    fmt.Println(increment())       // \"1\"\n    fmt.Println(increment())       // \"2\"\n    fmt.Println(increment())       // \"3\"\n\n    newIncrement := incrementer()\n    fmt.Println(newIncrement())    // \"1\"\n}\n```", "```go\ntype Vertex struct {\n    X, Y float64\n}\n\nfunc main() {\n    var v Vertex            // Structs are never nil\n    fmt.Println(v)          // \"{0 0}\"\n\n    v = Vertex{}            // Explicitly define an empty struct\n    fmt.Println(v)          // \"{0 0}\"\n\n    v = Vertex{1.0, 2.0}    // Defining fields, in order\n    fmt.Println(v)          // \"{1 2}\"\n\n    v = Vertex{Y:2.5}       // Defining specific fields, by label\n    fmt.Println(v)          // \"{0 2.5}\"\n}\n```", "```go\nfunc main() {\n    v := Vertex{X: 1.0, Y: 3.0}\n    fmt.Println(v)                  // \"{1 3}\"\n\n    v.X *= 1.5\n    v.Y *= 2.5\n\n    fmt.Println(v)                  // \"{1.5 7.5}\"\n}\n```", "```go\nfunc main() {\n    var v *Vertex = &Vertex{1, 3}\n    fmt.Println(v)                  // &{1 3}\n\n    v.X, v.Y = v.Y, v.X\n    fmt.Println(v)                  // &{3 1}\n}\n```", "```go\nfunc (v *Vertex) Square() {    // Attach method to the *Vertex type\n    v.X *= v.X\n    v.Y *= v.Y\n}\n\nfunc main() {\n    vert := &Vertex{3, 4}\n    fmt.Println(vert)          // \"&{3 4}\"\n\n    vert.Square()\n    fmt.Println(vert)          // \"&{9 16}\"\n}\n```", "```go\ntype MyMap map[string]int\n\nfunc (m MyMap) Length() int {\n    return len(m)\n}\n\nfunc main() {\n    mm := MyMap{\"A\":1, \"B\": 2}\n\n    fmt.Println(mm)             // \"map[A:1 B:2]\"\n    fmt.Println(mm[\"A\"])        // \"1\"\n    fmt.Println(mm.Length())    // \"2\"\n}\n```", "```go\ntype Shape interface {\n    Area() float64\n}\n```", "```go\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n```", "```go\nfunc PrintArea(s Shape) {\n    fmt.Printf(\"%T's area is %0.2f\\n\", s, s.Area())\n}\n\nfunc main() {\n    r := Rectangle{Width:5, Height:10}\n    PrintArea(r)                         // \"main.Rectangle's area is 50.00\"\n\n    c := Circle{Radius:5}\n    PrintArea(c)                         // \"main.Circle's area is 78.54\"\n}\n```", "```go\nvar s Shape\ns = Circle{}                // s is an expression of Shape\nc := s.(Circle)             // Assert that s is a Circle\nfmt.Printf(\"%T\\n\", c)       // \"main.Circle\"\n```", "```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```", "```go\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n```", "```go\ntype ReadWriter struct {\n    *Reader\n    *Writer\n}\n```", "```go\nvar rw *bufio.ReadWriter = GetReadWriter()\nvar bytes []byte = make([]byte, 1024)\n\nn, err := rw.Read(bytes) {\n    // Do something\n}\n```", "```go\nfunc UseReader(r *bufio.Reader) {\n    fmt.Printf(\"We got a %T\\n\", r)      // \"We got a *bufio.Reader\"\n}\n\nfunc main() {\n    var rw *bufio.ReadWriter = GetReadWriter()\n    UseReader(rw.Reader)\n}\n```", "```go\nrw := &bufio.ReadWriter{Reader: &bufio.Reader{}, Writer: &bufio.Writer{}}\n```", "```go\nfoo()       // Call foo() and wait for it to return\ngo foo()    // Spawn a new goroutine that calls foo() concurrently\n```", "```go\nfunc Log(w io.Writer, message string) {\n    go func() {\n        fmt.Fprintln(w, message)\n    }() // Don't forget the trailing parentheses!\n}\n```", "```go\nvar ch chan int = make(chan int)\n```", "```go\nch <- val     // Sending on a channel\nval = <-ch    // Receiving on a channel and assigning it to val\n<-ch          // Receiving on a channel and discarding the result\n```", "```go\nfunc main() {\n    ch := make(chan string)    // Allocate a string channel\n\n    go func() {\n       message := <-ch         // Blocking receive; assigns to message\n       fmt.Println(message)    // \"ping\"\n       ch <- \"pong\"            // Blocking send\n    }()\n\n    ch <- \"ping\"               // Send \"ping\"\n    fmt.Println(<-ch)          // \"pong\"\n}\n```", "```go\nch := make(chan string, 2)    // Buffered channel with capacity 2\n\nch <- \"foo\"                   // Two non-blocking sends\nch <- \"bar\"\n\nfmt.Println(<-ch)             // Two non-blocking receives\nfmt.Println(<-ch)\n\nfmt.Println(<-ch)             // The third receive will block\n```", "```go\nch := make(chan string, 10)\n\nch <- \"foo\"\n\nclose(ch)                          // One value left in the buffer\n\nmsg, ok := <-ch\nfmt.Printf(\"%q, %v\\n\", msg, ok)    // \"foo\", true\n\nmsg, ok = <-ch\nfmt.Printf(\"%q, %v\\n\", msg, ok)    // \"\", false\n```", "```go\nch := make(chan string, 3)\n\nch <- \"foo\"                 // Send three (buffered) values to the channel\nch <- \"bar\"\nch <- \"baz\"\n\nclose(ch)                   // Close the channel\n\nfor s := range ch {         // Range will continue to the \"closed\" flag\n    fmt.Println(s)\n}\n```", "```go\nselect {\ncase <-ch1:                         // Discard received value\n    fmt.Println(\"Got something\")\n\ncase x := <-ch2:                    // Assign received value to x\n    fmt.Println(x)\n\ncase ch3 <- y:                      // Send y to channel\n    fmt.Println(y)\n\ndefault:\n    fmt.Println(\"None of the above\")\n}\n```", "```go\nvar ch chan int\n\nselect {\ncase m := <-ch:                        // Read from ch; blocks forever\n    fmt.Println(m)\n\ncase <-time.After(10 * time.Second):   // time.After returns a channel\n    fmt.Println(\"Timed out\")\n}\n```"]