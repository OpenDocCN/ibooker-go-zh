<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Loose Coupling"><div class="chapter" id="chapter_8">&#13;
<h1><span class="label">Chapter 8. </span>Loose Coupling</h1>&#13;
&#13;
<blockquote>&#13;
<p>We build our computers the way we build our cities—over time, without a plan, on top of ruins.<sup><a data-type="noteref" id="idm45983628500424-marker" href="ch08.xhtml#idm45983628500424">1</a></sup></p>&#13;
<p data-type="attribution">Ellen Ullman, <cite>The Dumbing-down of Programming (May 1998)</cite></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="indexterm" data-primary="coupling" data-seealso="loose coupling, tight coupling" id="ch08_term1"/>Coupling is one of those fascinating topics that seem straightforward in theory but are actually quite challenging in practice. As we’ll discuss, there are lots of ways in which coupling can be introduced in a system, which means it’s also a <em>big</em> subject. As you might imagine, this chapter is an ambitious one, and we cover a lot of ground.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="distributed monolith" id="idm45983628494296"/>First, we’ll introduce the subject, diving more deeply into the concept of “coupling,” and discussing the relative merits of “loose” versus “tight” coupling. We’ll present some of the most common coupling mechanisms, and how some kinds of tight coupling can lead to the dreaded “distributed monolith.”</p>&#13;
&#13;
<p>Next, we’ll talk about inter-service communications, and how fragile exchange protocols are a very common way of introducing tight coupling to distributed systems. We’ll cover some of the common protocols in use today to minimize the degree of coupling between two services.</p>&#13;
&#13;
<p>In the third part, we’ll change direction for a bit, away from distributed systems and into the implementations of the services themselves. We’ll talk about services as code artifacts, subject to coupling resulting from mingling implementations and violating separation of concerns, and present the use of plug-ins as a way to dynamically add implementations.</p>&#13;
&#13;
<p>Finally, we’ll close with a discussion of hexagonal architecture, an architectural pattern that makes loose coupling the central pillar of its design philosophy.</p>&#13;
&#13;
<p>Throughout the chapter, we’ll do our best to balance theory, architecture, and implementation. Most of the chapter will be spent on the fun stuff: discussing a variety of different strategies for managing coupling, particularly (but not exclusively) in the distributed context, and demonstrating by extending our example key/value store.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Tight Coupling"><div class="sect1" id="idm45983628490168">&#13;
<h1>Tight Coupling</h1>&#13;
&#13;
<p>“Coupling” is a somewhat romantic term describing the degree of direct knowledge between components. For example, a client that sends requests to a service is by definition coupled to that service. The degree of that coupling can vary considerably, however, falling anywhere between two extremes.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tight coupling" data-secondary="definition of" id="ch08_term2"/>“Tightly coupled” components have a great deal of knowledge about another component. Perhaps both require the same version of a shared library to communicate, or maybe the client needs an understanding of the server’s architecture or database schema. It’s easy to build tightly coupled systems when optimizing for the short term, but they have a huge downside: the more tightly coupled two components are, the more likely that a change to one component will necessitate corresponding changes to the other. As a result, tightly coupled systems lose many of the benefits of a microservice architecture.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="loose coupling" data-secondary="definition of" id="ch08_term3"/>In contrast, “loosely coupled” components have minimal direct knowledge of one another. They’re relatively independent, typically interacting via a change-robust abstraction. Systems designed for loose coupling require more up-front planning, but they can be more freely upgraded, redeployed, or even entirely rewritten without greatly affecting the systems that depend on them.</p>&#13;
&#13;
<p>Put simply, if you want to know how tightly coupled your system is, ask how many and what kind of changes can be made to one component without adversely affecting another.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Some amount of coupling isn’t necessarily a bad thing, especially early in a system’s development. It can be temping to over-abstract and over-complicate, but premature optimization is <em>still</em> the root of all evil.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch08_coupling">&#13;
<h5>Coupling in Different Computing Contexts</h5>&#13;
<p>The term “coupling” in the computing context predates microservices and service-oriented architecture by quite a bit, and has been used for many years to describe the degree of knowledge that one component has about another.</p>&#13;
&#13;
<p>In programming, code can be tightly coupled when a dependent class directly references a concrete implementation instead of an abstraction (such as an interface; see <a data-type="xref" href="ch03.xhtml#section_ch03_interfaces">“Interfaces”</a>). In Go this might be a function that requires an <code>os.File</code> when an <code>io.Reader</code> would do.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Message Transfer System (MTS)" id="idm45983628476872"/><a data-type="indexterm" data-primary="MTS (Message Transfer System)" id="idm45983628476152"/>Multiprocessor systems that communicate by sharing memory can be said to be tightly coupled. In a loosely coupled system, components are connected through a MTS (Message Transfer System) (see <a data-type="xref" href="ch07.xhtml#section_ch07_efficient_synchronization">“Efficient Synchronization”</a> for a refresher on how Go solves this problem with channels).<a data-type="indexterm" data-primary="loose coupling" data-secondary="definition of" data-startref="ch08_term3" id="idm45983628474312"/></p>&#13;
&#13;
<p>It’s important to note that there might, on occasion, be good reason to tightly couple certain components. Eliminating abstractions and other intermediate layers can reduce overhead, which can be a useful optimization if speed is a critical system requirement.</p>&#13;
&#13;
<p>Since this book is largely about distributed architectures, we’ll focus on coupling between services that communicate across a network, but keep in mind that there are other ways that software can be tightly coupled to resources in its environment.<a data-type="indexterm" data-primary="coupling" data-startref="ch08_term1" id="idm45983628471752"/></p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Tight Coupling Takes Many Forms"><div class="sect2" id="idm45983628470648">&#13;
<h2>Tight Coupling Takes Many Forms</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tight coupling" data-secondary="forms  of" id="ch08_term4"/>There’s no limit to the ways components in a distributed system can find themselves tightly coupled. However, while these all share one fundamental flaw—they all depend on some property of another component that they wrongly assume won’t change—most can be grouped into a few broad classes according to the resource that they’re coupled to.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Fragile exchange protocols"><div class="sect3" id="idm45983628467400">&#13;
<h3>Fragile exchange protocols</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="contract" id="idm45983628466264"/><a data-type="indexterm" data-primary="simple object access protocol" data-see="SOAP" id="idm45983628465400"/><a data-type="indexterm" data-primary="SOAP" id="idm45983628464440"/>Remember SOAP (simple object access protocol)? Statistically speaking, probably not.<sup><a data-type="noteref" id="idm45983628463640-marker" href="ch08.xhtml#idm45983628463640">2</a></sup> SOAP was a messaging protocol developed in the late 1990s that was designed for extensibility and implementation neutrality. SOAP services provided a <em>contract</em> that clients could follow to format their requests.<sup><a data-type="noteref" id="idm45983628462344-marker" href="ch08.xhtml#idm45983628462344">3</a></sup> The concept of the contract was something of a breakthrough at the time, but SOAP’s implementation was exceedingly fragile: if the contract changed in any way, the clients had to be updated along with it. This requirement meant that SOAP clients were tightly coupled to their &#13;
<span class="keep-together">services</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="REST" id="idm45983628460504"/><a data-type="indexterm" data-primary="Google" id="idm45983628459800"/><a data-type="indexterm" data-primary="gRPC" id="idm45983628459128"/><a data-type="indexterm" data-primary="gRPC Remote Procedure Calls" data-see="gRPC" id="idm45983628458456"/>It didn’t take long for people to realize that this was a problem, and SOAP quickly lost its shine. It’s since been largely replaced by REST, which, while a considerable improvement, can often introduce its own tight coupling. In 2016, Google released gRPC (gRPC Remote Procedure Calls<sup><a data-type="noteref" id="idm45983628457112-marker" href="ch08.xhtml#idm45983628457112">4</a></sup>), an open source framework with a number of useful features, including, importantly, allowing loose coupling between components.</p>&#13;
&#13;
<p>We’ll discuss some of these more contemporary options in <a data-type="xref" href="#section_ch08_communications_between_services">“Communications Between Services”</a>, where we’ll see how to use Go’s <code>net/http</code> package to build a REST/HTTP client and extend our key/value store with a gRPC frontend.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Shared dependencies"><div class="sect3" id="idm45983628454184">&#13;
<h3>Shared dependencies</h3>&#13;
&#13;
<p>In 2016, Facebook’s Ben Christensen <a href="https://oreil.ly/ZX2Oe">gave a talk</a> at the Microservices Practitioner Summit where he spoke about another increasingly common mechanism for tightly coupling distributed services, introducing the term “distributed monolith” in the process.</p>&#13;
&#13;
<p>Ben described an anti-pattern in which services were <em>required</em> to use specific libraries—and versions of libraries—in order to launch and interact with one another. Such systems find themselves saddled with a fleet-wide dependency, such that upgrading these shared libraries can force all services to have to upgrade in lockstep. This shared dependency has tightly coupled all of the services in the fleet.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch08_distributed_monoliths">&#13;
<h5>Distributed Monoliths</h5>&#13;
<p><a data-type="indexterm" data-primary="distributed monolith" id="idm45983628448856"/>In <a data-type="xref" href="ch07.xhtml#chapter_7">Chapter 7</a> we made the case that monoliths, at least for complex systems with multiple distinct functions, are (generally) less desirable, and microservices are (generally) the way to go.<sup><a data-type="noteref" id="idm45983628447000-marker" href="ch08.xhtml#idm45983628447000">5</a></sup> Of course, that’s easier said than done, in large part because it’s so easy to accidentally create a <em>distributed monolith</em>: a microservice-based system containing tightly coupled services.</p>&#13;
&#13;
<p>In a distributed monolith, even small changes to one service can necessitate changes to others, often triggering unintended consequences. Services often can’t be deployed independently, so deployments have to be carefully orchestrated, and errors in one component can send faults rippling through the entire system. Rollbacks are functionally impossible.</p>&#13;
&#13;
<p>In other words, a distributed monolith is a “worst of all worlds” system that pairs the management and complexity overhead of multiple services with the dependencies and entanglements of a monolith, losing many of the benefits of microservices in the process. Avoid at all costs.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Shared point-in-time"><div class="sect3" id="idm45983628443160">&#13;
<h3>Shared point-in-time</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="request-response messaging pattern" id="idm45983628441960"/>Often systems are designed in such a way that clients expect an immediate response from services. Systems using this <em>request-response messaging</em> pattern implicitly assume that a service is present and ready to promptly respond. But if it’s not, the request will fail. It can be said that they’re <em>coupled in time</em>.</p>&#13;
&#13;
<p>Coupling in time isn’t necessarily bad practice, though. It might even be preferable, particularly when there’s a human waiting for a timely response. We even detail how to construct such a client in the section <a data-type="xref" href="#section_ch08_request_response">“Request-Response Messaging”</a>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="publish-subscribe messaging pattern" id="idm45983628438216"/>But if the response isn’t necessarily time-constrained, then a safer approach may be to send messages to an intermediate queue that recipients can retrieve from when they’re ready, a messaging pattern commonly referred to as <em>publish-subscribe messaging</em> (“pub-sub” for short).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Fixed addresses"><div class="sect3" id="idm45983628436440">&#13;
<h3>Fixed addresses</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="service discovery" id="idm45983628435032"/>It’s the nature of microservices that they need to talk to one another. But to do that, they first have to find each other. This process of locating services on a network is called <em>service discovery</em>.</p>&#13;
&#13;
<p>Traditionally, services lived at relatively fixed, well-known network locations that could be discovered by referencing some centralized registry. Initially this took the form of manually maintained <code>hosts.txt</code> files, but as networks scaled up so did the adoption of DNS and URLs.</p>&#13;
&#13;
<p>Traditional DNS works well for long-lived services whose locations on the network rarely change, but the increased popularity of ephemeral, microservice-based applications has ushered in a world in which the lifespans of service instances is often measurable in seconds or minutes rather than months or years. In such dynamic environments, URLs and traditional DNS become just another form of tight &#13;
<span class="keep-together">coupling</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="service mesh" id="idm45983628430712"/>This need for dynamic, fluid service discovery has driven the adoption of entirely new strategies like the <em>service mesh</em>, a dedicated layer for facilitating service-to-service communications between resources in a distributed system.<a data-type="indexterm" data-primary="tight coupling" data-startref="ch08_term4" id="idm45983628429240"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-type="indexterm" data-primary="Envoy" id="idm45983628427416"/><a data-type="indexterm" data-primary="Linkerd" id="idm45983628426552"/><a data-type="indexterm" data-primary="Istio" id="idm45983628425880"/><a data-type="indexterm" data-primary="HashiCorp" id="idm45983628425208"/>Unfortunately, we won’t be able to cover the fascinating and fast-developing topics of service discovery or service meshes in this book. But the service mesh field is rich, with a number of mature open source projects with active communities—such as <a href="https://oreil.ly/woDEQ">Envoy</a>, <a href="https://linkerd.io">Linkerd</a>, and <a href="https://oreil.ly/zggyu">Istio</a>—and even commercial offerings like <a href="https://consul.io">Hashicorp’s Consul</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Communications Between Services"><div class="sect1" id="section_ch08_communications_between_services">&#13;
<h1>Communications Between Services</h1>&#13;
&#13;
<p>Communication and message passing is a critical function of distributed systems, and all distributed systems depend on some form of messaging to receive instructions and directions, exchange information, and provide results and updates. Of course, a message is useless if the recipient can’t understand it.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="contract" id="idm45983628418744"/>In order for services to communicate, they must first establish an implicit or explicit <em>contract</em> that defines how messages will be structured. While such a contract is necessary, it also effectively couples the components that depend on it.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="tight coupling" data-secondary="communication" id="idm45983628416968"/>It’s actually very easy to introduce tight coupling in this way, the degree of which is reflected in the protocol’s ability to change safely. Does it allow backward- and forward-compatible changes, like protocol buffers and gRPC, or do minor changes to the contract effectively break communications, as is the case with SOAP?</p>&#13;
&#13;
<p>Of course, the data exchange protocol and its contract isn’t the only variable in inter-service communications. There are, in fact, two broad classes of messaging patterns:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="synchronous messaging pattern" data-see="request-response messaging pattern" id="idm45983628414328"/><a data-type="indexterm" data-primary="request-response messaging pattern" id="ch08_term5"/>Request-response (synchronous)</dt>&#13;
<dd>&#13;
<p>A two-way message exchange in which a requester (the client) issues a request of a receiver (the service) and waits for a response. A textbook example is HTML.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="publish-subscribe messaging pattern" id="idm45983628411032"/>Publish-subscribe (asynchronous)</dt>&#13;
<dd>&#13;
<p>A one-way message exchange in which a requester (the publisher) issues a message to an event bus or message exchange, rather than directly to a specific receiver. Messages can be retrieved asynchronously and acted upon by one or more services (subscribers).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Each of these patterns has a variety of implementations and particular use-cases, each with their own pros and cons. While we won’t be able to cover every possible nuance, we’ll do our best to provide a usable survey and some direction about how they may be implemented in Go.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Request-Response Messaging"><div class="sect1" id="section_ch08_request_response">&#13;
<h1>Request-Response Messaging</h1>&#13;
&#13;
<p>As its name suggests, systems using a <em>request-response</em>, or <em>synchronous</em>, messaging pattern communicate using a series of coordinated requests and responses, in which a requester (or client) submits a request to a receiver (or service) and waits until the receiver responds (hopefully) with the requested the data or service (see <a data-type="xref" href="#img_ch08_request_response">Figure 8-1</a>).</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HTTP" id="idm45983628403704"/><a data-type="indexterm" data-primary="REST" id="idm45983628403000"/><a data-type="indexterm" data-primary="GraphQL" id="idm45983628402328"/>The most obvious example of this pattern might be HTTP, which is so ubiquitous and well-established that it’s been extended beyond its original purpose, and now underlies common messaging protocols like REST and GraphQL.</p>&#13;
&#13;
<figure><div id="img_ch08_request_response" class="figure">&#13;
<img src="Images/cngo_0801.png" alt="cngo 0801" width="657" height="137"/>&#13;
<h6><span class="label">Figure 8-1. </span>Systems using a request-response messaging pattern communicate using a series of coordinated requests and responses</h6>&#13;
</div></figure>&#13;
&#13;
<p>The request-response pattern has the advantages of being relatively easy to reason about and straightforward to implement, and has long been considered the default messaging pattern, particularly for public-facing services. However, it’s also “point-to-point,” involving exactly one requester and receiver, and requires the requesting process to pause until it receives a response.</p>&#13;
&#13;
<p>Together, these properties make the request-response pattern a good choice for straightforward exchanges between two endpoints where a response can be expected in a reasonably short amount of time, but less than ideal when a message has to be sent to multiple receivers or when a response might take longer than a requester might want to wait.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Common Request-Response Implementations"><div class="sect2" id="idm45983628397496">&#13;
<h2>Common Request-Response Implementations</h2>&#13;
&#13;
<p>Over the years, a multitude of bespoke request-response protocols have been developed for any number of purposes. Over time, this has largely settled down, giving way to three major implementations.</p>&#13;
<dl>&#13;
<dt>REST</dt>&#13;
<dd>&#13;
<p>You’re likely already very familiar with REST, which we discussed in some detail in <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>. REST has some things going for it. It’s human-readable and easy to implement, making it a good choice for outward-facing services (which is why we chose it in <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a>). We’ll discuss a little more in <a data-type="xref" href="#section_ch08_issuing_http_requests">“Issuing HTTP Requests with net/http”</a>.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="remote procedure calls" data-see="RPC" id="idm45983628391160"/><a data-type="indexterm" data-primary="RPC" id="idm45983628390184"/>Remote procedure calls (RPC)</dt>&#13;
<dd>&#13;
<p>Remote procedure call (RPC) frameworks allow programs to execute procedures in a different address space, often on another computer. Go provides a standard Go-specific RPC implementation in the form of <code>net/rpc</code>. There are also two big language-agnostic RPC players: Apache Thrift and gRPC. While similar in design and usage goals, gRPC seems to have taken the lead with respect to adoption and community support. We’ll discuss gRPC in much more detail in <a data-type="xref" href="#section_ch08_gRPC">“Remote Procedure Calls with gRPC”</a>.<a data-type="indexterm" data-primary="Apache Thrift" id="idm45983628386856"/><a data-type="indexterm" data-primary="gRPC" id="idm45983628386152"/></p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="GraphQL" id="idm45983628385096"/><a data-type="indexterm" data-primary="REST" id="idm45983628384392"/>GraphQL</dt>&#13;
<dd>&#13;
<p>A relative newcomer on the scene, GraphQL is a query and manipulation language generally considered an alternative to REST, and is particularly powerful when working with complex datasets. We don’t discuss GraphQL in much detail in this book, but I encourage you to <a href="https://graphql.org">look into it</a> the next time you’re designing an outward-facing API.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Issuing HTTP Requests with net/http"><div class="sect2" id="section_ch08_issuing_http_requests">&#13;
<h2>Issuing HTTP Requests with net/http</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HTTP" id="ch08_term7"/>HTTP is perhaps the most common request-response protocol, particularly for public-facing services, underlying popular API formats like REST and GraphQL. If you’re interacting with an HTTP service, you’ll need some way to programmatically issue requests to the service and retrieve the response.<a data-type="indexterm" data-primary="request-response messaging pattern" data-startref="ch08_term5" id="idm45983628377864"/></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="libraries" id="idm45983628376600"/>Fortunately, the Go standard library comes with excellent HTTP client and server implementations in the form of the <code>net/http</code> package. You may remember <code>net/http</code> from <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>, where we used it to build the first iteration of our key/value store.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="GET function" id="ch08_term8"/><a data-type="indexterm" data-primary="HEAD method" id="ch08_term9"/><a data-type="indexterm" data-primary="POST method" id="ch08_term10"/>The <code>net/http</code> includes, among other things, convenience functions for GET, HEAD, and POST methods. The signatures for the first of these, <code>http.Get</code> and <code>http.Head</code>, are shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Get issues a GET to the specified URL</code>&#13;
<code class="kd">func</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">url</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Response</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Head issues a HEAD to the specified URL</code>&#13;
<code class="kd">func</code> <code class="nx">Head</code><code class="p">(</code><code class="nx">url</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Response</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>The previous functions are very straightforward and are both used similarly: each accepts a <code>string</code> that represents the URL of interest, and each returns an <code>error</code> value and a pointer to an <code>http.Response</code> struct.</p>&#13;
&#13;
<p>The <code>http.Response</code> struct is particularly useful because it contains all kinds of useful information about the service’s response to our request, including the returned status code and the response body.</p>&#13;
&#13;
<p>A small selection of the <code>http.Response</code> struct is in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Response</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Status</code>     <code class="kt">string</code>       <code class="c1">// e.g. "200 OK"</code>&#13;
    <code class="nx">StatusCode</code> <code class="kt">int</code>          <code class="c1">// e.g. 200</code>&#13;
&#13;
    <code class="c1">// Header maps header keys to values.</code>&#13;
    <code class="nx">Header</code> <code class="nx">Header</code>&#13;
&#13;
    <code class="c1">// Body represents the response body.</code>&#13;
    <code class="nx">Body</code> <code class="nx">io</code><code class="p">.</code><code class="nx">ReadCloser</code>&#13;
&#13;
    <code class="c1">// ContentLength records the length of the associated content. The</code>&#13;
    <code class="c1">// value -1 indicates that the length is unknown.</code>&#13;
    <code class="nx">ContentLength</code> <code class="kt">int64</code>&#13;
&#13;
    <code class="c1">// Request is the request that was sent to obtain this Response.</code>&#13;
    <code class="nx">Request</code> <code class="o">*</code><code class="nx">Request</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There are some useful things in there! Of particular interest is the <code>Body</code> field, which provides access to the HTTP response body. It’s a <code>ReadCloser</code> interface, which tells us two things: that the response body is streamed on demand as it’s read, and that it has a <code>Close</code> method that we’re expected to call.</p>&#13;
&#13;
<p>In the following, we demonstrate several things: how to use the <code>Get</code> convenience function, how to close the response body, and how to use <code>io.ReadAll</code> to read the <em>entire</em> response body as a string (if you’re into that kind of thing):</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
    <code class="s">"io"</code>&#13;
    <code class="s">"net/http"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">resp</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"http://example.com"</code><code class="p">)</code>     <code class="c1">// Send an HTTP GET</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">defer</code> <code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code>                         <code class="c1">// Close your response!</code>&#13;
&#13;
    <code class="nx">body</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">io</code><code class="p">.</code><code class="nx">ReadAll</code><code class="p">(</code><code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">)</code>          <code class="c1">// Read body as []byte</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">body</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the last example, we use the <code>http.Get</code> function to issue a GET to the URL <code>http://example.com</code>, which returns a pointer to a <code>http.Response</code> struct and an <code>error</code> value.</p>&#13;
&#13;
<p>As we mentioned previously, access to the HTTP response body is provided via the <code>resp.Body</code> variable, which implements <code>io.ReadCloser</code>. Note how we <code>defer</code> the call <code>resp.Body.Close()</code>. This is very important: failing to close your response body can sometimes lead to some unfortunate memory leaks.</p>&#13;
&#13;
<p>Because <code>Body</code> implements <code>io.Reader</code>, we have many different standard means to retrieve its data. In this case we use the very reliable <code>io.ReadAll</code>, which conveniently returns the entire response body as a <code>[]byte</code> slice, which we simply print.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Always remember to use <code>Close()</code> to close your response body!</p>&#13;
&#13;
<p>Not doing so can lead to some unfortunate memory leaks.</p>&#13;
</div>&#13;
&#13;
<p>We’ve already seen the <code>Get</code> and <code>Head</code> functions, but how do we issue POSTs? Fortunately, similar convenience functions exist for them too. Two, in fact: <code>http.Post</code> and <code>http.PostForm</code>. The signatures for each of these are shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Post issues a POST to the specified URL</code>&#13;
<code class="kd">func</code> <code class="nx">Post</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">contentType</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">body</code> <code class="nx">io</code><code class="p">.</code><code class="nx">Reader</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">Response</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// PostForm issues a POST to the specified URL, with data's keys</code>&#13;
<code class="c1">// and values URL-encoded as the request body</code>&#13;
<code class="kd">func</code> <code class="nx">PostForm</code><code class="p">(</code><code class="nx">url</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">data</code> <code class="nx">url</code><code class="p">.</code><code class="nx">Values</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">Response</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HTTP" data-startref="ch08_term7" id="idm45983628158216"/>The first of these, <code>Post</code>, expects an <code>io.Reader</code> that provides the body—such as a file of a JSON object—of the post. We demonstrate how to upload JSON text in a POST in the following code:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
    <code class="s">"io"</code>&#13;
    <code class="s">"net/http"</code>&#13;
    <code class="s">"strings"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">const</code> <code class="nx">json</code> <code class="p">=</code> <code class="s">`{ "name":"Matt", "age":44 }`</code>      <code class="c1">// This is our JSON</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">in</code> <code class="o">:=</code> <code class="nx">strings</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">json</code><code class="p">)</code>               <code class="c1">// Wrap JSON with an io.Reader</code>&#13;
&#13;
    <code class="c1">// Issue HTTP POST, declaring our content-type as "text/json"</code>&#13;
    <code class="nx">resp</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Post</code><code class="p">(</code><code class="s">"http://example.com/upload"</code><code class="p">,</code> <code class="s">"text/json"</code><code class="p">,</code> <code class="nx">in</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">defer</code> <code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code>                     <code class="c1">// Close your response!</code>&#13;
&#13;
    <code class="nx">message</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">io</code><code class="p">.</code><code class="nx">ReadAll</code><code class="p">(</code><code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">message</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch08_convenience_functions">&#13;
<h5>A Possible Pitfall of Convenience Functions</h5>&#13;
<p>We’ve been referring to the <code>Get</code>, <code>Head</code>, <code>Post</code>, and <code>PostForm</code> functions as “convenience functions,” but what does that mean?</p>&#13;
&#13;
<p>It turns out that, under the hood, each is actually calling a method on a default <code>*http.Client</code> value, a concurrency-safe type that Go uses to manage the internals of communicating over HTTP.</p>&#13;
&#13;
<p>The code for the <code>Get</code> convenience function, for example, is actually a call to the default client’s <code>http.Client.Get</code> method:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">url</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="nx">resp</code> <code class="o">*</code><code class="nx">Response</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">DefaultClient</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, when you use <code>http.Get</code>, you’re actually using <code>http.DefaultClient</code>. Because <code>http.Client</code> is concurrency safe, it’s possible to have only one of these, predefined as a package variable.</p>&#13;
&#13;
<p>The source code for the creation of <code>DefaultClient</code> itself is somewhat plain, creating a zero-value <code>http.Client</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">DefaultClient</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">Client</code><code class="p">{}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="timeouts" id="idm45983627925736"/>Generally, this is perfectly fine. However, there’s a potential issue here, and it involves timeouts. The <code>http.Client</code> methods are capable of asserting timeouts that terminate long-running requests. This is super useful. Unfortunately, the default timeout value is 0, which Go interprets as “no timeout.”</p>&#13;
&#13;
<p>Okay, so Go’s default HTTP client will never time out. Is that a problem? <em>Usually</em> not, but what if it connects to a server that doesn’t respond and doesn’t close the connection? The result would be an especially nasty and nondeterministic memory leak.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="GET function" data-startref="ch08_term8" id="idm45983627922568"/><a data-type="indexterm" data-primary="HEAD method" data-startref="ch08_term9" id="idm45983627921368"/><a data-type="indexterm" data-primary="POST method" data-startref="ch08_term10" id="idm45983627920424"/>But how do we fix this? Well, as it turns out, <code>http.Client</code> <em>does</em> support timeouts; we just have to enable that functionality by creating a custom <code>Client</code> and setting a &#13;
<span class="keep-together">timeout</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">client</code> <code class="p">=</code> <code class="o">&amp;</code><code class="nx">http</code><code class="p">.</code><code class="nx">Client</code><code class="p">{</code>&#13;
    <code class="nx">Timeout</code><code class="p">:</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code> <code class="o">*</code> <code class="mi">10</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">response</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code></pre>&#13;
&#13;
<p>Take a look at the <a href="https://oreil.ly/91haC"><code>net/http</code> package documentation</a> for more information about <code>http.Client</code> and its available settings.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Remote Procedure Calls with gRPC"><div class="sect2" id="section_ch08_gRPC">&#13;
<h2>Remote Procedure Calls with gRPC</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Google" id="idm45983627780856"/><a data-type="indexterm" data-primary="Stubby" id="idm45983627780264"/><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983627779592"/><a data-type="indexterm" data-primary="RPC" id="ch08_term11"/><a data-type="indexterm" data-primary="gRPC" id="ch08_term12"/>gRPC is an efficient, polyglot data exchange framework that was originally developed by Google as the successor to <em>Stubby</em>, a general-purpose RPC framework that had been in use internally at Google for over a decade. It was open sourced in 2015 under the name gRPC, and taken over by the Cloud Native Computing Foundation in 2017.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="REST" id="idm45983627775912"/><a data-type="indexterm" data-primary="SOAP" id="idm45983627775208"/><a data-type="indexterm" data-primary="Apache Thrift" id="idm45983627774536"/><a data-type="indexterm" data-primary="Java RMI" id="idm45983627773864"/><a data-type="indexterm" data-primary="COBRA" id="idm45983627773192"/>Unlike REST, which is essentially a set of unenforced best practices, gRPC is a fully-featured data exchange framework, which, like other RPC frameworks such as SOAP, Apache Thrift, Java RMI, and CORBA (to name a few) allows a client to execute specific methods implemented on different systems as if they were local functions.</p>&#13;
&#13;
<p>This approach has a number of advantages over REST, including but not limited to:</p>&#13;
<dl>&#13;
<dt>Conciseness</dt>&#13;
<dd>&#13;
<p>Its messages are more compact, consuming less network I/O.</p>&#13;
</dd>&#13;
<dt>Speed</dt>&#13;
<dd>&#13;
<p>Its binary exchange format is much faster to marshal and unmarshal.</p>&#13;
</dd>&#13;
<dt>Strong-typing</dt>&#13;
<dd>&#13;
<p>It’s natively strongly typed, eliminating a lot of boilerplate and removing a common source of errors.</p>&#13;
</dd>&#13;
<dt>Feature-rich</dt>&#13;
<dd>&#13;
<p>It has a number of built-in features like authentication, encryption, timeout, and compression (to name a few) that you would otherwise have to implement yourself.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>That’s not to say that gRPC is always the best choice. Compared to REST:</p>&#13;
<dl>&#13;
<dt>Contract-driven</dt>&#13;
<dd>&#13;
<p>gRPC’s contracts make it less suitable for external-facing services.</p>&#13;
</dd>&#13;
<dt>Binary format</dt>&#13;
<dd>&#13;
<p>gRPC data isn’t human-readable, making it harder to inspect and debug.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>gRPC is a very large and rich subject that this modest section can’t fully do justice to. If you’re interested in learning more I recommend the official <a href="https://oreil.ly/10q7G">“Introduction to gRPC”</a> and the excellent <a href="https://oreil.ly/Dxhjo"><em>gRPC: Up and Running</em></a> by Kasun Indrasiri and Danesh Kuruppu (O’Reilly Media).</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" class="pagebreak-before less_space" data-pdf-bookmark="Interface definition with protocol buffers"><div class="sect3" id="idm45983627759112">&#13;
<h3>Interface definition with protocol buffers</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="service interface" id="idm45983627757400"/><a data-type="indexterm" data-primary="Interface Definition Language (IDL)" id="idm45983627756696"/><a data-type="indexterm" data-primary="IDL (Interface Definition Language)" id="idm45983627756008"/><a data-type="indexterm" data-primary="JSON" id="idm45983627755320"/><a data-type="indexterm" data-primary="protocol buffers" id="ch08_term13"/>As is the case with most RPC frameworks, gRPC requires you to define a <em>service interface</em>. By default, gRPC uses <a href="https://oreil.ly/JKoyj"><em>protocol buffers</em></a> for this purpose, though it’s possible to use an alternative Interface Definition Language (IDL) like JSON if you want.</p>&#13;
&#13;
<p>To define a service interface, the author uses the protocol buffers schema to describe the service methods that can be called remotely by a client in a <code>.proto</code> file. This is then <em>compiled</em> into a language-specific interface (Go code, in our case).</p>&#13;
&#13;
<p>As illustrated in <a data-type="xref" href="#img_ch08_gRPC_overview">Figure 8-2</a>, gRPC servers implement the resulting source code to handle client calls, while the client has a stub that provides the same methods as the server.</p>&#13;
&#13;
<figure><div id="img_ch08_gRPC_overview" class="figure">&#13;
<img src="Images/cngo_0802.png" alt="cngo 0802" width="771" height="427"/>&#13;
<h6><span class="label">Figure 8-2. </span>By default, gRPC uses protocol buffers as both its Interface Definition Language and its underlying message interchange format; servers and clients can be written in <a href="https://oreil.ly/N0uWc">any supported language</a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Yes, this seems very hand-wavey and abstract right now. Keep reading for some more details!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Installing the protocol compiler"><div class="sect3" id="section_ch08_installing_protoc">&#13;
<h3>Installing the protocol compiler</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="protocol buffers" id="ch08_term14"/>Before we proceed, we’ll first need to install the protocol buffer compiler, <code>protoc</code>, and the Go protocol buffers plug-in. We’ll use these to compile <code>.proto</code> files into Go service interface code.</p>&#13;
<ol>&#13;
<li>&#13;
<p>If you’re using Linux or MacOS, the simplest and easiest way to install <code>protoc</code> is to use a package manager. To install it on a Debian-flavored Linux you can use <code>apt</code> or <code>apt-get</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>apt install -y protobuf-compiler&#13;
<code class="nv">$ </code>protoc --version</pre>&#13;
&#13;
<p class="pagebreak-before less_space">The easiest way to install <code>protoc</code> on MacOS is to use Homebrew:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>brew install protobuf&#13;
<code class="nv">$ </code>protoc --version</pre>&#13;
</li>&#13;
<li>&#13;
<p>Run the following command to install the Go protocol buffers plug-in:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go install google.golang.org/protobuf/cmd/protoc-gen-go</pre>&#13;
&#13;
<p>The compiler plug-in <code>protoc-gen-go</code> will be installed in <code>$GOBIN</code>, defaulting to <code>$GOPATH/bin</code>. It must be in your <code>$PATH</code> for <code>protoc</code> to find it.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This book uses protocol buffers version 3. Be sure to check your version of <code>protoc</code> after installation to make sure that it’s version 3 or higher.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="indexterm" data-primary="protocol buffer compiler installation" id="idm45983627650968"/>If you’re using another OS, your chosen package manager has an old version, or if you just want to make sure you have the latest and greatest, you can find the instructions for installing the precompiled binaries on gRPC’s <a href="https://oreil.ly/b6RAD">Protocol Buffer Compiler Installation page</a>.<a data-type="indexterm" data-primary="Go" data-secondary="protocol buffers" data-startref="ch08_term14" id="idm45983627649320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The message definition structure"><div class="sect3" id="idm45983627725720">&#13;
<h3>The message definition structure</h3>&#13;
&#13;
<p>Protocol buffers are a language-neutral mechanism for serializing structured data. You can think of it as a binary version of XML.<sup><a data-type="noteref" id="idm45983627711544-marker" href="ch08.xhtml#idm45983627711544">6</a></sup> Protocol buffer data is structured as <em>messages</em>, where each message is a small record of information containing a series of name-value pairs called <em>fields</em>.</p>&#13;
&#13;
<p>The first step when working with protocol buffers is to define the message structure by defining it in a <code>.proto</code> file. A basic example is presented in the following:</p>&#13;
<div id="code_ch08_example_proto" data-type="example">&#13;
<h5><span class="label">Example 8-1. </span>An example <code>.proto</code> file. The <code>message</code> definitions define remote procedure payloads.</h5>&#13;
&#13;
<pre data-type="programlisting" data-code-language="proto"><code class="na">syntax</code> <code class="o">=</code> <code class="s">"proto3"</code><code class="p">;</code>&#13;
&#13;
<code class="k">option</code> <code class="na">go_package</code> <code class="o">=</code> <code class="s">"github.com/cloud-native-go/ch08/point"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Point represents a labeled position on a 2-dimensional surface</code>&#13;
<code class="kd">message</code> <code class="nc">Point</code> <code class="p">{</code>&#13;
  <code class="kt">int32</code> <code class="na">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="kt">int32</code> <code class="na">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
  <code class="kt">string</code> <code class="na">label</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Line contains start and end Points</code>&#13;
<code class="kd">message</code> <code class="nc">Line</code> <code class="p">{</code>&#13;
  <code class="n">Point</code> <code class="na">start</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="n">Point</code> <code class="na">end</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
  <code class="kt">string</code> <code class="na">label</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Polyline contains any number (including zero) of Points</code>&#13;
<code class="kd">message</code> <code class="nc">Polyline</code> <code class="p">{</code>&#13;
  <code class="k">repeated</code> <code class="n">Point</code> <code class="na">point</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="kt">string</code> <code class="na">label</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>You may have noticed that the protocol buffer syntax is reminiscent of C/C++, complete with its semicolon and commenting syntax.</p>&#13;
&#13;
<p>The first line of the file specifies that you’re using <code>proto3</code> syntax: if you don’t do this, the protocol buffer compiler will assume you are using <code>proto2</code>. This must be the first nonempty, noncomment line of the file.</p>&#13;
&#13;
<p>The second line uses the <code>option</code> keyword to specify the full import path of the Go package that will contain the generated code.</p>&#13;
&#13;
<p>Finally, we have three <code>message</code> definitions, which describe the structure of the payload messages. In this example, we have three messages of increasing complexity:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Point</code>, which contains <code>x</code> and <code>y</code> integer values, and a <code>label</code> string</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Line</code>, which contains exactly two <code>Point</code> values</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Polyline</code>, which uses the <code>repeated</code> keyword to indicate that it can contain any number of <code>Point</code> values</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="indexterm" data-primary="field number" id="idm45983627487928"/>Each <code>message</code> contains zero or more fields that have a name and a type. Note that each field in a message definition has a <em>field number</em> that is unique for that message type. These are used to identify fields in the message binary format, and should not be changed once your message type is in use.</p>&#13;
&#13;
<p>If this raises a “tight coupling” red flag in your mind, you get a gold star for paying attention. For this reason, protocol buffers provide explicit support for <a href="https://oreil.ly/IeyL2">updating message types</a>, including marking a field as <a href="https://oreil.ly/I1Jiu">reserved</a> so that it can’t be accidentally reused.</p>&#13;
&#13;
<p>This example is incredibly simple, but don’t let that fool you: protocol buffers are capable of some very sophisticated encodings. See the <a href="https://oreil.ly/UDl65">Protocol Buffers Language Guide</a> for more information.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The key-value message structure"><div class="sect3" id="idm45983627712760">&#13;
<h3>The key-value message structure</h3>&#13;
&#13;
<p>So how do we make use of protocol buffers and gRPC to extend the example key-value store that we started in <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a>?</p>&#13;
&#13;
<p>Let’s say that we want to implement gRPC equivalents to the <code>Get</code>, <code>Put</code>, and <code>Delete</code> functions we are already exposing via RESTful methods. The message formats for that might look something like the following <code>.proto</code> file:</p>&#13;
<div id="code_ch08_keyvalue_messages_proto" data-type="example">&#13;
<h5><span class="label">Example 8-2. </span><code>keyvalue.proto</code>—the messages that will be passed to and from our key-value service procedures</h5>&#13;
&#13;
<pre data-type="programlisting" data-code-language="proto"><code class="na">syntax</code> <code class="o">=</code> <code class="s">"proto3"</code><code class="p">;</code>&#13;
&#13;
<code class="k">option</code> <code class="na">go_package</code> <code class="o">=</code> <code class="s">"github.com/cloud-native-go/ch08/keyvalue"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// GetRequest represents a request to the key-value store for the</code>&#13;
<code class="c1">// value associated with a particular key</code>&#13;
<code class="kd">message</code> <code class="nc">GetRequest</code> <code class="p">{</code>&#13;
  <code class="kt">string</code> <code class="na">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// GetResponse represents a response from the key-value store for a</code>&#13;
<code class="c1">// particular value</code>&#13;
<code class="kd">message</code> <code class="nc">GetResponse</code> <code class="p">{</code>&#13;
  <code class="kt">string</code> <code class="na">value</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// PutRequest represents a request to the key-value store for the</code>&#13;
<code class="c1">// value associated with a particular key</code>&#13;
<code class="kd">message</code> <code class="nc">PutRequest</code> <code class="p">{</code>&#13;
  <code class="kt">string</code> <code class="na">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="kt">string</code> <code class="na">value</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// PutResponse represents a response from the key-value store for a</code>&#13;
<code class="c1">// Put action.</code>&#13;
<code class="kd">message</code> <code class="nc">PutResponse</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// DeleteRequest represents a request to the key-value store to delete</code>&#13;
<code class="c1">// the record associated with a key</code>&#13;
<code class="kd">message</code> <code class="nc">DeleteRequest</code> <code class="p">{</code>&#13;
  <code class="kt">string</code> <code class="na">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// DeleteResponse represents a response from the key-value store for a</code>&#13;
<code class="c1">// Delete action.</code>&#13;
<code class="kd">message</code> <code class="nc">DeleteResponse</code> <code class="p">{}</code></pre></div>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Don’t let the names of the message definitions confuse you: they represent <em>messages</em> (nouns) that will be passed to and from functions (verbs) that we’ll define in the next section.</p>&#13;
</div>&#13;
&#13;
<p>In the <em>.proto</em> file, which we’ll call <em>keyvalue.proto</em>, we have three <code>Request</code> message definitions describing messages that will be sent from the client to the server, and three <code>Response</code> message definitions describing the server’s response messages.</p>&#13;
&#13;
<p>You may have noticed that we don’t include <code>error</code> or <code>status</code> values in the message response definitions. As you’ll see in <a data-type="xref" href="#section_ch08_impl_grpc_client">“Implementing the gRPC client”</a>, these are unnecessary because they’re included in the return values of the gRPC client functions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Defining our service methods"><div class="sect3" id="idm45983627398328">&#13;
<h3>Defining our service methods</h3>&#13;
&#13;
<p>So now that we’ve completed our message definitions, we’ll need to describe the methods that’ll use them.</p>&#13;
&#13;
<p>To do that, we extend our <em>keyvalue.proto</em> file, using the <code>rpc</code> keyword to define our service interfaces. Compiling the modified <em>.proto</em> file will generate Go code that includes the service interface code and client stubs.</p>&#13;
<div id="code_ch08_keyvalue_rpc_proto" data-type="example">&#13;
<h5><span class="label">Example 8-3. </span><code>keyvalue.proto</code>—the procedures for our key-value service.</h5>&#13;
&#13;
<pre data-type="programlisting" data-code-language="proto"><code class="kd">service</code> <code class="n">KeyValue</code> <code class="p">{</code>&#13;
  <code class="k">rpc</code> <code class="n">Get</code><code class="p">(</code><code class="n">GetRequest</code><code class="p">)</code> <code class="k">returns</code> <code class="p">(</code><code class="n">GetResponse</code><code class="p">);</code>&#13;
&#13;
  <code class="k">rpc</code> <code class="n">Put</code><code class="p">(</code><code class="n">PutRequest</code><code class="p">)</code> <code class="k">returns</code> <code class="p">(</code><code class="n">PutResponse</code><code class="p">);</code>&#13;
&#13;
  <code class="k">rpc</code> <code class="n">Delete</code><code class="p">(</code><code class="n">DeleteRequest</code><code class="p">)</code> <code class="k">returns</code> <code class="p">(</code><code class="n">DeleteResponse</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>In contrast to the messages defined in <a data-type="xref" href="#code_ch08_keyvalue_messages_proto">Example 8-2</a>, the <code>rpc</code> definitions represent functions (verbs) which will send and receive messages (nouns).</p>&#13;
</div>&#13;
&#13;
<p>In this example, we add three methods to our service:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Get</code>, which accepts a <code>GetRequest</code> and returns a <code>GetResponse</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Put</code>, which accepts a <code>PutRequest</code> and returns a <code>PutResponse</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Delete</code>, which accepts a <code>DeleteRequest</code> and returns a <code>DeleteResponse</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note that we don’t actually implement the functionality here. We do that later.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="unary RPC" id="idm45983627367880"/>The previous methods are all examples of <em>unary RPC</em> definitions, in which a client sends a single request to the server and gets a single response back. This is the simplest of the four service methods types. Various streaming modes are also supported, but these are beyond the scope of this simple primer. The <a href="https://oreil.ly/rs3dN">gRPC documentation</a> discusses these in more detail.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Compiling your protocol buffers"><div class="sect3" id="idm45983627365512">&#13;
<h3>Compiling your protocol buffers</h3>&#13;
&#13;
<p>Now that you have a <em>.proto</em> file complete with message and service definitions, &#13;
<span class="keep-together">the next</span> thing you need to do is generate the classes you’ll need to read and write &#13;
<span class="keep-together">messages</span>. To do this, you need to run the protocol buffer compiler <code>protoc</code> on our &#13;
<span class="keep-together"><em>keyvalue.proto</em>.</span></p>&#13;
&#13;
<p>If you haven’t installed the <code>protoc</code> compiler and Go protocol buffers plug-in, follow the directions in <a data-type="xref" href="#section_ch08_installing_protoc">“Installing the protocol compiler”</a> to do so.</p>&#13;
&#13;
<p>Now you can run the compiler, specifying the source directory (<code>$SOURCE_DIR</code>) where your application’s source code lives (which defaults to the the current directory), the destination directory (<code>$DEST_DIR</code>; often the same as <code>$SOURCE_DIR</code>), and the path to your <em>keystore.proto</em>. Because we want Go code, you use the <code>--go_out</code> option. <code>protoc</code> provides equivalent options to generate code for other supported languages as well.</p>&#13;
&#13;
<p>In this case, we would invoke:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>protoc --proto_path<code class="o">=</code><code class="nv">$SOURCE_DIR</code> <code class="se">\</code>&#13;
    --go_out<code class="o">=</code><code class="nv">$DEST_DIR</code> --go_opt<code class="o">=</code><code class="nv">paths</code><code class="o">=</code>source_relative <code class="se">\</code>&#13;
    --go-grpc_out<code class="o">=</code><code class="nv">$DEST_DIR</code> --go-grpc_opt<code class="o">=</code><code class="nv">paths</code><code class="o">=</code>source_relative <code class="se">\</code>&#13;
    <code class="nv">$SOURCE_DIR</code>/keyvalue.proto</pre>&#13;
&#13;
<p>The <code>go_opt</code> and <code>go-grpc_opt</code> flags tell <code>protoc</code> to place the output files in the same relative directory as the input file. Our <em>keyvalue.proto</em> file results in two files, named <em>keyvalue.pb.go</em> and <em>keyvalue_grpc.pb.go</em>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="protocol buffers" data-startref="ch08_term13" id="idm45983627240360"/>Without these flags, the output files are placed in a directory named after the Go package’s import path. Our <em>keyvalue.proto</em> file, for example, would result in a file named <code>github.com/cloud-native-go/ch08/keyvalue/keyvalue.pb.go</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementing the gRPC service"><div class="sect3" id="section_ch08_implementing_grpc_service">&#13;
<h3>Implementing the gRPC service</h3>&#13;
&#13;
<p>To implement our gRPC server, we’ll need to implement the generated service interface, which defines the server API for our key-value service. It can be found in &#13;
<span class="keep-together"><em>keyvalue_grpc.pb.go</em></span> as <code>KeyValueServer</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">KeyValueServer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Get</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="o">*</code><code class="nx">GetRequest</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">GetResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Put</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="o">*</code><code class="nx">PutRequest</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">PutResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Delete</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="o">*</code><code class="nx">DeleteRequest</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">PutResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, the <code>KeyValueServer</code> interface specifies our <code>Get</code>, <code>Put</code>, and <code>Delete</code> methods: each accepts a <code>context.Context</code> and a request pointer, and returns a response pointer and an <code>error</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>As a side effect of its simplicity, it’s dead easy to mock requests to, and responses from, a gRPC server implementation.</p>&#13;
</div>&#13;
&#13;
<p>To implement our server, we’ll make use of a generated struct that provides a default implementation for the <code>KeyValueServer</code> interface, which, in our case, is named &#13;
<span class="keep-together"><code>UnimplementedKeyValueServer</code>.</span> It’s so named because it includes default “unimplemented” versions of all of our client methods attached, which look something like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">UnimplementedKeyValueServer</code> <code class="kd">struct</code> <code class="p">{}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="o">*</code><code class="nx">UnimplementedKeyValueServer</code><code class="p">)</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="o">*</code><code class="nx">GetRequest</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">GetResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">status</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="nx">codes</code><code class="p">.</code><code class="nx">Unimplemented</code><code class="p">,</code> <code class="s">"method not implemented"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By embedding the <code>UnimplementedKeyValueServer</code>, we’re able to implement our key-value gRPC server. This is demonstrated with the following code, in which we implement the <code>Get</code> method. The <code>Put</code> and <code>Delete</code> methods are omitted for brevity:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"context"</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"net"</code>&#13;
&#13;
    <code class="nx">pb</code> <code class="s">"github.com/cloud-native-go/ch08/keyvalue"</code>&#13;
    <code class="s">"google.golang.org/grpc"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// server is used to implement KeyValueServer. It MUST embed the generated</code>&#13;
<code class="c1">// struct pb.UnimplementedKeyValueServer</code>&#13;
<code class="kd">type</code> <code class="nx">server</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">pb</code><code class="p">.</code><code class="nx">UnimplementedKeyValueServer</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">server</code><code class="p">)</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">r</code> <code class="o">*</code><code class="nx">pb</code><code class="p">.</code><code class="nx">GetRequest</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">pb</code><code class="p">.</code><code class="nx">GetResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Received GET key=%v"</code><code class="p">,</code> <code class="nx">r</code><code class="p">.</code><code class="nx">Key</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// The local Get function is implemented back in Chapter 5</code>&#13;
    <code class="nx">value</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">Get</code><code class="p">(</code><code class="nx">r</code><code class="p">.</code><code class="nx">Key</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Return expects a GetResponse pointer and an err</code>&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">pb</code><code class="p">.</code><code class="nx">GetResponse</code><code class="p">{</code><code class="nx">Value</code><code class="p">:</code> <code class="nx">value</code><code class="p">},</code> <code class="nx">err</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Create a gRPC server and register our KeyValueServer with it</code>&#13;
    <code class="nx">s</code> <code class="o">:=</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">NewServer</code><code class="p">()</code>&#13;
    <code class="nx">pb</code><code class="p">.</code><code class="nx">RegisterKeyValueServer</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">server</code><code class="p">{})</code>&#13;
&#13;
    <code class="c1">// Open a listening port on 50051</code>&#13;
    <code class="nx">lis</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">Listen</code><code class="p">(</code><code class="s">"tcp"</code><code class="p">,</code> <code class="s">":50051"</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"failed to listen: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Start accepting connections on the listening port</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Serve</code><code class="p">(</code><code class="nx">lis</code><code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"failed to serve: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the previous code, we implement and start our service in four steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p><em>Create the server struct.</em> Our <code>server</code> struct embeds <code>pb.UnimplementedKeyValueServer</code>. This is not optional: gRPC requires your server struct to similarly embed its generated <code>UnimplementedXXXServer</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Implement the service methods.</em> We implement the service methods defined in the generated <code>pb.KeyValueServer</code> interface. Interestingly, because the <code>pb.UnimplementedKeyValueServer</code> includes stubs for all of these service methods, we don’t have to implement them all right away.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Register our gRPC server.</em> In the <code>main</code> function, we create a new instance of the <code>server</code> struct and register it with the gRPC framework. This is similar to how we registered handler functions in <a data-type="xref" href="ch05.xhtml#section_ch05_server_with_nethttp">“Building an HTTP Server with net/http”</a>, except we register an entire instance rather than individual functions.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Start accepting connections.</em> Finally, we open a listening port<sup><a data-type="noteref" id="idm45983626853480-marker" href="ch08.xhtml#idm45983626853480">7</a></sup> using <code>net.Listen</code>, which we pass to the gRPC framework via <code>s.Serve</code> to begin listening.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>It could be argued that gRPC provides the best of both worlds by providing the freedom to implement any desired functionality without having to be concerned with building many of the tests and checks usually associated with a RESTful service.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Implementing the gRPC client"><div class="sect3" id="section_ch08_impl_grpc_client">&#13;
<h3>Implementing the gRPC client</h3>&#13;
&#13;
<p>Because all of the client code is generated, making use of a gRPC client is fairly straightforward.</p>&#13;
&#13;
<p>The generated client interface will be named <code>XXXClient</code>, which in our case will be <code>KeyValueClient</code>, shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">KeyValueClient</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Get</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">in</code> <code class="o">*</code><code class="nx">GetRequest</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">grpc</code><code class="p">.</code><code class="nx">CallOption</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">GetResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">Put</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">in</code> <code class="o">*</code><code class="nx">PutRequest</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">grpc</code><code class="p">.</code><code class="nx">CallOption</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">PutResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
&#13;
    <code class="nx">Delete</code><code class="p">(</code><code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code> <code class="nx">in</code> <code class="o">*</code><code class="nx">DeleteRequest</code><code class="p">,</code> <code class="nx">opts</code> <code class="o">...</code><code class="nx">grpc</code><code class="p">.</code><code class="nx">CallOption</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="o">*</code><code class="nx">PutResponse</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All of the methods described in our source <code>.proto</code> file are specified here, each accepting a request type pointer, and returning a response type pointer and an error.</p>&#13;
&#13;
<p>Additionally, each of the methods accepts a <code>context.Context</code> (if you’re rusty on what this is or how it’s used, take a look at <a data-type="xref" href="ch04.xhtml#section_ch04_context">“The Context Package”</a>), and zero or more instances of <code>grpc.CallOption</code>. <code>CallOption</code> is used to modify the behavior of the client when it executes its calls. More detail can be found <a href="https://oreil.ly/t8fEz">in the gRPC API documentation</a>.</p>&#13;
&#13;
<p>I demonstrate how to create and use a gRPC client in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"context"</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"os"</code>&#13;
    <code class="s">"strings"</code>&#13;
    <code class="s">"time"</code>&#13;
&#13;
    <code class="nx">pb</code> <code class="s">"github.com/cloud-native-go/ch08/keyvalue"</code>&#13;
    <code class="s">"google.golang.org/grpc"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Set up a connection to the gRPC server</code>&#13;
    <code class="nx">conn</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">Dial</code><code class="p">(</code><code class="s">"localhost:50051"</code><code class="p">,</code>&#13;
        <code class="nx">grpc</code><code class="p">.</code><code class="nx">WithInsecure</code><code class="p">(),</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">WithBlock</code><code class="p">(),</code> <code class="nx">grpc</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">))</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"did not connect: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">defer</code> <code class="nx">conn</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Get a new instance of our client</code>&#13;
    <code class="nx">client</code> <code class="o">:=</code> <code class="nx">pb</code><code class="p">.</code><code class="nx">NewKeyValueClient</code><code class="p">(</code><code class="nx">conn</code><code class="p">)</code>&#13;
&#13;
    <code class="kd">var</code> <code class="nx">action</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">value</code> <code class="kt">string</code>&#13;
&#13;
    <code class="c1">// Expect something like "set foo bar"</code>&#13;
    <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">)</code> <code class="p">&gt;</code> <code class="mi">2</code> <code class="p">{</code>&#13;
        <code class="nx">action</code><code class="p">,</code> <code class="nx">key</code> <code class="p">=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>&#13;
        <code class="nx">value</code> <code class="p">=</code> <code class="nx">strings</code><code class="p">.</code><code class="nx">Join</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">3</code><code class="p">:],</code> <code class="s">" "</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Use context to establish a 1-second timeout.</code>&#13;
    <code class="nx">ctx</code><code class="p">,</code> <code class="nx">cancel</code> <code class="o">:=</code> <code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(),</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code>&#13;
    <code class="k">defer</code> <code class="nx">cancel</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Call client.Get() or client.Put() as appropriate.</code>&#13;
    <code class="k">switch</code> <code class="nx">action</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s">"get"</code><code class="p">:</code>&#13;
        <code class="nx">r</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">pb</code><code class="p">.</code><code class="nx">GetRequest</code><code class="p">{</code><code class="nx">Key</code><code class="p">:</code> <code class="nx">key</code><code class="p">})</code>&#13;
        <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
            <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"could not get value for key %s: %v\n"</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Get %s returns: %s"</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">r</code><code class="p">.</code><code class="nx">Value</code><code class="p">)</code>&#13;
&#13;
    <code class="k">case</code> <code class="s">"put"</code><code class="p">:</code>&#13;
        <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Put</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">pb</code><code class="p">.</code><code class="nx">PutRequest</code><code class="p">{</code><code class="nx">Key</code><code class="p">:</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">Value</code><code class="p">:</code> <code class="nx">value</code><code class="p">})</code>&#13;
        <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
            <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"could not put key %s: %v\n"</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"Put %s"</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
&#13;
    <code class="k">default</code><code class="p">:</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"Syntax: go run [get|put] KEY VALUE..."</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The preceding example parses command-line values to determine whether it should do a <code>Get</code> or a <code>Put</code> operation.</p>&#13;
&#13;
<p>First, it establishes a connection with the gRPC server using the <code>grpc.Dial</code> function, which takes a target address string, and one or more <code>grpc.DialOption</code> arguments that configure how the connection gets set up. In our case we use:</p>&#13;
&#13;
<ul class="pagebreak-before less_space">&#13;
<li>&#13;
<p><code>WithInsecure</code>, which disables transport security for this <code>ClientConn</code>. <em>Don’t use insecure connections in production.</em></p>&#13;
</li>&#13;
<li>&#13;
<p><code>WithBlock</code>, which makes <code>Dial</code> a block until a connection is established, otherwise the connection will occur in the background.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>WithTimeout</code>, which makes a blocking <code>Dial</code> throw an error if it takes longer than the specified amount of time.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Next, it uses <code>NewKeyValueClient</code> to get a new <code>KeyValueClient</code>, and gets the various command-line arguments.</p>&#13;
&#13;
<p>Finally, based on the <code>action</code> value, we call either <code>client.Get</code> or <code>client.Put</code>, both of which return an appropriate return type and an error.</p>&#13;
&#13;
<p>Once again, these functions look and feel exactly like local function calls. No checking status codes, hand-building our own clients, or any other funny business.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Loose Coupling Local Resources with Plug-ins"><div class="sect1" id="idm45983627781960">&#13;
<h1>Loose Coupling Local Resources with Plug-ins</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="loose coupling" data-secondary="plug-ins" id="ch08_term15"/>At first glance, the topic of loose coupling of local—as opposed to remote or distributed—resources might seem mostly irrelevant to a discussion of “cloud native” technologies. But you might be surprised how often such patterns come in handy.</p>&#13;
&#13;
<p>For example, it’s often useful to build services or tools that can accept data from different kinds of input sources (such as REST interface, a gRPC interface, and a chatbot interface) or generate different kinds of outputs (such as generating different kinds of logging or metric formats). As an added bonus, designs that support such modularity can also make mocking resources for testing dead simple.</p>&#13;
&#13;
<p>As we’ll see in <a data-type="xref" href="#section_ch08_hexagonal_architecture">“Hexagonal Architecture”</a>, entire software architectures &#13;
<span class="keep-together">have even</span> been built around this concept.</p>&#13;
&#13;
<p>No discussion of loose coupling would be complete without a review of plug-in &#13;
<span class="keep-together">technologies</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="In-Process Plug-ins with the plugin Package"><div class="sect2" id="idm45983626372440">&#13;
<h2>In-Process Plug-ins with the plugin Package</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="plug-ins" id="ch08_term17"/>Go provides a native plug-in system in the form of the standard <a href="https://oreil.ly/zxt9W"><code>plugin</code> package</a>. This package is used to open and access Go plug-ins, but it’s not necessary to actually build the plug-ins themselves.</p>&#13;
&#13;
<p>As we’ll demonstrate in the following, the requirements for building and using a Go plug-in are pretty minimal. It doesn’t have to even know it’s a plug-in or even import the <code>plugin</code> package. A Go plug-in has three real requirements: it must be in the <code>main</code> package, &#13;
<span class="keep-together">it must</span> export one or more functions or variables, and it must be compiled using the &#13;
<span class="keep-together"><code>-buildmode=plugin</code></span> build flag. That’s it, really.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983626365112">&#13;
<h5>Go Plug-in Caveats</h5>&#13;
<p>Before we get too deep into the subject of Go plug-ins, it’s important to mention some caveats up front.</p>&#13;
<ol>&#13;
<li>&#13;
<p>As of Go version 1.16.1, Go plug-ins are only supported on Linux, FreeBSD, and MacOS.</p>&#13;
</li>&#13;
<li>&#13;
<p>The version of Go used to build a plug-in must match the program that’s using it <em>exactly</em>. Plug-ins built with Go 1.16.0 won’t work with Go 1.16.1.</p>&#13;
</li>&#13;
<li>&#13;
<p>Similarly, the versions of any packages used by both the plug-in and program must also match <em>exactly</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, building plug-ins forces <code>CGO_ENABLED</code>, making cross-compiling more complicated.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>These conditions make Go plug-ins most appropriate when you’re building plug-ins for use within the same codebase, but it adds considerable obstacles for creating distributable plug-ins.</p>&#13;
</div></aside>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Plug-in vocabulary"><div class="sect3" id="idm45983626357032">&#13;
<h3>Plug-in vocabulary</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="plug-ins" data-seealso="Go plug-ins, looking up plug-ins, loose coupling plug-ins, opening plug-ins, symbol plug-ins" id="ch08_term16"/>Before we continue, we need to define a few terms that are particular to plug-ins. Each of the following describes a specific plug-in concept, and each has a corresponding type or function implementation in the <code>plugin</code> package. We’ll go into all of these in more detail in our example.</p>&#13;
<dl>&#13;
<dt>Plug-in</dt>&#13;
<dd>&#13;
<p>A <em>plug-in</em> is a Go <code>main</code> package with one or more exported functions and variables that has been built with the <code>-buildmode=plugin</code> build flag. It’s represented in the <code>plugin</code> package by the <code>Plugin</code> type.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="opening plug-ins" id="idm45983626349128"/>Open</dt>&#13;
<dd>&#13;
<p><em>Opening</em> a plug-in is the process of loading it into memory, validating it, and discovering its exposed symbols. A plug-in at a known location in the file system can be opened using the <code>Open</code> function, which returns a <code>*Plugin</code> value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">Open</code><code class="p">(</code><code class="nx">path</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">Plugin</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="symbol plug-ins" id="idm45983626336488"/>Symbol</dt>&#13;
<dd>&#13;
<p>A plug-in <em>symbol</em> is any variable or function that’s exported by the plug-in’s package. Symbols can be retrieved by “looking them up,” and are represented in the <code>plugin</code> package by the <code>Symbol</code> type:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Symbol</code> <code class="kd">interface</code><code class="p">{}</code></pre>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="looking up plug-ins" id="idm45983626311928"/>Look up</dt>&#13;
<dd>&#13;
<p><em>Looking up</em> describes the process of searching for and retrieving a symbol exposed by a plug-in. The <code>plugin</code> package’s <code>Lookup</code> method provides that functionality, and returns a <code>Symbol</code> value:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="p">(</code><code class="nx">p</code> <code class="o">*</code><code class="nx">Plugin</code><code class="p">)</code> <code class="nx">Lookup</code><code class="p">(</code><code class="nx">symName</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="nx">Symbol</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In the next section, we present a toy example that demonstrates how these resources are used, and dig into a little detail in the process.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="A toy plug-in example"><div class="sect3" id="section_ch08_standard_plugin_example">&#13;
<h3>A toy plug-in example</h3>&#13;
&#13;
<p>You can only learn so much from a review of the API, even one as minimal as the <code>plugin</code> package. So, let’s build ourselves a toy example: a program that tells you about various animals,<sup><a data-type="noteref" id="idm45983626256968-marker" href="ch08.xhtml#idm45983626256968">8</a></sup> as implemented by plug-ins.</p>&#13;
&#13;
<p>For this example, we’ll be creating three independent packages with the following package structure:</p>&#13;
&#13;
<pre data-type="programlisting">~/cloud-native-go/ch08/go-plugin&#13;
├── duck&#13;
│   └── duck.go&#13;
├── frog&#13;
│   └── frog.go&#13;
└── main&#13;
    └── main.go</pre>&#13;
&#13;
<p>The <code>duck/duck.go</code> and <code>frog/frog.go</code> files each contain the source code for one plug-in. The <code>main/main.go</code> file contains our example’s <code>main</code> function, which will load and use the plug-ins we’ll generate by building <code>frog.go</code> and <code>duck.go</code>.</p>&#13;
&#13;
<p>The complete source code for this example is available in <a href="https://oreil.ly/9jRyU">this book’s companion GitHub repository</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The Sayer interface"><div class="sect3" id="section_ch08_standard_plugin_sayer">&#13;
<h3>The Sayer interface</h3>&#13;
&#13;
<p>In order for a plug-in to be useful, the functions that access it need to know what symbols to look up and what contract those symbols conform to.</p>&#13;
&#13;
<p>One convenient—but by no means required—way to do this is to use an interface that a symbol can be expected to satisfy. In our particular implementation our plug-ins will expose just one symbol—<code>Animal</code>—which we’ll expect to conform to the following <code>Sayer</code> interface:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Sayer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Says</code><code class="p">()</code> <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This interface describes only one method, <code>Says</code>, which returns a string that says what an animal says.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="The Go plugin code"><div class="sect3" id="idm45983626240184">&#13;
<h3>The Go plugin code</h3>&#13;
&#13;
<p>We have source for two separate plug-ins in <code>duck/duck.go</code> and <code>frog/frog.go</code>. In the following snippet, the first of these, <code>duck/duck.go</code>, is shown in its entirety and displays all of the requirements of a plug-in implementation:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">duck</code> <code class="kd">struct</code><code class="p">{}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">d</code> <code class="nx">duck</code><code class="p">)</code> <code class="nx">Says</code><code class="p">()</code> <code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s">"quack!"</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Animal is exported as a symbol.</code>&#13;
<code class="kd">var</code> <code class="nx">Animal</code> <code class="nx">duck</code></pre>&#13;
&#13;
<p>As described in the introduction to this section, the requirements for Go plug-in are really, really minimal: it just has to be a <code>main</code> package that exports one or more variables or functions.</p>&#13;
&#13;
<p>The previous plug-in code describes and exports just one feature—<code>Animal</code>—that satisfies the preceding <code>Sayer</code> interface. Recall that exported package variables and symbols are exposed on the plug-in as shared library symbols that can be looked up later. In this case, our code will have to look specifically for the exported <code>Animal</code> symbol.</p>&#13;
&#13;
<p>In this example we have only one symbol, but there’s no explicit limit to the number of symbols we can have. We could have exported many more features, if we &#13;
<span class="keep-together">wanted to.</span></p>&#13;
&#13;
<p>We won’t show the <code>frog/frog.go</code> file here because it’s essentially the same. But it’s important to know that the internals of a plug-in don’t matter as long as it satisfies the expectations of its consumer. These expectations are that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The plug-in exposes a symbol named <code>Animal</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>Animal</code> symbol adheres to the contract defined by the <code>Sayer</code> interface.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Building the plug-ins"><div class="sect3" id="idm45983626158856">&#13;
<h3>Building the plug-ins</h3>&#13;
&#13;
<p>Building a Go plug-in is very similar to building any other Go <code>main</code> package, except that you have to include the <code>-buildmode=plugin</code> build parameter.</p>&#13;
&#13;
<p>To build our <code>duck/duck.go</code> plug-in code, we do the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go build -buildmode<code class="o">=</code>plugin -o duck/duck.so duck/duck.go</pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Executable Linkable Format" id="idm45983626154520"/>The result is a shared object (<code>.so</code>) file in ELF (Executable Linkable Format) format:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>file duck/duck.so&#13;
duck/duck.so: Mach-O 64-bit dynamically linked shared library x86_64</pre>&#13;
&#13;
<p>ELF files are commonly used for plug-ins because once they’re loaded into memory by the kernel they expose symbols in a way that allows for easy discovery and access.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Using our go plug-ins"><div class="sect3" id="section_ch08_using_our_go_plugins">&#13;
<h3>Using our go plug-ins</h3>&#13;
&#13;
<p>Now that we’ve built our plug-ins, which are patiently sitting there with their <code>.so</code> extensions, we need to write some code that’ll load and use them.</p>&#13;
&#13;
<p>Note that even though we have our plug-ins fully built and in place, we haven’t had to reach for the <code>plugin</code> package yet. However, now that we want to actually use our plug-ins, we get to change that now.</p>&#13;
&#13;
<p>The process of finding, opening, and consuming a plug-in requires several steps, which I demonstrate next.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Import the plugin package"><div class="sect4" id="idm45983626149320">&#13;
<h4>Import the plugin package</h4>&#13;
&#13;
<p>First things first: we have to import the <code>plugin</code> package, which will provide us the tools we need to open and access our plug-ins.</p>&#13;
&#13;
<p>In this example, we import four packages: <code>fmt</code>, <code>log</code>, <code>os</code>, and most relevant to this example, <code>plugin</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"os"</code>&#13;
    <code class="s">"plugin"</code>&#13;
<code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Find our plug-in"><div class="sect4" id="idm45983626007416">&#13;
<h4>Find our plug-in</h4>&#13;
&#13;
<p>To load a plug-in, we have to find its relative or absolute file path. For this reason, plug-in binaries are usually named according to some pattern and placed somewhere where they can be easily discovered, like the user’s command path or other standard fixed location.</p>&#13;
&#13;
<p>For simplicity, our implementation assumes that our plug-in has the same name as the user’s chosen animal and lives in a path relative to the execution location:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">)</code> <code class="o">!=</code> <code class="mi">2</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="s">"usage: run main/main.go animal"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Get the animal name, and build the path where we expect to</code>&#13;
<code class="c1">// find the corresponding shared object (.so) file.</code>&#13;
<code class="nx">name</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
<code class="nx">module</code> <code class="o">:=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"./%s/%s.so"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code></pre>&#13;
&#13;
<p>Importantly, this approach means that our plug-in doesn’t need to be known—or even exist—at compile time. In this manner, we’re able to implement whatever plug-ins we want at any time, and load and access them dynamically as we see fit.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Open our plug-in"><div class="sect4" id="idm45983625958296">&#13;
<h4>Open our plug-in</h4>&#13;
&#13;
<p>Now that we think we know our plug-in’s path we can use the <code>Open</code> function to “open” it, loading it into memory and discovering its available symbols. The <code>Open</code> function returns a <code>*Plugin</code> value that can then be used to look up any symbols exposed by the plug-in:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Open our plugin and get a *plugin.Plugin.</code>&#13;
<code class="nx">p</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">plugin</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">module</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When a plug-in is first opened by the <code>Open</code> function, the <code>init</code> functions of all packages that aren’t already part of the program are called. The package’s <code>main</code> function is <em>not</em> run.</p>&#13;
&#13;
<p>When a plug-in is opened, a single canonical <code>*Plugin</code> value representation of it is loaded into memory. If a particular path has already been opened, subsequent calls to <code>Open</code> will return the same <code>*Plugin</code> value.</p>&#13;
&#13;
<p>A plug-in can’t be loaded more than once, and can’t be closed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Look up your symbol"><div class="sect4" id="idm45983625925800">&#13;
<h4>Look up your symbol</h4>&#13;
&#13;
<p>To retrieve a variable or function exported by our package—and therefore exposed as a symbol by the plug-in—we have to use the <code>Lookup</code> method to find it. Unfortunately, the <code>plugin</code> package doesn’t provide any way to list all of the symbols exposed by a plug-in, so you we to know the name of our symbol ahead of time:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Lookup searches for a symbol named "Animal" in plug-in p.</code>&#13;
<code class="nx">symbol</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">p</code><code class="p">.</code><code class="nx">Lookup</code><code class="p">(</code><code class="s">"Animal"</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If the symbol exists in the plug-in <code>p</code>, then <code>Lookup</code> returns a <code>Symbol</code> value. If the symbol doesn’t exist in <code>p</code>, then a non-nil <code>error</code> is returned instead.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Assert and use your symbol"><div class="sect4" id="idm45983625857976">&#13;
<h4>Assert and use your symbol</h4>&#13;
&#13;
<p>Now that we have our <code>Symbol</code>, we can convert it into the form we need and use it however we want. To make things nice and easy for us, the <code>Symbol</code> type is essentially a rebranded <code>interface{}</code> value. From the <code>plugin</code> source code:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Symbol</code> <code class="kd">interface</code><code class="p">{}</code></pre>&#13;
&#13;
<p>This means that as long as we know what our symbol’s type is, we can use type assertion to coerce it into a concrete type value that can be used however we see fit:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// Asserts that the symbol interface holds a Sayer.</code>&#13;
<code class="nx">animal</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="nx">symbol</code><code class="p">.(</code><code class="nx">Sayer</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="p">!</code><code class="nx">ok</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="s">"that's not a Sayer"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Now we can use our loaded plug-in!</code>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"A %s says: %q\n"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">animal</code><code class="p">.</code><code class="nx">Says</code><code class="p">())</code></pre>&#13;
&#13;
<p>In the previous code, we assert that the <code>symbol</code> value satisfies the <code>Sayer</code> interface. If it does, we print what our animal says. If it doesn’t we’re able to exit gracefully.</p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Executing our example"><div class="sect3" id="idm45983626047048">&#13;
<h3>Executing our example</h3>&#13;
&#13;
<p>Now that we’ve written our main code that attempts to open and access the plug-in, we can run it like any other Go <code>main</code> package, passing the animal name in the &#13;
<span class="keep-together">arguments</span>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run main/main.go duck&#13;
A duck says: <code class="s2">"quack!"</code>&#13;
&#13;
<code class="nv">$ </code>go run main/main.go frog&#13;
A frog says: <code class="s2">"ribbit!"</code></pre>&#13;
&#13;
<p>We can even implement arbitrary plug-ins later without changing our main source code:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>go run main/main.go fox&#13;
A fox says: <code class="s2">"ring-ding-ding-ding-dingeringeding!"</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="HashiCorp’s Go Plug-in System over RPC"><div class="sect2" id="idm45983626371784">&#13;
<h2>HashiCorp’s Go Plug-in System over RPC</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HashiCorp" id="ch08_term19"/>HashiCorp’s <a href="https://oreil.ly/owKQp">Go plugin system</a> has been in wide use—both internally to HashiCorp and elsewhere—since at least 2016, predating the release of Go’s standard <code>plugin</code> package by about a year.</p>&#13;
&#13;
<p>Unlike Go plug-ins, which use shared libraries, HashiCorp’s plug-ins are standalone processes that are executed by using <code>exec.Command</code>, which has some obvious benefits over shared libraries:</p>&#13;
<dl>&#13;
<dt>They can’t crash your host process</dt>&#13;
<dd>&#13;
<p>Because they’re separate processes, a <code>panic</code> in a plug-in doesn’t automatically crash the plug-in consumer.</p>&#13;
</dd>&#13;
<dt>They’re more version-flexible</dt>&#13;
<dd>&#13;
<p>Go plug-ins are famously version-specific. HashiCorp plug-ins are far less so, expecting only that plug-ins adhere to a contract. It also supports explicit protocol versioning.</p>&#13;
</dd>&#13;
<dt>They’re relatively secure</dt>&#13;
<dd>&#13;
<p>HashiCorp plug-ins only have access to the interfaces and parameters passed to them, as opposed to the entire memory space of the consuming process.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>They do have a couple of downsides, though:</p>&#13;
<dl>&#13;
<dt>More verbose</dt>&#13;
<dd>&#13;
<p>HashiCorp plug-ins require more boilerplate than Go plug-ins.</p>&#13;
</dd>&#13;
<dt>Lower performance</dt>&#13;
<dd>&#13;
<p>Because all data exchange with HashiCorp plug-ins occurs over RPC, communication with Go plug-ins is generally more performant.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>That being said, let’s take a look at what it takes to assemble a simple plug-in.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Another toy plug-in example"><div class="sect3" id="idm45983625740712">&#13;
<h3>Another toy plug-in example</h3>&#13;
&#13;
<p>So we can compare apples to apples, we’re going to work through a toy example that’s functionally identical to the one for the standard <code>plugin</code> package in <a data-type="xref" href="#section_ch08_standard_plugin_example">“A toy plug-in example”</a>: a program that tells you what various animals say.</p>&#13;
&#13;
<p>As before, we’ll be creating several independent packages with the following &#13;
<span class="keep-together">structure</span>:</p>&#13;
&#13;
<pre data-type="programlisting">~/cloud-native-go/ch08/hashicorp-plugin&#13;
├── commons&#13;
│   └── commons.go&#13;
├── duck&#13;
│   └── duck.go&#13;
└── main&#13;
    └── main.go</pre>&#13;
&#13;
<p>As before, the <code>duck/duck.go</code> file contains the source code for a plug-in, and the <code>main/main.go</code> file contains our example’s <code>main</code> function that loads and uses the plug-in. Because both of these are independently compiled to produce executable binaries, both files are in the <code>main</code> package.</p>&#13;
&#13;
<p>The <code>commons</code> package is new. It contains some resources that are shared by the plug-in and the consumer, including the service interface and some RPC boilerplate.</p>&#13;
&#13;
<p>As before, the complete source code for this example is available in <a href="https://oreil.ly/9jRyU">this book’s companion GitHub repository</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Common code"><div class="sect3" id="idm45983625727800">&#13;
<h3>Common code</h3>&#13;
&#13;
<p>The <code>commons</code> package contains some resources that are shared by both the plug-in and the consumer, so in our example it’s imported by both the plug-in and client code.</p>&#13;
&#13;
<p>It contains the RPC stubs that are used by the underlying <code>net/rpc</code> machinery to define the service abstraction for the host and allow the plug-ins to construct their service implementations.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The Sayer interface"><div class="sect4" id="idm45983625665976">&#13;
<h4>The Sayer interface</h4>&#13;
&#13;
<p>The first of these is the <code>Sayer</code> interface. This is our service interface, which provides the service contract that the plug-in service implementations must conform to and that the host can expect.</p>&#13;
&#13;
<p>It’s identical to the interface that we used in <a data-type="xref" href="#section_ch08_standard_plugin_sayer">“The Sayer interface”</a>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Sayer</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Says</code><code class="p">()</code> <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>Sayer</code> interface only describes one method: <code>Says</code>. Although this code is shared, as long as this interface doesn’t change, the shared contract will be satisfied and the degree of coupling is kept fairly low.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The SayerPlugin struct"><div class="sect4" id="idm45983625645816">&#13;
<h4>The SayerPlugin struct</h4>&#13;
&#13;
<p>The more complex of the common resources is the <code>SayerPlugin</code> struct, shown in the following. It’s an implementation of <code>plugin.Plugin</code>, the primary plug-in interface from the <code>github.com/hashicorp/go-plugin</code> package.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The package declaration inside the <em>github.com/hashicorp/go-plugin</em> repository is <code>plugin</code>, not <code>go-plugin</code>, as its path might suggest. Adjust your imports accordingly!<a data-type="indexterm" data-primary="HashiCorp" data-startref="ch08_term19" id="idm45983625654184"/></p>&#13;
</div>&#13;
&#13;
<p>The <code>Client</code> and <code>Server</code> methods are used to describe our service according to the expectations of Go’s standard <code>net/rpc</code> package. We won’t cover that package in this book, but if you’re interested, you can find a wealth of information in <a href="https://oreil.ly/uoe8k">the Go <span class="keep-together">documentation</span></a>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">SayerPlugin</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Impl</code> <code class="nx">Sayer</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">SayerPlugin</code><code class="p">)</code> <code class="nx">Client</code><code class="p">(</code><code class="nx">b</code> <code class="o">*</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">MuxBroker</code><code class="p">,</code> <code class="nx">c</code> <code class="o">*</code><code class="nx">rpc</code><code class="p">.</code><code class="nx">Client</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="kd">interface</code><code class="p">{},</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">SayerRPC</code><code class="p">{</code><code class="nx">client</code><code class="p">:</code> <code class="nx">c</code><code class="p">},</code> <code class="kc">nil</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">p</code> <code class="o">*</code><code class="nx">SayerPlugin</code><code class="p">)</code> <code class="nx">Server</code><code class="p">(</code><code class="o">*</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">MuxBroker</code><code class="p">)</code> <code class="p">(</code><code class="kd">interface</code><code class="p">{},</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">SayerRPCServer</code><code class="p">{</code><code class="nx">Impl</code><code class="p">:</code> <code class="nx">p</code><code class="p">.</code><code class="nx">Impl</code><code class="p">},</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Both methods accept a <code>plugin.MuxBroker</code>, which is used to create multiplexed streams on a plug-in connection. While very useful, this is a more advanced use case that we won’t have time to cover in this book.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The SayerRPC client implementation"><div class="sect4" id="idm45983625639672">&#13;
<h4>The SayerRPC client implementation</h4>&#13;
&#13;
<p>SayerPlugin’s <code>Client</code> method provides an implementation of our <code>Sayer</code> interface that communicates over an RPC client—the appropriately named <code>SayerRPC</code> struct—shown in the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">SayerRPC</code> <code class="kd">struct</code><code class="p">{</code> <code class="nx">client</code> <code class="o">*</code><code class="nx">rpc</code><code class="p">.</code><code class="nx">Client</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">g</code> <code class="o">*</code><code class="nx">SayerRPC</code><code class="p">)</code> <code class="nx">Says</code><code class="p">()</code> <code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nx">resp</code> <code class="kt">string</code>&#13;
&#13;
    <code class="nx">err</code> <code class="o">:=</code> <code class="nx">g</code><code class="p">.</code><code class="nx">client</code><code class="p">.</code><code class="nx">Call</code><code class="p">(</code><code class="s">"Plugin.Says"</code><code class="p">,</code> <code class="nb">new</code><code class="p">(</code><code class="kd">interface</code><code class="p">{}),</code> <code class="o">&amp;</code><code class="nx">resp</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">resp</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>SayerRPC</code> uses Go’s RPC framework to remotely call the <code>Says</code> method implemented in the plug-in. It invokes the <code>Call</code> method attached to the <code>*rpc.Client</code>, passing &#13;
<span class="keep-together">in any</span> parameters (<code>Says</code> doesn’t have any parameters, so we pass an empty &#13;
<span class="keep-together"><code>interface{}</code>)</span> and retrieves the response, which it puts it into the <code>resp</code> string.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The handshake configuration"><div class="sect4" id="idm45983625520616">&#13;
<h4>The handshake configuration</h4>&#13;
&#13;
<p><a data-type="indexterm" data-primary="handshake configuration" id="idm45983625437128"/><code>HandshakeConfig</code> is used by both the plug-in and host to do a basic handshake between the host and the plug-in. If the handshake fails—if the plug-in was compiled with a different protocol version, for example—a user-friendly error is shown. This prevents users from executing bad plug-ins or executing a plug-in directly. Importantly, this is a UX feature, not a security feature:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code> <code class="nx">HandshakeConfig</code> <code class="p">=</code> <code class="nx">plugin</code><code class="p">.</code><code class="nx">HandshakeConfig</code><code class="p">{</code>&#13;
    <code class="nx">ProtocolVersion</code><code class="p">:</code>  <code class="mi">1</code><code class="p">,</code>&#13;
    <code class="nx">MagicCookieKey</code><code class="p">:</code>   <code class="s">"BASIC_PLUGIN"</code><code class="p">,</code>&#13;
    <code class="nx">MagicCookieValue</code><code class="p">:</code> <code class="s">"hello"</code><code class="p">,</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="The SayerRPCServer server implementation"><div class="sect4" id="idm45983625369160">&#13;
<h4>The SayerRPCServer server implementation</h4>&#13;
&#13;
<p>SayerPlugin’s <code>Server</code> method provides a definition of an RPC server—the <code>SayerRPCServer</code> struct—to serve the actual methods in a way that’s consistent with <code>net/rpc</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">SayerRPCServer</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Impl</code> <code class="nx">Sayer</code>    <code class="c1">// Impl contains our actual implementation</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">s</code> <code class="o">*</code><code class="nx">SayerRPCServer</code><code class="p">)</code> <code class="nx">Says</code><code class="p">(</code><code class="nx">args</code> <code class="kd">interface</code><code class="p">{},</code> <code class="nx">resp</code> <code class="o">*</code><code class="kt">string</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="o">*</code><code class="nx">resp</code> <code class="p">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">Impl</code><code class="p">.</code><code class="nx">Says</code><code class="p">()</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>SayerRPCServer</code> doesn’t implement the <code>Sayer</code> service. Instead, its <code>Says</code> method calls into a <code>Sayer</code> implementation—<code>Impl</code>—that we’ll provide when we use this to build our plug-in.</p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our plug-in implementation"><div class="sect3" id="idm45983625324456">&#13;
<h3>Our plug-in implementation</h3>&#13;
&#13;
<p>Now that we’ve assembled the code that’s common between the host and plug-ins—the <code>Sayer</code> interface and the RPC stubs—we can build our plug-in code. The code in this section represents the entirety of our <code>main/main.go</code> file.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HashiCorp" id="ch08_term21"/>Just like standard Go plug-ins, HashiCorp plug-ins are compiled into standalone executable binaries, so they must be in the <code>main</code> package. Effectively, every HashiCorp plug-in is a small, self-contained RPC server:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code></pre>&#13;
&#13;
<p>We have to import our <code>commons</code> package, as well as the <code>hashicorp/go-plugin</code> package, whose contents we’ll reference as <code>plugin</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"github.com/cloud-native-go/ch08/hashicorp-plugin/commons"</code>&#13;
    <code class="s">"github.com/hashicorp/go-plugin"</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>In our plug-ins we get to build our real implementations. We can build it however we want,<sup><a data-type="noteref" id="idm45983625313160-marker" href="ch08.xhtml#idm45983625313160">9</a></sup> as long as it conforms to the <code>Sayer</code> interface that we define in the commons package:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Duck</code> <code class="kd">struct</code><code class="p">{}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">g</code> <code class="o">*</code><code class="nx">Duck</code><code class="p">)</code> <code class="nx">Says</code><code class="p">()</code> <code class="kt">string</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="s">"Quack!"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, we get to our <code>main</code> function. It’s somewhat “boilerplate-y” but it’s essential:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Create and initialize our service implementation.</code>&#13;
    <code class="nx">sayer</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">Duck</code><code class="p">{}</code>&#13;
&#13;
    <code class="c1">// pluginMap is the map of plug-ins we can dispense.</code>&#13;
    <code class="kd">var</code> <code class="nx">pluginMap</code> <code class="p">=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">Plugin</code><code class="p">{</code>&#13;
        <code class="s">"sayer"</code><code class="p">:</code> <code class="o">&amp;</code><code class="nx">commons</code><code class="p">.</code><code class="nx">SayerPlugin</code><code class="p">{</code><code class="nx">Impl</code><code class="p">:</code> <code class="nx">sayer</code><code class="p">},</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">plugin</code><code class="p">.</code><code class="nx">Serve</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">ServeConfig</code><code class="p">{</code>&#13;
        <code class="nx">HandshakeConfig</code><code class="p">:</code> <code class="nx">handshakeConfig</code><code class="p">,</code>&#13;
        <code class="nx">Plugins</code><code class="p">:</code>         <code class="nx">pluginMap</code><code class="p">,</code>&#13;
    <code class="p">})</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>main</code> function does three things. First, it creates and initializes our service implementation, a <code>*Duck</code> value, in this case.</p>&#13;
&#13;
<p>Next, it maps the service implementation to the name “sayer” in the <code>pluginMap</code>. If we wanted to, we could actually implement several plug-ins, listing them all here with different names.</p>&#13;
&#13;
<p>Finally, we call <code>plugin.Serve</code>, which starts the RPC server that will handle any connections from the host process, allowing the handshake with the host to proceed and the service’s methods to be executed as the host sees fit.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our host process"><div class="sect3" id="idm45983625323832">&#13;
<h3>Our host process</h3>&#13;
&#13;
<p>We now have our host process; the main command that acts as a client that finds, loads, and executes the plug-in processes.</p>&#13;
&#13;
<p>As you’ll see, using HashiCorp plug-ins isn’t all that different from the steps that described for Go plug-ins in <a data-type="xref" href="#section_ch08_using_our_go_plugins">“Using our go plug-ins”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Import the hashicorp/go-plugin and commons packages"><div class="sect4" id="idm45983625122136">&#13;
<h4>Import the hashicorp/go-plugin and commons packages</h4>&#13;
&#13;
<p>As usual, we start with our package declaration and imports. The imports mostly aren’t interesting, and their necessity should be clear from examination of the code.</p>&#13;
&#13;
<p>The two that <em>are</em> interesting (but not surprising) are <code>github.com/hashicorp/go-plugin</code>, which we, once again, have to reference as <code>plugin</code>, and our <code>commons</code> package, which contains the interface and handshake configuration, both of which must be agreed upon by the host and the plug-ins:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"fmt"</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"os"</code>&#13;
    <code class="s">"os/exec"</code>&#13;
&#13;
    <code class="s">"github.com/cloud-native-go/ch08/hashicorp-plugin/commons"</code>&#13;
    <code class="s">"github.com/hashicorp/go-plugin"</code>&#13;
<code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Find our plug-in"><div class="sect4" id="idm45983625050440">&#13;
<h4>Find our plug-in</h4>&#13;
&#13;
<p>Since our plug-in is an external file, we have to find it. Again, for simplicity, our implementation assumes that our plug-in has the same name as the user’s chosen animal and lives in a path relative to the execution location:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="nb">len</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">)</code> <code class="o">!=</code> <code class="mi">2</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="s">"usage: run main/main.go animal"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Get the animal name, and build the path where we expect to</code>&#13;
    <code class="c1">// find the corresponding executable file.</code>&#13;
    <code class="nx">name</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>&#13;
    <code class="nx">module</code> <code class="o">:=</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"./%s/%s"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Does the file exist?</code>&#13;
    <code class="nx">_</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Stat</code><code class="p">(</code><code class="nx">module</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">os</code><code class="p">.</code><code class="nx">IsNotExist</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="s">"can't find an animal named"</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It bears repeating that the value of this approach is that our plug-in—and its implementation—doesn’t need to be known, or even exist, at compile time. We’re able to implement whatever plug-ins we want at any time, and use then dynamically as we see fit.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Create our plug-in client"><div class="sect4" id="idm45983625096760">&#13;
<h4>Create our plug-in client</h4>&#13;
&#13;
<p>The first way that a HashiCorp RPC plug-in differs from a Go plug-in is the way that it retrieves the implementation. Where Go plug-ins have to be “opened” and their symbol “looked up,” HashiCorp plug-ins are built on RPC, and therefore require an RPC client.</p>&#13;
&#13;
<p>This actually requires two steps, and two clients: a <code>*plugin.Client</code> that manages the lifecycle of the plug-in subprocess, and a protocol client—a <code>plugin.ClientProtocol</code> implementation—that can communicate with the plug-in subprocess.</p>&#13;
&#13;
<p>This awkward API is mostly historical, but is used to split the client that deals with subprocess management and the client that does RPC management:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="c1">// pluginMap is the map of plug-ins we can dispense.</code>&#13;
<code class="kd">var</code> <code class="nx">pluginMap</code> <code class="p">=</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">Plugin</code><code class="p">{</code>&#13;
    <code class="s">"sayer"</code><code class="p">:</code> <code class="o">&amp;</code><code class="nx">commons</code><code class="p">.</code><code class="nx">SayerPlugin</code><code class="p">{},</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Launch the plugin process!</code>&#13;
<code class="nx">client</code> <code class="o">:=</code> <code class="nx">plugin</code><code class="p">.</code><code class="nx">NewClient</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">ClientConfig</code><code class="p">{</code>&#13;
    <code class="nx">HandshakeConfig</code><code class="p">:</code> <code class="nx">commons</code><code class="p">.</code><code class="nx">HandshakeConfig</code><code class="p">,</code>&#13;
    <code class="nx">Plugins</code><code class="p">:</code>         <code class="nx">pluginMap</code><code class="p">,</code>&#13;
    <code class="nx">Cmd</code><code class="p">:</code>             <code class="nx">exec</code><code class="p">.</code><code class="nx">Command</code><code class="p">(</code><code class="nx">module</code><code class="p">),</code>&#13;
<code class="p">})</code>&#13;
<code class="k">defer</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Kill</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Connect to the plugin via RPC</code>&#13;
<code class="nx">rpcClient</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Client</code><code class="p">()</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="HashiCorp" data-startref="ch08_term21" id="idm45983624961560"/>Most of this snippet consists of defining the parameters of the plug-in that we want in the form of a <code>plugin.ClientConfig</code>. The <a href="https://oreil.ly/z29Ys">complete list of available client configurations</a> is lengthy. This example uses only three:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="handshake configuration" id="idm45983624853960"/><code>HandshakeConfig</code></dt>&#13;
<dd>&#13;
<p>The handshake configuration. This has to match the plug-in’s own handshake configuration or we’ll get an error in the next step.</p>&#13;
</dd>&#13;
<dt><code>Plugins</code></dt>&#13;
<dd>&#13;
<p>A map that specifies the name and type of the plug-in we want.</p>&#13;
</dd>&#13;
<dt><code>Cmd</code></dt>&#13;
<dd>&#13;
<p>An <code>*exec.Cmd</code> value that represents the command for starting the plug-in subprocess.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With all of the configuration stuff out of the way, we can first use <code>plugin.NewClient</code> to retrieve a <code>*plugin.Client</code> value, which we call <code>client</code>.</p>&#13;
&#13;
<p>Once we have that, we can use <code>client.Client</code> to request a protocol client. We call this <code>rpcClient</code> because it knows how to use RPC to communicate with the plug-in subprocess.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect4" data-pdf-bookmark="Connect to our plug-in and dispense our Sayer"><div class="sect4" id="idm45983624845464">&#13;
<h4>Connect to our plug-in and dispense our Sayer</h4>&#13;
&#13;
<p>Now that we have our protocol client, we can use it to dispense our <code>Sayer</code> implementation:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go">    <code class="c1">// Request the plug-in from the client</code>&#13;
    <code class="nx">raw</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rpcClient</code><code class="p">.</code><code class="nx">Dispense</code><code class="p">(</code><code class="s">"sayer"</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// We should have a Sayer now! This feels like a normal interface</code>&#13;
    <code class="c1">// implementation, but is actually over an RPC connection.</code>&#13;
    <code class="nx">sayer</code> <code class="o">:=</code> <code class="nx">raw</code><code class="p">.(</code><code class="nx">commons</code><code class="p">.</code><code class="nx">Sayer</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Now we can use our loaded plug-in!</code>&#13;
    <code class="nx">fmt</code><code class="p">.</code><code class="nx">Printf</code><code class="p">(</code><code class="s">"A %s says: %q\n"</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">sayer</code><code class="p">.</code><code class="nx">Says</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using the protocol client’s <code>Dispense</code> function, we’re able to finally retrieve our <code>Sayer</code> implementation as an <code>interface{}</code>, which we can assert as a <code>commons.Sayer</code> value and immediately use exactly like using a local value.</p>&#13;
&#13;
<p>Under the covers, our <code>sayer</code> is in fact a <code>SayerRPC</code> value, and calls to its functions trigger RPC calls that are executed in our plug-in’s address space.</p>&#13;
&#13;
<p>In the next section, we’ll introduce the hexagonal architecture, an architectural pattern built around the entire concept of loose coupling by using easily exchangeable “ports and adapters” to connect to its environment.<a data-type="indexterm" data-primary="loose coupling" data-secondary="plug-ins" data-startref="ch08_term15" id="idm45983624819800"/><a data-type="indexterm" data-primary="plug-ins" data-startref="ch08_term16" id="idm45983624818552"/><a data-type="indexterm" data-primary="Go" data-secondary="plug-ins" data-startref="ch08_term17" id="idm45983624817608"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Hexagonal Architecture"><div class="sect1" id="section_ch08_hexagonal_architecture">&#13;
<h1>Hexagonal Architecture</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="loose coupling" data-secondary="hexagonal architecture and" id="ch08_term23"/><a data-type="indexterm" data-primary="inversion of control" id="idm45983624749288"/><a data-type="indexterm" data-primary="patterns" data-secondary="ports and adapters pattern" data-see="hexagonal architecture" id="idm45983624748616"/><a data-type="indexterm" data-primary="ports and adapters pattern" data-see="hexagonal architecture" id="idm45983624747432"/><a data-type="indexterm" data-primary="hexagonal architecture" id="ch08_term22"/><em>Hexagonal architecture</em>—also known as the “ports and adapters” pattern—is an architectural pattern that uses loose coupling and <em>inversion of control</em> as its central design philosophy to establish clear boundaries between business and peripheral logic.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="ports" id="idm45983624744248"/><a data-type="indexterm" data-primary="adaptors" id="idm45983624743544"/>In a hexagonal application, the core application doesn’t know any details at all about the outside world, operating entirely through loosely coupled <em>ports</em> and technology-specific <em>adapters</em>.</p>&#13;
&#13;
<p>This approach allows the application to, for example, expose different APIs (REST, gRPC, a test harness, etc.) or use different data sources (database, message queues, local files, etc.) without impacting its core logic or requiring major code changes.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It took me an embarrassingly long time to realize that the name “hexagonal architecture” doesn’t actually mean anything. Alistair Cockburn, <a href="https://oreil.ly/sx5io">the author of hexagonal architecture</a>, chose the shape because it gave him enough room to illustrate the design.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="The Architecture"><div class="sect2" id="idm45983624738904">&#13;
<h2>The Architecture</h2>&#13;
&#13;
<p>As illustrated in <a data-type="xref" href="#img_ch08_hexagonal_architecture">Figure 8-3</a>, hexagonal architecture is composed of three components conceptually arranged in and around a central hexagon:</p>&#13;
<dl>&#13;
<dt>The core application</dt>&#13;
<dd>&#13;
<p>The application proper, represented by the hexagon. This contains all of the business logic but has no direct reference to any technology, framework, or real world device. The business logic shouldn’t depend on whether it exposes a REST or a gRPC API, or whether it gets data from a database or a <em>.csv</em> file. Its only view of the world should be through ports.</p>&#13;
</dd>&#13;
<dt>Ports and adapters</dt>&#13;
<dd>&#13;
<p>The ports and adapters are represented on the edge of the hexagon. Ports allow different kinds of actors to “plug in” and interact with the core service. Adapters can “plug into” a port and translate signals between the core application and &#13;
<span class="keep-together">an actor.</span></p>&#13;
&#13;
<p>For example, your application might have a “data port” into which a “data adapter” might plug. One data adapter might write to a database, while another might use an in-memory datastore or automated test harness.</p>&#13;
</dd>&#13;
<dt>Actors</dt>&#13;
<dd>&#13;
<p>The actors can be anything in the environment that interacts with the core application (users, upstream services, etc.) or that the core application interacts with (storage devices, downstream services, etc.). They exist outside the hexagon.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div id="img_ch08_hexagonal_architecture" class="figure">&#13;
<img src="Images/cngo_0803.png" alt="cngo 0803" width="1070" height="448"/>&#13;
<h6><span class="label">Figure 8-3. </span>All dependencies in the hexagonal architecture point inward; the hexagons represent the core application’s domain and API layers, and the ports and adapters are represented as arrows on the edge of the hexagon, each of which interfaces with a &#13;
<span class="keep-together">particular</span> actor</h6>&#13;
</div></figure>&#13;
&#13;
<p>In a traditional layered architecture, all of the dependencies point in the same direction, with each layer depending on the one below it.</p>&#13;
&#13;
<p>In a hexagonal architecture, however, all dependencies point inward: the core business logic doesn’t know any details about the outer world, the adapters know how to ferry information to and from the core, and the adapters in the outer world know how to interact with the actors.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Implementing a Hexagonal Service"><div class="sect2" id="idm45983624725000">&#13;
<h2>Implementing a Hexagonal Service</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="key-value store" id="idm45983624723560"/>To illustrate this, we’re going to refactor our old friend the key-value store.</p>&#13;
&#13;
<p>If you’ll recall from <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a>, the core application of our key-value store reads and writes to a in-memory map, which can be accessed via a RESTful (or gRPC) frontend. Later in the same chapter, we implemented a transaction logger, which knows how to write all transactions to <em>somewhere</em> and read them all back when the system restarts.</p>&#13;
&#13;
<p>We’ll reproduce important snippets of the service here, but if you want a refresher on what we did, go back and do so now.</p>&#13;
&#13;
<p>By this point in the book, we’ve accumulated a couple of different implementations for a couple of different components of our service that seem like good candidates for ports and adapters in a hexagonal architecture:</p>&#13;
<dl>&#13;
<dt>The frontend</dt>&#13;
<dd>&#13;
<p>Back in <a data-type="xref" href="ch05.xhtml#section_ch05_generation_1">“Generation 1: The Monolith”</a> we implemented a REST frontend, and then in <a data-type="xref" href="#section_ch08_gRPC">“Remote Procedure Calls with gRPC”</a> we implemented a separate gRPC frontend. We can describe these with a single “driver” port into which we’ll be able to plug either (or both!) as adapters.</p>&#13;
</dd>&#13;
<dt>The transaction logger</dt>&#13;
<dd>&#13;
<p>In <a data-type="xref" href="ch05.xhtml#section_ch05_whats_a_transaction_log">“What’s a Transaction Log?”</a> we created two implementations of a transaction log. These seem like a natural choice for a “driven” port and &#13;
<span class="keep-together">adapters</span>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While all the logic for all of these already exists, we’ll need to do some refactoring to make this architecture “hexagonal”:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Our original core application—originally described in <a data-type="xref" href="ch05.xhtml#section_ch05_generation_0">“Generation 0: The Core Functionality”</a>—uses exclusively public functions. We’ll refactor those into struct methods to make it easier to use in a “ports and adapters” &#13;
<span class="keep-together">format</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both the RESTful and gRPC frontends are already consistent with hexagonal architecture, since the core application doesn’t know or care about them, but they’re constructed in a <code>main</code> function. We’ll convert these into <code>FrontEnd</code> adapters into which we can pass our core application. This pattern is typical of a “driver” port.</p>&#13;
</li>&#13;
<li>&#13;
<p>The transaction loggers themselves won’t need much refactoring, but they’re currently embedded in the frontend logic. When we refactor the core application, we’ll add a transaction logger port so that the adapter can be passed into the core logic. This pattern is typical of a “driven” port.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In the next section, we’ll begin taking the existing components and refactoring them in accordance with hexagonal principles.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our refactored components"><div class="sect3" id="idm45983624679112">&#13;
<h3>Our refactored components</h3>&#13;
&#13;
<p>For the sake of this example, all of our components live under the <code>github.com/cloud-native-go/examples/ch08/hexarch</code> package:</p>&#13;
&#13;
<pre data-type="programlisting">~/cloud-native-go/ch08/hexarch/&#13;
├── core&#13;
│   └── core.go&#13;
├── frontend&#13;
│   ├── grpc.go&#13;
│   └── rest.go&#13;
├── main.go&#13;
└── transact&#13;
    ├── filelogger.go&#13;
    └── pglogger.go</pre>&#13;
<dl>&#13;
<dt><code>core</code></dt>&#13;
<dd>&#13;
<p>The core key-value application logic. Importantly, it has no dependencies outside of the Go standard libraries.</p>&#13;
</dd>&#13;
<dt><code>frontend</code></dt>&#13;
<dd>&#13;
<p>Contains the REST and gRPC frontend driver adapters. These have a dependency on <code>core</code>.</p>&#13;
</dd>&#13;
<dt><code>transact</code></dt>&#13;
<dd>&#13;
<p>Contains the file and PostgreSQL transaction logger driven adapters. These also have a dependency on <code>core</code>.</p>&#13;
</dd>&#13;
<dt><code>main.go</code></dt>&#13;
<dd>&#13;
<p>Makes the core application instance, into which it passes the driven components, and which it passes to the driver adapters.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The complete source code is also available in <a href="https://oreil.ly/SsujV">the companion GitHub repository</a>.</p>&#13;
&#13;
<p>Now that we have our very high-level structure, let’s go ahead and implement our first plug.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our first plug"><div class="sect3" id="idm45983624666776">&#13;
<h3>Our first plug</h3>&#13;
&#13;
<p><a data-type="indexterm" data-primary="transaction log" id="idm45983624665400"/>You may remember that we also implemented a <em>transaction log</em> to maintain a record of every time a resource is modified so that if our service crashes, is restarted, or otherwise finds itself in an inconsistent state, it can reconstruct its complete state by replaying the transactions.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.xhtml#section_ch05_eventlogger_interface">“Your transaction logger interface”</a>, we represented a generic transaction logger with the <code>TransactionLogger</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">TransactionLogger</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">WriteDelete</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code>&#13;
    <code class="nx">WritePut</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code> <code class="kt">string</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For brevity, we only define the <code>WriteDelete</code> and <code>WritePut</code> methods.</p>&#13;
&#13;
<p>A common aspect of “driven” adapters is that the core logic acts <em>on them</em>, so the core application has to know about the port. As such, this code lives in the <code>core</code> package.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our core application"><div class="sect3" id="idm45983624639416">&#13;
<h3>Our core application</h3>&#13;
&#13;
<p>In our original implementation in <a data-type="xref" href="ch05.xhtml#section_ch05_our_api">“Your Super Simple API”</a>, the transaction logger was used by the frontend. In a hexagonal architecture we move the port—in the form of the <code>TransactionLogger</code> interface—into the core application:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">core</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"errors"</code>&#13;
    <code class="s">"log"</code>&#13;
    <code class="s">"sync"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">KeyValueStore</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">m</code>        <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code>&#13;
    <code class="nx">transact</code> <code class="nx">TransactionLogger</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">NewKeyValueStore</code><code class="p">(</code><code class="nx">tl</code> <code class="nx">TransactionLogger</code><code class="p">)</code> <code class="o">*</code><code class="nx">KeyValueStore</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">KeyValueStore</code><code class="p">{</code>&#13;
        <code class="nx">m</code><code class="p">:</code>        <code class="nb">make</code><code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="p">),</code>&#13;
        <code class="nx">transact</code><code class="p">:</code> <code class="nx">tl</code><code class="p">,</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">store</code> <code class="o">*</code><code class="nx">KeyValueStore</code><code class="p">)</code> <code class="nx">Delete</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nb">delete</code><code class="p">(</code><code class="nx">store</code><code class="p">.</code><code class="nx">m</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
    <code class="nx">store</code><code class="p">.</code><code class="nx">transact</code><code class="p">.</code><code class="nx">WriteDelete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">store</code> <code class="o">*</code><code class="nx">KeyValueStore</code><code class="p">)</code> <code class="nx">Put</code><code class="p">(</code><code class="nx">key</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code> <code class="kt">string</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nx">store</code><code class="p">.</code><code class="nx">m</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="p">=</code> <code class="nx">value</code>&#13;
    <code class="nx">store</code><code class="p">.</code><code class="nx">transact</code><code class="p">.</code><code class="nx">WritePut</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Comparing the previous code with the original form in <a data-type="xref" href="ch05.xhtml#section_ch05_generation_0">“Generation 0: The Core Functionality”</a>, you’ll see some significant changes.</p>&#13;
&#13;
<p>First, <code>Put</code> and <code>Delete</code> aren’t pure functions anymore: they’re now methods on a new <code>KeyValueStore</code> struct, which also has the map data structure. We’ve also added a <code>NewKeyValueStore</code> function that initializes and returns a new <code>KeyValueStore</code> pointer value.</p>&#13;
&#13;
<p>Finally, <code>KeyValueStore</code> now has a <code>TransactionLogger</code>, which <code>Put</code> and <code>Delete</code> act upon appropriately. This is our port.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our TransactionLogger adapters"><div class="sect3" id="idm45983624490984">&#13;
<h3>Our TransactionLogger adapters</h3>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a> we created two <code>TransactionLogger</code> implementations:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In <a data-type="xref" href="ch05.xhtml#section_ch05_implementing_filetransactionlogger">“Implementing your FileTransactionLogger”</a>, we describe a file-based implementation.</p>&#13;
</li>&#13;
<li>&#13;
<p>In <a data-type="xref" href="ch05.xhtml#section_ch05_implementing_postgrestransactionlogger">“Implementing your PostgresTransactionLogger”</a>, we describe a PostgreSQL-backed implementation.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Both of these have been moved to the <code>transact</code> package. They hardly have to change at all, except to account for the fact that the <code>TransactionLogger</code> interface and <code>Event</code> struct now live in the <code>core</code> package.</p>&#13;
&#13;
<p>But how do we determine which one to load? Well, Go doesn’t have annotations or any fancy dependency injection features,<sup><a data-type="noteref" id="idm45983624481432-marker" href="ch08.xhtml#idm45983624481432">10</a></sup> but there are still a couple of ways you can do this.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="plug-ins" id="idm45983624480392"/>The first option is to use plug-ins of some kind (this is actually a primary use case for Go plug-ins). This might make sense if you want changing adapters to require <em>zero</em> code changes.</p>&#13;
&#13;
<p>More commonly, you’ll see some kind of “factory” function<sup><a data-type="noteref" id="idm45983624478280-marker" href="ch08.xhtml#idm45983624478280">11</a></sup> that’s used by the initializing function. While this still requires code changes to add adapters, they’re isolated to a single, easily modified location. A more sophisticated approach might accept a parameter or configuration value to choose which adapter to use.</p>&#13;
&#13;
<p>An example of a <code>TransactionLogger</code> factory function might look like the following:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code> <code class="nx">NewTransactionLogger</code><code class="p">(</code><code class="nx">logger</code> <code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="nx">core</code><code class="p">.</code><code class="nx">TransactionLogger</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">switch</code> <code class="nx">logger</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s">"file"</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="nx">NewFileTransactionLogger</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_FILENAME"</code><code class="p">))</code>&#13;
&#13;
    <code class="k">case</code> <code class="s">"postgres"</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="nx">NewPostgresTransactionLogger</code><code class="p">(</code>&#13;
            <code class="nx">PostgresDbParams</code><code class="p">{</code>&#13;
                <code class="nx">dbName</code><code class="p">:</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_DB_HOST"</code><code class="p">),</code>&#13;
                <code class="nx">host</code><code class="p">:</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_DB_DATABASE"</code><code class="p">),</code>&#13;
                <code class="nx">user</code><code class="p">:</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_DB_USERNAME"</code><code class="p">),</code>&#13;
                <code class="nx">password</code><code class="p">:</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_DB_PASSWORD"</code><code class="p">),</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">)</code>&#13;
&#13;
    <code class="k">case</code> <code class="s">""</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"transaction logger type not defined"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">default</code><code class="p">:</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"no such transaction logger %s"</code><code class="p">,</code> <code class="nx">s</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the <code>NewTransactionLogger</code> function accepts a string that specifies the desired implementation, returning either one of our implementations or an <code>error</code>. We use the <code>os.Getenv</code> function to retrieve the appropriate parameters from environment variables.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Our FrontEnd port"><div class="sect3" id="idm45983624490360">&#13;
<h3>Our FrontEnd port</h3>&#13;
&#13;
<p>But what about our frontends? If you will recall, we now have two frontend &#13;
<span class="keep-together">implementations</span>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In <a data-type="xref" href="ch05.xhtml#section_ch05_generation_1">“Generation 1: The Monolith”</a> in <a data-type="xref" href="ch05.xhtml#chapter_5">Chapter 5</a>, we built a RESTful interface using <code>net/http</code> and <code>gorilla/mux</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>In <a data-type="xref" href="#section_ch08_gRPC">“Remote Procedure Calls with gRPC”</a>, earlier in this chapter, we built an RPC interface with gRPC.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Both of these implementations include a <code>main</code> function where we configure and start the service to listen for connections.</p>&#13;
&#13;
<p>Since they’re “driver” ports, we need to pass the core application to them, so let’s refactor both frontends into structs according to the following interface:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">frontend</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">FrontEnd</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Start</code><code class="p">(</code><code class="nx">kv</code> <code class="o">*</code><code class="nx">core</code><code class="p">.</code><code class="nx">KeyValueStore</code><code class="p">)</code> <code class="kt">error</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>FrontEnd</code> interface serves as our “frontend port,” which all frontend implementations are expected to satisfy. The <code>Start</code> method accepts the core application API in the form of a <code>*core.KeyValueStore</code>, and will also include the setup logic that formerly lived in a <code>main</code> function.</p>&#13;
&#13;
<p>Now that we have this, we can refactor both frontends so that they comply with the <code>FrontEnd</code> interface, starting with the RESTful frontend. As usual, the complete source code for this and the gRPC service refactor are available in <a href="https://oreil.ly/9jRyU">this book’s companion GitHub repository</a>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go" class="pagebreak-before less_space"><code class="kn">package</code> <code class="nx">frontend</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"net/http"</code>&#13;
&#13;
    <code class="s">"github.com/cloud-native-go/examples/ch08/hexarch/core"</code>&#13;
    <code class="s">"github.com/gorilla/mux"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// restFrontEnd contains a reference to the core application logic,</code>&#13;
<code class="c1">// and complies with the contract defined by the FrontEnd interface.</code>&#13;
<code class="kd">type</code> <code class="nx">restFrontEnd</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">store</code> <code class="o">*</code><code class="nx">core</code><code class="p">.</code><code class="nx">KeyValueStore</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// keyValueDeleteHandler handles the logic for the DELETE HTTP method.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">f</code> <code class="o">*</code><code class="nx">restFrontEnd</code><code class="p">)</code> <code class="nx">keyValueDeleteHandler</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code>&#13;
        <code class="nx">r</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="nx">vars</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">Vars</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>&#13;
    <code class="nx">key</code> <code class="o">:=</code> <code class="nx">vars</code><code class="p">[</code><code class="s">"key"</code><code class="p">]</code>&#13;
&#13;
    <code class="nx">err</code> <code class="o">:=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">store</code><code class="p">.</code><code class="nx">Delete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">http</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">(),</code> <code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// ...other handler functions omitted for brevity.</code>&#13;
&#13;
<code class="c1">// Start includes the setup and start logic that previously</code>&#13;
<code class="c1">// lived in a main function.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">f</code> <code class="o">*</code><code class="nx">restFrontEnd</code><code class="p">)</code> <code class="nx">Start</code><code class="p">(</code><code class="nx">store</code> <code class="o">*</code><code class="nx">core</code><code class="p">.</code><code class="nx">KeyValueStore</code><code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="c1">// Remember our core application reference.</code>&#13;
    <code class="nx">f</code><code class="p">.</code><code class="nx">store</code> <code class="p">=</code> <code class="nx">store</code>&#13;
&#13;
    <code class="nx">r</code> <code class="o">:=</code> <code class="nx">mux</code><code class="p">.</code><code class="nx">NewRouter</code><code class="p">()</code>&#13;
&#13;
    <code class="nx">r</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/v1/{key}"</code><code class="p">,</code> <code class="nx">f</code><code class="p">.</code><code class="nx">keyValueGetHandler</code><code class="p">).</code><code class="nx">Methods</code><code class="p">(</code><code class="s">"GET"</code><code class="p">)</code>&#13;
    <code class="nx">r</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/v1/{key}"</code><code class="p">,</code> <code class="nx">f</code><code class="p">.</code><code class="nx">keyValuePutHandler</code><code class="p">).</code><code class="nx">Methods</code><code class="p">(</code><code class="s">"PUT"</code><code class="p">)</code>&#13;
    <code class="nx">r</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/v1/{key}"</code><code class="p">,</code> <code class="nx">f</code><code class="p">.</code><code class="nx">keyValueDeleteHandler</code><code class="p">).</code><code class="nx">Methods</code><code class="p">(</code><code class="s">"DELETE"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":8080"</code><code class="p">,</code> <code class="nx">r</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Comparing the previous code to the code we produced in <a data-type="xref" href="ch05.xhtml#section_ch05_generation_1">“Generation 1: The Monolith”</a>, some differences stand out:</p>&#13;
&#13;
<ul class="pagebreak-before less_space">&#13;
<li>&#13;
<p>All functions are now methods attached to a <code>restFrontEnd</code> struct.</p>&#13;
</li>&#13;
<li>&#13;
<p>All calls to the core application go through the <code>store</code> value that lives in the <code>restFrontEnd</code> struct.</p>&#13;
</li>&#13;
<li>&#13;
<p>Creating the router, defining the handlers, and starting the server now live in the <code>Start</code> method.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Similar changes will have been made for our gRPC frontend implementation to make it consistent with the <code>FrontEnd</code> port.</p>&#13;
&#13;
<p>This new arrangement makes it easier for a consumer to choose and plug in a “frontend adapter,” as demonstrated in the following.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect3" data-pdf-bookmark="Putting it all together"><div class="sect3" id="idm45983624327128">&#13;
<h3>Putting it all together</h3>&#13;
&#13;
<p>Here, we have our <code>main</code> function, in which we plug all of the components into our application:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"log"</code>&#13;
&#13;
    <code class="s">"github.com/cloud-native-go/examples/ch08/hexarch/core"</code>&#13;
    <code class="s">"github.com/cloud-native-go/examples/ch08/hexarch/frontend"</code>&#13;
    <code class="s">"github.com/cloud-native-go/examples/ch08/hexarch/transact"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// Create our TransactionLogger. This is an adapter that will plug</code>&#13;
    <code class="c1">// into the core application's TransactionLogger port.</code>&#13;
    <code class="nx">tl</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">transact</code><code class="p">.</code><code class="nx">NewTransactionLogger</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"TLOG_TYPE"</code><code class="p">))</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Create Core and tell it which TransactionLogger to use.</code>&#13;
    <code class="c1">// This is an example of a "driven agent"</code>&#13;
    <code class="nx">store</code> <code class="o">:=</code> <code class="nx">core</code><code class="p">.</code><code class="nx">NewKeyValueStore</code><code class="p">(</code><code class="nx">tl</code><code class="p">)</code>&#13;
    <code class="nx">store</code><code class="p">.</code><code class="nx">Restore</code><code class="p">()</code>&#13;
&#13;
    <code class="c1">// Create the frontend.</code>&#13;
    <code class="c1">// This is an example of a "driving agent."</code>&#13;
    <code class="nx">fe</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">frontend</code><code class="p">.</code><code class="nx">NewFrontEnd</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"FRONTEND_TYPE"</code><code class="p">))</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">fe</code><code class="p">.</code><code class="nx">Start</code><code class="p">(</code><code class="nx">store</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, we then create a transaction logger according to the environment <code>TLOG_TYPE</code>. We do this first because the “transaction logger port” is “driven,” so we’ll need to provide it to the application to plug it in.</p>&#13;
&#13;
<p>We then create our <code>KeyValueStore</code> value, which represents our core application functions and provides an API for ports to interact with, and provide it with any driven adapters.</p>&#13;
&#13;
<p>Next, we create any “driver” adapters. Since these act on the core application API, we provide the API to the adapter instead of the other way around as we would with a “driven” adapter. This means we could also create multiple frontends here, if we wanted, by creating a new adapter and passing it the <code>KeyValueStore</code> that exposes the core application API.</p>&#13;
&#13;
<p>Finally, we call <code>Start</code> on our frontend, which instructs it to start listening for connections. At last, we have a complete hexagonal service!<a data-type="indexterm" data-primary="hexagonal architecture" data-startref="ch08_term22" id="idm45983623952424"/><a data-type="indexterm" data-primary="loose coupling" data-secondary="hexagonal architecture and" data-startref="ch08_term23" id="idm45983623951784"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983624724376">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We covered a lot of ground in this chapter, but really only scratched the surface of all the different ways that components can find themselves tightly coupled and all the different ways of managing each of those tightly coupled components.</p>&#13;
&#13;
<p>In the first half of the chapter, we focused on the coupling that can result from how services communicate. We talked about the problems caused by fragile exchange protocols like SOAP, and demonstrated REST and gRPC, which are less fragile because they can be changed to some degree without necessarily forcing client upgrades. We also touched on coupling “in time,” in which one service implicitly expects a timely response from another, and how publish-subscribe messaging might be used to relieve this.</p>&#13;
&#13;
<p>In the second half we addressed some of the ways that systems can minimize coupling to local resources. After all, even distributed services are just programs, subject to the same limitations of the architectures and implementations as any program. Plug-ins implementations and hexagonal architectures are two ways of doing this by enforcing separation of concerns and inversion of control.</p>&#13;
&#13;
<p>Unfortunately, we didn’t get to drill down into some other fascinating topics like service discovery, but, sadly, I had to draw a line somewhere before this subject got away from me!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983628500424"><sup><a href="ch08.xhtml#idm45983628500424-marker">1</a></sup> Ullman, Ellen. “The Dumbing-down of Programming.” <em>Salon</em>, 12 May 1998. <a href="https://oreil.ly/Eib3K"><em class="hyperlink">https://oreil.ly/Eib3K</em></a>.</p><p data-type="footnote" id="idm45983628463640"><sup><a href="ch08.xhtml#idm45983628463640-marker">2</a></sup> Get off my lawn.</p><p data-type="footnote" id="idm45983628462344"><sup><a href="ch08.xhtml#idm45983628462344-marker">3</a></sup> In XML, no less. We didn’t know any better at the time.</p><p data-type="footnote" id="idm45983628457112"><sup><a href="ch08.xhtml#idm45983628457112-marker">4</a></sup> At Google, even the acronyms are recursive.</p><p data-type="footnote" id="idm45983628447000"><sup><a href="ch08.xhtml#idm45983628447000-marker">5</a></sup> This is actually a pretty nuanced discussion. See <a data-type="xref" href="ch07.xhtml#section_ch07_service_architectures">“Service Architectures”</a>.</p><p data-type="footnote" id="idm45983627711544"><sup><a href="ch08.xhtml#idm45983627711544-marker">6</a></sup> If you’re into that kind of thing.</p><p data-type="footnote" id="idm45983626853480"><sup><a href="ch08.xhtml#idm45983626853480-marker">7</a></sup> If you wanted to be creative, this could be a <a href="https://oreil.ly/mViL3"><code>FileListener</code></a>, or even a <code>stdio</code> stream.</p><p data-type="footnote" id="idm45983626256968"><sup><a href="ch08.xhtml#idm45983626256968-marker">8</a></sup> Yes, I know the animal thing has been done before. Sue me.</p><p data-type="footnote" id="idm45983625313160"><sup><a href="ch08.xhtml#idm45983625313160-marker">9</a></sup> So, naturally, we’re building a duck. Obviously.</p><p data-type="footnote" id="idm45983624481432"><sup><a href="ch08.xhtml#idm45983624481432-marker">10</a></sup> Good riddance.</p><p data-type="footnote" id="idm45983624478280"><sup><a href="ch08.xhtml#idm45983624478280-marker">11</a></sup> I’m sorry.</p></div></div></section></div></body></html>