<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. The Context"><div class="chapter" id="unique_chapter_id_14">
<h1><span class="label">Chapter 14. </span>The Context</h1>


<p>Servers need a way to handle metadata<a data-type="indexterm" data-primary="context package" data-secondary="about metadata problem" id="id2734"/><a data-type="indexterm" data-primary="net/http package" data-secondary="context" data-tertiary="about metadata problem" id="id2735"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="about the problem" id="id2736"/> on individual requests. This metadata falls into two general categories: metadata that is required to correctly process the request, and metadata on when to stop processing the request. For example, an HTTP server might want to use a tracking ID to identify a chain of requests through a set of microservices. It also might want to set a timer that ends requests to other microservices if they take too long.</p>

<p>Many languages use <em>threadlocal</em> variables to store this kind of information, associating data to a specific operating system thread of execution. This doesn’t work in Go because goroutines don’t have unique identities that can be used to look up values. More importantly, threadlocals feel like magic; values go in one place and pop up somewhere else.</p>

<p>Go solves the request metadata problem with a construct called the <em>context</em>. Let’s see how to use it correctly.</p>






<section data-type="sect1" data-pdf-bookmark="What Is the Context?"><div class="sect1" id="id183">
<h1>What Is the Context?</h1>

<p>Rather than add a new feature to the language, <a data-type="indexterm" data-primary="standard library" data-secondary="context package" data-seealso="context package" id="id2737"/><a data-type="indexterm" data-primary="context package" data-secondary="description of context" id="ch14-what"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" data-secondary="context" data-tertiary="description" id="ch14-what2"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="description" id="ch14-what3"/>a context is simply an instance that meets the <code>Context</code> interface defined in the <code>context</code> package. As you know, idiomatic Go encourages explicit data passing via function parameters. The same is true for the context. It is just another parameter to your function.</p>

<p>Just as Go has a convention that the last return value from a function is an <code>error</code>, <a data-type="indexterm" data-primary="context package" data-secondary="description of context" data-tertiary="first parameter passed" id="id2738"/><a data-type="indexterm" data-primary="parameters" data-secondary="context as first" id="id2739"/>Go has another convention that the context is explicitly passed through your program as the first parameter of a function. The usual name for the context parameter is <code>ctx</code>:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">func</code><code class="w"> </code><code class="nx">logic</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">info</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="c1">// do some interesting stuff here</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In addition to defining the <code>Context</code> interface, the <code>context</code> package contains several factory functions for creating and wrapping contexts. <a data-type="indexterm" data-primary="context package" data-secondary="context.Background" id="id2740"/><a data-type="indexterm" data-primary="types" data-secondary="context.Context" id="id2741"/>When you don’t have an existing context, such as at the entry point to a command-line program, create an empty initial context with the function <code>context.Background</code>. This returns a variable of type <code>context.Context</code>. (Yes, this is an exception to the usual pattern of returning a concrete type from a function call.)</p>

<p>An empty context is a starting point; each time you add metadata to the context, you do so by <em>wrapping</em> the existing context by using one of the factory functions in the 
<span class="keep-together"><code>context</code></span> package.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Another function, <code>context.TODO</code>, also<a data-type="indexterm" data-primary="context package" data-secondary="context.TODO" id="id2742"/> creates an empty <code>context.Context</code>. It is intended for temporary use during development. If you aren’t sure where the context is going to come from or how it’s going to be used, use <code>context.TODO</code> to put a placeholder in your code. Production code shouldn’t include 
<span class="keep-together"><code>context.TODO</code>.</span></p>
</div>

<p>When writing an HTTP server, you use a slightly different pattern for acquiring and passing the context through layers of middleware to the top-level <code>http.Handler</code>. Unfortunately, context was added to the Go APIs long after the <code>net/http</code> package was created. Because of the compatibility promise, there was no way to change the <code>http.Handler</code> interface to add a <code>context.Context</code> parameter.</p>

<p>The compatibility promise does allow new methods to be added to existing types, 
<span class="keep-together">and that’s</span> what the Go team did. Two context-related methods are on <code>http.Request</code>:<a data-type="indexterm" data-primary="net/http package" data-secondary="http.Request context-related methods" id="id2743"/></p>

<ul>
<li>
<p><code>Context</code> returns the <code>context.Context</code> associated with the request.</p>
</li>
<li>
<p><code>WithContext</code> takes in a <code>context.Context</code> and returns a new <code>http.Request</code> with the old request’s state combined with the supplied <code>context.Context</code>.</p>
</li>
</ul>

<p>Here’s the general pattern:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Middleware</code><code class="p">(</code><code class="nx">handler</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="c1">// wrap the context with stuff -- you'll see how soon!</code><code class="w"/>
<code class="w">        </code><code class="nx">req</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">WithContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">handler</code><code class="p">.</code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">rw</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The first thing you do in your middleware is extract the existing context from the request by using the <code>Context</code> method. (If you want to skip ahead, you can see how to put values into the context in <a data-type="xref" href="#context_values">“Values”</a>.) After you put values into the context, you create a new request based on the old request and the now-populated context by using the 
<span class="keep-together"><code>WithContext</code></span> method. Finally, you call the <code>handler</code> and pass it your new request and the existing <code>http.ResponseWriter</code>.</p>

<p>When you implement the handler, extract the context from the request by using the 
<span class="keep-together"><code>Context</code></span> method and call your business logic with the context as the first parameter, just as you saw previously:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">handler</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">ParseForm</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">FormValue</code><code class="p">(</code><code class="s">"data"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">logic</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">result</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When making an HTTP call from your application to another HTTP service, use the <code>NewRequestWithContext</code> function in the <code>net/http</code> package to construct a request that includes existing context information:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">ServiceCaller</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">client</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Client</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">sc</code><code class="w"> </code><code class="nx">ServiceCaller</code><code class="p">)</code><code class="w"> </code><code class="nx">callAnotherService</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="w">                                          </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">req</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewRequestWithContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">MethodGet</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"http://example.com?data="</code><code class="o">+</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">sc</code><code class="p">.</code><code class="nx">client</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">StatusCode</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusOK</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"Unexpected status code %d"</code><code class="p">,</code><code class="w"/>
<code class="w">                              </code><code class="nx">resp</code><code class="p">.</code><code class="nx">StatusCode</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// do the rest of the stuff to process the response</code><code class="w"/>
<code class="w">    </code><code class="nx">id</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">processResponse</code><code class="p">(</code><code class="nx">resp</code><code class="p">.</code><code class="nx">Body</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">id</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find these code samples in the <em>sample_code/context_patterns</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2744"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2745"/></p>

<p>Now that you know how to acquire and pass a context, let’s start making them useful. You’ll begin with passing values.<a data-type="indexterm" data-startref="ch14-what" id="id2746"/><a data-type="indexterm" data-startref="ch14-what2" id="id2747"/><a data-type="indexterm" data-startref="ch14-what3" id="id2748"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Values"><div class="sect1" id="context_values">
<h1>Values</h1>

<p>By default, you should prefer to pass data<a data-type="indexterm" data-primary="context package" data-secondary="values" id="ch14-val"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" data-secondary="context" data-tertiary="values" id="ch14-val2"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="values" id="ch14-val3"/> through explicit parameters. As has been mentioned before, idiomatic Go favors the explicit over the implicit, and this includes explicit data passing. If a function depends on some data, it should be clear what data it needs and where that data came from.</p>

<p>However, in some cases you cannot pass data explicitly. The most common situation is an HTTP request handler and its associated middleware. As you have seen, all HTTP request handlers have two parameters, one for the request and one for the response. If you want to make a value available to your handler in middleware, you need to store it in the context. Possible situations include extracting a user from a JWT (JSON Web Token) or creating a per-request GUID that is passed through multiple layers of middleware and into your handler and business logic.</p>

<p>There is a factory method for putting values into the<a data-type="indexterm" data-primary="context package" data-secondary="context.WithValue" id="id2749"/> context, 
<span class="keep-together"><code>context.WithValue</code>.</span> It takes in three values: a context, a key to look up the value, and the value itself. The key and the value parameters are declared to be of type <code>any</code>. The <code>context.WithValue</code> function returns a context, but it is not the same context that was passed into the function. Instead, it is a <em>child</em> context that contains the key-value pair and <em>wraps</em> the passed-in <em>parent</em> <code>context.Context</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You’ll see this wrapping pattern several times. A context is treated as an immutable instance. Whenever you add information to a context, you do so by wrapping an existing parent context with a child context. This allows you to use contexts to pass information into deeper layers of the code. The context is never used to pass information out of deeper layers to higher layers.</p>
</div>

<p>The <code>Value</code> method on <code>context.Context</code> checks<a data-type="indexterm" data-primary="context package" data-secondary="Value method" id="id2750"/><a data-type="indexterm" data-primary="context package" data-secondary="Value method" data-tertiary="key" id="id2751"/> whether a value is in a context or any of its parent contexts. This method takes in a key and returns the value associated with the key. Again, both the key parameter and the value result are declared to be of type <code>any</code>. If no value is found for the supplied key, <code>nil</code> is returned. Use the comma ok idiom to type-assert the returned value to the correct type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">myVal</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Value</code><code class="p">(</code><code class="nx">myKey</code><code class="p">).(</code><code class="kt">int</code><code class="p">);</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"no value"</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"value:"</code><code class="p">,</code><code class="w"> </code><code class="nx">myVal</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you are familiar with data structures, you might recognize that searching for values stored in the context chain is a <em>linear</em> search. This has no serious performance implications when there are only a few values, but it would perform poorly if you stored dozens of values in the context during a request. That said, if your program is creating a context chain with dozens of values, your program probably needs some refactoring.</p>
</div>

<p>The value stored in the context can be of any type, but picking the correct key is important. Like the key for a <code>map</code>, the key for a context value must be comparable. Don’t just use a <code>string</code> like <code>"id"</code>. If you use <code>string</code> or another predefined or exported type for the type of the key, different packages could create identical keys, resulting in collisions. This causes problems that are hard to debug, such as one package writing data to the context that masks the data written by another package, or reading data from the context that was written by another package.</p>

<p>Two patterns are used to guarantee that a key is unique and comparable. The first creates a new, unexported type for the key, based on an <code>int</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">userKey</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>

<p>After declaring your unexported key type, you then declare an unexported constant of that type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">_</code><code class="w"> </code><code class="nx">userKey</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">iota</code><code class="w"/>
<code class="w">    </code><code class="nx">key</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>With both the type and the typed constant of the key being unexported, no code from outside your package can put data into the context that would cause a collision. If your package needs to put multiple values into the context, define a different key of the same type for each value, using the <code>iota</code> pattern you looked at in <a data-type="xref" href="ch07.html#iota_section">“iota Is for Enumerations—Sometimes”</a>. Since you care about the constant’s value only as a way to differentiate multiple keys, this is a perfect use for <code>iota</code>.</p>

<p>Next, build an API to place a value into the context and to read the value from the context. Make these functions public only if code outside your package should be able to read and write your context values. The name of the function that creates a context with the value should start with <code>ContextWith</code>. The function that returns the value from the context should have a name that ends with <code>FromContext</code>. Here are the implementations of functions to set and read the user from the context:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">ContextWithUser</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">user</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithValue</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">key</code><code class="p">,</code><code class="w"> </code><code class="nx">user</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">UserFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Value</code><code class="p">(</code><code class="nx">key</code><code class="p">).(</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Another option is to define the unexported key type by using an empty struct:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">userKey</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}</code><code class="w"/></pre>

<p>The functions for managing access to the context value are then changed:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">ContextWithUser</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">user</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithValue</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">userKey</code><code class="p">{},</code><code class="w"> </code><code class="nx">user</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">UserFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Value</code><code class="p">(</code><code class="nx">userKey</code><code class="p">{}).(</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>How do you know which key style to use? If you have a set of related keys for storing different values in the context, use the <code>int</code> and <code>iota</code> technique. If you have only a single key, either is fine. The important thing is that you want to make it impossible for context keys to collide.</p>

<p>Now that you’ve written your user-management code, let’s see how to use it. You’re going to write middleware that extracts a user ID from a cookie:</p>

<pre data-type="programlisting" data-code-language="go"><code class="c1">// a real implementation would be signed to make sure</code><code class="w"/>
<code class="c1">// the user didn't spoof their identity</code><code class="w"/>
<code class="kd">func</code><code class="w"> </code><code class="nx">extractUser</code><code class="p">(</code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">userCookie</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Cookie</code><code class="p">(</code><code class="s">"identity"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">userCookie</code><code class="p">.</code><code class="nx">Value</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Middleware</code><code class="p">(</code><code class="nx">h</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">extractUser</code><code class="p">(</code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">rw</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusUnauthorized</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"unauthorized"</code><code class="p">))</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="nx">ctx</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">ContextWithUser</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">user</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">req</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">WithContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">h</code><code class="p">.</code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">rw</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>In the middleware, you first get your user value. Next, you extract the context from the request with the <code>Context</code> method and create a new context that contains the user with your <code>ContextWithUser</code> function. It is idiomatic to reuse the <code>ctx</code> variable name when you wrap a context. You then make a new request from the old request and the new context by using the <code>WithContext</code> method. Finally, you call the next function in your handler chain with our new request and the supplied <code>http.ResponseWriter</code>.</p>

<p>In most cases, you want to extract the value from the context in your request handler and pass it in to your business logic explicitly. Go functions have explicit parameters, and you shouldn’t use the context as a way to sneak values past the API:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="nx">Controller</code><code class="p">)</code><code class="w"> </code><code class="nx">DoLogic</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">identity</code><code class="p">.</code><code class="nx">UserFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">!</code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">URL</code><code class="p">.</code><code class="nx">Query</code><code class="p">().</code><code class="nx">Get</code><code class="p">(</code><code class="s">"data"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">Logic</code><code class="p">.</code><code class="nx">BusinessLogic</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">user</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">WriteHeader</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">()))</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">rw</code><code class="p">.</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">result</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Your handler gets the context by using the <code>Context</code> method on the request, extracts the user from the context by using the <code>UserFromContext</code> function, and then calls the business logic. This code shows the value of separation of concerns; how the user is loaded is unknown to the <code>Controller</code>. A real user-management system could be implemented in middleware and swapped in without changing any of the controller’s code.</p>

<p>The complete code for this example is in the <em>sample_code/context_user</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2752"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2753"/></p>

<p>In some situations, it’s better to keep a value in the context. The tracking GUID that was mentioned earlier is one. This information is meant for management of your application; it is not part of your business state. Passing it explicitly through your code adds additional parameters and prevents integration with third-party 
<span class="keep-together">libraries</span> that do not know about your metainformation. By leaving a tracking GUID in the context, it passes invisibly through business logic that doesn’t need to know about tracking and is available when your program writes a log message or connects to another server.</p>

<p>Here is a simple context-aware GUID implementation that tracks from service to service and creates logs with the GUID included:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">tracker</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="s">"context"</code><code class="w"/>
<code class="w">    </code><code class="s">"fmt"</code><code class="w"/>
<code class="w">    </code><code class="s">"net/http"</code><code class="w"/>

<code class="w">    </code><code class="s">"github.com/google/uuid"</code><code class="w"/>
<code class="p">)</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">guidKey</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="nx">key</code><code class="w"> </code><code class="nx">guidKey</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">1</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">contextWithGUID</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">guid</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithValue</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">key</code><code class="p">,</code><code class="w"> </code><code class="nx">guid</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">guidFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">g</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Value</code><code class="p">(</code><code class="nx">key</code><code class="p">).(</code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">g</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Middleware</code><code class="p">(</code><code class="nx">h</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="p">)</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">Handler</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandlerFunc</code><code class="p">(</code><code class="kd">func</code><code class="p">(</code><code class="nx">rw</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">guid</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"X-GUID"</code><code class="p">);</code><code class="w"> </code><code class="nx">guid</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="s">""</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">ctx</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">contextWithGUID</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">guid</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">ctx</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">contextWithGUID</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">uuid</code><code class="p">.</code><code class="nx">New</code><code class="p">().</code><code class="nx">String</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="nx">req</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">WithContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">h</code><code class="p">.</code><code class="nx">ServeHTTP</code><code class="p">(</code><code class="nx">rw</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Logger</code><code class="w"> </code><code class="kd">struct</code><code class="p">{}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">Logger</code><code class="p">)</code><code class="w"> </code><code class="nx">Log</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">guid</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">guidFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">message</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"GUID: %s - %s"</code><code class="p">,</code><code class="w"> </code><code class="nx">guid</code><code class="p">,</code><code class="w"> </code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="c1">// do logging</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">Request</code><code class="p">(</code><code class="nx">req</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Context</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">guid</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">guidFromContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">req</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="s">"X-GUID"</code><code class="p">,</code><code class="w"> </code><code class="nx">guid</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">req</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The <code>Middleware</code> function either extracts the GUID from the incoming request or generates a new GUID. In both cases, it places the GUID into the context, creates a new request with the updated context, and continues the call chain.</p>

<p>Next you see how this GUID is used. The <code>Logger</code> struct provides a generic logging method that takes in a context and a string. If there’s a GUID in the context, it appends it to the beginning of the log message and outputs it. The <code>Request</code> function is used when this service makes a call to another service. It takes in an <code>*http.Request</code>, adds a header with the GUID if it exists in the context, and returns the <code>*http.Request</code>.</p>

<p>Once you have this package, you can use the dependency injection techniques that I discussed in <a data-type="xref" href="ch07.html#dependency_injection">“Implicit Interfaces Make Dependency Injection Easier”</a> to create business logic that is completely unaware of any tracking information. First, you declare an interface to represent your logger, a function type to represent a request decorator, and a business logic struct that depends on them:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Logger</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Log</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">RequestDecorator</code><code class="w"> </code><code class="kd">func</code><code class="p">(</code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">LogicImpl</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">RequestDecorator</code><code class="w"> </code><code class="nx">RequestDecorator</code><code class="w"/>
<code class="w">    </code><code class="nx">Logger</code><code class="w">           </code><code class="nx">Logger</code><code class="w"/>
<code class="w">    </code><code class="nx">Remote</code><code class="w">           </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Next, you implement your business logic:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">l</code><code class="w"> </code><code class="nx">LogicImpl</code><code class="p">)</code><code class="w"> </code><code class="nx">Process</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">l</code><code class="p">.</code><code class="nx">Logger</code><code class="p">.</code><code class="nx">Log</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"starting Process with "</code><code class="o">+</code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">req</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">NewRequestWithContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">http</code><code class="p">.</code><code class="nx">MethodGet</code><code class="p">,</code><code class="w"> </code><code class="nx">l</code><code class="p">.</code><code class="nx">Remote</code><code class="o">+</code><code class="s">"/second?query="</code><code class="o">+</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">l</code><code class="p">.</code><code class="nx">Logger</code><code class="p">.</code><code class="nx">Log</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"error building remote request:"</code><code class="o">+</code><code class="nx">err</code><code class="p">.</code><code class="nx">Error</code><code class="p">())</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">req</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">l</code><code class="p">.</code><code class="nx">RequestDecorator</code><code class="p">(</code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">DefaultClient</code><code class="p">.</code><code class="nx">Do</code><code class="p">(</code><code class="nx">req</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="c1">// process the response...</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The GUID is passed through to the logger and the request decorator without the business logic being aware of it, separating the data needed for program logic from the data needed for program management. The only place that’s aware of the association is the code in <code>main</code> that wires up your dependencies:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">controller</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">Controller</code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Logic</code><code class="p">:</code><code class="w"> </code><code class="nx">LogicImpl</code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">RequestDecorator</code><code class="p">:</code><code class="w"> </code><code class="nx">tracker</code><code class="p">.</code><code class="nx">Request</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="nx">Logger</code><code class="p">:</code><code class="w">           </code><code class="nx">tracker</code><code class="p">.</code><code class="nx">Logger</code><code class="p">{},</code><code class="w"/>
<code class="w">        </code><code class="nx">Remote</code><code class="p">:</code><code class="w">           </code><code class="s">"http://localhost:4000"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="p">},</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find the complete code for the GUID tracker in the <em>sample_code/context_guid</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2754"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2755"/></p>
<div data-type="tip"><h6>Tip</h6>
<p>Use the context to pass values through standard APIs. Copy values from the context into explicit parameters when they are needed for processing business logic. System maintenance information can be accessed directly from the context.<a data-type="indexterm" data-startref="ch14-val" id="id2756"/><a data-type="indexterm" data-startref="ch14-val2" id="id2757"/><a data-type="indexterm" data-startref="ch14-val3" id="id2758"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Cancellation"><div class="sect1" id="cancelation">
<h1>Cancellation</h1>

<p>While context values are useful for passing<a data-type="indexterm" data-primary="context package" data-secondary="cancellation" id="ch14-cancl"/><a data-type="indexterm" data-primary="cancellation" id="ch14-cancl2"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="cancellation" id="ch14-cancl3"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" data-secondary="context" data-tertiary="cancellation" id="ch14-cancl4"/><a data-type="indexterm" data-primary="context package" data-secondary="terminating goroutines" data-tertiary="context cancellation" id="ch14-cancl5"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" data-tertiary="context cancellation" id="ch14-cancl6"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="terminating" data-tertiary="context cancellation" id="ch14-cancl7"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="terminating" id="ch14-cancl8"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="terminating" id="ch14-cancl9"/> metadata and working around the limitations of Go’s HTTP API, the context has a second use. The context also allows you to control the responsiveness of your application and coordinate concurrent goroutines. Let’s see how.</p>

<p>I  discussed this briefly in <a data-type="xref" href="ch12.html#done_channel">“Use the Context to Terminate Goroutines”</a>. Imagine that you have a request that launches several goroutines, each one calling a different HTTP service. If one service returns an error that prevents you from returning a valid result, there is no point in continuing to process the other goroutines. In Go, this is called <em>cancellation</em>, and the context provides the mechanism for its implementation.</p>

<p>To create a cancellable context, <a data-type="indexterm" data-primary="context package" data-secondary="context.WithCancel" id="id2759"/><a data-type="indexterm" data-primary="context package" data-secondary="context.CancelFunc" id="id2760"/>use the <code>context.WithCancel</code> function. It takes in a <code>context.Context</code> as a parameter and returns a <code>context.Context</code> and a 
<span class="keep-together"><code>context.CancelFunc</code>.</span> Just like <code>context.WithValue</code>, the returned <code>context.Context</code> is a child context of the context that was passed into the function. A <code>context.CancelFunc</code> is a function that takes no parameters and <em>cancels</em> the context, telling all the code that’s listening for potential cancellation that it’s time to stop processing.</p>

<p>Anytime you create a context that has an associated cancel function, you <em>must</em> call that cancel function when you are done processing, whether or not your processing ends in an error. If you do not, your program will leak resources (memory and goroutines) and eventually slow down or crash. No error occurs if you call the cancel function more than once; any invocation after the first does nothing.</p>

<p>The easiest way to make sure you call the cancel function is to use <code>defer</code> to invoke it right after the cancel function is returned:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithCancel</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">())</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="p">()</code><code class="w"/></pre>

<p>This leads to the question, how do you detect cancellation? The <code>context.Context</code> interface has a method called <code>Done</code>. It returns a channel of type <code>struct{}</code>. (The reason this is the chosen return type is that an empty struct uses no memory.) This channel is closed when the <code>cancel</code> function is invoked. Remember, a closed channel always immediately returns its zero value when you attempt to read it.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you call <code>Done</code> on a context that isn’t cancellable, it returns <code>nil</code>. As was covered in <a data-type="xref" href="ch12.html#nil_channel">“Turn Off a case in a select”</a>, a read from a <code>nil</code> channel never returns. If this is not done inside a <code>case</code> in a <code>select</code> statement, your program will hang.</p>
</div>

<p>Let’s take a look at how this works. Let’s say you have a program that’s gathering data from a number of HTTP endpoints. If any one of them fails, you want to end processing across all of them. Context cancellation allows you to do that.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this example, you are going to take advantage of a great service called <a href="http://httpbin.org">httpbin.org</a>. You send it HTTP or HTTPS requests to test how your application responds to a variety of situations. You’ll use two of its endpoints: one that delays response for a specified number of seconds, and one that will return one of the status codes that you send it.</p>
</div>

<p>First, create your cancellable context, a channel to get back data from your goroutines, and a <code>sync.WaitGroup</code> to allow you to wait until all goroutines have completed:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithCancel</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">())</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="p">()</code><code class="w"/>
<code class="nx">ch</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">make</code><code class="p">(</code><code class="kd">chan</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">wg</code><code class="w"> </code><code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code><code class="w"/>
<code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code class="w"/></pre>

<p>Next, you launch two goroutines, one that calls a URL that randomly returns a bad status, and the other that sends a canned JSON response after a delay. First the random status goroutine:</p>

<pre data-type="programlisting" data-code-language="go"><code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// return one of these status code at random</code><code class="w"/>
<code class="w">            </code><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">makeRequest</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"/>
<code class="w">                </code><code class="s">"http://httpbin.org/status/200,200,200,500"</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error in status goroutine:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="nx">cancelFunc</code><code class="p">()</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">StatusCode</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"bad status, exiting"</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="nx">cancelFunc</code><code class="p">()</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="s">"success from status"</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">1</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/></pre>

<p>The <code>makeRequest</code> function is a helper to make an HTTP request using the supplied context and URL. If you get back an OK status, you write a message to the channel and sleep for a second. When an error occurs or you get back a bad status code, you call <code>cancelFunc</code> and exit the goroutine.</p>

<p>The delay goroutine is similar:</p>

<pre data-type="programlisting" data-code-language="go"><code class="w">    </code><code class="k">go</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">defer</code><code class="w"> </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="w">        </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// return after a 1 second delay</code><code class="w"/>
<code class="w">            </code><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">makeRequest</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"http://httpbin.org/delay/1"</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">                </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"error in delay goroutine:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">                </code><code class="nx">cancelFunc</code><code class="p">()</code><code class="w"/>
<code class="w">                </code><code class="k">return</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">            </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="s">"success from delay: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"date"</code><code class="p">):</code><code class="w"/>
<code class="w">            </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/></pre>

<p class="pagebreak-before">Finally, you use the for/select pattern to read data from the channel written to by the goroutines and wait for cancellation to happen:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">loop</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main: cancelled!"</code><code class="p">)</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"> </code><code class="nx">loop</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/></pre>

<p>In your <code>select</code> statement, you have two cases. One reads from the message channel, and the other waits for the done channel to be closed. When it closes, you exit the loop and wait for the goroutines to exit. You can find this program in the <em>sample_code/cancel_http</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2761"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2762"/></p>

<p>Here’s what happens when you run the code (the results are random, so go ahead and run it a few times to see different results):</p>

<pre data-type="programlisting">in main: success from status
in main: success from delay: Thu, 16 Feb 2023 03:53:57 GMT
in main: success from status
in main: success from delay: Thu, 16 Feb 2023 03:53:58 GMT
bad status, exiting
in main: cancelled!
error in delay goroutine: Get "http://httpbin.org/delay/1": context canceled</pre>

<p>There are some interesting things to note. First, you are calling <code>cancelFunc</code> multiple times. As mentioned earlier, this is perfectly fine and causes no problems. Next, notice that you got an error from the delay goroutine after cancellation was triggered. This is because the built-in HTTP client in the Go standard library respects cancellation. You created the request using the cancellable context, and when it was cancelled, the request ended. This triggers the error path in the goroutine and makes sure that it does not leak.</p>

<p>You might wonder about the error that caused the cancellation and how you can report it. An alternate version of <code>WithCancel</code>, called <code>WithCancelCause</code>, returns a cancellation function that takes in an error as a parameter. <a data-type="indexterm" data-primary="context package" data-secondary="context.Cause" id="id2763"/>The <code>Cause</code> function in the <code>context</code> package returns the error that was passed into the first invocation of the cancellation function.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>Cause</code> is a function in the <code>context</code> package instead of a method on <code>context.Context</code> because the ability to return errors via cancellation was added to the <code>context</code> package in Go 1.20, long after the context was initially introduced. If a new method was added to the <code>context.Context</code> interface, this would have broken any third-party code that implemented it. Another option would be to define a new interface that included this method, but existing code already passes <code>context.Context</code> everywhere, and converting to a new interface with a <code>Cause</code> method would require type assertions or type switches. Adding a function is the simplest approach. There are several ways to evolve your APIs over time. You should pick the one that has the least impact on your users.</p>
</div>

<p>Let’s rewrite the program to capture the error. First, you change your context 
<span class="keep-together">creation:</span></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithCancelCause</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">())</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="p">(</code><code class="kc">nil</code><code class="p">)</code><code class="w"/></pre>

<p>Next, you are going to make slight modifications to your two goroutines. The body of the <code>for</code> loop in the status goroutine now looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">makeRequest</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"http://httpbin.org/status/200,200,200,500"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">cancelFunc</code><code class="p">(</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in status goroutine: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">StatusCode</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">cancelFunc</code><code class="p">(</code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"bad status"</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="s">"success from status"</code><code class="w"/>
<code class="nx">time</code><code class="p">.</code><code class="nx">Sleep</code><code class="p">(</code><code class="mi">1</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/></pre>

<p>You’ve removed the <code>fmt.Println</code> statements and pass errors to <code>cancelFunc</code>. The body of the <code>for</code> loop in the delay goroutine now looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">resp</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">makeRequest</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="s">"http://httpbin.org/delay/1"</code><code class="p">)</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in delay goroutine:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">cancelFunc</code><code class="p">(</code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in delay goroutine: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="nx">ch</code><code class="w"> </code><code class="o">&lt;-</code><code class="w"> </code><code class="s">"success from delay: "</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">resp</code><code class="p">.</code><code class="nx">Header</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"date"</code><code class="p">)</code><code class="w"/></pre>

<p>The <code>fmt.Println</code> is still there so you can show that the error is still generated and passed to <code>cancelFunc</code>.</p>

<p class="pagebreak-before">Finally, you use <code>context.Cause</code> to print out the error both on initial cancellation and after you finish waiting for your goroutines to complete:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">loop</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ch</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main:"</code><code class="p">,</code><code class="w"> </code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Done</code><code class="p">():</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main: cancelled with error"</code><code class="p">,</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Cause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">))</code><code class="w"/>
<code class="w">            </code><code class="k">break</code><code class="w"> </code><code class="nx">loop</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"context cause:"</code><code class="p">,</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Cause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">))</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/cancel_error_http</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2764"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2765"/></p>

<p>Running your new program produces this output:</p>

<pre data-type="programlisting">in main: success from status
in main: success from delay: Thu, 16 Feb 2023 04:11:49 GMT
in main: cancelled with error bad status
in delay goroutine: Get "http://httpbin.org/delay/1": context canceled
context cause: bad status</pre>

<p>You see that the error from the status goroutine is printed out both when cancellation is initially detected in the <code>switch</code> statement and after you finish waiting for the delay goroutine to complete. Notice that the delay goroutine called <code>cancelFunc</code> with an error, but that error doesn’t overwrite the initial cancellation error.</p>

<p>Manual cancellation is very useful when your code reaches a logical state that ends processing. Sometimes you want to cancel because a task is taking too long. In that case, you use a timer.<a data-type="indexterm" data-startref="ch14-cancl" id="id2766"/><a data-type="indexterm" data-startref="ch14-cancl2" id="id2767"/><a data-type="indexterm" data-startref="ch14-cancl3" id="id2768"/><a data-type="indexterm" data-startref="ch14-cancl4" id="id2769"/><a data-type="indexterm" data-startref="ch14-cancl5" id="id2770"/><a data-type="indexterm" data-startref="ch14-cancl6" id="id2771"/><a data-type="indexterm" data-startref="ch14-cancl7" id="id2772"/><a data-type="indexterm" data-startref="ch14-cancl8" id="id2773"/><a data-type="indexterm" data-startref="ch14-cancl9" id="id2774"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Contexts with Deadlines"><div class="sect1" id="context_timers">
<h1>Contexts with Deadlines</h1>

<p>One of the most important jobs<a data-type="indexterm" data-primary="context package" data-secondary="contexts with deadlines" id="ch14-dead"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" data-secondary="context" data-tertiary="contexts with deadlines" id="ch14-dead2"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="contexts with deadlines" id="ch14-dead3"/> for a server is managing requests. A novice programmer often thinks that a server should take as many requests as it possibly can and work on them for as long as it can until it returns a result for each client.</p>

<p>The problem is that this approach does not scale. A server is a shared resource. Like all shared resources, each user wants to get as much as they can out of it and isn’t terribly concerned with the needs of other users. It’s the responsibility of the shared resource to manage itself so that it provides a fair amount of time to all its users.</p>

<p class="pagebreak-before">Generally, a server can do four things to manage its load:</p>

<ul>
<li>
<p>Limit simultaneous requests</p>
</li>
<li>
<p>Limit the number of queued requests waiting to run</p>
</li>
<li>
<p>Limit the amount of time a request can run</p>
</li>
<li>
<p>Limit the resources a request can use (such as memory or disk space)</p>
</li>
</ul>

<p>Go provides tools to handle the first three. You saw how to handle the first two when learning about concurrency in <a data-type="xref" href="ch12.html#unique_chapter_id_12">Chapter 12</a>. By limiting the number of goroutines, a server manages simultaneous load. The size of the waiting queue is handled via buffered channels.</p>

<p>The context provides a way to control how long a request runs. When building an application, you should have an idea of your performance envelope: how long you have for your request to complete before the user has an unsatisfactory experience. If you know the maximum amount of time that a request can run, you can enforce it using the context.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While <code>GOMEMLIMIT</code> provides a <a data-type="indexterm" data-primary="environment variables" data-secondary="GOMEMLIMIT" id="id2775"/><a data-type="indexterm" data-primary="GOMEMLIMIT environment variable" id="id2776"/>soft way to limit the amount of memory a Go program uses, if you want to enforce constraints on memory or disk space that a single request uses, you’ll have to write the code to manage that yourself. Discussion of this topic is beyond the scope of this book.</p>
</div>

<p>You can use one of two functions<a data-type="indexterm" data-primary="context package" data-secondary="context.WithTimeout" id="id2777"/> to create a time-limited context. The first is <code>context.WithTimeout</code>. It takes two parameters: an existing context and 
<span class="keep-together"><code>time.Duration</code></span> that specifies the duration until the context automatically cancels. It returns a context that automatically triggers a cancellation after the specified duration as well as a cancellation function that is invoked to cancel the context immediately.</p>

<p>The second function is <code>context.WithDeadline</code>. <a data-type="indexterm" data-primary="context package" data-secondary="context.WithDeadline" id="id2778"/>This function takes in an existing context and a <code>time.Time</code> that specifies the time when the context is automatically canceled. Like <code>context.WithTimeout</code>, it returns a context that automatically triggers a cancellation after the specified time has elapsed as well as a cancellation function.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you pass a time in the past to <code>context.WithDeadline</code>, the context is created already canceled.</p>
</div>

<p>Just as with the cancellation function returned from <code>context.WithCancel</code> and <code>context.WithCancelCause</code>, you must make sure that that the cancellation function returned by <code>context.WithTimeout</code> and <code>context.WithDeadline</code> is invoked at least once.</p>

<p>If you want to find out when a context will automatically cancel, use the <code>Deadline</code> method on <code>context.Context</code>. It returns a <code>time.Time</code> that indicates the time and a <code>bool</code> that indicates if a timeout was set. This mirrors the comma ok idiom you use when reading from maps or channels.</p>

<p>When you set a time limit for the overall duration of the request, you might want 
<span class="keep-together">to subdivide</span> that time. And if you call another service from your service, you might want to limit how long you allow the network call to run, reserving some time for 
<span class="keep-together">the rest</span> of your processing or for other network calls. You control how long an individual call takes by creating a child context that wraps a parent context by using 
<span class="keep-together"><code>context.WithTimeout</code></span> or <code>context.WithDeadline</code>.</p>

<p>Any timeout that you set on the child context is bounded by the timeout set on the parent context; if a parent context times out in 2 seconds, you can declare that a child context times out in 3 seconds, but when the parent context times out after 2 seconds, so will the child.</p>

<p>You can see this with a simple program:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">()</code><code class="w"/>
<code class="nx">parent</code><code class="p">,</code><code class="w"> </code><code class="nx">cancel</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancel</code><code class="p">()</code><code class="w"/>
<code class="nx">child</code><code class="p">,</code><code class="w"> </code><code class="nx">cancel2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">parent</code><code class="p">,</code><code class="w"> </code><code class="mi">3</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancel2</code><code class="p">()</code><code class="w"/>
<code class="nx">start</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="o">&lt;-</code><code class="nx">child</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code><code class="w"/>
<code class="nx">end</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">()</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">end</code><code class="p">.</code><code class="nx">Sub</code><code class="p">(</code><code class="nx">start</code><code class="p">).</code><code class="nx">Truncate</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">))</code><code class="w"/></pre>

<p>In this sample, you specify a 2-second timeout on the parent context and a 3-second timeout on the child context. You then wait for the child context to complete by waiting on the channel returned from the <code>Done</code> method on the child <code>context.Context</code>. I’ll talk more about the <code>Done</code> method in the next section.</p>

<p>You can find this code in the <em>sample_code/nested_timers</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a> or run this code on <a href="https://oreil.ly/FS8h2">The Go Playground</a>. You’ll see the following result:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="ix_nnn123"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="ix_n12345n"/></p>

<pre data-type="programlisting">2s</pre>

<p>Since contexts with timers can cancel because of a timeout or an explicit call to the cancellation function, the context API provides a way to tell what caused cancellation. The <code>Err</code> method returns <code>nil</code> if the context is still active, or it returns one of two sentinel errors if the context has been canceled: <code>context.Canceled</code> or <code>context.DeadlineExceeded</code>. The first is returned after explicit cancellation, and the second is returned when a timeout triggered cancellation.</p>

<p>Let’s see them in use. You’re going to make one more change to your httpbin program. This time, you’re adding a timeout to the context that’s used to control how long the goroutines run:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancelFuncParent</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithTimeout</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(),</code><code class="w"> </code><code class="mi">3</code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancelFuncParent</code><code class="p">()</code><code class="w"/>
<code class="nx">ctx</code><code class="p">,</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">WithCancelCause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="w"/>
<code class="k">defer</code><code class="w"> </code><code class="nx">cancelFunc</code><code class="p">(</code><code class="kc">nil</code><code class="p">)</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you want the option of returning the error for the cancellation cause, you need to wrap a context created by <code>WithTimeout</code> or <code>WithDeadline</code> in a context created by <code>WithCancelCause</code>. You must <code>defer</code> both cancellation functions to keep resources from being leaked. If you want to return a custom sentinel error when a context times out, use the <code>context.WithTimeoutCause</code> or <code>context.WithDeadlineCause</code> functions instead.</p>
</div>

<p>Now your program will exit if a 500 status code is returned or if you don’t get a 500 status code
within 3 seconds. The only other change you are making to the program is to print out the value returned by <code>Err</code> when cancellation happens:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"in main: cancelled with cause:"</code><code class="p">,</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Cause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">),</code><code class="w"/>
<code class="w">    </code><code class="s">"err:"</code><code class="p">,</code><code class="w"> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Err</code><code class="p">())</code><code class="w"/></pre>

<p>You can find the code in the <em>sample_code/timeout_error_http</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-startref="ix_n12345n" id="id2779"/><a data-type="indexterm" data-startref="ix_nnn123" id="id2780"/></p>

<p>The results are random, so run the program multiple times to see different results. If you run the program and hit the timeout, you’ll get output like this:</p>

<pre data-type="programlisting">in main: success from status
in main: success from delay: Sun, 19 Feb 2023 04:36:44 GMT
in main: success from status
in main: success from status
in main: success from delay: Sun, 19 Feb 2023 04:36:45 GMT
in main: cancelled with cause: context deadline exceeded
    err: context deadline exceeded
in delay goroutine: Get "http://httpbin.org/delay/1":
    context deadline exceeded
context cause: context deadline exceeded</pre>

<p>Notice that the error returned by <code>context.Cause</code> is the same error that’s returned by the
<code>Err</code> method: <code>context.DeadlineExceeded</code>.</p>

<p>If the status error happens within 3 seconds, you’ll get output like this:</p>

<pre data-type="programlisting">in main: success from status
in main: success from status
in main: success from delay: Sun, 19 Feb 2023 04:37:14 GMT
in main: cancelled with cause: bad status err: context canceled
in delay goroutine: Get "http://httpbin.org/delay/1": context canceled
context cause: bad status</pre>

<p>Now the error returned by <code>context.Cause</code> is <code>bad status</code>, but <code>Err</code> returns a <code>context.Canceled</code> error.<a data-type="indexterm" data-startref="ch14-dead" id="id2781"/><a data-type="indexterm" data-startref="ch14-dead2" id="id2782"/><a data-type="indexterm" data-startref="ch14-dead3" id="id2783"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Context Cancellation in Your Own Code"><div class="sect1" id="id267">
<h1>Context Cancellation in Your Own Code</h1>

<p>Most of the time, you don’t need to worry<a data-type="indexterm" data-primary="context package" data-secondary="cancellation" data-tertiary="in your own code" id="id2784"/><a data-type="indexterm" data-primary="cancellation" data-secondary="in your own code" id="id2785"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="always clean up goroutines" data-tertiary="cancellation in your own code" id="id2786"/><a data-type="indexterm" data-primary="concurrency" data-secondary="goroutines" data-tertiary="terminating" id="id2787"/><a data-type="indexterm" data-primary="functions" data-secondary="goroutines in concurrency" data-tertiary="terminating" id="id2788"/><a data-type="indexterm" data-primary="goroutines in concurrency" data-secondary="terminating" data-tertiary="cancellation in your own code" id="id2789"/><a data-type="indexterm" data-primary="metadata" data-secondary="context" data-tertiary="cancellation in your own code" id="id2790"/><a data-type="indexterm" data-primary="middleware pattern of HTTP server" data-secondary="context" data-tertiary="cancellation in your own code" id="id2791"/> about timeouts or cancellation within your own code; it simply doesn’t run for long enough. Whenever you call another HTTP service or the database, you should pass along the context; those libraries properly handle cancellation via the context.</p>

<p>You should think about handling cancellation for two situations. The first is when you have a function that reads or writes channels by using a <code>select</code> statement. As shown in <a data-type="xref" href="#cancelation">“Cancellation”</a>, include a <code>case</code> that checks the channel returned by the <code>Done</code> method on the context. This allows your function to exit upon context cancellation, even if the goroutines do not handle cancellation properly.</p>

<p>The second situation is when you write code that runs long enough that it should be interrupted by a context cancellation. In that case, check the status of the context periodically using <code>context.Cause</code>. The <code>context.Cause</code> function returns an error if the context has been cancelled.</p>

<p>Here’s the pattern for supporting context cancellation in your code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">longRunningComputation</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// do some processing</code><code class="w"/>
<code class="w">        </code><code class="c1">// insert this if statement periodically</code><code class="w"/>
<code class="w">        </code><code class="c1">// to check if the context has been cancelled</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Cause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="c1">// return a partial value if it makes sense,</code><code class="w"/>
<code class="w">            </code><code class="c1">// or a default one if it doesn't</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">        </code><code class="c1">// do some more processing and loop again</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Here’s an example loop from a function that calculates π by using the inefficient Leibniz algorithm. Using context cancellation allows you to control how long it can run:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="k">for</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Cause</code><code class="p">(</code><code class="nx">ctx</code><code class="p">);</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"cancelled after"</code><code class="p">,</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="s">"iterations"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">sum</code><code class="p">.</code><code class="nx">Text</code><code class="p">(</code><code class="sc">'g'</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">),</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">diff</code><code class="w"> </code><code class="nx">big</code><code class="p">.</code><code class="nx">Float</code><code class="w"/>
<code class="w">    </code><code class="nx">diff</code><code class="p">.</code><code class="nx">SetInt64</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">diff</code><code class="p">.</code><code class="nx">Quo</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">diff</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">d</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">i</code><code class="o">%</code><code class="mi">2</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">sum</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">sum</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">diff</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">sum</code><code class="p">.</code><code class="nx">Sub</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">sum</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">diff</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">d</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">d</code><code class="p">,</code><code class="w"> </code><code class="nx">two</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">i</code><code class="o">++</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can see the complete sample program that demonstrates this pattern in the <em>sample_code/own_cancellation</em> directory in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2792"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 14" data-tertiary-sortas="nnn" id="id2793"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id356">
<h1>Exercises</h1>

<p>Now that you’ve seen how to use the context, try to implement these exercises. All the answers are found in the <a href="https://oreil.ly/iT-az">Chapter 14 repository</a>.</p>
<ol>
<li>
<p>Create a middleware-generating function that creates a context with a timeout. The function should have one parameter, which is the number of milliseconds that a request is allowed to run. It should return a <code>func(http.Handler) http.Handler</code>.</p>
</li>
<li>
<p>Write a program that adds randomly generated numbers between 0 (inclusive) and 100,000,000 (exclusive) together until one of two things happen: the number 1234 is generated or 2 seconds has passed. Print out the sum, the number of iterations, and the reason for ending (timeout or number reached).</p>
</li>
<li>
<p>Assume you have a simple logging function that looks like this:</p>
<div class="openblock">
<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">Log</code><code class="p">(</code><code class="nx">ctx</code><code class="w"> </code><code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code><code class="w"> </code><code class="nx">level</code><code class="w"> </code><code class="nx">Level</code><code class="p">,</code><code class="w"> </code><code class="nx">message</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">inLevel</code><code class="w"> </code><code class="nx">Level</code><code class="w"/>
<code class="w">    </code><code class="c1">// TODO get a logging level out of the context and assign it to inLevel</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">level</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">Debug</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">inLevel</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">Debug</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">level</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">Info</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">(</code><code class="nx">inLevel</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">Debug</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="nx">inLevel</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">Info</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Define a type called <code>Level</code> whose underlying type is <code>string</code>. Define two constants of this type, <code>Debug</code> and <code>Info</code>, and set them to <code>"debug"</code> and <code>"info"</code>, 
<span class="keep-together">respectively.</span></p>

<p>Create functions to store the log level in the context and to extract it.</p>

<p>Create a middleware function to get the logging level from a query parameter called <code>log_level</code>. The valid values for <code>log_level</code> are <code>debug</code> and <code>info</code>.</p>

<p>Finally, fill in the <code>TODO</code> in <code>Log</code> to properly extract the log level from the context. If the log level is not assigned or is not a valid value, nothing should be printed.</p>
</div>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id357">
<h1>Wrapping Up</h1>

<p>In this chapter, you learned how to manage request metadata by using the context. You can now set timeouts, perform explicit cancellation, pass values through the context, and know when you should do each of these things. In the next chapter, you’re going to see Go’s built-in testing framework and learn how to use it to find bugs and diagnose performance problems in your programs.</p>
</div></section>
</div></section></div>
</div>
</body></html>