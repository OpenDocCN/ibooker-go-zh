["```go\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n```", "```go\ntype NotHowReaderIsDefined interface {\n    Read() (p []byte, err error)\n}\n```", "```go\nfunc countLetters(r io.Reader) (map[string]int, error) {\n    buf := make([]byte, 2048)\n    out := map[string]int{}\n    for {\n        n, err := r.Read(buf)\n        for _, b := range buf[:n] {\n            if (b >= 'A' && b <= 'Z') || (b >= 'a' && b <= 'z') {\n                out[string(b)]++\n            }\n        }\n        if err == io.EOF {\n            return out, nil\n        }\n        if err != nil {\n            return nil, err\n        }\n    }\n}\n```", "```go\ns := \"The quick brown fox jumped over the lazy dog\"\nsr := strings.NewReader(s)\ncounts, err := countLetters(sr)\nif err != nil {\n    return err\n}\nfmt.Println(counts)\n```", "```go\nfunc buildGZipReader(fileName string) (*gzip.Reader, func(), error) {\n    r, err := os.Open(fileName)\n    if err != nil {\n        return nil, nil, err\n    }\n    gr, err := gzip.NewReader(r)\n    if err != nil {\n        return nil, nil, err\n    }\n    return gr, func() {\n        gr.Close()\n        r.Close()\n    }, nil\n}\n```", "```go\nr, closer, err := buildGZipReader(\"my_data.txt.gz\")\nif err != nil {\n    return err\n}\ndefer closer()\ncounts, err := countLetters(r)\nif err != nil {\n    return err\n}\nfmt.Println(counts)\n```", "```go\ntype Closer interface {\n        Close() error\n}\n\ntype Seeker interface {\n        Seek(offset int64, whence int) (int64, error)\n}\n```", "```go\nf, err := os.Open(fileName)\nif err != nil {\n    return nil, err\n}\ndefer f.Close()\n// use f\n```", "```go\ntype nopCloser struct {\n    io.Reader\n}\n\nfunc (nopCloser) Close() error { return nil }\n\nfunc NopCloser(r io.Reader) io.ReadCloser {\n    return nopCloser{r}\n}\n```", "```go\nd := 2 * time.Hour + 30 * time.Minute // d is of type time.Duration\n```", "```go\nt, err := time.Parse(\"2006-01-02 15:04:05 -0700\", \"2023-03-13 00:00:00 +0000\")\nif err != nil {\n    return err\n}\nfmt.Println(t.Format(\"January 2, 2006 at 3:04:05PM MST\"))\n```", "```go\nMarch 13, 2023 at 12:00:00AM UTC\n```", "```go\n{\n    \"id\":\"12345\",\n    \"date_ordered\":\"2020-05-01T13:01:02Z\",\n    \"customer_id\":\"3\",\n    \"items\":[{\"id\":\"xyz123\",\"name\":\"Thing 1\"},{\"id\":\"abc789\",\"name\":\"Thing 2\"}]\n}\n```", "```go\ntype Order struct {\n    ID            string        `json:\"id\"`\n    DateOrdered   time.Time     `json:\"date_ordered\"`\n    CustomerID    string        `json:\"customer_id\"`\n    Items         []Item        `json:\"items\"`\n}\n\ntype Item struct {\n    ID   string `json:\"id\"`\n    Name string `json:\"name\"`\n}\n```", "```go\nvar o Order\nerr := json.Unmarshal([]byte(data), &o)\nif err != nil {\n    return err\n}\n```", "```go\nout, err := json.Marshal(o)\n```", "```go\ntype Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\ntoFile := Person {\n    Name: \"Fred\",\n    Age:  40,\n}\n```", "```go\ntmpFile, err := os.CreateTemp(os.TempDir(), \"sample-\")\nif err != nil {\n    panic(err)\n}\ndefer os.Remove(tmpFile.Name())\nerr = json.NewEncoder(tmpFile).Encode(toFile)\nif err != nil {\n    panic(err)\n}\nerr = tmpFile.Close()\nif err != nil {\n    panic(err)\n}\n```", "```go\ntmpFile2, err := os.Open(tmpFile.Name())\nif err != nil {\n    panic(err)\n}\nvar fromFile Person\nerr = json.NewDecoder(tmpFile2).Decode(&fromFile)\nif err != nil {\n    panic(err)\n}\nerr = tmpFile2.Close()\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"%+v\\n\", fromFile)\n```", "```go\n{\"name\": \"Fred\", \"age\": 40}\n{\"name\": \"Mary\", \"age\": 21}\n{\"name\": \"Pat\", \"age\": 30}\n```", "```go\nvar t struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\ndec := json.NewDecoder(strings.NewReader(streamData))\nfor {\n    err := dec.Decode(&t)\n    if err != nil {\n        if errors.Is(err, io.EOF) {\n            break\n        }\n        panic(err)\n    }\n    // process t\n}\n```", "```go\nvar b bytes.Buffer\nenc := json.NewEncoder(&b)\nfor _, input := range allInputs {\n    t := process(input)\n    err = enc.Encode(t)\n    if err != nil {\n        panic(err)\n    }\n}\nout := b.String()\n```", "```go\ntype RFC822ZTime struct {\n    time.Time\n}\n\nfunc (rt RFC822ZTime) MarshalJSON() ([]byte, error) {\n    out := rt.Time.Format(time.RFC822Z)\n    return []byte(`\"` + out + `\"`), nil\n}\n\nfunc (rt *RFC822ZTime) UnmarshalJSON(b []byte) error {\n    if string(b) == \"null\" {\n        return nil\n    }\n    t, err := time.Parse(`\"`+time.RFC822Z+`\"`, string(b))\n    if err != nil {\n        return err\n    }\n    *rt = RFC822ZTime{t}\n    return nil\n}\n```", "```go\ntype Order struct {\n    ID          string      `json:\"id\"`\n    DateOrdered RFC822ZTime `json:\"date_ordered\"`\n    CustomerID  string      `json:\"customer_id\"`\n    Items       []Item      `json:\"items\"`\n}\n```", "```go\ntype Order struct {\n    ID          string    `json:\"id\"`\n    Items       []Item    `json:\"items\"`\n    DateOrdered time.Time `json:\"date_ordered\"`\n    CustomerID  string    `json:\"customer_id\"`\n}\n```", "```go\nfunc (o Order) MarshalJSON() ([]byte, error) {\n    type Dup Order\n\n    tmp := struct {\n        DateOrdered string `json:\"date_ordered\"`\n        Dup\n    }{\n        Dup: (Dup)(o),\n    }\n    tmp.DateOrdered = o.DateOrdered.Format(time.RFC822Z)\n    b, err := json.Marshal(tmp)\n    return b, err\n}\n```", "```go\nfunc (o *Order) UnmarshalJSON(b []byte) error {\n    type Dup Order\n\n    tmp := struct {\n        DateOrdered string `json:\"date_ordered\"`\n        *Dup\n    }{\n        Dup: (*Dup)(o),\n    }\n\n    err := json.Unmarshal(b, &tmp)\n    if err != nil {\n        return err\n    }\n\n    o.DateOrdered, err = time.Parse(time.RFC822Z, tmp.DateOrdered)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```", "```go\nclient := &http.Client{\n    Timeout: 30 * time.Second,\n}\n```", "```go\nreq, err := http.NewRequestWithContext(context.Background(),\n    http.MethodGet, \"https://jsonplaceholder.typicode.com/todos/1\", nil)\nif err != nil {\n    panic(err)\n}\n```", "```go\nreq.Header.Add(\"X-My-Client\", \"Learning Go\")\nres, err := client.Do(req)\nif err != nil {\n    panic(err)\n}\n```", "```go\ndefer res.Body.Close()\nif res.StatusCode != http.StatusOK {\n    panic(fmt.Sprintf(\"unexpected status: got %v\", res.Status))\n}\nfmt.Println(res.Header.Get(\"Content-Type\"))\nvar data struct {\n    UserID    int    `json:\"userId\"`\n    ID        int    `json:\"id\"`\n    Title     string `json:\"title\"`\n    Completed bool   `json:\"completed\"`\n}\nerr = json.NewDecoder(res.Body).Decode(&data)\nif err != nil {\n    panic(err)\n}\nfmt.Printf(\"%+v\\n\", data)\n```", "```go\ntype Handler interface {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n```", "```go\ntype ResponseWriter interface {\n        Header() http.Header\n        Write([]byte) (int, error)\n        WriteHeader(statusCode int)\n}\n```", "```go\ntype HelloHandler struct{}\n\nfunc (hh HelloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello!\\n\"))\n}\n```", "```go\ns := http.Server{\n    Addr:         \":8080\",\n    ReadTimeout:  30 * time.Second,\n    WriteTimeout: 90 * time.Second,\n    IdleTimeout:  120 * time.Second,\n    Handler:      HelloHandler{},\n}\nerr := s.ListenAndServe()\nif err != nil {\n    if err != http.ErrServerClosed {\n        panic(err)\n    }\n}\n```", "```go\nmux.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello!\\n\"))\n})\n```", "```go\nmux.HandleFunc(\"GET /hello/{name}\", func(w http.ResponseWriter,\n                                         r *http.Request) {\n    name := r.PathValue(\"name\")\n    w.Write([]byte(fmt.Sprintf(\"Hello, %s!\\n\", name)))\n})\n```", "```go\nperson := http.NewServeMux()\nperson.HandleFunc(\"/greet\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"greetings!\\n\"))\n})\ndog := http.NewServeMux()\ndog.HandleFunc(\"/greet\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"good puppy!\\n\"))\n})\nmux := http.NewServeMux()\nmux.Handle(\"/person/\", http.StripPrefix(\"/person\", person))\nmux.Handle(\"/dog/\", http.StripPrefix(\"/dog\", dog))\n```", "```go\nfunc RequestTimer(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        start := time.Now()\n        h.ServeHTTP(w, r)\n        dur := time.Since(start)\n        slog.Info(\"request time\",\n            \"path\", r.URL.Path,\n            \"duration\", dur)\n    })\n}\n\nvar securityMsg = []byte(\"You didn't give the secret password\\n\")\n\nfunc TerribleSecurityProvider(password string) func(http.Handler) http.Handler {\n    return func(h http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            if r.Header.Get(\"X-Secret-Password\") != password {\n                w.WriteHeader(http.StatusUnauthorized)\n                w.Write(securityMsg)\n                return\n            }\n            h.ServeHTTP(w, r)\n        })\n    }\n}\n```", "```go\nterribleSecurity := TerribleSecurityProvider(\"GOPHER\")\n\nmux.Handle(\"/hello\", terribleSecurity(RequestTimer(\n    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"Hello!\\n\"))\n    }))))\n```", "```go\nterribleSecurity := TerribleSecurityProvider(\"GOPHER\")\nwrappedMux := terribleSecurity(RequestTimer(mux))\ns := http.Server{\n    Addr:    \":8080\",\n    Handler: wrappedMux,\n}\n```", "```go\nhelloHandler := func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello!\\n\"))\n}\nchain := alice.New(terribleSecurity, RequestTimer).ThenFunc(helloHandler)\nmux.Handle(\"/hello\", chain)\n```", "```go\nfunc handler(rw http.ResponseWriter, req *http.Request) {\n    rc := http.NewResponseController(rw)\n    for i := 0; i < 10; i++ {\n        result := doStuff(i)\n        _, err := rw.Write([]byte(result))\n        if err != nil {\n            slog.Error(\"error writing\", \"msg\", err)\n            return\n        }\n        err = rc.Flush()\n        if err != nil && !errors.Is(err, http.ErrNotSupported) {\n            slog.Error(\"error flushing\", \"msg\", err)\n            return\n        }\n    }\n}\n```", "```go\nfunc main() {\n    slog.Debug(\"debug log message\")\n    slog.Info(\"info log message\")\n    slog.Warn(\"warning log message\")\n    slog.Error(\"error log message\")\n}\n```", "```go\n2023/04/20 23:13:31 INFO info log message\n2023/04/20 23:13:31 WARN warning log message\n2023/04/20 23:13:31 ERROR error log message\n```", "```go\nuserID := \"fred\"\nloginCount := 20\nslog.Info(\"user login\",\n    \"id\", userID,\n    \"login_count\", loginCount)\n```", "```go\n2023/04/20 23:36:38 INFO user login id=fred login_count=20\n```", "```go\noptions := &slog.HandlerOptions{Level: slog.LevelDebug}\nhandler := slog.NewJSONHandler(os.Stderr, options)\nmySlog := slog.New(handler)\nlastLogin := time.Date(2023, 01, 01, 11, 50, 00, 00, time.UTC)\nmySlog.Debug(\"debug message\",\n    \"id\", userID,\n    \"last_login\", lastLogin)\n```", "```go\n{\"time\":\"2023-04-22T23:30:01.170243-04:00\",\"level\":\"DEBUG\",\n \"msg\":\"debug message\",\"id\":\"fred\",\"last_login\":\"2023-01-01T11:50:00Z\"}\n```", "```go\nmySlog.LogAttrs(ctx, slog.LevelInfo, \"faster logging\",\n                slog.String(\"id\", userID),\n                slog.Time(\"last_login\", lastLogin))\n```", "```go\nmyLog := slog.NewLogLogger(mySlog.Handler(), slog.LevelDebug)\nmyLog.Println(\"using the mySlog Handler\")\n```", "```go\n{\"time\":\"2023-04-22T23:30:01.170269-04:00\",\"level\":\"DEBUG\",\n \"msg\":\"using the mySlog Handler\"}\n```", "```go\n    {\n        \"day_of_week\": \"Monday\",\n        \"day_of_month\": 10,\n        \"month\": \"April\",\n        \"year\": 2023,\n        \"hour\": 20,\n        \"minute\": 15,\n        \"second\": 20\n    }\n    ```"]