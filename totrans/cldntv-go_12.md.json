["```go\n// Effector is the function that you want to subject to throttling.\ntype Effector func(context.Context) (string, error)\n\n// Throttled wraps an Effector. It accepts the same parameters, plus a\n// \"UID\" string that represents a caller identity. It returns the same,\n// plus a bool that's true if the call is not throttled.\ntype Throttled func(context.Context, string) (bool, string, error)\n\n// A bucket tracks the requests associated with a UID.\ntype bucket struct {\n    tokens uint\n    time   time.Time\n}\n\n// Throttle accepts an Effector function, and returns a Throttled\n// function with a per-UID token bucket with a capacity of max\n// that refills at a rate of refill tokens every d.\nfunc Throttle(e Effector, max uint, refill uint, d time.Duration) Throttled {\n    // buckets maps UIDs to specific buckets\n    buckets := map[string]*bucket{}\n\n    return func(ctx context.Context, uid string) (bool, string, error) {\n        b := buckets[uid]\n\n        // This is a new entry! It passes. Assumes that capacity >= 1.\n        if b == nil {\n            buckets[uid] = &bucket{tokens: max - 1, time: time.Now()}\n\n            str, err := e(ctx)\n            return true, str, err\n        }\n\n        // Calculate how many tokens we now have based on the time\n        // passed since the previous request.\n        refillInterval := uint(time.Since(b.time) / d)\n        tokensAdded := refill * refillInterval\n        currentTokens := b.tokens + tokensAdded\n\n        // We don't have enough tokens. Return false.\n        if currentTokens < 1 {\n            return false, \"\", nil\n        }\n\n        // If we've refilled our bucket, we can restart the clock.\n        // Otherwise, we figure out when the most recent tokens were added.\n        if currentTokens > max {\n            b.time = time.Now()\n            b.tokens = max - 1\n        } else {\n            deltaTokens := currentTokens - b.tokens\n            deltaRefills := deltaTokens / refill\n            deltaTime := time.Duration(deltaRefills) * d\n\n            b.time = b.time.Add(deltaTime)\n            b.tokens = currentTokens - 1\n        }\n\n        str, err := e(ctx)\n\n        return true, str, err\n    }\n}\n```", "```go\nvar throttled = Throttle(getHostname, 1, 1, time.Second)\n\nfunc getHostname(ctx context.Context) (string, error) {\n    if ctx.Err() != nil {\n        return \"\", ctx.Err()\n    }\n\n    return os.Hostname()\n}\n\nfunc throttledHandler(w http.ResponseWriter, r *http.Request) {\n    ok, hostname, err := throttled(r.Context(), r.RemoteAddr)\n\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    if !ok {\n        http.Error(w, \"Too many requests\", http.StatusTooManyRequests)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(hostname))\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    r.HandleFunc(\"/hostname\", throttledHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\nconst MaxQueueDepth = 1000\n\n// Middleware function, which will be called for each request.\n// If queue depth is exceeded, it returns HTTP 503 (service unavailable).\nfunc loadSheddingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // CurrentQueueDepth is fictional and for example purposes only.\n        if CurrentQueueDepth() > MaxQueueDepth {\n            log.Println(\"load shedding engaged\")\n\n            http.Error(w,\n                err.Error(),\n                http.StatusServiceUnavailable)\n            return\n        }\n\n        next.ServeHTTP(w, r)\n    })\n}\n\nfunc main() {\n    r := mux.NewRouter()\n\n    // Register middleware\n    r.Use(loadSheddingMiddleware)\n\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\nres, err := SendRequest()\nfor err != nil {\n    res, err = SendRequest()\n}\n```", "```go\nres, err := SendRequest()\nfor err != nil {\n    time.Sleep(2 * time.Second)\n    res, err = SendRequest()\n}\n```", "```go\nres, err := SendRequest()\nbase, cap := time.Second, time.Minute\n\nfor backoff := base; err != nil; backoff <<= 1 {\n    if backoff > cap {\n        backoff = cap\n    }\n    time.Sleep(backoff)\n    res, err = SendRequest()\n}\n```", "```go\nres, err := SendRequest()\nbase, cap := time.Second, time.Minute\n\nfor backoff := base; err != nil; backoff <<= 1 {\n    if backoff > cap {\n        backoff = cap\n    }\n\n    jitter := rand.Int63n(int64(backoff * 3))\n    sleep := base + time.Duration(jitter)\n    time.Sleep(sleep)\n    res, err = SendRequest()\n}\n```", "```go\nfunc UserName(ctx context.Context, id int) (string, error) {\n    const query = \"SELECT username FROM users WHERE id=?\"\n\n    dctx, cancel := context.WithTimeout(ctx, 15*time.Second)\n    defer cancel()\n\n    var username string\n    err := db.QueryRowContext(dctx, query, id).Scan(&username)\n\n    return username, err\n}\n```", "```go\nfunc UserGetHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    id := vars[\"id\"]\n\n    // Get the request's context. This context is canceled when\n    // the client's connection closes, the request is canceled\n    // (with HTTP/2), or when the ServeHTTP method returns.\n    rctx := r.Context()\n\n    ctx, cancel := context.WithTimeout(rctx, 10*time.Second)\n    defer cancel()\n\n    username, err := UserName(ctx, id)\n\n    switch {\n    case errors.Is(err, sql.ErrNoRows):\n        http.Error(w, \"no such user\", http.StatusNotFound)\n    case errors.Is(err, context.DeadlineExceeded):\n        http.Error(w, \"database timeout\", http.StatusGatewayTimeout)\n    case err != nil:\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    default:\n        w.Write([]byte(username))\n    }\n}\n```", "```go\nvar client = &http.Client{\n    Timeout: time.Second * 10,\n}\n\nresponse, err := client.Get(url)\n```", "```go\nfunc (c *Client) Get(url string) (resp *Response, err error) {\n    req, err := NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    return c.Do(req)\n}\n```", "```go\ntype ClientContext struct {\n    http.Client\n}\n\nfunc (c *ClientContext) GetContext(ctx context.Context, url string)\n        (resp *http.Response, err error) {\n\n    req, err := http.NewRequestWithContext(ctx, \"GET\", url, nil)\n    if err != nil {\n        return nil, err\n    }\n\n    return c.Do(req)\n}\n```", "```go\nfunc main() {\n    client := &ClientContext{}\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    response, err := client.GetContext(ctx, \"http://www.example.com\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    bytes, _ := ioutil.ReadAll(response.Body)\n    fmt.Println(string(bytes))\n}\n```", "```go\n$ go run .\n2020/08/25 14:03:16 Get \"http://www.example.com\": context deadline exceeded\nexit status 1\n```", "```go\nopts := []grpc.DialOption{\n    grpc.WithInsecure(),\n    grpc.WithBlock(),\n    grpc.WithTimeout(5 * time.Second),\n}\nconn, err := grpc.Dial(serverAddr, opts...)\n```", "```go\nfunc TimeoutKeyValueGet() *pb.Response {\n    // Use context to set a 5-second timeout.\n    ctx, cancel := context.WithTimeout(context.Background(), 5 * time.Second)\n    defer cancel()\n\n    // We can still set other options as desired.\n    opts := []grpc.DialOption{grpc.WithInsecure(), grpc.WithBlock()}\n\n    conn, err := grpc.DialContext(ctx, serverAddr, opts...)\n    if err != nil {\n        grpclog.Fatalf(err)\n    }\n    defer conn.Close()\n\n    client := pb.NewKeyValueClient(conn)\n\n    // We can reuse the same Context in the client calls.\n    response, err := client.Get(ctx, &pb.GetRequest{Key: key})\n    if err != nil {\n        grpclog.Fatalf(err)\n    }\n\n    return response\n}\n```", "```go\nvar store = make(map[string]string)\n\nfunc Create(key, value string) error {\n    if _, ok := store[key]; ok {\n        return errors.New(\"duplicate key\")\n    }\n\n    store[key] = value\n    return nil\n}\n\nfunc Update(key, value string) error {\n    if _, ok := store[key]; !ok {\n        return errors.New(\"no such key\")\n    }\n\n    store[key] = value\n    return nil\n}\n\nfunc Delete(key string) error {\n    if _, ok := store[key]; ok {\n        return errors.New(\"no such key\")\n    }\n\n    delete(store, key)\n    return nil\n}\n```", "```go\nvar store = make(map[string]string)\n\nfunc Set(key, value string) {\n    store[key] = value\n}\n\nfunc Delete(key string) {\n    delete(store, key)\n}\n```", "```go\n{\n    \"credit\":{\n        \"accountID\": 12345,\n        \"amount\": 500\n    }\n}\n```", "```go\n{\n    \"credit\":{\n        \"accountID\": 12345,\n        \"amount\": 500,\n        \"transactionID\": 789\n    }\n}\n```", "```go\nfunc healthLivenessHandler(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(http.StatusOK)\n    w.Write([]byte(\"OK\"))\n})\n\nfunc main() {\n    r := mux.NewRouter()\n    http.HandleFunc(\"/healthz\", healthLivenessHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\nfunc healthShallowHandler(w http.ResponseWriter, r *http.Request) {\n    // Create our test file.\n    // This will create a filename like /tmp/shallow-123456\n    tmpFile, err := ioutil.TempFile(os.TempDir(), \"shallow-\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusServiceUnavailable)\n        return\n    }\n    defer os.Remove(tmpFile.Name())\n\n    // Make sure that we can write to the file.\n    text := []byte(\"Check.\")\n    if _, err = tmpFile.Write(text); err != nil {\n        http.Error(w, err.Error(), http.StatusServiceUnavailable)\n        return\n    }\n\n    // Make sure that we can close the file.\n    if err := tmpFile.Close(); err != nil {\n        http.Error(w, err.Error(), http.StatusServiceUnavailable)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    http.HandleFunc(\"/healthz\", healthShallowHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```", "```go\nfunc healthDeepHandler(w http.ResponseWriter, r *http.Request) {\n    // Retrieve the context from the request and add a 5-second timeout\n    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)\n    defer cancel()\n\n    // service.GetUser is a hypothetical method on a service interface\n    // that executes a database query\n    if err := service.GetUser(ctx, 0); err != nil {\n        http.Error(w, err.Error(), http.StatusServiceUnavailable)\n        return\n    }\n\n    w.WriteHeader(http.StatusOK)\n}\n\nfunc main() {\n    r := mux.NewRouter()\n    http.HandleFunc(\"/healthz\", healthDeepHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n```"]