- en: 'Chapter 6\. appending issue: Slices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0175-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**We’ve learned we can’t add more elements to an array.** That’s a real problem
    for our program, because we don’t know in advance how many pieces of data our
    file contains. But that’s where Go **slices** come in. Slices are a collection
    type that can grow to hold additional items—just the thing to fix our current
    program! We’ll also see how slices give users an easier way to provide data to
    *all* your programs, and how they can help you write functions that are more convenient
    to call.'
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There actually *is* a Go data structure that we can add more values to—it’s
    called a **slice**. Like arrays, slices are made up of multiple elements, all
    of the same type. *Unlike* arrays, functions are available that allow us to add
    extra elements onto the end of a slice.
  prefs: []
  type: TYPE_NORMAL
- en: To declare the type for a variable that holds a slice, you use an empty pair
    of square brackets, followed by the type of elements the slice will hold.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0176-01.png)'
  prefs: []
  type: TYPE_IMG
- en: This is just like the syntax for declaring an array variable, except that you
    don’t specify the size.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0176-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlike with array variables, declaring a slice variable doesn’t automatically
    create a slice. For that, you can call the built-in `make` function. You pass
    `make` the type of the slice you want to create (which should be the same as the
    type of the variable you’re going to assign it to), and the length of slice it
    should create.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0176-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the slice is created, you assign and retrieve its elements using the same
    syntax you would for an array.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0176-04.png)'
  prefs: []
  type: TYPE_IMG
- en: You don’t have to declare the variable and create the slice in separate steps;
    using `make` with a short variable declaration will infer the variable’s type
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0176-05.png)'
  prefs: []
  type: TYPE_IMG
- en: The built-in `len` function works the same way with slices as it does with arrays.
    Just pass `len` a slice, and its length will be returned as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0177-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both `for` and `for`...`range` loops work just the same with slices as they
    do with arrays, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0177-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Slice literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like with arrays, if you know in advance what values a slice will start
    with, you can initialize the slice with those values using a **slice literal**.
    A slice literal looks a lot like an array literal, but where an array literal
    has the length of the array in square brackets, a slice literal’s square brackets
    are empty. The empty brackets are then followed by the type of elements the slice
    will hold, and a list in curly braces of the initial values each element will
    have.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to call the `make` function; using a slice literal in your code
    will create the slice *and* prepopulate it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0177-03.png)'
  prefs: []
  type: TYPE_IMG
- en: These examples are like the previous ones we showed, except that instead of
    assigning values to the slice elements one by one, the entire slice is initialized
    using slice literals.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0177-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0178-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0178-02.png)![image](assets/f0178-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: each snippet from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_Solution_4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0179-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Because slices are built on top of arrays. You can’t understand how slices
    work without understanding arrays. Here, we’ll show you why...**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The slice operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every slice is built on top of an **underlying array**. It’s the underlying
    array that actually holds the slice’s data; the slice is merely a view into some
    (or all) of the array’s elements.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the `make` function or a slice literal to create a slice, the underlying
    array is created for you automatically (and you can’t access it, except through
    the slice). But you can also create the array yourself, and then create a slice
    based on it with the **slice operator**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0180-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The slice operator looks similar to the syntax for accessing an individual
    element or slice of an array, except that it has two indexes: the index of the
    array where the slice should start, and the index of the array that the slice
    should stop before.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0180-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we emphasize that the second index is the index the slice will stop
    before. That is, the slice should include the elements up to, but *not* including,
    the second index. If you use `underlyingArray[i:j]` as a slice operator, the resulting
    slice will actually contain the elements `underlyingArray[i]` through `underlyingArray[j-1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (We know, it’s counterintuitive. But a similar notation has been used in the
    Python programming language for over 20 years, and it seems to work OK.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0180-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want a slice to include the last element of an underlying array, you
    actually specify a second index that’s one *beyond* the end of the array in your
    slice operator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0181-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you don’t go any further than that, though, or you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0181-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice operator has defaults for both the start and stop indexes. If you
    omit the start index, a value of `0` (the first element of the array) will be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0181-03.png)'
  prefs: []
  type: TYPE_IMG
- en: And if you omit the stop index, everything from the start index to the end of
    the underlying array will be included in the resulting slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0181-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Underlying arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, a slice doesn’t hold any data itself; it’s merely a view into
    the elements of an underlying array. You can think of a slice as a microscope,
    focusing on a particular portion of the contents of a slide (the underlying array).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0182-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you take a slice of an underlying array, you can only “see” the portion
    of the array’s elements that are visible through the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0182-02.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s even possible to have multiple slices point to the same underlying array.
    Each slice will then be a view into its own subset of the array’s elements. The
    slices can even overlap!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0182-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the underlying array, change the slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, here’s something to be careful about: because a slice is just a view into
    the contents of an array, if you change the underlying array, those changes will
    *also* be visible within the slice!'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0183-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Assigning a new value to a slice element will change the corresponding element
    in the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0183-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If multiple slices point to the same underlying array, a change to the array’s
    elements will be visible in *all* the slices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0183-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Because of these potential issues, you may find it’s generally better to create
    slices using `make` or a slice literal, rather than creating an array and using
    a slice operator on it. With `make` and with slice literals, you never have to
    work with the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: Add onto a slice with the “append” function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0184-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Go offers a built-in `append` function that takes a slice, and one or more values
    you want to append to the end of that slice. It returns a new, larger slice with
    all the same elements as the original slice, plus the new elements added onto
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0184-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You don’t have to keep track of what index you want to assign new values to,
    or anything! Just call `append` with your slice and the value(s) you want added
    to the end, and you’ll get a new, longer slice back. It’s really that easy!
  prefs: []
  type: TYPE_NORMAL
- en: Well, with one caution...
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’re making sure to assign the return value of `append` back to
    the *same* slice variable we passed to `append`. This is to avoid some potentially
    inconsistent behavior in the slices returned from `append`.
  prefs: []
  type: TYPE_NORMAL
- en: A slice’s underlying array can’t grow in size. If there isn’t room in the array
    to add elements, all its elements will be copied to a new, larger array, and the
    slice will be updated to refer to this new array. But since all this happens behind
    the scenes in the `append` function, there’s no easy way to tell whether the slice
    returned from `append` has the *same* underlying array as the slice you passed
    in, or a *different* underlying array. If you keep both slices, this can lead
    to some unpredictable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Below, for example, we have four slices, the last three created by calls to
    `append`. Here we are *not* following the convention of assigning `append`’s return
    value back to the same variable. When we assign a value to an element of the `s4`
    slice, we can see the change reflected in `s3`, because `s4` and `s3` happen to
    share the same underlying array. But the change is *not* reflected in `s2` or
    `s1`, because they have a *different* underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0185-01.png)'
  prefs: []
  type: TYPE_IMG
- en: So when calling `append`, it’s conventional to just assign the return value
    back to the same slice variable you passed to `append`. You don’t need to worry
    about whether two slices have the same underlying array if you’re only storing
    one slice!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0185-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Slices and zero values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with arrays, if you access a slice element that no value has been assigned
    to, you’ll get the zero value for that type back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0186-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike arrays, the slice variable itself *also* has a zero value: it’s `nil`.
    That is, a slice variable that no slice has been assigned to will have a value
    of `nil`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0186-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In other languages, that might require testing whether a variable actually
    contains a slice before attempting to use it. But in Go, functions are intentionally
    written to treat a `nil` slice value as if it were an empty slice. For example,
    the `len` function will return `0` if it’s passed a `nil` slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0186-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The `append` function also treats `nil` slices like empty slices. If you pass
    an empty slice to `append`, it will add the item you specify to the slice, and
    return a slice with one item. If you pass a `nil` slice to `append`, you’ll *also*
    get a slice with one item back, even though there technically was no slice to
    “append” the item to. The `append` function will create the slice behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0186-04.png)'
  prefs: []
  type: TYPE_IMG
- en: This means you generally don’t have to worry about whether you have an empty
    slice or a `nil` slice. You can treat them both the same, and your code will “just
    work”!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0186-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading additional file lines using slices and “append”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know about slices and the `append` function, we can finally fix
    our `average` program! Remember, `average` was failing as soon as we added a fourth
    line to the *data.txt* file it reads from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0187-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We traced the problem back to our `datafile` package, which stores the file
    lines in an array that can’t grow beyond three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0187-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of our work with slices has just centered on understanding them. Now that
    we do, updating the `GetFloats` function to use a slice instead of an array doesn’t
    involve much effort.
  prefs: []
  type: TYPE_NORMAL
- en: First, we update the function declaration to return a slice of `float64` values
    instead of an array. Previously, we stored the array in a variable called `numbers`;
    we’ll just use that same variable name to hold the slice. We won’t assign a value
    to `numbers`, so at first it will be `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of assigning values read from the file to a specific array index, we
    can just call `append` to extend the slice (or create a slice, if it’s `nil`)
    and add new values. That means we can get rid of the code to create and update
    the `i` variable that tracks the index. We assign the `float64` value returned
    from `ParseFloat` to a new temporary variable, just to hold it while we check
    for any errors in parsing. Then we pass the `numbers` slice and the new value
    from the file to `append`, making sure to assign the return value back to the
    `numbers` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from that, the code in `GetFloats` can remain the same—the slice is basically
    a drop-in replacement for the array.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0188-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Trying our improved program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The slice returned from the `GetFloats` function works like a drop-in replacement
    for an array in our main `average` program, too. In fact, we don’t have to make
    *any* changes to the main program!
  prefs: []
  type: TYPE_NORMAL
- en: Because we used a `:=` short variable declaration to assign the `GetFloats`
    return value to a variable, the `numbers` variable automatically switches from
    an inferred type of `[3]float64` (an array) to a type of `[]float64` (a slice).
    And because the `for`...`range` loop and the `len` functions work the same way
    with a slice as they do with an array, no changes are needed to that code, either!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0189-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That means we’re ready to try the changes out! Ensure the *data.txt* file is
    still saved in your Go workspace’s *bin* subdirectory, and then compile and run
    the code using the same commands as before. It will read all the lines of *data.txt*
    and display their average. Then try updating *data.txt* to have more lines, or
    fewer; it will still work regardless!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0189-02.png)![image](assets/f0189-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Returning a nil slice in the event of an error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s make one more small improvement to the `GetFloats` function. Currently,
    we’re returning the `numbers` slice even in the event of an error. That means
    that we could be returning a slice with invalid data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0190-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The code that calls `GetFloats` *should* check the returned error value, see
    that it’s not `nil`, and ignore the contents of the returned slice. But really,
    why bother to return the slice at all, if the data it contains is invalid? Let’s
    update `GetFloats` to return `nil` instead of a slice in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0190-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s recompile the program (which will include the updated `datafile` package)
    and run it. It should work the same as before. But now our error-handling code
    is a little bit cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0190-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](assets/arrow.png) Answers in [“![image](assets/common1.png) Exercise
    Solution”](#exercise_solutions_10).'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0191-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**There is an alternative—users could pass the values to the program as command-line
    arguments.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Just as you can control the behavior of many Go functions by passing them arguments,
    you can pass arguments to many programs you run from the terminal or command prompt.
    This is known as a program’s *command-line interface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen command-line arguments used in this very book. When we
    run the `cd` (“change directory”) command, we pass it the name of the directory
    we want to change to as an argument. When we run the `go` command, we often pass
    it multiple arguments: the subcommand (`run`, `install`, etc.) we want to use,
    and the name of the file or package we want the subcommand to work on.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0191-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting command-line arguments from the os.Args slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s set up a new version of the `average` program, called `average2`, that
    takes the values to average as command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `os` package has a package variable, `os.Args`, that gets set to a slice
    of strings representing the command-line arguments the currently running program
    was executed with. We’ll start by simply printing the `os.Args` slice to see what
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new *average2* directory alongside the *average* directory in your
    workspace, and save a *main.go* file within it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0192-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, save the following code in *main.go*. It simply imports the `fmt` and
    `os` packages, and passes the `os.Args` slice to `fmt.Println`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0192-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s try it out. From your terminal or command prompt, run this command to
    compile and install the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go install github.com/headfirstgo/average2`'
  prefs: []
  type: TYPE_NORMAL
- en: That will install an executable file named *average2* (or *average2.exe* on
    Windows) to your Go workspace’s *bin* subdirectory. Use the `cd` command to change
    to *bin*, and type **average2**, but don’t hit the Enter key just yet. Following
    the program name, type a space, and then type one or more arguments, separated
    by spaces. *Then* hit Enter. The program will run and print the value of `os.Args`.
  prefs: []
  type: TYPE_NORMAL
- en: Rerun `average2` with different arguments, and you should see different output.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0192-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice operator can be used on other slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is working pretty well, but there’s one problem: the name of the executable
    is being included as the first element of `os.Args`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0193-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That should be easy to remove, though. Remember how we used the slice operator
    to get a slice that included everything but the first element of an array?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0193-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The slice operator can be used on slices just like it can on arrays. If we use
    a slice operator of `[1:]` on `os.Args`, it will give us a new slice that omits
    the first element (whose index is `0`), and includes the second element (index
    `1`) through the end of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0193-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If we recompile and rerun `average2`, this time we’ll see that the output includes
    only the actual command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0193-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating our program to use command-line arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’re able to get the command-line arguments as a slice of strings,
    let’s update the `average2` program to convert the arguments to actual numbers,
    and calculate their average. We’ll mostly be able to reuse the concepts we learned
    about in our original `average` program and the `datafile` package.
  prefs: []
  type: TYPE_NORMAL
- en: We use the slice operator on `os.Args` to omit the program name, and assign
    the resulting slice to an `arguments` variable. We set up a `sum` variable that
    will hold the total of all the numbers we’re given. Then we use a `for`...`range`
    loop to process the elements of the `arguments` slice (using the `_` blank identifier
    to ignore the element index). We use `strconv.ParseFloat` to convert the argument
    string to a `float64`. If we get an error, we log it and exit, but otherwise we
    add the current number to `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve looped through all the arguments, we use `len(arguments)` to determine
    how many data samples we’re averaging. We then divide `sum` by this sample count
    to get the average.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0194-01.png)'
  prefs: []
  type: TYPE_IMG
- en: With these changes saved, we can recompile and rerun the program. It will take
    the numbers you provide as arguments and average them. Give as few or as many
    arguments as you like; it will still work!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0194-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Variadic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know about slices, we can cover a feature of Go that we haven’t
    talked about so far. Have you noticed that some function calls can take as few,
    or as many, arguments as needed? Look at `fmt.Println` or `append`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0195-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Don’t try doing this with just any function, though! With all the functions
    we’ve defined so far, there had to be an *exact* match between the number of parameters
    in the function definition and the number of arguments in the function call. Any
    difference would result in a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0195-02.png)'
  prefs: []
  type: TYPE_IMG
- en: So how do `Println` and `append` do it? They’re declared as variadic functions.
    A **variadic function** is one that can be called with a *varying* number of arguments.
    To make a function variadic, use an ellipsis (`...`) before the type of the last
    (or only) function parameter in the function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0195-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The last parameter of a variadic function receives the variadic arguments as
    a slice, which the function can then process like any other slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a variadic version of the `twoInts` function, and it works just fine
    with any number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0196-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s a similar function that works with strings. Notice that if we provide
    no variadic arguments, it’s not an error; the function just receives an empty
    slice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0196-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A function can take one or more nonvariadic arguments as well. Although a function
    caller can omit variadic arguments (resulting in an empty slice), nonvariadic
    arguments are always required; it’s a compile error to omit those. Only the *last*
    parameter in a function definition can be variadic; you can’t place it in front
    of required parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0196-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Using variadic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s a `maximum` function that takes any number of `float64` arguments and
    returns the greatest value out of all of them. The arguments to `maximum` are
    stored in a slice in the `numbers` parameter. To start, we set the current maximum
    value to `-Inf`, a special value representing negative infinity, obtained by calling
    `math.Inf`. (We could start with a current maximum of `0`, but this way `maximum`
    will work with negative numbers.) Then we use `for`...`range` to process each
    argument in the `numbers` slice, comparing it to the current maximum, and setting
    it as the new maximum if it’s greater. Whatever maximum remains after processing
    all the arguments is the one we return.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0197-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s an `inRange` function that takes a minimum value, a maximum value, and
    any number of additional `float64` arguments. It will discard any argument that
    is below the given minimum or above the given maximum, returning a slice containing
    only the arguments that were in the specified range.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0197-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0198-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go program that defines and uses a variadic function is scrambled up on the
    fridge. Can you reconstruct the code snippets to make a working program that will
    produce the given output?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0198-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_4).'
  prefs: []
  type: TYPE_NORMAL
- en: Using a variadic function to calculate averages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a variadic `average` function that can take any number of `float64`
    arguments and return their average. It will look much like the logic from our
    `average2` program. We’ll set up a `sum` variable to hold the total of the argument
    values. Then we’ll loop through the range of arguments, adding each one to the
    value in `sum`. Finally, we’ll divide `sum` by the number of arguments (converted
    to a `float64`) to get the average. The result is a function that can average
    as many (or as few) numbers as we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0198-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing slices to variadic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our new `average` variadic function works so well, we should try updating our
    `average2` program to make use of it. We can paste the `average` function into
    our `average2` code as is.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we’re still going to need to convert each of the command-line
    arguments from a `string` to a `float64` value. We’ll create a slice to hold the
    resulting values, and store it in a variable named `numbers`. After each command-line
    argument is converted, instead of using it to calculate the average directly,
    we’ll just append it to the `numbers` slice.
  prefs: []
  type: TYPE_NORMAL
- en: We then *attempt* to pass the `numbers` slice to the `average` function. But
    when we go to compile the program, that results in an error...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0199-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The `average` function is expecting one or more `float64` arguments, not a *slice*
    of `float64` values...
  prefs: []
  type: TYPE_NORMAL
- en: So what now? Are we forced to choose between making our functions variadic and
    being able to pass slices to them?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Go provides special syntax for this situation. When calling a variadic
    function, simply add an ellipsis (`...`) following the slice you want to use in
    place of variadic arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0200-01.png)'
  prefs: []
  type: TYPE_IMG
- en: So all we need to do is add an ellipsis following the `numbers` slice in our
    call to `average`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0200-02.png)'
  prefs: []
  type: TYPE_IMG
- en: With that change made, we should be able to compile and run our program again.
    It will convert our command-line arguments to a slice of `float64` values, then
    pass that slice to the variadic `average` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0200-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Slices have saved the day!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0201-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with lists of values is essential for any programming language. With
    arrays and slices, you can keep your data in collections of whatever size you
    need. And with features like `for`...`range` loops, Go makes it easy to process
    the data in those collections, too!
  prefs: []
  type: TYPE_NORMAL
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0202-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 6](#appending_issuecolon_slices)! You’ve added slices
    to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0202-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0203-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0204-01.png)'
  prefs: []
  type: TYPE_IMG
