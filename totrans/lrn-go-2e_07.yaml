- en: Chapter 7\. Types, Methods, and Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. 类型、方法和接口
- en: As you saw in earlier chapters, Go is a statically typed language with both
    built-in types and user-defined types. Like most modern languages, Go allows you
    to attach methods to types. It also has type abstraction, allowing you to write
    code that invokes methods without explicitly specifying the implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，Go 是一种静态类型语言，具有内置类型和用户定义类型。像大多数现代语言一样，Go 允许你为类型附加方法。它还具有类型抽象，允许你编写调用方法的代码，而不需显式指定实现方式。
- en: However, Go’s approach to methods, interfaces, and types is very different from
    that of most other languages in common use today. Go is designed to encourage
    the best practices advocated by software engineers, avoiding inheritance while
    encouraging composition. In this chapter, you’ll take a look at types, methods,
    and interfaces, and see how to use them to build testable and maintainable programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Go 对方法、接口和类型的处理方式与今天大多数其他常用语言非常不同。Go 设计旨在鼓励软件工程师提倡的最佳实践，避免继承，而鼓励组合。在本章中，你将了解类型、方法和接口，并看看如何使用它们构建可测试和可维护的程序。
- en: Types in Go
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 中的类型
- en: 'Back in [“Structs”](ch03.html#struct_first_look), you saw how to define a struct
    type:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[“结构体”](ch03.html#struct_first_look)，你看到了如何定义结构体类型：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should be read as declaring a user-defined type with the name `Person`
    to have the *underlying type* of the struct literal that follows. In addition
    to struct literals, you can use any primitive type or compound type literal to
    define a concrete type. Here are a few examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该被理解为声明一个名为 `Person` 的用户定义类型，并具有随后的结构文字的 *基础类型*。除了结构文字，你还可以使用任何原始类型或复合类型文字来定义具体类型。以下是一些例子：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Go allows you to declare a type at any block level, from the package block down.
    However, you can access the type only from within its scope. The only exceptions
    are types exported from other packages. I’ll talk more about those in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你在任何代码块级别声明类型，从包级块到更低级别。然而，你只能在其作用域内访问该类型。唯一的例外是从其他包导出的类型。关于这些，我会在[第10章](ch10.html#unique_chapter_id_10)详细讨论。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To make it easier to talk about types, I’ll define a couple of terms. An *abstract
    type* is one that specifies *what* a type should do but not *how* it is done.
    A *concrete type* specifies what and how. This means that tthe type has a specified
    way to store its data and provides an implementation of any methods declared on
    the type. While all types in Go are either abstract or concrete, some languages
    allow hybrid types, such as abstract classes or interfaces with default methods
    in Java.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易讨论类型，我将定义几个术语。*抽象类型* 是指规定类型应该做什么而不是如何做到的类型。*具体类型* 指定了什么和如何。这意味着类型有指定的存储数据的方法，并提供了在类型上声明的任何方法的实现。虽然Go中的所有类型都是抽象或具体的，但某些语言允许混合类型，如Java中具有默认方法的抽象类或接口。
- en: Methods
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: Like most modern languages, Go supports methods on user-defined types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数现代语言一样，Go 支持用户定义类型的方法。
- en: 'The methods for a type are defined at the package block level:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类型的方法在包级别块中定义：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Method declarations look like function declarations, with one addition: the
    *receiver* specification. The receiver appears between the keyword `func` and
    the name of the method. Like all other variable declarations, the receiver name
    appears before the type. By convention, the receiver name is a short abbreviation
    of the type’s name, usually its first letter. It is nonidiomatic to use `this`
    or `self`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 方法声明看起来像函数声明，但有一个额外的 *接收器* 规范。接收器出现在关键字 `func` 和方法名称之间。像所有其他变量声明一样，接收器名称出现在类型之前。按照惯例，接收器名称通常是类型名称的简短缩写，通常是其首字母。使用
    `this` 或 `self` 是非惯用法的。
- en: 'There is one key difference between declaring methods and functions: methods
    can be defined *only* at the package block level, while functions can be defined
    inside any block.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 声明方法和函数之间有一个关键区别：方法只能在包级别块中定义，而函数可以在任何块中定义。
- en: Just like functions, method names cannot be overloaded. You can use the same
    method names for different types, but you can’t use the same method name for two
    different methods on the same type. While this philosophy feels limiting when
    coming from languages that have method overloading, not reusing names is part
    of Go’s philosophy of making clear what your code is doing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，方法名不能被重载。您可以为不同的类型使用相同的方法名，但不能在同一类型的两个不同方法上使用相同的方法名。尽管从具有方法重载的语言过来时，这种哲学感觉有限制，但不重用名称是
    Go 的一部分，使得代码的作用更加明确。
- en: I’ll talk more about packages in [Chapter 10](ch10.html#unique_chapter_id_10),
    but be aware that methods must be declared in the same package as their associated
    type; Go doesn’t allow you to add methods to types you don’t control. While you
    can define a method in a different file within the same package as the type declaration,
    it is best to keep your type definition and its associated methods together so
    that it’s easy to follow the implementation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 10 章](ch10.html#unique_chapter_id_10)中详细讨论包，但请注意，方法必须在与其关联类型相同的包中声明；Go
    不允许您向不受您控制的类型添加方法。虽然您可以在同一包中类型声明的不同文件中定义方法，但最好将类型定义及其关联的方法放在一起，以便易于理解实现。
- en: 'Method invocations should look familiar to those who have used methods in other
    languages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用对于那些在其他语言中使用方法的人应该看起来很熟悉：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Pointer Receivers and Value Receivers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针接收者和值接收者
- en: 'As I covered in [Chapter 6](ch06.html#unique_chapter_id_06), Go uses parameters
    of pointer type to indicate that a parameter might be modified by the function.
    The same rules apply for method receivers too. They can be *pointer receivers*
    (the type is a pointer) or *value receivers* (the type is a value type). The following
    rules help you determine when to use each kind of receiver:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 6 章](ch06.html#unique_chapter_id_06)中所述，Go 使用指针类型的参数来表示函数可能修改参数。方法接收者也适用相同的规则。它们可以是*指针接收者*（类型是指针）或*值接收者*（类型是值类型）。以下规则帮助您确定何时使用每种类型的接收者：
- en: If your method modifies the receiver, you *must* use a pointer receiver.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的方法修改接收者，您*必须*使用指针接收者。
- en: If your method needs to handle `nil` instances (see [“Code Your Methods for
    nil Instances”](#nil_instances)), then it *must* use a pointer receiver.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的方法需要处理`nil`实例（参见[“为 nil 实例编写方法”](#nil_instances)），那么它*必须*使用指针接收者。
- en: If your method doesn’t modify the receiver, you *can* use a value receiver.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的方法不修改接收者，您*可以*使用值接收者。
- en: Whether you use a value receiver for a method that doesn’t modify the receiver
    depends on the other methods declared on the type. When a type has *any* pointer
    receiver methods, a common practice is to be consistent and use pointer receivers
    for *all* methods, even the ones that don’t modify the receiver.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法没有修改接收者，是否使用值接收者取决于类型声明中的其他方法。当一个类型有*任何*指针接收者方法时，一个常见的做法是保持一致，即使对于*所有*不修改接收者的方法也使用指针接收者。
- en: 'Here’s some simple code to demonstrate pointer and value receivers. It starts
    with a type that has two methods on it, one using a value receiver, the other
    with a pointer receiver:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些简单的代码，演示指针和值接收者。它从一个类型开始，该类型有两个方法，一个使用值接收者，另一个使用指针接收者：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then try out these methods with the following code. You can run it
    yourself on [The Go Playground](https://oreil.ly/aqY0i) or use the code in the
    *sample_code/pointer_value* directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以尝试使用以下代码来测试这些方法。您可以在[Go Playground](https://oreil.ly/aqY0i)上运行它，或者使用[第
    7 章代码库中的*sample_code/pointer_value*目录](https://oreil.ly/qJQgV)中的代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One thing you might notice is that you were able to call the pointer receiver
    method even though `c` is a value type. When you use a pointer receiver with a
    local variable that’s a value type, Go automatically takes the address of the
    local variable when calling the method. In this case, `c.Increment()` is converted
    to `(&c).Increment()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到的一件事是，即使`c`是值类型，您仍然可以调用指针接收者方法。当您在本地变量（值类型）上使用指针接收者时，Go 在调用方法时会自动取本地变量的地址。在这种情况下，`c.Increment()`
    被转换为 `(&c).Increment()`。
- en: 'If you call a value receiver on a pointer variable, Go automatically dereferences
    the pointer when calling the method. In the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在指针变量上调用值接收者，Go 在调用方法时会自动解引用指针。在代码中：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: the call `c.String()` is silently converted to `(*c).String()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `c.String()` 会被悄悄地转换为 `(*c).String()`。
- en: Warning
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you call a value receiver method with pointer instance whose value is `nil`,
    your code will compile but will panic at runtime (I discuss panics in [“panic
    and recover”](ch09.html#panic_recover)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用空指针实例调用值接收器方法，您的代码将编译通过，但在运行时会引发恐慌（我在[“恐慌和恢复”](ch09.html#panic_recover)中讨论了恐慌）。
- en: 'Be aware that the rules for passing values to functions still apply. If you
    pass a value type to a function and call a pointer receiver method on the passed
    value, you are invoking the method on a *copy*. You can try out the following
    code on [The Go Playground](https://oreil.ly/bGdDi) or use the code in the *sample_code/update_wrong*
    directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍然适用将值传递给函数的规则。如果您将值类型传递给函数并在传递的值上调用指针接收器方法，则是在对*副本*调用该方法。您可以在[The Go Playground](https://oreil.ly/bGdDi)上尝试以下代码，或使用[第7章存储库](https://oreil.ly/qJQgV)中的*sample_code/update_wrong*目录中的代码：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you run this code, you’ll get the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，您将得到以下输出：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameter in `doUpdateRight` is of type `*Counter`, which is a pointer instance.
    As you can see, you can call both `Increment` and `String` on it. Go considers
    both pointer and value receiver methods to be in the *method set* for a pointer
    instance. For a value instance, only the value receiver methods are in the method
    set. This seems like a pedantic detail right now, but I’ll come back to it when
    talking about interfaces in just a bit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`doUpdateRight`中的参数类型是`*Counter`，它是一个指针实例。如您所见，您可以在其上同时调用`Increment`和`String`。对于指针实例，Go
    认为指针和值接收器方法都在*方法集*中。对于值实例，只有值接收器方法在方法集中。这看起来现在可能是一个琐碎的细节，但我将在接下来讨论接口时再回到它。'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This can be confusing to new Go programmers (and, to be honest, to not-so-new
    Go programmers), but Go’s automatic conversion from pointer types to value types,
    and vice versa, is purely syntactic sugar. It is independent of the method set
    concept. Alexey Gronskiy has written a [blog post](https://oreil.ly/i7P5_) that
    explores in detail why the method set of pointer instances have both pointer and
    value receiver methods, but the method set of value instances has only value receiver
    methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手 Go 程序员（实际上，即使对于不那么新的 Go 程序员），这可能会有些混淆，但是 Go 对指针类型到值类型以及反之间的自动转换只是一种语法糖。这与方法集概念是独立的。Alexey
    Gronskiy 在[博客文章](https://oreil.ly/i7P5_)中详细探讨了为什么指针实例的方法集包括指针和值接收器方法，但值实例的方法集只包括值接收器方法。
- en: 'One final note: do not write getter and setter methods for Go structs unless
    you need them to meet an interface (I’ll start covering interfaces in [“A Quick
    Lesson on Interfaces”](#interfaces)). Go encourages you to directly access a field.
    Reserve methods for business logic. The exceptions are when you need to update
    multiple fields as a single operation or when the update isn’t a straightforward
    assignment of a new value. The `Increment` method defined earlier demonstrates
    both of these properties.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条注意事项：除非需要满足接口的要求，否则不要为 Go 结构体编写 getter 和 setter 方法（我将在[“接口快速入门课程”](#interfaces)中开始介绍接口）。Go
    鼓励您直接访问字段。保留方法用于业务逻辑。唯一的例外是当您需要将多个字段作为单个操作更新或更新不是简单的新值分配时。之前定义的`Increment`方法展示了这两个属性。
- en: Code Your Methods for nil Instances
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为`nil`实例编写您的方法
- en: The previous section covered pointer receivers, which might make you wonder
    what happens when you call a method on a `nil` instance. In most languages, this
    produces some sort of error. (Objective-C allows you to call a method on a `nil`
    instance, but it always does nothing.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分涵盖了指针接收器，这可能会让您想知道在调用`nil`实例上的方法时会发生什么。在大多数语言中，这会产生某种错误。（Objective-C 允许您在`nil`实例上调用方法，但它总是什么都不做。）
- en: Go does something a little different. It actually tries to invoke the method.
    As mentioned earlier, if it’s a method with a value receiver, you’ll get a panic,
    since there is no value being pointed to by the pointer. If it’s a method with
    a pointer receiver, it can work if the method is written to handle the possibility
    of a `nil` instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有些不同之处。它实际上尝试调用该方法。如前所述，如果它是一个值接收器方法，您将会得到一个恐慌，因为指针没有指向任何值。如果它是一个指针接收器方法，如果该方法编写得能够处理`nil`实例的可能性，它就能正常工作。
- en: 'In some cases, expecting a `nil` receiver makes the code simpler. Here’s an
    implementation of a binary tree that takes advantage of `nil` values for the receiver:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，期望一个`nil`接收器可以使代码更简单。这里有一个利用`nil`接收器值的二叉树实现：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `Contains` method doesn’t modify the `*IntTree`, but it is declared with
    a pointer receiver. This demonstrates the rule mentioned previously about supporting
    a `nil` receiver. A method with a value receiver can’t check for `nil` and, as
    mentioned earlier, panics if invoked with a `nil` receiver.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contains` 方法不修改`*IntTree`，但是它是用指针接收器声明的。这展示了之前提到的关于支持`nil`接收器的规则。具有值接收器的方法不能检查`nil`，并且如前所述，如果使用`nil`接收器调用，它会引发恐慌。'
- en: 'The following code uses the tree. You can try it out on [The Go Playground](https://oreil.ly/-F2i-)
    or use the code in the *sample_code/tree* directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用了这棵树。你可以在[Go Playground](https://oreil.ly/-F2i-)上试一下，或者使用[第 7 章代码库](https://oreil.ly/qJQgV)中的*sample_code/tree*目录中的代码：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s very clever that Go allows you to call a method on a `nil` receiver, and
    there are situations where it is useful, like the previous tree node example.
    However, most of the time it’s not very useful. Pointer receivers work like pointer
    function parameters; it’s a copy of the pointer that’s passed into the method.
    Just like `nil` parameters passed to functions, if you change the copy of the
    pointer, you haven’t changed the original. This means you can’t write a pointer
    receiver method that handles `nil` and makes the original pointer non-nil.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你在`nil`接收器上调用方法非常聪明，而且在像前面的树节点示例中这样的情况下非常有用。然而，大多数情况下它并不是很有用。指针接收器的工作原理与指针函数参数相似；传递给方法的是指针的副本。就像将`nil`参数传递给函数一样，如果更改指针的副本，则并未更改原始指针。这意味着你不能编写一个处理`nil`并使原始指针非`nil`的指针接收器方法。
- en: If your method has a pointer receiver and won’t work for a `nil` receiver, you
    have to decide how your method should handle a `nil` receiver. One choice is to
    treat it as a fatal flaw, like trying to access a position in a slice beyond its
    length. In that case, don’t do anything and let the code panic. (Also make sure
    you write good tests, as discussed in [Chapter 15](ch15.html#unique_chapter_id_15).)
    If a `nil` receiver is something that is recoverable, check for `nil` and return
    an error (I discuss errors in [Chapter 9](ch09.html#unique_chapter_id_09)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方法有一个指针接收器，并且对于`nil`接收器不起作用，你必须决定你的方法应该如何处理`nil`接收器。一种选择是将其视为致命缺陷，就像尝试访问切片超出其长度的位置一样。在这种情况下，什么都不做，让代码发生恐慌。（同时确保编写良好的测试，如[第 15 章](ch15.html#unique_chapter_id_15)中所讨论的。）如果`nil`接收器是可恢复的内容，检查`nil`并返回一个错误（我在[第 9 章](ch09.html#unique_chapter_id_09)中讨论错误）。
- en: Methods Are Functions Too
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也是函数
- en: Methods in Go are so much like functions that you can use a method as a replacement
    for a function anytime there’s a variable or parameter of a function type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的方法与函数非常相似，你可以在任何需要函数类型的变量或参数的地方使用方法作为函数的替代品。
- en: 'Let’s start with this simple type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个简单类型开始：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You create an instance of the type in the usual way and invoke its method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以通常的方式创建类型的实例并调用其方法：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also assign the method to a variable or pass it to a parameter of type
    `func(int)int`. This is called a *method value*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将方法分配给变量或将其传递给`func(int)int`类型的参数。这称为*方法值*：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A method value is a bit like a closure, since it can access the values in the
    fields of the instance from which it was created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法值有点像闭包，因为它可以访问创建它的实例字段中的值。
- en: 'You can also create a function from the type itself. This is called a *method
    expression*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从类型本身创建一个函数。这称为*方法表达式*：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a method expression, the first parameter is the receiver for the method;
    the function signature is `func(Adder, int) int`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法表达式中，第一个参数是方法的接收器；函数签名是`func(Adder, int) int`。
- en: Method values and method expressions aren’t clever corner cases. You’ll see
    one way to use them when you look at dependency injection in [“Implicit Interfaces
    Make Dependency Injection Easier”](#dependency_injection).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 方法值和方法表达式并不是什么聪明的边界情况。当你查看[“隐式接口使依赖注入更容易”](#dependency_injection)时，你会看到如何使用它们之一。
- en: Functions Versus Methods
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数与方法
- en: Since you can use a method as a function, you might wonder when you should declare
    a function and when you should use a method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以将方法用作函数，你可能会想知道何时应该声明函数，何时应该使用方法。
- en: The differentiator is whether your function depends on other data. As I’ve covered
    several times, package-level state should be effectively immutable. Anytime your
    logic depends on values that are configured at startup or changed while your program
    is running, those values should be stored in a struct, and that logic should be
    implemented as a method. If your logic depends only on the input parameters, it
    should be a function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 区分因素是您的函数是否依赖于其他数据。正如我多次提到的那样，包级别的状态应该是有效不可变的。每当您的逻辑依赖于在启动时配置或在程序运行时更改的值时，这些值应存储在一个结构体中，并且该逻辑应作为方法实现。如果您的逻辑仅依赖于输入参数，则应该是一个函数。
- en: Type Declarations Aren’t Inheritance
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型声明不等同于继承
- en: 'In addition to declaring types based on built-in Go types and struct literals,
    you can also declare a user-defined type based on another user-defined type:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于内置Go类型和结构字面量声明类型之外，您还可以基于其他用户定义的类型声明用户定义的类型：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Many concepts can be considered “object-oriented,” but one stands out: *inheritance*.
    With inheritance, the state and methods of a *parent* type are declared to be
    available on a *child* type, and values of the child type can be substituted for
    the parent type.^([1](ch07.html#id1628))'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 许多概念都可以被视为“面向对象的”，但一个概念尤为突出：*继承*。通过继承，声明了父类型的状态和方法可以在子类型上使用，并且子类型的值可以替代父类型的值^([1](ch07.html#id1628))。
- en: 'Declaring a type based on another type looks a bit like inheritance but isn’t.
    The two types have the same underlying type, but that’s all. The types have no
    hierarchy. In languages with inheritance, a child instance can be used anywhere
    the parent instance is used. The child instance also has all the methods and 
    data  structures of  the  parent  instance.  That’s  not  the  case  in  Go. 
    You  can’t assign  an  instance  of  type  `HighScore` to  a  variable  of  type 
    `Score`, or  vice  versa,  without  a type conversion, nor can you assign either
    of them to a variable of type `int` without a type conversion. Furthermore, any
    methods defined on `Score` aren’t defined on `HighScore`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个基于另一种类型的类型看起来有点像继承，但实际上并不是。这两种类型具有相同的基础类型，但仅此而已。这些类型之间没有层次结构。在具有继承的语言中，子实例可以在任何父实例可以使用的地方使用。子实例还具有父实例的所有方法和数据结构。但在Go语言中并非如此。你不能将`HighScore`类型的实例赋给`Score`类型的变量，反之亦然，除非进行类型转换。也不能将它们中的任何一个分配给`int`类型的变量而不进行类型转换。此外，在`Score`上定义的任何方法在`HighScore`上也不存在：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'User-defined types whose underlying types are built-in types can be assigned
    literals and constants compatible with the underlying type. They can also be used
    with the operators for those types:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 具有内置类型作为其基础类型的用户定义类型可以分配与基础类型兼容的字面量和常量。它们也可以与这些类型的运算符一起使用：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A type conversion between types that share an underlying type keeps the same
    underlying storage but associates different methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有共享基础类型的类型之间进行类型转换会保持相同的基础存储，但关联不同的方法。
- en: Types Are Executable Documentation
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型是可执行文档
- en: While it’s well understood that you should declare a struct type to hold a set
    of related data, it’s less clear when you should declare a user-defined type based
    on other built-in types or one user-defined type that’s based on another user-defined
    type. The short answer is that types are documentation. They make code clearer
    by providing a name for a concept and describing the kind of data that is expected.
    It’s clearer for someone reading your code when a method has a parameter of type
    `Percentage` than of type `int`, and it’s harder for it to be invoked with an
    invalid value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们深知应该声明一个结构体类型来保存一组相关数据，但当您应该声明一个基于其他内置类型或基于另一个用户定义类型的用户定义类型时，这一点并不十分清晰。简短的答案是，类型是文档。它们通过为概念提供名称并描述预期数据的类型，使代码更加清晰。对于阅读您代码的人来说，当一个方法有一个`Percentage`类型的参数时，比有一个`int`类型的参数更加清晰，而且更难以使用无效值调用它。
- en: The same logic applies when declaring one user-defined type based on another
    user-defined type. When you have the same underlying data, but different sets
    of operations to perform, make two types. Declaring one as being based on the
    other avoids some repetition and makes it clear that the two types are related.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个用户定义的类型基于另一个用户定义的类型时，相同的逻辑也适用。当您拥有相同的基础数据但需要执行不同操作集时，请创建两种类型。声明一种类型基于另一种类型可以避免一些重复，并清楚地表明这两种类型是相关的。
- en: iota Is for Enumerations—Sometimes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`iota`用于枚举——有时'
- en: Many programming languages have the concept of enumerations, which allow you
    to specify that a type can have only a limited set of values. Go doesn’t have
    an enumeration type. Instead, it has `iota`, which lets you assign an increasing
    value to a set of constants.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言都有枚举的概念，允许你指定类型只能有限的几个值。Go语言没有枚举类型，而是使用 `iota`，它允许你为一组常量赋予递增的值。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of `iota` comes from the programming language APL (which stood for
    “A Programming Language”). To generate a list of the first three positive integers
    in APL, you write `ι3`, where `ι` is the lowercase Greek letter iota.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota` 的概念源自编程语言APL（全称“A Programming Language”）。在APL中，要生成前三个正整数的列表，你可以写作 `ι3`，其中
    `ι` 是小写希腊字母iota。'
- en: APL is famous for being so reliant on its own custom notation that it required
    computers with a special keyboard. For example, (~R∊R∘.×R)/R←1↓ιR is an APL program
    to find all the prime numbers up to the value of the variable R.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: APL因其高度依赖自定义符号而闻名，以至于需要配备特殊键盘的计算机。例如，(~R∊R∘.×R)/R←1↓ιR 是一个APL程序，用于找出小于变量R值的所有质数。
- en: 'It may seem ironic that a language as focused on readability as Go would borrow
    a concept from a language that is concise to a fault, but this is why you should
    learn multiple programming languages: you can find inspiration everywhere.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言强调可读性，却从另一种以简洁著称的语言借鉴概念，这或许有些讽刺，但这也是为什么你应该学习多种编程语言：你可以从任何地方获得灵感。
- en: 'When using `iota`, the best practice is to first define a type based on `int`
    that will represent all the valid values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `iota` 时，最佳实践是首先定义一个基于 `int` 的类型，该类型将表示所有有效值：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, use a `const` block to define a set of values for your type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `const` 块为你的类型定义一组值：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first constant in the `const` block has the type specified, and its value
    is set to `iota`. Every subsequent line has neither the type nor a value assigned
    to it. When the Go compiler sees this, it repeats the type and the assignment
    to all the subsequent constants in the block, which is `iota`. The value of `iota`
    increments for each constant defined in the `const` block, starting with `0`.
    This means that `0` is assigned to the first constant (`Uncategorized`), 1 to
    the second constant (`Personal`), and so on. When a new `const` block is created,
    `iota` is set back to 0.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `const` 块中，第一个常量的类型已经指定，并且其值设置为 `iota`。随后的每一行既没有指定类型也没有指定值。当Go编译器看到这种写法时，会将类型和赋值重复到块中的所有后续常量，这就是
    `iota` 的作用。`iota` 的值递增，从 `0` 开始为第一个常量（`Uncategorized`），第二个常量为 `1`（`Personal`），依此类推。当创建新的
    `const` 块时，`iota` 会被重置为 `0`。
- en: 'The value of `iota` increments for each constant in the `const` block, whether
    or not `iota` is used to define the value of a constant. The following code demonstrates
    what happens when `iota` is used intermittently in a `const` block:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota` 的值递增，每个常量在 `const` 块中，无论是否使用 `iota` 来定义常量的值。以下代码演示了在 `const` 块中间歇性使用
    `iota` 时会发生什么：'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can run this code on [The Go Playground](https://oreil.ly/jTXxD) and see
    the (perhaps unexpected) result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[The Go Playground](https://oreil.ly/jTXxD)上运行此代码，并查看（也许是意外的）结果：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Field2` is assigned `2` because `iota` has a value of `1` on the second line
    in the `const` block. `Field4` is assigned `20` because it has no type or value
    explicitly assigned, so it gets the value of the previous line with a type and
    assignment. Finally, `Field5` gets the value `4` because it is the fifth line
    and `iota` starts counting from `0`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Field2` 被赋值为 `2`，因为在 `const` 块的第二行中，`iota` 的值为 `1`。`Field4` 被赋值为 `20`，因为它没有显式指定类型或值，所以它获取了前一行的具有类型和赋值的值。最后，`Field5`
    获取值 `4`，因为它是第五行，而 `iota` 从 `0` 开始计数。'
- en: 'This is the best advice I’ve seen on `iota`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我见过的关于 `iota` 的最佳建议：
- en: Don’t use *iota* for defining constants where its values are explicitly defined
    (elsewhere). For example, when implementing parts of a specification and the specification
    says which values are assigned to which constants, you should explicitly write
    the constant values. Use *iota* for “internal” purposes only. That is, where the
    constants are referred to by name rather than by value. That way, you can optimally
    enjoy *iota* by inserting new constants at any moment in time / location in the
    list without the risk of breaking everything.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要将*iota*用于定义其值在其他地方明确定义的常量。例如，在实施规范的部分和规范指定分配给哪些常量的值时，应明确写出常量值。仅在“内部”目的中使用*iota*。也就是说，通过名称引用而不是通过值引用常量。这样，您可以在任何时刻/列表中的位置上最优地使用*iota*插入新常量，而不会造成破坏。
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Danny van Heumen](https://oreil.ly/3MKwn)'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[丹尼·范·休曼](https://oreil.ly/3MKwn)'
- en: The important thing to understand is that nothing in Go will stop you (or anyone
    else) from creating additional values of your type. Furthermore, if you insert
    a new identifier in the middle of your list of literals, all subsequent ones will
    be renumbered. This will break your application in a subtle way if those constants
    represented values in another system or in a database. Given these two limitations,
    `iota`-based enumerations make sense only when you care about being able to differentiate
    between a set of values and don’t particularly care what the value is behind the
    scenes. If the actual value matters, specify it explicitly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，Go 中没有任何东西会阻止您（或其他任何人）创建您类型的其他值。此外，如果在字面常量列表中间插入一个新标识符，则所有后续标识符将重新编号。如果这些常量表示另一个系统或数据库中的值，则会以微妙的方式破坏您的应用程序。鉴于这两个限制条件，基于
    `iota` 的枚举仅在您关心能够区分一组值并且不特别关心背后的值时才有意义。如果实际值很重要，请明确指定它。
- en: Warning
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Because you can assign a literal expression to a constant, you’ll see sample
    code that suggests you should use `iota` for cases like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您可以将字面表达式分配给常量，所以您会看到示例代码建议在此类情况下使用 `iota`：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While this is clever, be careful when using this pattern. If you do so, document
    what you are doing. As mentioned previously, using `iota` with constants is fragile
    when you care about the value. You don’t want a future maintainer to insert a
    new constant in the middle of the list and break your code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很聪明，但在使用此模式时要小心。如果这样做，请记录您所做的事情。如前所述，当您关心值时，使用 `iota` 与常量是脆弱的。您不希望未来的维护者在列表中间插入新常量并破坏您的代码。
- en: Be aware that `iota` starts numbering from 0\. If you are using your set of
    constants to represent different configuration states, the zero value might be
    useful. You saw this earlier in the `MailCategory` type. When mail first arrives,
    it is uncategorized, so the zero value makes sense. If there isn’t a sensical
    default value for your constants, a common pattern is to assign the first `iota`
    value in the constant block to `_` or to a constant that indicates the value is
    invalid. This makes it easy to detect when a variable has not been properly initialized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`iota` 从 0 开始编号。如果您使用自己的常量集表示不同的配置状态，则零值可能会有用。您在 `MailCategory` 类型中之前看到过这一点。当邮件首次到达时，它是未分类的，因此零值是合理的。如果您的常量没有合理的默认值，一个常见的模式是将常量块中的第一个
    `iota` 值分配给 `_` 或指示该值无效的常量。这样可以轻松检测变量是否已正确初始化。
- en: Use Embedding for Composition
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌入进行组合
- en: 'The software engineering advice “Favor object composition over class inheritance”
    dates back to at least the 1994 book *Design Patterns* by Erich Gamma, Richard
    Helm, Ralph Johnson, and John Vlissides (Addison-Wesley), better known as the
    Gang of Four book. While Go doesn’t have inheritance, it encourages code reuse
    via built-in support for composition and promotion:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程建议“优先使用对象组合而不是类继承”可以追溯到至少 1994 年出版的 *设计模式* 一书（Erich Gamma、Richard Helm、Ralph
    Johnson 和 John Vlissides，Addison-Wesley），更为人所知的是四人帮书籍。虽然 Go 没有继承，但通过内置支持组合和提升来鼓励代码重用：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that `Manager` contains a field of type `Employee`, but no name is assigned
    to that field. This makes `Employee` an *embedded field*. Any fields or methods
    declared on an embedded field are *promoted* to the containing struct and can
    be invoked directly on it. That makes the following code valid:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Manager` 包含一个类型为 `Employee` 的字段，但未为该字段分配名称。这使 `Employee` 成为一个*嵌入字段*。在嵌入字段上声明的任何字段或方法都会*提升*到包含的结构体中，并且可以直接在其上调用。这使得以下代码有效：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can embed any type within a struct, not just another struct. This promotes
    the methods on the embedded type to the containing struct.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌入结构中的任何类型，不仅仅是另一个结构。这样可以将嵌入类型的方法提升到包含它的结构体中。
- en: 'If the containing struct has fields or methods with the same name as an embedded
    field, you need to use the embedded field’s type to refer to the obscured fields
    or methods. If you have types defined like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含的结构体具有与嵌入字段相同名称的字段或方法，则需要使用嵌入字段的类型来引用被隐藏的字段或方法。如果你定义的类型如下：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'you can access the `X` on `Inner` only by specifying `Inner` explicitly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 只能通过显式指定`Inner`来访问`Inner`上的`X`：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Embedding Is Not Inheritance
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入不是继承
- en: 'Built-in embedding support is rare in programming languages (I’m not aware
    of another popular language that supports it). Many developers who are familiar
    with inheritance (which is available in many languages) try to understand embedding
    by treating it as inheritance. That way lies tears. You cannot assign a variable
    of type `Manager` to a variable of type `Employee`. If you want to access the
    `Employee` field in `Manager`, you must do so explicitly. You can run the following
    code on [The Go Playground](https://oreil.ly/vBl7o) or use the code in the *sample_code/embedding*
    directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中内置的嵌入支持很少见（我不知道其他流行语言支持它）。许多熟悉继承（在许多语言中都有）的开发人员尝试将嵌入视为继承来理解。这条路不通。你不能将`Manager`类型的变量赋给`Employee`类型的变量。如果你想访问`Manager`中的`Employee`字段，必须显式地这样做。你可以在[Go
    Playground](https://oreil.ly/vBl7o)上运行以下代码或者使用[第7章仓库](https://oreil.ly/qJQgV)中的*sample_code/embedding*目录中的代码：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You’ll get the error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会得到错误：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Furthermore, Go has no *dynamic dispatch* for concrete types. The methods on
    the embedded field have no idea they are embedded. If you have a method on an
    embedded field that calls another method on the embedded field, and the containing
    struct has a method of the same name, the method on the embedded field is invoked,
    not the method on the containing struct. This behavior is demonstrated in the
    following code, which you can run on [The Go Playground](https://oreil.ly/yN6bV),
    or use the code in the *sample_code/no_dispatch* directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Go没有具体类型的*动态分派*。嵌入字段上的方法并不知道它们被嵌入了。如果在嵌入字段上有一个方法调用另一个嵌入字段上的方法，并且包含结构体具有同名方法，则会调用嵌入字段上的方法，而不是包含结构体上的方法。此行为在以下代码中得到了演示，你可以在[Go
    Playground](https://oreil.ly/yN6bV)上运行它，或者使用[第7章仓库](https://oreil.ly/qJQgV)中的*sample_code/no_dispatch*目录中的代码：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running this code produces the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While embedding one concrete type inside another won’t allow you to treat the
    outer type as the inner type, the methods on an embedded field do count toward
    the *method set* of the containing struct. This means they can make the containing
    struct implement an interface.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在一个具体类型内嵌另一个类型不允许你将外部类型视为内部类型，但嵌入字段的方法确实计入包含结构体的*方法集*。这意味着它们可以使包含的结构体实现一个接口。
- en: A Quick Lesson on Interfaces
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口的快速课程
- en: While Go’s concurrency model (which I cover in [Chapter 12](ch12.html#unique_chapter_id_12))
    gets all the publicity, the real star of Go’s design is its implicit interfaces,
    the only abstract type in Go. Let’s see what makes them so great.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go的并发模型（我在[第12章](ch12.html#unique_chapter_id_12)中介绍）备受瞩目，但Go设计的真正亮点是它的隐式接口，这是Go中唯一的抽象类型。让我们看看它们为何如此出色。
- en: Let’s start by taking a quick look at how to declare interfaces. At their core,
    interfaces are simple. Like other user-defined types, you use the `type` keyword.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速看一下如何声明接口。接口在本质上很简单。像其他用户定义的类型一样，你使用`type`关键字。
- en: 'Here’s the definition of the `Stringer` interface in the `fmt` package:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fmt`包中`Stringer`接口的定义：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In an interface declaration, an interface literal appears after the name of
    the interface type. It lists the methods that must be implemented by a concrete
    type to meet the interface. The methods defined by an interface are the method
    set of the interface. As I covered in [“Pointer Receivers and Value Receivers”](#pointer_value_receivers),
    the method set of a pointer instance contains the methods defined with both pointer
    and value receivers, while the method set of a value instance contains only the
    methods with value receivers. Here’s a quick example using the `Counter` struct
    defined previously:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口声明中，接口文字出现在接口类型名称之后。它列出了具体类型必须实现的方法，以符合接口的要求。接口定义的方法称为接口的方法集。正如我在[“指针接收器和值接收器”](#pointer_value_receivers)中所述，指针实例的方法集包含使用指针接收器和值接收器定义的方法，而值实例的方法集仅包含使用值接收器定义的方法。以下是使用先前定义的`Counter`结构的快速示例：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Trying to compile this code results in the error `cannot use valueCounter (variable
    of type Counter) as Incrementer value in assignment: Counter does not implement
    Incrementer (method Increment has pointer receiver).`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试编译这段代码会导致错误`cannot use valueCounter (variable of type Counter) as Incrementer
    value in assignment: Counter does not implement Incrementer (method Increment
    has pointer receiver).`'
- en: You can try this code on [The Go Playground](https://oreil.ly/yYx8Q) or use
    the code in the *sample_code/method_set* directory in the [Chapter 7 repository](https://oreil.ly/qJQgV).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[The Go Playground](https://oreil.ly/yYx8Q)上尝试这段代码，或者使用[第7章代码库](https://oreil.ly/qJQgV)中*sample_code/method_set*目录中的代码。
- en: Like other types, interfaces can be declared in any block.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，接口可以在任何块中声明。
- en: Interfaces are usually named with “er” endings. You’ve already seen `fmt.Stringer`,
    but there are many more, including `io.Reader`, `io.Closer`, `io.ReadCloser`,
    `json.Marshaler`, and `http.Handler`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接口通常以“er”结尾命名。你已经见过`fmt.Stringer`，但还有很多，包括`io.Reader`、`io.Closer`、`io.ReadCloser`、`json.Marshaler`和`http.Handler`。
- en: Interfaces Are Type-Safe Duck Typing
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口是类型安全的鸭子类型
- en: So far, nothing that’s been said about the Go interface is much different from
    interfaces in other languages. What makes Go’s interfaces special is that they
    are implemented *implicitly*. As you’ve seen with the `Counter` struct type and
    the `Incrementer` interface type that you’ve used in previous examples, a concrete
    type does not declare that it implements an interface. If the method set for a
    concrete type contains all the methods in the method set for an interface, the
    concrete type implements the interface. Therefore, that the concrete type can
    be assigned to a variable or field declared to be of the type of the interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于Go语言接口的讨论并没有什么不同于其他语言的接口。使Go语言接口特殊的是它们是*隐式*实现的。正如你在前面示例中使用的`Counter`结构类型和`Incrementer`接口类型所看到的那样，具体类型不声明它实现了一个接口。如果具体类型的方法集包含接口方法集中的所有方法，则具体类型实现了该接口。因此，具体类型可以赋给声明为接口类型的变量或字段。
- en: This implicit behavior makes interfaces the most interesting thing about types
    in Go, because they enable both type safety and decoupling, bridging the functionality
    in both static and dynamic languages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐式行为使接口成为Go语言中最有趣的类型特性，因为它们既实现了类型安全又实现了解耦，将静态语言和动态语言的功能桥接起来。
- en: To understand why, let’s talk about why languages have interfaces. Earlier I
    mentioned that *Design Patterns* taught developers to favor composition over inheritance.
    Another piece of advice from the book is “Program to an interface, not an implementation.”
    Doing so allows you to depend on behavior, not on implementation, allowing you
    to swap implementations as needed. This allows your code to evolve over time,
    as requirements inevitably change.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解其中的原因，让我们讨论一下为什么语言需要接口。前面我提到过*设计模式*教导开发者更倾向于组合而非继承。书中的另一个建议是“针对接口编程，而不是针对实现编程”。这样做允许你依赖行为而不是实现，使你能够根据需要交换实现。这使得你的代码能够随着需求的变化而演变。
- en: 'Dynamically typed languages like Python, Ruby, and JavaScript don’t have interfaces.
    Instead, those developers use *duck typing*, which is based on the expression
    “If it walks like a duck and quacks like a duck, it’s a duck.” The concept is
    that you can pass an instance of a type as a parameter to a function as long as
    the function can find a method to invoke that it expects:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python、Ruby和JavaScript等动态类型语言没有接口。相反，这些开发者使用*鸭子类型*，其基于“如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子”的表达。该概念是，只要函数能够找到预期的方法来调用，你就可以将类型的实例作为参数传递给函数：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Duck typing might sound weird at first, but it’s been used to build large and
    successful systems. If you program in a statically typed language, this sounds
    like utter chaos. Without an explicit type being specified, it’s hard to know
    exactly what functionality should be expected. As new developers move on to a
    project or the existing developers forget what the code is doing, they have to
    trace through the code to identify the actual dependencies.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型起初可能听起来很奇怪，但它已被用于构建大型且成功的系统。如果你在静态类型语言中编程，这听起来像彻头彻尾的混乱。在没有明确指定类型的情况下，很难知道应该期望什么功能。当新开发人员加入项目或现有开发人员忘记代码的作用时，他们必须跟踪代码以确定实际的依赖关系。
- en: 'Java developers use a different pattern. They define an interface, create an
    implementation of the interface, but refer to the interface only in the client
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发人员使用不同的模式。他们定义一个接口，创建接口的实现，但仅在客户端代码中引用接口：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Dynamic language developers look at the explicit interfaces in Java and don’t
    see how you can possibly refactor your code over time when you have explicit dependencies.
    Switching to a new implementation from a different provider means rewriting your
    code to depend on a new interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 动态语言开发人员看到 Java 中的显式接口，不明白在有显式依赖关系的情况下如何随时间重构代码。从不同提供者切换到新实现意味着重写代码以依赖新接口。
- en: 'Go’s developers decided that both groups are right. If your application is
    going to grow and change over time, you need flexibility to change implementation.
    However, in order for people to understand what your code is doing (as new people
    work on the same code over time), you also need to specify what the code depends
    on. That’s where implicit interfaces come in. Go code is a blend of the previous
    two styles:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的开发人员认为两种方法都是正确的。如果你的应用程序会随时间增长和变化，你需要灵活性来改变实现。然而，为了让人们理解你的代码在做什么（随着时间的推移，新的人员在同一代码上工作时），你还需要指定代码依赖的内容。这就是隐式接口的用武之地。Go
    代码是前两种风格的混合：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Go code provides an interface, but only the caller (`Client`) knows about
    it; nothing is declared on `LogicProvider` to indicate that it meets the interface.
    This is sufficient to both allow a new logic provider in the future and provide
    executable documentation to ensure that any type passed into the client will match
    the client’s need.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Go 代码提供了一个接口，但只有调用者（`Client`）知道它；在`LogicProvider`上没有声明任何内容来表明它符合接口。这足以允许将来引入新的逻辑提供者，并提供可执行的文档以确保传递给客户端的任何类型都与客户端的需求匹配。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: Interfaces specify what callers need. The client code defines the interface
    to specify what functionality it requires.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接口指定调用者需要什么。客户端代码定义接口以指定它需要哪些功能。
- en: This doesn’t mean that interfaces can’t be shared. You’ve already seen several
    interfaces in the standard library that are used for input and output. Having
    a standard interface is powerful; if you write your code to work with `io.Reader`
    and `io.Writer`, it will function correctly whether it is writing to a file on
    local disk or a value in memory.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着接口不能共享。你已经在标准库中看到了几个用于输入和输出的接口。拥有标准接口是强大的；如果你的代码编写为与`io.Reader`和`io.Writer`一起工作，它将正确地运行，无论是写入本地磁盘上的文件还是内存中的值。
- en: 'Furthermore, using standard interfaces encourages the *decorator pattern*.
    It is common in Go to write factory functions that take in an instance of an interface
    and return another type that implements the same interface. For example, say you
    have a function with the following definition:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用标准接口鼓励*装饰器模式*。在 Go 中编写工厂函数的常见做法是，接受一个接口实例并返回实现相同接口的另一种类型。例如，假设你有以下定义的函数：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can process data from a file with the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下代码处理来自文件的数据：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `os.File` instance returned by `os.Open` meets the `io.Reader` interface
    and can be used in any code that reads in data. If the file is gzip-compressed,
    you can wrap the `io.Reader` in another `io.Reader`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `os.Open` 返回的 `os.File` 实例符合 `io.Reader` 接口，并可以在任何读取数据的代码中使用。如果文件是 gzip 压缩的，你可以将
    `io.Reader` 包装在另一个 `io.Reader` 中：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now the exact same code that was reading from an uncompressed file is reading
    from a compressed file instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从未压缩文件读取的完全相同的代码改为从压缩文件读取。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: If an interface in the standard library describes what your code needs, use
    it! Commonly used interfaces include `io.Reader`, `io.Writer`, and `io.Closer`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准库中的接口描述了你的代码所需的功能，请使用它！常用的接口包括`io.Reader`、`io.Writer`和`io.Closer`。
- en: It’s perfectly fine for a type that meets an interface to specify additional
    methods that aren’t part of the interface. One set of client code may not care
    about those methods, but others do. For example, the `io.File` type also meets
    the `io.Writer` interface. If your code cares only about reading from a file,
    use the `io.Reader` interface to refer to the file instance and ignore the other
    methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于满足接口的类型而言，指定附加方法并不是不合适的做法。一组客户端代码可能不关心这些方法，但其他人可能关心。例如，`io.File` 类型也满足 `io.Writer`
    接口。如果你的代码只关心从文件中读取数据，可以使用 `io.Reader` 接口来引用文件实例，并忽略其他方法。
- en: Embedding and Interfaces
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入和接口
- en: 'Embedding is not only for structs. You can also embed an interface in an interface.
    For example, the `io.ReadCloser` interface is built out of an `io.Reader` and
    an `io.Closer`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不仅适用于结构体。你还可以在接口中嵌入接口。例如，`io.ReadCloser` 接口由 `io.Reader` 和 `io.Closer` 组成：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just as you can embed a concrete type in a struct, you can also embed an interface
    in a struct. You’ll see a use for this in [“Using Stubs in Go”](ch15.html#test_stubs).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在结构体中嵌入具体类型一样，你也可以在结构体中嵌入接口。你会在[“在Go中使用存根”](ch15.html#test_stubs)中看到这种用法。
- en: Accept Interfaces, Return Structs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受接口，返回结构体
- en: 'You’ll often hear experienced Go developers say that your code should “Accept
    interfaces, return structs.” This phrase was most likely coined by Jack Lindamood
    in his 2016 blog post [“Preemptive Interface Anti-Pattern in Go”](https://oreil.ly/OT1yi).
    It means that the business logic invoked by your functions should be invoked via
    interfaces, but the output of your functions should be a concrete type. I’ve already
    covered why functions should accept interfaces: they make your code more flexible
    and explicitly declare the exact functionality being used.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会听到经验丰富的Go开发者说，你的代码应该“接受接口，返回结构体”。这句话很可能是由Jack Lindamood在他2016年的博客文章[“Go中的预防性接口反模式”](https://oreil.ly/OT1yi)中首次提出的。这意味着由你的函数调用的业务逻辑应通过接口调用，但你函数的输出应为具体类型。我已经解释了为什么函数应接受接口：它们使你的代码更灵活，并明确声明正在使用的确切功能。
- en: The primary reason your functions should return concrete types is they make
    it easier to gradually update a function’s return values in new versions of your
    code. When a concrete type is returned by a function, new methods and fields can
    be added without breaking existing code that calls the function, because the new
    fields and methods are ignored. The same is not true for an interface. Adding
    a new method to an interface means that all existing implementations of that interface
    must be updated, or your code breaks. In semantic versioning terms, this is the
    difference between a minor release that is backward compatible and a major release,
    which is backward breaking. If you are exposing an API that’s consumed by other
    people (either inside your organization or as part of an open source project),
    avoiding backward-breaking changes keeps your users happy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应返回具体类型的主要原因是它们使得在代码的新版本中逐步更新函数的返回值变得更容易。当函数返回一个具体类型时，可以添加新方法和字段而不会破坏调用该函数的现有代码，因为新字段和方法会被忽略。但对于接口来说并非如此。向接口添加新方法意味着必须更新该接口的所有现有实现，否则你的代码就会出现问题。从语义化版本的角度来看，这是后向兼容的次要发布和后向不兼容的主要发布之间的区别。如果你正在暴露一个API供其他人使用（无论是在你的组织内部还是作为开源项目的一部分），避免破坏向后兼容的变更会让你的用户满意。
- en: In some rare situations, the least bad option is to have your functions return
    interfaces. For example, the `database/sql/driver` package in the standard library
    defines a set of interfaces that define what a database driver must provide. It
    is the responsibility of the database driver author to provide concrete implementations
    of these interfaces, so almost all methods on all interfaces defined in `database/sql/driver`
    return interfaces. Starting in Go 1.8, database drivers are expected to support
    additional features. The standard library has a compatibility promise, so the
    existing interfaces can’t be updated with new methods, and the existing methods
    on these interfaces can’t be updated to return different types. The solution is
    to leave the existing interfaces alone, define new interfaces that describe the
    new functionality, and tell database driver authors that they should implement
    both the old and new methods on their concrete types.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见情况下，最不坏的选择是使你的函数返回接口。例如，标准库中的`database/sql/driver`包定义了一组接口，定义了数据库驱动程序必须提供的内容。数据库驱动程序的作者有责任提供这些接口的具体实现，因此标准库中`database/sql/driver`定义的所有接口上的几乎所有方法都返回接口。从Go
    1.8开始，期望数据库驱动程序支持额外的功能。标准库承诺兼容性，因此不能更新现有接口以添加新方法，也不能更新这些接口上的现有方法以返回不同类型。解决方案是保持现有接口不变，定义描述新功能的新接口，并告诉数据库驱动程序作者他们应该在其具体类型上实现旧方法和新方法。
- en: This leads to the question of how to check whether these new methods are present
    and how to access them if they are. You’ll learn how in [“Type Assertions and
    Type Switches”](#type_assert).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题，即如何检查这些新方法是否存在，以及如果存在如何访问它们。你将在[“类型断言和类型开关”](#type_assert)中学习如何做到这一点。
- en: Rather than writing a single factory function that returns different instances
    behind an interface based on input parameters, try to write separate factory functions
    for each concrete type. In some situations (such as a parser that can return one
    or more kinds of tokens), it’s unavoidable and you have no choice but to return
    an interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写一个返回基于输入参数返回不同实例的接口的单个工厂函数，试着为每种具体类型编写单独的工厂函数。在某些情况下（例如可以返回一种或多种类型令牌的解析器），这是不可避免的，你别无选择，只能返回一个接口。
- en: Errors are an exception to this rule. As you’ll see in [Chapter 9](ch09.html#unique_chapter_id_09),
    Go functions and methods can declare a return parameter of the `error` interface
    type. In the case of `error`, it’s quite likely that different implementations
    of the interface could be returned, so you need to use an interface to handle
    all possible options, as interfaces are the only abstract type in Go.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是此规则的一个例外。正如你将在[第9章](ch09.html#unique_chapter_id_09)中看到的那样，Go函数和方法可以声明返回`error`接口类型的返回参数。在`error`的情况下，不同的接口实现很可能会被返回，因此你需要使用接口来处理所有可能的选项，因为在Go中接口是唯一的抽象类型。
- en: This pattern has one potential drawback. As I discussed in [“Reducing the Garbage
    Collector’s Workload”](ch06.html#memory), reducing heap allocations improves performance
    by reducing the amount of work for the garbage collector. Returning a struct avoids
    a heap allocation, which is good. However, when invoking a function with parameters
    of interface types, a heap allocation occurs for each interface parameter. Figuring
    out the trade-off between better abstraction and better performance should be
    done over the life of your program. Write your code so that it is readable and
    maintainable. If you find that your program is too slow *and* you have profiled
    it *and* you have determined that the performance problems are due to a heap allocation
    caused by an interface parameter, then you should rewrite the function to use
    a concrete type parameter. If multiple implementations of an interface are passed
    into the function, this will mean creating multiple functions with repeated logic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式存在一个潜在的缺点。正如我在[“减少垃圾收集器工作量”](ch06.html#memory)中讨论的那样，减少堆分配可以通过减少垃圾收集器的工作量来提高性能。返回一个结构体可以避免堆分配，这是很好的。然而，当调用带有接口类型参数的函数时，每个接口参数都会进行堆分配。找出更好的抽象与更好的性能之间的权衡应该在程序的整个生命周期内完成。编写你的代码使其可读和可维护。如果你发现你的程序太慢，并且你已经对其进行了分析，并且确定性能问题是由接口参数引起的堆分配导致的，那么你应该重写函数以使用具体类型参数。如果将多个接口实现传递给函数，这意味着需要创建多个带有重复逻辑的函数。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Developers who come from a C++ or Rust background might try using generics as
    a way to get the compiler to generate specialized functions. As of Go 1.21, this
    will probably not produce faster code. I’ll cover why in [“Idiomatic Go and Generics”](ch08.html#generic_speed).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 来自C++或Rust背景的开发人员可能会尝试使用泛型作为让编译器生成专门函数的一种方式。截至Go 1.21，这可能不会生成更快的代码。我将在[“Go语言惯用法和泛型”](ch08.html#generic_speed)中详细介绍原因。
- en: Interfaces and nil
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和`nil`
- en: When discussing pointers in [Chapter 6](ch06.html#unique_chapter_id_06), I also
    talked about `nil`, the zero value for pointer types. You can also use `nil` to
    represent the zero value for an interface instance, but it’s not as simple as
    it is for concrete types.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论指针时（见第6章](ch06.html#unique_chapter_id_06)，我还谈到了`nil`，即指针类型的零值。您也可以使用`nil`来表示接口实例的零值，但这对于具体类型来说并不简单。
- en: Understanding the relationship between interfaces and `nil` requires understanding
    a little bit about how interfaces are implemented. In the Go runtime, interfaces
    are implemented as a struct with two pointer fields, one for the value and one
    for the type of the value. As long as the type field is non-nil, the interface
    is non-nil. (Since you cannot have a variable without a type, if the value pointer
    is non-nil, the type pointer is always non-nil.)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解接口与`nil`之间的关系，需要了解一些关于接口实现方式的知识。在Go运行时中，接口实现为一个结构体，其中包含两个指针字段，一个用于值，一个用于值的类型。只要类型字段非`nil`，接口就非`nil`。（由于不能有没有类型的变量，如果值指针非`nil`，则类型指针始终非`nil`。
- en: 'In order for an interface to be considered `nil`, *both* the type and the value
    must be `nil`. The following code prints out `true` on the first two lines and
    `false` on the last:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要将接口视为`nil`，*类型和值*都必须为`nil`。以下代码在前两行上打印出`true`，在最后一行上打印出`false`：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can run this code for yourself on [The Go Playground](https://oreil.ly/njtz9)
    or use the code in the *sample_code/interface_nil* directory in the [Chapter 7
    repository](https://oreil.ly/qJQgV).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Go Playground](https://oreil.ly/njtz9)上运行此代码，或者使用[第7章存储库](https://oreil.ly/qJQgV)中的*sample_code/interface_nil*目录中的代码。
- en: What `nil` indicates for a variable with an interface type is whether you can
    invoke methods on it. As I covered earlier, you can invoke methods on `nil` concrete
    instances, so it makes sense that you can invoke methods on an interface variable
    that was assigned a `nil` concrete instance. If an interface variable is `nil`,
    invoking any methods on it triggers a panic (which I’ll discuss in [“panic and
    recover”](ch09.html#panic_recover)). If an interface variable is non-nil, you
    can invoke methods on it. (But note that if the value is `nil` and the methods
    of the assigned type don’t properly handle `nil`, you could still trigger a panic.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有接口类型的变量，`nil`表示您是否可以在其上调用方法。正如我之前讨论过的，您可以在`nil`具体实例上调用方法，因此对于分配了`nil`具体实例的接口变量也可以调用方法。如果接口变量为`nil`，在其上调用任何方法将触发恐慌（我将在[“恐慌和恢复”](ch09.html#panic_recover)中讨论）。如果接口变量为非`nil`，则可以在其上调用方法。（但请注意，如果值为`nil`并且分配类型的方法未正确处理`nil`，仍可能触发恐慌。）
- en: Since an interface instance with a non-nil type is not equal to `nil`, it is
    not straightforward to tell whether the value associated with the interface is
    `nil` when the type is non-nil. You must use reflection (which I’ll discuss in
    [“Use Reflection to Check If an Interface’s Value Is nil”](ch16.html#reflect_interface_nil))
    to find out.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有非`nil`类型的接口实例不等于`nil`，因此在类型为非`nil`时，要确定与接口关联的值是否为`nil`并不简单。您必须使用反射（我将在[“使用反射检查接口值是否为nil”](ch16.html#reflect_interface_nil)中讨论）来找出。
- en: Interfaces Are Comparable
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口可比较
- en: 'In [Chapter 3](ch03.html#unique_chapter_id_03), you learned about comparable
    types, the ones that can be checked for equality with `==`. You might be surprised
    to learn that interfaces are comparable. Just as an interface is equal to `nil`
    only if its type and value fields are both `nil`, two instances of an interface
    type are equal only if their types are equal and their values are equal. This
    suggests a question: what happens if the type isn’t comparable? Let’s use a simple
    example to explore this concept. Start with an interface definition and a couple
    of implementations of that interface:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html#unique_chapter_id_03)中，您学习了可比较类型，这些类型可以使用`==`进行相等性检查。也许您会惊讶地发现接口也是可以比较的。正如一个接口仅在其类型和值字段都为`nil`时才等于`nil`一样，两个接口类型的实例仅在它们的类型和值都相等时才相等。这引发了一个问题：如果类型不可比较会发生什么？让我们通过一个简单的例子来探讨这个概念。首先定义一个接口和该接口的一些实现：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Double` method on `DoubleInt` is declared with a pointer receiver because
    you are modifying the value of the `int`. You can use a value receiver for the
    `Double` method on `DoubleIntSlice` because, as covered in [“The Difference Between
    Maps and Slices”](ch06.html#map_slice), you can change the value of an item in
    a parameter that is a slice type. The `*DoubleInt` type is comparable (all pointer
    types are), and the `DoubleIntSlice` type is not comparable (slices aren’t comparable).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleInt` 上的 `Double` 方法声明为指针接收器，因为你要修改 `int` 的值。对于 `DoubleIntSlice` 上的 `Double`
    方法，可以使用值接收器，因为如 [“映射与切片的区别”](ch06.html#map_slice) 所述，可以更改参数为切片类型的项的值。`*DoubleInt`
    类型是可比较的（所有指针类型都是），而 `DoubleIntSlice` 类型不可比较（切片不可比较）。'
- en: 'You also have a function that takes in two parameters of type `Doubler` and
    prints if they are equal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有一个函数，它接受两个 `Doubler` 类型的参数，并打印它们是否相等：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You now define four variables:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你定义了四个变量：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you’re going to call this function three times. The first call is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你要调用这个函数三次。第一次调用如下：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This prints out `false`. The types match (both are `*DoubleInt`), but you are
    comparing pointers, not values, and the pointers point to different instances.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 `false`。类型匹配（都是 `*DoubleInt`），但你比较的是指针而不是值，而这些指针指向不同的实例。
- en: 'Next, you compare a `*DoubleInt` with a `DoubleIntSlice`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将 `*DoubleInt` 与 `DoubleIntSlice` 进行比较：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This prints out `false`, because the types do not match.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 `false`，因为类型不匹配。
- en: 'Finally, you get to the problematic case:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你遇到了问题的情况：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code compiles without issue, but triggers a panic at runtime:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以编译通过，但在运行时会触发 panic：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The entire program is available in the *sample_code/comparable* directory in
    the [Chapter 7 repository](https://oreil.ly/qJQgV).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序在[第 7 章存储库的 *sample_code/comparable* 目录](https://oreil.ly/qJQgV)中都可用。
- en: 'Also be aware that the key of a map must be comparable, so a map can be defined
    to have an interface as a key:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，映射的键必须是可比较的，因此可以定义一个接口作为键的映射：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you add a key-value pair to this map and the key isn’t comparable, that will
    also trigger a panic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向此映射添加键值对且键不可比较，那也会触发 panic。
- en: Given this behavior, be careful when using `==` or `!=` with interfaces or using
    an interface as a map key, as it’s easy to accidentally generate a panic that
    will crash your program. Even if all your interface implementations are currently
    comparable, you don’t know what will happen when someone else uses or modifies
    your code, and there’s no way to specify that an interface can be implemented
    only by comparable types. If you want to be extra safe, you can use the `Comparable`
    method on `reflect.Value` to inspect an interface before using it with `==` or
    `!=`. (You’ll learn more about reflection in [“Reflection Lets You Work with Types
    at Runtime”](ch16.html#reflection)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种行为，在使用接口进行 `==` 或 `!=` 比较时要小心，或者将接口用作映射键时，很容易意外触发会崩溃程序的 panic。即使当前所有接口实现都是可比较的，你也不知道其他人在使用或修改你的代码时会发生什么，并且没有办法指定接口只能由可比较类型实现。如果想要更加安全，可以使用
    `reflect.Value` 的 `Comparable` 方法在使用 `==` 或 `!=` 之前检查接口。（关于反射，你可以在 [“反射让你在运行时操作类型”](ch16.html#reflection)
    中了解更多）。
- en: The Empty Interface Says Nothing
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空接口毫无意义
- en: 'Sometimes in a statically typed language, you need a way to say that a variable
    could store a value of any type. Go uses an *empty interface*, `interface{}`,
    to represent this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在静态类型语言中，你需要一种方式来表示变量可以存储任何类型的值。Go 使用 *空接口* `interface{}` 表示这种情况：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`interface{}` isn’t special case syntax. An empty interface type simply states
    that the variable can store any value whose type implements zero or more methods.
    This just happens to match every type in Go.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface{}` 并非特例语法。空接口类型仅表示变量可以存储任何类型的值，该类型实现了零个或多个方法。这恰好匹配 Go 中的每种类型。'
- en: To improve readability, Go added `any` as a type alias for `interface{}`. Legacy
    code (written before `any` was added in Go 1.18) used `interface{}`, but stick
    with `any` for new code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，Go 在 `interface{}` 的类型别名中添加了 `any`。遗留代码（在 Go 1.18 中添加 `any` 之前编写的代码）使用
    `interface{}`，但对于新代码，请坚持使用 `any`。
- en: 'Because an empty interface doesn’t tell you anything about the value it represents,
    you can’t do a lot with it. One common use of `any` is as a placeholder for data
    of uncertain schema that’s read from an external source, like a JSON file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因为空接口无法告诉你关于其表示的值的任何信息，所以你无法对其进行太多操作。`any` 的一个常见用途是作为从外部源（如 JSON 文件）读取的具有不确定模式的数据的占位符：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: User-created data containers that were written before generics were added to
    Go use an empty interface to store a value. (I’ll talk about generics in [Chapter 8](ch08.html#unique_chapter_id_08).)
    An example in the standard library is [`container/list`](https://oreil.ly/53tmr).
    Now that generics are part of Go, please use them for any newly created data containers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 添加泛型之前编写的用户创建的数据容器使用空接口来存储值（我将在[第 8 章](ch08.html#unique_chapter_id_08)中讨论泛型）。标准库中的一个示例是[`container/list`](https://oreil.ly/53tmr)。现在泛型是
    Go 的一部分，请为任何新创建的数据容器使用它们。
- en: If you see a function that takes in an empty interface, it’s likely using reflection
    (which I’ll talk about in [Chapter 16](ch16.html#unique_chapter_id_16)) to either
    populate or read the value. In the preceding example, the second parameter of
    the `json.Unmarshal` function is declared to be of type `any`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到一个接受空接口的函数，很可能使用反射（我将在[第 16 章](ch16.html#unique_chapter_id_16)中讨论）来填充或读取值。在上面的例子中，`json.Unmarshal`函数的第二个参数声明为`any`类型。
- en: These situations should be relatively rare. Avoid using `any`. As you’ve seen,
    Go is designed as a strongly typed language and attempts to work around this are
    unidiomatic.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况应该相对罕见。避免使用`any`。正如您所看到的，Go 被设计为一种强类型语言，试图绕过这一点是不符合习惯的。
- en: If you find yourself in a situation where you had to store a value into an empty
    interface, you might be wondering how to read the value back again. To do that,
    you need to learn about type assertions and type switches.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己处于必须将值存储到空接口中的情况中，您可能想知道如何再次读取该值。为了做到这一点，您需要了解类型断言和类型切换。
- en: Type Assertions and Type Switches
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型断言和类型切换
- en: 'Go provides two ways to see if a variable of an interface type has a specific
    concrete type or if the concrete type implements another interface. Let’s start
    by looking at type assertions. A *type assertion* names the concrete type that
    implemented the interface, or names another interface that is also implemented
    by the concrete type whose value is stored in the interface. You can try it out
    on [The Go Playground](https://oreil.ly/XUfuO) or in the `typeAssert` function
    in *main.go* in the *sample_code/type_assertions* directory in the [Chapter 7
    repository](https://oreil.ly/qJQgV):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Go 为检查接口类型的变量是否具有特定具体类型或具体类型是否实现另一个接口提供了两种方法。让我们从看类型断言开始。*类型断言*指出实现接口的具体类型，或指出另一个同样被存储在接口中值的具体类型也实现了另一个接口。您可以在[Go
    Playground](https://oreil.ly/XUfuO)上试试，或在[第 7 章仓库](https://oreil.ly/qJQgV)的*sample_code/type_assertions*目录中的*main.go*中的`typeAssert`函数中看到：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, the variable `i2` is of type `MyInt`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，变量`i2`的类型为`MyInt`。
- en: 'You might wonder what happens if a type assertion is wrong. In that case, your
    code panics. You can try it out on [The Go Playground](https://oreil.ly/qoXu_)
    or in the `typeAssertPanicWrongType` function in *main.go* in the *sample_code/type_assertions*
    directory in the [Chapter 7 repository](https://oreil.ly/qJQgV):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如果类型断言错误会发生什么。在这种情况下，您的代码会导致恐慌。您可以在[Go Playground](https://oreil.ly/qoXu_)上尝试或在[第
    7 章仓库](https://oreil.ly/qJQgV)的*sample_code/type_assertions*目录中的*main.go*中的`typeAssertPanicWrongType`函数中看到这一点：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Running this code produces the following panic:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会导致以下恐慌：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you’ve already seen, Go is very careful about concrete types. Even if two
    types share an underlying type, a type assertion must match the type of the value
    stored in the interface. The following code panics. You can try it out on [The
    Go Playground](https://oreil.ly/YUaka) or in the `typeAssertPanicTypeNotIdentical`
    function in *main.go* in the *sample_code/type_assertions* directory in the [Chapter
    7 repository](https://oreil.ly/qJQgV):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，Go 对具体类型非常谨慎。即使两种类型共享底层类型，类型断言也必须匹配存储在接口中的值的类型。以下代码将导致恐慌。您可以在[Go Playground](https://oreil.ly/YUaka)上尝试或在[第
    7 章仓库](https://oreil.ly/qJQgV)的*sample_code/type_assertions*目录中的*main.go*中的`typeAssertPanicTypeNotIdentical`函数中看到：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Obviously, crashing is not desired behavior. You avoid this by using the comma
    ok idiom, just as you saw in [“The comma ok Idiom”](ch03.html#comma_ok_section)
    when detecting whether a zero value was in a map. You can see this in the `typeAssertCommaOK`
    function in *main.go* in the *sample_code/type_assertions* directory in the [Chapter
    7 repository](https://oreil.ly/qJQgV):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，崩溃不是预期的行为。您可以通过使用逗号 ok 惯用法来避免这种情况，就像在检测地图中是否有零值时所看到的[“逗号 ok 惯用法”](ch03.html#comma_ok_section)一样。您可以在[第
    7 章仓库](https://oreil.ly/qJQgV)的*sample_code/type_assertions*目录中的*main.go*中的`typeAssertCommaOK`函数中看到这一点：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The boolean `ok` is set to `true` if the type conversion was successful. If
    it was not, `ok` is set to `false` and the other variable (in this case `i2`)
    is set to its zero value. You then handle the unexpected condition within an `if`
    statement. I’ll talk more about error handling in [Chapter 9](ch09.html#unique_chapter_id_09).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型转换成功，则布尔值`ok`设置为`true`。如果不成功，则`ok`设置为`false`，另一个变量（在本例中为`i2`）设置为其零值。然后，你在`if`语句中处理意外情况。我会在[第9章](ch09.html#unique_chapter_id_09)中详细讨论错误处理。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A type assertion is very different from a type conversion. Conversions change
    a value to a new type, while assertions reveal the type of the value stored in
    the interface. Type conversions can be applied to both concrete types and interfaces.
    Type assertions can be applied only to interface types. All type assertions are
    checked at runtime, so they can fail at runtime with a panic if you don’t use
    the comma ok idiom. Most type conversions are checked at compile time, so if they
    are invalid, your code won’t compile. (Type conversions between slices and array
    pointers can fail at runtime and don’t support the comma ok idiom, so be careful
    when using them!)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言与类型转换非常不同。转换将值更改为新类型，而断言则显示存储在接口中的值的类型。类型转换可以应用于具体类型和接口。类型断言只能应用于接口类型。所有类型断言在运行时都会被检查，因此如果你不使用逗号ok惯用法，它们可能会在运行时失败并引发恐慌。大多数类型转换在编译时检查，因此如果无效，你的代码将无法编译。（切片和数组指针之间的类型转换可能在运行时失败，并且不支持逗号ok惯用法，因此在使用它们时要小心！）
- en: Even if you are absolutely certain that your type assertion is valid, use the
    comma ok idiom version. You don’t know how other people (or you in six months)
    will reuse your code. Sooner or later, your unvalidated type assertions will fail
    at runtime.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你绝对确定你的类型断言是有效的，也使用逗号OK惯用法版本。你不知道其他人（或者六个月后的你）将如何重用你的代码。 sooner or later,
    your unvalidated type assertions will fail at runtime.
- en: 'When an interface could be one of multiple possible types, use a *type switch*
    instead:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口可能是多种可能类型之一时，应该使用*类型switch*代替：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A type `switch` looks a lot like the `switch` statement that you saw way back
    in [“switch”](ch04.html#switch_statement). Instead of specifying a boolean operation,
    you specify a variable of an interface type and follow it with `.(type)`. Usually,
    you assign the variable being checked to another variable that’s valid only within
    the `switch`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`switch`看起来很像你早些时候在[“switch”](ch04.html#switch_statement)中看到的`switch`语句。不同之处在于，你指定一个接口类型的变量，然后跟上`.(type)`。通常情况下，你将正在检查的变量分配给另一个仅在`switch`内有效的变量。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since the purpose of a type `switch` is to derive a new variable from an existing
    one, it is idiomatic to assign the variable being switched on to a variable of
    the same name (`i := i.(type)`), making this one of the few places where shadowing
    is a good idea. To make the comments more readable, this example doesn’t use shadowing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型`switch`的目的是从现有变量派生新变量，因此将正在进行switch的变量分配给同名变量（`i := i.(type)`）是一种惯用法，这是少数几个使用影子变量是一个好主意的地方之一。为了使注释更易读，本例没有使用影子变量。
- en: The type of the new variable depends on which case matches. You can use `nil`
    for one case to see if the interface has no associated type. If you list more
    than one type on a case, the new variable is of type `any`. Just as with a `switch`
    statement, you can have a `default` case that matches when no specified type does.
    Otherwise, the new variable has the type of the case that matches.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量的类型取决于哪种情况匹配。你可以在一个情况中使用`nil`来查看接口是否没有关联类型。如果在一个情况中列出多种类型，则新变量的类型为`any`。与`switch`语句一样，如果没有指定类型匹配时有一个`default`情况，则新变量的类型与匹配的情况类型相同。
- en: While the examples so far have used the `any` interface with type assertions
    and type switches, you can uncover the concrete type from all interface types.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子都使用了带有类型断言和类型switch的`any`接口，你可以从所有接口类型中发现具体类型。
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you *don’t* know the type of the value stored in an interface, you need to
    use reflection. I’ll talk more about reflection in [Chapter 16](ch16.html#unique_chapter_id_16).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你*不知道*接口中存储的值的类型，你需要使用反射。我会在[第16章](ch16.html#unique_chapter_id_16)中详细讨论反射。
- en: Use Type Assertions and Type Switches Sparingly
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用类型断言和类型switch
- en: While being able to extract the concrete implementation from an interface variable
    might seem handy, you should use these techniques infrequently. For the most part,
    treat a parameter or return value as the type that was supplied and not what else
    it could be. Otherwise, your function’s API isn’t accurately declaring the types
    it needs to perform its task. If you needed a different type, it should be specified.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能从接口变量中提取具体实现看似方便，但应该少用这些技术。大多数情况下，应将参数或返回值视为所提供的类型，而不是可能的其他类型。否则，函数的 API
    未能准确声明其执行任务所需的类型。如果需要不同的类型，应该明确指定。
- en: 'That said, type assertions and type switches are useful in some use cases.
    One common use of a type assertion is to see if the concrete type behind the interface
    also implements another interface. This allows you to specify optional interfaces.
    For example, the standard library uses this technique to allow more efficient
    copies when the `io.Copy` function is called. This function has two parameters
    of types `io.Writer` and `io.Reader` and calls the `io.copyBuffer` function to
    do its work. If the `io.Writer` parameter also implements `io.WriterTo`, or the
    `io.Reader` parameter also implements `io.ReaderFrom`, most of the work in the
    function can be skipped:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，类型断言和类型切换在某些情况下很有用。类型断言的一个常见用法是查看接口背后的具体类型是否还实现了另一个接口。这允许您指定可选接口。例如，标准库使用这种技术在调用
    `io.Copy` 函数时允许更高效的复制。此函数具有两个类型为 `io.Writer` 和 `io.Reader` 的参数，并调用 `io.copyBuffer`
    函数来执行其工作。如果 `io.Writer` 参数还实现了 `io.WriterTo`，或者 `io.Reader` 参数还实现了 `io.ReaderFrom`，则函数中的大部分工作可以跳过。
- en: '[PRE58]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Another place optional interfaces are used is when evolving an API. As was covered
    in [“Accept Interfaces, Return Structs”](#accept_interface), the API for the database
    drivers has changed over time. One of the reasons for this change is the addition
    of the context, which is discussed in [Chapter 14](ch14.html#unique_chapter_id_14).
    Context is a parameter that’s passed to functions that provides, among other things,
    a standard way to manage cancellation. It was added to Go in version 1.7, which
    means older code doesn’t support it. This includes older database drivers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用可选接口的地方是在演化 API 时。正如《接受接口，返回结构》中所述，数据库驱动程序的 API 随时间变化而变化。这种变化的原因之一是上下文的添加，在第
    14 章中有详细讨论。上下文是传递给函数的参数，提供了管理取消等功能的标准方式。它在 Go 1.7 中添加，这意味着旧代码不支持它。这包括旧的数据库驱动程序。
- en: 'In Go 1.8, new context-aware analogues of existing interfaces were defined
    in the `database/sql/driver` package. For example, the `StmtExecContext` interface
    defines a method called `ExecContext`, which is a context-aware replacement for
    the `Exec` method in `Stmt`. When an implementation of `Stmt` is passed into standard
    library database code, it checks whether it also implements `StmtExecContext`.
    If it does, `ExecContext` is invoked. If not, the Go standard library provides
    a fallback implementation of the cancellation support provided by newer code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 1.8 中，`database/sql/driver` 包定义了现有接口的新的上下文感知模拟。例如，`StmtExecContext` 接口定义了一个名为
    `ExecContext` 的方法，它是 `Stmt` 中 `Exec` 方法的上下文感知替代。当将 `Stmt` 的实现传递给标准库数据库代码时，它会检查是否还实现了
    `StmtExecContext`。如果是，将调用 `ExecContext`。如果不是，Go 标准库提供了一个取消支持的后备实现：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This optional interface technique has one drawback. You saw earlier that it
    is common for implementations of interfaces to use the decorator pattern to wrap
    other implementations of the same interface to layer behavior. The problem is
    that if an optional interface is implemented by one of the wrapped implementations,
    you cannot detect it with a type assertion or type switch. For example, the standard
    library includes a `bufio` package that provides a buffered reader. You can buffer
    any other `io.Reader` implementation by passing it to the `bufio.NewReader` function
    and using the returned `*bufio.Reader`. If the passed-in `io.Reader` also implemented
    `io.ReaderFrom`, wrapping it in a buffered reader prevents the optimization.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可选接口技术有一个缺点。前面提到，接口的实现通常使用装饰器模式来包装相同接口的其他实现以进行层级行为。问题在于，如果一个可选接口由包装实现之一实现，你无法使用类型断言或类型切换来检测它。例如，标准库包括一个
    `bufio` 包，提供了缓冲读取器。您可以通过将其传递给 `bufio.NewReader` 函数并使用返回的 `*bufio.Reader` 缓冲任何其他
    `io.Reader` 实现。如果传入的 `io.Reader` 也实现了 `io.ReaderFrom`，将其包装在缓冲读取器中将阻止优化。
- en: You also see this when handling errors. As mentioned earlier, they implement
    the `error` interface. Errors can include additional information by wrapping other
    errors. A type switch or type assertion cannot detect or match wrapped errors.
    If you want different behaviors to handle different concrete implementations of
    a returned error, use the `errors.Is` and `errors.As` functions to test for and
    access the wrapped error.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误时也可以看到这一点。如前所述，它们实现了 `error` 接口。错误可以通过包装其他错误来包含额外信息。类型开关或类型断言无法检测或匹配已包装的错误。如果您希望采取不同的行为来处理返回错误的不同具体实现，请使用
    `errors.Is` 和 `errors.As` 函数来测试和访问已包装的错误。
- en: 'Type `switch` statements provide the ability to differentiate between multiple
    implementations of an interface that require different processing. They are most
    useful when only certain possible valid types can be supplied for an interface.
    Be sure to include a `default` case in the type `switch` to handle implementations
    that aren’t known at development time. This protects you if you forget to update
    your type `switch` statements when adding new interface implementations:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `switch` 语句提供了区分需要不同处理的接口多个实现的能力。当只有某些可能的有效类型可以提供给接口时，它们非常有用。确保在类型 `switch`
    中包含一个 `default` 情况来处理在开发时不知道的实现。这可以保护您免受在添加新接口实现时忘记更新类型 `switch` 语句的影响：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can see the complete implementation on [The Go Playground](https://oreil.ly/jDhqM)
    or in the *sample_code/type_switch* directory in the [Chapter 7 repository](https://oreil.ly/qJQgV).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[Go Playground](https://oreil.ly/jDhqM)上看到完整的实现，或者在[第 7 章存储库](https://oreil.ly/qJQgV)的
    *sample_code/type_switch* 目录中找到。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can further protect yourself from unexpected interface implementations by
    making the interface unexported and at least one method unexported. If the interface
    is exported, it can be embedded in a struct in another package, making the struct
    implement the interface. I’ll talk more about packages and exporting identifiers
    in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使接口未导出并且至少一个方法未导出来进一步保护自己免受意外接口实现的影响。如果接口被导出，它可以嵌入在另一个包中的结构体中，使结构体实现接口。我将在
    [第 10 章](ch10.html#unique_chapter_id_10) 中更多地讨论包和导出标识符。
- en: Function Types Are a Bridge to Interfaces
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型是接口的桥梁
- en: I haven’t talked about one last thing with type declarations. Once you understand
    the concept of declaring a method on a struct, you can start to see how a user-defined
    type with an underlying type of `int` or `string` can have a method as well. After
    all, a method provides business logic that interacts with the state of an instance,
    and integers and strings have state as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型声明中，还有一件事情我没有讲到。一旦你理解了在结构体上声明方法的概念，你就能开始看到具有 `int` 或 `string` 底层类型的用户定义类型也可以有方法。毕竟，方法提供了与实例状态交互的业务逻辑，而整数和字符串也有状态。
- en: 'Go, however, allows methods on *any* user-defined type, including user-defined
    function types. This sounds like an academic corner case, but they are actually
    very useful. They allow functions to implement interfaces. The most common usage
    is for HTTP handlers. An HTTP handler processes an HTTP server request. It’s defined
    by an interface:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Go 中，方法允许在 *任何* 用户定义的类型上，包括用户定义的函数类型。这听起来像是一个学术边角案例，但它们实际上非常有用。它们允许函数实现接口。最常见的用法是用于
    HTTP 处理程序。HTTP 处理程序处理 HTTP 服务器请求。它由一个接口定义：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'By using a type conversion to `http.HandlerFunc`, any function that has the
    signature `func(http.ResponseWriter,*http.Request)` can be used as an `http.Handler`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类型转换到 `http.HandlerFunc`，任何具有 `func(http.ResponseWriter,*http.Request)`
    签名的函数都可以用作 `http.Handler`：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This lets you implement HTTP handlers using functions, methods, or closures
    using the exact same code path as the one used for other types that meet the `http.Handler`
    interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以使用函数、方法或闭包实现 HTTP 处理程序，使用与用于满足 `http.Handler` 接口的其他类型相同的代码路径。
- en: 'Functions in Go are first-class concepts, and as such, they are often passed
    as parameters into functions. Meanwhile, Go encourages small interfaces, and an
    interface of only one method could easily replace a parameter of a function type.
    The question becomes: when should your function or method specify an input parameter
    of a function type, and when should you use an interface?'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的函数是一流的概念，因此它们经常作为参数传递给函数。同时，Go 鼓励小接口，并且仅有一个方法的接口可以轻松替代函数类型的参数。问题在于：在何时应该让您的函数或方法指定函数类型的输入参数，而何时应该使用接口？
- en: If your single function is likely to depend on many other functions or other
    state that’s not specified in its input parameters, use an interface parameter
    and define a function type to bridge a function to the interface. That’s what’s
    done in the `http` package; a `Handler` is likely just the entry point for a chain
    of calls that needs to be configured. However, if it’s a simple function (like
    the one used in `sort.Slice`), then a parameter of a function type is a good choice.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的单一函数可能依赖于许多其他函数或未在其输入参数中指定的其他状态，请使用接口参数并定义函数类型以将函数桥接到接口。这就是在`http`包中所做的；`Handler`很可能只是需要配置的一系列调用的入口点。但是，如果它是一个简单的函数（例如在`sort.Slice`中使用的函数），那么函数类型的参数是一个很好的选择。
- en: Implicit Interfaces Make Dependency Injection Easier
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式接口使依赖注入更加容易
- en: In the preface, I compared writing software to building bridges. One of the
    things that software has in common with physical infrastructure is that any program
    used for a lengthy period of time by multiple people will need maintenance. While
    programs don’t wear out, developers are often asked to update programs to fix
    bugs, add features, and run in new environments. Therefore, you should structure
    your programs in ways that make them easier to modify. Software engineers talk
    about *decoupling* code, so that changes to different parts of a program have
    no effect on one another.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前言中，我将软件编写比作建造桥梁。软件与物理基础设施的共同点之一是，任何被多人长时间使用的程序都需要维护。虽然程序不会磨损，但开发人员经常被要求更新程序以修复错误、添加功能并在新环境中运行。因此，您应该以使其更易于修改的方式来构造程序。软件工程师讨论*解耦*代码，以便程序的不同部分的更改互不影响。
- en: One of the techniques that has been developed to ease decoupling is called *dependency
    injection*. Dependency injection is the concept that your code should explicitly
    specify the functionality it needs to perform its task. It’s quite a bit older
    than you might think; in 1996, Robert Martin wrote an article called [“The Dependency
    Inversion Principle”](https://oreil.ly/6HVob).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化解耦，已经开发出了一种称为*依赖注入*的技术。依赖注入是指您的代码应明确指定执行任务所需的功能。它比您想象的要古老得多；1996年，Robert
    Martin写了一篇名为[《依赖倒置原则》](https://oreil.ly/6HVob)的文章。
- en: One of the surprising benefits of Go’s implicit interfaces is that they make
    dependency injection an excellent way to decouple your code. While developers
    in other languages often use large, complicated frameworks to inject their dependencies,
    the truth is that it is easy to implement dependency injection in Go without any
    additional libraries. Let’s work through a simple example to see how to use implicit
    interfaces to compose applications via dependency injection.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Go隐式接口的一个令人惊讶的好处是，它们使依赖注入成为解耦代码的一种优秀方式。尽管其他语言的开发人员通常使用大型复杂的框架来注入其依赖关系，但事实是，在Go中很容易实现依赖注入，而无需任何额外的库。让我们通过一个简单的示例来看看如何使用隐式接口通过依赖注入来组合应用程序。
- en: 'To understand this concept better and see how to implement dependency injection
    in Go, you’ll build a very simple web application. (I’ll talk more about Go’s
    built-in HTTP server support in [“The Server”](ch13.html#http_server); consider
    this a preview.) Start by writing a small utility function, a logger:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，并了解如何在Go中实现依赖注入，您将构建一个非常简单的Web应用程序。（我将在[《服务器》](ch13.html#http_server)中更详细地讨论Go的内置HTTP服务器支持；可以将其视为预览。）首先编写一个小的实用函数，一个记录器：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another thing your app needs is a data store. Let’s create a simple one:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还需要的另一件事是数据存储。让我们创建一个简单的数据存储：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Also define a factory function to create an instance of a `SimpleDataStore`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义一个工厂函数来创建`SimpleDataStore`的实例：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, write some business logic that looks up a user and says hello or goodbye.
    Your business logic needs some data to work with, so it requires a data store.
    You also want your business logic to log when it is invoked, so it depends on
    a logger. However, you don’t want to force it to depend on `LogOutput` or `SimpleDataStore`,
    because you might want to use a different logger or data store later. What your
    business logic needs are interfaces to describe what it depends on:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一些业务逻辑来查找用户并打招呼或告别。您的业务逻辑需要一些数据来进行工作，因此它需要一个数据存储。您还希望您的业务逻辑在调用时记录日志，因此它依赖于一个记录器。但是，您不希望强制它依赖于`LogOutput`或`SimpleDataStore`，因为以后您可能希望使用不同的记录器或数据存储。您的业务逻辑需要的是描述其依赖关系的接口：
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To make your `LogOutput` function meet this interface, you define a function
    type with a method on it:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的`LogOutput`函数符合此接口，你需要定义一个带有方法的函数类型：
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By a stunning coincidence, `LoggerAdapter` and `SimpleDataStore` happen to meet
    the interfaces needed by your business logic, but neither type has any idea that
    it does.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，`LoggerAdapter`和`SimpleDataStore`恰好符合你的业务逻辑所需的接口，但是这两种类型都不知道自己符合这些接口。
- en: 'Now that you have the dependencies defined, let’s look at the implementation
    of your business logic:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了依赖项，让我们来看看你的业务逻辑的实现：
- en: '[PRE68]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You have a `struct` with two fields: one a `Logger`, the other a `DataStore`.
    Nothing in `SimpleLogic` mentions the concrete types, so there’s no dependency
    on them. There’s no problem if you later swap in new implementations from an entirely
    different provider, because the provider has nothing to do with your interface.
    This is very different from explicit interfaces in languages like Java. Even though
    Java uses an interface to decouple the implementation from the interface, the
    explicit interfaces bind the client and the provider together. This makes replacing
    a dependency in Java (and other languages with explicit interfaces) far more difficult
    than it is in Go.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个带有两个字段的`struct`：一个是`Logger`，另一个是`DataStore`。`SimpleLogic`中没有提到具体类型，因此对它们没有依赖。如果以后从完全不同的提供者中交换新的实现，那就没有问题，因为提供者与你的接口没有关系。这与像Java这样的显式接口非常不同。尽管Java使用接口来解耦实现与接口，但显式接口将客户端和提供者绑定在一起。这使得在Java（以及其他具有显式接口的语言）中替换依赖关系比在Go中更困难。
- en: 'When you want a `SimpleLogic` instance, you call a factory function, passing
    in interfaces and returning a struct:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要一个`SimpleLogic`实例时，你调用一个工厂函数，传递接口并返回一个结构体：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-298
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The fields in `SimpleLogic` are unexported. This means they can be accessed
    only by code within the same package as `SimpleLogic`. You can’t enforce immutability
    in Go, but limiting which code can access these fields makes their accidental
    modification less likely. I’ll talk more about exported and unexported identifiers
    in [Chapter 10](ch10.html#unique_chapter_id_10).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleLogic`中的字段是未导出的。这意味着它们只能被与`SimpleLogic`在同一包内的代码访问。虽然在Go语言中不能强制实现不可变性，但限制可以访问这些字段的代码可以减少其意外修改的可能性。我将在[第10章](ch10.html#unique_chapter_id_10)中详细讨论导出和未导出标识符。'
- en: 'Now you get to your API. You’re going to have only a single endpoint, `/hello`,
    which says hello to the person whose user ID is supplied. (Please do not use query
    parameters in your real applications for authentication information; this is just
    a quick sample.) Your controller needs business logic that says hello, so you
    define an interface for that:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你要到达你的API。你将只有一个端点`/hello`，它向提供用户ID的人打招呼。（请在你的真实应用程序中不要使用查询参数作为认证信息；这只是一个快速示例。）你的控制器需要业务逻辑来打招呼，所以你为此定义了一个接口：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This method is available on your `SimpleLogic` struct, but once again, the
    concrete type is not aware of the interface. Furthermore, the other method on
    `SimpleLogic`, `SayGoodbye`, is not in the interface because your controller doesn’t
    care about it. The interface is owned by the client code, so its method set is
    customized to the needs of the client code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在你的`SimpleLogic`结构体上是可用的，但是再次强调，具体类型并不知道这个接口。此外，`SimpleLogic`上的另一个方法`SayGoodbye`不在接口中，因为你的控制器不关心它。接口是由客户端代码拥有的，因此它的方法集是根据客户端代码的需求定制的：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Just as you have factory functions for your other types, let’s write one for
    the `Controller`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你的其他类型有工厂函数一样，让我们为`Controller`编写一个工厂函数：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Again, you accept interfaces and return structs.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你接受接口并返回结构体。
- en: 'Finally, you wire up all your components in your `main` function and start
    your server:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main`函数中连接所有组件并启动服务器：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can find the complete code for this application in the *sample_code/dependency_injection*
    directory in the [Chapter 7 repository](https://oreil.ly/qJQgV).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第7章存储库](https://oreil.ly/qJQgV)的*sample_code/dependency_injection*目录中找到此应用程序的完整代码。
- en: The `main` function is the only part of the code that knows what all the concrete
    types actually are. If you want to swap in different implementations, this is
    the only place that needs to change. Externalizing the dependencies via dependency
    injection means that you limit the changes that are needed to evolve your code
    over time.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数是唯一知道所有具体类型的代码部分。如果你想要切换不同的实现，这是唯一需要改变的地方。通过依赖注入来外部化依赖项意味着您限制了随时间演变代码所需的更改。'
- en: Dependency injection is also a great pattern for making testing easier. It shouldn’t
    be surprising, since writing unit tests is effectively reusing your code in a
    different environment, one that constrains the inputs and outputs to validate
    functionality. For example, you can validate the logging output in a test by injecting
    a type that captures the log output and meets the `Logger` interface. I’ll talk
    about this more in [Chapter 15](ch15.html#unique_chapter_id_15).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入也是简化测试的一个很好的模式。这并不令人惊讶，因为编写单元测试实际上是在不同环境中重复使用你的代码，这个环境限制输入和输出以验证功能。例如，你可以通过注入一个能捕获日志输出并符合`Logger`接口的类型来验证测试中的日志输出。我会在[第15章](ch15.html#unique_chapter_id_15)详细讨论这一点。
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The line `http.HandleFunc("/hello", c.SayHello)` demonstrates two points I talked
    about earlier.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 行`http.HandleFunc("/hello", c.SayHello)`展示了我之前讨论的两点。
- en: First, you are treating the `SayHello` method as a function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将`SayHello`方法视为一个函数。
- en: Second, the `http.HandleFunc` function takes in a function and converts it to
    an `http.HandlerFunc` function type, which declares a method to meet the `http.Handler`
    interface, which is the type used to represent a request handler in Go. You took
    a method from one type and converted it into another type with its own method.
    That’s pretty neat.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`http.HandleFunc`函数接收一个函数，并将其转换为`http.HandlerFunc`函数类型，它声明了一个方法以满足`http.Handler`接口，这个类型用于表示Go中的请求处理程序。你将一个类型的方法转换成另一个类型的方法，这非常巧妙。
- en: Wire
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wire
- en: If you feel that writing dependency injection code by hand is too much work,
    you can use [Wire](https://oreil.ly/Akwt_), a dependency injection helper written
    by Google. Wire uses code generation to automatically create the concrete type
    declarations that you wrote yourself in `main`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得手写依赖注入代码太麻烦，可以使用[Wire](https://oreil.ly/Akwt_)，这是由Google编写的依赖注入辅助工具。Wire利用代码生成来自动创建你在`main`中手动编写的具体类型声明。
- en: Go Isn’t Particularly Object-Oriented (and That’s Great)
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go不是特别面向对象（这很好）
- en: Now that you’ve taken a look at the idiomatic use of types in Go, you can see
    that categorizing Go as a particular style of language is difficult. It clearly
    isn’t a strictly procedural language. At the same time, Go’s lack of method overriding,
    inheritance, or, well, objects means that it is also not a particularly object-oriented
    language. Go has function types and closures, but it isn’t a functional language
    either. If you attempt to shoehorn Go into one of these categories, the result
    is nonidiomatic code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过Go中类型的惯用用法，你会发现将Go归类为某种特定风格的语言是困难的。它显然不是严格的过程式语言。同时，Go缺乏方法重写、继承或对象的特性，这也使它不是特别面向对象的语言。Go有函数类型和闭包，但它也不是一种函数式语言。如果你试图强行将Go归入其中一个类别，结果会是非惯用的代码。
- en: If you had to label Go’s style, the best word to use is *practical*. It borrows
    concepts from many places with the overriding goal of creating a language that
    is simple, readable, and maintainable by large teams for many years.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要给Go的风格贴上标签，最合适的词是*实用*。它从多个地方借鉴概念，主要目标是创建一种简单、可读性强且适合大团队长期维护的语言。
- en: Exercises
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In these exercises, you’re going to build a program that uses what you’ve learned
    about types, methods, and interfaces. Answers are available in the *exercise_solutions*
    directory in the [Chapter 7 repository](https://oreil.ly/qJQgV).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，你将构建一个程序，利用你所学的关于类型、方法和接口的知识。答案可以在[第7章仓库](https://oreil.ly/qJQgV)的*exercise_solutions*目录中找到。
- en: You have been asked to manage a basketball league and are going to write a program
    to help you. Define two types. The first one, called `Team`, has a field for the
    name of the team and a field for the player names. The second type is called `League`
    and has a field called `Teams` for the teams in the league and a field called
    `Wins` that maps a team’s name to its number of wins.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被要求管理一个篮球联赛，并准备编写一个程序来帮助你。定义两种类型。第一种称为`Team`，有一个用于球队名称和一个用于球员名称的字段。第二种类型称为`League`，有一个用于联赛中的球队的`Teams`字段和一个用于映射球队名称到胜场数的`Wins`字段。
- en: 'Add two methods to `League`. The first method is called `MatchResult`. It takes
    four parameters: the name of the first team, its score in the game, the name of
    the second team, and its score in the game. This method should update the `Wins`
    field in `League`. Add a second method to `League` called `Ranking` that returns
    a slice of the team names in order of wins. Build your data structures and call
    these methods from the `main` function in your program using some sample data.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`League`添加两个方法。第一个方法名为`MatchResult`，接受四个参数：第一支队伍的名称，其在比赛中的得分，第二支队伍的名称，以及其在比赛中的得分。此方法应更新`League`中的`Wins`字段。向`League`添加第二个方法名为`Ranking`，返回按胜场排序的球队名称切片。在你的程序中构建数据结构，并从`main`函数中调用这些方法，使用一些示例数据。
- en: Define an interface called `Ranker` that has a single method called `Ranking`
    that returns a slice of strings. Write a function called `RankPrinter` with two
    parameters, the first of type `Ranker` and the second of type `io.Writer`. Use
    the `io.WriteString` function to write the values returned by `Ranker` to the
    `io.Writer`, with a newline separating each result. Call this function from `main`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Ranker`的接口，它有一个名为`Ranking`的方法，返回一个字符串切片。编写一个名为`RankPrinter`的函数，有两个参数，第一个参数类型为`Ranker`，第二个参数类型为`io.Writer`。使用`io.WriteString`函数将`Ranker`返回的值写入`io.Writer`，每个结果之间用换行分隔。从`main`函数中调用此函数。
- en: Wrapping Up
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束语
- en: In this chapter, you learned about types, methods, interfaces, and their best
    practices. In the next chapter, you’ll learn about generics, which improve readability
    and maintainability by allowing you to reuse logic and custom-written containers
    with different types.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了有关类型、方法、接口及其最佳实践的知识。在下一章中，您将学习泛型，它通过允许您重用逻辑和使用不同类型的自定义容器来提高可读性和可维护性。
- en: ^([1](ch07.html#id1628-marker)) For the computer scientists in the audience,
    I realize that subtyping is not inheritance. However, most programming languages
    use inheritance to implement subtyping, so the definitions are often conflated
    in popular usage.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#id1628-marker)) 针对观众中的计算机科学家，我意识到子类型化并非继承。然而，大多数编程语言使用继承来实现子类型化，因此这些定义在流行使用中经常混淆。
