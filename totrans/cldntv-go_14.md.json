["```go\nstdExporter, err := stdout.NewExporter(\n    stdout.WithPrettyPrint(),\n)\n```", "```go\njaegerEndpoint := \"http://localhost:14268/api/traces\"\nserviceName := \"fibonacci\"\n\njaegerExporter, err := jaeger.NewRawExporter(\n    jaeger.WithCollectorEndpoint(jaegerEndpoint),\n    jaeger.WithProcess(jaeger.Process{\n        ServiceName: serviceName,\n    }),\n)\n```", "```go\ntp := sdktrace.NewTracerProvider(\n    sdktrace.WithSyncer(stdExporter),\n    sdktrace.WithSyncer(jaegerExporter))\n```", "```go\notel.SetTracerProvider(tp)\n```", "```go\ngtp := otel.GetTracerProvider(tp)\n```", "```go\ntr := otel.GetTracerProvider().Tracer(\"fibonacci\")\n```", "```go\ntype Tracer interface {\n    Start(ctx context.Context, spanName string, opts ...trace.SpanOption)\n        (context.Context, trace.Span)\n}\n```", "```go\nconst serviceName = \"foo\"\n\nfunc main() {\n    // EXPORTER SETUP OMITTED FOR BREVITY\n\n    // Retrieve the Tracer from the otel TracerProvider.\n    tr := otel.GetTracerProvider().Tracer(serviceName)\n\n    // Start the root span; receive a child context (which now\n    // contains the trace ID), and a trace.Span.\n    ctx, sp := tr.Start(context.Background(), \"main\")\n    defer sp.End()     // End completes the span.\n\n    SomeFunction(ctx)\n}\n```", "```go\nfunc SomeFunction(ctx context.Context) {\n    tr := otel.GetTracerProvider().Tracer(serviceName)\n    _, sp := tr.Start(ctx, \"SomeFunction\")\n    defer sp.End()\n\n    // Do something MAGICAL here!\n}\n```", "```go\nctx, sp := tr.Start(ctx, \"attributesAtCreation\",\n    trace.WithAttributes(\n        label.String(\"hello\", \"world\"), label.String(\"foo\", \"bar\")))\ndefer sp.End()\n```", "```go\nanswer := LifeTheUniverseAndEverything()\nspan.SetAttributes(label.Int(\"answer\", answer))\n```", "```go\nspan.AddEvent(\"Acquiring mutex lock\")\nmutex.Lock()\n\n// Do something amazing.\n\nspan.AddEvent(\"Releasing mutex lock\")\nmutex.Unlock()\n```", "```go\nspan.AddEvent(\"Canceled by external signal\",\n    label.Int(\"pid\", 1234),\n    label.String(\"signal\", \"SIGHUP\"))\n```", "```go\nfunc main() {\n    http.HandleFunc(\"/\", helloGoHandler)\n    log.Fatal(http.ListenAndServe(\":3000\", nil))\n}\n```", "```go\nfunc NewHandler(handler http.Handler, operation string, opts ...Option)\n    http.Handler\n```", "```go\nfunc main() {\n    http.Handle(\"/\",\n        otelhttp.NewHandler(http.HandlerFunc(helloGoHandler), \"root\"))\n    log.Fatal(http.ListenAndServe(\":3000\", nil))\n}\n```", "```go\nfunc main() {\n    r := mux.NewRouter()\n    r.Handle(\"/\",\n        otelhttp.NewHandler(http.HandlerFunc(helloGoHandler), \"root\"))\n    log.Fatal(http.ListenAndServe(\":3000\", r))\n}\n```", "```go\ns := grpc.NewServer()\npb.RegisterKeyValueServer(s, &server{})\n```", "```go\ns := grpc.NewServer(\n    grpc.UnaryInterceptor(otelgrpc.UnaryServerInterceptor()),\n    grpc.StreamInterceptor(otelgrpc.StreamServerInterceptor()),\n)\n\npb.RegisterKeyValueServer(s, &server{})\n```", "```go\nfunc printSpanHandler(w http.ResponseWriter, req *http.Request) {\n    ctx := req.Context()                    // Get the request Context\n\n    span := trace.SpanFromContext(ctx)      // Get the current span\n\n    fmt.Printf(\"current span: %v\\n\", span)  // Why not print the span?\n}\n```", "```go\nfunc Fibonacci(ctx context.Context, n int) chan int {\n    ch := make(chan int)\n\n    go func() {\n        tr := otel.GetTracerProvider().Tracer(serviceName)\n\n        cctx, sp := tr.Start(ctx,\n            fmt.Sprintf(\"Fibonacci(%d)\", n),\n            trace.WithAttributes(label.Int(\"n\", n)))\n        defer sp.End()\n\n        result := 1\n        if n > 1 {\n            a := Fibonacci(cctx, n-1)\n            b := Fibonacci(cctx, n-2)\n            result = <-a + <-b\n        }\n\n        sp.SetAttributes(label.Int(\"result\", result))\n\n        ch <- result\n    }()\n\n    return ch\n}\n```", "```go\nfunc fibHandler(w http.ResponseWriter, req *http.Request) {\n    var err error\n    var n int\n\n    if len(req.URL.Query()[\"n\"]) != 1 {\n        err = fmt.Errorf(\"wrong number of arguments\")\n    } else {\n        n, err = strconv.Atoi(req.URL.Query()[\"n\"][0])\n    }\n\n    if err != nil {\n        http.Error(w, \"couldn't parse index n\", 400)\n        return\n    }\n\n    // Retrieve the current context from the incoming request\n    ctx := req.Context()\n\n    // Call the child function, passing it the request context.\n    result := <-Fibonacci(ctx, n)\n\n    // Get the Span associated with the current context and\n    // attach the parameter and result as attributes.\n    if sp := trace.SpanFromContext(ctx); sp != nil {\n        sp.SetAttributes(\n            label.Int(\"parameter\", n),\n            label.Int(\"result\", result))\n    }\n\n    // Finally, send the result back in the response.\n    fmt.Fprintln(w, result)\n}\n```", "```go\nconst (\n    jaegerEndpoint = \"http://localhost:14268/api/traces\"\n    serviceName    = \"fibonacci\"\n)\n\nfunc main() {\n    // Create and configure the console exporter\n    stdExporter, err := stdout.NewExporter(\n        stdout.WithPrettyPrint(),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create and configure the Jaeger exporter\n    jaegerExporter, err := jaeger.NewRawExporter(\n        jaeger.WithCollectorEndpoint(jaegerEndpoint),\n        jaeger.WithProcess(jaeger.Process{\n            ServiceName: serviceName,\n        }),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create and configure the TracerProvider exporter using the\n    // newly created exporters.\n    tp := sdktrace.NewTracerProvider(\n        sdktrace.WithSyncer(stdExporter),\n        sdktrace.WithSyncer(jaegerExporter))\n\n    // Now we can register tp as the otel trace provider.\n    otel.SetTracerProvider(tp)\n\n    // Register the autoinstrumented service handler\n    http.Handle(\"/\",\n        otelhttp.NewHandler(http.HandlerFunc(fibHandler), \"root\"))\n\n    // Start the service listening on port 3000\n    log.Fatal(http.ListenAndServe(\":3000\", nil))\n}\n```", "```go\n$ docker run -d --name jaeger   \\\n  -p 16686:16686                \\\n  -p 14268:14268                \\\n  jaegertracing/all-in-one:1.21\n```", "```go\n$ go run .\n```", "```go\n$ curl localhost:3000?n=6\n13\n```", "```go\n[\n    {\n        \"SpanContext\":{\n            \"TraceID\":\"4253c86eb68783546b8ae3b5e59b4a0c\",\n            \"SpanID\":\"817822981fc2fb30\",\n            \"TraceFlags\":1\n        },\n        \"ParentSpanID\":\"0000000000000000\",\n        \"SpanKind\":1,\n        \"Name\":\"main\",\n        \"StartTime\":\"2020-11-27T13:50:29.739725-05:00\",\n        \"EndTime\":\"2020-11-27T13:50:29.74044542-05:00\",\n        \"Attributes\":[\n            {\n                \"Key\":\"n\",\n                \"Value\":{\n                    \"Type\":\"INT64\",\n                    \"Value\":6\n                }\n            },\n            {\n                \"Key\":\"result\",\n                \"Value\":{\n                    \"Type\":\"INT64\",\n                    \"Value\":13\n                }\n            }\n        ],\n        \"ChildSpanCount\":1,\n        \"InstrumentationLibrary\":{\n            \"Name\":\"fibonacci\",\n            \"Version\":\"\"\n        }\n    }\n]\n```", "```go\nprometheusExporter, err := prometheus.NewExportPipeline(prometheus.Config{})\n```", "```go\n// Get the meter provider from the exporter.\nmp := prometheusExporter.MeterProvider()\n\n// Set it as the global meter provider.\notel.SetMeterProvider(mp)\n```", "```go\n// Register the exporter as the handler for the \"/metrics\" pattern.\nhttp.Handle(\"/metrics\", prometheusExporter)\n\n// Start the HTTP server listening on port 3000.\nlog.Fatal(http.ListenAndServe(\":3000\", nil))\n```", "```go\nmeter := otel.GetMeterProvider().Meter(\"fibonacci\")\n```", "```go\nfunc (m Meter) NewInt64Counter(name string, options ...InstrumentOption)\n    (Int64Counter, error)\n```", "```go\n// The requests counter instrument. As a synchronous instrument,\n// we'll need to keep it so we can use it later to record data.\nvar requests metric.Int64Counter\n\nfunc buildRequestsCounter() error {\n    var err error\n\n    // Retrieve the meter from the meter provider.\n    meter := otel.GetMeterProvider().Meter(serviceName)\n\n    // Get an Int64Counter for a metric called \"fibonacci_requests_total\".\n    requests, err = meter.NewInt64Counter(\"fibonacci_requests_total\",\n        metric.WithDescription(\"Total number of Fibonacci requests.\"),\n    )\n\n    return err\n}\n```", "```go\n// Define our labels here so that we can easily reuse them.\nvar labels = []label.KeyValue{\n    label.Key(\"application\").String(serviceName),\n    label.Key(\"container_id\").String(os.Getenv(\"HOSTNAME\")),\n}\n\nfunc Fibonacci(ctx context.Context, n int) chan int {\n    // Use the Add method on out metric.Int64Counter instance\n    // to increment the counter value.\n    requests.Add(ctx, 1, labels...)\n\n    // The rest of the function...\n}\n```", "```go\nfunc updateMetrics(ctx context.Context) {\n    // Retrieve the meter from the meter provider.\n    meter := otel.GetMeterProvider().Meter(serviceName)\n\n    // Create the instruments that we'll use to report memory\n    // and goroutine values. Error values ignored for brevity.\n    mem, _ := meter.NewInt64UpDownCounter(\"memory_usage_bytes\",\n        metric.WithDescription(\"Amount of memory used.\"),\n    )\n    goroutines, _ := meter.NewInt64UpDownCounter(\"num_goroutines\",\n        metric.WithDescription(\"Number of running goroutines.\"),\n    )\n\n    var m runtime.MemStats\n\n    for {\n        runtime.ReadMemStats(&m)\n\n        // Report the values to the instruments, and receive\n        // metric.Measurement values in return.\n        mMem := mem.Measurement(int64(m.Sys))\n        mGoroutines := goroutines.Measurement(int64(runtime.NumGoroutine()))\n\n        // Provide the measurements (and teh context and\n        // labels) to the meter.\n        meter.RecordBatch(ctx, labels, mMem, mGoroutines)\n\n        time.Sleep(5 * time.Second)\n    }\n}\n```", "```go\nfunc (m Meter) NewInt64UpDownSumObserver(name string,\n    callback Int64ObserverFunc, opts ...InstrumentOption)\n    (Int64UpDownSumObserver, error)\n```", "```go\ntype Int64ObserverFunc func(context.Context, metric.Int64ObserverResult)\n```", "```go\nfunc buildRuntimeObservers() {\n    meter := otel.GetMeterProvider().Meter(serviceName)\n    m := runtime.MemStats{}\n\n    meter.NewInt64UpDownSumObserver(\"memory_usage_bytes\",\n        func(_ context.Context, result metric.Int64ObserverResult) {\n            runtime.ReadMemStats(&m)\n            result.Observe(int64(m.Sys), labels...)\n        },\n        metric.WithDescription(\"Amount of memory used.\"),\n    )\n\n    meter.NewInt64UpDownSumObserver(\"num_goroutines\",\n        func(_ context.Context, result metric.Int64ObserverResult) {\n            result.Observe(int64(runtime.NumGoroutine()), labels...)\n        },\n        metric.WithDescription(\"Number of running goroutines.\"),\n    )\n}\n```", "```go\n$ go run .\n```", "```go\nscrape_configs:\n- job_name: fibonacci\n  scrape_interval: 5s\n  static_configs:\n  - targets: ['host.docker.internal:3000']\n```", "```go\ndocker run -d --name prometheus                             \\\n  -p 9090:9090                                              \\\n  -v \"${PWD}/prometheus.yml:/etc/prometheus/prometheus.yml\" \\\n  prom/prometheus:v2.23.0\n```", "```go\n$ curl localhost:3000?n=6\n13\n```", "```go\n$ curl localhost:3000/metrics\n# HELP fibonacci_requests_total Total number of Fibonacci requests.\n# TYPE fibonacci_requests_total counter\nfibonacci_requests_total{application=\"fibonacci\",container_id=\"d35f0bef2ca0\"} 25\n# HELP memory_usage_bytes Amount of memory used.\n# TYPE memory_usage_bytes gauge\nmemory_usage_bytes{application=\"fibonacci\",container_id=\"d35f0bef2ca0\"}\n  7.5056128e+07\n# HELP num_goroutines Number of running goroutines.\n# TYPE num_goroutines gauge\nnum_goroutines{application=\"fibonacci\",container_id=\"d35f0bef2ca0\"} 6\n```", "```go\n2020/11/09 02:15:10AM User 12345: GET /help in 23ms\n2020/11/09 02:15:11AM Database error: connection reset by peer\n```", "```go\n{\"time\":1604888110, \"level\":\"info\", \"method\":\"GET\", \"path\":\"/help\",\n        \"duration\":23, \"message\":\"Access\"}\n{\"time\":1604888111, \"level\":\"error\", \"error\":\"connection reset by peer\",\n        \"database\":\"user\", \"message\":\"Database error\"}\n```", "```go\nfunc Print(v ...interface{})\nfunc Printf(format string, v ...interface{})\nfunc Println(v ...interface{})\n```", "```go\npackage main\n\nimport \"log\"\n\nfunc main() {\n    log.Print(\"Hello, World!\")\n}\n```", "```go\n$ go run .\n2020/11/10 09:15:39 Hello, World!\n```", "```go\nfunc Fatal(v ...interface{})\nfunc Fatalf(format string, v ...interface{})\nfunc Fatalln(v ...interface{})\n```", "```go\nfunc Panic(v ...interface{})\nfunc Panicf(format string, v ...interface{})\nfunc Panicln(v ...interface{})\n```", "```go\npackage main\n\nimport (\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    // O_APPEND = Append data to the file when writing\n    // O_CREATE = Create a new file if none exists\n    // O_WRONLY = Open the file write-only\n    flags := os.O_APPEND | os.O_CREATE | os.O_WRONLY\n\n    file, err := os.OpenFile(\"log.txt\", flags, 0666)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.SetOutput(file)\n\n    log.Println(\"Hello, World!\")\n}\n```", "```go\n$ go run .; tail log.txt\n2020/11/10 09:17:05 Hello, World!\n```", "```go\nlog.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)\n```", "```go\n2020/11/10 10:14:36 main.go:7: Hello, World!\n```", "```go\nimport \"go.uber.org/zap\"\n```", "```go\nlogger, err := zap.NewProduction()\nif err != nil {\n    log.Fatalf(\"can't initialize zap logger: %v\", err)\n}\n```", "```go\nlogger, _ := zap.NewProduction()\n\n// Structured context as strongly typed Field values.\nlogger.Info(\"failed to fetch URL\",\n    zap.String(\"url\", url),\n    zap.Int(\"attempt\", 3),\n    zap.Duration(\"backoff\", time.Second),\n)\n```", "```go\n{\"level\":\"info\", \"msg\":\"failed to fetch URL\",\n        \"url\":\"http://example.com\", \"attempt\":3, \"backoff\":\"1s\"}\n```", "```go\nlogger, _ := zap.NewProduction()\nsugar := logger.Sugar()\n\n// Structured context as loosely typed key-value pairs.\nsugar.Infow(\"failed to fetch URL\",\n    \"url\", url,\n    \"attempt\", 3,\n    \"backoff\", time.Second,\n)\n\nsugar.Infof(\"failed to fetch URL: %s\", url)\n```", "```go\n{\"level\":\"info\", \"msg\":\"failed to fetch URL\",\n        \"url\":\"http://example.com\", \"attempt\":3, \"backoff\":\"1s\"}\n{\"level\":\"info\", \"msg\":\"failed to fetch URL: http://example.com\"}\n```", "```go\ntype SamplingConfig struct {\n    // Initial sets the cap on the number of events logged each second.\n    Initial    int\n\n    // Thereafter sets the proportion of events that are logged each second\n    // after Initial is exceeded. A value of 3 indicates one event in every\n    // 3 is logged.\n    Thereafter int\n\n    // Hook (if defined) is called after each \"log/no log\" decision.\n    Hook       func(zapcore.Entry, zapcore.SamplingDecision)\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n\n    \"go.uber.org/zap\"\n    \"go.uber.org/zap/zapcore\"\n)\n\nfunc init() {\n    cfg := zap.NewDevelopmentConfig()\n    cfg.EncoderConfig.TimeKey = \"\"          // Turn off timestamp output\n\n    cfg.Sampling = &zap.SamplingConfig{\n        Initial:    3,                      // Allow first 3 events/second\n        Thereafter: 3,                      // Allows 1 per 3 thereafter\n        Hook: func(e zapcore.Entry, d zapcore.SamplingDecision) {\n            if d == zapcore.LogDropped {\n                fmt.Println(\"event dropped...\")\n            }\n        },\n    }\n\n    logger, _ := cfg.Build()                // Constructs the new logger\n\n    zap.ReplaceGlobals(logger)              // Replace Zap's global logger\n}\n```", "```go\nfunc main() {\n    for i := 1; i <= 10; i++ {\n        zap.S().Infow(\n            \"Testing sampling\",\n            \"index\", i,\n        )\n    }\n}\n```", "```go\n$ go run .\nINFO    zap/main.go:39    Testing sampling    {\"index\": 1}\nINFO    zap/main.go:39    Testing sampling    {\"index\": 2}\nINFO    zap/main.go:39    Testing sampling    {\"index\": 3}\nevent dropped...\nevent dropped...\nINFO    zap/main.go:39    Testing sampling    {\"index\": 6}\nevent dropped...\nevent dropped...\nINFO    zap/main.go:39    Testing sampling    {\"index\": 9}\nevent dropped...\n```"]