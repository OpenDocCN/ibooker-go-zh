["```go\nfunc divAndRemainder(num, denom int) (int, int, error) {\n    if denom == 0 {\n        return 0, 0, errors.New(\"cannot divide by zero\")\n    }\n    return num / denom, num % denom, nil\n}\n```", "```go\ntype Node struct {\n    val  int\n    next *Node\n}\n```", "```go\ntype Orderable interface {\n    // Order returns:\n    // a value < 0 when the Orderable is less than the supplied value,\n    // a value > 0 when the Orderable is greater than the supplied value,\n    // and 0 when the two values are equal.\n    Order(any) int\n}\n```", "```go\ntype Tree struct {\n    val         Orderable\n    left, right *Tree\n}\n\nfunc (t *Tree) Insert(val Orderable) *Tree {\n    if t == nil {\n        return &Tree{val: val}\n    }\n\n    switch comp := val.Order(t.val); {\n    case comp < 0:\n        t.left = t.left.Insert(val)\n    case comp > 0:\n        t.right = t.right.Insert(val)\n    }\n    return t\n}\n```", "```go\ntype OrderableInt int\n\nfunc (oi OrderableInt) Order(val any) int {\n    return int(oi - val.(OrderableInt))\n}\n\nfunc main() {\n    var it *Tree\n    it = it.Insert(OrderableInt(5))\n    it = it.Insert(OrderableInt(3))\n    // etc...\n}\n```", "```go\ntype OrderableString string\n\nfunc (os OrderableString) Order(val any) int {\n    return strings.Compare(string(os), val.(string))\n}\n```", "```go\nvar it *Tree\nit = it.Insert(OrderableInt(5))\nit = it.Insert(OrderableString(\"nope\"))\n```", "```go\npanic: interface conversion: interface {} is main.OrderableInt, not string\n```", "```go\ntype Stack[T any] struct {\n    vals []T\n}\n\nfunc (s *Stack[T]) Push(val T) {\n    s.vals = append(s.vals, val)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.vals) == 0 {\n        var zero T\n        return zero, false\n    }\n    top := s.vals[len(s.vals)-1]\n    s.vals = s.vals[:len(s.vals)-1]\n    return top, true\n}\n```", "```go\nfunc main() {\n    var intStack Stack[int]\n    intStack.Push(10)\n    intStack.Push(20)\n    intStack.Push(30)\n    v, ok := intStack.Pop()\n    fmt.Println(v, ok)\n}\n```", "```go\nintStack.Push(\"nope\")\n```", "```go\ncannot use \"nope\" (untyped string constant) as int value\n  in argument to intStack.Push\n```", "```go\nfunc (s Stack[T]) Contains(val T) bool {\n    for _, v := range s.vals {\n        if v == val {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\ninvalid operation: v == val (type parameter T is not comparable with ==)\n```", "```go\ntype Stack[T comparable] struct {\n    vals []T\n}\n```", "```go\nfunc main() {\n    var s Stack[int]\n    s.Push(10)\n    s.Push(20)\n    s.Push(30)\n    fmt.Println(s.Contains(10))\n    fmt.Println(s.Contains(5))\n}\n```", "```go\ntrue\nfalse\n```", "```go\n// Map turns a []T1 to a []T2 using a mapping function.\n// This function has two type parameters, T1 and T2.\n// This works with slices of any type.\nfunc Map[T1, T2 any](s []T1, f func(T1) T2) []T2 {\n    r := make([]T2, len(s))\n    for i, v := range s {\n        r[i] = f(v)\n    }\n    return r\n}\n\n// Reduce reduces a []T1 to a single value using a reduction function.\nfunc Reduce[T1, T2 any](s []T1, initializer T2, f func(T2, T1) T2) T2 {\n    r := initializer\n    for _, v := range s {\n        r = f(r, v)\n    }\n    return r\n}\n\n// Filter filters values from a slice using a filter function.\n// It returns a new slice with only the elements of s\n// for which f returned true.\nfunc Filter[T any](s []T, f func(T) bool) []T {\n    var r []T\n    for _, v := range s {\n        if f(v) {\n            r = append(r, v)\n        }\n    }\n    return r\n}\n```", "```go\nwords := []string{\"One\", \"Potato\", \"Two\", \"Potato\"}\nfiltered := Filter(words, func(s string) bool {\n    return s != \"Potato\"\n})\nfmt.Println(filtered)\nlengths := Map(filtered, func(s string) int {\n    return len(s)\n})\nfmt.Println(lengths)\nsum := Reduce(lengths, 0, func(acc int, val int) int {\n    return acc + val\n})\nfmt.Println(sum)\n```", "```go\n[One Two]\n[3 3]\n6\n```", "```go\ntype Pair[T fmt.Stringer] struct {\n    Val1 T\n    Val2 T\n}\n```", "```go\ntype Differ[T any] interface {\n    fmt.Stringer\n    Diff(T) float64\n}\n```", "```go\nfunc FindCloser[T Differ[T]](pair1, pair2 Pair[T]) Pair[T] {\n    d1 := pair1.Val1.Diff(pair1.Val2)\n    d2 := pair2.Val1.Diff(pair2.Val2)\n    if d1 < d2 {\n        return pair1\n    }\n    return pair2\n}\n```", "```go\ntype Point2D struct {\n    X, Y int\n}\n\nfunc (p2 Point2D) String() string {\n    return fmt.Sprintf(\"{%d,%d}\", p2.X, p2.Y)\n}\n\nfunc (p2 Point2D) Diff(from Point2D) float64 {\n    x := p2.X - from.X\n    y := p2.Y - from.Y\n    return math.Sqrt(float64(x*x) + float64(y*y))\n}\n\ntype Point3D struct {\n    X, Y, Z int\n}\n\nfunc (p3 Point3D) String() string {\n    return fmt.Sprintf(\"{%d,%d,%d}\", p3.X, p3.Y, p3.Z)\n}\n\nfunc (p3 Point3D) Diff(from Point3D) float64 {\n    x := p3.X - from.X\n    y := p3.Y - from.Y\n    z := p3.Z - from.Z\n    return math.Sqrt(float64(x*x) + float64(y*y) + float64(z*z))\n}\n```", "```go\nfunc main() {\n    pair2Da := Pair[Point2D]{Point2D{1, 1}, Point2D{5, 5}}\n    pair2Db := Pair[Point2D]{Point2D{10, 10}, Point2D{15, 5}}\n    closer := FindCloser(pair2Da, pair2Db)\n    fmt.Println(closer)\n\n    pair3Da := Pair[Point3D]{Point3D{1, 1, 10}, Point3D{5, 5, 0}}\n    pair3Db := Pair[Point3D]{Point3D{10, 10, 10}, Point3D{11, 5, 0}}\n    closer2 := FindCloser(pair3Da, pair3Db)\n    fmt.Println(closer2)\n}\n```", "```go\ntype Integer interface {\n    int | int8 | int16 | int32 | int64 |\n        uint | uint8 | uint16 | uint32 | uint64 | uintptr\n}\n```", "```go\nfunc divAndRemainder[T Integer](num, denom T) (T, T, error) {\n    if denom == 0 {\n        return 0, 0, errors.New(\"cannot divide by zero\")\n    }\n    return num / denom, num % denom, nil\n}\n\nfunc main() {\n    var a uint = 18_446_744_073_709_551_615\n    var b uint = 9_223_372_036_854_775_808\n    fmt.Println(divAndRemainder(a, b))\n}\n```", "```go\ntype MyInt int\nvar myA MyInt = 10\nvar myB MyInt = 20\nfmt.Println(divAndRemainder(myA, myB))\n```", "```go\nMyInt does not satisfy Integer (possibly missing ~ for int in Integer)\n```", "```go\ntype Integer interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr\n}\n```", "```go\ntype Ordered interface {\n    ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n        ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |\n        ~float32 | ~float64 |\n        ~string\n}\n```", "```go\ntype PrintableInt interface {\n    ~int\n    String() string\n}\n```", "```go\ntype ImpossiblePrintableInt interface {\n    int\n    String() string\n}\n\ntype ImpossibleStruct[T ImpossiblePrintableInt] struct {\n    val T\n}\n\ntype MyInt int\n\nfunc (mi MyInt) String() string {\n    return fmt.Sprint(mi)\n}\n```", "```go\ns := ImpossibleStruct[int]{10}\ns2 := ImpossibleStruct[MyInt]{10}\n```", "```go\nint does not implement ImpossiblePrintableInt (missing String method)\nMyInt does not implement ImpossiblePrintableInt (possibly missing ~ for\nint in constraint ImpossiblePrintableInt)\n```", "```go\ntype Integer interface {\n    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64\n}\n\nfunc Convert[T1, T2 Integer](in T1) T2 {\n    return T2(in)\n}\n\nfunc main() {\n    var a int = 10\n    b := Convert[int, int64](a) // can't infer the return type\n    fmt.Println(b)\n}\n```", "```go\n// INVALID!\nfunc PlusOneThousand[T Integer](in T) T {\n    return in + 1_000\n}\n```", "```go\n// VALID\nfunc PlusOneHundred[T Integer](in T) T {\n    return in + 100\n}\n```", "```go\ntype OrderableFunc [T any] func(t1, t2 T) int\n```", "```go\ntype Tree[T any] struct {\n    f    OrderableFunc[T]\n    root *Node[T]\n}\n\ntype Node[T any] struct {\n    val         T\n    left, right *Node[T]\n}\n```", "```go\nfunc NewTree[T any](f OrderableFunc[T]) *Tree[T] {\n    return &Tree[T]{\n        f: f,\n    }\n}\n```", "```go\nfunc (t *Tree[T]) Add(v T) {\n    t.root = t.root.Add(t.f, v)\n}\n\nfunc (t *Tree[T]) Contains(v T) bool {\n    return t.root.Contains(t.f, v)\n}\n```", "```go\nfunc (n *Node[T]) Add(f OrderableFunc[T], v T) *Node[T] {\n    if n == nil {\n        return &Node[T]{val: v}\n    }\n    switch r := f(v, n.val); {\n    case r <= -1:\n        n.left = n.left.Add(f, v)\n    case r >= 1:\n        n.right = n.right.Add(f, v)\n    }\n    return n\n}\n\nfunc (n *Node[T]) Contains(f OrderableFunc[T], v T) bool {\n    if n == nil {\n        return false\n    }\n    switch r := f(v, n.val); {\n    case r <= -1:\n        return n.left.Contains(f, v)\n    case r >= 1:\n        return n.right.Contains(f, v)\n    }\n    return true\n}\n```", "```go\nt1 := NewTree(cmp.Compare[int])\nt1.Add(10)\nt1.Add(30)\nt1.Add(15)\nfmt.Println(t1.Contains(15))\nfmt.Println(t1.Contains(40))\n```", "```go\ntype Person struct {\n    Name string\n    Age int\n}\n\nfunc OrderPeople(p1, p2 Person) int {\n    out := cmp.Compare(p1.Name, p2.Name)\n    if out == 0 {\n        out = cmp.Compare(p1.Age, p2.Age)\n    }\n    return out\n}\n```", "```go\nt2 := NewTree(OrderPeople)\nt2.Add(Person{\"Bob\", 30})\nt2.Add(Person{\"Maria\", 35})\nt2.Add(Person{\"Bob\", 50})\nfmt.Println(t2.Contains(Person{\"Bob\", 30}))\nfmt.Println(t2.Contains(Person{\"Fred\", 25}))\n```", "```go\nfunc (p Person) Order(other Person) int {\n    out := cmp.Compare(p.Name, other.Name)\n    if out == 0 {\n        out = cmp.Compare(p.Age, other.Age)\n    }\n    return out\n}\n```", "```go\nt3 := NewTree(Person.Order)\nt3.Add(Person{\"Bob\", 30})\nt3.Add(Person{\"Maria\", 35})\nt3.Add(Person{\"Bob\", 50})\nfmt.Println(t3.Contains(Person{\"Bob\", 30}))\nfmt.Println(t3.Contains(Person{\"Fred\", 25}))\n```", "```go\ntype Thinger interface {\n    Thing()\n}\n\ntype ThingerInt int\n\nfunc (t ThingerInt) Thing() {\n    fmt.Println(\"ThingInt:\", t)\n}\n\ntype ThingerSlice []int\n\nfunc (t ThingerSlice) Thing() {\n    fmt.Println(\"ThingSlice:\", t)\n}\n```", "```go\nfunc Comparer[T comparable](t1, t2 T) {\n    if t1 == t2 {\n        fmt.Println(\"equal!\")\n    }\n}\n```", "```go\nvar a int = 10\nvar b int = 10\nComparer(a, b) // prints true\n\nvar a2 ThingerInt = 20\nvar b2 ThingerInt = 20\nComparer(a2, b2) // prints true\n```", "```go\nvar a3 ThingerSlice = []int{1, 2, 3}\nvar b3 ThingerSlice = []int{1, 2, 3}\nComparer(a3, b3) // compile fails: \"ThingerSlice does not satisfy comparable\"\n```", "```go\nvar a4 Thinger = a2\nvar b4 Thinger = b2\nComparer(a4, b4) // prints true\n```", "```go\na4 = a3\nb4 = b3\nComparer(a4, b4) // compiles, panics at runtime\n```", "```go\ntype functionalSlice[T any] []T\n\n// THIS DOES NOT WORK\nfunc (fs functionalSlice[T]) Map[E any](f func(T) E) functionalSlice[E] {\n    out := make(functionalSlice[E], len(fs))\n    for i, v := range fs {\n        out[i] = f(v)\n    }\n    return out\n}\n\n// THIS DOES NOT WORK\nfunc (fs functionalSlice[T]) Reduce[E any](start E, f func(E, T) E) E {\n    out := start\n    for _, v := range fs {\n        out = f(out, v)\n    }\n    return out\n}\n```", "```go\nvar numStrings = functionalSlice[string]{\"1\", \"2\", \"3\"}\nsum := numStrings.Map(func(s string) int {\n    v, _ := strconv.Atoi(s)\n    return v\n}).Reduce(0, func(acc int, cur int) int {\n    return acc + cur\n})\n```", "```go\ntype Ager interface {\n    age() int\n}\n\nfunc doubleAge(a Ager) int {\n    return a.age() * 2\n}\n```", "```go\nfunc doubleAgeGeneric[T Ager](a T) int {\n    return a.age() * 2\n}\n```", "```go\n    // adds a new element to the end of the linked list\n    Add(T)\n    // adds an element at the specified position in the linked list\n    Insert(T, int)\n    // returns the position of the supplied value, -1 if it's not present\n    Index (T) int\n    ```"]