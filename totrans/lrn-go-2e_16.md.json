["```go\ntype Foo struct {\n  A int\n  B string\n}\n\nvar x Foo\n\nfunc DoSomething(f Foo) {\n  fmt.Println(f.A, f.B)\n}\n```", "```go\nvType := reflect.TypeOf(v)\n```", "```go\nvar x int\nxt := reflect.TypeOf(x)\nfmt.Println(xt.Name())     // returns int\nf := Foo{}\nft := reflect.TypeOf(f)\nfmt.Println(ft.Name())     // returns Foo\nxpt := reflect.TypeOf(&x)\nfmt.Println(xpt.Name())    // returns an empty string\n```", "```go\nvar x int\nxpt := reflect.TypeOf(&x)\nfmt.Println(xpt.Name())        // returns an empty string\nfmt.Println(xpt.Kind())        // returns reflect.Pointer\nfmt.Println(xpt.Elem().Name()) // returns \"int\"\nfmt.Println(xpt.Elem().Kind()) // returns reflect.Int\n```", "```go\ntype Foo struct {\n    A int    `myTag:\"value\"`\n    B string `myTag:\"value2\"`\n}\n\nvar f Foo\nft := reflect.TypeOf(f)\nfor i := 0; i < ft.NumField(); i++ {\n    curField := ft.Field(i)\n    fmt.Println(curField.Name, curField.Type.Name(),\n        curField.Tag.Get(\"myTag\"))\n}\n```", "```go\nA int value\nB string value2\n```", "```go\nvValue := reflect.ValueOf(v)\n```", "```go\ns := []string{\"a\", \"b\", \"c\"}\nsv := reflect.ValueOf(s)        // sv is of type reflect.Value\ns2 := sv.Interface().([]string) // s2 is of type []string\n```", "```go\ni := 10\niv := reflect.ValueOf(&i)\n```", "```go\nivv := iv.Elem()\n```", "```go\nivv.SetInt(20)\nfmt.Println(i) // prints 20\n```", "```go\nfunc changeInt(i *int) {\n    *i = 20\n}\n\nfunc changeIntReflect(i *int) {\n    iv := reflect.ValueOf(i)\n    iv.Elem().SetInt(20)\n}\n```", "```go\nfunc MakeChan(typ Type, buffer int) Value\n\nfunc MakeMap(typ Type) Value\n\nfunc MakeMapWithSize(typ Type, n int) Value\n\nfunc MakeSlice(typ Type, len, cap int) Value\n```", "```go\nvar stringType = reflect.TypeOf((*string)(nil)).Elem()\n\nvar stringSliceType = reflect.TypeOf([]string(nil))\n```", "```go\nssv := reflect.MakeSlice(stringSliceType, 0, 10)\n\nsv := reflect.New(stringType).Elem()\nsv.SetString(\"hello\")\n\nssv = reflect.Append(ssv, sv)\nss := ssv.Interface().([]string)\nfmt.Println(ss) // prints [hello]\n```", "```go\nfunc hasNoValue(i any) bool {\n    iv := reflect.ValueOf(i)\n    if !iv.IsValid() {\n        return true\n    }\n    switch iv.Kind() {\n    case reflect.Pointer, reflect.Slice, reflect.Map, reflect.Func,\n         reflect.Interface:\n        return iv.IsNil()\n    default:\n        return false\n    }\n}\n```", "```go\ntype MyData struct {\n    Name   string `csv:\"name\"`\n    Age    int    `csv:\"age\"`\n    HasPet bool   `csv:\"has_pet\"`\n}\n```", "```go\n// Unmarshal maps all of the rows of data in a slice of slice of strings\n// into a slice of structs.\n// The first row is assumed to be the header with the column names.\nfunc Unmarshal(data [][]string, v any) error\n\n// Marshal maps all of the structs in a slice of structs to a slice of slice\n// of strings.\n// The first row written is the header with the column names.\nfunc Marshal(v any) ([][]string, error)\n```", "```go\nfunc Marshal(v any) ([][]string, error) {\n    sliceVal := reflect.ValueOf(v)\n    if sliceVal.Kind() != reflect.Slice {\n        return nil, errors.New(\"must be a slice of structs\")\n    }\n    structType := sliceVal.Type().Elem()\n    if structType.Kind() != reflect.Struct {\n        return nil, errors.New(\"must be a slice of structs\")\n    }\n    var out [][]string\n    header := marshalHeader(structType)\n    out = append(out, header)\n    for i := 0; i < sliceVal.Len(); i++ {\n        row, err := marshalOne(sliceVal.Index(i))\n        if err != nil {\n            return nil, err\n        }\n        out = append(out, row)\n    }\n    return out, nil\n}\n```", "```go\nfunc marshalHeader(vt reflect.Type) []string {\n    var row []string\n    for i := 0; i < vt.NumField(); i++ {\n        field := vt.Field(i)\n        if curTag, ok := field.Tag.Lookup(\"csv\"); ok {\n            row = append(row, curTag)\n        }\n    }\n    return row\n}\n```", "```go\nfunc marshalOne(vv reflect.Value) ([]string, error) {\n    var row []string\n    vt := vv.Type()\n    for i := 0; i < vv.NumField(); i++ {\n        fieldVal := vv.Field(i)\n        if _, ok := vt.Field(i).Tag.Lookup(\"csv\"); !ok {\n            continue\n        }\n        switch fieldVal.Kind() {\n        case reflect.Int:\n            row = append(row, strconv.FormatInt(fieldVal.Int(), 10))\n        case reflect.String:\n            row = append(row, fieldVal.String())\n        case reflect.Bool:\n            row = append(row, strconv.FormatBool(fieldVal.Bool()))\n        default:\n            return nil, fmt.Errorf(\"cannot handle field of kind %v\",\n                                   fieldVal.Kind())\n        }\n    }\n    return row, nil\n}\n```", "```go\nfunc Unmarshal(data [][]string, v any) error {\n    sliceValPointer := reflect.ValueOf(v)\n    if sliceValPointer.Kind() != reflect.Pointer {\n        return errors.New(\"must be a pointer to a slice of structs\")\n    }\n    sliceVal := sliceValPointer.Elem()\n    if sliceVal.Kind() != reflect.Slice {\n        return errors.New(\"must be a pointer to a slice of structs\")\n    }\n    structType := sliceVal.Type().Elem()\n    if structType.Kind() != reflect.Struct {\n        return errors.New(\"must be a pointer to a slice of structs\")\n    }\n\n    // assume the first row is a header\n    header := data[0]\n    namePos := make(map[string]int, len(header))\n    for i, name := range header {\n        namePos[name] = i\n    }\n\n    for _, row := range data[1:] {\n        newVal := reflect.New(structType).Elem()\n        err := unmarshalOne(row, namePos, newVal)\n        if err != nil {\n            return err\n        }\n        sliceVal.Set(reflect.Append(sliceVal, newVal))\n    }\n    return nil\n}\n```", "```go\nfunc unmarshalOne(row []string, namePos map[string]int, vv reflect.Value) error {\n    vt := vv.Type()\n    for i := 0; i < vv.NumField(); i++ {\n        typeField := vt.Field(i)\n        pos, ok := namePos[typeField.Tag.Get(\"csv\")]\n        if !ok {\n            continue\n        }\n        val := row[pos]\n        field := vv.Field(i)\n        switch field.Kind() {\n        case reflect.Int:\n            i, err := strconv.ParseInt(val, 10, 64)\n            if err != nil {\n                return err\n            }\n            field.SetInt(i)\n        case reflect.String:\n            field.SetString(val)\n        case reflect.Bool:\n            b, err := strconv.ParseBool(val)\n            if err != nil {\n                return err\n            }\n            field.SetBool(b)\n        default:\n            return fmt.Errorf(\"cannot handle field of kind %v\",\n                              field.Kind())\n        }\n    }\n    return nil\n}\n```", "```go\ndata := `name,age,has_pet\nJon,\"100\",true\n\"Fred \"\"The Hammer\"\" Smith\",42,false\nMartha,37,\"true\"\n`\nr := csv.NewReader(strings.NewReader(data))\nallData, err := r.ReadAll()\nif err != nil {\n    panic(err)\n}\nvar entries []MyData\nUnmarshal(allData, &entries)\nfmt.Println(entries)\n\n//now to turn entries into output\nout, err := Marshal(entries)\nif err != nil {\n    panic(err)\n}\nsb := &strings.Builder{}\nw := csv.NewWriter(sb)\nw.WriteAll(out)\nfmt.Println(sb)\n```", "```go\nfunc MakeTimedFunction(f any) any {\n    ft := reflect.TypeOf(f)\n    fv := reflect.ValueOf(f)\n    wrapperF := reflect.MakeFunc(ft, func(in []reflect.Value) []reflect.Value {\n        start := time.Now()\n        out := fv.Call(in)\n        end := time.Now()\n        fmt.Println(end.Sub(start))\n        return out\n    })\n    return wrapperF.Interface()\n}\n```", "```go\nfunc timeMe(a int) int {\n    time.Sleep(time.Duration(a) * time.Second)\n    result := a * 2\n    return result\n}\n\nfunc main() {\n    timed:= MakeTimedFunction(timeMe).(func(int) int)\n    fmt.Println(timed(2))\n}\n```", "```go\nfunc Filter(slice any, filter any) any {\n    sv := reflect.ValueOf(slice)\n    fv := reflect.ValueOf(filter)\n\n    sliceLen := sv.Len()\n    out := reflect.MakeSlice(sv.Type(), 0, sliceLen)\n    for i := 0; i < sliceLen; i++ {\n        curVal := sv.Index(i)\n        values := fv.Call([]reflect.Value{curVal})\n        if values[0].Bool() {\n            out = reflect.Append(out, curVal)\n        }\n    }\n    return out.Interface()\n}\n```", "```go\nnames := []string{\"Andrew\", \"Bob\", \"Clara\", \"Hortense\"}\nlongNames := Filter(names, func(s string) bool {\n    return len(s) > 3\n}).([]string)\nfmt.Println(longNames)\n\nages := []int{20, 50, 13}\nadults := Filter(ages, func(age int) bool {\n    return age >= 18\n}).([]int)\nfmt.Println(adults)\n```", "```go\n[Andrew Clara Hortense]\n[20 50]\n```", "```go\nBenchmarkFilterReflectString-8     5870  203962 ns/op  46616 B/op  2219 allocs/op\nBenchmarkFilterGenericString-8   294355    3920 ns/op  16384 B/op     1 allocs/op\nBenchmarkFilterString-8          302636    3885 ns/op  16384 B/op     1 allocs/op\nBenchmarkFilterReflectInt-8        5756  204530 ns/op  45240 B/op  2503 allocs/op\nBenchmarkFilterGenericInt-8      439100    2698 ns/op   8192 B/op     1 allocs/op\nBenchmarkFilterInt-8             443745    2677 ns/op   8192 B/op     1 allocs/op\n\n```", "```go\ntype BoolInt struct {\n    b bool\n    i int64\n}\n\ntype IntBool struct {\n    i int64\n    b bool\n}\n```", "```go\nfmt.Println(unsafe.Sizeof(BoolInt{}),\n    unsafe.Offsetof(BoolInt{}.b),\n    unsafe.Offsetof(BoolInt{}.i))\n\nfmt.Println(unsafe.Sizeof(IntBool{}),\n    unsafe.Offsetof(IntBool{}.i),\n    unsafe.Offsetof(IntBool{}.b))\n```", "```go\n16 0 8\n16 0 8\n```", "```go\ntype BoolIntBool struct {\n    b  bool\n    i  int64\n    b2 bool\n}\n\ntype BoolBoolInt struct {\n    b  bool\n    b2 bool\n    i  int64\n}\n\ntype IntBoolBool struct {\n    i  int64\n    b  bool\n    b2 bool\n}\n```", "```go\n24 0 8 16\n16 0 1 8\n16 0 8 9\n```", "```go\ntype Data struct {\n    Value  uint32   // 4 bytes\n    Label  [10]byte // 10 bytes\n    Active bool     // 1 byte\n    // Go pads this with 1 byte to make it align\n}\n```", "```go\nconst dataSize = unsafe.Sizeof(Data{}) // sets dataSize to 16\n```", "```go\n[0 132 95 237 80 104 111 110 101 0 0 0 0 0 1 0]\n```", "```go\nfunc DataFromBytes(b [dataSize]byte) Data {\n    d := Data{}\n    d.Value = binary.BigEndian.Uint32(b[:4])\n    copy(d.Label[:], b[4:14])\n    d.Active = b[14] != 0\n    return d\n}\n```", "```go\nfunc DataFromBytesUnsafe(b [dataSize]byte) Data {\n    data := *(*Data)(unsafe.Pointer(&b))\n    if isLE {\n        data.Value = bits.ReverseBytes32(data.Value)\n    }\n    return data\n}\n```", "```go\nvar isLE bool\n\nfunc init() {\n    var x uint16 = 0xFF00\n    xb := *(*[2]byte)(unsafe.Pointer(&x))\n    isLE = (xb[0] == 0x00)\n}\n```", "```go\nfunc BytesFromData(d Data) [dataSize]byte {\n    out := [dataSize]byte{}\n    binary.BigEndian.PutUint32(out[:4], d.Value)\n    copy(out[4:14], d.Label[:])\n    if d.Active {\n        out[14] = 1\n    }\n    return out\n}\n```", "```go\nfunc BytesFromDataUnsafe(d Data) [dataSize]byte {\n    if isLE {\n        d.Value = bits.ReverseBytes32(d.Value)\n    }\n    b := *(*[dataSize]byte)(unsafe.Pointer(&d))\n    return b\n}\n```", "```go\nfunc BytesFromDataUnsafeSlice(d Data) []byte {\n    if isLE {\n        d.Value = bits.ReverseBytes32(d.Value)\n    }\n    bs := unsafe.Slice((*byte)(unsafe.Pointer(&d)), dataSize)\n    return bs\n}\n\nfunc DataFromBytesUnsafeSlice(b []byte) Data {\n    data := *(*Data)((unsafe.Pointer)(unsafe.SliceData(b)))\n    if isLE {\n        data.Value = bits.ReverseBytes32(data.Value)\n    }\n    return data\n}\n```", "```go\nBenchmarkBytesFromData-8             548607271  2.185 ns/op   0 B/op 0 allocs/op\nBenchmarkBytesFromDataUnsafe-8      1000000000  0.8418 ns/op  0 B/op 0 allocs/op\nBenchmarkBytesFromDataUnsafeSlice-8  91179056  13.14 ns/op   16 B/op 1 allocs/op\nBenchmarkDataFromBytes-8             538443861  2.186 ns/op   0 B/op 0 allocs/op\nBenchmarkDataFromBytesUnsafe-8      1000000000  1.160 ns/op   0 B/op 0 allocs/op\nBenchmarkDataFromBytesUnsafeSlice-8 1000000000  0.9617 ns/op  0 B/op 0 allocs/op\n```", "```go\ntype HasUnexportedField struct {\n    A int\n    b bool\n    C string\n}\n```", "```go\nfunc SetBUnsafe(huf *one_package.HasUnexportedField) {\n    sf, _ := reflect.TypeOf(huf).Elem().FieldByName(\"b\")\n    offset := sf.Offset\n    start := unsafe.Pointer(huf)\n    pos := unsafe.Add(start, offset)\n    b := (*bool)(pos)\n    fmt.Println(*b) // read the value\n    *b = true       // write the value\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\n/*\n #cgo LDFLAGS: -lm\n #include <stdio.h>\n #include <math.h>\n #include \"mylib.h\"\n\n int add(int a, int b) {\n int sum = a + b;\n printf(\"a: %d, b: %d, sum %d\\n\", a, b, sum);\n return sum;\n }\n*/\nimport \"C\"\n\nfunc main() {\n    sum := C.add(3, 2)\n    fmt.Println(sum)\n    fmt.Println(C.sqrt(100))\n    fmt.Println(C.multiply(10, 20))\n}\n```", "```go\nint multiply(int a, int b);\n```", "```go\n#include \"mylib.h\"\n\nint multiply(int a, int b) {\n    return a * b;\n}\n```", "```go\n$ go build\n$ ./call_c_from_go\na: 3, b: 2, sum 5\n5\n10\n200\n```", "```go\n//export doubler\nfunc doubler(i int) int {\n    return i * 2\n}\n```", "```go\n/*\n extern int add(int a, int b);\n*/\nimport \"C\"\n```", "```go\n#include \"_cgo_export.h\"\n\nint add(int a, int b) {\n    int doubleA = doubler(a);\n    int sum = doubleA + b;\n    return sum;\n}\n```", "```go\n$ go build\n$ ./call_go_from_c\n8\n```", "```go\npackage main\n\n/*\n #include <stdint.h>\n\n extern void in_c(uintptr_t handle);\n*/\nimport \"C\"\n\nimport (\n    \"fmt\"\n    \"runtime/cgo\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{\n        Name: \"Jon\",\n        Age:  21,\n    }\n    C.in_c(C.uintptr_t(cgo.NewHandle(p)))\n}\n\n//export processor\nfunc processor(handle C.uintptr_t) {\n    h := cgo.Handle(handle)\n    p := h.Value().(Person)\n    fmt.Println(p.Name, p.Age)\n    h.Delete()\n}\n```", "```go\n#include <stdint.h>\n#include \"_cgo_export.h\"\n\nvoid in_c(uintptr_t handle) {\n    processor(handle);\n}\n```"]