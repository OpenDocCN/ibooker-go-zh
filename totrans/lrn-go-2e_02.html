<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Predeclared Types and Declarations"><div class="chapter" id="unique_chapter_id_02">
<h1><span class="label">Chapter 2. </span>Predeclared Types and Declarations</h1>


<p>Now that you have your development environment set up, it’s time to start looking at Go’s language features and how to best use them. When trying to figure out what “best” means, there is one overriding principle: write your programs in a way that makes your intentions clear. As I go through features and discuss the options, I’ll explain why I find that a particular approach produces clearer code.</p>

<p>I’ll start by looking at the types that are built into Go and how to declare variables of those types. While every programmer has experience with these concepts, Go does some things differently, and subtle differences exist between Go and other languages.</p>






<section data-type="sect1" data-pdf-bookmark="The Predeclared Types"><div class="sect1" id="id212">
<h1>The Predeclared Types</h1>

<p>Go has many types built into the language.<a data-type="indexterm" data-primary="predeclared types" data-secondary="about" id="id560"/><a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="about" id="id561"/> These are called <em>predeclared</em> types. They are similar to types that are found in other languages: booleans, integers, floats, and strings. Using these types idiomatically is sometimes a challenge for developers who are transitioning from another language. You’ll look at these types and see how they work best in Go. Before I review the types, let’s cover some of the concepts that apply to all types.</p>








<section data-type="sect2" data-pdf-bookmark="The Zero Value"><div class="sect2" id="id16">
<h2>The Zero Value</h2>

<p>Go, like most modern languages,<a data-type="indexterm" data-primary="types" data-secondary="zero value of unassigned variables" id="id562"/><a data-type="indexterm" data-primary="zero value of unassigned variables" id="id563"/><a data-type="indexterm" data-primary="variables" data-secondary="unassigned variable zero value" data-seealso="zero value of unassigned variables" id="id564"/> assigns a default <em>zero value</em> to any variable that is declared but not assigned a value. Having an explicit zero value makes code clearer and removes a source of bugs found in C and C++ programs. As I talk about each type, I will also cover the zero value for the type. <a data-type="indexterm" data-primary="Go Programming Language Specification" id="id565"/><a data-type="indexterm" data-primary="Go" data-secondary="Go Programming Language Specification" id="id566"/><a data-type="indexterm" data-primary="resources online" data-secondary="Go Programming Language Specification" id="id567"/>You can find details on the zero value in <a href="https://oreil.ly/3d3e6">The Go Programming Language Specification</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Literals"><div class="sect2" id="goliterals">
<h2>Literals</h2>

<p>A Go <em>literal</em>  is an explicitly <a data-type="indexterm" data-primary="types" data-secondary="literals" id="id568"/><a data-type="indexterm" data-primary="literals" id="id569"/>specified number, character, or string. Go programs have four common kinds of literals. (I’ll cover a rare fifth kind of literal when discussing complex numbers.)</p>

<p>An <em>integer literal</em> is a sequence<a data-type="indexterm" data-primary="literals" data-secondary="integer literals" id="id570"/><a data-type="indexterm" data-primary="integer literals" id="id571"/><a data-type="indexterm" data-primary="integer literals" data-secondary="prefixes indicating bases" id="id572"/><a data-type="indexterm" data-primary="binary prefix (0b)" id="id573"/><a data-type="indexterm" data-primary="0b (binary prefix)" id="id574"/><a data-type="indexterm" data-primary="octal prefix (0o)" id="id575"/><a data-type="indexterm" data-primary="0o (octal prefix)" id="id576"/><a data-type="indexterm" data-primary="0x (hexadecimal prefix)" id="id577"/><a data-type="indexterm" data-primary="hexadecimal prefix (0x)" id="id578"/> of numbers. Integer literals are base 10 by default, but different prefixes are used to indicate other bases: 0b for binary (base 2), 0o for octal (base 8), or 0x for hexadecimal (base 16). You can use either upper- or lowercase letters for the prefix. <a data-type="indexterm" data-primary="octal prefix (0o)" data-secondary="0 alone should not be used" id="id579"/><a data-type="indexterm" data-primary="0o (octal prefix)" data-secondary="0 alone should not be used" id="id580"/>A leading 0 with no letter after it is another way to represent an octal literal. Do not use it, as it is very confusing.</p>

<p>To make it easier to read longer integer literals,<a data-type="indexterm" data-primary="integer literals" data-secondary="underscores for readability" id="id581"/><a data-type="indexterm" data-primary="_ (underscore)" data-secondary="integer literals" id="id582"/><a data-type="indexterm" data-primary="underscore (_)" data-secondary="integer literals" id="id583"/> Go allows you to put underscores in the middle of your literal. This allows you to, for example, group by thousands in base 10 (1_234). These underscores have no effect on the value of the number. The only limitations on underscores are that they can’t be at the beginning or end of numbers, and you can’t have them next to each other. You could put an underscore between every digit in your literal (1_2_3_4), but don’t. Use them to improve readability by breaking up base 10 numbers at the thousands place or to break up binary, octal, or hexadecimal numbers at 1-, 2-, or 4-byte boundaries.</p>

<p>A <em>floating-point literal</em> has a<a data-type="indexterm" data-primary="literals" data-secondary="floating-point literals" id="id584"/><a data-type="indexterm" data-primary="floating-point literals" id="id585"/> decimal point to indicate the fractional portion of the value. They can also have an exponent specified with the letter <code>e</code> and a positive or negative number (such as 6.03e23). <a data-type="indexterm" data-primary="floating-point literals" data-secondary="0x prefix for hexadecimal" id="id586"/><a data-type="indexterm" data-primary="floating-point literals" data-secondary="p indicating exponent" id="id587"/><a data-type="indexterm" data-primary="p for exponent in floating-point literals" id="id588"/>You also have the option to write them in hexadecimal by using the 0x prefix and the letter <code>p</code> for indicating any exponent (0x12.34p5, which is equal to 582.5 in base 10). <a data-type="indexterm" data-primary="floating-point literals" data-secondary="underscores for readability" id="id589"/><a data-type="indexterm" data-primary="_ (underscore)" data-secondary="floating-point literals" id="id590"/><a data-type="indexterm" data-primary="underscore (_)" data-secondary="floating-point literals" id="id591"/>As integer literals, you can use underscores to format your floating-point literals.</p>

<p>A <em>rune literal</em> represents a character<a data-type="indexterm" data-primary="literals" data-secondary="rune literals" id="id592"/><a data-type="indexterm" data-primary="rune literals" id="id593"/> and is surrounded by single quotes. <a data-type="indexterm" data-primary="' (single quote)" data-secondary="not interchangeable with double quote" id="id594"/><a data-type="indexterm" data-primary="single quote (')" data-secondary="not interchangeable with double quote" id="id595"/><a data-type="indexterm" data-primary="&quot; (double quote)" data-secondary="not interchangeable with single quote" id="id596"/><a data-type="indexterm" data-primary="double quote (&quot;)" data-secondary="not interchangeable with single quote" id="id597"/><a data-type="indexterm" data-primary="single quote (')" data-secondary="rune literals" id="id598"/><a data-type="indexterm" data-primary="' (single quote)" data-secondary="rune literals" id="id599"/><a data-type="indexterm" data-primary="Unicode support" data-secondary="rune literals" id="id600"/>Unlike many other languages, in Go single quotes and double quotes are <em>not</em> interchangeable. Rune literals can be written as single Unicode characters (<code>'a'</code>), 8-bit octal numbers (<code>'\141'</code>), 8-bit hexadecimal numbers (<code>'\x61'</code>), 16-bit hexadecimal numbers (<code>'\u0061'</code>), or 32-bit Unicode numbers (<code>'\U00000061'</code>). <a data-type="indexterm" data-primary="backslash-escaped rune literals" id="id601"/><a data-type="indexterm" data-primary="rune literals" data-secondary="backslash-escaped rune literals" id="id602"/><a data-type="indexterm" data-primary="newline rune literal ('\n')" id="id603"/><a data-type="indexterm" data-primary="tab rune literal ('\t')" id="id604"/><a data-type="indexterm" data-primary="single quote rune literal ('\'')" id="id605"/><a data-type="indexterm" data-primary="backslash rune literal ('\\')" id="id606"/>There are also several backslash-escaped rune literals, with the most useful ones being newline (<code>'\n'</code>), tab (<code>'\t'</code>), single quote (<code>'\''</code>), and backslash (<code>'\\'</code>).</p>

<p>Practically speaking, use base 10 to represent your integer and floating-point literals. <a data-type="indexterm" data-primary="octal prefix (0o)" data-secondary="uses for octal" id="id607"/>Octal representations are rare, mostly used to represent POSIX permission flag values (such as 0o777 for rwxrwxrwx). <a data-type="indexterm" data-primary="hexadecimal prefix (0x)" data-secondary="uses for hexadecimal" id="id608"/><a data-type="indexterm" data-primary="binary prefix (0b)" data-secondary="uses for binary" id="id609"/>Hexadecimal and binary are sometimes used for bit filters or networking and infrastructure applications. Avoid using any of the numeric escapes for rune literals, unless the context makes your code clearer.</p>

<p class="pagebreak-before">There are two ways to<a data-type="indexterm" data-primary="literals" data-secondary="string literals" id="id610"/><a data-type="indexterm" data-primary="string literals" data-secondary="string literals" id="id611"/><a data-type="indexterm" data-primary="rune literals" data-secondary="string literals" id="id612"/><a data-type="indexterm" data-primary="&quot; (double quote)" data-secondary="string literals" id="id613"/><a data-type="indexterm" data-primary="double quote (&quot;)" data-secondary="string literals" id="id614"/> indicate <em>string literals</em>. Most of the time, you should use double quotes to create an <em>interpreted string literal</em> (e.g., type <strong><code>"Greetings and</code></strong> 
<span class="keep-together"><strong><code>Salutations"</code></strong>).</span> These contain zero or more rune literals. They are called “interpreted” because they interpret rune literals (both numeric and backslash escaped) into single characters.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>One rune literal backslash escape is not legal in a string literal: the single quote escape. It is replaced by a backslash escape for double quotes.</p>
</div>

<p>The only characters that cannot appear in an interpreted string literal are unescaped backslashes, unescaped 
<span class="keep-together">newlines,</span> and unescaped double quotes. If you use an interpreted string literal and want your greetings on a different line from your salutations and want “Salutations” to appear in quotes, you need to type <strong><code>"Greetings and\n\"Salutations\""</code></strong>.</p>

<p>If you need to include backslashes,<a data-type="indexterm" data-primary="string literals" data-secondary="raw string literals" id="id615"/><a data-type="indexterm" data-primary="literals" data-secondary="string literals" data-tertiary="raw string literals" id="id616"/><a data-type="indexterm" data-primary="backquote (`)" data-secondary="raw string literals" id="id617"/><a data-type="indexterm" data-primary="` (backquote)" data-secondary="raw string literals" id="id618"/> double quotes, or newlines in your string, using a <em>raw string literal</em> is easier. These are delimited with backquotes (<code>`</code>) and can contain any character except a backquote. There’s no escape character in a raw string literal; all characters are included as is. When using a raw string literal, you write a multiline greeting like so:</p>

<pre data-type="programlisting" data-code-language="go"><code class="s">`Greetings and</code>
<code class="s">"Salutations"`</code><code class="w"/></pre>

<p>Literals are considered <em>untyped</em>. <a data-type="indexterm" data-primary="literals" data-secondary="untyped" id="id619"/><a data-type="indexterm" data-primary="types" data-secondary="literals" data-tertiary="untyped" id="id620"/><a data-type="indexterm" data-primary="literals" data-secondary="untyped" data-tertiary="default type" id="id621"/><a data-type="indexterm" data-primary="types" data-secondary="default type" id="id622"/><a data-type="indexterm" data-primary="default type" id="id623"/>I’ll explore this concept more in <a data-type="xref" href="#literal_untyped">“Literals Are Untyped”</a>. As you will see in <a data-type="xref" href="#var_declarations">“var Versus :=”</a>, there are situations in Go where the type isn’t explicitly declared. In those cases, Go uses the <em>default type</em> for a literal; if there’s nothing in the expression that makes clear what the type of the literal is, the literal defaults to a type. I will mention the default type for literals when discussing the different predeclared types.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Booleans"><div class="sect2" id="id18">
<h2>Booleans</h2>

<p>The <code>bool</code> type represents Boolean variables.<a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="booleans" id="id624"/><a data-type="indexterm" data-primary="predeclared types" data-secondary="booleans" id="id625"/><a data-type="indexterm" data-primary="bool type" id="id626"/><a data-type="indexterm" data-primary="variables" data-secondary="bool type" id="id627"/><a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="bool types as false" id="id628"/><a data-type="indexterm" data-primary="false" id="id629"/><a data-type="indexterm" data-primary="false" data-secondary="zero value for bool type" id="id630"/><a data-type="indexterm" data-primary="true" id="id631"/><a data-type="indexterm" data-primary="bool type" data-secondary="zero value as false" id="id632"/> Variables of <code>bool</code> type can have one of two values: <code>true</code> or <code>false</code>. The zero value for a <code>bool</code> is <code>false</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">flag</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="c1">// no value assigned, set to false</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">isAwesome</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>

<p>It’s hard to talk about variable types without showing a variable declaration, and vice versa. I’ll use variable declarations first and describe them in <a data-type="xref" href="#var_declarations">“var Versus :=”</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Numeric Types"><div class="sect2" id="id19">
<h2>Numeric Types</h2>

<p>Go has a large number of numeric types:<a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="numeric" id="ch02-numty"/><a data-type="indexterm" data-primary="numeric types" id="ch02-numty2"/><a data-type="indexterm" data-primary="predeclared types" data-secondary="numeric" id="ch02-numty3"/> 12 types (and a few special names) that are grouped into three categories. If you are coming from a language like JavaScript that gets along with only a single numeric type, this might seem like a lot. And in fact, some types are used frequently while others are more esoteric. I’ll start by looking at integer types before moving on to floating-point types and the very unusual complex type.</p>










<section data-type="sect3" data-pdf-bookmark="Integer types"><div class="sect3" id="id20">
<h3>Integer types</h3>

<p>Go provides both signed and unsigned integers<a data-type="indexterm" data-primary="numeric types" data-secondary="integer types" id="ch02-intty"/><a data-type="indexterm" data-primary="integer types" id="ch02-intty2"/> in a variety of sizes, from one to eight bytes. They are shown in <a data-type="xref" href="#table2_1">Table 2-1</a>.</p>
<table id="table2_1">
<caption><span class="label">Table 2-1. </span>The integer types in Go</caption>
<thead>
<tr>
<th>Type name</th>
<th>Value range</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>int8</code></p></td>
<td><p>–128 to 127</p></td>
</tr>
<tr>
<td><p><code>int16</code></p></td>
<td><p>–32768 to 32767</p></td>
</tr>
<tr>
<td><p><code>int32</code></p></td>
<td><p>–2147483648 to 2147483647</p></td>
</tr>
<tr>
<td><p><code>int64</code></p></td>
<td><p>–9223372036854775808 to 9223372036854775807</p></td>
</tr>
<tr>
<td><p><code>uint8</code></p></td>
<td><p>0 to 255</p></td>
</tr>
<tr>
<td><p><code>uint16</code></p></td>
<td><p>0 to 65535</p></td>
</tr>
<tr>
<td><p><code>uint32</code></p></td>
<td><p>0 to 4294967295</p></td>
</tr>
<tr>
<td><p><code>uint64</code></p></td>
<td><p>0 to 18446744073709551615</p></td>
</tr>
</tbody>
</table>

<p>It might be obvious from the name,<a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="integer types as 0" id="id633"/><a data-type="indexterm" data-primary="integer types" data-secondary="zero value as 0" id="id634"/> but the zero value for all of the integer types is <code>0</code>.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="The special integer types"><div class="sect3" id="id21">
<h3>The special integer types</h3>

<p>Go does have some special names<a data-type="indexterm" data-primary="integer types" data-secondary="special integer types" id="id635"/><a data-type="indexterm" data-primary="byte for uint8" id="id636"/><a data-type="indexterm" data-primary="types" data-secondary="byte for uint8" id="id637"/><a data-type="indexterm" data-primary="uint8 as byte" id="id638"/><a data-type="indexterm" data-primary="types" data-secondary="uint8 as byte" id="id639"/> for integer types. A <code>byte</code> is an alias for <code>uint8</code>; it is legal to assign, compare, or perform mathematical operations between a <code>byte</code> and a <code>uint8</code>. However, you rarely see <code>uint8</code> used in Go code; just call it a <code>byte</code>.</p>

<p>The second special name<a data-type="indexterm" data-primary="int for int32 or int64" id="id640"/><a data-type="indexterm" data-primary="types" data-secondary="int for int32 or int64" id="id641"/> is <code>int</code>. On a 32-bit CPU, <code>int</code> is a 32-bit signed integer like an <code>int32</code>. On most 64-bit CPUs, <code>int</code> is a 64-bit signed integer, just like an <code>int64</code>. Because <code>int</code> isn’t consistent from platform to platform, it is a compile-time error to assign, compare, or perform mathematical operations between an <code>int</code> and an <code>int32</code> or <code>int64</code> without a type conversion (see <a data-type="xref" href="#type_conversion">“Explicit Type Conversion”</a> for more details). <a data-type="indexterm" data-primary="integer literals" data-secondary="defaulting to int type" id="id642"/>Integer literals default to being of <code>int</code> type.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some uncommon 64-bit CPU architectures use a 32-bit signed integer for the <code>int</code> type. Go supports three of them: <code>amd64p32</code>, <code>mips64p32</code>, and <code>mips64p32le</code>.</p>
</div>

<p>The third special name<a data-type="indexterm" data-primary="uint as unsigned int" id="id643"/><a data-type="indexterm" data-primary="types" data-secondary="uint as unsigned int" id="id644"/><a data-type="indexterm" data-primary="int for int32 or int64" data-secondary="uint as unsigned int" id="id645"/><a data-type="indexterm" data-primary="types" data-secondary="int for int32 or int64" data-tertiary="uint as unsigned int" id="id646"/> is <code>uint</code>. It follows the same rules as <code>int</code>, only it is unsigned (the values are always 0 or positive).</p>

<p>There are two other special names<a data-type="indexterm" data-primary="rune integer type" id="id647"/><a data-type="indexterm" data-primary="types" data-secondary="rune integer type" id="id648"/><a data-type="indexterm" data-primary="uintptr integer type" id="id649"/><a data-type="indexterm" data-primary="types" data-secondary="uintptr integer type" id="id650"/> for integer types, <code>rune</code> and <code>uintptr</code>. You looked at rune literals earlier and I’ll discuss the <code>rune</code> type in <a data-type="xref" href="#string_rune">“A Taste of Strings and Runes”</a> and <code>uintptr</code> in <a data-type="xref" href="ch16.html#unique_chapter_id_16">Chapter 16</a>.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Choosing which integer to use"><div class="sect3" id="id213">
<h3>Choosing which integer to use</h3>

<p>Go provides more integer types<a data-type="indexterm" data-primary="integer types" data-secondary="choosing which to use" id="id651"/> than some other languages. Given all these choices, you might wonder when you should use each of them. You should follow three simple rules:</p>

<ul>
<li>
<p>If you are working with a binary file format or network protocol that has an integer of a specific size or sign, use the corresponding integer type.</p>
</li>
<li>
<p>If you are writing a library function that should work with any integer type, take advantage of Go’s generics support and use a generic type parameter to represent any integer type (I talk more about functions and their parameters in 
<span class="keep-together"><a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a> and more about generics in <a data-type="xref" href="ch08.html#unique_chapter_id_08">Chapter 8</a>.)</span></p>
</li>
<li>
<p>In all other cases, just use <code>int</code>.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You’ll likely find legacy code where there’s a pair of functions that do the same thing, but one has <code>int64</code> for the parameters and variables and the other has <code>uint64</code>. The reason is that the API was created before generics were added to Go. Without generics, you needed to write functions with slightly different names to implement the same algorithm with different types. Using <code>int64</code> and <code>uint64</code> meant that you could write the code once and let callers use type conversions to pass values in and convert data that’s returned.</p>

<p>You can see this pattern in the Go standard library within the functions <code>FormatInt</code> and <code>FormatUint</code> in the <code>strconv</code> package.<a data-type="indexterm" data-primary="strconv package" data-secondary="strconv.FormatInt" id="id652"/><a data-type="indexterm" data-primary="standard library" data-secondary="strconv package" id="id653"/></p>
</div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Integer operators"><div class="sect3" id="id22">
<h3>Integer operators</h3>

<p>Go integers support the usual<a data-type="indexterm" data-primary="integer types" data-secondary="arithmetic operators" id="id654"/><a data-type="indexterm" data-primary="arithmetic operators" data-secondary="integer types" id="id655"/><a data-type="indexterm" data-primary="% (modulus) for integer types" id="id656"/><a data-type="indexterm" data-primary="modulus (%) for integer types" id="id657"/> arithmetic operators: +, <code>-</code>, <code>*</code>, <code>/</code>, with <code>%</code> for modulus. The result of an integer division is an integer; if you want to get a floating-point result, you need to use a type conversion to make your integers into floating-point numbers. <a data-type="indexterm" data-primary="integer types" data-secondary="arithmetic operators" data-tertiary="dividing by zero" id="id658"/><a data-type="indexterm" data-primary="dividing by zero" data-secondary="integer types" id="id659"/><a data-type="indexterm" data-primary="arithmetic operators" data-secondary="dividing by zero" data-tertiary="integer types" id="id660"/><a data-type="indexterm" data-primary="panics" data-secondary="dividing by zero" id="id661"/>Also, be careful not to divide an integer by 0; this causes a panic (I talk more about panics in <a data-type="xref" href="ch09.html#panic_recover">“panic and recover”</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Integer division in Go follows truncation<a data-type="indexterm" data-primary="arithmetic operators" data-secondary="integer types" data-tertiary="Go specification URL" id="id662"/><a data-type="indexterm" data-primary="resources online" data-secondary="arithmetic operators" id="id663"/> toward zero; see the Go spec’s section on <a href="https://oreil.ly/zp3OJ">arithmetic operators</a> for the full details.</p>
</div>

<p>You can combine any of the<a data-type="indexterm" data-primary="arithmetic operators" data-secondary="integer types" data-tertiary="combined with =" id="id664"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="arithmetic operators" id="id665"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="arithmetic operators" id="id666"/> arithmetic operators with <code>=</code> to modify a variable: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, and <code>%=</code>. For example, the following code results in <code>x</code> having the value 20:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="o">*=</code><code class="w"> </code><code class="mi">2</code><code class="w"/></pre>

<p>You compare integers <a data-type="indexterm" data-primary="arithmetic operators" data-secondary="integer types" data-tertiary="comparison operators" id="id667"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="integer types" id="id668"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="integer types" id="id669"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="integer types" id="id670"/>with <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&lt;=</code>.</p>

<p>Go also has bit-manipulation operators<a data-type="indexterm" data-primary="arithmetic operators" data-secondary="integer types" data-tertiary="bit manipulation operators" id="id671"/><a data-type="indexterm" data-primary="bit manipulation operators" id="id672"/> for integers. You can bit shift left and right with <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, or do bit masks with <code>&amp;</code> (bitwise AND), <code>|</code> (bitwise OR), <code>^</code> (bitwise XOR), and <code>&amp;^</code> (bitwise AND NOT). As with the arithmetic operators, you can also combine all the bitwise operators with <code>=</code> to modify a variable: <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&amp;^=</code>, <code>&lt;&lt;=</code>, and <code>&gt;&gt;=</code>.<a data-type="indexterm" data-startref="ch02-intty" id="id673"/><a data-type="indexterm" data-startref="ch02-intty2" id="id674"/></p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Floating-point types"><div class="sect3" id="id23">
<h3>Floating-point types</h3>

<p>Go has two floating-point types, as shown in <a data-type="xref" href="#table2_2">Table 2-2</a>.<a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="floating-point types" id="id675"/><a data-type="indexterm" data-primary="predeclared types" data-secondary="floating-point types" id="id676"/><a data-type="indexterm" data-primary="floating-point types" id="id677"/><a data-type="indexterm" data-primary="numeric types" data-secondary="floating-point types" id="id678"/></p>
<table id="table2_2">
<caption><span class="label">Table 2-2. </span>The floating-point types in Go</caption>
<thead>
<tr>
<th>Type name</th>
<th>Largest absolute value</th>
<th>Smallest (nonzero) absolute value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>float32</code></p></td>
<td><p>3.40282346638528859811704183484516925440e+38</p></td>
<td><p>1.401298464324817070923729583289916131280e-45</p></td>
</tr>
<tr>
<td><p><code>float64</code></p></td>
<td><p>1.797693134862315708145274237317043567981e+308</p></td>
<td><p>4.940656458412465441765687928682213723651e-324</p></td>
</tr>
</tbody>
</table>

<p>Like the integer types, the zero value for the floating-point types is 0.<a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="floating-point types as 0" id="id679"/><a data-type="indexterm" data-primary="floating-point types" data-secondary="zero value as 0" id="id680"/></p>

<p>Floating point in Go is similar to floating-point math in other languages. Go uses the IEEE 754 specification, giving a large range and limited precision. <a data-type="indexterm" data-primary="floating-point types" data-secondary="using float64 simplest" id="id681"/><a data-type="indexterm" data-primary="floating-point literals" data-secondary="default type of float64" id="id682"/>Picking which floating-point type to use is straightforward: unless you have to be compatible with an existing format, use <code>float64</code>. Floating-point literals have a default type of <code>float64</code>, so always using <code>float64</code> is the simplest option. It also helps mitigate floating-point accuracy issues since a <code>float32</code> has only six- or seven-decimal digits of precision. Don’t worry about the difference in memory size unless you have used the profiler to determine that it is a significant source of problems. (Testing and profiling are covered in <a data-type="xref" href="ch15.html#unique_chapter_id_15">Chapter 15</a>.)</p>

<p>The bigger question is whether <a data-type="indexterm" data-primary="floating-point types" data-secondary="inexactness of" id="id683"/>you should be using a floating-point number at all. In many cases, the answer is no. Just like other languages, Go floating-point numbers have a huge range, but they cannot store every value in that range; they store the nearest approximation. Because floats aren’t exact, they can be used only in situations where inexact values are acceptable or the rules of floating point are well understood. That limits them to things like graphics, statistics, and scientific operations.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A floating-point number cannot represent a decimal value exactly. Do not use them to represent money or any other value that must have an exact decimal representation! You’ll look at a third-party module for handling exact decimal values in <a data-type="xref" href="ch10.html#import_third_party">“Importing Third-Party Code”</a>.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id684">
<h1>IEEE 754</h1>
<p>As mentioned earlier, Go (and most other programming languages) stores floating-point numbers using a specification called IEEE 754.</p>

<p>The actual rules are outside the scope of this book, and they aren’t straightforward. <a data-type="indexterm" data-primary="floating-point types" data-secondary="The Floating Point Guide" data-secondary-sortas="Floating Point Guide" id="id685"/><a data-type="indexterm" data-primary="resources online" data-secondary="The Floating Point Guide" data-secondary-sortas="Floating Point Guide" id="id686"/>You can learn more about IEEE 754 from <a href="https://oreil.ly/FHeW-">The Floating Point Guide</a>.</p>
</div></aside>

<p>You can use all the standard <a data-type="indexterm" data-primary="floating-point types" data-secondary="arithmetic operators" id="id687"/><a data-type="indexterm" data-primary="mathematical operators" data-see="arithmetic operators" id="id688"/><a data-type="indexterm" data-primary="arithmetic operators" data-secondary="floating-point types" id="id689"/><a data-type="indexterm" data-primary="modulus (%) for integer types" data-secondary="not floating-point types" id="id690"/><a data-type="indexterm" data-primary="% (modulus) for integer types" data-secondary="not floating-point types" id="id691"/><a data-type="indexterm" data-primary="floating-point types" data-secondary="arithmetic operators" data-tertiary="division" id="id692"/><a data-type="indexterm" data-primary="dividing by zero" data-secondary="floating-point types" id="id693"/><a data-type="indexterm" data-primary="floating-point types" data-secondary="arithmetic operators" data-tertiary="dividing by zero" id="id694"/><a data-type="indexterm" data-primary="arithmetic operators" data-secondary="dividing by zero" data-tertiary="floating-point types" id="id695"/><a data-type="indexterm" data-primary="±Inf when dividing by zero" data-primary-sortas="Inf" id="id696"/><a data-type="indexterm" data-primary="NaN (Not a Number) when dividing by zero" id="id697"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="floating-point types" id="id698"/>mathematical and comparison operators with floats, except <code>%</code>. Floating-point division has a couple of interesting properties. Dividing a nonzero floating-point variable by 0 returns <code>+Inf</code> or <code>-Inf</code> (positive or negative infinity), depending on the sign of the number. Dividing a floating-point variable set to 0 by 0 returns <code>NaN</code> (Not a Number).</p>

<p>While Go lets you use <code>==</code> and <code>!=</code> to <a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="floating-point types" id="id699"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison  operators" data-tertiary="floating-point types" id="id700"/><a data-type="indexterm" data-primary="floating-point types" data-secondary="inexactness of" data-tertiary="comparing floats" id="id701"/>compare floats, don’t do it. Because of the inexact nature of floats, two floating-point values might not be equal when you think they should be. Instead, define a maximum allowed variance and see if the difference between two floats is less than that. This value (sometimes called <em>epsilon</em>) depends on your accuracy needs; I can’t give you a simple rule. If you aren’t sure, consult your friendly local mathematician for advice. <a data-type="indexterm" data-primary="floating-point types" data-secondary="The Floating Point Guide" data-tertiary="comparing floats" data-secondary-sortas="Floating Point Guide" id="id702"/><a data-type="indexterm" data-primary="resources online" data-secondary="The Floating Point Guide" data-tertiary="comparing floats" data-secondary-sortas="Floating Point Guide" id="id703"/>If you can’t find one, <a href="https://oreil.ly/n9ws3">The Floating Point Guide has a “Comparison” page</a> that can help you out (or possibly convince you to avoid floating-point numbers unless absolutely necessary).</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Complex types (you’re probably not going to use these)"><div class="sect3" id="id24">
<h3>Complex types (you’re probably not going to use these)</h3>

<p>There is one more numeric type<a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="complex types" id="ch02-cplx"/><a data-type="indexterm" data-primary="predeclared types" data-secondary="complex types" id="ch02-cplx2"/><a data-type="indexterm" data-primary="complex types" id="ch02-cplx3"/><a data-type="indexterm" data-primary="numeric types" data-secondary="complex types" id="ch02-cplx4"/> and it is pretty unusual. Go has first-class support for complex numbers. If you don’t know what complex numbers are, you are not the target audience for this feature; feel free to skip ahead.</p>

<p>There isn’t a lot to the complex number support in Go. Go defines two complex number types. <code>complex64</code> uses <code>float32</code> values to represent the real and imaginary part, and <code>complex128</code> uses <code>float64</code> values. <a data-type="indexterm" data-primary="complex types" data-secondary="complex function to declare" id="id704"/>Both are declared with the <code>complex</code> built-in function:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">complexNum</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">complex</code><code class="p">(</code><code class="mf">20.3</code><code class="p">,</code><code class="w"> </code><code class="mf">10.2</code><code class="p">)</code><code class="w"/></pre>

<p>Go uses a few rules to determine the type of the value returned by <code>complex</code>:</p>

<ul>
<li>
<p>If you use untyped constants or literals for both function parameters, you’ll create an untyped complex literal, which has a default type of <code>complex128</code>.</p>
</li>
<li>
<p>If both values passed into <code>complex</code> are of <code>float32</code> type, you’ll create a 
<span class="keep-together"><code>complex64</code>.</span></p>
</li>
<li>
<p>If one value is a <code>float32</code> and the other value is an untyped constant or literal that can fit within a <code>float32</code>, you’ll create a <code>complex64</code>.</p>
</li>
<li>
<p>Otherwise, you’ll create a <code>complex128</code>.</p>
</li>
</ul>

<p>All the standard floating-point <a data-type="indexterm" data-primary="arithmetic operators" data-secondary="complex types" id="id705"/><a data-type="indexterm" data-primary="complex types" data-secondary="arithmetic operators" id="id706"/><a data-type="indexterm" data-primary="comparison operators" data-secondary="complex types" id="id707"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="complex types" id="id708"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="complex types" id="id709"/>arithmetic operators work on complex numbers. Just as with floats, you can use <code>==</code> or <code>!=</code> to compare them, <a data-type="indexterm" data-primary="complex types" data-secondary="inexactness of" id="id710"/>but they have the same precision limitations, so it’s best to use the epsilon technique. <a data-type="indexterm" data-primary="complex types" data-secondary="extracting real and imaginary portions" id="id711"/><a data-type="indexterm" data-primary="real function" id="id712"/><a data-type="indexterm" data-primary="imag function" id="id713"/>You can extract the real and imaginary portions of a complex number with the <code>real</code> and <code>imag</code> built-in functions, respectively. The <code>math/cmplx</code> package has additional functions for manipulating <code>complex128</code> values.</p>

<p>The zero value for both types<a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="complex numbers as 0" id="id714"/><a data-type="indexterm" data-primary="complex types" data-secondary="zero value as 0" id="id715"/> of complex numbers has 0 assigned to both the real and imaginary portions of the number.</p>

<p><a data-type="xref" href="#EX2_4">Example 2-1</a> shows a simple program that demonstrates how complex numbers work. You can run it for yourself on <a href="https://oreil.ly/fuyIu">The Go Playground</a> or in the <em>sample_code/complex_numbers</em> directory in the <a href="https://oreil.ly/zXZqI">Chapter 2 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id716"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id717"/></p>
<div id="EX2_4" data-type="example">
<h5><span class="label">Example 2-1. </span>Complex numbers</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">complex</code><code class="p">(</code><code class="mf">2.5</code><code class="p">,</code><code class="w"> </code><code class="mf">3.1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">complex</code><code class="p">(</code><code class="mf">10.2</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">real</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nb">imag</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">cmplx</code><code class="p">.</code><code class="nx">Abs</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p class="pagebreak-before">Running this code gives you the following:</p>

<pre data-type="programlisting">(12.7+5.1i)
(-7.699999999999999+1.1i)
(19.3+36.62i)
(0.2934098482043688+0.24639022584228065i)
2.5
3.1
3.982461550347975</pre>

<p>You can see floating-point imprecision on display here too.</p>

<p>In case you were wondering what<a data-type="indexterm" data-primary="imaginary literals" id="id718"/><a data-type="indexterm" data-primary="literals" data-secondary="imaginary literals" id="id719"/> the fifth kind of primitive literal was, Go supports imaginary literals to represent the imaginary portion of a complex number. They look just like floating-point literals, but they have an <code>i</code> for a suffix.</p>

<p>Despite having complex numbers as a predeclared type,<a data-type="indexterm" data-primary="numeric types" data-secondary="numerical computing in Go" id="id720"/> Go is not a popular language for numerical computing. Adoption has been limited because other features (like matrix support) are not part of the language and libraries have to use inefficient replacements, like slices of slices. (You’ll look at slices in <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a> and how they are implemented in <a data-type="xref" href="ch06.html#unique_chapter_id_06">Chapter 6</a>.) But if you need to calculate a Mandelbrot set as part of a larger program, or implement a quadratic equation solver, complex number support is there for you.</p>

<p>You might be wondering why<a data-type="indexterm" data-primary="complex types" data-secondary="why supported" id="id721"/><a data-type="indexterm" data-primary="Thompson, Ken" id="id722"/> Go includes complex numbers. The answer is simple: Ken Thompson, one of the creators of Go (and Unix), thought they would be <a href="https://oreil.ly/eBmkq">interesting</a>. There has been discussion about <a href="https://oreil.ly/Q76EV">removing complex numbers</a> from a future version of Go, but it’s easier to just ignore the feature.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you do want to write <a data-type="indexterm" data-primary="numeric types" data-secondary="numerical computing in Go" data-tertiary="Gonum third-party package" id="id723"/><a data-type="indexterm" data-primary="Gonum package for numerical computing" id="id724"/>numerical computing applications in Go, you can use the third-party <a href="https://www.gonum.org">Gonum</a> package. It takes advantage of complex numbers and provides useful libraries for things like linear algebra, matrices, integration, and statistics. But you should consider other languages first.<a data-type="indexterm" data-startref="ch02-numty" id="id725"/><a data-type="indexterm" data-startref="ch02-numty2" id="id726"/><a data-type="indexterm" data-startref="ch02-numty3" id="id727"/><a data-type="indexterm" data-startref="ch02-cplx" id="id728"/><a data-type="indexterm" data-startref="ch02-cplx2" id="id729"/><a data-type="indexterm" data-startref="ch02-cplx3" id="id730"/><a data-type="indexterm" data-startref="ch02-cplx4" id="id731"/></p>
</div>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Taste of Strings and Runes"><div class="sect2" id="string_rune">
<h2>A Taste of Strings and Runes</h2>

<p>This brings us to strings. Like most modern languages,<a data-type="indexterm" data-primary="types" data-secondary="predeclared types" data-tertiary="strings" id="id732"/><a data-type="indexterm" data-primary="string type" id="id733"/><a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="strings as empty string" id="id734"/><a data-type="indexterm" data-primary="string type" data-secondary="zero value as empty string" id="id735"/><a data-type="indexterm" data-primary="Unicode support" data-secondary="strings" id="id736"/> Go includes strings as a built-in type. The zero value for a string is the empty string. Go supports Unicode; as I showed <a data-type="xref" href="#goliterals">“Literals”</a>, you can put any Unicode character into a string. <a data-type="indexterm" data-primary="comparison operators" data-secondary="strings" id="id737"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary="comparison operators" data-tertiary="string types" id="id738"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary="comparison operators" data-tertiary="string types" id="id739"/>Like integers and floats, strings are compared for equality using <code>==</code>, difference with <code>!=</code>, or ordering with <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, or <code>&lt;=</code>. They are concatenated by using the <code>+</code> 
<span class="keep-together">operator.</span></p>

<p>Strings in Go are immutable;<a data-type="indexterm" data-primary="string type" data-secondary="immutable" id="id740"/><a data-type="indexterm" data-primary="variables" data-secondary="strings immutable" data-seealso="string type" id="id741"/> you can reassign the value of a string variable, but you cannot change the value of the string that is assigned to it.</p>

<p>Go also has a type that represents<a data-type="indexterm" data-primary="rune integer type" id="id742"/><a data-type="indexterm" data-primary="types" data-secondary="rune integer type" id="id743"/><a data-type="indexterm" data-primary="int32 via rune type" id="id744"/><a data-type="indexterm" data-primary="types" data-secondary="int32 via rune type" id="id745"/><a data-type="indexterm" data-primary="uint8 as byte" id="id746"/><a data-type="indexterm" data-primary="types" data-secondary="uint8 as byte" id="id747"/><a data-type="indexterm" data-primary="byte for uint8" id="id748"/><a data-type="indexterm" data-primary="types" data-secondary="byte for uint8" id="id749"/> a single code point. The <em>rune</em> type is an alias for the <code>int32</code> type, just as <code>byte</code> is an alias for <code>uint8</code>. <a data-type="indexterm" data-primary="rune literals" data-secondary="default type as rune" id="id750"/><a data-type="indexterm" data-primary="string literals" data-secondary="default type as string" id="id751"/>As you could probably guess, a rune literal’s default type is a rune, and a string literal’s default type is a string.</p>

<p>If you are referring to a character,<a data-type="indexterm" data-primary="characters via rune type" id="id752"/><a data-type="indexterm" data-primary="rune integer type" data-secondary="characters via" id="id753"/><a data-type="indexterm" data-primary="types" data-secondary="rune integer type" data-tertiary="characters via" id="id754"/> use the rune type, not the <code>int32</code> type. They might be the same to the compiler, but you want to use the type that clarifies the intent of your code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">myFirstInitial</code><code class="w"> </code><code class="kt">rune</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="sc">'J'</code><code class="w"> </code><code class="c1">// good - the type name matches the usage</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">myLastInitial</code><code class="w"> </code><code class="kt">int32</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="sc">'B'</code><code class="w"> </code><code class="c1">// bad - legal but confusing</code><code class="w"/></pre>

<p>I am going to talk a lot more about strings in the next chapter, covering some implementation details, relationships with bytes and runes, as well as advanced features and pitfalls.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Explicit Type Conversion"><div class="sect2" id="type_conversion">
<h2>Explicit Type Conversion</h2>

<p>Most languages that have multiple<a data-type="indexterm" data-primary="types" data-secondary="explicit type conversion" id="id755"/><a data-type="indexterm" data-primary="numeric types" data-secondary="explicit type conversion" id="id756"/><a data-type="indexterm" data-primary="predeclared types" data-secondary="explicit type conversion" id="id757"/><a data-type="indexterm" data-primary="automatic type promotion" id="id758"/><a data-type="indexterm" data-primary="types" data-secondary="explicit type conversion" data-tertiary="automatic type promotion versus" id="id759"/><a data-type="indexterm" data-primary="variables" data-secondary="explicit type conversion" id="id760"/><a data-type="indexterm" data-primary="variables" data-secondary="explicit type conversion" data-tertiary="automatic type promotion versus" id="id761"/><a data-type="indexterm" data-primary="type conversion" id="id762"/><a data-type="indexterm" data-primary="arithmetic operators" data-secondary="type conversion" id="id763"/> numeric types automatically convert from one to another when needed. This is called <em>automatic type promotion</em>, and while it seems very convenient, it turns out that the rules to properly convert one type to another can get complicated and produce unexpected results. As a language that values clarity of intent and readability, Go doesn’t allow automatic type promotion between variables. You must use a <em>type conversion</em> when variable types do not match. Even different-sized integers and floats must be converted to the same type to interact. This makes it clear exactly what type you want without having to memorize any type conversion rules (see <a data-type="xref" href="#EX2_1">Example 2-2</a>).</p>
<div id="EX2_1" data-type="example">
<h5><span class="label">Example 2-2. </span>Type conversions</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mf">30.2</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">sum1</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">float64</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">y</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">sum2</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">int</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum1</code><code class="p">,</code><code class="w"> </code><code class="nx">sum2</code><code class="p">)</code><code class="w"/></pre></div>

<p>In this sample code, you define four variables. <code>x</code> is an <code>int</code> with the value 10, and <code>y</code> is a <code>float64</code> with the value 30.2. Since these are not identical types, you need to convert them to add them together. For <code>sum1</code>, you convert <code>x</code> to a <code>float64</code> using a <code>float64</code> type conversion, and for <code>sum2</code>, you convert <code>y</code> to an <code>int</code> using an <code>int</code> type conversion. When you run this code, it prints out 40.2 40.</p>

<p>The same behavior applies with different-sized integer types (see <a data-type="xref" href="#EX2_1a">Example 2-3</a>).</p>
<div id="EX2_1a" data-type="example">
<h5><span class="label">Example 2-3. </span>Integer type conversions</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">b</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">100</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">sum3</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nb">int</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">sum4</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">byte</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">b</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">sum3</code><code class="p">,</code><code class="w"> </code><code class="nx">sum4</code><code class="p">)</code><code class="w"/></pre></div>

<p>You can run these examples on <a href="https://oreil.ly/VoE7H">The Go Playground</a> or in the <em>sample_code/type_conversion</em> directory in the <a href="https://oreil.ly/dGtos">Chapter 2 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id764"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id765"/></p>

<p>This strictness around types has other implications. <a data-type="indexterm" data-primary="bool type" data-secondary="explicit type conversion and booleans" id="id766"/><a data-type="indexterm" data-primary="types" data-secondary="explicit type conversion" data-tertiary="boolean treatment of variable and" id="id767"/><a data-type="indexterm" data-primary="true" data-secondary="booleans only" id="id768"/><a data-type="indexterm" data-primary="false" data-secondary="booleans only" id="id769"/>Since all type conversions in Go are explicit, you cannot treat another Go type as a boolean. In many languages, a nonzero number or a nonempty string can be interpreted as a boolean <code>true</code>. Just like automatic type promotion, the rules for “truthy” values vary from language to language and can be confusing. Unsurprisingly, Go doesn’t allow truthiness. In fact, <em>no other type can be converted to a bool, implicitly or explicitly</em>. <a data-type="indexterm" data-primary="comparison operators" data-secondary="boolean types via" id="id770"/>If you want to convert from another data type to boolean, you must use one of the comparison operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, or <code>&gt;=</code>). For example, to check if variable <code>x</code> is equal to 0, the code would be <code>x == 0</code>. If you want to check if string <code>s</code> is empty, use <code>s == ""</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Type conversions are one of the places where Go chooses to add a little verbosity in exchange for a great deal of simplicity and clarity. You’ll see this trade-off multiple times. Idiomatic Go values comprehensibility over conciseness.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Literals Are Untyped"><div class="sect2" id="literal_untyped">
<h2>Literals Are Untyped</h2>

<p>While you can’t add two integer<a data-type="indexterm" data-primary="literals" data-secondary="untyped" id="id771"/><a data-type="indexterm" data-primary="types" data-secondary="literals" data-tertiary="untyped" id="id772"/> variables together if they are declared to be of different types of integers, Go lets you use an integer literal in floating-point expressions or even assign an integer literal to a floating-point variable:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mf">200.3</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">5</code><code class="w"/></pre>

<p>This is because, as I mentioned earlier, literals in Go are untyped. Go is a practical language, and it makes sense to avoid forcing a type until the developer specifies one. This means they can be used with any variable whose type is compatible with the literal. When you look at user-defined types in <a data-type="xref" href="ch07.html#unique_chapter_id_07">Chapter 7</a>, you’ll see that you can even use literals with user-defined types based on predefined types. Being untyped goes only so far; you can’t assign a literal string to a variable with a numeric type or a literal number to a string variable, nor can you assign a float literal to an <code>int</code>. These are all flagged by the compiler as errors. Size limitations also exist; while you can write numeric literals that are larger than any integer can hold, it is a compile-time error to try to assign a literal whose value overflows the specified variable, such as trying to assign the literal 1000 to a variable of type <code>byte</code>.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="var Versus :="><div class="sect1" id="var_declarations">
<h1>var Versus :=</h1>

<p>For a small language, Go has a lot<a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="var versus :=" id="ch02-var"/><a data-type="indexterm" data-primary="var versus :=" id="ch02-var2"/><a data-type="indexterm" data-primary=":= versus var" id="ch02-var3"/><a data-type="indexterm" data-primary="equal sign (=)" data-secondary=":= versus var" id="ch02-var4"/><a data-type="indexterm" data-primary="= (equal sign)" data-secondary=":= versus var" id="ch02-var5"/><a data-type="indexterm" data-primary="keywords" data-secondary="var" id="ch02-var6"/> of ways to declare variables. There’s a reason for this: each declaration style communicates something about how the variable is used. Let’s go through the ways you can declare a variable in Go and see when each is appropriate.</p>

<p>The most verbose way to declare a variable in Go uses the <code>var</code> keyword, an explicit type, and an assignment. It looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/></pre>

<p>If the type on the righthand side of the <code>=</code> is the expected type of your variable, you can leave off the type from the left side of the <code>=</code>. Since the default type of an integer literal is <code>int</code>, the following declares <code>x</code> to be a variable of type <code>int</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/></pre>

<p>Conversely, if you want to declare a variable and assign it the zero value, you can keep the type and drop the <code>=</code> on the righthand side:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>

<p>You can declare multiple variables at once with <code>var</code>, and they can be of the same type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="mi">20</code><code class="w"/></pre>

<p>You can declare all zero values of the same type:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="kt">int</code><code class="w"/></pre>

<p>or of different types:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/></pre>

<p>There’s one more way to use <code>var</code>. <a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="declaration list" id="id773"/><a data-type="indexterm" data-primary="declaration list for variables" id="id774"/>If you are declaring multiple variables at once, you can wrap them in a <em>declaration list</em>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w">    </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">y</code><code class="w">        </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="w">    </code><code class="nx">z</code><code class="w">    </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">30</code><code class="w"/>
<code class="w">    </code><code class="nx">d</code><code class="p">,</code><code class="w"> </code><code class="nx">e</code><code class="w">     </code><code class="p">=</code><code class="w"> </code><code class="mi">40</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">g</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>Go also supports a short declaration and assignment format. When you are within a function, you can use the <code>:=</code> operator to replace a <code>var</code> declaration that uses type inference. The following two statements do exactly the same thing—they declare <code>x</code> to be an <code>int</code> with the value of 10:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="w"/></pre>

<p>As with <code>var</code>, you can declare multiple variables at once using <code>:=</code>. These two lines both assign 10 to <code>x</code> and “hello” to <code>y</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/>
<code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/></pre>

<p>The <code>:=</code> operator can do one trick that you cannot do with <code>var</code>: it allows you to assign values to existing variables too. As long as at least one new variable is on the lefthand side of the <code>:=</code>, any of the other variables can already exist:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="nx">x</code><code class="p">,</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">30</code><code class="p">,</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/></pre>

<p>Using <code>:=</code> has one limitation. If you are declaring a variable at the package level, you must use <code>var</code> because <code>:=</code> is not legal outside of functions.</p>

<p>How do you know which style to use? As always, choose what makes your intent clearest. The most common declaration style within functions is <code>:=</code>. Outside of a function, use declaration lists on the rare occasions when you are declaring multiple package-level variables.</p>

<p>In some situations within functions, you should avoid <code>:=</code>:</p>

<ul>
<li>
<p>When initializing a variable to its zero value,<a data-type="indexterm" data-primary="zero value of unassigned variables" data-secondary="using var for initializing" id="id775"/> use <code>var x int</code>. This makes it clear that the zero value is intended.</p>
</li>
<li>
<p>When assigning an untyped constant<a data-type="indexterm" data-primary="type conversion" data-secondary="untyped constants or literals" id="id776"/><a data-type="indexterm" data-primary="types" data-secondary="explicit type conversion" data-tertiary="untyped constants or literals" id="id777"/><a data-type="indexterm" data-primary="const keyword" data-secondary="typed and untyped constants" data-tertiary="untyped constant type conversion" id="id778"/><a data-type="indexterm" data-primary="literals" data-secondary="untyped" data-tertiary="type conversion" id="id779"/> or a literal to a variable and the default type for the constant or literal isn’t the type you want for the variable, use the long <code>var</code> form with the type specified. While it is legal to use a type conversion to specify the type of the value and use <code>:=</code> to write <code>x := byte(20)</code>, it is idiomatic to write <code>var x byte = 20</code>.</p>
</li>
<li>
<p>Because <code>:=</code> allows you to assign to both new and existing variables, it sometimes creates new variables when you think you are reusing existing ones (see <a data-type="xref" href="ch04.html#shadowing">“Shadowing Variables”</a> for details). <a data-type="indexterm" data-primary="troubleshooting" data-secondary="variables" data-tertiary="declaring new with var" id="id780"/>In those situations, explicitly declare all your new variables with <code>var</code> to make it clear which variables are new, and then use the assignment operator (<code>=</code>) to assign values to both new and old variables.</p>
</li>
</ul>

<p>While <code>var</code> and <code>:=</code> allow you to declare multiple variables on the same line, use this style only when assigning multiple values returned from a function or the comma ok idiom (see <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a> and <a data-type="xref" href="ch03.html#comma_ok_section">“The comma ok Idiom”</a>).</p>

<p>You should rarely declare variables<a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="package-level variables avoided" id="id781"/><a data-type="indexterm" data-primary="package blocks" id="id782"/><a data-type="indexterm" data-primary="troubleshooting" data-secondary="variables" data-tertiary="package-level avoided" id="id783"/><a data-type="indexterm" data-primary="blocks" data-secondary="package blocks" id="id784"/> outside of functions, in what’s called the <em>package block</em> (see <a data-type="xref" href="ch04.html#blocks">“Blocks”</a>). Package-level variables whose values change are a bad idea. When you have a variable outside of a function, it can be difficult to track the changes made to it, which makes it hard to understand how data is flowing through your program. This can lead to subtle bugs. As a general rule, you should only declare variables in the package block that are effectively immutable.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Avoid declaring variables outside of functions because they complicate data flow analysis.<a data-type="indexterm" data-startref="ch02-var" id="id785"/><a data-type="indexterm" data-startref="ch02-var2" id="id786"/><a data-type="indexterm" data-startref="ch02-var3" id="id787"/><a data-type="indexterm" data-startref="ch02-var4" id="id788"/><a data-type="indexterm" data-startref="ch02-var5" id="id789"/><a data-type="indexterm" data-startref="ch02-var6" id="id790"/></p>
</div>

<p>You might be wondering: does Go provide a way to <em>ensure</em> that a value is immutable? It does, but it is a bit different from what you may have seen in other programming languages. It’s time to learn about <code>const</code>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Using const"><div class="sect1" id="id28">
<h1>Using const</h1>

<p>Many languages have a way<a data-type="indexterm" data-primary="keywords" data-secondary="const" id="ch02-const"/><a data-type="indexterm" data-primary="const keyword" id="ch02-const2"/> to declare a value as immutable. In Go, this is done with the <code>const</code> keyword. At first glance, it seems to work exactly as it would in other languages. Try out the code in <a data-type="xref" href="#EX2_7">Example 2-4</a> on <a href="https://oreil.ly/FdG-W">The Go Playground</a> or in the <em>sample_code/const_declaration</em> directory in the <a href="https://oreil.ly/QxTTT">Chapter 2 repository</a>.<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id791"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="id792"/></p>
<div id="EX2_7" data-type="example">
<h5><span class="label">Example 2-4. </span><code>const</code> declarations</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>

<code class="kn">import</code><code class="w"> </code><code class="s">"fmt"</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="kt">int64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">idKey</code><code class="w">   </code><code class="p">=</code><code class="w"> </code><code class="s">"id"</code><code class="w"/>
<code class="w">    </code><code class="nx">nameKey</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"name"</code><code class="w"/>
<code class="p">)</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="nx">z</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">10</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"hello"</code><code class="w"/>

<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code><code class="w"/>

<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"> </code><code class="c1">// this will not compile!</code><code class="w"/>
<code class="w">    </code><code class="nx">y</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s">"bye"</code><code class="w"> </code><code class="c1">// this will not compile!</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p>When you run this code, compilation fails with the following error messages:</p>

<pre data-type="programlisting">./prog.go:20:2: cannot assign to x (constant 10 of type int64)
./prog.go:21:2: cannot assign to y (untyped string constant "hello")</pre>

<p>As you see, you declare a constant at the package level or within a function. Just as with <code>var</code>, you can (and should) declare a group of related constants within a set of 
<span class="keep-together">parentheses.</span></p>

<p>Be aware that <code>const</code> in Go is very limited. <a data-type="indexterm" data-primary="literals" data-secondary="constants for naming literals" id="id793"/>Constants in Go are a way to give names to literals. They can only hold values that the compiler can figure out at compile time. This means that they can be assigned:</p>

<ul>
<li>
<p>Numeric literals</p>
</li>
<li>
<p><code>true</code> and <code>false</code></p>
</li>
<li>
<p>Strings</p>
</li>
<li>
<p>Runes</p>
</li>
<li>
<p>The values returned by the built-in functions <code>complex</code>, <code>real</code>, <code>imag</code>, <code>len</code>, and <code>cap</code></p>
</li>
<li>
<p>Expressions that consist of operators and the preceding values</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>I’ll cover the <code>len</code> and <code>cap</code> functions in the next chapter. Another value that can be used with <code>const</code> is called <code>iota</code>. I’ll talk about <code>iota</code> when I discuss creating your own types in 
<span class="keep-together"><a data-type="xref" href="ch07.html#unique_chapter_id_07">Chapter 7</a>.</span></p>
</div>

<p>Go doesn’t provide a way to specify<a data-type="indexterm" data-primary="const keyword" data-secondary="constants" data-tertiary="immutability of" id="id794"/><a data-type="indexterm" data-primary="immutable values in Go" data-secondary="constant immutability" id="id795"/> that a value calculated at runtime is immutable. For example, the following code will fail to compile with the error <code>x + y (value of type int) is not constant</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">5</code><code class="w"/>
<code class="nx">y</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="w"/>
<code class="kd">const</code><code class="w"> </code><code class="nx">z</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="c1">// this won't compile!</code><code class="w"/></pre>

<p>As you’ll see in the next chapter, there are no immutable arrays, slices, maps, or structs, and there’s no way to declare that a field in a struct is immutable. This is less limiting than it sounds. Within a function, it is clear if a variable is being modified, so immutability is less important. In <a data-type="xref" href="ch05.html#call_value">“Go Is Call by Value”</a>, you’ll see how Go prevents modifications to variables that are passed as parameters to functions.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Constants in Go are a way to give names to literals. There is <em>no</em> way in Go to declare that a variable is immutable.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Typed and Untyped Constants"><div class="sect1" id="id29">
<h1>Typed and Untyped Constants</h1>

<p>Constants can be typed or untyped.<a data-type="indexterm" data-primary="const keyword" data-secondary="typed and untyped constants" id="id796"/><a data-type="indexterm" data-primary="types" data-secondary="constants typed and untyped" id="id797"/> An untyped constant works exactly like a literal; it has no type of its own but does have a default type that is used when no other type can be inferred. A typed constant can be directly assigned only to a variable of that type.</p>

<p>Whether to make a constant typed depends on why the constant was declared. If you are giving a name to a mathematical constant that could be used with multiple numeric types, keep the constant untyped. In general, leaving a constant untyped gives you more flexibility. In certain situations, you’ll want a constant to enforce a type. You’ll see a use for typed constants when I cover enumerations with <code>iota</code> in <a data-type="xref" href="ch07.html#iota_section">“iota Is for Enumerations—Sometimes”</a>.</p>

<p>Here’s what an untyped constant declaration looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/></pre>

<p>All of the following assignments are legal:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">y</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">z</code><code class="w"> </code><code class="kt">float64</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">d</code><code class="w"> </code><code class="kt">byte</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">x</code><code class="w"/></pre>

<p>Here’s what a typed constant declaration looks like:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">const</code><code class="w"> </code><code class="nx">typedX</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">10</code><code class="w"/></pre>

<p>This constant can be assigned directly only to an <code>int</code>. Assigning it to any other type produces a compile-time error like this:<a data-type="indexterm" data-startref="ch02-const" id="id798"/><a data-type="indexterm" data-startref="ch02-const2" id="id799"/></p>

<pre data-type="programlisting">cannot use typedX (type int) as type float64 in assignment</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Unused Variables"><div class="sect1" id="unused_vars_section">
<h1>Unused Variables</h1>

<p>One of the goals for Go is to make<a data-type="indexterm" data-primary="variables" data-secondary="unused" id="id800"/><a data-type="indexterm" data-primary="collaboration" data-secondary="unused variables" id="id801"/> it easier for large teams to collaborate on programs. To do so, Go has some rules that are unique among programming languages. <a data-type="indexterm" data-primary="collaboration" data-secondary="code formatting for" id="id802"/>In <a data-type="xref" href="ch01.html#unique_chapter_id_01">Chapter 1</a>, you saw that Go programs need to be formatted in a specific way with <code>go fmt</code> to make it easier to write code-manipulation tools and to provide coding standards. <a data-type="indexterm" data-primary="errors" data-secondary="compile-time errors" data-tertiary="declared variable not used" id="id803"/>Another Go requirement is that <em>every declared local variable must be read</em>. It is a <em>compile-time error</em> to declare a local variable and to not read its value.</p>

<p>The compiler’s unused variable check is not exhaustive. As long as a variable is 
<span class="keep-together">read once,</span> the compiler won’t complain, even if there are writes to the variable that are never read. The following is a valid Go program that you can run on 
<span class="keep-together"><a href="https://oreil.ly/8JLA6">The Go Playground</a></span> or in the <em>sample_code/assignments_not_read</em> directory in the <a href="https://oreil.ly/FqALl">Chapter 2 repository</a>:<a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="ix_bbbb"/><a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 2" data-tertiary-sortas="bbb" id="ix_bbb"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">10</code><code class="w"> </code><code class="c1">// this assignment isn't read!</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">x</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="mi">30</code><code class="w"> </code><code class="c1">// this assignment isn't read!</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>While the compiler and <code>go vet</code> do not catch the unused assignments of 10 and 30 to <code>x</code>, third-party tools can detect them. I’ll talk about these tools in <a data-type="xref" href="ch11.html#code_quality">“Using Code-Quality Scanners”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Go compiler won’t stop you from<a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="package-level variables avoided" id="id804"/> creating unread package-level variables. This is one more reason you should avoid creating package-level variables.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id805">
<h1>Unused Constants</h1>
<p>Perhaps surprisingly, the Go compiler<a data-type="indexterm" data-primary="const keyword" data-secondary="constants" data-tertiary="unused constants" id="id806"/> allows you to create unread constants with <code>const</code>. This is because constants in Go are calculated at compile time and cannot have any side effects. This makes them easy to eliminate: if a constant isn’t used, it is simply not included in the compiled binary.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Naming Variables and Constants"><div class="sect1" id="id30">
<h1>Naming Variables and Constants</h1>

<p>There is a difference between<a data-type="indexterm" data-primary="variables" data-secondary="naming" id="id807"/><a data-type="indexterm" data-primary="const keyword" data-secondary="naming constants" id="id808"/><a data-type="indexterm" data-primary="naming variables and constants" id="id809"/> Go’s rules for naming variables and the patterns that Go developers follow when naming their variables and constants. Like most languages, Go requires identifier names to start with a letter or underscore, and the name can contain numbers, underscores, and letters.  <a data-type="indexterm" data-primary="Unicode support" data-secondary="naming variables and constants" id="id810"/>Go’s definition of “letter” and “number” is a bit broader than many languages. Any Unicode character considered a letter or digit is allowed. This makes all the variable definitions in <a data-type="xref" href="#EX1">Example 2-5</a> perfectly valid Go.</p>
<div data-type="example" id="EX1">
<h5><span class="label">Example 2-5. </span>Variable names you should never use</h5>
<pre data-type="programlisting" data-code-language="go">
<code class="nx">_0</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="nx">_0</code><code class="w"/>
<code class="nx">_𝟙</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="nx">π</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="nx">ａ</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"hello"</code><code class="w"> </code><code class="c1">// Unicode U+FF41</code><code class="w"/>
<code class="nx">__</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"double underscore"</code><code class="w"> </code><code class="c1">// two underscores</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">_0</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">_𝟙</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">π</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ａ</code><code class="p">)</code><code class="w"/>
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">__</code><code class="p">)</code><code class="w"/>
</pre>
</div>

<p>You can test out this awful code on <a href="https://oreil.ly/VIYOk">The Go Playground</a>. While it works, <em>do not</em> use variable names like this. These names are considered nonidiomatic because they break the fundamental rule of making sure that your code communicates what it is doing. These names are confusing or difficult to type on many keyboards. Look-alike Unicode code points are the most insidious, because even if they appear to be the same character, they represent entirely different variables. You can run the code shown in <a data-type="xref" href="#EX2_10">Example 2-6</a> on <a href="https://oreil.ly/hrvb6">The Go Playground</a> or in the <em>sample_code/look_alike_code_points</em> directory in the <a href="https://oreil.ly/7nLfx">Chapter 2 repository</a>.</p>
<div data-type="example" id="EX2_10">
<h5><span class="label">Example 2-6. </span>Using look-alike code points for variable names</h5>
<pre data-type="programlisting" data-code-language="go">
<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">ａ</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"hello"</code><code class="w">   </code><code class="c1">// Unicode U+FF41</code><code class="w"/>
<code class="w">    </code><code class="nx">a</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"goodbye"</code><code class="w"> </code><code class="c1">// standard lowercase a (Unicode U+0061)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">ａ</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>
</pre>
</div>

<p>When you run this program, you get:</p>

<pre data-type="programlisting">hello
goodbye</pre>

<p>Even though the underscore<a data-type="indexterm" data-primary="naming variables and constants" data-secondary="camelCase instead of snake_case" id="id811"/><a data-type="indexterm" data-primary="camelCase instead of snake_case" id="id812"/><a data-type="indexterm" data-primary="variables" data-secondary="naming" data-tertiary="camelCase instead of snake_case" id="id813"/><a data-type="indexterm" data-primary="const keyword" data-secondary="naming constants" data-tertiary="camelCase instead of snake_case" id="id814"/><a data-type="indexterm" data-primary="underscore (_)" data-secondary="variable and constant names not using" id="id815"/><a data-type="indexterm" data-primary="_ (underscore)" data-secondary="variable and constant names not using" id="id816"/> is a valid character in a variable name, it is rarely used, because idiomatic Go doesn’t use snake case (names like <code>index_counter</code> or <code>number_tries</code>). Instead, idiomatic Go uses camel case (names like <code>indexCounter</code> or <code>numberTries</code>) when an identifier name consists of multiple words.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>An underscore by itself (<code>_</code>) is a special identifier name in Go; I’ll talk more about it when I cover functions in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>.</p>
</div>

<p>In many languages, constants are always written in all uppercase letters, with words separated by underscores (names like <code>INDEX_COUNTER</code> or <code>NUMBER_TRIES</code>). <a data-type="indexterm" data-primary="naming variables and constants" data-secondary="case of first letter in package-level declaration" id="id817"/><a data-type="indexterm" data-primary="const keyword" data-secondary="naming constants" data-tertiary="uppercase names not used" id="id818"/><a data-type="indexterm" data-primary="packages" data-secondary="case of first letter in package-level declaration" id="id819"/>Go does not follow this pattern. This is because Go uses the case of the first letter in the name of a package-level declaration to determine if the item is accessible outside the package. I will revisit this when I talk about packages in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>.</p>

<p>Within a function, favor <a data-type="indexterm" data-primary="naming variables and constants" data-secondary="smaller the scope, shorter the name" id="id820"/><a data-type="indexterm" data-primary="variables" data-secondary="naming" data-tertiary="smaller the scope, shorter the name" id="id821"/><a data-type="indexterm" data-primary="for statement" data-secondary="single-letter variable names" id="id822"/><a data-type="indexterm" data-primary="control structures" data-secondary="for statement" data-tertiary="single-letter variable names" id="id823"/>short variable names. <em>The smaller the scope for a variable, the shorter the name that’s used for it</em>. It is common in Go to see single-letter variable names used with <code>for</code> loops. For example, the names <code>k</code> and <code>v</code> (short for <em>key</em> and <em>value</em>) are used as the variable names in a <code>for-range</code> loop.  If you are using a standard <code>for</code> loop, <code>i</code> and <code>j</code> are common names for the index variable. There are other idiomatic ways to name variables of common types; I will mention them as I cover more parts of the standard library.</p>

<p>Some languages with weaker type systems encourage developers to include the expected type of the variable in the variable’s name. <a data-type="indexterm" data-primary="types" data-secondary="names of variables" id="id824"/>Since Go is strongly typed, you don’t need to do this to keep track of the underlying type. However, you may see Go code where the first letter of a type is used as the variable name (for example, <code>i</code> for integers or <code>f</code> for floats). When you define your own types, similar patterns apply, especially when naming receiver variables (which are covered in <a data-type="xref" href="ch07.html#methods">“Methods”</a>).</p>

<p>These short names serve two purposes. The first is that they eliminate repetitive typing, keeping your code shorter. Second, they serve as a check on how complicated your code is. If you find it hard to keep track of your short-named variables, your block of code is likely doing too much.</p>

<p>When naming variables<a data-type="indexterm" data-primary="package blocks" data-secondary="descriptive variable and constant names" id="id825"/> and constants in the package block, use more descriptive names. The type should still be excluded from the name, but since the scope is wider, you need a more complete name to clarify what the value represents.</p>

<p>For more discussion of Go naming recommendations, read the <a href="https://oreil.ly/6AUc_">Naming section of Google’s Go Style Decisions</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id31">
<h1>Exercises</h1>

<p>These exercises demonstrate the concepts discussed in the chapter. Solutions to these exercises, along with the programs in this chapter, are in the <a href="https://oreil.ly/nGUVd">Chapter 2 repository</a>.<a data-type="indexterm" data-startref="ix_bbbb" id="id826"/><a data-type="indexterm" data-startref="ix_bbb" id="id827"/></p>
<ol>
<li>
<p>Write a program that declares an integer variable called <code>i</code> with the value 20. Assign <code>i</code> to a floating-point variable named <code>f</code>. Print out <code>i</code> and <code>f</code>.</p>
</li>
<li>
<p>Write a program that declares a constant called <code>value</code> that can be assigned to both an integer and a floating-point variable. Assign it to an integer called <code>i</code> and a floating-point variable called <code>f</code>. Print out <code>i</code> and <code>f</code>.</p>
</li>
<li>
<p>Write a program with three variables, one named <code>b</code> of type <code>byte</code>, one named <code>smallI</code> of type <code>int32</code>, and one named <code>bigI</code> of type <code>uint64</code>. Assign each variable the maximum legal value for its type; then add <code>1</code> to each variable. Print out their values.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id340">
<h1>Wrapping Up</h1>

<p>You’ve covered a lot of ground here, understanding how to use the predeclared types, declare variables, and work with assignments and operators. In the next chapter, we will look at the composite types in Go: arrays, slices, maps, and structs. We will also take another look at strings and runes and how they interact with character encodings.</p>
</div></section>
</div></section></div>
</div>
</body></html>