["```go\ntype Context interface {\n    // Done returns a channel that's closed when this Context is cancelled.\n    Done() <-chan struct{}\n\n    // Err indicates why this context was cancelled after the Done channel is\n    // closed. If Done is not yet closed, Err returns nil.\n    Err() error\n\n    // Deadline returns the time when this Context should be cancelled; it\n    // returns ok==false if no deadline is set.\n    Deadline() (deadline time.Time, ok bool)\n\n    // Value returns the value associated with this context for key, or nil\n    // if no value is associated with key. Use with care.\n    Value(key interface{}) interface{}\n}\n```", "```go\nfunc Stream(ctx context.Context, out chan<- Value) error {\n    // Create a derived Context with a 10s timeout; dctx\n    // will be cancelled upon timeout, but ctx will not.\n    // cancel is a function that will explicitly cancel dctx.\n    dctx, cancel := context.WithTimeout(ctx, time.Second * 10)\n\n    // Release resources if SlowOperation completes before timeout\n    defer cancel()\n\n    res, err := SlowOperation(dctx)\n    if err != nil {                     // True if dctx times out\n        return err\n    }\n\n    for {\n        select {\n        case out <- res:                // Read from res; send to out\n\n        case <-ctx.Done():              // Triggered if ctx is cancelled\n            return ctx.Err()\n        }\n    }\n}\n```", "```go\ntype Circuit func(context.Context) (string, error)\n```", "```go\nfunc Breaker(circuit Circuit, failureThreshold uint) Circuit {\n    var consecutiveFailures int = 0\n    var lastAttempt = time.Now()\n    var m sync.RWMutex\n\n    return func(ctx context.Context) (string, error) {\n        m.RLock()                       // Establish a \"read lock\"\n\n        d := consecutiveFailures - int(failureThreshold)\n\n        if d >= 0 {\n            shouldRetryAt := lastAttempt.Add(time.Second * 2 << d)\n            if !time.Now().After(shouldRetryAt) {\n                m.RUnlock()\n                return \"\", errors.New(\"service unreachable\")\n            }\n        }\n\n        m.RUnlock()                     // Release read lock\n\n        response, err := circuit(ctx)   // Issue request proper\n\n        m.Lock()                        // Lock around shared resources\n        defer m.Unlock()\n\n        lastAttempt = time.Now()        // Record time of attempt\n\n        if err != nil {                 // Circuit returned an error,\n            consecutiveFailures++       // so we count the failure\n            return response, err        // and return\n        }\n\n        consecutiveFailures = 0         // Reset failures counter\n\n        return response, nil\n    }\n}\n```", "```go\ntype Circuit func(context.Context) (string, error)\n```", "```go\nfunc myFunction func(ctx context.Context) (string, error) { /* ... */ }\n\nwrapped := Breaker(Debounce(myFunction))\nresponse, err := wrapped(ctx)\n```", "```go\nfunc DebounceFirst(circuit Circuit, d time.Duration) Circuit {\n    var threshold time.Time\n    var result string\n    var err error\n    var m sync.Mutex\n\n    return func(ctx context.Context) (string, error) {\n        m.Lock()\n\n        defer func() {\n            threshold = time.Now().Add(d)\n            m.Unlock()\n        }()\n\n        if time.Now().Before(threshold) {\n            return result, err\n        }\n\n        result, err = circuit(ctx)\n\n        return result, err\n    }\n}\n```", "```go\ntype Circuit func(context.Context) (string, error)\n\nfunc DebounceLast(circuit Circuit, d time.Duration) Circuit {\n    var threshold time.Time = time.Now()\n    var ticker *time.Ticker\n    var result string\n    var err error\n    var once sync.Once\n    var m sync.Mutex\n\n    return func(ctx context.Context) (string, error) {\n        m.Lock()\n        defer m.Unlock()\n\n        threshold = time.Now().Add(d)\n\n        once.Do(func() {\n            ticker = time.NewTicker(time.Millisecond * 100)\n\n            go func() {\n                defer func() {\n                    m.Lock()\n                    ticker.Stop()\n                    once = sync.Once{}\n                    m.Unlock()\n                }()\n\n                for {\n                    select {\n                    case <-ticker.C:\n                        m.Lock()\n                        if time.Now().After(threshold) {\n                            result, err = circuit(ctx)\n                            m.Unlock()\n                            return\n                        }\n                        m.Unlock()\n                    case <-ctx.Done():\n                        m.Lock()\n                        result, err = \"\", ctx.Err()\n                        m.Unlock()\n                        return\n                    }\n                }\n            }()\n        })\n\n        return result, err\n    }\n}\n```", "```go\ntype Effector func(context.Context) (string, error)\n```", "```go\nfunc Retry(effector Effector, retries int, delay time.Duration) Effector {\n    return func(ctx context.Context) (string, error) {\n        for r := 0; ; r++ {\n            response, err := effector(ctx)\n            if err == nil || r >= retries {\n                return response, err\n            }\n\n            log.Printf(\"Attempt %d failed; retrying in %v\", r + 1, delay)\n\n            select {\n            case <-time.After(delay):\n            case <-ctx.Done():\n                return \"\", ctx.Err()\n            }\n        }\n    }\n}\n```", "```go\nvar count int\n\nfunc EmulateTransientError(ctx context.Context) (string, error) {\n    count++\n\n    if count <= 3 {\n        return \"intentional fail\", errors.New(\"error\")\n    } else {\n        return \"success\", nil\n    }\n}\n\nfunc main() {\n    r := Retry(EmulateTransientError, 5, 2*time.Second)\n\n    res, err := r(context.Background())\n\n    fmt.Println(res, err)\n}\n```", "```go\ntype Effector func(context.Context) (string, error)\n\nfunc Throttle(e Effector, max uint, refill uint, d time.Duration) Effector {\n    var tokens = max\n    var once sync.Once\n\n    return func(ctx context.Context) (string, error) {\n        if ctx.Err() != nil {\n            return \"\", ctx.Err()\n        }\n\n        once.Do(func() {\n            ticker := time.NewTicker(d)\n\n            go func() {\n                defer ticker.Stop()\n\n                for {\n                    select {\n                    case <-ctx.Done():\n                        return\n\n                    case <-ticker.C:\n                        t := tokens + refill\n                        if t > max {\n                            t = max\n                        }\n                        tokens = t\n                    }\n                }\n            }()\n        })\n\n        if tokens <= 0 {\n            return \"\", fmt.Errorf(\"too many calls\")\n        }\n\n        tokens--\n\n        return e(ctx)\n    }\n}\n```", "```go\nctx := context.Background()\nctxt, cancel := context.WithTimeout(ctx, 10 * time.Second)\ndefer cancel()\n\nresult, err := SomeFunction(ctxt)\n```", "```go\ntype SlowFunction func(string) (string, error)\n```", "```go\ntype WithContext func(context.Context, string) (string, error)\n\nfunc Timeout(f SlowFunction) WithContext {\n    return func(ctx context.Context, arg string) (string, error) {\n        chres := make(chan string)\n        cherr := make(chan error)\n\n        go func() {\n            res, err := f(arg)\n            chres <- res\n            cherr <- err\n        }()\n\n        select {\n        case res := <-chres:\n            return res, <-cherr\n        case <-ctx.Done():\n            return \"\", ctx.Err()\n        }\n    }\n}\n```", "```go\nfunc main() {\n    ctx := context.Background()\n    ctxt, cancel := context.WithTimeout(ctx, 1*time.Second)\n    defer cancel()\n\n    timeout := Timeout(Slow)\n    res, err := timeout(ctxt, \"some input\")\n\n    fmt.Println(res, err)\n}\n```", "```go\nfunc Funnel(sources ...<-chan int) <-chan int {\n    dest := make(chan int)                  // The shared output channel\n\n    var wg sync.WaitGroup                   // Used to automatically close dest\n                                            // when all sources are closed\n\n    wg.Add(len(sources))                    // Set size of the WaitGroup\n\n    for _, ch := range sources {            // Start a goroutine for each source\n        go func(c <-chan int) {\n            defer wg.Done()                 // Notify WaitGroup when c closes\n\n            for n := range c {\n                dest <- n\n            }\n        }(ch)\n    }\n\n    go func() {                             // Start a goroutine to close dest\n        wg.Wait()                           // after all sources close\n        close(dest)\n    }()\n\n    return dest\n}\n```", "```go\nfunc main() {\n    sources := make([]<-chan int, 0)        // Create an empty channel slice\n\n    for i := 0; i < 3; i++ {\n        ch := make(chan int)\n        sources = append(sources, ch)       // Create a channel; add to sources\n\n        go func() {                         // Run a toy goroutine for each\n            defer close(ch)                 // Close ch when the routine ends\n\n            for i := 1; i <= 5; i++ {\n                ch <- i\n                time.Sleep(time.Second)\n            }\n        }()\n    }\n\n    dest := Funnel(sources...)\n    for d := range dest {\n        fmt.Println(d)\n    }\n}\n```", "```go\nfunc Split(source <-chan int, n int) []<-chan int {\n    dests := make([]<-chan int, 0)          // Create the dests slice\n\n    for i := 0; i < n; i++ {                // Create n destination channels\n        ch := make(chan int)\n        dests = append(dests, ch)\n\n        go func() {                         // Each channel gets a dedicated\n            defer close(ch)                 // goroutine that competes for reads\n\n            for val := range source {\n                ch <- val\n            }\n        }()\n    }\n\n    return dests\n}\n```", "```go\nfunc main() {\n    source := make(chan int)                // The input channel\n    dests := Split(source, 5)               // Retrieve 5 output channels\n\n    go func() {                             // Send the number 1..10 to source\n        for i := 1; i <= 10; i++ {          // and close it when we're done\n            source <- i\n        }\n\n        close(source)\n    }()\n\n    var wg sync.WaitGroup                   // Use WaitGroup to wait until\n    wg.Add(len(dests))                      // the output channels all close\n\n    for i, ch := range dests {\n        go func(i int, d <-chan int) {\n            defer wg.Done()\n\n            for val := range d {\n                fmt.Printf(\"#%d got %d\\n\", i, val)\n            }\n        }(i, ch)\n    }\n\n    wg.Wait()\n}\n```", "```go\nfunc ConcurrentInverse(m Matrix) <-chan Matrix {\n    out := make(chan Matrix)\n\n    go func() {\n        out <- BlockingInverse(m)\n        close(out)\n    }()\n\n    return out\n}\n```", "```go\nfunc InverseProduct(a, b Matrix) Matrix {\n    inva := ConcurrentInverse(a)\n    invb := ConcurrentInverse(b)\n\n    return Product(<-inva, <-invb)\n}\n```", "```go\nreturn Product(<-ConcurrentInverse(a), <-ConcurrentInverse(b))\n```", "```go\ntype Future interface {\n    Result() (string, error)\n}\n```", "```go\ntype InnerFuture struct {\n    once sync.Once\n    wg   sync.WaitGroup\n\n    res   string\n    err   error\n    resCh <-chan string\n    errCh <-chan error\n}\n\nfunc (f *InnerFuture) Result() (string, error) {\n    f.once.Do(func() {\n        f.wg.Add(1)\n        defer f.wg.Done()\n        f.res = <-f.resCh\n        f.err = <-f.errCh\n    })\n\n    f.wg.Wait()\n\n    return f.res, f.err\n}\n```", "```go\nfunc SlowFunction(ctx context.Context) Future {\n    resCh := make(chan string)\n    errCh := make(chan error)\n\n    go func() {\n        select {\n        case <-time.After(time.Second * 2):\n            resCh <- \"I slept for 2 seconds\"\n            errCh <- nil\n        case <-ctx.Done():\n            resCh <- \"\"\n            errCh <- ctx.Err()\n        }\n    }()\n\n    return &InnerFuture{resCh: resCh, errCh: errCh}\n}\n```", "```go\nfunc main() {\n    ctx := context.Background()\n    future := SlowFunction(ctx)\n\n    res, err := future.Result()\n    if err != nil {\n        fmt.Println(\"error:\", err)\n        return\n    }\n\n    fmt.Println(res)\n}\n```", "```go\nvar items = struct{                                 // Struct with a map and a\n    sync.RWMutex                                    // composed sync.RWMutex\n    m map[string]int\n}{m: make(map[string]int)}\n\nfunc ThreadSafeRead(key string) int {\n    items.RLock()                                   // Establish read lock\n    value := items.m[key]\n    items.RUnlock()                                 // Release read lock\n    return value\n}\n\nfunc ThreadSafeWrite(key string, value int) {\n    items.Lock()                                    // Establish write lock\n    items.m[key] = value\n    items.Unlock()                                  // Release write lock\n}\n```", "```go\ntype Shard struct {\n    sync.RWMutex                            // Compose from sync.RWMutex\n    m map[string]interface{}                // m contains the shard's data\n}\n\ntype ShardedMap []*Shard                    // ShardedMap is a *Shards slice\n```", "```go\nfunc NewShardedMap(nshards int) ShardedMap {\n    shards := make([]*Shard, nshards)       // Initialize a *Shards slice\n\n    for i := 0; i < nshards; i++ {\n        shard := make(map[string]interface{})\n        shards[i] = &Shard{m: shard}\n    }\n\n    return shards                           // A ShardedMap IS a *Shards slice!\n}\n```", "```go\nfunc (m ShardedMap) getShardIndex(key string) int {\n    checksum := sha1.Sum([]byte(key))   // Use Sum from \"crypto/sha1\"\n    hash := int(checksum[17])           // Pick an arbitrary byte as the hash\n    return hash % len(m)                // Mod by len(m) to get index\n}\n\nfunc (m ShardedMap) getShard(key string) *Shard {\n    index := m.getShardIndex(key)\n    return m[index]\n}\n```", "```go\nfunc (m ShardedMap) Get(key string) interface{} {\n    shard := m.getShard(key)\n    shard.RLock()\n    defer shard.RUnlock()\n\n    return shard.m[key]\n}\n\nfunc (m ShardedMap) Set(key string, value interface{}) {\n    shard := m.getShard(key)\n    shard.Lock()\n    defer shard.Unlock()\n\n    shard.m[key] = value\n}\n```", "```go\nfunc (m ShardedMap) Keys() []string {\n    keys := make([]string, 0)               // Create an empty keys slice\n\n    mutex := sync.Mutex{}                   // Mutex for write safety to keys\n\n    wg := sync.WaitGroup{}                  // Create a wait group and add a\n    wg.Add(len(m))                          // wait value for each slice\n\n    for _, shard := range m {               // Run a goroutine for each slice\n        go func(s *Shard) {\n            s.RLock()                       // Establish a read lock on s\n\n            for key := range s.m {          // Get the slice's keys\n                mutex.Lock()\n                keys = append(keys, key)\n                mutex.Unlock()\n            }\n\n            s.RUnlock()                     // Release the read lock\n            wg.Done()                       // Tell the WaitGroup it's done\n        }(shard)\n    }\n\n    wg.Wait()                               // Block until all reads are done\n\n    return keys                             // Return combined keys slice\n}\n```", "```go\nfunc main() {\n    shardedMap := NewShardedMap(5)\n\n    shardedMap.Set(\"alpha\", 1)\n    shardedMap.Set(\"beta\", 2)\n    shardedMap.Set(\"gamma\", 3)\n\n    fmt.Println(shardedMap.Get(\"alpha\"))\n    fmt.Println(shardedMap.Get(\"beta\"))\n    fmt.Println(shardedMap.Get(\"gamma\"))\n\n    keys := shardedMap.Keys()\n    for _, k := range keys {\n        fmt.Println(k)\n    }\n}\n```"]