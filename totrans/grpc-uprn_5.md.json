["```go\nfunc(ctx context.Context, req interface{}, info *UnaryServerInfo,\n\t                     handler UnaryHandler) (resp interface{}, err error)\n```", "```go\n// Server - Unary Interceptor func orderUnaryServerInterceptor(ctx context.Context, req interface{},\n                             info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)\n                             (interface{}, error) {\n\n\t// Preprocessing logic \t// Gets info about the current RPC call by examining the args passed in \tlog.Println(\"======= [Server Interceptor] \", info.FullMethod) ![1](assets/1.png)\n\n\t// Invoking the handler to complete the normal execution of a unary RPC. \tm, err := handler(ctx, req) ![2](assets/2.png)\n\n\t// Post processing logic \tlog.Printf(\" Post Proc Message : %s\", m) ![3](assets/3.png)\n\treturn m, err ![4](assets/4.png)\n}\n\n// ... \nfunc main() {\n\n...\n     // Registering the Interceptor at the server-side. \ts := grpc.NewServer(\n\t\tgrpc.UnaryInterceptor(orderUnaryServerInterceptor)) ![5](assets/5.png)\n...\n```", "```go\nfunc(srv interface{}, ss ServerStream, info *StreamServerInfo,\n                                     handler StreamHandler) error\n```", "```go\n// Server - Streaming Interceptor // wrappedStream wraps around the embedded grpc.ServerStream, // and intercepts the RecvMsg and SendMsg method call. \ntype wrappedStream struct { ![1](assets/1.png)\n\tgrpc.ServerStream\n}\n\n![2](assets/2.png)\nfunc (w *wrappedStream) RecvMsg(m interface{}) error {\n\tlog.Printf(\"====== [Server Stream Interceptor Wrapper] \" +\n\t\t\"Receive a message (Type: %T) at %s\",\n\t\tm, time.Now().Format(time.RFC3339))\n\treturn w.ServerStream.RecvMsg(m)\n}\n\n![3](assets/3.png)\nfunc (w *wrappedStream) SendMsg(m interface{}) error {\n\tlog.Printf(\"====== [Server Stream Interceptor Wrapper] \" +\n\t\t\"Send a message (Type: %T) at %v\",\n\t\tm, time.Now().Format(time.RFC3339))\n\treturn w.ServerStream.SendMsg(m)\n}\n\n![4](assets/4.png)\nfunc newWrappedStream(s grpc.ServerStream) grpc.ServerStream {\n\treturn &wrappedStream{s}\n}\n\n![5](assets/5.png)\nfunc orderServerStreamInterceptor(srv interface{},\n        ss grpc.ServerStream, info *grpc.StreamServerInfo,\n        handler grpc.StreamHandler) error {\n\tlog.Println(\"====== [Server Stream Interceptor] \",\n\t\tinfo.FullMethod) ![6](assets/6.png)\n\terr := handler(srv, newWrappedStream(ss)) ![7](assets/7.png)\n\tif err != nil {\n\t\tlog.Printf(\"RPC failed with error %v\", err)\n\t}\n\treturn err\n}\n\n...\n// Registering the interceptor s := grpc.NewServer(\n\t\tgrpc.StreamInterceptor(orderServerStreamInterceptor)) ![8](assets/8.png)\n\n…\n```", "```go\n[Server Stream Interceptor]  /ecommerce.OrderManagement/searchOrders\n[Server Stream Interceptor Wrapper] Receive a message\n\nMatching Order Found : 102 -> Writing Order to the stream ...\n[Server Stream Interceptor Wrapper] Send a message...\nMatching Order Found : 104 -> Writing Order to the stream ...\n[Server Stream Interceptor Wrapper] Send a message...\n```", "```go\nfunc(ctx context.Context, method string, req, reply interface{},\n         cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error\n```", "```go\nfunc orderUnaryClientInterceptor(\n\tctx context.Context, method string, req, reply interface{},\n\tcc *grpc.ClientConn,\n\tinvoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {\n\t// Preprocessor phase \tlog.Println(\"Method : \" + method) ![1](assets/1.png)\n\n\t// Invoking the remote method \terr := invoker(ctx, method, req, reply, cc, opts...) ![2](assets/2.png)\n\n\t// Postprocessor phase \tlog.Println(reply) ![3](assets/3.png)\n\n\treturn err ![4](assets/4.png)\n}\n...\n\nfunc main() {\n\t// Setting up a connection to the server. \tconn, err := grpc.Dial(address, grpc.WithInsecure(),\n\t\tgrpc.WithUnaryInterceptor(orderUnaryClientInterceptor)) ![5](assets/5.png)\n...\n```", "```go\nfunc(ctx context.Context, desc *StreamDesc, cc *ClientConn,\n                                      method string, streamer Streamer,\n                                      opts ...CallOption) (ClientStream, error)\n```", "```go\nfunc clientStreamInterceptor(\n\tctx context.Context, desc *grpc.StreamDesc,\n\tcc *grpc.ClientConn, method string,\n\tstreamer grpc.Streamer, opts ...grpc.CallOption)\n        (grpc.ClientStream, error) {\n\tlog.Println(\"======= [Client Interceptor] \", method) ![1](assets/1.png)\n\ts, err := streamer(ctx, desc, cc, method, opts...) ![2](assets/2.png)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newWrappedStream(s), nil ![3](assets/3.png)\n}\n\ntype wrappedStream struct { ![4](assets/4.png)\n\tgrpc.ClientStream\n}\n\nfunc (w *wrappedStream) RecvMsg(m interface{}) error { ![5](assets/5.png)\n\tlog.Printf(\"====== [Client Stream Interceptor] \" +\n\t\t\"Receive a message (Type: %T) at %v\",\n\t\tm, time.Now().Format(time.RFC3339))\n\treturn w.ClientStream.RecvMsg(m)\n}\n\nfunc (w *wrappedStream) SendMsg(m interface{}) error { ![6](assets/6.png)\n\tlog.Printf(\"====== [Client Stream Interceptor] \" +\n\t\t\"Send a message (Type: %T) at %v\",\n\t\tm, time.Now().Format(time.RFC3339))\n\treturn w.ClientStream.SendMsg(m)\n}\n\nfunc newWrappedStream(s grpc.ClientStream) grpc.ClientStream {\n\treturn &wrappedStream{s}\n}\n\n...\n\nfunc main() {\n\t// Setting up a connection to the server. \tconn, err := grpc.Dial(address, grpc.WithInsecure(),\n\t\tgrpc.WithStreamInterceptor(clientStreamInterceptor)) ![7](assets/7.png)\n...\n```", "```go\nconn, err := grpc.Dial(address, grpc.WithInsecure())\nif err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n}\ndefer conn.Close()\nclient := pb.NewOrderManagementClient(conn)\n\nclientDeadline := time.Now().Add(\n    time.Duration(2 * time.Second))\nctx, cancel := context.WithDeadline(\n    context.Background(), clientDeadline) ![1](assets/1.png)\n\ndefer cancel()\n\n// Add Order order1 := pb.Order{Id: \"101\",\n    Items:[]string{\"iPhone XS\", \"Mac Book Pro\"},\n    Destination:\"San Jose, CA\",\n    Price:2300.00}\nres, addErr := client.AddOrder(ctx, &order1) ![2](assets/2.png)\n\nif addErr != nil {\n    got := status.Code(addErr) ![3](assets/3.png)\n    log.Printf(\"Error Occured -> addOrder : , %v:\", got) ![4](assets/4.png)\n} else {\n    log.Print(\"AddOrder Response -> \", res.Value)\n}\n```", "```go\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) ![1](assets/1.png)\n\nstreamProcOrder, _ := client.ProcessOrders(ctx) ![2](assets/2.png)\n_ = streamProcOrder.Send(&wrapper.StringValue{Value:\"102\"}) ![3](assets/3.png)\n_ = streamProcOrder.Send(&wrapper.StringValue{Value:\"103\"})\n_ = streamProcOrder.Send(&wrapper.StringValue{Value:\"104\"})\n\nchannel := make(chan bool, 1)\n\ngo asncClientBidirectionalRPC(streamProcOrder, channel)\ntime.Sleep(time.Millisecond * 1000)\n\n// Canceling the RPC cancel() ![4](assets/4.png)\nlog.Printf(\"RPC Status : %s\", ctx.Err()) ![5](assets/5.png)\n\n_ = streamProcOrder.Send(&wrapper.StringValue{Value:\"101\"})\n_ = streamProcOrder.CloseSend()\n\n<- channel\n\nfunc asncClientBidirectionalRPC (\n    streamProcOrder pb.OrderManagement_ProcessOrdersClient, c chan bool) {\n...\n\t\tcombinedShipment, errProcOrder := streamProcOrder.Recv()\n\t\tif errProcOrder != nil {\n\t\t\tlog.Printf(\"Error Receiving messages %v\", errProcOrder) ![6](assets/6.png)\n...\n}\n```", "```go\nif orderReq.Id == \"-1\" { ![1](assets/1.png)\n    log.Printf(\"Order ID is invalid! -> Received Order ID %s\",\n        orderReq.Id)\n\n    errorStatus := status.New(codes.InvalidArgument,\n        \"Invalid information received\") ![2](assets/2.png)\n    ds, err := errorStatus.WithDetails( ![3](assets/3.png)\n        &epb.BadRequest_FieldViolation{\n            Field:\"ID\",\n            Description: fmt.Sprintf(\n                \"Order ID received is not valid %s : %s\",\n                orderReq.Id, orderReq.Description),\n        },\n    )\n    if err != nil {\n        return nil, errorStatus.Err()\n    }\n\n    return nil, ds.Err() ![4](assets/4.png)\n    }\n    ...\n```", "```go\norder1 := pb.Order{Id: \"-1\",\n\tItems:[]string{\"iPhone XS\", \"Mac Book Pro\"},\n\tDestination:\"San Jose, CA\", Price:2300.00} ![1](assets/1.png)\nres, addOrderError := client.AddOrder(ctx, &order1) ![2](assets/2.png)\n\nif addOrderError != nil {\n\terrorCode := status.Code(addOrderError) ![3](assets/3.png)\n\tif errorCode == codes.InvalidArgument { ![4](assets/4.png)\n\t\tlog.Printf(\"Invalid Argument Error : %s\", errorCode)\n\t\terrorStatus := status.Convert(addOrderError) ![5](assets/5.png)\n\t\tfor _, d := range errorStatus.Details() {\n\t\t\tswitch info := d.(type) {\n\t\t\tcase *epb.BadRequest_FieldViolation: ![6](assets/6.png)\n\t\t\t\tlog.Printf(\"Request Field Invalid: %s\", info)\n\t\t\tdefault:\n\t\t\t\tlog.Printf(\"Unexpected error type: %s\", info)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog.Printf(\"Unhandled error : %s \", errorCode)\n\t}\n} else {\n\tlog.Print(\"AddOrder Response -> \", res.Value)\n}\n```", "```go\nfunc main() {\n\tinitSampleData()\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\tgrpcServer := grpc.NewServer() ![1](assets/1.png)\n\n\t// Register Order Management service on gRPC orderMgtServer \tordermgt_pb.RegisterOrderManagementServer(grpcServer, &orderMgtServer{}) ![2](assets/2.png)\n\n\t// Register Greeter Service on gRPC orderMgtServer \thello_pb.RegisterGreeterServer(grpcServer, &helloServer{}) ![3](assets/3.png)\n\n      ...\n}\n```", "```go\n// Setting up a connection to the server. conn, err := grpc.Dial(address, grpc.WithInsecure()) ![1](assets/1.png)\n...\n\norderManagementClient := pb.NewOrderManagementClient(conn) ![2](assets/2.png)\n\n...\n\n// Add Order RPC \t...\nres, addErr := orderManagementClient.AddOrder(ctx, &order1)\n\n...\n\nhelloClient := hwpb.NewGreeterClient(conn) ![3](assets/3.png)\n\n\t...\n\t// Say hello RPC helloResponse, err := helloClient.SayHello(hwcCtx,\n\t&hwpb.HelloRequest{Name: \"gRPC Up and Running!\"})\n...\n```", "```go\n// Metadata Creation : option I\nmd := metadata.New(map[string]string{\"key1\": \"val1\", \"key2\": \"val2\"})\n\n// Metadata Creation : option II\nmd := metadata.Pairs(\n    \"key1\", \"val1\",\n    \"key1\", \"val1-2\", // \"key1\" will have map value []string{\"val1\", \"val1-2\"}\n    \"key2\", \"val2\",\n)\n```", "```go\nfunc (s *server) AddOrder(ctx context.Context, orderReq *pb.Order)\n    (*wrappers.StringValue, error) {\n\nmd, metadataAvailable := metadata.FromIncomingContext(ctx)\n// read the required metadata from the ‘md’ metadata map.\n```", "```go\nmd := metadata.Pairs(\n\t\"timestamp\", time.Now().Format(time.StampNano),\n\t\"kn\", \"vn\",\n) ![1](assets/1.png)\nmdCtx := metadata.NewOutgoingContext(context.Background(), md) ![2](assets/2.png)\n\nctxA := metadata.AppendToOutgoingContext(mdCtx,\n      \"k1\", \"v1\", \"k1\", \"v2\", \"k2\", \"v3\") ![3](assets/3.png)\n\n// make unary RPC response, err := client.SomeRPC(ctxA, someRequest) ![4](assets/4.png)\n\n// or make streaming RPC stream, err := client.SomeStreamingRPC(ctxA) ![5](assets/5.png)\n```", "```go\nvar header, trailer metadata.MD ![1](assets/1.png)\n\n// ***** Unary RPC ***** \nr, err := client.SomeRPC( ![2](assets/2.png)\n    ctx,\n    someRequest,\n    grpc.Header(&header),\n    grpc.Trailer(&trailer),\n)\n\n// process header and trailer map here. \n// ***** Streaming RPC ***** \nstream, err := client.SomeStreamingRPC(ctx)\n\n// retrieve header header, err := stream.Header() ![3](assets/3.png)\n\n// retrieve trailer trailer := stream.Trailer() ![4](assets/4.png)\n\n// process header and trailer map here.\n```", "```go\nfunc (s *server) SomeRPC(ctx context.Context,\n    in *pb.someRequest) (*pb.someResponse, error) { ![1](assets/1.png)\n    md, ok := metadata.FromIncomingContext(ctx) ![2](assets/2.png)\n    // do something with metadata }\n\nfunc (s *server) SomeStreamingRPC(\n    stream pb.Service_SomeStreamingRPCServer) error { ![3](assets/3.png)\n    md, ok := metadata.FromIncomingContext(stream.Context()) ![4](assets/4.png)\n    // do something with metadata }\n```", "```go\nfunc (s *server) SomeRPC(ctx context.Context,\n    in *pb.someRequest) (*pb.someResponse, error) {\n    // create and send header\n    header := metadata.Pairs(\"header-key\", \"val\")\n    grpc.SendHeader(ctx, header) ![1](assets/1.png)\n    // create and set trailer\n    trailer := metadata.Pairs(\"trailer-key\", \"val\")\n    grpc.SetTrailer(ctx, trailer) ![2](assets/2.png)\n}\n\nfunc (s *server) SomeStreamingRPC(stream pb.Service_SomeStreamingRPCServer) error {\n    // create and send header\n    header := metadata.Pairs(\"header-key\", \"val\")\n    stream.SendHeader(header) ![3](assets/3.png)\n    // create and set trailer\n    trailer := metadata.Pairs(\"trailer-key\", \"val\")    stream.SetTrailer(trailer) ![4](assets/4.png)\n}\n```", "```go\ntype exampleResolverBuilder struct{} ![1](assets/1.png)\n\nfunc (*exampleResolverBuilder) Build(target resolver.Target,\n\tcc resolver.ClientConn,\n\topts resolver.BuildOption) (resolver.Resolver, error) {\n\n\tr := &exampleResolver{ ![2](assets/2.png)\n\t\ttarget: target,\n\t\tcc:     cc,\n\t\taddrsStore: map[string][]string{\n           exampleServiceName: addrs, ![3](assets/3.png)\n\t\t},\n\t}\n\tr.start()\n\treturn r, nil\n}\nfunc (*exampleResolverBuilder) Scheme() string { return exampleScheme } ![4](assets/4.png)\n\ntype exampleResolver struct { ![5](assets/5.png)\n\ttarget     resolver.Target\n\tcc         resolver.ClientConn\n\taddrsStore map[string][]string\n}\n\nfunc (r *exampleResolver) start() {\n\taddrStrs := r.addrsStore[r.target.Endpoint]\n\taddrs := make([]resolver.Address, len(addrStrs))\n\tfor i, s := range addrStrs {\n\t\taddrs[i] = resolver.Address{Addr: s}\n\t}\n\tr.cc.UpdateState(resolver.State{Addresses: addrs})\n}\nfunc (*exampleResolver) ResolveNow(o resolver.ResolveNowOption) {}\nfunc (*exampleResolver) Close()                                 {}\n\nfunc init() {\n\tresolver.Register(&exampleResolverBuilder{})\n}\n```", "```go\npickfirstConn, err := grpc.Dial(\n\t\tfmt.Sprintf(\"%s:///%s\",\n        // \texampleScheme      = \"example\"\n        //\texampleServiceName = \"lb.example.grpc.io\"\n        exampleScheme, exampleServiceName), ![1](assets/1.png)\n        // \"pick_first\" is the default option. ![2](assets/2.png)\n\t\tgrpc.WithBalancerName(\"pick_first\"),\n\n\t\tgrpc.WithInsecure(),)\nif err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n}\ndefer pickfirstConn.Close()\n\nlog.Println(\"==== Calling helloworld.Greeter/SayHello \" +\n\t\"with pick_first ====\")\nmakeRPCs(pickfirstConn, 10)\n\n// Make another ClientConn with round_robin policy. roundrobinConn, err := grpc.Dial(\n    fmt.Sprintf(\"%s:///%s\", exampleScheme, exampleServiceName),\n    // \"example:///lb.example.grpc.io\"\n    grpc.WithBalancerName(\"round_robin\"), ![3](assets/3.png)\n    grpc.WithInsecure(),\n)\nif err != nil {\n    log.Fatalf(\"did not connect: %v\", err)\n}\ndefer roundrobinConn.Close()\n\nlog.Println(\"==== Calling helloworld.Greeter/SayHello \" +\n\t\"with round_robin ====\")\nmakeRPCs(roundrobinConn, 10)\n```"]