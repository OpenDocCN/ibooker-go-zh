["```go\nfunc TestServer_AddProduct(t *testing.T) { ![1](assets/1.png)\n\tgrpcServer := initGRPCServerHTTP2() ![2](assets/2.png)\n\tconn, err := grpc.Dial(address, grpc.WithInsecure()) ![3](assets/3.png)\n\tif err != nil {\n\n           grpcServer.Stop()\n           t.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewProductInfoClient(conn)\n\n\tname := \"Sumsung S10\"\n\tdescription := \"Samsung Galaxy S10 is the latest smart phone, launched in\n\tFebruary 2019\"\n\tprice := float32(700.0)\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.AddProduct(ctx, &pb.Product{Name: name,\n\t                                Description: description, Price: price}) ![4](assets/4.png)\n\tif err != nil { ![5](assets/5.png)\n\t\tt.Fatalf(\"Could not add product: %v\", err)\n\t}\n\n\tif r.Value == \"\" {\n\t\tt.Errorf(\"Invalid Product ID %s\", r.Value)\n\t}\n\tlog.Printf(\"Res %s\", r.Value)\n      grpcServer.Stop()\n}\n```", "```go\nmockgen github.com/grpc-up-and-running/samples/ch07/grpc-docker/go/proto-gen \\\nProductInfoClient > mock_prodinfo/prodinfo_mock.go\n```", "```go\nfunc TestAddProduct(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\tmocklProdInfoClient := NewMockProductInfoClient(ctrl) ![1](assets/1.png)\n     ...\n\treq := &pb.Product{Name: name, Description: description, Price: price}\n\n\tmocklProdInfoClient. ![2](assets/2.png)\n\t EXPECT().AddProduct(gomock.Any(), &rpcMsg{msg: req},). ![3](assets/3.png)\n\t Return(&wrapper.StringValue{Value: \"ABC123\" + name}, nil) ![4](assets/4.png)\n\n\ttestAddProduct(t, mocklProdInfoClient) ![5](assets/5.png)\n}\n\nfunc testAddProduct(t *testing.T, client pb.ProductInfoClient) {\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\t...\n\n\tr, err := client.AddProduct(ctx, &pb.Product{Name: name,\n    Description: description, Price: price})\n\n\t// test and verify response. }\n```", "```go\nghz --insecure \\\n  --proto ./greeter.proto \\\n  --call helloworld.Greeter.SayHello \\\n  -d '{\"name\":\"Joe\"}'\\\n  -n 2000 \\\n  -c 20 \\\n\n  0.0.0.0:50051\n```", "```go\n# Multistage build \n# Build stage I: ![1](assets/1.png)\nFROM golang AS build\nENV location /go/src/github.com/grpc-up-and-running/samples/ch07/grpc-docker/go\nWORKDIR ${location}/server\n\nADD ./server ${location}/server\nADD ./proto-gen ${location}/proto-gen\n\nRUN go get -d ./... ![2](assets/2.png)\nRUN go install ./... ![3](assets/3.png)\n\nRUN CGO_ENABLED=0 go build -o /bin/grpc-productinfo-server ![4](assets/4.png)\n\n# Build stage II: ![5](assets/5.png)\nFROM scratch\nCOPY --from=build /bin/grpc-productinfo-server /bin/grpc-productinfo-server ![6](assets/6.png)\n\nENTRYPOINT [\"/bin/grpc-productinfo-server\"]\nEXPOSE 50051\n```", "```go\ndocker image build -t grpc-productinfo-server -f server/Dockerfile\n```", "```go\nconn, err := grpc.Dial(\"productinfo:50051\", grpc.WithInsecure())\n```", "```go\ndocker run -it --network=my-net --name=productinfo \\\n    --hostname=productinfo\n    -p 50051:50051  grpc-productinfo-server ![1](assets/1.png)\n\ndocker run -it --network=my-net \\\n    --hostname=client grpc-productinfo-client ![2](assets/2.png)\n```", "```go\napiVersion: apps/v1\nkind: Deployment ![1](assets/1.png)\nmetadata:\n  name: grpc-productinfo-server ![2](assets/2.png)\nspec:\n  replicas: 1 ![3](assets/3.png)\n  selector:\n    matchLabels:\n      app: grpc-productinfo-server\n  template:\n    metadata:\n      labels:\n        app: grpc-productinfo-server\n    spec:\n      containers:\n      - name: grpc-productinfo-server ![4](assets/4.png)\n        image: kasunindrasiri/grpc-productinfo-server ![5](assets/5.png)\n        resources:\n          limits:\n            memory: \"128Mi\"\n            cpu: \"500m\"\n        ports:\n        - containerPort: 50051\n          name: grpc\n```", "```go\napiVersion: v1\nkind: Service ![1](assets/1.png)\nmetadata:\n  name: productinfo ![2](assets/2.png)\nspec:\n  selector:\n    app: grpc-productinfo-server ![3](assets/3.png)\n  ports:\n  - port: 50051 ![4](assets/4.png)\n    targetPort: 50051\n    name: grpc\n  type: NodePort\n```", "```go\napiVersion: batch/v1\nkind: Job ![1](assets/1.png)\nmetadata:\n  name: grpc-productinfo-client ![2](assets/2.png)\nspec:\n  completions: 1 ![3](assets/3.png)\n  parallelism: 1 ![4](assets/4.png)\n  template:\n    spec:\n      containers:\n      - name: grpc-productinfo-client ![5](assets/5.png)\n        image: kasunindrasiri/grpc-productinfo-client ![6](assets/6.png)\n      restartPolicy: Never\n  backoffLimit: 4\n```", "```go\napiVersion: extensions/v1beta1\nkind: Ingress ![1](assets/1.png)\nmetadata:\n  annotations: ![2](assets/2.png)\n    kubernetes.io/ingress.class: \"nginx\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"false\"\n    nginx.ingress.kubernetes.io/backend-protocol: \"GRPC\"\n  name: grpc-prodinfo-ingress ![3](assets/3.png)\nspec:\n  rules:\n  - host: productinfo ![4](assets/4.png)\n    http:\n      paths:\n      - backend:\n          serviceName: productinfo ![5](assets/5.png)\n          servicePort: grpc ![6](assets/6.png)\n```", "```go\npackage main\n\nimport (\n  \"errors\"\n  \"log\"\n  \"net\"\n  \"net/http\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"go.opencensus.io/plugin/ocgrpc\" ![1](assets/1.png)\n  \"go.opencensus.io/stats/view\"\n  \"go.opencensus.io/zpages\"\n  \"go.opencensus.io/examples/exporter\"\n)\n\nconst (\n  port = \":50051\"\n)\n\n// server is used to implement ecommerce/product_info. type server struct {\n  productMap map[string]*pb.Product\n}\n\nfunc main() {\n\n  go func() { ![7](assets/7.png)\n     mux := http.NewServeMux()\n     zpages.Handle(mux, \"/debug\")\n     log.Fatal(http.ListenAndServe(\"127.0.0.1:8081\", mux))\n  }()\n\n   view.RegisterExporter(&exporter.PrintExporter{}) ![2](assets/2.png)\n\n  if err := view.Register(ocgrpc.DefaultServerViews...); err != nil { ![3](assets/3.png)\n     log.Fatal(err)\n  }\n\n  grpcServer := grpc.NewServer(grpc.StatsHandler(&ocgrpc.ServerHandler{})) ![4](assets/4.png)\n  pb.RegisterProductInfoServer(grpcServer, &server{}) ![5](assets/5.png)\n\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n     log.Fatalf(\"Failed to listen: %v\", err)\n  }\n\n  if err := grpcServer.Serve(lis); err != nil { ![6](assets/6.png)\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  pb \"productinfo/server/ecommerce\"\n  \"google.golang.org/grpc\"\n  \"go.opencensus.io/plugin/ocgrpc\" ![1](assets/1.png)\n  \"go.opencensus.io/stats/view\"\n  \"go.opencensus.io/examples/exporter\"\n)\n\nconst (\n  address = \"localhost:50051\"\n)\n\nfunc main() {\n  view.RegisterExporter(&exporter.PrintExporter{}) ![2](assets/2.png)\n\n   if err := view.Register(ocgrpc.DefaultClientViews...); err != nil { ![3](assets/3.png)\n       log.Fatal(err)\n   }\n\n  conn, err := grpc.Dial(address, ![4](assets/4.png)\n        grpc.WithStatsHandler(&ocgrpc.ClientHandler{}),\n          grpc.WithInsecure(),\n          )\n  if err != nil {\n     log.Fatalf(\"Can't connect: %v\", err)\n  }\n  defer conn.Close() ![6](assets/6.png)\n\n  c := pb.NewProductInfoClient(conn) ![5](assets/5.png)\n\n  .... // Skip RPC method invocation. }\n```", "```go\npackage main\n\nimport (\n  ...\n  \"github.com/grpc-ecosystem/go-grpc-prometheus\" ![1](assets/1.png)\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n  reg = prometheus.NewRegistry() ![2](assets/2.png)\n\n  grpcMetrics = grpc_prometheus.NewServerMetrics() ![3](assets/3.png)\n\n   customMetricCounter = prometheus.NewCounterVec(prometheus.CounterOpts{\n       Name: \"product_mgt_server_handle_count\",\n       Help: \"Total number of RPCs handled on the server.\",\n   }, []string{\"name\"}) ![4](assets/4.png)\n)\n\nfunc init() {\n   reg.MustRegister(grpcMetrics, customMetricCounter) ![5](assets/5.png)\n}\n\nfunc main() {\n  lis, err := net.Listen(\"tcp\", port)\n  if err != nil {\n     log.Fatalf(\"failed to listen: %v\", err)\n  }\n\n  httpServer := &http.Server{\n      Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),\n        Addr:  fmt.Sprintf(\"0.0.0.0:%d\", 9092)} ![6](assets/6.png)\n\n  grpcServer := grpc.NewServer(\n     grpc.UnaryInterceptor(grpcMetrics.UnaryServerInterceptor()), ![7](assets/7.png)\n  )\n\n  pb.RegisterProductInfoServer(grpcServer, &server{})\n  grpcMetrics.InitializeMetrics(grpcServer) ![8](assets/8.png)\n\n  // Start your http server for prometheus.\n  go func() {\n     if err := httpServer.ListenAndServe(); err != nil {\n        log.Fatal(\"Unable to start a http server.\")\n     }\n  }()\n\n  if err := grpcServer.Serve(lis); err != nil {\n     log.Fatalf(\"failed to serve: %v\", err)\n  }\n}\n```", "```go\n// AddProduct implements ecommerce.AddProduct\nfunc (s *server) AddProduct(ctx context.Context,\n     in *pb.Product) (*wrapper.StringValue, error) {\n     customMetricCounter.WithLabelValues(in.Name).Inc()\n  ...\n}\n```", "```go\npackage main\n\nimport (\n  ...\n  \"github.com/grpc-ecosystem/go-grpc-prometheus\" ![1](assets/1.png)\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nconst (\n  address = \"localhost:50051\"\n)\n\nfunc main() {\n  reg := prometheus.NewRegistry() ![2](assets/2.png)\n  grpcMetrics := grpc_prometheus.NewClientMetrics() ![3](assets/3.png)\n  reg.MustRegister(grpcMetrics) ![4](assets/4.png)\n\n  conn, err := grpc.Dial(address,\n        grpc.WithUnaryInterceptor(grpcMetrics.UnaryClientInterceptor()), ![5](assets/5.png)\n          grpc.WithInsecure(),\n          )\n  if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n\n   // Create a HTTP server for prometheus.\n   httpServer := &http.Server{\n        Handler: promhttp.HandlerFor(reg, promhttp.HandlerOpts{}),\n          Addr: fmt.Sprintf(\"0.0.0.0:%d\", 9094)} ![6](assets/6.png)\n\n   // Start your http server for prometheus.\n   go func() {\n       if err := httpServer.ListenAndServe(); err != nil {\n           log.Fatal(\"Unable to start a http server.\")\n       }\n   }()\n\n  c := pb.NewProductInfoClient(conn)\n  ...\n}\n```", "```go\npackage tracer\n\nimport (\n  \"log\"\n\n  \"go.opencensus.io/trace\" ![1](assets/1.png)\n  \"contrib.go.opencensus.io/exporter/jaeger\"\n\n)\n\nfunc initTracing() {\n\n   trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})\n   agentEndpointURI := \"localhost:6831\"\n   collectorEndpointURI := \"http://localhost:14268/api/traces\" ![2](assets/2.png)\n    exporter, err := jaeger.NewExporter(jaeger.Options{\n            CollectorEndpoint: collectorEndpointURI,\n            AgentEndpoint: agentEndpointURI,\n            ServiceName:    \"product_info\",\n\n    })\n    if err != nil {\n       log.Fatal(err)\n    }\n    trace.RegisterExporter(exporter) ![3](assets/3.png)\n\n}\n```", "```go\n// GetProduct implements ecommerce.GetProduct func (s *server) GetProduct(ctx context.Context, in *wrapper.StringValue) (\n         *pb.Product, error) {\n  ctx, span := trace.StartSpan(ctx, \"ecommerce.GetProduct\") ![1](assets/1.png)\n  defer span.End() ![2](assets/2.png)\n  value, exists := s.productMap[in.Value]\n  if exists {\n     return value, status.New(codes.OK, \"\").Err()\n  }\n  return nil, status.Errorf(codes.NotFound, \"Product does not exist.\", in.Value)\n}\n```", "```go\npackage main\n\nimport (\n  \"context\"\n  \"log\"\n  \"time\"\n\n  pb \"productinfo/client/ecommerce\"\n  \"productinfo/client/tracer\"\n  \"google.golang.org/grpc\"\n  \"go.opencensus.io/plugin/ocgrpc\" ![1](assets/1.png)\n  \"go.opencensus.io/trace\"\n  \"contrib.go.opencensus.io/exporter/jaeger\"\n\n)\n\nconst (\n  address = \"localhost:50051\"\n)\n\nfunc main() {\n  tracer.initTracing() ![2](assets/2.png)\n\n  conn, err := grpc.Dial(address, grpc.WithInsecure())\n  if err != nil {\n     log.Fatalf(\"did not connect: %v\", err)\n  }\n  defer conn.Close()\n  c := pb.NewProductInfoClient(conn)\n\n  ctx, span := trace.StartSpan(context.Background(),\n          \"ecommerce.ProductInfoClient\") ![3](assets/3.png)\n\n  name := \"Apple iphone 11\"\n  description := \"Apple iphone 11 is the latest smartphone,\n            launched in September 2019\"\n  price := float32(700.0)\n  r, err := c.AddProduct(ctx, &pb.Product{Name: name,\n      Description: description, Price: price}) ![5](assets/5.png)\n  if err != nil {\n     log.Fatalf(\"Could not add product: %v\", err)\n  }\n  log.Printf(\"Product ID: %s added successfully\", r.Value)\n\n  product, err := c.GetProduct(ctx, &pb.ProductID{Value: r.Value}) ![6](assets/6.png)\n  if err != nil {\n    log.Fatalf(\"Could not get product: %v\", err)\n  }\n  log.Printf(\"Product: \", product.String())\n  span.End() ![4](assets/4.png)\n\n}\n```", "```go\nGRPC_GO_LOG_VERBOSITY_LEVEL=99 ![1](assets/1.png)\nGRPC_GO_LOG_SEVERITY_LEVEL=info ![2](assets/2.png)\n```", "```go\nhandlers=java.util.logging.ConsoleHandler\nio.grpc.netty.level=FINE\njava.util.logging.ConsoleHandler.level=FINE\njava.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter\n```", "```go\n-Djava.util.logging.config.file=logging.properties\n```"]