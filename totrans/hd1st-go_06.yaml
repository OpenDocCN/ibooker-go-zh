- en: 'Chapter 5\. on the list: Arrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0149-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A whole lot of programs deal with lists of things.** Lists of addresses.
    Lists of phone numbers. Lists of products. Go has *two* built-in ways of storing
    lists. This chapter will introduce the first: **arrays**. You’ll learn about how
    to create arrays, how to fill them with data, and how to get that data back out
    again. Then you’ll learn about processing all the elements in array, first the
    *hard* way with `for` loops, and then the *easy* way with `for`...`range` loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays hold collections of values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A local restaurant owner has a problem. He needs to know how much beef to order
    for the upcoming week. If he orders too much, the excess will go to waste. If
    he doesn’t order enough, he’ll have to tell his customers that he can’t make their
    favorite dishes.
  prefs: []
  type: TYPE_NORMAL
- en: He keeps data on how much meat was used the previous three weeks. He needs a
    program that will give him some idea of how much to order.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0150-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This should be simple enough: we can calculate the average by taking the three
    amounts, adding them together, and dividing by 3\. The average should offer a
    good estimate of how much to order.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0150-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The first issue is going to be storing the sample values. It would be a pain
    to declare three separate variables, and even more so if we wanted to average
    more values together later. But, like most programming languages, Go offers a
    data structure that’s perfect for this sort of situation...
  prefs: []
  type: TYPE_NORMAL
- en: An **array** is a collection of values that all share the same type. Think of
    it like one of those pill boxes with compartments — you can store and retrieve
    pills from each compartment separately, but it’s also easy to transport the container
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The values an array holds are called its **elements**. You can have an array
    of strings, an array of booleans, or an array of any other Go type (even an array
    of arrays). You can store an entire array in a single variable, and then access
    any element within the array that you need.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0150-03.png)'
  prefs: []
  type: TYPE_IMG
- en: An array holds a specific number of elements, and it cannot grow or shrink.
    To declare a variable that holds an array, you need to specify the number of elements
    it holds in square brackets (`[]`), followed by the type of elements the array
    holds.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0151-01.png)'
  prefs: []
  type: TYPE_IMG
- en: To set the array elements’ values or to retrieve values later, you’ll need a
    way to specify which element you mean. Elements in an array are numbered, starting
    with 0\. An element’s number is called its **index**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0151-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you wanted to make an array with the names of notes on a musical scale, for
    example, the first note would be assigned to index `0`, the second note would
    be at index `1`, and so forth. The index is specified in square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0151-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s an array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0151-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And an array of `time.Time` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0151-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Zero values in arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with variables, when an array is created, all the values it contains are
    initialized to the zero value for the type that array holds. So an array of `int`
    values is filled with zeros by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0152-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The zero value for strings, however, is an empty string, so an array of `string`
    values is filled with empty strings by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0152-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Zero values can make it safe to manipulate an array element even if you haven’t
    explicitly assigned a value to it. For example, here we have an array of integer
    counters. We can increment any of them without explicitly assigning a value first,
    because we know they will all start from `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0152-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**When an array is created, all the values it contains are initialized to the
    zero value for the type the array holds.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Array literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you know in advance what values an array should hold, you can initialize
    the array with those values using an **array literal**. An array literal starts
    just like an array type, with the number of elements it will hold in square brackets,
    followed by the type of its elements. This is followed by a list in curly braces
    of the initial values each element should have. The element values should be separated
    by commas.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0153-01.png)'
  prefs: []
  type: TYPE_IMG
- en: These examples are just like the previous ones we showed, except that instead
    of assigning values to the array elements one by one, the entire array is initialized
    using array literals.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0153-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using an array literal also allows you to do short variable declarations with
    `:=`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0153-03.png)'
  prefs: []
  type: TYPE_IMG
- en: You can spread array literals over multiple lines, but you’re required to use
    a comma before each newline character in your code. You’ll even need a comma following
    the final entry in the array literal, if it’s followed by a newline. (This style
    looks awkward at first, but it makes it easier to add more elements to the code
    later.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0153-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions in the “fmt” package know how to handle arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re just trying to debug code, you don’t have to pass array elements
    to `Println` and other functions in the `fmt` package one by one. Just pass the
    entire array. There’s logic in the `fmt` package to format and print the array
    for you. (The `fmt` package can also handle slices, maps, and other data structures
    we’ll see later.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0154-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You may also remember the `"%#v"` verb used by the `Printf` and `Sprintf` functions,
    which formats values as they’d appear in Go code. When formatted by `"%#v"`, arrays
    appear in the result as Go array literals.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0154-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing array elements within a loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t have to explicitly write the integer index of the array element you’re
    accessing in your code. You can also use the value in an integer variable as the
    array index.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0155-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That means you can do things like process elements of an array using a `for`
    loop. You loop through indexes in the array, and use the loop variable to access
    the element at the current index.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0155-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When accessing array elements using a variable, you need to be careful which
    index values you use. As we mentioned, arrays hold a specific number of elements.
    Trying to access an index that is outside the array will cause a **panic**, an
    error that occurs while your program is running (as opposed to when it’s compiling).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0155-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Normally, a panic causes your program to crash and display an error message
    to the user. Needless to say, panics should be avoided whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0155-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Checking array length with the “len” function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing loops that only access valid array indexes can be somewhat error-prone.
    Fortunately, there are a couple ways to make the process easier.
  prefs: []
  type: TYPE_NORMAL
- en: The first is to check the actual number of elements in the array before accessing
    it. You can do this with the built-in `len` function, which returns the length
    of the array (the number of elements it contains).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0156-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When setting up a loop to process an entire array, you can use `len` to determine
    which indexes are safe to access.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0156-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This still has the potential for mistakes, though. If `len(notes)` returns `7`,
    the highest index you can access is `6` (because array indexes start at `0`, not
    `1`). If you try to access index `7`, you’ll get a panic.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0156-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Looping over arrays safely with “for...range”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An even safer way to process each element of an array is to use the special
    `for`...`range` loop. In the `range` form, you provide a variable that will hold
    the integer index of each element, another variable that will hold the value of
    the element itself, and the array you want to loop over. The loop will run once
    for each element in the array, assigning the element’s index to your first variable
    and the element’s value to your second variable. You can add code to the loop
    block to process those values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0157-01.png)'
  prefs: []
  type: TYPE_IMG
- en: This form of the `for` loop has no messy init, condition, and post expressions.
    And because the element value is automatically assigned to a variable for you,
    there’s no risk that you’ll accidentally access an invalid array index. Because
    it’s safer and easier to read, you’ll see the `for` loop’s `range` form used most
    often when working with arrays and other collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our previous code that prints each value in our array of musical notes,
    updated to use a `for` ... `range` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0157-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The loop runs seven times, once for each element of the `notes` array. For each
    element, the `index` variable gets set to the element’s index, and the `note`
    variable gets set to the element’s value. Then we print the index and value.
  prefs: []
  type: TYPE_NORMAL
- en: Using the blank identifier with “for...range” loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, Go requires that you use every variable you declare. If we stop
    using the `index` variable from our `for`...`range` loop, we’ll get a compile
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0158-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And the same would be true if we didn’t use the variable that holds the element
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0158-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember in [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition),
    when we were calling a function with multiple return values, and we wanted to
    ignore one of them? We assigned that value to the blank identifier (`_`), which
    causes Go to discard that value, without giving a compiler error...
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same with values from `for`...`range` loops. If we don’t need
    the index for each array element, we can just assign it to the blank identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0158-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if we don’t need the value variable, we can assign that to the blank identifier
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0158-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting the sum of the numbers in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0159-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We finally know everything we need to create an array of `float64` values and
    calculate their average. Let’s take the amounts of beef that were used in previous
    weeks, and incorporate them into a program, named `average`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0159-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing we’ll need to do is set up a program file. In your Go workspace
    directory (the *go* directory within your user’s home directory, unless you’ve
    set the `GOPATH` environment variable), create the following nested directories
    (if they don’t already exist). Within the innermost directory, *average*, save
    a file named *main.go*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0159-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s write our program code within the *main.go* file. Since this will
    be an executable program, our code will be part of the `main` package, and will
    reside in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by just calculating the total for the three sample values; we can
    go back later to calculate the average. We use an array literal to create an array
    of three `float64` values, prepopulated with the sample values from prior weeks.
    We declare a `float64` variable named `sum` to hold the total, starting with a
    value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use a `for`...`range` loop to process each number. We don’t need the
    element indexes, so we discard them using the `_` blank identifier. We add each
    number to the value in `sum`. After we’ve totaled all the values, we print `sum`
    before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0159-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s try compiling and running our program. We’ll use the `go install` command
    to create an executable. We’re going to need to provide our executable’s import
    path to `go install`. If we used this directory structure...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0160-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '...that means the import path for our package will be `[github.com/headfirstgo/average](http://github.com/headfirstgo/average)`.
    So, from your terminal, type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go install github.com/headfirstgo/average`'
  prefs: []
  type: TYPE_NORMAL
- en: You can do so from within any directory. The `go` tool will look for a *[github.com/headfirstgo/average](http://github.com/headfirstgo/average)*
    directory within your workspace’s *src* directory, and compile any *.go* files
    it contains. The resulting executable will be named `average`, and will be stored
    in the *bin* directory within your Go workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can use the **`cd`** command to change to the *bin* directory within
    your Go workspace. Once you’re in *bin*, you can run the executable by typing
    **`./average`** (or **`average.exe`** on Windows).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0160-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The program will print the total of the three values from our array and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the average of the numbers in an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve got our `average` program printing the total of the array’s values, so
    now let’s update it to print the actual average. To do that, we’ll divide the
    total by the array’s length.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the array to the `len` function returns an `int` value with the array
    length. But since the total in the `sum` variable is a `float64` value, we’ll
    need to convert the length to a `float64` as well so we can use them together
    in a math operation. We store the result in the `sampleCount` variable. Once that’s
    done, all we have to do is divide `sum` by `sampleCount`, and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0161-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the code is updated, we can repeat the previous steps to see the new result:
    run **`go install`** to recompile the code, change to the *bin* directory, and
    run the updated `average` executable. Instead of the sum of the values in the
    array, we’ll see the average.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0161-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/chair.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    print the index and value of all the array elements that fall between `10` and
    `20` (it should match the output shown).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0162-01.png)![image](assets/f0162-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: each snippet from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_Solution_3).'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0163-01a.png)![image](assets/f0163-01.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s true—a program where users have to edit and compile the source code themselves
    isn’t very user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we’ve used the standard library’s `os` and `bufio` packages to read
    data a line at a time from the keyboard. We can use the same packages to read
    data a line at a time from text files. Let’s go on a brief detour to learn how
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we’ll come back and update the `average` program to read its numbers in
    from a text file.
  prefs: []
  type: TYPE_NORMAL
- en: In your favorite text editor, create a new file named *data.txt*. Save it somewhere
    *outside* of your Go workspace directory for now.
  prefs: []
  type: TYPE_NORMAL
- en: Within the file, enter our three floating-point sample values, one number per
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0163-02.png)![image](assets/f0163-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we can update our program to average numbers from a text file, we need
    to be able to read the file’s contents. To start, let’s write a program that only
    reads the file, and then we’ll incorporate what we learn into our averaging program.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0164-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In the same directory as *data.txt*, create a new program named *readfile.go*.
    We’ll just be running *readfile.go* with `go run`, rather than installing it,
    so it’s okay to save it outside of your Go workspace directory. Save the following
    code in *readfile.go*. (We’ll take a closer look at how this code works on the
    next page.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0164-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, from your terminal, change to the directory where you saved the two files,
    and run **`go run readfile.go`**. The program will read the contents of *data.txt*,
    and print them out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0164-03.png)![image](assets/f0163-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: Our test *readfile.go* program is successfully reading the lines of the *data.txt*
    file and printing them out. Let’s take a closer look at how the program works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by passing a string with the name of the file we want to open to the
    `os.Open` function. Two values are returned from `os.Open`: a pointer to an `os.File`
    value representing the opened file, and an `error` value. As we’ve seen with so
    many other functions, if the `error` value is `nil` it means the file was opened
    successfully, but any other value means there was an error. (This could happen
    if the file is missing or unreadable.) If that’s the case, we log the error message
    and exit the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0165-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we pass the `os.File` value to the `bufio.NewScanner` function. That will
    return a `bufio.Scanner` value that reads from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0165-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Scan` method on `bufio.Scanner` is designed to be used as part of a `for`
    loop. It will read a single line of text from the file, returning `true` if it
    read data successfully and `false` if it did not. If `Scan` is used as the condition
    on a `for` loop, the loop will continue running as long as there is more data
    to be read. Once the end of the file is reached (or there’s an error), `Scan`
    will return `false`, and the loop will exit.
  prefs: []
  type: TYPE_NORMAL
- en: After calling the `Scan` method on the `bufio.Scanner`, calling the `Text` method
    returns a string with the data that was read. For this program, we simply call
    `Println` within the loop to print each line out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0165-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the loop exits, we’re done with the file. Keeping files open consumes resources
    from the operating system, so files should always be closed when a program is
    done with them. Calling the `Close` method on the `os.File` will accomplish this.
    Like the `Open` function, the `Close` method returns an `error` value, which will
    be `nil` unless there was a problem. (Unlike `Open`, `Close` returns only a *single*
    value, as there is no useful value for it to return other than the error.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0165-04.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s also possible that the `bufio.Scanner` encountered an error while scanning
    through the file. If it did, calling the `Err` method on the scanner will return
    that error, which we log before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0165-05.png)![image](assets/f0165-06.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading a text file into an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our *readfile.go* program worked great—we were able to read the lines from our
    *data.txt* file in as strings, and print them out. Now we need to convert those
    strings to numbers and store them in an array. Let’s create a package named `datafile`
    that will do this for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0166-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In your Go workspace directory, create a *datafile* directory within the *headfirstgo*
    directory. Within the *datafile* directory, save a file named *floats.go*. (We
    name it *floats.go* because this file will contain code that reads floating-point
    numbers from files.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0166-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Within *floats.go*, save the following code. A lot of this is based on code
    from our test *readfile.go* program; we’ve grayed out the parts where the code
    is identical. We’ll explain the new code in detail on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0166-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We want to be able to read from files other than *data.txt*, so we accept the
    name of the file we should open as a parameter. We set the function up to return
    two values, an array of `float64` values and an `error` value. Like most functions
    that return an error, the first return value should only be considered usable
    if the error value is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Next we declare an array of three `float64` values that will hold the numbers
    we read from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like in *readfile.go*, we open the file for reading. The difference is
    that instead of a hardcoded string of `"data.txt"`, we open whatever filename
    was passed to the function. If an error is encountered, we need to return an array
    along with the error value, so we just return the `numbers` array (even though
    nothing has been assigned to it yet).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to know which array element to assign each line to, so we create a variable
    to track the current index.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code to set up a `bufio.Scanner` and loop over the file’s lines is identical
    to the code from *readfile.go*. The code within the loop is different, however:
    we need to call `strconv.ParseFloat` on the string read from the file to convert
    it to a `float64`, and assign the result to the array. If `ParseFloat` results
    in an error, we need to return that. And if the parsing is successful, we need
    to increment `i` so that the next number is assigned to the next array element.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Our code to close the file and report any errors is identical to *readfile.go*,
    except that we return any errors instead of exiting the program directly. If there
    are no errors, the end of the `GetFloats` function will be reached, and the array
    of `float64` values will be returned along with a `nil` error.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0167-06.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating our “average” program to read a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re ready to replace the hardcoded array in our `average` program with an
    array read in from the *data.txt* file!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0168-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Writing our `datafile` package was the hard part. Here in the main program,
    we only need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Update our `import` declaration to include the `datafile` and `log` packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace our array of hardcoded numbers with a call to `datafile.GetFloats("data.txt")`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether we got an error back from `GetFloats`, and log it and exit if
    so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the remaining code will be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0168-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can compile the program using the same terminal command as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go install github.com/headfirstgo/average`'
  prefs: []
  type: TYPE_NORMAL
- en: Since our program imports the `datafile` package, that will automatically be
    compiled as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0169-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll need to move the *data.txt* file to the *bin* subdirectory of the Go workspace.
    That’s because we’ll be running the `average` executable from that directory,
    and it will look for *data.txt* in the same directory. Once you’ve moved *data.txt*,
    change into that *bin* subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0169-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the `average` executable, it will load the values from *data.txt*
    into an array, and use them to calculate the average.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0169-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If we change the values in *data.txt*, the average will change as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0169-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Our program can only process three values!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But there’s a problem—the `average` program only runs if there are three or
    fewer lines in *data.txt*. If there are four or more, `average` will panic and
    exit when it’s run!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0170-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When a Go program panics, it outputs a report with information on the line of
    code where the problem occurred. In this case, it looks like the problem is on
    line 20 of the *floats.go* file.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at line 20 of *floats.go*, we’ll see that it’s the part of the `GetFloats`
    function where numbers from the file get added to the array!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0170-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember when a mistake in a previous code sample led a program to attempt to
    access an eighth element of a seven-element array? That program panicked and exited,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0171-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The same problem is happening in our `GetFloats` function. Because we declared
    that the `numbers` array holds three elements, that’s *all* it can hold. When
    the fourth line of the *data.txt* file is reached, it attempts to assign to a
    *fourth* element of `numbers`, which results in a panic.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0171-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Go arrays are fixed in size; they can’t grow or shrink. But the *data.txt* file
    can have as many lines as the user wants to add. We’ll see a solution for this
    dilemma in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0172-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 5](#on_the_listcolon_arrays)! You’ve added arrays
    to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0172-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0173-02.png)'
  prefs: []
  type: TYPE_IMG
