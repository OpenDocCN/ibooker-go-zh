<html><head></head><body><section data-pdf-bookmark="Chapter 9. you&#x2019;re my type: Defined Types" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="yoursquore_my_typecolon_defined_types">
<h1 class="calibre17"><span class="calibre">Chapter 9. </span>you’re my type: Defined Types</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0265-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">There’s more to learn about defined types.</strong> In the previous chapter, we showed you how to define a type with a struct underlying type. What we <em class="calibre9">didn’t</em> show you was that you can use <em class="calibre9">any</em> type as an underlying type.</p>
<p class="calibre7">And do you remember methods—the special kind of function that’s associated with values of a particular type? We’ve been calling methods on various values throughout the book, but we haven’t shown you how to define your <em class="calibre9">own</em> methods. In this chapter, we’re going to fix all of that. Let’s get started!</p>
<section data-pdf-bookmark="Type errors in real life" data-type="sect1" class="preface"><div class="preface" id="type_errors_in_real_life">
<h1 class="calibre25">Type errors in real life</h1>
<p class="calibre7">If you live in the US, you are probably used to the quirky system of measurement used there. At gas stations, for example, fuel is sold by the gallon, a volume nearly four times the size of the liter used in much of the rest of the world.</p>
<p class="calibre7">Steve is an American, renting a car in another country. He pulls into a gas station to refuel. He intends to purchase 10 gallons, figuring that will be enough to reach his hotel in another city.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0266-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">He gets back on the road, but only gets one-fourth of the way to his destination before running out of fuel.</p>
<p class="calibre7">If Steve had looked at the labels on the gas pump more closely, he would have realized that it was measuring the fuel in liters, not gallons, and that he needed to purchase 37.85 liters to get the equivalent of 10 gallons.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0266-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">10 gallons</strong></p>
<p class="calibre7">When you have a number, it’s best to be certain what that number is measuring. You want to know if it’s liters or gallons, kilograms or pounds, dollars or yen.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0266-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">10 liters</strong></p>
</div></section>
<section data-pdf-bookmark="Defined types with underlying basic types" data-type="sect1" class="preface"><div class="preface" id="defined_types_with_underlying_basic_type">
<h1 class="calibre25">Defined types with underlying basic types</h1>
<p class="calibre7"><a data-primary="conversions" data-secondary="between types with same underlying type" data-type="indexterm" id="idm46062711282520" class="calibre10"/><a data-primary="defined types" data-secondary="underlying basic types" data-type="indexterm" id="idm46062711281096" class="calibre10"/><a data-primary="short variable declaration (:=)" data-secondary="for types" data-type="indexterm" id="idm46062711280056" class="calibre10"/><a data-primary="short variable declaration (:=)" data-secondary="using type conversions" data-type="indexterm" id="idm46062711278904" class="calibre10"/><a data-primary="types" data-secondary="underlying basic types" data-type="indexterm" id="idm46062711277832" class="calibre10"/>If you have the following variable:</p>
<pre data-type="programlisting" class="calibre32">var fuel float64 = 10</pre>
<p class="calibre7">...does that represent 10 gallons or 10 liters? The person who wrote that declaration knows, but no one else does, not for sure.</p>
<p class="calibre7">You can use Go’s defined types to make it clear what a value is to be used for. Although defined types most commonly use structs as their underlying types, they <em class="calibre9">can</em> be based on <code class="calibre20">int</code>, <code class="calibre20">float64</code>, <code class="calibre20">string</code>, <code class="calibre20">bool</code>, or any other type.</p>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">Go defined types most often use structs as their underlying types, but they can also be based on ints, strings, booleans, or any other type.</strong></p>
</blockquote>
<p class="calibre7">Here’s a program that defines two new types, <code class="calibre20">Liters</code> and <code class="calibre20">Gallons</code>, both with an underlying type of <code class="calibre20">float64</code>. These are defined at the package level, so that they’re available within any function in the current package.</p>
<p class="calibre7">Within the <code class="calibre20">main</code> function, we declare a variable with a type of <code class="calibre20">Gallons</code>, and another with a type of <code class="calibre20">Liters</code>. We assign values to each variable, and then print them out.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0267-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Once you’ve defined a type, you can do a conversion to that type from any value of the underlying type. As with any other conversion, you write the type you want to convert to, followed by the value you want to convert in parentheses.</p>
<p class="calibre7">If we had wanted, we could have written short variable declarations in the code above using type conversions:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0267-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="variables" data-secondary="defined types and" data-type="indexterm" id="idm46062711263592" class="calibre10"/>If you have a variable that uses a defined type, you <em class="calibre9">cannot</em> assign a value of a different defined type to it, even if the other type has the same underlying type. This helps protect developers from confusing the two types.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0268-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">But you can <em class="calibre9">convert</em> between types that have the same underlying type. So <code class="calibre20">Liters</code> can be converted to <code class="calibre20">Gallons</code> and vice versa, because both have an underlying type of <code class="calibre20">float64</code>. But Go only considers the value of the underlying type when doing a conversion; there is no difference between <code class="calibre20">Gallons(Liters(240.0))</code> and <code class="calibre20">Gallons(240.0)</code>. Simply converting raw values from one type to another defeats the protection against conversion errors that types are supposed to provide.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0268-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Instead, you’ll want to perform whatever operations are necessary to convert the underlying type value to a value appropriate for the type you’re converting to.</p>
<p class="calibre7">A quick web search shows that one liter equals roughly 0.264 gallons, and that one gallon equals roughly 3.785 liters. We can multiply by these conversion rates to convert from <code class="calibre20">Gallons</code> to <code class="calibre20">Liters</code>, and vice versa.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0268-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Defined types and operators" data-type="sect1" class="preface"><div class="preface" id="defined_types_and_operators">
<h1 class="calibre25">Defined types and operators</h1>
<p class="calibre7"><a data-primary="arithmetic operators" data-type="indexterm" id="idm46062711247048" class="calibre10"/><a data-primary="comparison operators" data-type="indexterm" id="idm46062711246072" class="calibre10"/><a data-primary="defined types" data-secondary="operators and" data-type="indexterm" id="idm46062711245224" class="calibre10"/><a data-primary="literals" data-secondary="defined types and" data-type="indexterm" id="idm46062711244040" class="calibre10"/><a data-primary="operators" data-secondary="arithmetic" data-type="indexterm" id="idm46062711242904" class="calibre10"/><a data-primary="operators" data-secondary="comparison" data-type="indexterm" id="idm46062711241832" class="calibre10"/><a data-primary="operators" data-secondary="defined types and" data-type="indexterm" id="idm46062711240696" class="calibre10"/><a data-primary="string type (strings)" data-secondary="operator support" data-type="indexterm" id="idm46062711239624" class="calibre10"/><a data-primary="types" data-secondary="operators and" data-type="indexterm" id="idm46062711238488" class="calibre10"/>A defined type supports all the same operations as its underlying type. Types based on <code class="calibre20">float64</code>, for example, support arithmetic operators like <code class="calibre20">+</code>, <code class="calibre20">-</code>, <code class="calibre20">*</code>, and <code class="calibre20">/</code>, as well as comparison operators like <code class="calibre20">==</code>, <code class="calibre20">&gt;</code>, and <code class="calibre20">&lt;</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0269-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">A type based on an underlying type of <code class="calibre20">string</code>, however, would support <code class="calibre20">+</code>, <code class="calibre20">==</code>, <code class="calibre20">&gt;</code>, and <code class="calibre20">&lt;</code>, but not <code class="calibre20">-</code>, because <code class="calibre20">-</code> is not a valid operator for strings.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0269-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">A defined type can be used in operations together with literal values:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0269-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">But defined types <em class="calibre9">cannot</em> be used in operations together with values of a different type, even if the other type has the same underlying type. Again, this is to protect developers from accidentally mixing the two types.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0269-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If you want to add a value in <code class="calibre20">Liters</code> to a value in <code class="calibre20">Gallons</code>, you’ll need to convert one type to match the other first.</p>
</div></section>
<section data-pdf-bookmark="Pool Puzzle" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_8">
<h1 class="calibre25">Pool Puzzle</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0270-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Your <strong class="calibre8">job</strong> is to take code snippets from the pool and place them into the blank lines in this code. <strong class="calibre8">Don’t</strong> use the same snippet more than once, and you won’t need to use all the snippets. Your <strong class="calibre8">goal</strong> is to make a program that will run and produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0270-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0270-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Note: each snippet from the pool can only be used once!</strong></p>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#pool_puzzle_solution_6" class="calibre10">“Pool Puzzle Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="Converting between types using functions" data-type="sect1" class="preface"><div class="preface" id="converting_between_types_using_functions">
<h1 class="calibre25">Converting between types using functions</h1>
<p class="calibre7"><a data-primary="conversions" data-secondary="between types using functions" data-type="indexterm" id="idm46062711206328" class="calibre10"/><a data-primary="defined types" data-secondary="converting using functions" data-type="indexterm" id="idm46062711204840" class="calibre10"/><a data-primary="functions" data-secondary="converting types using" data-type="indexterm" id="idm46062711203688" class="calibre10"/><a data-primary="types" data-secondary="converting using functions" data-type="indexterm" id="idm46062711202616" class="calibre10"/>Suppose we wanted to take a car whose fuel level is measured in <code class="calibre20">Gallons</code> and refill it at a gas pump that measures in <code class="calibre20">Liters</code>. Or take a bus whose fuel is measured in <code class="calibre20">Liters</code> and refill it at a gas pump that measures in <code class="calibre20">Gallons</code>. To protect us from inaccurate measurements, Go will give us a compile error if we try to combine values of different types:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0271-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In order to do operations with values of different types, we need to convert the types to match first. Previously, we demonstrated multiplying a <code class="calibre20">Liters</code> value by 0.264 and converted the result to <code class="calibre20">Gallons</code>. We also multiplied a <code class="calibre20">Gallons</code> value by 3.785 and converted the result to <code class="calibre20">Liters</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0271-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We can create <code class="calibre20">ToGallons</code> and <code class="calibre20">ToLiters</code> functions that do the same thing, then call them to perform the conversion for us:</p>
<p class="calibre7"><a data-primary="functions" data-secondary="overloading" data-type="indexterm" id="idm46062711192024" class="calibre10"/><a data-primary="overloading functions" data-type="indexterm" id="idm46062711190376" class="calibre10"/>Gasoline isn’t the only liquid we need to measure the volume of. There’s cooking oil, bottles of soda, and juice, to name a few. And so there are many more measures of volume than just liters and gallons. In the US there are teaspoons, cups, quarts, and more. The metric system has other units of measure as well, but the milliliter (1/1000 of a liter) is the most commonly used.</p>
<p class="calibre7">Let’s add a new type, <code class="calibre20">Milliliters</code>. Like the others, it will use <code class="calibre20">float64</code> as an underlying type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0272-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We’re also going to want a way to convert from <code class="calibre20">Milliliters</code> to the other types. But if we start adding a function to convert from <code class="calibre20">Milliliters</code> to <code class="calibre20">Gallons</code>, we run into a problem: we can’t have two <code class="calibre20">ToGallons</code> functions in the same package!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0272-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We could rename the two <code class="calibre20">ToGallons</code> functions to include the type they’re converting from: <code class="calibre20">LitersToGallons</code> and <code class="calibre20">MillilitersToGallons</code>, respectively. But those names would be a pain to write out all the time, and as we start adding functions to convert between the other types, it becomes clear this isn’t sustainable.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0272-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="there are no Dumb Questions" data-type="sect1" class="preface"><div class="preface" id="there_are_no_dumb_questions_5">
<h1 class="calibre25">there are no Dumb Questions</h1>
<p class="calibre7"><strong class="calibre8">Q: I’ve seen other languages that support function <em class="calibre26">overloading</em>: they allow you to have multiple functions with the same name, as long as their parameter types are different. Doesn’t Go support that?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> The Go maintainers get this question frequently too, and they answer it at <em class="calibre9"><a href="https://golang.org/doc/faq#overloading" class="calibre10">https://golang.org/doc/faq#overloading</a></em>: “Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice.” The Go language is simplified by <em class="calibre9">not</em> supporting overloading, and so it doesn’t support it. As you’ll see later in the book, the Go team made similar decisions in other areas of the language, too; when they have to choose between simplicity and adding more features, they generally choose simplicity. But that’s okay! As we’ll see shortly, there are other ways to get the same benefits...</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0273-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>

</div></section>
<section data-pdf-bookmark="Fixing our function name conflict using methods" data-type="sect1" class="preface"><div class="preface" id="fixing_our_function_name_conflict_using">
<h1 class="calibre25">Fixing our function name conflict using methods</h1>
<p class="calibre7"><a data-primary="functions" data-secondary="fixing name conflicts using methods" data-type="indexterm" id="idm46062711171336" class="calibre10"/><a data-primary="methods" data-secondary="fixing function name conflicts" data-type="indexterm" id="idm46062711169928" class="calibre10"/>Remember way back in <a data-type="xref" href="ch02.html#which_code_runs_nextquestcolon_condition" class="calibre10">Chapter 2</a>, we introduced you to <em class="calibre9">methods</em>, which are functions associated with values of a given type? Among other things, we created a <code class="calibre20">time.Time</code> value and called its <code class="calibre20">Year</code> method, and we created a <code class="calibre20">strings.Replacer</code> value and called its <code class="calibre20">Replace</code> method.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0274-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We can define methods of our own to help with our type conversion problem.</p>
<p class="calibre7">We’re not allowed to have multiple functions named <code class="calibre20">ToGallons</code>, so we had to write long, cumbersome function names that incorporated the type we were converting:</p>
<pre data-type="programlisting" class="calibre32">LitersToGallons(Liters(2))
MillilitersToGallons(Milliliters(500))</pre>
<p class="calibre7">But we <em class="calibre9">can</em> have multiple <em class="calibre9">methods</em> named <code class="calibre20">ToGallons</code>, as long as they’re defined on separate types. Not having to worry about name conflicts will let us make our method names much shorter.</p>
<pre data-type="programlisting" class="calibre32">Liters(2).ToGallons()
Milliliters(500).ToGallons()</pre>
<p class="calibre7">But let’s not get ahead of ourselves. Before we can do anything else, we need to know how to define a method...</p>
</div></section>
<section data-pdf-bookmark="Defining methods" data-type="sect1" class="preface"><div class="preface" id="defining_methods">
<h1 class="calibre25">Defining methods</h1>
<p class="calibre7"><a data-primary="calling methods" data-type="indexterm" id="idm46062711154728" class="calibre10"/><a data-primary="methods" data-secondary="calling" data-type="indexterm" id="idm46062711152504" class="calibre10"/><a data-primary="methods" data-secondary="defining" data-type="indexterm" id="idm46062711151352" class="calibre10"/><a data-primary="parameters" data-secondary="methods and" data-type="indexterm" id="idm46062711150280" class="calibre10"/>A method definition is very similar to a function definition. In fact, there’s really only one difference: you add one extra parameter, a <strong class="calibre8">receiver parameter</strong>, in parentheses <em class="calibre9">before</em> the function name.</p>
<p class="calibre7">As with any function parameter, you need to provide a name for the receiver parameter, followed by a type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0275-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">To call a method you’ve defined, you write the value you’re calling the method on, a dot, and the name of the method you’re calling, followed by parentheses. The value you’re calling the method on is known as the method <strong class="calibre8">receiver</strong>.</p>
<p class="calibre7">The similarity between method calls and method definitions can help you remember the syntax: the receiver is listed first when you’re <em class="calibre9">calling</em> a method, and the receiver parameter is listed first when you’re <em class="calibre9">defining</em> a method.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0275-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The name of the receiver parameter in the method definition isn’t important, but its type is; the method you’re defining becomes associated with all values of that type.</p>
<p class="calibre7">Below, we define a type named <code class="calibre20">MyType</code>, with an underlying type of <code class="calibre20">string</code>. Then, we define a method named <code class="calibre20">sayHi</code>. Because <code class="calibre20">sayHi</code> has a receiver parameter with a type of <code class="calibre20">MyType</code>, we’ll be able to call the <code class="calibre20">sayHi</code> method on any <code class="calibre20">MyType</code> value. (Most developers would say that <code class="calibre20">sayHi</code> is defined “on” <code class="calibre20">MyType</code>.)</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0275-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Once a method is defined on a type, it can be called on any value of that type.</p>
<p class="calibre7">Here, we create two different <code class="calibre20">MyType</code> values, and call <code class="calibre20">sayHi</code> on each of them.</p>
</div></section>
<section data-pdf-bookmark="The receiver parameter is (pretty much) just another parameter" data-type="sect1" class="preface"><div class="preface" id="The_receiver_parameter_is_leftparenthesi">
<h1 class="calibre25">The receiver parameter is (pretty much) just another parameter</h1>
<p class="calibre7"><a data-primary="anonymous struct fields" data-type="indexterm" id="idm46062711130744" class="calibre10"/><a data-primary="embedding" data-secondary="struct types and" data-type="indexterm" id="idm46062711129288" class="calibre10"/><a data-primary="methods" data-secondary="receiver parameters" data-see="receiver parameters (methods)" data-type="indexterm" id="idm46062711128216" class="calibre10"/><a data-primary="methods" data-secondary="types and" data-type="indexterm" id="idm46062711126840" class="calibre10"/><a data-primary="receiver parameters (methods)" data-type="indexterm" id="idm46062711125768" class="calibre10"/><a data-primary="receiver parameters (methods)" data-secondary="about" data-type="indexterm" id="idm46062711124936" class="calibre10"/><a data-primary="structs" data-secondary="anonymous fields" data-type="indexterm" id="idm46062711123864" class="calibre10"/><a data-primary="struct types" data-secondary="embedding" data-type="indexterm" id="idm46062711122744" class="calibre10"/><a data-primary="types" data-secondary="methods and" data-type="indexterm" id="idm46062711121592" class="calibre10"/>The type of the receiver parameter is the type that the method becomes associated with. But aside from that, the receiver parameter doesn’t get special treatment from Go. You can access its contents within the method block just like you would any other function parameter.</p>
<p class="calibre7">The code sample below is almost identical to the previous one, except that we’ve updated it to print the value of the receiver parameter. You can see the receivers in the resulting output.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0276-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Go lets you name a receiver parameter whatever you want, but it’s more readable if all the methods you define for a type have receiver parameters with the same name.</p>
<p class="calibre7">By convention, Go developers usually use a name consisting of a single letter—the first letter of the receiver’s type name, in lowercase. (This is why we used <code class="calibre20">m</code> as the name for our <code class="calibre20">MyType</code> receiver parameter.)</p>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">Go uses receiver parameters instead of the “self” or “this” values seen in other languages.</strong></p>
</blockquote>
</div></section>
<section data-pdf-bookmark="there are no Dumb Questions" data-type="sect1" class="preface"><div class="preface" id="there_are_no_dumb_questions_6">
<h1 class="calibre25">there are no Dumb Questions</h1>
<p class="calibre7"><strong class="calibre8">Q: Can I define new methods on <em class="calibre26">any</em> type?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> Only types that are defined in the same package where you define the method. That means no defining methods for types from someone else’s <code class="calibre20">security</code> package from your <code class="calibre20">hacking</code> package, and no defining new methods on universal types like <code class="calibre20">int</code> or <code class="calibre20">string</code>.</p>
<p class="calibre7"><strong class="calibre8">Q: But I need to be able to use methods of my own with someone else’s type!</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> First you should consider whether a function would work well enough; a function can take any type you want as a parameter. But if you <em class="calibre9">really</em> need a value that has some methods of your own, plus some methods from a type in another package, you can make a struct type that embeds the other package’s type as an anonymous field. We’ll look at how that works in the next chapter.</p>
<p class="calibre7"><strong class="calibre8">Q: I’ve seen other languages where a method receiver was available in a method block in a special variable named <code class="calibre40">self</code> or <code class="calibre40">this</code>. Does Go do that?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> Go uses receiver parameters instead of <code class="calibre20">self</code> and <code class="calibre20">this</code>. The big difference is that <code class="calibre20">self</code> and <code class="calibre20">this</code> are set <em class="calibre9">implicitly</em>, whereas you <em class="calibre9">explicitly</em> declare a receiver parameter. Other than that, receiver parameters are used in the same way, and there’s no need for Go to reserve <code class="calibre20">self</code> or <code class="calibre20">this</code> as keywords! (You could even name your receiver parameter <code class="calibre20">this</code> if you wanted, but don’t do that; the convention is to use the first letter of the receiver’s type name instead.)</p>
</div></section>
<section data-pdf-bookmark="A method is (pretty much) just like a function" data-type="sect1" class="preface"><div class="preface" id="a_method_is_leftparenthesispretty_muchri">
<h1 class="calibre25">A method is (pretty much) just like a function</h1>
<p class="calibre7"><a data-primary="exporting from packages" data-secondary="methods" data-type="indexterm" id="idm46062711099128" class="calibre10"/><a data-primary="functions" data-secondary="methods and" data-type="indexterm" id="idm46062711097016" class="calibre10"/><a data-primary="methods" data-secondary="functions and" data-type="indexterm" id="idm46062711095928" class="calibre10"/><a data-primary="methods" data-secondary="naming rules for" data-type="indexterm" id="idm46062711094792" class="calibre10"/><a data-primary="methods" data-secondary="unexported" data-type="indexterm" id="idm46062711093688" class="calibre10"/><a data-primary="naming rules" data-secondary="methods" data-type="indexterm" id="idm46062711092584" class="calibre10"/><a data-primary="parentheses ()" data-secondary="defining method parameters" data-type="indexterm" id="idm46062711091480" class="calibre10"/><a data-primary="return values" data-secondary="methods and" data-type="indexterm" id="idm46062711090376" class="calibre10"/><a data-primary="unexported fields" data-secondary="methods and" data-type="indexterm" id="idm46062711089272" class="calibre10"/>Aside from the fact that they’re called on a receiver, methods are otherwise pretty similar to any other function.</p>
<p class="calibre7">As with any other function, you can define additional parameters within parentheses following the method name. These parameter variables can be accessed in the method block, along with the receiver parameter. When you call the method, you’ll need to provide an argument for each parameter.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0277-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">As with any other function, you can declare one or more return values for a method, which will be returned when the method is called:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0277-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">As with any other function, a method is considered exported from the current package if its name begins with a capital letter, and it’s considered unexported if its name begins with a lowercase letter. If you want to use your method outside the current package, be sure its name begins with a capital letter.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0277-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_16">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">Fill in the blanks to define a <code class="calibre20">Number</code> type with <code class="calibre20">Add</code> and <code class="calibre20">Subtract</code> methods that will produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0278-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#exercise_solution_17" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Pointer receiver parameters" data-type="sect1" class="preface"><div class="preface" id="pointer_receiver_parameters">
<h1 class="calibre25">Pointer receiver parameters</h1>
<p class="calibre7"><a data-primary="pointers and pointer types" data-secondary="receiver parameters" data-type="indexterm" id="idm46062711069784" class="calibre10"/><a data-primary="receiver parameters (methods)" data-secondary="pointers and" data-type="indexterm" id="idm46062711068680" class="calibre10"/>Here’s an issue that may look familiar by now. We’ve defined a new <code class="calibre20">Number</code> type with an underlying type of <code class="calibre20">int</code>. We’ve given <code class="calibre20">Number</code> a <code class="calibre20">double</code> method that is supposed to multiply the underlying value of its receiver by two and then update the receiver. But we can see from the output that the method receiver isn’t actually getting updated.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0279-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Back in <a data-type="xref" href="ch03.html#call_mecolon_functions" class="calibre10">Chapter 3</a>, we had a <code class="calibre20">double</code> <em class="calibre9">function</em> with a similar problem. Back then, we learned that function parameters receive a copy of the values the function is called with, not the original values, and that any updates to the copy would be lost when the function exited. To make the <code class="calibre20">double</code> function work, we had to pass a <em class="calibre9">pointer</em> to the value we wanted to update, and then update the value at that pointer within the function.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0279-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We’ve said that receiver parameters are treated no differently than ordinary parameters. And like any other parameter, a receiver parameter receives a <em class="calibre9">copy</em> of the receiver value. If you make changes to the receiver within a method, you’re changing the copy, not the original.</p>
<p class="calibre7">As with the <code class="calibre20">double</code> function in <a data-type="xref" href="ch03.html#call_mecolon_functions" class="calibre10">Chapter 3</a>, the solution is to update our <code class="calibre20">Double</code> method to use a pointer for its receiver parameter. This is done in the same way as any other parameter: we place a <code class="calibre20">*</code> in front of the receiver type to indicate it’s a pointer type. We’ll also need to modify the method block so that it updates the value at the pointer. Once that’s done, when we call <code class="calibre20">Double</code> on a <code class="calibre20">Number</code> value, the <code class="calibre20">Number</code> should be updated.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0280-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Notice that we <em class="calibre9">didn’t</em> have to change the method call at all. When you call a method that requires a pointer receiver on a variable with a nonpointer type, Go will automatically convert the receiver to a pointer for you. The same is true for variables with pointer types; if you call a method requiring a value receiver, Go will automatically get the value at the pointer for you and pass that to the method.</p>
<p class="calibre7">You can see this at work in the code at right. The method named <code class="calibre20">method</code> takes a value receiver, but we can call it using both direct values and pointers, because Go autoconverts if needed. And the method named <code class="calibre20">pointerMethod</code> takes a pointer receiver, but we can call it on both direct values and pointers, because Go will autoconvert if needed.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0280-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">By the way, the code at right breaks a convention: for consistency, all of your type’s methods can take value receivers, or they can all take pointer receivers, but you should avoid mixing the two. We’re only mixing the two kinds here for demonstration purposes.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="watch_it_5">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/watch-it.png" class="calibre4"/></span> Watch it!</h5>
<p class="calibre7"><strong class="calibre8">To call a method that requires a pointer receiver, you have to be able to get a pointer to the value!</strong></p>
<p class="calibre7"><em class="calibre9">You can only get pointers to values that are stored in variables. If you try to get the address of a value that’s not stored in a variable, you’ll get an error:</em></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0281-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><em class="calibre9">The same limitation applies when calling methods with pointer receivers. Go can automatically convert values to pointers for you, but only if the receiver value is stored in a variable. If you try to call a method on the value itself, Go won’t be able to get a pointer, and you’ll get a similar error:</em></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0281-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><em class="calibre9">Instead, you’ll need to store the value in a variable, which will then allow Go to get a pointer to it:</em></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0281-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Breaking Stuff is Educational!" data-type="sect1" class="preface"><div class="preface" id="breaking_stuff_is_educational_7">
<h1 class="calibre25">Breaking Stuff is Educational!</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0282-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Here is our <code class="calibre20">Number</code> type again, with definitions for a couple methods. Make one of the changes below and try to compile the code. Then undo your change and try the next one. See what happens!</p>
<pre data-type="programlisting" class="calibre32">package main

import "fmt"

type Number int

func (n *Number) Display() {
       fmt.Println(*n)
}
func (n *Number) Double() {
       *n *= 2
}
func main() {
       number := Number(4)
       number.Double()
       number.Display()
}</pre>
<table class="calibre11">
<thead class="calibre33">
<tr class="calibre13">
<th class="calibre34">If you do this...</th>
<th class="calibre34">...the code will break because...</th>
</tr>
</thead>
<tbody class="calibre12">
<tr class="calibre13">
<td class="calibre14">Change a receiver parameter to a type not defined in this package:<br class="calibre16"/>
<code class="calibre36">func (n *<s class="calibre35">Number</s>int) Double() {<br class="calibre16"/>
       *n *= 2<br class="calibre16"/>
}
</code>
</td>
<td class="calibre14">You can only define new methods on types that were declared in the current package. Defining a method on a globally defined type like <code class="calibre36">int</code> will result in a compile error.</td>
</tr>
<tr class="calibre15">
<td class="calibre14">Change the receiver parameter for <code class="calibre36">Double</code> to a nonpointer type:<br class="calibre16"/>
<code class="calibre36">func (n <s class="calibre35">*</s>Number) Double() {<br class="calibre16"/>
       <s class="calibre35">*</s>n *= 2<br class="calibre16"/>
}</code>
</td>
<td class="calibre14">Receiver parameters receive a copy of the value the method was called on. If the <code class="calibre36">Double</code> function only modifies the copy, the original value will be unchanged when <code class="calibre36">Double</code> exits.</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Call a method that requires a pointer receiver on a value that’s not in a variable:<br class="calibre16"/><code class="calibre36">Number(4).Double()</code></td>
<td class="calibre14">When calling a method that takes a pointer receiver, Go can automatically convert a value to a pointer to a receiver <em class="calibre9">if</em> it’s stored in a variable. If it’s not, you’ll get an error.</td>
</tr>
<tr class="calibre15">
<td class="calibre14">Change the receiver parameter for <code class="calibre36">Display</code> to a nonpointer type:<br class="calibre16"/>
<code class="calibre36">func (n <s class="calibre35">*</s>Number) Display() {<br class="calibre16"/>
       fmt.Println(<s class="calibre35">*</s>n)<br class="calibre16"/>
}</code>
</td>
<td class="calibre14">The code will actually still <em class="calibre9">work</em> after making this change, but it breaks convention! Receiver parameters in the methods for a type can be all pointers, or all values, but it’s best to avoid mixing the two.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Converting Liters and Milliliters to Gallons using methods" data-type="sect1" class="preface"><div class="preface" id="converting_liters_and_milliliters_to_gal">
<h1 class="calibre25">Converting Liters and Milliliters to Gallons using methods</h1>
<p class="calibre7"><a data-primary="conversions" data-secondary="between types using methods" data-type="indexterm" id="idm46062711008056" class="calibre10"/><a data-primary="defined types" data-secondary="converting using methods" data-type="indexterm" id="idm46062711006520" class="calibre10"/><a data-primary="methods" data-secondary="converting types using" data-type="indexterm" id="idm46062711005544" class="calibre10"/><a data-primary="types" data-secondary="converting using methods" data-type="indexterm" id="idm46062711004568" class="calibre10"/>When we added a <code class="calibre20">Milliliters</code> type to our defined types for measuring volume, we discovered we couldn’t have <code class="calibre20">ToGallons</code> functions for both <code class="calibre20">Liters</code> and <code class="calibre20">Milliliters</code>. To work around this, we had to create functions with lengthy names:</p>
<pre data-type="programlisting" class="calibre32">func LitersToGallons(l Liters) Gallons {
       return Gallons(l * 0.264)
}
func MillilitersToGallons(m Milliliters) Gallons {
       return Gallons(m * 0.000264)
}</pre>
<p class="calibre7">But unlike functions, method names don’t have to be unique, as long as they’re defined on different types.</p>
<p class="calibre7">Let’s try implementing a <code class="calibre20">ToGallons</code> method on the <code class="calibre20">Liters</code> type. The code will be almost identical to the <code class="calibre20">LitersToGallons</code> function, but we’ll make the <code class="calibre20">Liters</code> value a receiver parameter rather than an ordinary parameter. Then we’ll do the same for the <code class="calibre20">Milliliters</code> type, converting the <code class="calibre20">MillilitersToGallons</code> function to a <code class="calibre20">ToGallons</code> method.</p>
<p class="calibre7">Notice that we’re not using pointer types for the receiver parameters. We’re not modifying the receivers, and the values don’t consume much memory, so it’s fine for the parameter to receive a copy of the value.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0283-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In our <code class="calibre20">main</code> function, we create a <code class="calibre20">Liters</code> value, then call <code class="calibre20">ToGallons</code> on it. Because the receiver has the type <code class="calibre20">Liters</code>, the <code class="calibre20">ToGallons</code> method for the <code class="calibre20">Liters</code> type is called. Likewise, calling <code class="calibre20">ToGallons</code> on a <code class="calibre20">Milliliters</code> value causes the <code class="calibre20">ToGallons</code> method for the <code class="calibre20">Milliliters</code> type to be called.</p>
</div></section>
<section data-pdf-bookmark="Converting Gallons to Liters and Milliliters using methods" data-type="sect1" class="preface"><div class="preface" id="converting_gallons_to_liters_and_millili">
<h1 class="calibre25">Converting Gallons to Liters and Milliliters using methods</h1>
<p class="calibre7">The process is similar when converting the <code class="calibre20">GallonsToLiters</code> and <code class="calibre20">GallonsToMilliliters</code> functions to methods. We just move the <code class="calibre20">Gallons</code> parameter to a receiver parameter in each.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0284-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_17">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">The code below should add a <code class="calibre20">ToMilliliters</code> method on the <code class="calibre20">Liters</code> type, and a <code class="calibre20">ToLiters</code> method on the <code class="calibre20">Milliliters</code> type. The code in the <code class="calibre20">main</code> function should produce the output shown. Fill in the blanks to complete the code.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0284-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="#exercise_solution_17" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Your Go Toolbox" data-type="sect1" class="preface"><div class="preface" id="your_go_toolbox_9">
<h1 class="calibre25">Your Go Toolbox</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0285-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">That’s it for <a data-type="xref" href="#yoursquore_my_typecolon_defined_types" class="calibre10">Chapter 9</a>! You’ve added method definitions to your toolbox.</strong></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0285-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="bullet_points_9">
<h5 class="calibre31">Bullet Points</h5>
<ul class="list_style_type_none">
<li class="calibre18"><p class="calibre7">Once you’ve defined a type, you can do a conversion to that type from any value of the same underlying type:</p>
<pre data-type="programlisting" class="calibre32">Gallons(10.0)</pre></li>
<li class="calibre18"><p class="calibre7">Once a variable’s type is defined, values of other types cannot be assigned to that variable, even if they have the same underlying type.</p></li>
<li class="calibre18"><p class="calibre7">A defined type supports all the same operators as its underlying type. A type based on <code class="calibre20">int</code>, for example, would support <code class="calibre20">+</code>, <code class="calibre20">-</code>, <code class="calibre20">*</code>, <code class="calibre20">/</code>, <code class="calibre20">==</code>, <code class="calibre20">&gt;</code>, and <code class="calibre20">&lt;</code> operators.</p></li>
<li class="calibre18"><p class="calibre7">A defined type can be used in operations together with literal values:</p>
<pre data-type="programlisting" class="calibre32">Gallons(10.0) + 2.3</pre></li>
<li class="calibre18"><p class="calibre7">To define a method, provide a receiver parameter in parentheses before the method name:</p>
<pre data-type="programlisting" class="calibre32">func (m MyType) MyMethod() {
}</pre></li>
<li class="calibre18"><p class="calibre7">The receiver parameter can be used within the method block like any other parameter:</p>
<pre data-type="programlisting" class="calibre32">func (m MyType) MyMethod() {
    fmt.Println("called on", m)
}</pre></li>
<li class="calibre18"><p class="calibre7">You can define additional parameters or return values on a method, just as you would with any other function.</p></li>
<li class="calibre18"><p class="calibre7">Defining multiple functions with the same name in the same package is not allowed, even if they have parameters of different types. But you <em class="calibre9">can</em> define multiple <em class="calibre9">methods</em> with the same name, as long as each is defined on a different type.</p></li>
<li class="calibre18"><p class="calibre7">You can only define methods on types that were defined in the same package.</p></li>
<li class="calibre18"><p class="calibre7">As with any other parameter, receiver parameters receive a copy of the original value. If your method needs to modify the receiver, you should use a pointer type for the receiver parameter, and modify the value at that pointer.</p></li>
</ul>
</div></aside>
</div></section>
<section data-pdf-bookmark="Pool Puzzle Solution" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_solution_6">
<h1 class="calibre25">Pool Puzzle Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0286-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_16">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">Fill in the blanks to define a <code class="calibre20">Number</code> type with <code class="calibre20">Add</code> and <code class="calibre20">Subtract</code> methods that will produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0286-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_17">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">The code below should add a <code class="calibre20">ToMilliliters</code> method on the <code class="calibre20">Liters</code> type, and a <code class="calibre20">ToLiters</code> method on the <code class="calibre20">Milliliters</code> type. The code in the <code class="calibre20">main</code> function should produce the output shown. Fill in the blanks to complete the code.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0287-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>

</div></aside>
</div></section>
</div></section></body></html>