<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Errors"><div class="chapter" id="unique_chapter_id_09">
<h1><span class="label">Chapter 9. </span>Errors</h1>


<p>Error handling is one of the biggest challenges for developers moving to Go from other languages. For those used to exceptions, Go’s approach feels anachronistic. But solid software engineering principles underlie Go’s approach. In this chapter, you’ll learn how to work with errors in Go. You’ll also take a look at <code>panic</code> and <code>recover</code>, Go’s system for handling errors that should stop execution.</p>






<section data-type="sect1" data-pdf-bookmark="How to Handle Errors: The Basics"><div class="sect1" id="id106">
<h1>How to Handle Errors: The Basics</h1>

<p>As was covered briefly in <a data-type="xref" href="ch05.html#unique_chapter_id_05">Chapter 5</a>, Go<a data-type="indexterm" data-primary="errors" data-secondary="returning errors via return value" data-tertiary="last return value" id="id1899"/><a data-type="indexterm" data-primary="return keyword" data-secondary="multiple return values" data-tertiary="errors as last return value" id="id1900"/><a data-type="indexterm" data-primary="functions" data-secondary="returning values" data-tertiary="errors as last return values" id="id1901"/><a data-type="indexterm" data-primary="errors" data-secondary="error handling" id="ch09-erhndl"/><a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="multiple return values" id="ch09-erhndl2"/><a data-type="indexterm" data-primary="return keyword" data-secondary="multiple return values" data-tertiary="error handling" id="ch09-erhndl3"/><a data-type="indexterm" data-primary="functions" data-secondary="returning values" data-tertiary="error handling" id="ch09-erhndl4"/> handles errors by returning a value of type <code>error</code> as the last return value for a function. This is entirely by convention, but it is such a strong convention that it should never be breached. <a data-type="indexterm" data-primary="errors" data-secondary="returning errors via return value" data-tertiary="nil returned if no error" id="id1902"/><a data-type="indexterm" data-primary="nil" data-secondary="error return value when no error" id="id1903"/>When a function executes as expected, <code>nil</code> is returned for the error parameter. If something goes wrong, an error value is returned instead. The calling function then checks the error return value by comparing it to <code>nil</code>, handling the error, or returning an error of its own. A simple function with error handling looks like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">calcRemainderAndMod</code><code class="p">(</code><code class="nx">numerator</code><code class="p">,</code><code class="w"> </code><code class="nx">denominator</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">denominator</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"denominator is 0"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">numerator</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">denominator</code><code class="p">,</code><code class="w"> </code><code class="nx">numerator</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="nx">denominator</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>A new error is created from a string<a data-type="indexterm" data-primary="errors package" data-secondary="errors.New" id="id1904"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.New" id="id1905"/><a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="error messages not capitalized or punctuated" id="id1906"/> by calling the <code>New</code> function in the <code>errors</code> package. Error messages should not be capitalized nor should they end with punctuation or a newline. <a data-type="indexterm" data-primary="errors" data-secondary="returning errors via return value" data-tertiary="other return values to zero values on error" id="id1907"/>In most cases, you should set the other return values to their zero values when a non-nil error is returned. You’ll see an exception to this rule when I cover sentinel errors.</p>

<p>Unlike languages with exceptions, Go doesn’t have special constructs to detect if an error was returned. When a function returns an error, use an <code>if</code> statement to check the error variable to see if it is non-nil:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">numerator</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">20</code><code class="w"/>
<code class="w">    </code><code class="nx">denominator</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">3</code><code class="w"/>
<code class="w">    </code><code class="nx">remainder</code><code class="p">,</code><code class="w"> </code><code class="nx">mod</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">calcRemainderAndMod</code><code class="p">(</code><code class="nx">numerator</code><code class="p">,</code><code class="w"> </code><code class="nx">denominator</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="nx">os</code><code class="p">.</code><code class="nx">Exit</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">remainder</code><code class="p">,</code><code class="w"> </code><code class="nx">mod</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can try out this code in the <em>sample_code/error_basics</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iii"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iiii"/></p>

<p><code>error</code> is a built-in interface that defines a single method:<a data-type="indexterm" data-primary="errors" data-secondary="error interface type" id="id1908"/><a data-type="indexterm" data-primary="error interface type" id="id1909"/><a data-type="indexterm" data-primary="types" data-secondary="error interface type" id="id1910"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Anything that implements this interface is considered an error. The reason you return <code>nil</code> from a function to indicate that no error occurred is that <code>nil</code> is the zero value for any interface type.</p>

<p>There are two very good reasons<a data-type="indexterm" data-primary="Go" data-secondary="errors returned instead of exceptions thrown" data-seealso="errors" id="id1911"/><a data-type="indexterm" data-primary="errors" data-secondary="returning errors via return value" data-tertiary="why not throwing exceptions" id="id1912"/> that Go uses a returned error instead of thrown exceptions. First, exceptions add at least one new code path through the code. These paths are sometimes unclear, especially in languages whose functions don’t include a declaration that an exception is possible. This produces code that crashes in surprising ways when exceptions aren’t properly handled, or, even worse, code that doesn’t crash but whose data is not properly initialized, modified, or stored.</p>

<p>The second reason is more subtle but demonstrates how Go’s features work together. The Go compiler requires all variables to be read. Making errors returned values forces developers to either check and handle error conditions or make it explicit that they are ignoring errors by using an underscore (<code>_</code>) for the returned error value.</p>

<p>Exception handling may produce shorter code, but having fewer lines doesn’t necessarily make code easier to understand or maintain. As you’ve seen, idiomatic Go favors clear code, even if it takes more lines.</p>

<p>Another thing to note is how code flows in Go. The error handling is indented inside an <code>if</code> statement. The business logic is not. This gives a quick visual clue to which code is along the “golden path” and which code is the exceptional condition.<a data-type="indexterm" data-startref="ch09-erhndl" id="id1913"/><a data-type="indexterm" data-startref="ch09-erhndl2" id="id1914"/><a data-type="indexterm" data-startref="ch09-erhndl3" id="id1915"/><a data-type="indexterm" data-startref="ch09-erhndl4" id="id1916"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The second situation is a reused <code>err</code> variable.<a data-type="indexterm" data-primary="functions" data-secondary="returning values" data-tertiary="reused err variable" id="id1917"/><a data-type="indexterm" data-primary="variables" data-secondary="err variable for errors" id="id1918"/> The Go compiler requires every variable to be read at least once. It doesn’t require that <em>every</em> write to a variable is read. If you use an <code>err</code> variable multiple times, you have to read it only once to make the compiler happy. In <a data-type="xref" href="ch11.html#staticcheck">“staticcheck”</a>, you’ll see a way to detect this.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Use Strings for Simple Errors"><div class="sect1" id="id247">
<h1>Use Strings for Simple Errors</h1>

<p>Go’s standard library provides two ways<a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="strings for simple errors" id="id1919"/><a data-type="indexterm" data-primary="string type" data-secondary="error handling" id="id1920"/><a data-type="indexterm" data-primary="errors package" data-secondary="errors.New" id="id1921"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.New" id="id1922"/> to create an error from a string. The first is the <code>errors.New</code> function. It takes in a <code>string</code> and returns an <code>error</code>. This string is returned when you call the <code>Error</code> method on the returned error instance. <a data-type="indexterm" data-primary="fmt package" data-secondary="fmt.Println" data-tertiary="passing error to" id="id1923"/><a data-type="indexterm" data-primary="Println (fmt package)" data-secondary="passing error to" id="id1924"/>If you pass an error to <code>fmt.Println</code>, it calls the <code>Error</code> method automatically:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doubleEven</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"only even numbers are processed"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doubleEven</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"> </code><code class="c1">// prints "only even numbers are processed"</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The second way is to use the <code>fmt.Errorf</code> function.<a data-type="indexterm" data-primary="Go runtime" data-secondary="error runtime information via fmt.Errorf" id="id1925"/><a data-type="indexterm" data-primary="fmt package" data-secondary="fmt.Errorf" id="id1926"/> This function allows you to include runtime information in the error message by using the <code>fmt.Printf</code> verbs to format an error string. Like <code>errors.New</code>, this string is returned when you call the <code>Error</code> method on the returned error instance:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">doubleEven</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"%d isn't an even number"</code><code class="p">,</code><code class="w"> </code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/string_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sentinel Errors"><div class="sect1" id="id107">
<h1>Sentinel Errors</h1>

<p>Some errors are meant to<a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="sentinel errors" id="ch09-senter"/><a data-type="indexterm" data-primary="sentinel errors" id="ch09-senter2"/> signal that processing cannot continue because of a problem with the current state. <a data-type="indexterm" data-primary="sentinel errors" data-secondary="origin of term" id="id1927"/><a data-type="indexterm" data-primary="Cheney, Dave" id="id1928"/>In his blog post <a href="https://oreil.ly/TiJnS">“Don’t Just Check Errors, Handle Them Gracefully”</a>, Dave Cheney, a developer who has been active in the Go community for many years, coined the term <em>sentinel errors</em> to describe these:</p>
<blockquote>
<p>The name descends from the practice in computer programming of using a specific value to signify that no further processing is possible. So too with Go, we use specific values to signify an error.</p>
</blockquote>

<p>Sentinel errors are one of the few variables<a data-type="indexterm" data-primary="package blocks" data-secondary="sentinel errors declaration" id="id1929"/><a data-type="indexterm" data-primary="variables" data-secondary="declaration" data-tertiary="sentinel errors in package block" id="id1930"/><a data-type="indexterm" data-primary="sentinel errors" data-secondary="declared in package block" id="id1931"/> that are declared at the package level. By convention, their names start with <code>Err</code> (with the notable exception of <code>io.EOF</code>). They should be treated as read-only; there’s no way for the Go compiler to enforce this, but it is a programming error to change their value.</p>

<p>Sentinel errors are usually used to indicate that you cannot start or continue processing. For example, the standard library includes a package for processing ZIP files, <code>archive/zip</code>. This package defines several sentinel errors, including <code>ErrFormat</code>, which is returned when data that doesn’t represent a ZIP file is passed in. Try out this code on <a href="https://oreil.ly/DaW-s">The Go Playground</a> or in the <em>sample_code/sentinel_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:<a data-type="indexterm" data-startref="ix_iii" id="id1932"/><a data-type="indexterm" data-startref="ix_iiii" id="id1933"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="p">[]</code><code class="nb">byte</code><code class="p">(</code><code class="s">"This is not a zip file"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">notAZipFile</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bytes</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">zip</code><code class="p">.</code><code class="nx">NewReader</code><code class="p">(</code><code class="nx">notAZipFile</code><code class="p">,</code><code class="w"> </code><code class="nb">int64</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="nx">data</code><code class="p">)))</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">zip</code><code class="p">.</code><code class="nx">ErrFormat</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Told you so"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Another example of a sentinel error in the standard library is <code>rsa.ErrMessa⁠ge​TooLong</code> in the <code>crypto/rsa</code> package. It indicates that a message cannot be encrypted because it is too long for the provided public key. The sentinel error 
<span class="keep-together"><code>context.Canceled</code></span> is covered in <a data-type="xref" href="ch14.html#unique_chapter_id_14">Chapter 14</a>.</p>

<p>Be sure you need a sentinel error before you define one. <a data-type="indexterm" data-primary="APIs" data-secondary="sentinel errors a part of public API" id="id1934"/>Once you define one, it is part of your public API, and you have committed to it being available in all future backward-compatible releases. It’s far better to reuse one of the existing ones in the standard library or to define an error type that includes information about the condition that caused the error to be returned (you’ll see how to do that in the next section). But if you have an error condition that indicates a specific state has been reached in your application where no further processing is possible and no additional information needs to be used to explain the error state, a sentinel error is the correct choice.</p>

<p>How do you test for a sentinel error? <a data-type="indexterm" data-primary="sentinel errors" data-secondary="testing for" id="id1935"/><a data-type="indexterm" data-primary="testing" data-secondary="sentinel errors" id="id1936"/>As you can see in the preceding code sample, use <code>==</code> to test whether the error was returned when calling a function whose documentation explicitly says it returns a sentinel error. In <a data-type="xref" href="#is_as">“Is and As”</a>, I discuss how to check for sentinel errors in other situations.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id1937">
<h1>Using Constants for Sentinel Errors</h1>
<p>In <a href="https://oreil.ly/1AnVg">“Constant Errors”</a>, Dave Cheney proposes<a data-type="indexterm" data-primary="Cheney, Dave" id="id1938"/><a data-type="indexterm" data-primary="const keyword" data-secondary="constants" data-tertiary="as sentinel errors" data-tertiary-sortas="sentinel errors" id="id1939"/><a data-type="indexterm" data-primary="sentinel errors" data-secondary="constants as" id="id1940"/> that constants would make useful sentinel errors. You’d have a type like this in a package (I’ll talk about creating packages in <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a>):</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">consterr</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="nx">Sentinel</code><code class="w"> </code><code class="kt">string</code><code class="w"/>

<code class="kd">func</code><code class="p">(</code><code class="nx">s</code><code class="w"> </code><code class="nx">Sentinel</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nb">string</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Then you’d use it like this:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code><code class="w"> </code><code class="nx">mypkg</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">ErrFoo</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">consterr</code><code class="p">.</code><code class="nx">Sentinel</code><code class="p">(</code><code class="s">"foo error"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">ErrBar</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">consterr</code><code class="p">.</code><code class="nx">Sentinel</code><code class="p">(</code><code class="s">"bar error"</code><code class="p">)</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>This looks like a function call, but it’s actually casting a string literal to a type that implements the <code>error</code> interface. Changing the values of 
<span class="keep-together"><code>ErrFoo</code></span> and <code>ErrBar</code> would be impossible. At first glance, this looks like a good solution.</p>

<p>However, this practice isn’t considered idiomatic. If you used the same type to create constant errors across packages, two errors would be equal if their error strings are equal. They’d also be equal to a string literal with the same value. Meanwhile, an error created with <code>errors.New</code> is equal only to itself or to variables explicitly assigned its value. You almost certainly do not want to make errors in different packages equal to each other; otherwise, why declare two different errors? (You could avoid this by creating a nonpublic error type in every package, but that’s a lot of boilerplate.)</p>

<p>The sentinel error pattern is another example of the Go design philosophy. Sentinel errors should be rare, so they can be handled by convention instead of language rules. Yes, they are public package-level variables. This makes them mutable, but it’s highly unlikely someone would accidentally reassign a public variable in a package. In short, it’s a corner case that is handled by other features and patterns. The Go philosophy is that it’s better to keep the language simple and trust the developers and tooling than it is to add features.</p>
</div></aside>

<p>So far, all the errors that you’ve seen are strings. But Go errors can contain more information. Let’s see <a data-type="indexterm" data-startref="ch09-senter" id="id1941"/><a data-type="indexterm" data-startref="ch09-senter2" id="id1942"/>how.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Errors Are Values"><div class="sect1" id="id108">
<h1>Errors Are Values</h1>

<p>Since <code>error</code> is an interface, you can<a data-type="indexterm" data-primary="errors" data-secondary="error handling" data-tertiary="values for errors" id="ch09-errvalu"/> define your own errors that include additional information for logging or error handling. For example, you might want to include a status code as part of the error to indicate the kind of error that should be reported back to the user. This lets you avoid string comparisons (whose text might change) to determine error causes. Let’s see how this works. First, define your own enumeration to represent the status codes:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Status</code><code class="w"> </code><code class="kt">int</code><code class="w"/>

<code class="kd">const</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">    </code><code class="nx">InvalidLogin</code><code class="w"> </code><code class="nx">Status</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="kc">iota</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mi">1</code><code class="w"/>
<code class="w">    </code><code class="nx">NotFound</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>

<p>Next, define a <code>StatusErr</code> to hold this value:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">StatusErr</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Status</code><code class="w">    </code><code class="nx">Status</code><code class="w"/>
<code class="w">    </code><code class="nx">Message</code><code class="w">   </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">se</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">se</code><code class="p">.</code><code class="nx">Message</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now you can use <code>StatusErr</code> to provide more details about what went wrong:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">LoginAndGetData</code><code class="p">(</code><code class="nx">uid</code><code class="p">,</code><code class="w"> </code><code class="nx">pwd</code><code class="p">,</code><code class="w"> </code><code class="nx">file</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">token</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">login</code><code class="p">(</code><code class="nx">uid</code><code class="p">,</code><code class="w"> </code><code class="nx">pwd</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w">    </code><code class="nx">InvalidLogin</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="nx">Message</code><code class="p">:</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"invalid credentials for user %s"</code><code class="p">,</code><code class="w"> </code><code class="nx">uid</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">getData</code><code class="p">(</code><code class="nx">token</code><code class="p">,</code><code class="w"> </code><code class="nx">file</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w">    </code><code class="nx">NotFound</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="nx">Message</code><code class="p">:</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"file %s not found"</code><code class="p">,</code><code class="w"> </code><code class="nx">file</code><code class="p">),</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/custom_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iii2"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iiii2"/></p>

<p>Even when you define your own custom error types, always use <code>error</code> as the return type for the error result. This allows you to return different types of errors from your function and allows callers of your function to choose not to depend on the specific error type.</p>

<p>If you are using your own error type, be sure you don’t return an uninitialized instance. Let’s see what happens if you do. Try out the following code on <a href="https://oreil.ly/MPaHx">The Go Playground</a> or in the <em>sample_code/return_custom_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">GenerateErrorBroken</code><code class="p">(</code><code class="nx">flag</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">genErr</code><code class="w"> </code><code class="nx">StatusErr</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">flag</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">genErr</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w"> </code><code class="nx">NotFound</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">genErr</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">GenerateErrorBroken</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"GenerateErrorBroken(true) returns non-nil error:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">GenerateErrorBroken</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"GenerateErrorBroken(false) returns non-nil error:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this program produces the following output:</p>

<pre data-type="programlisting">true
true</pre>

<p>This isn’t a pointer type versus value type issue; if you declared <code>genErr</code> to be of type <code>*StatusErr</code>, you’d see the same output. The reason <code>err</code> is non-nil is that <code>error</code> is an interface. As I discussed in <a data-type="xref" href="ch07.html#interface_nil">“Interfaces and nil”</a>, for an interface to be considered <code>nil</code>, both the underlying type and the underlying value must be <code>nil</code>. Whether or not <code>genErr</code> is a pointer, the underlying type part of the interface is not <code>nil</code>.</p>

<p>You can fix this in two ways. The most common approach is to explicitly return <code>nil</code> for the error value when a function completes successfully:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">GenerateErrorOKReturnNil</code><code class="p">(</code><code class="nx">flag</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">flag</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w"> </code><code class="nx">NotFound</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This has the advantage of not requiring you to read through code to make sure that the error variable on the <code>return</code> statement is correctly defined.</p>

<p>Another approach is to make sure that any local variable that holds an <code>error</code> is of type <code>error</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">GenerateErrorUseErrorVar</code><code class="p">(</code><code class="nx">flag</code><code class="w"> </code><code class="kt">bool</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">genErr</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">flag</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">genErr</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w"> </code><code class="nx">NotFound</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">genErr</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>When using custom errors, never define a variable to be of the type of your custom error. Either explicitly return <code>nil</code> when no error occurs or define the variable to be of type <code>error</code>.</p>
</div>

<p>As was covered in <a data-type="xref" href="ch07.html#rare_type_assertions">“Use Type Assertions and Type Switches Sparingly”</a>, don’t use a type assertion or a type switch to access the fields and methods of a custom error. Instead, use <code>errors.As</code>, which is discussed in <a data-type="xref" href="#is_as">“Is and As”</a>.<a data-type="indexterm" data-startref="ch09-errvalu" id="id1943"/></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Errors"><div class="sect1" id="id109">
<h1>Wrapping Errors</h1>

<p>When an error is passed back through your code,<a data-type="indexterm" data-primary="errors" data-secondary="wrapping errors" id="ch09-wrer"/><a data-type="indexterm" data-primary="wrapping errors" id="ch09-wrer2"/> you often want to add information to it. This can be the name of the function that received the error or the operation it was trying to perform. When you preserve an error while adding information, it is called <em>wrapping</em> the error. When you have a series of wrapped errors, it is called an <em>error tree</em>.</p>

<p>A function in the Go standard library wraps errors, and you’ve already seen it. The <code>fmt.Errorf</code> function has a special verb, <code>%w</code>. Use this to create an error whose formatted string includes the formatted string of another error and which contains the original error as well. The convention is to write <code>: %w</code> at the end of the error format string and to make the error to be wrapped the last parameter passed to <code>fmt.Errorf</code>.</p>

<p>The standard library also provides a function for unwrapping errors, the <code>Unwrap</code> function in the <code>errors</code> package. You pass it an error, and it returns the wrapped error if there is one. If there isn’t, it returns <code>nil</code>. Here’s a quick program that demonstrates wrapping with <code>fmt.Errorf</code> and unwrapping with <code>errors.Unwrap</code>. You can run it on <a href="https://oreil.ly/HxdHz">The Go Playground</a> or in the <em>sample_code/wrap_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">func</code><code class="w"> </code><code class="nx">fileChecker</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in fileChecker: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fileChecker</code><code class="p">(</code><code class="s">"not_here.txt"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">wrappedErr</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Unwrap</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code><code class="w"> </code><code class="nx">wrappedErr</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">wrappedErr</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>When you run this program, you see the following output:</p>

<pre data-type="programlisting">in fileChecker: open not_here.txt: no such file or directory
open not_here.txt: no such file or directory</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You don’t usually call <code>errors.Unwrap</code> directly. Instead, you use <code>errors.Is</code> and <code>errors.As</code> to find a specific wrapped error. I’ll talk about these two functions in the next section.</p>
</div>

<p>If you want to wrap an error with your custom error type, your error type needs to implement the method <code>Unwrap</code>. This method takes in no parameters and returns an <code>error</code>. Here’s an update to the error that you defined earlier to demonstrate how this works. You can find it in the <em>sample_code/custom_wrapped_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:<a data-type="indexterm" data-startref="ix_iii2" id="id1944"/><a data-type="indexterm" data-startref="ix_iiii2" id="id1945"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">StatusErr</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Status</code><code class="w">  </code><code class="nx">Status</code><code class="w"/>
<code class="w">    </code><code class="nx">Message</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Err</code><code class="w">     </code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">se</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">se</code><code class="p">.</code><code class="nx">Message</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">se</code><code class="w"> </code><code class="nx">StatusErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">se</code><code class="p">.</code><code class="nx">Err</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now you can use <code>StatusErr</code> to wrap underlying errors:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">LoginAndGetData</code><code class="p">(</code><code class="nx">uid</code><code class="p">,</code><code class="w"> </code><code class="nx">pwd</code><code class="p">,</code><code class="w"> </code><code class="nx">file</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">([]</code><code class="kt">byte</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">token</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">login</code><code class="p">(</code><code class="nx">uid</code><code class="p">,</code><code class="nx">pwd</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">StatusErr</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w"> </code><code class="nx">InvalidLogin</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="nx">Message</code><code class="p">:</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"invalid credentials for user %s"</code><code class="p">,</code><code class="nx">uid</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="nx">Err</code><code class="p">:</code><code class="w"> </code><code class="nx">err</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">getData</code><code class="p">(</code><code class="nx">token</code><code class="p">,</code><code class="w"> </code><code class="nx">file</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">StatusErr</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">Status</code><code class="p">:</code><code class="w"> </code><code class="nx">NotFound</code><code class="p">,</code><code class="w"/>
<code class="w">            </code><code class="nx">Message</code><code class="p">:</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"file %s not found"</code><code class="p">,</code><code class="nx">file</code><code class="p">),</code><code class="w"/>
<code class="w">            </code><code class="nx">Err</code><code class="p">:</code><code class="w"> </code><code class="nx">err</code><code class="p">,</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Not all errors need to be wrapped. A library can return an error that means processing cannot continue, but the error message contains implementation details that aren’t needed in other parts of your program. In this situation, it is perfectly 
<span class="keep-together">acceptable</span> to create a brand-new error and return that instead. Understand the situation and determine what needs to be returned.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you want to create a new error that contains the message from another error, but don’t want to wrap it, use <code>fmt.Errorf</code> to create an error but use the <code>%v</code> verb instead of <code>%w</code>:<a data-type="indexterm" data-startref="ch09-wrer" id="id1946"/><a data-type="indexterm" data-startref="ch09-wrer2" id="id1947"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">internalFunction</code><code class="p">()</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"internal failure: %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Multiple Errors"><div class="sect1" id="id248">
<h1>Wrapping Multiple Errors</h1>

<p>Sometimes a function generates<a data-type="indexterm" data-primary="errors" data-secondary="wrapping errors" data-tertiary="wrapping multiple errors" id="id1948"/><a data-type="indexterm" data-primary="wrapping errors" data-secondary="wrapping multiple errors" id="id1949"/> multiple errors that should be returned. For example, if you wrote a function to validate the fields in a struct, it would be better to return an error for each invalid field. Since the standard function signature returns <code>error</code> and not <code>[]error</code>, you need to merge multiple errors into a single error. That’s what the <code>errors.Join</code> function is for:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">Person</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">FirstName</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">LastName</code><code class="w">  </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Age</code><code class="w">       </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">ValidatePerson</code><code class="p">(</code><code class="nx">p</code><code class="w"> </code><code class="nx">Person</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="kd">var</code><code class="w"> </code><code class="nx">errs</code><code class="w"> </code><code class="p">[]</code><code class="kt">error</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">FirstName</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">errs</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">errs</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"field FirstName cannot be empty"</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">LastName</code><code class="p">)</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">errs</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">errs</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"field LastName cannot be empty"</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">p</code><code class="p">.</code><code class="nx">Age</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">errs</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nb">append</code><code class="p">(</code><code class="nx">errs</code><code class="p">,</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"field Age cannot be negative"</code><code class="p">))</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">errs</code><code class="p">)</code><code class="w"> </code><code class="p">&gt;</code><code class="w"> </code><code class="mi">0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Join</code><code class="p">(</code><code class="nx">errs</code><code class="o">...</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can find this code in the <em>sample_code/join_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_i123i"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iii123"/></p>

<p>Another way to merge multiple errors is to pass multiple <code>%w</code> verbs to <code>fmt.Errorf</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">err1</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"first error"</code><code class="p">)</code><code class="w"/>
<code class="nx">err2</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"second error"</code><code class="p">)</code><code class="w"/>
<code class="nx">err3</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="s">"third error"</code><code class="p">)</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"first: %w, second: %w, third: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err1</code><code class="p">,</code><code class="w"> </code><code class="nx">err2</code><code class="p">,</code><code class="w"> </code><code class="nx">err3</code><code class="p">)</code><code class="w"/></pre>

<p>You can implement your own <code>error</code> type that supports multiple wrapped errors. To do so, implement the <code>Unwrap</code> method but have it return <code>[]error</code> instead of <code>error</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MyError</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Code</code><code class="w">   </code><code class="kt">int</code><code class="w"/>
<code class="w">    </code><code class="nx">Errors</code><code class="w"> </code><code class="p">[]</code><code class="kt">error</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">type</code><code class="w"> </code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="nx">MyError</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Join</code><code class="p">(</code><code class="nx">m</code><code class="p">.</code><code class="nx">Errors</code><code class="o">...</code><code class="p">).</code><code class="nx">Error</code><code class="p">()</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="nx">MyError</code><code class="p">)</code><code class="w"> </code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"> </code><code class="p">[]</code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">m</code><code class="p">.</code><code class="nx">Errors</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Go doesn’t support method overloading, so you can’t create a single type that provides both implementations of <code>Unwrap</code>. Also note that the <code>errors.Unwrap</code> function will return <code>nil</code> if you pass it an error that implements the <code>[]error</code> variant of <code>Unwrap</code>. This is another reason you shouldn’t call the <code>errors.Unwrap</code> function directly.</p>

<p>If you need to handle errors that may wrap zero, one, or multiple errors, use this code as a basis. You can find it in the <em>sample_code/custom_wrapped_multi_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">var</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="w"/>
<code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">funcThatReturnsAnError</code><code class="p">()</code><code class="w"/>
<code class="k">switch</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">err</code><code class="p">.(</code><code class="kd">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"> </code><code class="kt">error</code><code class="p">}:</code><code class="w"/>
<code class="w">    </code><code class="c1">// handle single error</code><code class="w"/>
<code class="w">    </code><code class="nx">innerErr</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">err</code><code class="p">.</code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="c1">// process innerErr</code><code class="w"/>
<code class="k">case</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"> </code><code class="p">[]</code><code class="kt">error</code><code class="p">}:</code><code class="w"/>
<code class="w">    </code><code class="c1">//handle multiple wrapped errors</code><code class="w"/>
<code class="w">    </code><code class="nx">innerErrs</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">err</code><code class="p">.</code><code class="nx">Unwrap</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">innerErr</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">innerErrs</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="c1">// process each innerErr</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="c1">// handle no wrapped error</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Since the standard library doesn’t define interfaces to represent errors with either <code>Unwrap</code> variant, this code uses anonymous interfaces in a type switch to match the methods and access the wrapped errors. Before writing your own code, see if you can use <code>errors.Is</code> and <code>errors.As</code> to examine your error trees. Let’s see how they work.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Is and As"><div class="sect1" id="is_as">
<h1>Is and As</h1>

<p>Wrapping errors is a useful way to get additional information about an error, but it introduces problems. <a data-type="indexterm" data-primary="sentinel errors" data-secondary="wrapped not checkable by ==" id="id1950"/><a data-type="indexterm" data-primary="wrapping errors" data-secondary="sentinel errors not checkable by ==" id="id1951"/><a data-type="indexterm" data-primary="errors" data-secondary="wrapping errors" data-tertiary="sentinel errors not checkable by ==" id="id1952"/>If a sentinel error is wrapped, you cannot use <code>==</code> to check for it, nor can you use a type assertion or type switch to match a wrapped custom error. Go solves this problem with two functions in the <code>errors</code> package, <code>Is</code> and <code>As</code>.</p>

<p>To check whether the returned error or <a data-type="indexterm" data-primary="errors package" data-secondary="errors.Is" id="id1953"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.Is" id="id1954"/><a data-type="indexterm" data-primary="sentinel errors" data-secondary="wrapped not checkable by ==" data-tertiary="errors.Is" id="id1955"/>any errors that it wraps match a specific sentinel error instance, use <code>errors.Is</code>. It takes in two parameters: the error being checked and the instance you are comparing it against. The <code>errors.Is</code> function returns <code>true</code> if any error in the error tree matches the provided sentinel error. You’ll write a short program to see <code>errors.Is</code> in action. You can run it yourself on <a href="https://oreil.ly/5_6rI">The Go Playground</a> or in the <em>sample_code/is_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:<a data-type="indexterm" data-startref="ix_i123i" id="id1956"/><a data-type="indexterm" data-startref="ix_iii123" id="id1957"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">fileChecker</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Open</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in fileChecker: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">f</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">fileChecker</code><code class="p">(</code><code class="s">"not_here.txt"</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Is</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">ErrNotExist</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"That file doesn't exist"</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this program produces the following output:</p>

<pre data-type="programlisting">That file doesn't exist</pre>

<p>By default, <code>errors.Is</code> uses <code>==</code> to compare each wrapped error with the specified error. If this does not work for an error type that you define (for example, if your error is a noncomparable type), implement the <code>Is</code> method on your error:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">MyErr</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Codes</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">me</code><code class="w"> </code><code class="nx">MyErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"codes: %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">me</code><code class="p">.</code><code class="nx">Codes</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">me</code><code class="w"> </code><code class="nx">MyErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Is</code><code class="p">(</code><code class="nx">target</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">me2</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">target</code><code class="p">.(</code><code class="nx">MyErr</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">slices</code><code class="p">.</code><code class="nx">Equal</code><code class="p">(</code><code class="nx">me</code><code class="p">.</code><code class="nx">Codes</code><code class="p">,</code><code class="w"> </code><code class="nx">me2</code><code class="p">.</code><code class="nx">Codes</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>(The <code>slices.Equal</code> function was mentioned back in <a data-type="xref" href="ch03.html#slice_info">“Slices”</a>.)</p>

<p>Another use for defining your own <code>Is</code> method is to allow comparisons against errors that aren’t identical instances. You might want to pattern match your errors, specifying a filter instance that matches errors that have some of the same fields. Define a new error type, <code>ResourceErr</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code><code class="w"> </code><code class="nx">ResourceErr</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">Resource</code><code class="w">     </code><code class="kt">string</code><code class="w"/>
<code class="w">    </code><code class="nx">Code</code><code class="w">         </code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">re</code><code class="w"> </code><code class="nx">ResourceErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Error</code><code class="p">()</code><code class="w"> </code><code class="kt">string</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%s: %d"</code><code class="p">,</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">Resource</code><code class="p">,</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">Code</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If you want two <code>ResourceErr</code> instances to match when either field is set, you can do so by writing a custom <code>Is</code> method:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">re</code><code class="w"> </code><code class="nx">ResourceErr</code><code class="p">)</code><code class="w"> </code><code class="nx">Is</code><code class="p">(</code><code class="nx">target</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="kt">bool</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">other</code><code class="p">,</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">target</code><code class="p">.(</code><code class="nx">ResourceErr</code><code class="p">);</code><code class="w"> </code><code class="nx">ok</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">ignoreResource</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Resource</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">        </code><code class="nx">ignoreCode</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Code</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">        </code><code class="nx">matchResource</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Resource</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">Resource</code><code class="w"/>
<code class="w">        </code><code class="nx">matchCode</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">other</code><code class="p">.</code><code class="nx">Code</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="nx">re</code><code class="p">.</code><code class="nx">Code</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="nx">matchResource</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">matchCode</code><code class="w"> </code><code class="o">||</code><code class="w"/>
<code class="w">            </code><code class="nx">matchResource</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">ignoreCode</code><code class="w"> </code><code class="o">||</code><code class="w"/>
<code class="w">            </code><code class="nx">ignoreResource</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">matchCode</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="kc">false</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Now you can find, for example, all errors that refer to the database, no matter the code:</p>

<pre data-type="programlisting" data-code-language="go"><code class="k">if</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">Is</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="nx">ResourceErr</code><code class="p">{</code><code class="nx">Resource</code><code class="p">:</code><code class="w"> </code><code class="s">"Database"</code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"The database is broken:"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="c1">// process the codes</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can see this code on <a href="https://oreil.ly/Mz_Op">The Go Playground</a> or in the <em>sample_code/cus⁠tom_is​_error_pattern_match</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="id1958"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="id1959"/></p>

<p>The <code>errors.As</code> function allows you<a data-type="indexterm" data-primary="errors package" data-secondary="errors.As" id="id1960"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="errors.As" id="id1961"/> to check whether a returned error (or any error it wraps) matches a specific type. It takes in two parameters. The first is the error being examined, and the second is a pointer to a variable of the type that you are looking for. If the function returns <code>true</code>, an error in the error tree was found that matched, and that matching error is assigned to the second parameter. If the function returns <code>false</code>, no match was found in the error tree. Try it out with <code>MyErr</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">AFunctionThatReturnsAnError</code><code class="p">()</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">myErr</code><code class="w"> </code><code class="nx">MyErr</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">As</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">myErr</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">myErr</code><code class="p">.</code><code class="nx">Codes</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Note that you use <code>var</code> to declare a variable of a specific type set to the zero value. You then pass a pointer to this variable into <code>errors.As</code>.</p>

<p>You don’t have to pass a pointer to a variable of an error type as the second parameter to <code>errors.As</code>. You can pass a pointer to an interface to find an error that meets the interface:</p>

<pre data-type="programlisting" data-code-language="go"><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">AFunctionThatReturnsAnError</code><code class="p">()</code><code class="w"/>
<code class="kd">var</code><code class="w"> </code><code class="nx">coder</code><code class="w"> </code><code class="kd">interface</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">CodeVals</code><code class="p">()</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="k">if</code><code class="w"> </code><code class="nx">errors</code><code class="p">.</code><code class="nx">As</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">coder</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">coder</code><code class="p">.</code><code class="nx">CodeVals</code><code class="p">())</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The example uses an anonymous interface, but any interface type is acceptable. You can find both <code>errors.As</code> examples in the <em>sample_code/custom_as_error</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If the second parameter to <code>errors.As</code> is anything other than a pointer to an error or a pointer to an interface, the method panics.</p>
</div>

<p>Just as you can override the default <code>errors.Is</code> comparison with an <code>Is</code> method, you can override the default <code>errors.As</code> comparison with an <code>As</code> method on your error. Implementing an <code>As</code> method is nontrivial and requires reflection (I will talk about reflection in Go in <a data-type="xref" href="ch16.html#unique_chapter_id_16">Chapter 16</a>). You should do it only in unusual circumstances, such as when you want to match an error of one type and return another.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Use <code>errors.Is</code> when you are looking for a specific <em>instance</em> or specific <em>values</em>. Use <code>errors.As</code> when you are looking for a specific <em>type</em>.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Errors with defer"><div class="sect1" id="id249">
<h1>Wrapping Errors with defer</h1>

<p>Sometimes you find yourself wrapping multiple errors with the same message:<a data-type="indexterm" data-primary="errors" data-secondary="wrapping errors" data-tertiary="defer" id="id1962"/><a data-type="indexterm" data-primary="defer keyword" data-secondary="wrapping errors with" id="id1963"/><a data-type="indexterm" data-primary="keywords" data-secondary="defer" id="id1964"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">DoSomeThings</code><code class="p">(</code><code class="nx">val1</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">val2</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">val3</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doThing1</code><code class="p">(</code><code class="nx">val1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in DoSomeThings: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">val4</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doThing2</code><code class="p">(</code><code class="nx">val2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in DoSomeThings: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doThing3</code><code class="p">(</code><code class="nx">val3</code><code class="p">,</code><code class="w"> </code><code class="nx">val4</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in DoSomeThings: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">result</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You can simplify this code by using <code>defer</code>:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">DoSomeThings</code><code class="p">(</code><code class="nx">val1</code><code class="w"> </code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="nx">val2</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">_</code><code class="w"> </code><code class="kt">string</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"in DoSomeThings: %w"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="nx">val3</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doThing1</code><code class="p">(</code><code class="nx">val1</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="nx">val4</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">doThing2</code><code class="p">(</code><code class="nx">val2</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="s">""</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">doThing3</code><code class="p">(</code><code class="nx">val3</code><code class="p">,</code><code class="w"> </code><code class="nx">val4</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>You have to name the return values so that you can refer to <code>err</code> in the deferred function. If you name a single return value, you must name all of them, so you use an underscore here for the string return value that isn’t explicitly assigned.</p>

<p>In the <code>defer</code> closure, the code checks whether an error was returned. If so, it reassigns the error to a new error that wraps the original error with a message indicating which function detected the error.</p>

<p>This pattern works well when you are wrapping every error with the same message. If you want to customize the wrapping error with more detail, put both the specific and the general message in every <code>fmt.Errorf</code>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="panic and recover"><div class="sect1" id="panic_recover">
<h1>panic and recover</h1>

<p>Previous chapters have mentioned<a data-type="indexterm" data-primary="panics" data-secondary="about panics" id="ch09-pan"/><a data-type="indexterm" data-primary="errors" data-secondary="panic and recover" data-seealso="panics" id="ch09-pan2"/> panics in passing without going into any details on what they are. A <em>panic</em> is similar to an <code>Error</code> in Java or Python. It is a state generated by the Go runtime whenever it is unable to figure out what should happen next. This is almost always due to a programming error, like an attempt to read past the end of a slice or passing a negative size to <code>make</code>. The Go runtime also panics if it detects bugs in itself, such as the garbage collector misbehaving. However, I’ve never seen this happen. If there’s a panic, blame the runtime last.</p>

<p>As soon as a panic happens, the current function exits immediately, and any <code>defer</code>s attached to the current function start running. When those <code>defer</code>s complete, the <code>defer</code>s attached to the calling function run, and so on, until <code>main</code> is reached. The program then exits with a message and a stack trace.<a data-type="indexterm" data-primary="panics" data-secondary="about panics" data-tertiary="stack trace" id="id1965"/><a data-type="indexterm" data-primary="stack" data-secondary="stack traces" data-tertiary="panics providing" id="id1966"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If there is a panic in a goroutine other than the main goroutine (goroutines are covered in <a data-type="xref" href="ch12.html#goroutines">“Goroutines”</a>), the chain of defers ends at the function used to launch the goroutine. A program exits if <em>any</em> goroutine panics without being recovered.</p>
</div>

<p>If any situations in your programs are unrecoverable, you can create your own panics. The built-in function <code>panic</code> takes one parameter, which can be of any type. Usually, it is a string. Following is a trivial program that panics; you can run it on <a href="https://oreil.ly/yCBib">The Go Playground</a> or in the <em>sample_code/panic</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iiiii"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="ix_iii1234"/></p>

<pre data-type="programlisting" data-code-language="go" class="less_space pagebreak-before"><code class="kd">func</code><code class="w"> </code><code class="nx">doPanic</code><code class="p">(</code><code class="nx">msg</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nb">panic</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nx">doPanic</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Running this code produces the following output:</p>

<pre data-type="programlisting">panic: /tmpfs/play

goroutine 1 [running]:
main.doPanic(...)
    /tmp/sandbox567884271/prog.go:6
main.main()
    /tmp/sandbox567884271/prog.go:10 +0x5f</pre>

<p>As you can see, a <code>panic</code> prints out its message followed by a stack trace.</p>

<p>Go provides a way to capture a <code>panic</code> to provide<a data-type="indexterm" data-primary="panics" data-secondary="about panics" data-tertiary="recover" id="id1967"/> a more graceful shutdown or to prevent shutdown at all. The built-in <code>recover</code> function is called from within a <code>defer</code> to check whether a <code>panic</code> happened. If there was a <code>panic</code>, the value assigned to the <code>panic</code> is returned. Once a <code>recover</code> happens, execution continues normally. Let’s take a look with another sample program. Run it on <a href="https://oreil.ly/f5Ybe">The Go Playground</a> or in the <em>sample_code/panic_recover</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>:<a data-type="indexterm" data-startref="ix_iiiii" id="id1968"/><a data-type="indexterm" data-startref="ix_iii1234" id="id1969"/></p>

<pre data-type="programlisting" data-code-language="go"><code class="kd">func</code><code class="w"> </code><code class="nx">div60</code><code class="p">(</code><code class="nx">i</code><code class="w"> </code><code class="kt">int</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">defer</code><code class="w"> </code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nb">recover</code><code class="p">();</code><code class="w"> </code><code class="nx">v</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code><code class="w"/>
<code class="w">        </code><code class="p">}</code><code class="w"/>
<code class="w">    </code><code class="p">}()</code><code class="w"/>
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="mi">60</code><code class="w"> </code><code class="o">/</code><code class="w"> </code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/>

<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">val</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="p">[]</code><code class="kt">int</code><code class="p">{</code><code class="mi">1</code><code class="p">,</code><code class="w"> </code><code class="mi">2</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"> </code><code class="mi">6</code><code class="p">}</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nx">div60</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>There’s a specific pattern for using <code>recover</code>. You register a function with <code>defer</code> to handle a potential <code>panic</code>. You call <code>recover</code> within an <code>if</code> statement and check whether a non-nil value was found. You must call <code>recover</code> from within a <code>defer</code> because once a <code>panic</code> happens, only deferred functions are run.</p>

<p class="pagebreak-before">Running this code produces the following output:</p>

<pre data-type="programlisting">60
30
runtime error: integer divide by zero
10</pre>

<p>Since <code>recover</code> uses a non-nil value to detect whether a <code>panic</code> happened, a clever reader might raise the question: <em>What happens if you call <code>panic(nil)</code> and there’s a <code>recover</code>?</em> In code compiled with Go versions before 1.21, the answer was “nothing great.” In those versions, <code>recover</code> stops a <code>panic</code> from propagating, but no message or data indicates what happened. Starting with Go 1.21, a <code>panic(nil)</code> call is identical to <code>panic(new(runtime.PanicNilError))</code>.</p>

<p>While <code>panic</code> and <code>recover</code> look a lot like exception handling in other languages, they are not intended to be used that way. Reserve panics for fatal situations and use <code>recover</code> as a way to gracefully handle these situations. If your program panics, be careful about trying to continue executing after the panic. You’ll rarely want to keep your program running after a <code>panic</code> occurs. If the <code>panic</code> was triggered because the computer is out of a resource like memory or disk space, the safest thing to do is use <code>recover</code> to log the situation to monitoring software and shut down with <code>os.Exit(1)</code>. If a programming error caused the panic, you can try to continue, but you’ll likely hit the same problem again. In the preceding sample program, it would be idiomatic to check for division by zero and return an error if one was passed in.</p>

<p>The reason you don’t rely on <code>panic</code> and <code>recover</code> is that <code>recover</code> doesn’t make clear <em>what</em> could fail. It just ensures that <em>if</em> something fails, you can print out a message and continue. Idiomatic Go favors code that explicitly outlines the possible failure conditions over shorter code that handles anything while saying nothing.</p>

<p>Using<a data-type="indexterm" data-primary="APIs" data-secondary="panics must not escape public APIs" id="id1970"/> <code>recover</code> is recommended in one situation. If you are creating a library for third parties, do not let panics escape the boundaries of your public API. If a <code>panic</code> is possible, a public function should use <code>recover</code> to convert the <code>panic</code> into an error, return it, and let the calling code decide what to do with them.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While the HTTP server built into Go recovers from panics in handlers, David Symonds said in a <a href="https://oreil.ly/BGOmg">GitHub comment</a> that as of 2015, this is now considered a mistake by the Go team.<a data-type="indexterm" data-startref="ch09-pan" id="id1971"/><a data-type="indexterm" data-startref="ch09-pan2" id="id1972"/></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Getting a Stack Trace from an Error"><div class="sect1" id="id250">
<h1>Getting a Stack Trace from an Error</h1>

<p>One of the reasons that new Go developers<a data-type="indexterm" data-primary="stack" data-secondary="stack traces" data-tertiary="errors providing" id="id1973"/><a data-type="indexterm" data-primary="errors" data-secondary="stack trace from" id="id1974"/> are tempted to use <code>panic</code> and <code>recover</code> is they want to get a stack trace when something goes wrong. By default, Go doesn’t provide that. As I’ve shown, you can use error wrapping to build a call stack by hand, but some third-party libraries with error types generate those stacks automatically (see <a data-type="xref" href="ch10.html#unique_chapter_id_10">Chapter 10</a> to learn how to incorporate third-party code in your program). Cockroachdb provides a <a href="https://oreil.ly/-n1EX">third-party library</a> with functions for wrapping errors with stack traces.</p>

<p>By default, the stack trace is not printed out.<a data-type="indexterm" data-primary="fmt package" data-secondary="fmt.Printf" data-tertiary="stack trace via verbose output" id="id1975"/><a data-type="indexterm" data-primary="Printf (fmt package)" data-secondary="stack trace via verbose output" id="id1976"/> If you want to see the stack trace, use <code>fmt.Printf</code> and the verbose output verb (<code>%+v</code>). <a data-type="indexterm" data-primary="errors" data-secondary="documentation URL" id="id1977"/><a data-type="indexterm" data-primary="resources online" data-secondary="errors package documentation" id="id1978"/><a data-type="indexterm" data-primary="errors package" data-secondary="documentation URL" id="id1979"/><a data-type="indexterm" data-primary="standard library" data-secondary="errors package" data-tertiary="documentation URL" id="id1980"/>Check the <a href="https://oreil.ly/3-5Ql">documentation</a> to learn more.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you have a stack trace in your error, the output includes the full path to the file on the computer where the program was compiled. If you don’t want to expose the path, use the <code>-trimpath</code> flag when building your code. This replaces the full path with the 
<span class="keep-together">package.</span></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exercises"><div class="sect1" id="id284">
<h1>Exercises</h1>

<p>Look at the code in the <em>sample_code/exercise</em> directory in the <a href="https://oreil.ly/KCSeb">Chapter 9 repository</a>.<a data-type="indexterm" data-primary="resources online" data-secondary="book supplemental material" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="id1981"/><a data-type="indexterm" data-primary="book supplemental material URL" data-secondary="code repository" data-tertiary="Chapter 9" data-tertiary-sortas="iii" id="id1982"/> You are going to modify this code in each of these exercises. It works correctly, but improvements should be made to its error handling.</p>
<ol>
<li>
<p>Create a sentinel error to represent an invalid ID. In <code>main</code>, use <code>errors.Is</code> to check for the sentinel error, and print a message when it is found.</p>
</li>
<li>
<p>Define a custom error type to represent an empty field error. This error should include the name of the empty <code>Employee</code> field. In <code>main</code>, use <code>errors.As</code> to check for this error. Print out a message that includes the field name.</p>
</li>
<li>
<p>Rather than returning the first error found, return back a single error that contains all errors discovered during validation. Update the code in <code>main</code> to properly report multiple errors.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wrapping Up"><div class="sect1" id="id347">
<h1>Wrapping Up</h1>

<p>This chapter covered errors in Go, what they are, how to define your own, and how to examine them. You also took a look at <code>panic</code> and <code>recover</code>. The next chapter discusses packages and modules, how to use third-party code in your programs, and how to publish your own code for others to use.</p>
</div></section>
</div></section></div>
</div>
</body></html>