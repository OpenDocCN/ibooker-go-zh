["```go\nimport (\n    \"os\"\n\n    \"github.com/efficientgo/core/errors\"\n    \"github.com/efficientgo/core/merrors\"\n    \"golang.org/x/sys/unix\"\n)\n\ntype MemoryMap struct {\n    f *os.File // nil if anonymous.\n    b []byte\n}\n\nfunc OpenFileBacked(path string, size int) (mf *MemoryMap, _ error) { ![1](assets/1.png)\n    f, err := os.Open(path)\n    if err != nil {\n        return nil, err\n    }\n\n    b, err := unix.Mmap(int(f.Fd()), 0, size, unix.PROT_READ, unix.MAP_SHARED) ![2](assets/2.png)\n    if err != nil {\n        return nil, merrors.New(f.Close(), err).Err() ![3](assets/3.png)\n    }\n\n    return &MemoryMap{f: f, b: b}, nil\n}\n\nfunc (f *MemoryMap) Close() error {\n    errs := merrors.New()\n    errs.Add(unix.Munmap(f.b)) ![4](assets/4.png)\n    errs.Add(f.f.Close())\n    return errs.Err()\n}\n\nfunc (f *MemoryMappedFile) Bytes() []byte { return f.b }\n```", "```go\nf, err := os.Open(\"test686mbfile.out\") ![1](assets/1.png)\nif err != nil {\n   return err\n}\n\nb := make([]byte, 600*1024*1024)\nif _, err := f.Read(b); err != nil { ![2](assets/2.png)\n   return err\n}\n\nfmt.Println(\"Reading the 5000th byte\", b[5000]) ![3](assets/3.png)\nfmt.Println(\"Reading the 100 000th byte\", b[100000]) ![3](assets/3.png)\nfmt.Println(\"Reading the 104 000th byte\", b[104000]) ![3](assets/3.png)\n\nif err := f.Close(); err != nil {\n   return err\n}\n```", "```go\nf, err := mmap.OpenFileBacked(\"test686mbfile.out,\" 600*1024*1024) ![1](assets/1.png)\nif err != nil {\n   return err\n}\nb := f.Bytes() ![2](assets/2.png)\n\nfmt.Println(\"Reading the 5000th byte\", b[5000]) ![3](assets/3.png)\nfmt.Println(\"Reading the 100 000th byte\", b[100000]) ![4](assets/4.png)\nfmt.Println(\"Reading the 104 000th byte\", b[104000]) ![5](assets/5.png)\n\nif err := f.Close(); err != nil { ![6](assets/6.png)\n   return err\n}\n```", "```go\nfunc myFunction(\n    arg1 int, arg2 *int, ![1](assets/1.png)\n    arg3 biggie, arg4 *biggie, ![2](assets/2.png)\n    arg5 []byte, arg6 *[]byte, ![3](assets/3.png)\n    arg7 chan byte, arg8 map[string]int, arg9 func(), ![4](assets/4.png)\n) {\n   // ...\n}\n\ntype biggie struct { ![2](assets/2.png)\n    huge [1e8]byte\n    other *biggie\n}\n```", "```go\nb := make([]byte, 600*1024*1024) ![1](assets/1.png)\nb[5000] = 1\nb[100000] = 1\nb[104000] = 1 ![2](assets/2.png)\nfor i := range b { ![3](assets/3.png)\n   b[i] = 1\n}\n```", "```go\nb := make([]byte, 600*1024*1024)\nfor i := range b { ![1](assets/1.png)\n   b[i] = 1\n}\n\nb[5000] = 1 ![2](assets/2.png)\nb = nil ![3](assets/3.png)\nruntime.GC() ![4](assets/4.png)\n\n// Let's allocate another one, this time 300 MB!\nb = make([]byte, 300*1024*1024)\nfor i := range b { ![5](assets/5.png)\n   b[i] = 2\n}\n```"]