["```go\nfunc Sum(fileName string) (ret int64, _ error) {\n   b, err := os.ReadFile(fileName)\n   if err != nil {\n      return 0, err\n   }\n\n   for _, line := range bytes.Split(b, []byte(\"\\n\")) {\n      num, err := strconv.ParseInt(string(line), 10, 64)\n      if err != nil {\n         return 0, err\n      }\n\n      ret += num ![1](assets/1.png)\n   }\n\n   return ret, nil\n}\n```", "```go\n// go tool objdump -s sum.test\nret += num\n0x4f9b6d      488b742450    MOVQ 0x50(SP), SI  ![1](assets/1.png)\n0x4f9b72      4801c6       ADDQ AX, SI  ![2](assets/2.png)\n```", "```go\n# command-line-arguments ./sum.go:10:27: inlining call to os.ReadFile ![1](assets/1.png)\n./sum.go:15:34: inlining call to bytes.Split ![1](assets/1.png)\n./sum.go:9:10: leaking param: fileName ![2](assets/2.png)\n./sum.go:15:44: ([]byte)(\"\\n\") does not escape ![3](assets/3.png)\n./sum.go:16:38: string(line) escapes to heap ![4](assets/4.png)\n```", "```go\nArchitecture:                    x86_64\nCPU op-mode(s):                  32-bit, 64-bit\nByte Order:                      Little Endian\nAddress sizes:                   39 bits physical, 48 bits virtual\nCPU(s):                          12\nOn-line CPU(s) list:             0-11\nThread(s) per core:              2 ![1](assets/1.png) Core(s) per socket:              6\nSocket(s):                       1\nNUMA node(s):                    1\nVendor ID:                       GenuineIntel\nCPU family:                      6\nModel:                           158\nModel name:                      Intel(R) Core(TM) i7-9850H CPU @ 2.60GHz\nCPU MHz:                         2600.000\nCPU max MHz:                     4600.0000\nCPU min MHz:                     800.0000\n```", "```go\nfunc anotherFunction(arg1 string) { /*...*/ }\n\nfunc function() {\n   // ... ![1](assets/1.png)\n\n   go func() {\n      // ... ![2](assets/2.png)\n   }()\n\n   go anotherFunction(\"argument1\") ![3](assets/3.png)\n\n   return ![4](assets/4.png)\n}\n```", "```go\nfunc sharingWithAtomic() (sum int64) {\n   var wg sync.WaitGroup ![1](assets/1.png)\n\n   concurrentFn := func() {\n      atomic.AddInt64(&sum, randInt64())\n      wg.Done()\n   }\n   wg.Add(3)\n   go concurrentFn()\n   go concurrentFn()\n   go concurrentFn()\n\n   wg.Wait()\n   return sum\n}\n```", "```go\nfunc sharingWithMutex() (sum int64) {\n   var wg sync.WaitGroup\n   var mu sync.Mutex\n\n   concurrentFn := func() {\n      mu.Lock()\n      sum += randInt64()\n      mu.Unlock()\n      wg.Done()\n   }\n   wg.Add(3)\n   go concurrentFn()\n   go concurrentFn()\n   go concurrentFn()\n\n   wg.Wait()\n   return sum\n}\n```", "```go\nfunc sharingWithChannel() (sum int64) {\n   result := make(chan int64) ![1](assets/1.png)\n\n   concurrentFn := func() {\n      // ...\n      result <- randInt64() ![2](assets/2.png)\n   }\n   go concurrentFn()\n   go concurrentFn()\n   go concurrentFn()\n\n   for i := 0; i < 3; i++ { ![3](assets/3.png)\n      sum += <-result ![4](assets/4.png)\n   }\n   close(result) ![5](assets/5.png)\n   return sum\n}\n```"]