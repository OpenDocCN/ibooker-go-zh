- en: 'Chapter 2\. which code runs next?: Conditionals and Loops'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0031-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Every program has parts that apply only in certain situations**. “This code
    should run *if* there’s an error. Otherwise, that other code should run.” Almost
    every program contains code that should be run only when a certain *condition*
    is true. So almost every programming language provides **conditional statements**
    that let you determine whether to run segments of code. Go is no exception.'
  prefs: []
  type: TYPE_NORMAL
- en: You may also need some parts of your code to run *repeatedly*. Like most languages,
    Go provides **loops** that run sections of code more than once. We’ll learn to
    use both conditionals and loops in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, it’s possible to define **methods**: functions that are associated with
    values of a given type. Go methods are kind of like the methods that you may have
    seen attached to “objects” in other languages, but they’re a bit simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be taking a detailed look at how methods work in [Chapter 9](ch09.html#yoursquore_my_typecolon_defined_types).
    But we need to use a couple methods to make our examples for this chapter work,
    so let’s look at some brief examples of calling methods now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `time` package has a `Time` type that represents a date (year, month, and
    day) and time (hour, minute, second, etc.). Each `time.Time` value has a `Year`
    method that returns the year. The code below uses this method to print the current
    year:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0032-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `time.Now` function returns a new `Time` value for the current date and
    time, which we store in the `now` variable. Then, we call the `Year` method on
    the value that `now` refers to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0032-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Year` method returns an integer with the year, which we then print.
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods are functions that are associated with values of a particular type.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `strings` package has a `Replacer` type that can search through a string
    for a substring, and replace each occurrence of that substring with another string.
    The code below replaces every `#` symbol in a string with the letter `o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0033-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The `strings.NewReplacer` function takes arguments with a string to replace
    (`"#"`), and a string to replace it with (`"o"`), and returns a `strings.Replacer`.
    When we pass a string to the `Replacer` value’s `Replace` method, it returns a
    string with those replacements made.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0033-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The dot indicates that the thing on its right belongs to the thing on its
    left**.'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the functions we saw earlier belonged to a *package*, the methods belong
    to an individual *value*. That value is what appears to the left of the dot.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0033-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Making the grade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at features of Go that let you decide whether
    to run some code or not, based on a condition. Let’s look at a situation where
    we might need that ability...
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to write a program that allows a student to type in their percentage
    grade and tells them whether they passed or not. Passing or failing follows a
    simple formula: a grade of 60% or more is passing, and less than 60% is failing.
    So our program will need to give one response if the percentage users enter is
    60 or greater, and a different response otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a new file, *pass_fail.go*, to hold our program. We’re going to
    take care of a detail we omitted in our previous programs, and add a description
    of what the program does at the top.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0034-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Most Go programs include descriptions in their source code of what they do,
    intended for people maintaining the program to read. These **comments** are ignored
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The most common form of comment is marked with two slash characters (`//`).
    Everything from the slashes to the end of the line is treated as part of the comment.
    A `//` comment can appear on a line by itself, or following a line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The less frequently used form of comments, **block comments**, spans multiple
    lines. Block comments start with `/*` and end with `*/`, and everything between
    those markers (including newlines) is part of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting a grade from the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s add some actual code to our *pass_fail.go* program. The first thing
    it needs to do is allow the user to input a percentage grade. We want them to
    type a number and press Enter, and we’ll store the number they typed in a variable.
    Let’s add code to handle this. *(Note: this code will not actually compile as
    shown; we’ll talk about the reason in a moment!)*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0035-01.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we need to let the user know to enter something, so we use the `fmt.Print`
    function to display a prompt. (Unlike the `Println` function, `Print` doesn’t
    skip to a new terminal line after printing a message, which lets us keep the prompt
    and the user’s entry on the same line.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need a way to read (receive and store) input from the program’s *standard
    input*, which all keyboard input goes to. The line `reader := bufio.NewReader(os.Stdin)`
    stores a `bufio.Reader` in the `reader` variable that can do that for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0035-02.png)'
  prefs: []
  type: TYPE_IMG
- en: To actually get the user’s input, we call the `ReadString` method on the `Reader`.
    The `ReadString` method requires an argument with a rune (character) that marks
    the end of the input. We want to read everything the user types up until they
    press Enter, so we give `ReadString` a newline rune.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the user input, we simply print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the plan, anyway. But if we try to compile or run this program, we’ll
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0035-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple return values from a function or method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re trying to read the user’s keyboard input, but we’re getting an error.
    The compiler is reporting a problem in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0036-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that the `ReadString` method is trying to return *two* values,
    and we’ve only provided *one* variable to assign a value to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most programming languages, functions and methods can only have a single
    return value, but in Go, they can return any number of values. The most common
    use of multiple return values in Go is to return an additional error value that
    can be consulted to find out if anything went wrong while the function or method
    was running. A few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0036-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Go doesn’t allow us to declare a variable unless we use it**.'
  prefs: []
  type: TYPE_NORMAL
- en: Go requires that every variable that gets *declared* must also get *used* somewhere
    in your program. If we add an `err` variable and then don’t check it, our code
    won’t compile. Unused variables often indicate a bug, so this is an example of
    Go helping you detect and fix bugs!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0036-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Option 1: Ignore the error return value with the blank identifier'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ReadString` method returns a second value along with the user’s input,
    and we need to do something with that second value. We’ve tried just adding a
    second variable and ignoring it, but our code still won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0037-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we have a value that would normally be assigned to a variable, but that
    we don’t intend to use, we can use Go’s **blank identifier**. Assigning a value
    to the blank identifier essentially discards it (while making it obvious to others
    reading your code that you are doing so). To use the blank identifier, simply
    type a single underscore ( `_` ) character in an assignment statement where you
    would normally type a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try using the blank identifier in place of our old `err` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0037-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we’ll try the change out. In your terminal, change to the directory where
    you saved *pass_fail.go*, and run the program with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0037-03.png)'
  prefs: []
  type: TYPE_IMG
- en: When you type a grade (or any other string) at the prompt and press Enter, your
    entry will be echoed back to you. Our program is working!
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: Handle the error'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0038-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s true. If an error actually occurred, this program wouldn’t tell us!**'
  prefs: []
  type: TYPE_NORMAL
- en: If we got an error back from the `ReadString` method, the blank identifier would
    just cause the error to be ignored, and our program would proceed anyway, possibly
    with invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0038-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, it would be more appropriate to alert the user and stop the program
    if there was an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log` package has a `Fatal` function that can do both of these operations
    for us at once: log a message to the terminal *and* stop the program. (“Fatal”
    in this context means reporting an error that “kills” your program.)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get rid of the blank identifier and replace it with an `err` variable
    so that we’re recording the error again. Then, we’ll use the `Fatal` function
    to log the error and halt the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0038-03.png)'
  prefs: []
  type: TYPE_IMG
- en: But if we try running this updated program, we’ll see there’s a new problem...
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If our program encounters a problem reading input from the keyboard, we’ve set
    it up to report the error and stop running. But now, it stops running even when
    everything’s working correctly!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0039-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions and methods like `ReadString` return an error value of **nil**, which
    basically means “there’s nothing there.” In other words, if `err` is `nil`, it
    means there was no error. But our program is set up to simply report the `nil`
    error! What we *should* do is exit the program only *if* the `err` variable has
    a value other than `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this using **conditionals**: statements that cause a block of code
    (one or more statements surrounded by `{}` curly braces) to be executed only if
    a condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0039-02.png)'
  prefs: []
  type: TYPE_IMG
- en: An expression is evaluated, and if its result is `true`, the code in the conditional
    block body is executed. If it’s `false`, the conditional block is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0039-03.png)'
  prefs: []
  type: TYPE_IMG
- en: As with most other languages, Go supports multiple branches in the conditional.
    These statements take the form `if`...`else if`...`else`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Conditionals rely on a Boolean expression (one that evaluates to `true` or `false`)
    to decide whether the code they contain should be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0040-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you need to execute code only if a condition is *false*, you can use `!`,
    the Boolean negation operator, which lets you take a `true` value and make it
    `false`, or a `false` value and make it `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0040-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If you want to run some code only if two conditions are *both* true, you can
    use the `&&` (“and”) operator. If you want it to run if *either* of two conditions
    is true, you can use the `||` (“or”) operator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0040-03.png)'
  prefs: []
  type: TYPE_IMG
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: My other programming language requires that an `**if**` statement’s condition
    be surrounded with parentheses. Doesn’t Go?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** No, and in fact the `go fmt` tool will remove any parentheses you add,
    unless you’re using them to set order of operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging a fatal error, conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our grading program is reporting an error and exiting, even if it reads input
    from the keyboard successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0042-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We know that if the value in our `err` variable is `nil`, it means reading from
    the keyboard was successful. Now that we know about `if` statements, let’s try
    updating our code to log an error and exit only if `err` is *not* `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0042-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If we rerun our program, we’ll see that it’s working again. And now, if there
    are any errors when reading user input, we’ll see those as well!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0042-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0018-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go program that prints the size of a file is on the fridge. It calls the `os.Stat`
    function, which returns an `os.FileInfo` value, and possibly an error value. Then
    it calls the `Size` method on the `FileInfo` value to get the file size.
  prefs: []
  type: TYPE_NORMAL
- en: But the original program uses the `_` blank identifier to ignore the error value
    from `os.Stat`. If an error occurs (which could happen if the file doesn’t exist),
    this will cause the program to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Reconstruct the extra code snippets to make a program that works just like the
    original one, but also checks for an error from `os.Stat`. If the error from `os.Stat`
    is not `nil`, the error should be reported, and the program should exit. Discard
    the magnet with the `_` blank identifier; it won’t be used in the finished program.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0043-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](assets/arrow.png) Answers in [“Code Magnets Solution”](#code_magnets_solution_2).'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid shadowing names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0044-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Naming a variable `**error**` would be a bad idea, because it would shadow
    the name of a type called `**error**`**.'
  prefs: []
  type: TYPE_NORMAL
- en: When you declare a variable, you should make sure it doesn’t have the same name
    as any existing functions, packages, types, or other variables. If something by
    the same name exists in the enclosing scope (we’ll talk about scopes shortly),
    your variable will **shadow** it—that is, take precedence over it. And all too
    often, that’s a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we declare a variable named `int` that shadows a type name, a variable
    named `append` that shadows a built-in function name (we’ll see the `append` function
    in [Chapter 6](ch06.html#appending_issuecolon_slices)), and a variable named `fmt`
    that shadows an imported package name. Those names are awkward, but they don’t
    cause any errors by themselves...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0044-02.png)![image](assets/f0044-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '...But if we try to access the type, function, or package the variables are
    shadowing, we’ll get the value in the variable instead. In this case, it results
    in compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0045-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To avoid confusion for yourself and your fellow developers, you should avoid
    shadowing names wherever possible. In this case, fixing the issue is as simple
    as choosing nonconflicting names for the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0045-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As we’ll see in [Chapter 3](ch03.html#call_mecolon_functions), Go has a built-in
    type named `error`. So that’s why, when declaring variables meant to hold errors,
    we’ve been naming them `err` instead of `error`—we want to avoid shadowing the
    name of the `error` type with our variable name.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0045-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If you *do* name your variables `error`, your code will *probably* still work.
    That is, *until* you forget that the `error` type name is shadowed, you try to
    use the type, and you get the variable instead. Don’t take that chance; use the
    name `err` for your error variables!
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional statements will also let us evaluate the entered grade. Let’s add
    an `if`/`else` statement to determine whether the grade is passing or failing.
    If the entered percentage grade is 60 or greater, we’ll set the status to `"passing"`.
    Otherwise, we’ll set it to `"failing"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In its current form, though, this gets us a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0046-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the problem: input from the keyboard is read in as a string. Go can
    only compare numbers to other numbers; we can’t compare a number with a string.
    And there’s no direct type conversion from `string` to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0046-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a pair of issues to address here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `input` string still has a newline character on the end, from when the user
    pressed the Enter key while entering it. We need to strip that off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of the string needs to be converted to a floating-point number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the newline character from the end of the `input` string will be easy.
    The `strings` package has a `TrimSpace` function that will remove all whitespace
    characters (newlines, tabs, and regular spaces) from the start and end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0047-01a.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we can get rid of the newline on `input` by passing it to `TrimSpace`, and
    assigning the return value back to the `input` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All that should remain in the `input` string now is the number the user entered.
    We can use the `strconv` package’s `ParseFloat` function to convert it to a `float64`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0047-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You pass `ParseFloat` a string that you want to convert to a number, as well
    as the number of bits of precision the result should have. Since we’re converting
    to a `float64` value, we pass the number `64`. (In addition to `float64`, Go offers
    a less precise `float32` type, but you shouldn’t use that unless you have a good
    reason.)
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseFloat` converts the string to a number, and returns it as a `float64`
    value. Like `ReadString`, it also has a second return value, an error, which will
    be `nil` unless there was some problem converting the string. (For example, a
    string that *can’t* be converted to a number. We don’t know of a numeric equivalent
    to `"hello"`...)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update *pass_fail.go* with calls to `TrimSpace` and `ParseFloat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0048-01.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we add the appropriate packages to the `import` section. We add code
    to remove the newline character from the `input` string. Then we pass `input`
    to `ParseFloat`, and store the resulting `float64` value in a new variable, `grade`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did with `ReadString`, we test whether `ParseFloat` returns an error
    value. If it does, we report it and stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the conditional statement to test the number in `grade`,
    rather than the string in `input`. That should fix the error stemming from comparing
    a string to a number.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to run the updated program, we no longer get the `mismatched types
    string and int` error. So it looks like we’ve fixed that issue. But we’ve got
    a couple more errors to address. We’ll look at those next.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0048-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve converted the user’s grade input to a `float64` value, and added it to
    a conditional to determine if it’s passing or failing. But we’re getting a couple
    more compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0049-01.png)'
  prefs: []
  type: TYPE_IMG
- en: As we’ve seen previously, declaring a variable like `status` without using it
    afterward is an error in Go. It seems a little strange that we’re getting the
    error twice, but let’s disregard that for now. We’ll add a call to `Println` to
    print the percentage grade we were given, and the value of `status`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0049-02.png)'
  prefs: []
  type: TYPE_IMG
- en: But now we get a *new* error, saying that the `status` variable is undefined
    when we attempt to use it in our `Println` statement! What’s going on?
  prefs: []
  type: TYPE_NORMAL
- en: Go code can be divided up into **blocks**, segments of code. Blocks are usually
    surrounded by curly braces (`{}`), although there are also blocks at the source
    code file and package levels. Blocks can be nested inside one another.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0049-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The bodies of functions and conditionals are both blocks as well. Understanding
    this will be key to solving our problem with the `status` variable...
  prefs: []
  type: TYPE_NORMAL
- en: Blocks and variable scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each variable you declare has a **scope**: a portion of your code that it’s
    “visible” within. A declared variable can be accessed anywhere within its scope,
    but if you try to access it outside that scope, you’ll get an error.'
  prefs: []
  type: TYPE_NORMAL
- en: A variable’s scope consists of the block it’s declared in and any blocks nested
    within that block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0050-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the scopes of the variables in the code above:'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of `packageVar` is the entire `main` package. You can access `packageVar`
    anywhere within any function you define in the package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of `functionVar` is the entire function it’s declared in, including
    the `if` block nested within that function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of `conditionalVar` is limited to the `if` block. When we try to access
    `conditionalVar` *after* the closing `}` brace of the `if` block, we’ll get an
    error saying that `conditionalVar` is undefined!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand variable scope, we can explain why our `status` variable
    was undefined in the grading program. We declared `status` in our conditional
    blocks. (In fact, we declared it twice, since there are two separate blocks. That’s
    why we got two `status declared and not used` errors.) But then we tried to access
    `status` *outside* those blocks, where it was no longer in scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0051-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The solution is to move the declaration of the `status` variable out of the
    conditional blocks, and up to the function block. Once we do that, the `status`
    variable will be in scope both within the nested conditional blocks *and* at the
    end of the function block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0051-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve finished the grading program!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That was it! Our *pass_fail.go* program is ready for action! Let’s take one
    more look at the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0052-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You can try running the finished program as many times as you like. Enter a
    percentage grade under 60, and it will report a failing status. Enter a grade
    over 60, and it will report that it’s passing. Looks like everything’s working!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0052-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Only one variable in a short variable declaration has to be new
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0054-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s true that when the same variable name is declared twice in the same scope,
    we get a compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0054-02.png)'
  prefs: []
  type: TYPE_IMG
- en: But as long as at least one variable name in a short variable declaration is
    new, it’s allowed. The new variable names are treated as a declaration, and the
    existing names are treated as an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0054-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There’s a reason for this special handling: a lot of Go functions return multiple
    values. It would be a pain if you had to declare all the variables separately
    just because you want to reuse one of them.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0054-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead, Go lets you use a short variable declaration for everything, even if
    for *one* of the variables, it’s actually an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0054-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s build a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to wrap up this chapter by building a simple game. If that sounds
    daunting, don’t worry; you’ve already learned most of the skills you’re going
    to need! Along the way, we’ll learn about *loops*, which will allow the player
    to take multiple turns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at everything we’ll need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0055-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This example debuted in Head First Ruby. (Another fine book that you should
    also buy!) It worked so well that we’re using it again here.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0055-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Gary Richardott Game Designer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s create a new source file, named *guess.go*.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like our first requirement is to generate a random number. Let’s get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: Package names vs. import paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `math/rand` package has a `Intn` function that can generate a random number
    for us, so we’ll need to import `math/rand`. Then we’ll call `rand.Intn` to generate
    the random number.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0056-01.png)![image](assets/f0056-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**One is the package’s import path, and the other is the package’s name**.'
  prefs: []
  type: TYPE_NORMAL
- en: When we say `math/rand` we’re referring to the package’s *import path*, not
    its *name*. An **import path** is just a unique string that identifies a package
    and that you use in an `import` statement. Once you’ve imported the package, you
    can refer to it by its package name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For every package we’ve used so far, the import path has been identical to
    the package name. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Import path | Package name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"fmt"` | `fmt` |'
  prefs: []
  type: TYPE_TB
- en: '| `"log"` | `log` |'
  prefs: []
  type: TYPE_TB
- en: '| `"strings"` | `strings` |'
  prefs: []
  type: TYPE_TB
- en: But the import path and package name don’t have to be identical. Many Go packages
    fall into similar categories, like compression or complex math. So they’re grouped
    together under similar import path prefixes, such as `"archive/"` or `"math/"`.
    (Think of them as being similar to the paths of directories on your hard drive.)
  prefs: []
  type: TYPE_NORMAL
- en: '| Import path | Package name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive"` | `archive` |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive/tar"` | `tar` |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive/zip"` | `zip` |'
  prefs: []
  type: TYPE_TB
- en: '| `"math"` | `math` |'
  prefs: []
  type: TYPE_TB
- en: '| `"math/cmplx"` | `cmplx` |'
  prefs: []
  type: TYPE_TB
- en: '| `"math/rand"` | `rand` |'
  prefs: []
  type: TYPE_TB
- en: The Go language doesn’t require that a package name have anything to do with
    its import path. But by convention, the last (or only) segment of the import path
    is also used as the package name. So if the import path is `"archive"`, the package
    name will be `archive`, and if the import path is `"archive/zip"`, the package
    name will be `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Import path | Package name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive"` | archive |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive/tar"` | tar |'
  prefs: []
  type: TYPE_TB
- en: '| `"archive/zip"` | zip |'
  prefs: []
  type: TYPE_TB
- en: '| `"math"` | math |'
  prefs: []
  type: TYPE_TB
- en: '| `"math/cmplx"` | cmplx |'
  prefs: []
  type: TYPE_TB
- en: '| `"math/rand"` | rand |'
  prefs: []
  type: TYPE_TB
- en: 'So, that’s why our `import` statement uses a path of `"math/rand"`, but our
    `main` function just uses the package name: `rand`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0057-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating a random number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pass a number to `rand.Intn`, and it will return a random integer between `0`
    and the number you provided. In other words, if we pass an argument of `100`,
    we’ll get a random number in the range 0–99\. Since we need a number in the range
    1–100, we’ll just add `1` to whatever random value we get. We’ll store the result
    in a variable, `target`. We’ll do more with `target` later, but for now we’ll
    just print it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0057-03.png)'
  prefs: []
  type: TYPE_IMG
- en: If we try running our program right now, we’ll get a random number. But we just
    get the *same* random number over and over! The problem is, random numbers generated
    by computers aren’t really that random. But there’s a way to increase that randomness...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0057-04.png)'
  prefs: []
  type: TYPE_IMG
- en: To get different random numbers, we need to pass a value to the `rand.Seed`
    function. That will “seed” the random number generator—that is, give it a value
    that it will use to generate other random values. But if we keep giving it the
    same seed value, it will keep giving us the same random values, and we’ll be back
    where we started.
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that the `time.Now` function will give us a `Time` value representing
    the current date and time. We can use that to get a different seed value every
    time we run our program.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0058-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The `rand.Seed` function expects an integer, so we can’t pass it a `Time` value
    directly. Instead, we call the `Unix` method on the `Time`, which will convert
    it to an integer. (Specifically, it will convert it to Unix time format, which
    is an integer with the number of seconds since January 1, 1970\. But you don’t
    really need to remember that.) We pass that integer to `rand.Seed`.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a couple `Println` calls to let the user know we’ve chosen a random
    number. But aside from that, we can leave the rest of our code, including the
    call to `rand.Intn`, as is. Seeding the generator should be the only change we
    need to make.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each time we run our program, we’ll see our message, along with a random
    number. It looks like our changes are successful!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0058-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting an integer from the keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first requirement is complete! Next we need to get the user’s guess via
    the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: That should work in much the same way as when we read in a percentage grade
    from the keyboard for our grading program.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0059-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There will be only one difference: instead of converting the input to a `float64`,
    we need to convert it to an `int` (since our guessing game uses only whole numbers).
    So we’ll pass the string read from the keyboard to the `strconv` package’s `Atoi`
    (string to integer) function instead of its `ParseFloat` function. `Atoi` will
    give us an integer as its return value. (Just like `ParseFloat`, `Atoi` might
    also give us an error if it can’t convert the string. If that happens, we again
    report the error and exit.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0059-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparing the guess to the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another requirement finished. And this next one will be easy... We just need
    to compare the user’s guess to the randomly generated number, and tell them whether
    it was higher or lower.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0060-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If `guess` is less than `target`, we need to print a message saying the guess
    was low. *Otherwise, if* `guess` is greater than `target`, we should print a message
    saying the guess was high. Sounds like we need an `if`...`else if` statement.
    We’ll add it below the other code in our `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0060-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Now try running our updated program from the terminal. It’s still set up to
    print `target` each time it runs, which will be useful for debugging. Just enter
    a number lower than `target`, and you should be told your guess was low. If you
    rerun the program, you’ll get a new `target` value. Enter a number higher than
    that, and you’ll be told your guess was high.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0060-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another requirement down! Let’s look at the next one.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0061-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Currently, the player only gets to guess once, but we need to allow them to
    guess up to 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: The code to prompt for a guess is already in place. We just need to run it *more
    than once*. We can use a **loop** to execute a block of code repeatedly. If you’ve
    used other programming languages, you’ve probably encountered loops. When you
    need one or more statements executed over and over, you place them inside a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0061-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Loops always begin with the `for` keyword. In one common kind of loop, `for`
    is followed by three segments of code that control the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: An initialization (or init) statement that is usually used to initialize a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition expression that determines when to break out of the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post statement that runs after each iteration of the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, the initialization statement is used to initialize a variable, the condition
    expression keeps the loop running until that variable reaches a certain value,
    and the post statement is used to update the value of that variable. For example,
    in this snippet, the `t` variable is initialized to `3`, the condition keeps the
    loop going while `t > 0`, and the post statement subtracts `1` from `t` each time
    the loop runs. Eventually, `t` reaches `0` and the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0061-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The `++` and `--` statements are frequently used in loop post statements. Each
    time they’re evaluated, `++` adds `1` to a variable’s value, and `--` subtracts
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0062-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Used in a loop, `++` and `--` are convenient for counting up or down.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0062-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Go also includes the assignment operators `+=` and `-=`. They take the value
    in a variable, add or subtract another value, and then assign the result back
    to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0062-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '`+=` and `-=` can be used in a loop to count in increments other than `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0062-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the loop finishes, execution will resume with whatever statement follows
    the loop block. But the loop will keep going as long as the condition expression
    evaluates to `true`. It’s possible to abuse this; here are examples of a loop
    that will run forever, and a loop that will never run at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0062-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Init and post statements are optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want, you can leave out the init and post statements from a `for` loop,
    leaving only the condition expression (although you still need to make sure the
    condition eventually evaluates to `false`, or you could have an infinite loop
    on your hands).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0063-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Loops and scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like with conditionals, the scope of any variables declared within a loop’s
    block is limited to that block (although the init statement, condition expression,
    and post statement can be considered part of that scope as well).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0063-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Also as with conditionals, any variable declared *before* the loop will still
    be in scope within the loop’s control statements and block, *and* will still be
    in scope after the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0063-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Breaking Stuff is Educational!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0006-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s a program that uses a loop to count to 3\. Try making one of the changes
    below and run it. Then undo your change and try the next one. See what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0064-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '| If you do this... | ...it will break because... |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Add parentheses after the `for` keyword `for (x := 1; x <= 3; x++)` | Some
    other languages *require* parentheses around a `for` loop’s control statements,
    but not only does Go not require them, it doesn’t *allow* them. |'
  prefs: []
  type: TYPE_TB
- en: '| Delete the `:` from the init statement `x = 1` | Unless you’re assigning
    to a variable that’s already been declared in the enclosing scope (which you usually
    won’t be), the init statement needs to be a *declaration*, not an *assignment.*
    |'
  prefs: []
  type: TYPE_TB
- en: '| Remove the `=` from the condition expression `x < 3` | The expression `x
    < 3` becomes `false` when `x` reaches `3` (whereas `x <= 3` would still be `true`).
    So the loop would only count to `2`. |'
  prefs: []
  type: TYPE_TB
- en: '| Reverse the comparison in the condition expression `x >= 3` | Because the
    condition is already `false` when the loop begins (`x` is initialized to `1`,
    which is *less* than `3`), the loop will never run. |'
  prefs: []
  type: TYPE_TB
- en: '| Change the post statement from `x++` to `x--` `x--` | The `x` variable will
    start counting *down* from `1` (`1`, `0`, `-1`, `-2`, etc.), and since it will
    never be greater than `3`, the loop will never end. |'
  prefs: []
  type: TYPE_TB
- en: '| Move the `fmt.Println(x)` statement outside the loop’s block | Variables
    declared in the init statement or within the loop block are only in scope within
    the loop block. |'
  prefs: []
  type: TYPE_TB
- en: Using a loop in our guessing game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game still only prompts the user for a guess once. Let’s add a loop around
    the code that prompts the user for a guess and tells them if it was low or high,
    so that the user can guess 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use an `int` variable named `guesses` to track the number of guesses the
    player has made. In our loop’s init statement, we’ll initialize `guesses` to `0`.
    We’ll add `1` to `guesses` with each iteration of the loop, and we’ll stop the
    loop when `guesses` reaches `10`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also add a `Println` statement at the top of the loop’s block to tell
    the user how many guesses they have left.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0066-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our loop is in place, if we run our game again, we’ll get asked 10
    times what our guess is!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0067-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the code to prompt for a guess and state whether it was high or low is
    inside the loop, it gets run repeatedly. After 10 guesses, the loop (and the game)
    will end.
  prefs: []
  type: TYPE_NORMAL
- en: But the loop always runs 10 times, even if the player guesses correctly! Fixing
    that will be our next requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping parts of a loop with “continue” and “break”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hard part is done! We only have a couple requirements left to go.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the loop that prompts the user for a guess always runs 10 times.
    Even if the player guesses correctly, we don’t tell them so, and we don’t stop
    the loop. Our next task is to fix that.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0068-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Go provides two keywords that control the flow of a loop. The first, `continue`,
    immediately skips to the next iteration of a loop, without running any further
    code in the loop block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0068-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the above example, the string `"after continue"` never gets printed, because
    the `continue` keyword always skips back to the top of the loop before the second
    call to `Println` can be run.
  prefs: []
  type: TYPE_NORMAL
- en: The second keyword, `break`, immediately breaks out of a loop. No further code
    within the loop block is executed, and no further iterations are run. Execution
    moves to the first statement following the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0068-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, in the first iteration of the loop, the string `"before break"` gets printed,
    but then the `break` statement immediately breaks out of the loop, without printing
    the `"after break"` string, and without running the loop again (even though it
    normally would have run two more times). Execution instead moves to the statement
    following the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` keyword seems like it would be applicable to our current problem:
    we need to break out of our loop when the player guesses correctly. Let’s try
    using it in our game...'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out of our guessing loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re using an `if`...`else if` conditional to tell the player the status of
    their guess. If the player guesses a number too high or too low, we currently
    print a message telling them so.
  prefs: []
  type: TYPE_NORMAL
- en: It stands to reason that if the guess is neither too high *nor* too low, it
    must be correct. So let’s add an `else` branch onto the conditional, that will
    run in the event of a correct guess. Inside the block for the `else` branch, we’ll
    tell the player they were right, and then use the `break` statement to stop the
    guessing loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0069-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, when the player guesses correctly, they’ll see a congratulatory message,
    and the loop will exit without repeating the full 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0069-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s another requirement complete!
  prefs: []
  type: TYPE_NORMAL
- en: Revealing the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0070-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re *so* close! Just one more requirement left!
  prefs: []
  type: TYPE_NORMAL
- en: If the player makes 10 guesses without finding the target number, the loop will
    exit. In that event, we need to print a message saying they lost, and tell them
    what the target was.
  prefs: []
  type: TYPE_NORMAL
- en: But we *also* exit the loop if the player guesses correctly. We don’t want to
    say the player has lost when they’ve already won!
  prefs: []
  type: TYPE_NORMAL
- en: So, before our guessing loop, we’ll declare a `success` variable that holds
    a `bool`. (We need to declare it *before* the loop so that it’s still in scope
    after the loop ends.) We’ll initialize `success` to a default value of `false`.
    Then, if the player guesses correctly, we’ll set `success` to `true`, indicating
    we don’t need to print the failure message.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0070-02.png)'
  prefs: []
  type: TYPE_IMG
- en: After the loop, we add an `if` block that prints the failure message. But an
    `if` block only runs if its condition evaluates to `true`, and we only want to
    print the failure message if `success` is `false`. So we add the Boolean negation
    operator (`!`). As we saw earlier, `!` turns `true` values `false` and `false`
    values `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that the failure message will be printed if `success` is `false`,
    but *won’t* be printed if `success` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0071-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, that’s the last requirement!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take care of a couple final issues with our code, and then try out our
    game!
  prefs: []
  type: TYPE_NORMAL
- en: First, as we mentioned, it’s typical to add a comment at the top of each Go
    program describing what it does. Let’s add one now.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0071-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Our program is also encouraging cheaters by printing the target number at the
    start of every game. Let’s remove the `Println` call that does that.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0071-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re finally ready to try running our complete code!
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll run out of guesses on purpose to ensure the target number gets
    displayed...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0071-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we’ll try guessing successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Our game is working great!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0071-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, your game is complete!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0072-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Using conditionals and loops, you’ve written a complete game in Go! Pour yourself
    a cold drink—you’ve earned it!
  prefs: []
  type: TYPE_NORMAL
- en: '**Here’s our complete guess.go source code!**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](assets/f0073-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0074-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 2](#which_code_runs_nextquestcolon_condition)! You’ve
    added conditionals and loops to your toolbox**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0074-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Loops**'
  prefs: []
  type: TYPE_NORMAL
- en: Loops cause a block of code to execute repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: One common kind of loop starts with the keyword “for”, followed by an init statement
    that initializes a variable, a condition expression that determines when to break
    out of the loop, and a post statement that runs after each iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Code Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/bag.png)'
  prefs: []
  type: TYPE_IMG
- en: A Go program that prints the size of a file is on the fridge. It calls the `os.Stat`
    function, which returns an `os.FileInfo` value, and possibly an error. Then it
    calls the `Size` method on the `FileInfo` value to get the file size.
  prefs: []
  type: TYPE_NORMAL
- en: The original program used the `_` blank identifier to ignore the error value
    from `os.Stat`. If an error occurred (which could happen if the file doesn’t exist),
    this would cause the program to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Your job was to reconstruct the extra code snippets to make a program that works
    just like the original one, but also checks for an error from `os.Stat`. If the
    error from `os.Stat` is not `nil`, the error should be reported, and the program
    should exit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0076-02.png)'
  prefs: []
  type: TYPE_IMG
