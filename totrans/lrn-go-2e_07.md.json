["```go\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n```", "```go\ntype Score int\ntype Converter func(string)Score\ntype TeamScores map[string]Score\n```", "```go\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"%s %s, age %d\", p.FirstName, p.LastName, p.Age)\n}\n```", "```go\np := Person{\n    FirstName: \"Fred\",\n    LastName:  \"Fredson\",\n    Age:       52,\n}\noutput := p.String()\n```", "```go\ntype Counter struct {\n    total       int\n    lastUpdated time.Time\n}\n\nfunc (c *Counter) Increment() {\n    c.total++\n    c.lastUpdated = time.Now()\n}\n\nfunc (c Counter) String() string {\n    return fmt.Sprintf(\"total: %d, last updated: %v\", c.total, c.lastUpdated)\n}\n```", "```go\nvar c Counter\nfmt.Println(c.String())\nc.Increment()\nfmt.Println(c.String())\n```", "```go\ntotal: 0, last updated: 0001-01-01 00:00:00 +0000 UTC\ntotal: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001\n```", "```go\nc := &Counter{}\nfmt.Println(c.String())\nc.Increment()\nfmt.Println(c.String())\n```", "```go\nfunc doUpdateWrong(c Counter) {\n    c.Increment()\n    fmt.Println(\"in doUpdateWrong:\", c.String())\n}\n\nfunc doUpdateRight(c *Counter) {\n    c.Increment()\n    fmt.Println(\"in doUpdateRight:\", c.String())\n}\n\nfunc main() {\n    var c Counter\n    doUpdateWrong(c)\n    fmt.Println(\"in main:\", c.String())\n    doUpdateRight(&c)\n    fmt.Println(\"in main:\", c.String())\n}\n```", "```go\nin doUpdateWrong: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC\n    m=+0.000000001\nin main: total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC\nin doUpdateRight: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC\n    m=+0.000000001\nin main: total: 1, last updated: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001\n```", "```go\ntype IntTree struct {\n    val         int\n    left, right *IntTree\n}\n\nfunc (it *IntTree) Insert(val int) *IntTree {\n    if it == nil {\n        return &IntTree{val: val}\n    }\n    if val < it.val {\n        it.left = it.left.Insert(val)\n    } else if val > it.val {\n        it.right = it.right.Insert(val)\n    }\n    return it\n}\n\nfunc (it *IntTree) Contains(val int) bool {\n    switch {\n    case it == nil:\n        return false\n    case val < it.val:\n        return it.left.Contains(val)\n    case val > it.val:\n        return it.right.Contains(val)\n    default:\n        return true\n    }\n}\n```", "```go\nfunc main() {\n    var it *IntTree\n    it = it.Insert(5)\n    it = it.Insert(3)\n    it = it.Insert(10)\n    it = it.Insert(2)\n    fmt.Println(it.Contains(2))  // true\n    fmt.Println(it.Contains(12)) // false\n}\n```", "```go\ntype Adder struct {\n    start int\n}\n\nfunc (a Adder) AddTo(val int) int {\n    return a.start + val\n}\n```", "```go\nmyAdder := Adder{start: 10}\nfmt.Println(myAdder.AddTo(5)) // prints 15\n```", "```go\nf1 := myAdder.AddTo\nfmt.Println(f1(10))           // prints 20\n```", "```go\nf2 := Adder.AddTo\nfmt.Println(f2(myAdder, 15))  // prints 25\n```", "```go\ntype HighScore Score\ntype Employee Person\n```", "```go\n// assigning untyped constants is valid\nvar i int = 300\nvar s Score = 100\nvar hs HighScore = 200\nhs = s                  // compilation error!\ns = i                   // compilation error!\ns = Score(i)            // ok\nhs = HighScore(s)       // ok\n```", "```go\nvar s Score = 50\nscoreWithBonus := s + 100 // type of scoreWithBonus is Score\n```", "```go\ntype MailCategory int\n```", "```go\nconst (\n    Uncategorized MailCategory = iota\n    Personal\n    Spam\n    Social\n    Advertisements\n)\n```", "```go\nconst (\n    Field1 = 0\n    Field2 = 1 + iota\n    Field3 = 20\n    Field4\n    Field5 = iota\n)\n\nfunc main() {\n    fmt.Println(Field1, Field2, Field3, Field4, Field5)\n}\n```", "```go\n0 2 20 20 4\n```", "```go\ntype BitField int\n\nconst (\n    Field1 BitField = 1 << iota // assigned 1\n    Field2                      // assigned 2\n    Field3                      // assigned 4\n    Field4                      // assigned 8\n)\n```", "```go\ntype Employee struct {\n    Name         string\n    ID           string\n}\n\nfunc (e Employee) Description() string {\n    return fmt.Sprintf(\"%s (%s)\", e.Name, e.ID)\n}\n\ntype Manager struct {\n    Employee\n    Reports []Employee\n}\n\nfunc (m Manager) FindNewEmployees() []Employee {\n    // do business logic\n}\n```", "```go\nm := Manager{\n    Employee: Employee{\n        Name: \"Bob Bobson\",\n        ID:   \"12345\",\n    },\n    Reports: []Employee{},\n}\nfmt.Println(m.ID)            // prints 12345\nfmt.Println(m.Description()) // prints Bob Bobson (12345)\n```", "```go\ntype Inner struct {\n    X int\n}\n\ntype Outer struct {\n    Inner\n    X int\n}\n```", "```go\no := Outer{\n    Inner: Inner{\n        X: 10,\n    },\n    X: 20,\n}\nfmt.Println(o.X)       // prints 20\nfmt.Println(o.Inner.X) // prints 10\n```", "```go\nvar eFail Employee = m        // compilation error!\nvar eOK Employee = m.Employee // ok!\n```", "```go\ncannot use m (type Manager) as type Employee in assignment\n```", "```go\ntype Inner struct {\n    A int\n}\n\nfunc (i Inner) IntPrinter(val int) string {\n    return fmt.Sprintf(\"Inner: %d\", val)\n}\n\nfunc (i Inner) Double() string {\n    return i.IntPrinter(i.A * 2)\n}\n\ntype Outer struct {\n    Inner\n    S string\n}\n\nfunc (o Outer) IntPrinter(val int) string {\n    return fmt.Sprintf(\"Outer: %d\", val)\n}\n\nfunc main() {\n    o := Outer{\n        Inner: Inner{\n            A: 10,\n        },\n        S: \"Hello\",\n    }\n    fmt.Println(o.Double())\n}\n```", "```go\nInner: 20\n```", "```go\ntype Stringer interface {\n    String() string\n}\n```", "```go\ntype Incrementer interface {\n    Increment()\n}\n\nvar myStringer fmt.Stringer\nvar myIncrementer Incrementer\npointerCounter := &Counter{}\nvalueCounter := Counter{}\n\nmyStringer = pointerCounter    // ok\nmyStringer = valueCounter      // ok\nmyIncrementer = pointerCounter // ok\nmyIncrementer = valueCounter   // compile-time error!\n```", "```go\nclass Logic:\n    def process(self, data):\n        # business logic\n\ndef program(logic):\n    # get data from somewhere\n    logic.process(data)\n\nlogicToUse = Logic()\nprogram(logicToUse)\n```", "```go\npublic interface Logic {\n    String process(String data);\n}\n\npublic class LogicImpl implements Logic {\n    public String process(String data) {\n        // business logic\n    }\n}\n\npublic class Client {\n    private final Logic logic;\n    // this type is the interface, not the implementation\n\n    public Client(Logic logic) {\n        this.logic = logic;\n    }\n\n    public void program() {\n        // get data from somewhere\n        this.logic.process(data);\n    }\n}\n\npublic static void main(String[] args) {\n    Logic logic = new LogicImpl();\n    Client client = new Client(logic);\n    client.program();\n}\n```", "```go\ntype LogicProvider struct {}\n\nfunc (lp LogicProvider) Process(data string) string {\n    // business logic\n}\n\ntype Logic interface {\n    Process(data string) string\n}\n\ntype Client struct{\n    L Logic\n}\n\nfunc(c Client) Program() {\n    // get data from somewhere\n    c.L.Process(data)\n}\n\nmain() {\n    c := Client{\n        L: LogicProvider{},\n    }\n    c.Program()\n}\n```", "```go\nfunc process(r io.Reader) error\n```", "```go\nr, err := os.Open(fileName)\nif err != nil {\n    return err\n}\ndefer r.Close()\nreturn process(r)\n```", "```go\nr, err := os.Open(fileName)\nif err != nil {\n    return err\n}\ndefer r.Close()\ngz, err := gzip.NewReader(r)\nif err != nil {\n    return err\n}\ndefer gz.Close()\nreturn process(gz)\n```", "```go\ntype Reader interface {\n        Read(p []byte) (n int, err error)\n}\n\ntype Closer interface {\n        Close() error\n}\n\ntype ReadCloser interface {\n        Reader\n        Closer\n}\n```", "```go\nvar pointerCounter *Counter\nfmt.Println(pointerCounter == nil) // prints true\nvar incrementer Incrementer\nfmt.Println(incrementer == nil) // prints true\nincrementer = pointerCounter\nfmt.Println(incrementer == nil) // prints false\n```", "```go\ntype Doubler interface {\n    Double()\n}\n\ntype DoubleInt int\n\nfunc (d *DoubleInt) Double() {\n    *d = *d * 2\n}\n\ntype DoubleIntSlice []int\n\nfunc (d DoubleIntSlice) Double() {\n    for i := range d {\n        d[i] = d[i] * 2\n    }\n}\n```", "```go\nfunc DoublerCompare(d1, d2 Doubler) {\n    fmt.Println(d1 == d2)\n}\n```", "```go\nvar di DoubleInt = 10\nvar di2 DoubleInt = 10\nvar dis = DoubleIntSlice{1, 2, 3}\nvar dis2 = DoubleIntSlice{1, 2, 3}\n```", "```go\nDoublerCompare(&di, &di2)\n```", "```go\nDoublerCompare(&di, dis)\n```", "```go\nDoublerCompare(dis, dis2)\n```", "```go\npanic: runtime error: comparing uncomparable type main.DoubleIntSlice\n```", "```go\nm := map[Doubler]int{}\n```", "```go\nvar i interface{}\ni = 20\ni = \"hello\"\ni = struct {\n    FirstName string\n    LastName string\n} {\"Fred\", \"Fredson\"}\n```", "```go\ndata := map[string]any{}\ncontents, err := os.ReadFile(\"testdata/sample.json\")\nif err != nil {\n    return err\n}\njson.Unmarshal(contents, &data)\n// the contents are now in the data map\n```", "```go\ntype MyInt int\n\nfunc main() {\n    var i any\n    var mine MyInt = 20\n    i = mine\n    i2 := i.(MyInt)\n    fmt.Println(i2 + 1)\n}\n```", "```go\ni2 := i.(string)\nfmt.Println(i2)\n```", "```go\npanic: interface conversion: interface {} is main.MyInt, not string\n```", "```go\ni2 := i.(int)\nfmt.Println(i2 + 1)\n```", "```go\ni2, ok := i.(int)\nif !ok {\n    return fmt.Errorf(\"unexpected type for %v\",i)\n}\nfmt.Println(i2 + 1)\n```", "```go\nfunc doThings(i any) {\n    switch j := i.(type) {\n    case nil:\n        // i is nil, type of j is any\n    case int:\n        // j is of type int\n    case MyInt:\n        // j is of type MyInt\n    case io.Reader:\n        // j is of type io.Reader\n    case string:\n        // j is a string\n    case bool, rune:\n        // i is either a bool or rune, so j is of type any\n    default:\n        // no idea what i is, so j is of type any\n    }\n}\n```", "```go\n// copyBuffer is the actual implementation of Copy and CopyBuffer.\n// if buf is nil, one is allocated.\nfunc copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {\n    // If the reader has a WriteTo method, use it to do the copy.\n    // Avoids an allocation and a copy.\n    if wt, ok := src.(WriterTo); ok {\n        return wt.WriteTo(dst)\n    }\n    // Similarly, if the writer has a ReadFrom method, use it to do the copy.\n    if rt, ok := dst.(ReaderFrom); ok {\n        return rt.ReadFrom(src)\n    }\n    // function continues...\n}\n```", "```go\nfunc ctxDriverStmtExec(ctx context.Context, si driver.Stmt,\n                       nvdargs []driver.NamedValue) (driver.Result, error) {\n    if siCtx, is := si.(driver.StmtExecContext); is {\n        return siCtx.ExecContext(ctx, nvdargs)\n    }\n    // fallback code is here\n}\n```", "```go\nfunc walkTree(t *treeNode) (int, error) {\n    switch val := t.val.(type) {\n    case nil:\n        return 0, errors.New(\"invalid expression\")\n    case number:\n        // we know that t.val is of type number, so return the\n        // int value\n        return int(val), nil\n    case operator:\n        // we know that t.val is of type operator, so\n        // find the values of the left and right children, then\n        // call the process() method on operator to return the\n        // result of processing their values.\n        left, err := walkTree(t.lchild)\n        if err != nil {\n            return 0, err\n        }\n        right, err := walkTree(t.rchild)\n        if err != nil {\n            return 0, err\n        }\n        return val.process(left, right), nil\n    default:\n        // if a new treeVal type is defined, but walkTree wasn't updated\n        // to process it, this detects it\n        return 0, errors.New(\"unknown node type\")\n    }\n}\n```", "```go\ntype Handler interface {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n```", "```go\ntype HandlerFunc func(http.ResponseWriter, *http.Request)\n\nfunc (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    f(w, r)\n}\n```", "```go\nfunc LogOutput(message string) {\n    fmt.Println(message)\n}\n```", "```go\ntype SimpleDataStore struct {\n    userData map[string]string\n}\n\nfunc (sds SimpleDataStore) UserNameForID(userID string) (string, bool) {\n    name, ok := sds.userData[userID]\n    return name, ok\n}\n```", "```go\nfunc NewSimpleDataStore() SimpleDataStore {\n    return SimpleDataStore{\n        userData: map[string]string{\n            \"1\": \"Fred\",\n            \"2\": \"Mary\",\n            \"3\": \"Pat\",\n        },\n    }\n}\n```", "```go\ntype DataStore interface {\n    UserNameForID(userID string) (string, bool)\n}\n\ntype Logger interface {\n    Log(message string)\n}\n```", "```go\ntype LoggerAdapter func(message string)\n\nfunc (lg LoggerAdapter) Log(message string) {\n    lg(message)\n}\n```", "```go\ntype SimpleLogic struct {\n    l  Logger\n    ds DataStore\n}\n\nfunc (sl SimpleLogic) SayHello(userID string) (string, error) {\n    sl.l.Log(\"in SayHello for \" + userID)\n    name, ok := sl.ds.UserNameForID(userID)\n    if !ok {\n        return \"\", errors.New(\"unknown user\")\n    }\n    return \"Hello, \" + name, nil\n}\n\nfunc (sl SimpleLogic) SayGoodbye(userID string) (string, error) {\n    sl.l.Log(\"in SayGoodbye for \" + userID)\n    name, ok := sl.ds.UserNameForID(userID)\n    if !ok {\n        return \"\", errors.New(\"unknown user\")\n    }\n    return \"Goodbye, \" + name, nil\n}\n```", "```go\nfunc NewSimpleLogic(l Logger, ds DataStore) SimpleLogic {\n    return SimpleLogic{\n        l:    l,\n        ds: ds,\n    }\n}\n```", "```go\ntype Logic interface {\n    SayHello(userID string) (string, error)\n}\n```", "```go\ntype Controller struct {\n    l     Logger\n    logic Logic\n}\n\nfunc (c Controller) SayHello(w http.ResponseWriter, r *http.Request) {\n    c.l.Log(\"In SayHello\")\n    userID := r.URL.Query().Get(\"user_id\")\n    message, err := c.logic.SayHello(userID)\n    if err != nil {\n        w.WriteHeader(http.StatusBadRequest)\n        w.Write([]byte(err.Error()))\n        return\n    }\n    w.Write([]byte(message))\n}\n```", "```go\nfunc NewController(l Logger, logic Logic) Controller {\n    return Controller{\n        l:     l,\n        logic: logic,\n    }\n}\n```", "```go\nfunc main() {\n    l := LoggerAdapter(LogOutput)\n    ds := NewSimpleDataStore()\n    logic := NewSimpleLogic(l, ds)\n    c := NewController(l, logic)\n    http.HandleFunc(\"/hello\", c.SayHello)\n    http.ListenAndServe(\":8080\", nil)\n}\n```"]