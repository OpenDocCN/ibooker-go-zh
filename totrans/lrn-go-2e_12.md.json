["```go\nfunc process(val int) int {\n    // do something with val\n}\n\nfunc processConcurrently(inVals []int) []int {\n    // create the channels\n    in := make(chan int, 5)\n    out := make(chan int, 5)\n    // launch processing goroutines\n    for i := 0; i < 5; i++ {\n        go func() {\n            for val := range in {\n                out <- process(val)\n            }\n        }()\n    }\n    // load the data into the in channel in another goroutine\n    // read the data from the out channel\n    // return the data\n}\n```", "```go\nch := make(chan int)\n```", "```go\na := <-ch // reads a value from ch and assigns it to a\nch <- b   // write the value in b to ch\n```", "```go\nch := make(chan int, 10)\n```", "```go\nfor v := range ch {\n    fmt.Println(v)\n}\n```", "```go\nclose(ch)\n```", "```go\nv, ok := <-ch\n```", "```go\nselect {\ncase v := <-ch:\n    fmt.Println(v)\ncase v := <-ch2:\n    fmt.Println(v)\ncase ch3 <- x:\n    fmt.Println(\"wrote\", x)\ncase <-ch4:\n    fmt.Println(\"got value on ch4, but ignored it\")\n}\n```", "```go\nfunc main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        inGoroutine := 1\n        ch1 <- inGoroutine\n        fromMain := <-ch2\n        fmt.Println(\"goroutine:\", inGoroutine, fromMain)\n    }()\n    inMain := 2\n    ch2 <- inMain\n    fromGoroutine := <-ch1\n    fmt.Println(\"main:\", inMain, fromGoroutine)\n}\n```", "```go\nfatal error: all goroutines are asleep - deadlock!\n```", "```go\nfunc main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        inGoroutine := 1\n        ch1 <- inGoroutine\n        fromMain := <-ch2\n        fmt.Println(\"goroutine:\", inGoroutine, fromMain)\n    }()\n    inMain := 2\n    var fromGoroutine int\n    select {\n    case ch2 <- inMain:\n    case fromGoroutine = <-ch1:\n    }\n    fmt.Println(\"main:\", inMain, fromGoroutine)\n}\n```", "```go\nmain: 2 1\n```", "```go\nfor {\n    select {\n    case <-done:\n        return\n    case v := <-ch:\n        fmt.Println(v)\n    }\n}\n```", "```go\nselect {\ncase v := <-ch:\n    fmt.Println(\"read from ch:\", v)\ndefault:\n    fmt.Println(\"no value written to ch\")\n}\n```", "```go\nfunc main() {\n    a := []int{2, 4, 6, 8, 10}\n    ch := make(chan int, len(a))\n    for _, v := range a {\n        go func() {\n            ch <- v * 2\n        }()\n    }\n    for i := 0; i < len(a); i++ {\n        fmt.Println(<-ch)\n    }\n}\n```", "```go\n20\n20\n20\n20\n20\n```", "```go\n20\n8\n4\n12\n16\n```", "```go\nfor _, v := range a {\n    v := v\n    go func() {\n        ch <- v * 2\n    }()\n}\n```", "```go\nfor _, v := range a {\n    go func(val int) {\n        ch <- val * 2\n    }(v)\n}\n```", "```go\nfunc countTo(max int) <-chan int {\n    ch := make(chan int)\n    go func() {\n        for i := 0; i < max; i++ {\n            ch <- i\n        }\n        close(ch)\n    }()\n    return ch\n}\n\nfunc main() {\n    for i := range countTo(10) {\n        fmt.Println(i)\n    }\n}\n```", "```go\nfunc main() {\n    for i := range countTo(10) {\n        if i > 5 {\n            break\n        }\n        fmt.Println(i)\n    }\n}\n```", "```go\nfunc countTo(ctx context.Context, max int) <-chan int {\n    ch := make(chan int)\n    go func() {\n        defer close(ch)\n        for i := 0; i < max; i++ {\n            select {\n            case <-ctx.Done():\n                return\n            case ch <- i:\n            }\n        }\n    }()\n    return ch\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n    ch := countTo(ctx, 10)\n    for i := range ch {\n        if i > 5 {\n            break\n        }\n        fmt.Println(i)\n    }\n}\n```", "```go\nfunc processChannel(ch chan int) []int {\n    const conc = 10\n    results := make(chan int, conc)\n    for i := 0; i < conc; i++ {\n        go func() {\n            v := <- ch\n            results <- process(v)\n        }()\n    }\n    var out []int\n    for i := 0; i < conc; i++ {\n        out = append(out, <-results)\n    }\n    return out\n}\n```", "```go\ntype PressureGauge struct {\n    ch chan struct{}\n}\n\nfunc New(limit int) *PressureGauge {\n    return &PressureGauge{\n        ch: make(chan struct{}, limit),\n    }\n}\n\nfunc (pg *PressureGauge) Process(f func()) error {\n    select {\n    case pg.ch <- struct{}{}:\n        f()\n        <-pg.ch\n        return nil\n    default:\n        return errors.New(\"no more capacity\")\n    }\n}\n```", "```go\nfunc doThingThatShouldBeLimited() string {\n    time.Sleep(2 * time.Second)\n    return \"done\"\n}\n\nfunc main() {\n    pg := New(10)\n    http.HandleFunc(\"/request\", func(w http.ResponseWriter, r *http.Request) {\n        err := pg.Process(func() {\n            w.Write([]byte(doThingThatShouldBeLimited()))\n        })\n        if err != nil {\n            w.WriteHeader(http.StatusTooManyRequests)\n            w.Write([]byte(\"Too many requests\"))\n        }\n    })\n    http.ListenAndServe(\":8080\", nil)\n}\n```", "```go\n// in and in2 are channels\nfor count := 0; count < 2; {\n    select {\n    case v, ok := <-in:\n        if !ok {\n            in = nil // the case will never succeed again!\n            count++\n            continue\n        }\n        // process the v that was read from in\n    case v, ok := <-in2:\n        if !ok {\n            in2 = nil // the case will never succeed again!\n            count++\n            continue\n        }\n        // process the v that was read from in2\n    }\n}\n```", "```go\nfunc timeLimit[T any](worker func() T, limit time.Duration) (T, error) {\n    out := make(chan T, 1)\n    ctx, cancel := context.WithTimeout(context.Background(), limit)\n    defer cancel()\n    go func() {\n        out <- worker()\n    }()\n    select {\n    case result := <-out:\n        return result, nil\n    case <-ctx.Done():\n        var zero T\n        return zero, errors.New(\"work timed out\")\n    }\n}\n```", "```go\nfunc main() {\n    var wg sync.WaitGroup\n    wg.Add(3)\n    go func() {\n        defer wg.Done()\n        doThing1()\n    }()\n    go func() {\n        defer wg.Done()\n        doThing2()\n    }()\n    go func() {\n        defer wg.Done()\n        doThing3()\n    }()\n    wg.Wait()\n}\n```", "```go\nfunc processAndGather[T, R any](in <-chan T, processor func(T) R, num int) []R {\n    out := make(chan R, num)\n    var wg sync.WaitGroup\n    wg.Add(num)\n    for i := 0; i < num; i++ {\n        go func() {\n            defer wg.Done()\n            for v := range in {\n                out <- processor(v)\n            }\n        }()\n    }\n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n    var result []R\n    for v := range out {\n        result = append(result, v)\n    }\n    return result\n}\n```", "```go\ntype SlowComplicatedParser interface {\n    Parse(string) string\n}\n\nfunc initParser() SlowComplicatedParser {\n    // do all sorts of setup and loading here\n}\n```", "```go\nvar parser SlowComplicatedParser\nvar once sync.Once\n\nfunc Parse(dataToParse string) string {\n    once.Do(func() {\n        parser = initParser()\n    })\n    return parser.Parse(dataToParse)\n}\n```", "```go\nvar initParserCached func() SlowComplicatedParser = sync.OnceValue(initParser)\n\nfunc Parse(dataToParse string) string {\n    parser := initParserCached()\n    return parser.Parse(dataToParse)\n}\n```", "```go\nfunc GatherAndProcess(ctx context.Context, data Input) (COut, error) {\n    ctx, cancel := context.WithTimeout(ctx, 50*time.Millisecond)\n    defer cancel()\n\n    ab := newABProcessor()\n    ab.start(ctx, data)\n    inputC, err := ab.wait(ctx)\n    if err != nil {\n        return COut{}, err\n    }\n\n    c := newCProcessor()\n    c.start(ctx, inputC)\n    out, err := c.wait(ctx)\n    return out, err\n}\n```", "```go\ntype abProcessor struct {\n    outA chan aOut\n    outB chan bOut\n    errs chan error\n}\n\nfunc newABProcessor() *abProcessor {\n    return &abProcessor{\n        outA: make(chan aOut, 1),\n        outB: make(chan bOut, 1),\n        errs: make(chan error, 2),\n    }\n}\n```", "```go\nfunc (p *abProcessor) start(ctx context.Context, data Input) {\n    go func() {\n        aOut, err := getResultA(ctx, data.A)\n        if err != nil {\n            p.errs <- err\n            return\n        }\n        p.outA <- aOut\n    }()\n    go func() {\n        bOut, err := getResultB(ctx, data.B)\n        if err != nil {\n            p.errs <- err\n            return\n        }\n        p.outB <- bOut\n    }()\n}\n```", "```go\nfunc (p *abProcessor) wait(ctx context.Context) (cIn, error) {\n    var cData cIn\n    for count := 0; count < 2; count++ {\n        select {\n        case a := <-p.outA:\n            cData.a = a\n        case b := <-p.outB:\n            cData.b = b\n        case err := <-p.errs:\n            return cIn{}, err\n        case <-ctx.Done():\n            return cIn{}, ctx.Err()\n        }\n    }\n    return cData, nil\n}\n```", "```go\ntype cProcessor struct {\n    outC chan COut\n    errs chan error\n}\n\nfunc newCProcessor() *cProcessor {\n    return &cProcessor{\n        outC: make(chan COut, 1),\n        errs: make(chan error, 1),\n    }\n}\n\nfunc (p *cProcessor) start(ctx context.Context, inputC cIn) {\n    go func() {\n        cOut, err := getResultC(ctx, inputC)\n        if err != nil {\n            p.errs <- err\n            return\n        }\n        p.outC <- cOut\n    }()\n}\n\nfunc (p *cProcessor) wait(ctx context.Context) (COut, error) {\n    select {\n    case out := <-p.outC:\n        return out, nil\n    case err := <-p.errs:\n        return COut{}, err\n    case <-ctx.Done():\n        return COut{}, ctx.Err()\n    }\n}\n```", "```go\nfunc scoreboardManager(ctx context.Context, in <-chan func(map[string]int)) {\n    scoreboard := map[string]int{}\n    for {\n        select {\n        case <-ctx.Done():\n            return\n        case f := <-in:\n            f(scoreboard)\n        }\n    }\n}\n```", "```go\ntype ChannelScoreboardManager chan func(map[string]int)\n\nfunc NewChannelScoreboardManager(ctx context.Context) ChannelScoreboardManager {\n    ch := make(ChannelScoreboardManager)\n    go scoreboardManager(ctx, ch)\n    return ch\n}\n\nfunc (csm ChannelScoreboardManager) Update(name string, val int) {\n    csm <- func(m map[string]int) {\n        m[name] = val\n    }\n}\n```", "```go\nfunc (csm ChannelScoreboardManager) Read(name string) (int, bool) {\n    type Result struct {\n        out int\n        ok  bool\n    }\n    resultCh := make(chan Result)\n    csm <- func(m map[string]int) {\n        out, ok := m[name]\n        resultCh <- Result{out, ok}\n    }\n    result := <-resultCh\n    return result.out, result.ok\n}\n```", "```go\ntype MutexScoreboardManager struct {\n    l          sync.RWMutex\n    scoreboard map[string]int\n}\n\nfunc NewMutexScoreboardManager() *MutexScoreboardManager {\n    return &MutexScoreboardManager{\n        scoreboard: map[string]int{},\n    }\n}\n\nfunc (msm *MutexScoreboardManager) Update(name string, val int) {\n    msm.l.Lock()\n    defer msm.l.Unlock()\n    msm.scoreboard[name] = val\n}\n\nfunc (msm *MutexScoreboardManager) Read(name string) (int, bool) {\n    msm.l.RLock()\n    defer msm.l.RUnlock()\n    val, ok := msm.scoreboard[name]\n    return val, ok\n}\n```"]