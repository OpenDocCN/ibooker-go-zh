- en: 'Chapter 4\. bundles of code: Packages'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：代码包
- en: '![image](assets/f0113-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0113-01.png)'
- en: '**It’s time to get organized**. So far, we’ve been throwing all our code together
    in a single file. As our programs grow bigger and more complex, that’s going to
    quickly become a mess.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**是时候开始组织了**。到目前为止，我们一直将所有代码混合放在一个文件中。随着程序变得越来越大和复杂，这很快就会变得一团糟。'
- en: In this chapter, we’ll show you how to create your own **packages** to help
    keep related code together in one place. But packages are good for more than just
    organization. Packages are an easy way to *share code between your programs*.
    And they’re an easy way to *share code with other developers*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向你展示如何创建你自己的**包**，以帮助将相关的代码放在一个地方。但包不仅仅是用于组织的好工具。包是在程序之间*分享代码*的一种简便方式。它们也是向其他开发者*分享代码*的简便方式。
- en: Different programs, same function
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的程序，同一个函数
- en: We’ve written two programs, each with an identical copy of a function, and it’s
    becoming a maintenance headache...
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了两个程序，每个程序中都有一个相同的函数副本，这让维护变得头疼…
- en: On this page, we’ve got a new version of our *pass_fail.go* program from [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition).
    The code that reads a grade from the keyboard has been moved to a new `getFloat`
    function. `getFloat` returns the floating-point number the user typed, unless
    there’s an error, in which case it returns `0` and an error value. If an error
    is returned, the program reports it and exits; otherwise, it reports whether the
    grade is passing or failing, as before.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一页上，我们有一个来自[第 2 章](ch02.html#which_code_runs_nextquestcolon_condition)的新版本的*pass_fail.go*程序。从键盘读取成绩的代码已经移动到一个新的`getFloat`函数中。`getFloat`返回用户键入的浮点数，除非出现错误，否则返回`0`和一个错误值。如果返回错误，程序会报告并退出；否则，它会像以前一样报告成绩是否及格。
- en: '![image](assets/f0114-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0114-01.png)'
- en: On this page, we’ve got a new *tocelsius.go* program that lets the user type
    a temperature in the Fahrenheit measurement system and converts it to the Celsius
    system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一页上，我们有一个新的*tocelsius.go*程序，允许用户输入华氏温度，并将其转换为摄氏温度。
- en: Notice that the `getFloat` function in *tocelsius.go* is identical to the `getFloat`
    function in *pass_fail.go*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*tocelsius.go*中的`getFloat`函数与*pass_fail.go*中的`getFloat`函数是完全相同的。
- en: '![image](assets/f0115-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0115-01.png)'
- en: Sharing code between programs using packages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包在程序之间共享代码
- en: '![image](assets/f0116-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0116-01.png)'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Actually, there is something we can do—we can move the shared function to
    a new package!**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际上，我们可以做一些事情——我们可以将共享的函数移到一个新的包中！**'
- en: Go allows us to define our own packages. As we discussed back in [Chapter 1](ch01.html#letapsos_get_going_syntax_basics),
    a package is a group of code that all does similar things. The `fmt` package formats
    output, the `math` package works with numbers, the `strings` package works with
    strings, and so on. We’ve used the functions from each of these packages in multiple
    programs already.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许我们定义自己的包。正如我们在[第 1 章](ch01.html#letapsos_get_going_syntax_basics)中讨论的那样，包是一组做类似事情的代码。`fmt`
    包格式化输出，`math` 包处理数字，`strings` 包处理字符串，等等。我们已经在多个程序中使用了每个包中的函数。
- en: Being able to use the same code between programs is one of the major reasons
    packages exist. If parts of your code are shared between multiple programs, you
    should consider moving them into packages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在程序之间使用相同的代码是包存在的主要原因之一。如果你的代码的某些部分被多个程序共享，你应该考虑将它们移到包中。
- en: '**If parts of your code are shared between multiple programs, you should consider
    moving them into packages.**'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**如果你的代码的某些部分被多个程序共享，你应该考虑将它们移到包中。**'
- en: The Go workspace directory holds package code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 工作空间目录保存包代码
- en: Go tools look for package code in a special directory (folder) on your computer
    called the **workspace**. By default, the workspace is a directory named *go*
    in the current user’s home directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具在计算机上的一个特殊目录（文件夹）中寻找包代码，这个目录称为**工作空间**。默认情况下，工作空间是当前用户主目录中名为*go*的目录。
- en: 'The workspace directory contains three subdirectories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 工作空间目录包含三个子目录：
- en: '*bin*, which holds compiled binary executable programs. (We’ll talk more about
    *bin* later in the chapter.)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bin*，它包含编译后的二进制可执行程序。（我们稍后在本章还会更多地讨论*bin*。）'
- en: '*pkg*, which holds compiled binary package files. (We’ll also talk more about
    *pkg* later in the chapter.)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pkg*，它包含编译后的二进制包文件。（我们稍后在本章还会更多地讨论*pkg*。）'
- en: '*src*, which holds Go source code.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*src*，它包含 Go 源代码。'
- en: Within *src*, code for each package lives in its own separate subdirectory.
    By convention, the subdirectory name should be the same as the package name (so
    code for a `gizmo` package would go in a *gizmo* subdirectory).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *src* 中，每个包的代码都存在于自己单独的子目录中。按照惯例，子目录的名称应与包名称相同（因此 `gizmo` 包的代码将放在 *gizmo*
    子目录中）。
- en: Each package directory should contain one or more source code files. The filenames
    don’t matter, but they should end in a *.go* extension.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包目录应该包含一个或多个源代码文件。文件名不重要，但应以 *.go* 扩展名结尾。
- en: '![image](assets/f0117-01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0117-01.png)'
- en: there are no Dumb Questions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有愚蠢的问题
- en: '**Q: You said a package folder can contain multiple files. What should go in
    each file?**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q: 你说一个包文件夹可以包含多个文件。每个文件应该放什么？**'
- en: '**A:** Whatever you want! You can keep all of a package’s code in one file,
    or split it between multiple files. Either way, it will all become part of the
    same package.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**A:** 你想要的任何内容！你可以将一个包的所有代码放在一个文件中，或者在多个文件之间进行拆分。无论哪种方式，它们都将成为同一个包的一部分。'
- en: Creating a new package
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的包
- en: Let’s try setting up a package of our own in the workspace. We’ll make a simple
    package named `greeting` that prints greetings in various languages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在工作空间中设置我们自己的包。我们将创建一个简单的包，名为 `greeting`，用于打印各种语言的问候语。
- en: The workspace directory isn’t created by default when Go is installed, so you’ll
    need to create it yourself. Start by going to your home directory. (The path is
    *C:\Users\<yourname>* on most Windows systems, */Users/<yourname>* on Macs, and
    */home/<yourname>* on most Linux systems.) Within the home directory, create a
    directory named *go*—this will be our new workspace directory. Within the *go*
    directory, create a directory named *src*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Go 安装时不会默认创建工作空间目录，因此您需要自己创建。首先进入您的主目录。（在大多数 Windows 系统上，路径为 *C:\Users\<yourname>*，在
    Mac 上为 */Users/<yourname>*，在大多数 Linux 系统上为 */home/<yourname>*。）在主目录中，创建一个名为 *go*
    的目录——这将是我们的新工作空间目录。在 *go* 目录中，创建一个名为 *src* 的目录。
- en: Finally, we need a directory to hold our package code. By convention, a package’s
    directory should have the same name as a package. Since our package will be named
    `greeting`, that’s the name you should use for the directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个目录来存放我们的包代码。按照惯例，包的目录应与包的名称相同。因为我们的包将被命名为 `greeting`，所以您应该为目录使用这个名称。
- en: We know, that seems like a lot of nested directories (and actually, we’ll be
    nesting them even deeper shortly). But trust us, once you’ve built up a collection
    of packages of your own as well as packages from others, this structure will help
    you keep your code organized.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，这似乎是很多嵌套的目录（实际上，我们很快将进一步嵌套它们）。但请相信我们，一旦您建立了自己的包集合以及来自他人的包，这种结构将帮助您保持代码的组织性。
- en: '![image](assets/f0118-01.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0118-01.png)'
- en: And more importantly, this structure helps Go tools find the code. Because it’s
    always in the *src* directory, Go tools know exactly where to look to find code
    for the packages you’re importing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这种结构有助于 Go 工具找到代码。因为它始终位于 *src* 目录中，Go 工具确切知道在哪里查找导入包的代码。
- en: Your next step is to create a file within the *greeting* directory, and name
    it *greeting.go*. The file should include the code below. We’ll talk about it
    more shortly, but for now there’s just a couple things we want you to notice...
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一步是在 *greeting* 目录中创建一个文件，并将其命名为 *greeting.go*。文件应包含以下代码。稍后我们将详细讨论它，但现在我们想让您注意几点…
- en: Like all of our Go source code files thus far, this file starts with a `package`
    line. But unlike the others, this code isn’t part of the `main` package; it’s
    part of a package named `greeting`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们迄今为止的所有 Go 源代码文件一样，此文件以 `package` 行开头。但不同于其他文件的是，这段代码不属于 `main` 包；它属于名为
    `greeting` 的包。
- en: '![image](assets/f0118-02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0118-02.png)'
- en: Also notice the two function definitions. They aren’t much different from other
    functions we’ve seen so far. But because we want these functions to be accessible
    outside the `greeting` package, notice that we capitalize the first letter of
    their names so the functions are exported.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意两个函数定义。它们与我们迄今为止见过的其他函数没有太大不同。但因为我们希望这些函数可以在 `greeting` 包外部访问，所以请注意我们将它们的名称首字母大写，以便导出这些函数。
- en: Importing our package into a program
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的包导入到程序中
- en: Now let’s try using our new package within a program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在程序中使用我们的新包。
- en: '![image](assets/f0119-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0119-01.png)'
- en: In your workspace directory, within the *src* subdirectory, create another subdirectory
    named *hi*. (We don’t *have* to store code for executable programs within the
    workspace, but it’s a good idea.)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工作区目录中，在*src*子目录中，创建另一个名为*hi*的子目录。（我们不一定要将可执行程序的代码存储在工作区中，但这是一个好主意。）
- en: Then, within your new *hi* directory, we need to create another source file.
    We can name the file anything we want, as long as it ends with a *.go* extension,
    but since this is going to be an executable command, we’ll name it *main.go*.
    Save the code below within the file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的新*hi*目录中，我们需要创建另一个源文件。我们可以将文件命名为任何我们想要的名称，只要以*.go*扩展名结尾，但由于这将是一个可执行命令，我们将其命名为*main.go*。将下面的代码保存在文件中。
- en: Like in every Go source code file, this code starts with a `package` line. But
    because we intend this to be an executable command, we need to use a package name
    of `main`. Generally, the package name should match the name of the directory
    it’s kept in, but the `main` package is an exception to that rule.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个Go源代码文件一样，这段代码以一个`package`行开始。但因为我们打算将其作为一个可执行命令，我们需要使用一个`main`的包名。通常，包名应该与其所在目录的名称匹配，但`main`包是这个规则的一个例外。
- en: '![image](assets/f0119-02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0119-02.png)'
- en: Next we need to import the `greeting` package so we can use its functions. Go
    tools look for package code in a folder within the workspace’s *src* directory
    whose name matches the name in the `import` statement. To tell Go to look for
    code in the *src/greeting* directory within the workspace, we use `import "greeting"`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们需要导入`greeting`包，以便我们可以使用它的函数。Go工具会在工作区的*src*目录中与`import`语句中的名称匹配的文件夹中查找包代码。为了告诉Go在工作区内的*src/greeting*目录中查找代码，我们使用`import
    "greeting"`。 '
- en: Finally, because this is code for an executable, we need a `main` function that
    will be called when the program runs. In `main` we call both functions that are
    defined in the `greeting` package. Both calls are preceded by the package name
    and a dot, so that Go knows which package the functions are a part of.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为这是一个可执行文件的代码，我们需要一个`main`函数，当程序运行时将被调用。在`main`中，我们调用了`greeting`包中定义的两个函数。两个调用都在包名和一个点之前，这样Go就知道这些函数属于哪个包。
- en: '![image](assets/f0119-03.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0119-03.png)'
- en: We’re all set; let’s try running the program. In your terminal or command prompt
    window, use the `**cd**` command to change to the *src/hi* directory within your
    workspace directory. (The path will vary based on the location of your home directory.)
    Then, use `**go run main.go**` to run the program.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了；让我们尝试运行程序。在你的终端或命令提示符窗口中，使用`**cd**`命令切换到工作区目录中的*src/hi*目录。（路径会根据你的主目录位置而变化。）然后，使用`**go
    run main.go**`来运行程序。
- en: When it sees the `import "greeting"` line, Go will look in the *greeting* directory
    in your workspace’s *src* directory for the package source code. That code gets
    compiled and imported, and we’re able to call the `greeting` package’s functions!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当它看到`import "greeting"`这一行时，Go将在你工作区的*src*目录中的*greeting*目录中查找包源代码。该代码被编译和导入，我们就能调用`greeting`包的函数了！
- en: Packages use the same file layout
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包使用相同的文件布局
- en: Remember back in [Chapter 1](ch01.html#letapsos_get_going_syntax_basics), we
    talked about the three sections almost every Go source code file has?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第1章](ch01.html#letapsos_get_going_syntax_basics)中谈到的几乎每个Go源代码文件都有的三个部分吗？
- en: '![image](assets/f0120-01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0120-01.png)'
- en: That rule holds true for the `main` package in our *main.go* file, of course.
    In our code, you can see a `package` clause, followed by an imports section, followed
    by the actual code for our package.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则对我们*main.go*文件中的`main`包当然也适用。在我们的代码中，你可以看到一个`package`子句，后面是一个导入部分，然后是我们包的实际代码。
- en: '![image](assets/f0120-02.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0120-02.png)'
- en: Packages other than `main` follow the same format. You can see that our *greeting.go*
    file also has a package clause, imports section, and the actual package code at
    the end.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`main`之外的包遵循相同的格式。你可以看到我们的*greeting.go*文件也有一个包子句，导入部分，以及最后的实际包代码。
- en: '![image](assets/f0120-03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0120-03.png)'
- en: Breaking Stuff is Educational!
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏东西是教育性的！
- en: '![image](assets/f0121-01.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0121-01.png)'
- en: Take our code for the `greeting` package, as well as the code for the program
    that imports it. Try making one of the changes below and run it. Then undo your
    change and try the next one. See what happens!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出我们的`greeting`包的代码，以及导入它的程序的代码。尝试做出以下一项更改并运行它。然后撤销你的更改并尝试下一个。看看会发生什么！
- en: '![image](assets/f0121-02.png)![image](assets/f0121-03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0121-02.png)![图片](assets/f0121-03.png)'
- en: Pool Puzzle
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines. **Don’t** use the same snippet more than once, and you won’t need
    to use all the snippets. Your **goal** is to set up a `calc` package within a
    Go workspace so `calc`’s functions can be used within *main.go*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从池中提取代码片段，并将其放入空白行中。**不要**重复使用同一段落，也不需要使用所有的段落。你的**目标**是在 Go 工作空间中设置一个
    `calc` 包，以便在 *main.go* 中使用 `calc` 的函数。
- en: '![image](assets/f0122-01.png)![image](assets/f0122-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0122-01.png)![image](assets/f0122-02.png)'
- en: '**Note: each snippet from the pool can only be used once!**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个来自池中的片段只能使用一次！**'
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_4a).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](assets/arrow.png) 在 [“池子难题解决方案”](#pool_puzzle_solution_4a) 中有答案。'
- en: Package naming conventions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包命名约定
- en: 'Developers using a package are going to need to type its name each and every
    time they call a function from that package. (Think of `fmt.Printf`, `fmt.Println`,
    `fmt.Print`, etc.) To make that as painless as possible, there are a few rules
    package names should follow:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包的开发者需要在每次调用来自该包的函数时输入其名称（例如 `fmt.Printf`、`fmt.Println`、`fmt.Print` 等）。为了尽可能简化这个过程，包名称应遵循几个规则：
- en: A package name should be all lowercase.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名应全小写。
- en: The name should be abbreviated if the meaning is fairly obvious (such as `fmt`).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果含义相当明显，名称应缩写（例如 `fmt`）。
- en: It should be one word, if possible. If two words are needed, they should *not*
    be separated by underscores, and the second word should *not* be capitalized.
    (The `strconv` package is one example.)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，应该是一个单词。如果需要两个单词，它们*不应*用下划线分隔，并且第二个单词*不应*大写。（`strconv` 包就是一个例子。）
- en: Imported package names can conflict with local variable names, so don’t use
    a name that package users are likely to want to use as well. (For example, if
    the `fmt` package were named `format`, anyone who imported that package would
    risk conflicts if they named a local variable `format`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的包名称可能与局部变量名称冲突，因此不要使用包用户可能也想使用的名称。（例如，如果 `fmt` 包被命名为 `format`，那么任何导入该包的人在命名局部变量
    `format` 时都会面临冲突风险。）
- en: Package qualifiers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包限定符
- en: When accessing a function, variable, or the like that’s exported from a different
    package, you need to qualify the name of the function or variable by typing the
    package name before it. When you access a function or variable that’s defined
    in the *current* package, however, you should *not* qualify the package name.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问来自不同包的导出函数、变量或类似内容时，需要通过输入包名称来限定函数或变量的名称。然而，当访问在*当前*包中定义的函数或变量时，不应限定包名称。
- en: In our *main.go* file, since our code is in the `main` package, we need to specify
    that the `Hello` and `Hi` functions are from the `greeting` package, by typing
    `**greeting.Hello**` and `**greeting.Hi**`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *main.go* 文件中，因为我们的代码在 `main` 包中，我们需要指定 `Hello` 和 `Hi` 函数来自 `greeting`
    包，通过输入 `**greeting.Hello**` 和 `**greeting.Hi**`。
- en: '![image](assets/f0123-01.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0123-01.png)'
- en: Suppose that we called the `Hello` and `Hi` functions from another function
    in the `greeting` package, though. There, we would just type `Hello` and `Hi`
    (without the package name qualifier) because we’d be calling the functions from
    the same package where they’re defined.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从 `greeting` 包中的另一个函数中调用了 `Hello` 和 `Hi` 函数。在那里，我们只需输入 `Hello` 和 `Hi`（不带包名限定符），因为我们将从定义它们的同一包中调用这些函数。
- en: Moving our shared code to a package
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的共享代码移动到一个包中
- en: Now that we understand how to add packages to the Go workspace, we’re finally
    ready to move our `getFloat` function to a package that our *pass_fail.go* and
    *tocelsius.go* programs can both use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何向 Go 工作空间添加包，我们终于可以将我们的 `getFloat` 函数移动到一个包中，这样我们的 *pass_fail.go* 和
    *tocelsius.go* 程序都可以使用它。
- en: '![image](assets/f0124-01.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0124-01.png)'
- en: Let’s name our package `keyboard`, since it reads user input from the keyboard.
    We’ll start by creating a new directory named *keyboard* inside our workspace’s
    *src* directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们命名我们的包为 `keyboard`，因为它从键盘读取用户输入。我们将在工作空间的 *src* 目录下创建一个名为 *keyboard* 的新目录。
- en: 'Next, we’ll create a source code file within the *keyboard* directory. We can
    name it anything we want, but we’ll just name it after the package: *keyboard.go*.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 *keyboard* 目录中创建一个源代码文件。我们可以任意命名它，但我们将其命名为包名：*keyboard.go*。
- en: 'At the top of the file, we’ll need a `package` clause with the package name:
    `keyboard`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部，我们需要一个 `package` 子句，并指定包名称为：`keyboard`。
- en: 'Then, because this is a separate file, we’ll need an `import` statement with
    all the packages used in our code: `bufio`, `os`, `strconv`, and `strings`. (We
    need to leave out the `fmt` and `log` packages, as those are only used in the
    *pass_fail.go* and *tocelsius.go* files.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，因为这是一个单独的文件，我们需要一个`import`语句来引入我们代码中使用的所有包：`bufio`、`os`、`strconv`和`strings`。（我们需要排除`fmt`和`log`包，因为它们仅在*pass_fail.go*和*tocelsius.go*文件中使用。）
- en: '![image](assets/f0124-02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0124-02.png)'
- en: Finally, we can copy the code from the old `getFloat` function as is. But we
    need to be sure to rename the function to `GetFloat`, because it won’t be exported
    unless the first letter of its name is capitalized.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接复制旧的`getFloat`函数的代码。但我们需要确保将函数重命名为`GetFloat`，因为除非其名称的第一个字母大写，否则它不会被导出。
- en: Now the *pass_fail.go* program can be updated to use our new `keyboard` package.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在*pass_fail.go*程序可以更新以使用我们的新`keyboard`包。
- en: '![image](assets/f0125-01.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0125-01.png)'
- en: Because we’re removing the old `getFloat` function, we need to remove the unused
    `bufio`, `os`, `strconv`, and `strings` imports. In their place, we’ll import
    the new `keyboard` package.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要移除旧的`getFloat`函数，所以需要移除未使用的`bufio`、`os`、`strconv`和`strings`导入项。我们将导入新的`keyboard`包。
- en: In our `main` function, in place of the old call to `getFloat`, we’ll call the
    new `keyboard.GetFloat` function. The rest of the code is unchanged.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们将不再调用旧的`getFloat`，而是调用新的`keyboard.GetFloat`函数。其余代码保持不变。
- en: If we run the updated program, we’ll see the same output as before.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行更新后的程序，我们将看到与之前相同的输出。
- en: '![image](assets/f0125-02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0125-02.png)'
- en: We can make the same updates to the *tocelsius.go* program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对*tocelsius.go*程序进行相同的更新。
- en: We update the imports, remove the old `getFloat`, and call `keyboard.GetFloat`
    instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了导入项，移除了旧的`getFloat`，并调用`keyboard.GetFloat`代替。
- en: And again, if we run the updated program, we’ll get the same output as before.
    But this time, instead of relying on redundant function code, we’re using the
    shared function in our new package!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果我们运行更新后的程序，将会得到与之前相同的输出。但这次，我们不再依赖于冗余的函数代码，而是在我们的新包中使用共享函数！
- en: Constants
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'Many packages export **constants**: named values that never change.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多包会导出**常量**：这些是从不改变的命名值。
- en: 'A constant declaration looks a lot like a variable declaration, with a name,
    optional type, and value for the constant. But the rules are slightly different:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明看起来很像变量声明，有名称、可选类型和常量值。但规则略有不同：
- en: Instead of the `var` keyword, you use the `const` keyword.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再使用`var`关键字，而是使用`const`关键字。
- en: You must assign a value at the time the constant is declared; you can’t assign
    a value later as with variables.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量在声明时必须赋值；不能像变量那样稍后再赋值。
- en: Variables have the `:=` short variable declaration syntax available, but there
    is no equivalent for constants.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量可以使用`:=`短变量声明语法，但常量没有类似的语法。
- en: '![image](assets/f0126-01.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0126-01.png)'
- en: 'As with variable declarations, you can omit the type, and it will be inferred
    from the value being assigned:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量声明一样，您可以省略类型，类型将从被赋值的值中推断出来：
- en: '![image](assets/f0126-02.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0126-02.png)'
- en: 'The value of a *variable* can *vary*, but the value of a *constant* must remain
    *constant*. Attempting to assign a new value to a constant will result in a compile
    error. This is a safety feature: constants should be used for values that *shouldn’t*
    ever change.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*的值可以*变化*，但*常量*的值必须*恒定*。试图给常量赋予新值将导致编译错误。这是一种安全特性：常量应该用于*不应*变化的值。'
- en: '![image](assets/f0126-03.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0126-03.png)'
- en: 'If your program includes “hardcoded” literal values, especially if those values
    are used in multiple places, you should consider replacing them with constants
    (even if the program isn’t broken up into multiple packages). Here’s a package
    with two functions, both featuring the integer literal `7` representing the number
    of days in a week:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序包含“硬编码”的文字值，特别是这些值在多个地方使用，您应考虑将它们替换为常量（即使程序没有分成多个包）。这是一个包含两个函数的包，两者都使用整数字面值`7`表示一周有几天：
- en: '![image](assets/f0126-04.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0126-04.png)'
- en: By replacing the literal values with a constant, `DaysInWeek`, we can document
    what they mean. (Other developers will see the name `DaysInWeek`, and immediately
    know we didn’t randomly choose the number `7` to use in our functions.) Also,
    if we add more functions later, we can avoid inconsistencies by having them refer
    to `DaysInWeek` as well.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用常量`DaysInWeek`替换文字值，我们可以说明它们的含义。（其他开发人员看到`DaysInWeek`这个名称，立即知道我们不是随意选择数字`7`来在函数中使用。）而且，如果以后添加更多函数，可以通过引用`DaysInWeek`来避免不一致性。
- en: Notice that we declare the constant outside of any function, at the package
    level. Although it’s possible to declare a constant inside a function, that would
    limit its scope to the block for that function. It’s much more typical to declare
    constants at the package level, so they can be accessed by all functions in that
    package.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将常量声明在任何函数之外，即在包级别。虽然可以在函数内部声明常量，但那将限制其作用域仅在该函数的块中。更典型的做法是在包级别声明常量，以便所有函数都可以访问它们。
- en: '![image](assets/f0127-01.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0127-01.png)'
- en: As with variables and functions, a constant whose name begins with a capital
    letter is exported, and we can access it from other packages by qualifying its
    name. Here, a program makes use of the `DaysInWeek` constant from the `main` package
    by importing the `dates` package and qualifying the constant name as `dates.DaysInWeek`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 像变量和函数一样，以大写字母开头的常量是导出的，我们可以通过限定其名称从其他包中访问它们。在这里，程序使用`dates`包中的`DaysInWeek`常量，并将常量名称限定为`dates.DaysInWeek`。
- en: '![image](assets/f0127-02.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0127-02.png)'
- en: Nested package directories and import paths
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套的包目录和导入路径
- en: When you’re working with the packages that come with Go, like `fmt` and `strconv`,
    the package name is usually the same as its import path (the string you use in
    an `import` statement to import the package). But as we saw in [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition),
    that’s not always the case...
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Go提供的像`fmt`和`strconv`这样的包时，包名通常与其导入路径相同（即在`import`语句中使用的字符串）。但正如我们在[第2章](ch02.html#which_code_runs_nextquestcolon_condition)中看到的那样，情况并非总是如此……
- en: '![image](assets/f0128-01.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0128-01.png)'
- en: Some sets of packages are grouped together by import path prefixes like `"archive/"`
    and `"math/"`. We said to think of these prefixes as being similar to the paths
    of directories on your hard drive...and that wasn’t a coincidence. These import
    path prefixes *are* created using directories!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有些包集合通过导入路径前缀进行分组，例如`"archive/"`和`"math/"`。我们说这些前缀可以类比于硬盘上的目录路径……这并非巧合。这些导入路径前缀确实是使用目录创建的！
- en: '![image](assets/f0128-02.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0128-02.png)'
- en: You can nest groups of similar packages together in a directory in your Go workspace.
    That directory then becomes part of the import path for all the packages it contains.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Go工作空间中的一个目录中嵌套类似的包组。
- en: Suppose, for example, that we wanted to add packages for greetings in additional
    languages. That would quickly become a mess if we placed them all directly in
    the *src* directory. But if we place the new packages under the *greeting* directory,
    they’ll all be grouped neatly together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要添加其他语言的问候包。如果直接将它们全部放在*src*目录下，会很快变得混乱。但如果将新包放置在*greeting*目录下，它们将会整齐地分组在一起。
- en: And placing the packages under the *greeting* directory affects their import
    path, too. If the `dansk` package were stored directly under *src*, its import
    path would be `"dansk"`. But place it within the *greeting* directory, and its
    import path becomes `"greeting/dansk"`. Move the `deutsch` package under the *greeting*
    directory, and its import path becomes `"greeting/deutsch"`. The original `greeting`
    package will still be available at an import path of `"greeting"`, as long as
    its source code file is stored directly under the *greeting* directory (not a
    subdirectory).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将包放置在*greeting*目录下也会影响它们的导入路径。如果`dansk`包直接存储在*src*下，其导入路径将是`"dansk"`。但将其放置在*greeting*目录下，则其导入路径变为`"greeting/dansk"`。将`deutsch`包移动到*greeting*目录下，其导入路径变为`"greeting/deutsch"`。原始的*greeting*包仍然可以通过导入路径`"greeting"`访问，只要其源代码文件直接存储在*greeting*目录下（而非子目录）。
- en: 'Suppose that we had a `deutsch` package nested under our *greeting* package
    directory, and that its code looked like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`deutsch`包嵌套在*greeting*包目录下，并且其代码看起来像这样：
- en: '![image](assets/f0129-01.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0129-01.png)'
- en: 'Let’s update our *hi/main.go* code to use the `deutsch` package as well. Since
    it’s nested under the *greeting* directory, we’ll need to use an import path of
    `"greeting/deutsch"`. But once it’s imported, we’ll be using just the package
    name to refer to it: `deutsch`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的*hi/main.go*代码，以便也使用`deutsch`包。因为它是嵌套在*greeting*目录下，我们需要使用引入路径`"greeting/deutsch"`。但一旦导入了它，我们将只使用包名`deutsch`来引用它。
- en: '![image](assets/f0129-02.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0129-02.png)'
- en: As before, we run our code by using the `**cd**` command to change to the *src/hi*
    directory within your workspace directory. Then, we use `**go run main.go**` to
    run the program. We’ll see the results of our calls to the `deutsch` package functions
    in the output.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们通过使用`**cd**`命令切换到工作空间目录中的*src/hi*目录来运行我们的代码。然后，我们使用`**go run main.go**`来运行程序。我们将在输出中看到对`deutsch`包函数调用的结果。
- en: '![image](assets/f0129-03.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0129-03.png)'
- en: Installing program executables with “go install”
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“go install”安装程序可执行文件
- en: When we use `go run`, Go has to compile the program, as well as all the packages
    it depends on, before it can execute it. And it throws that compiled code away
    when it’s done.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`go run`时，Go必须编译程序及其所有依赖的包，然后才能执行它。当完成后，它会丢弃已编译的代码。
- en: In [Chapter 1](ch01.html#letapsos_get_going_syntax_basics), we showed you the
    `go build` command, which compiles and saves an executable binary file (a file
    you can execute even without Go installed) in the current directory. But using
    that too much risks littering your Go workspace with executables in random, inconvenient
    places.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#letapsos_get_going_syntax_basics)中，我们向您展示了`go build`命令，它会编译并保存一个可执行的二进制文件（即使没有安装Go也可以执行的文件）在当前目录。但是过度使用可能会在随机且不方便的位置使您的Go工作空间混乱。
- en: 'The `go install` command also saves compiled binary versions of executable
    programs, but in a well-defined, easily accessible place: a *bin* directory in
    your Go workspace. Just give `go install` the name of a directory within *src*
    that contains code for an executable program (that is, *.go* files that begin
    with `package main`). The program will be compiled and an executable will be stored
    in this standard directory.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`go install`命令还会将可执行程序的编译二进制版本保存在一个定义良好且易于访问的地方：Go工作空间中的*bin*目录。只需将`go install`命令提供的目录名称设置为*src*中包含可执行程序代码的目录（即以`package
    main`开头的.go文件）。程序将被编译，并在此标准目录中存储可执行文件。'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: (Be sure to pass the name of a directory within “src” to “go install”, not the
    name of a .go file! By default, “go install” isn’t set up to handle .go files
    directly.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: （确保将“go install”中的目录名称传递给“src”，而不是.go文件的名称！默认情况下，“go install”未设置为直接处理.go文件。）
- en: Let’s try installing an executable for our *hi/main.go* program. As before,
    from a terminal, we type `**go install**`, a space, and the name of a folder within
    our *src* directory (`**hi**`). Again, it doesn’t matter what directory you do
    this from; the `go` tool will look the directory up within the *src* directory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为我们的*hi/main.go*程序安装一个可执行文件。与以前一样，从终端，我们键入`**go install**`，一个空格，然后是*src*目录中我们的一个文件夹的名称（`**hi**`）。无论您从哪个目录执行此操作，`go`工具都将在*src*目录中查找该目录。
- en: '![image](assets/f0130-01.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0130-01.png)'
- en: When Go sees that the file inside the *hi* directory contains a `package main`
    declaration, it will know this is code for an executable program. It will compile
    an executable file, storing it in a directory named *bin* in the Go workspace.
    (The *bin* directory will be created automatically if it doesn’t already exist.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当Go看到*hi*目录中的文件包含`package main`声明时，它会知道这是一个可执行程序的代码。它将编译一个可执行文件，并将其存储在Go工作空间中名为*bin*的目录中。（如果该目录不存在，将自动创建*bin*目录。）
- en: Unlike the `go build` command, which names an executable after the *.go* file
    it’s based on, `go install` names an executable after the directory that contains
    the code. Since we compiled the contents of the *hi* directory, the executable
    will be named `hi` (or `hi.exe` on Windows).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与`go build`命令不同，后者将可执行文件命名为基于其所依据的.go文件。`go install`将可执行文件命名为包含代码的目录名称。由于我们编译了*hi*目录的内容，可执行文件将命名为`hi`（或在Windows上为`hi.exe`）。
- en: '![image](assets/f0130-02.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0130-02.png)'
- en: Now, you can use the `**cd**` command to change to the *bin* directory within
    your Go workspace. Once you’re in *bin*, you can run the executable by typing
    `**./hi**` (or `**hi.exe**` on Windows).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`**cd**`命令切换到Go工作空间中的*bin*目录。一旦在*bin*中，您可以通过键入`**./hi**`（或在Windows上为`**hi.exe**`）来运行可执行文件。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can also add your workspace’s “bin” directory to your system’s “PATH” environment
    variable. Then, you’ll be able to run executables in “bin” from anywhere on your
    system! Recent Go installers for Mac and Windows will update “PATH” for you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将工作空间的“bin”目录添加到系统的“PATH”环境变量中。然后，您就可以从系统的任何位置运行“bin”中的可执行文件！最近的Mac和Windows安装程序会自动为您更新“PATH”。
- en: Changing workspaces with the GOPATH environment variable
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GOPATH环境变量更改工作空间
- en: You may see developers on various websites talking about “setting your `GOPATH`”
    when discussing the Go workspace. `GOPATH` is an environment variable that Go
    tools consult to find the location of your workspace. Most Go developers keep
    all their code in a single workspace, and don’t change it from its default location.
    But if you want, you can use `GOPATH` to move your workspace to a different directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论Go工作空间时，您可能会看到各种网站上的开发者谈论“设置您的`GOPATH`”。`GOPATH`是Go工具用来查找工作空间位置的环境变量。大多数Go开发人员将所有代码保存在单个工作空间中，并且不更改其默认位置。但是，如果需要，您可以使用`GOPATH`将工作空间移动到其他目录。
- en: An **environment variable** lets you store and retrieve values, kind of like
    a Go variable, but it’s maintained by the operating system, not by Go. You can
    configure some programs by setting environment variables, and that includes the
    Go tool.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境变量**允许您存储和检索值，有点像Go变量，但由操作系统维护，而不是Go。通过设置环境变量，您可以配置一些程序，包括Go工具。'
- en: Suppose that, instead of in your home directory, you had set up your `greeting`
    package inside a directory named *code* in the root of your hard drive. And now
    you want to run your *main.go* file, which depends on `greeting`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，您不是在您的主目录中，而是在硬盘根目录下的*code*目录中设置了`greeting`包。现在，您想运行依赖于`greeting`的*main.go*文件。
- en: '![image](assets/f0131-01.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0131-01.png)'
- en: 'But you’re getting an error saying the `greeting` package can’t be found, because
    the `go` tool is still looking in the *go* directory in your home directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您收到的错误消息显示找不到`greeting`包，因为`go`工具仍在查找您主目录中的*go*目录：
- en: '![image](assets/f0131-02.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0131-02.png)'
- en: Setting GOPATH
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GOPATH
- en: If your code is stored in a directory other than the default, you’ll need to
    configure the `go` tool to look in the right place. You can do that by setting
    the `GOPATH` environment variable. How you’ll do that depends on your operating
    system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码存储在默认位置以外的目录中，则需要配置`go`工具以查找正确的位置。您可以通过设置`GOPATH`环境变量来实现这一点。如何设置取决于您的操作系统。
- en: 'On Mac or Linux systems:'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Mac或Linux系统中：
- en: 'You can use the `export` command to set the environment variable. At a terminal
    prompt, type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`export`命令设置环境变量。在终端提示符下输入：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For a directory named *code* in the root of your hard drive, you’ll want to
    use a path of “`/code`”. You can substitute a different path if your code is in
    a different location.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于硬盘根目录中名为*code*的目录，您将需要使用路径“`/code`”。如果代码位于其他位置，可以替换不同的路径。
- en: 'On Windows systems:'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows系统中：
- en: 'You can use the `set` command to set the environment variable. At a command
    prompt, type:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`set`命令设置环境变量。在命令提示符下输入：
- en: '[PRE2]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For a directory named *code* in the root of your hard drive, you’ll want to
    use a path of “`C:\code`”. You can substitute a different path if your code is
    in a different location.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于硬盘根目录中名为*code*的目录，您将需要使用路径“`C:\code`”。如果代码位于其他位置，可以替换不同的路径。
- en: Once that’s done, `go run` should immediately begin using the directory you
    specified as its workspace (as should other Go tools). That means the `greeting`
    library will be found, and the program will run!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`go run`应立即开始使用您指定的工作区目录（其他Go工具也是如此）。这意味着会找到`greeting`库，并且程序会运行！
- en: '![image](assets/f0132-01.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0132-01.png)'
- en: Note that the methods above will only set `GOPATH` for the *current* terminal/command
    prompt window. You’ll need to set it again for each new window you open. But there
    are ways to set an environment variable permanently, if you want. The methods
    differ for each operating system, so we don’t have space to go into them here.
    If you type “environment variables” followed by the name of your OS into your
    favorite search engine, the results should include helpful instructions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述方法仅为*当前*终端/命令提示符窗口设置`GOPATH`。每次打开新窗口都需要重新设置。但是，如果需要，可以永久设置环境变量。对于每个操作系统，设置方法不同，我们无法在此处详细介绍。如果您在喜欢的搜索引擎中输入“环境变量”后跟上您的操作系统名称，结果应包含有用的说明。
- en: Publishing packages
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布包
- en: We’re getting so much use out of our `keyboard` package, we wonder if others
    might find it useful, too.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的`keyboard`包使用得如此频繁，我们想知道其他人是否也会觉得它有用。
- en: '![image](assets/f0133-01.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0133-01.png)'
- en: 'Let’s create a repository to hold our code on GitHub, a popular code sharing
    website. That way, other developers can download it and use it in their own projects!
    Our GitHub username is `headfirstgo`, and we’ll name the repository *keyboard*,
    so its URL will be:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在GitHub上创建一个仓库来保存我们的代码，这是一个流行的代码共享网站。这样，其他开发者可以下载并在他们自己的项目中使用它！我们的GitHub用户名是`headfirstgo`，我们将仓库命名为*keyboard*，因此它的URL将是：
- en: '*[https://github.com/headfirstgo/keyboard](https://github.com/headfirstgo/keyboard)*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*[https://github.com/headfirstgo/keyboard](https://github.com/headfirstgo/keyboard)*'
- en: We’ll upload just the *keyboard.go* file to the repository, without nesting
    it inside any directories.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅上传*keyboard.go*文件到仓库，而不将其嵌套在任何目录中。
- en: '![image](assets/f0133-02.png)![image](assets/f0134-01.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0133-02.png)![图片](assets/f0134-01.png)'
- en: Hmm, that’s a valid concern. There can only be one *keyboard* directory in the
    Go workspace’s *src* directory, and so it *looks* like we can only have one package
    named `keyboard`!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这是一个合理的担忧。在Go工作空间的*src*目录中只能有一个名为*keyboard*的目录，因此看起来我们只能有一个名为`keyboard`的包！
- en: '![image](assets/f0134-02.png)![image](assets/f0135-01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0134-02.png)![图片](assets/f0135-01.png)'
- en: 'Let’s try that: we’ll move our package into a directory structure that represents
    the URL where it’s hosted. Inside our *src* directory, we’ll create another directory
    named *[github.com](http://github.com)*. Inside that, we’ll create a directory
    named after the next segment of the URL, *headfirstgo*. And then we’ll move our
    *keyboard* package directory from the *src* directory into the *headfirstgo* directory.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧：我们将把我们的包移动到一个代表它托管的URL的目录结构中。在我们的*src*目录中，我们将创建另一个名为*[github.com](http://github.com)*的目录。在其中，我们将创建一个名为*headfirstgo*的目录。然后，我们将从*src*目录中将我们的*keyboard*包目录移动到*headfirstgo*目录中。
- en: Although moving the package into a new subdirectory will change its *import
    path*, it won’t change the package *name*. And since the package itself only contains
    references to the name, we don’t have to make any changes to the package code!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将包移动到新的子目录中会更改其*导入路径*，但不会更改包*名称*。由于包本身仅包含名称的引用，因此我们不必对包代码进行任何更改！
- en: '![image](assets/f0135-02.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0135-02.png)'
- en: 'We *will* need to update the programs that rely on our package, though, because
    the package import path has changed. Because we named each subdirectory after
    part of the URL where the package is hosted, our new import path looks a lot like
    that URL:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要更新依赖于我们包的程序，因为包导入路径已更改。因为我们将每个子目录命名为包托管URL的一部分，所以我们的新导入路径看起来很像那个URL：
- en: '[PRE3]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We only need to update the `import` statement in each program. Because the package
    name is the same, references to the package in the rest of the code will be unchanged.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要更新每个程序中的`import`语句。因为包名相同，代码中对包的引用将保持不变。
- en: '![image](assets/f0136-01.png)![image](assets/f0136-02.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0136-01.png)![图片](assets/f0136-02.png)'
- en: With those changes made, all the programs that rely on our `keyboard` package
    should resume working normally.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，依赖于我们的`keyboard`包的所有程序应该正常工作。
- en: By the way, we wish we could take credit for this idea of using domain names
    and paths to ensure a package import path is unique, but we didn’t really come
    up with it. The Go community has been using this as a package naming standard
    from the beginning. And similar ideas have been used in languages like Java for
    decades now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们希望能够因为使用域名和路径来确保包导入路径的唯一性而得到这个想法的荣誉，但实际上并不是我们想出来的。从一开始，Go社区就一直在使用这种包命名标准。类似的思想在像Java这样的语言中已经使用了几十年了。
- en: Downloading and installing packages with “go get”
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“go get”下载和安装包
- en: Using a package’s hosting URL as an import path has another benefit. The `go`
    tool has another subcommand named `go get` that can automatically download and
    install packages for you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包的托管URL作为导入路径还有另一个好处。`go`工具还有一个名为`go get`的子命令，可以自动为您下载和安装包。
- en: 'We’ve set up a Git repository with the `greeting` package that we showed you
    previously at this URL:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个包含我们之前在以下URL中展示给您的*greeting*包的Git仓库
- en: '*[https://github.com/headfirstgo/greeting](https://github.com/headfirstgo/greeting)*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*[https://github.com/headfirstgo/greeting](https://github.com/headfirstgo/greeting)*'
- en: 'That means that from any computer with Go installed, you can type this in a
    terminal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只要安装了Go的任何计算机，您都可以在终端中输入以下命令：
- en: '`go get github.com/headfirstgo/greeting`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get github.com/headfirstgo/greeting`'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '(Note: “go get” still may not be able to find Git after it’s installed. If
    this happens, try closing your old terminal or command prompt window and opening
    a new one.)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: （注意：“go get”安装后仍然可能无法找到 Git。如果出现这种情况，请尝试关闭旧的终端或命令提示符窗口，然后打开一个新的。）
- en: 'That’s `go get` followed by the repository URL, but with the “scheme” portion
    (the “https://”) left off. The `go` tool will connect to *[github.com](http://github.com)*,
    download the Git repository at the */headfirstgo/greeting* path, and save it in
    your Go workspace’s *src* directory. (Note: if your system doesn’t have Git installed,
    you’ll be prompted to install it when you run the `go get` command. Just follow
    the instructions on your screen. The `go get` command can also work with Subversion,
    Mercurial, and Bazaar repositories.)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `go get` 后跟着的存储库 URL，但是省略了 “scheme” 部分（即 “https://”）。 `go` 工具将连接到 *[github.com](http://github.com)*，下载
    */headfirstgo/greeting* 路径下的 Git 存储库，并将其保存在你的 Go 工作空间的 *src* 目录中。（注意：如果你的系统没有安装
    Git，则在运行 `go get` 命令时会提示你安装它。只需按照屏幕上的指示操作。 `go get` 命令还可以与 Subversion、Mercurial
    和 Bazaar 存储库一起使用。）
- en: 'The `go get` command will automatically create whatever subdirectories are
    needed to set up the appropriate import path (a *[github.com](http://github.com)*
    directory, a *headfirstgo* directory, etc.). The packages saved in the *src* directory
    will look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get` 命令将自动创建所需的子目录来设置适当的导入路径（如 *github.com* 目录，*headfirstgo* 目录等）。保存在 *src*
    目录中的包将如下所示：'
- en: '![image](assets/f0137-01.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0137-01.png)'
- en: 'With the packages saved in the Go workspace, they’re ready for use in programs.
    You can use the `greeting`, `dansk`, and `deutsch` packages in a program with
    an `import` statement like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有了保存在 Go 工作空间中的包，它们就可以在程序中使用了。你可以通过像这样的 `import` 语句来使用 `greeting`、`dansk` 和
    `deutsch` 包：
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `go get` command works for other packages, too. If you don’t already have
    the `keyboard` package we showed you previously, this command will install it:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get` 命令也适用于其他包。如果你之前没有我们展示过的 `keyboard` 包，这个命令会帮你安装它：'
- en: '`go get github.com/headfirstgo/keyboard`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`go get github.com/headfirstgo/keyboard`'
- en: In fact, the `go get` command works for any package that has been set up properly
    on a hosting service, no matter who the author is. All you’ll need to do is run
    `go get` and give it the package import path. The tool will look at the part of
    the path that corresponds to the host address, connect to that host, and download
    the package at the URL represented by the rest of the import path. It makes using
    other developers’ code really easy!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`go get` 命令适用于任何已经在托管服务上正确设置的包，无论作者是谁。你只需要运行 `go get` 并提供包的导入路径即可。该工具将查看路径中对应于主机地址的部分，连接到该主机，并下载由其余导入路径表示的
    URL 处的包。这使得使用其他开发者的代码变得非常简单！
- en: Reading package documentation with “go doc”
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 “go doc” 阅读包文档
- en: '![image](assets/f0139-01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0139-01.png)'
- en: '**You can use the `**go doc**` command to display documentation on any package
    or function.**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**你可以使用 `**go doc**` 命令来显示任何包或函数的文档。**'
- en: You can get a documentation for a package by passing its import path to `go
    doc`. For example, we can get info on the `strconv` package by running `go doc
    strconv`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其导入路径传递给 `go doc`，你可以获取包的文档。例如，我们可以通过运行 `go doc strconv` 来获取 `strconv` 包的信息。
- en: '![image](assets/f0139-02.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0139-02.png)'
- en: The output includes the package name and import path (which are one and the
    same in this case), a description of the package as a whole, and a list of all
    the functions the package exports.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括包名和导入路径（在这种情况下它们是一样的），包的整体描述，以及包导出的所有函数列表。
- en: You can also use `go doc` to get detailed info on specific functions by providing
    a function name following the package name. Suppose we saw the `ParseFloat` function
    in the list of the `strconv` package’s functions and we wanted to know more about
    it. We could bring up its documentation with `go doc strconv ParseFloat`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `go doc` 通过在包名后面提供函数名来获取特定函数的详细信息。假设我们在 `strconv` 包的函数列表中看到了 `ParseFloat`
    函数，并且想要了解更多信息。我们可以使用 `go doc strconv ParseFloat` 来查看它的文档。
- en: 'You’ll get back a description of the function and what it does:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会得到该函数的描述和它的功能：
- en: '![image](assets/f0140-01.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0140-01.png)'
- en: The first line looks just like a function declaration would look in code. It
    includes the function name, followed by parentheses containing the names and types
    of the parameters it takes (if any). If there are any return values, those will
    appear after the parameters.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行看起来就像代码中的函数声明。它包括函数名称，后面跟着包含其参数名称和类型（如果有的话）的括号。如果有返回值，那些将出现在参数后面。
- en: This is followed by a detailed description of what the function does, along
    with any other information developers need in order to use it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是详细描述函数做什么以及开发人员在使用它时需要的其他信息。
- en: 'We can get documentation for our `keyboard` package in the same way, by providing
    its import path to `go doc`. Let’s see if there’s anything there that will help
    our would-be user. From a terminal, run:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其导入路径提供给`go doc`，以相同的方式获取我们`keyboard`包的文档。让我们看看是否有任何内容能帮助我们潜在的用户。从终端运行：
- en: '[PRE5]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `go doc` tool is able to derive basic information like the package name
    and import path from the code. But there’s no package description, so it’s not
    that helpful.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`go doc`工具能够从代码中推导出基本信息，如包名和导入路径。但是由于没有包描述，因此这并不那么有帮助。'
- en: '![image](assets/f0140-02.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0140-02.png)'
- en: 'Requesting info on the `GetFloat` function doesn’t get us a description either:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请求`GetFloat`函数的信息也得不到描述：
- en: '![image](assets/f0140-03.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0140-03.png)'
- en: Documenting your packages with doc comments
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文档注释为您的包文档
- en: The `go doc` tool works hard to add useful info to its output based on examining
    the code. Package names and import paths are added for you. So are function names,
    parameters, and return types.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`go doc`工具会根据检查代码添加有用的信息到其输出中。包名和导入路径将被自动添加。函数名称、参数和返回类型也是如此。'
- en: But `go doc` isn’t magic. If you want your users to see documentation of a package
    or function’s intent, you’ll need to add it yourself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`go doc`并非魔法。如果您希望用户看到包或函数意图的文档，您需要自己添加。
- en: 'Fortunately, that’s easy to do: you simply add **doc comments** to your code.
    Ordinary Go comments that appear immediately before a package clause or function
    declaration are treated as doc comments, and will be displayed in `go doc`’s output.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这很容易做到：你只需在你的代码之前立即添加**文档注释**。出现在包声明或函数声明之前的普通Go注释将被视为文档注释，并将显示在`go doc`的输出中。
- en: Let’s try adding doc comments for the `keyboard` package. At the top of the
    *keyboard.go* file, immediately before the `package` line, we’ll add a comment
    describing what the package does. And immediately before the declaration of `GetFloat`,
    we’ll add a couple comment lines describing that function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为`keyboard`包添加文档注释。在*keyboard.go*文件的顶部，在`package`行之前，我们将添加一个注释描述该包的功能。在`GetFloat`声明之前，我们将添加几行注释描述该函数。
- en: '![image](assets/f0141-01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0141-01.png)'
- en: The next time we run `go doc` for the package, it will find the comment before
    the `package` line and convert it to a package description. And when we run `go
    doc` for the `GetFloat` function, we’ll see a description based on the comment
    lines we added above `GetFloat`’s declaration.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们为包运行`go doc`时，它将找到`package`行前的注释并将其转换为包描述。当我们为`GetFloat`函数运行`go doc`时，我们将看到基于我们在`GetFloat`声明之前添加的注释行的描述。
- en: '![image](assets/f0141-02.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0141-02.png)'
- en: Being able to display documentation via `go doc` makes developers that install
    a package happy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 能够通过`go doc`显示文档使安装包的开发人员感到高兴。
- en: '![image](assets/f0142-01.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0142-01.png)'
- en: And doc comments make developers who work on a package’s code happy, too! They’re
    ordinary comments, so they’re easy to add. And you can easily refer to them while
    making changes to the code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释还能让开发人员在处理包代码时感到愉快！它们是普通的注释，所以很容易添加。您可以在修改代码时轻松地参考它们。
- en: '![image](assets/f0142-02.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0142-02.png)'
- en: 'There are a few conventions to follow when adding doc comments:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文档注释时有一些约定要遵循：
- en: Comments should be complete sentences.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应该是完整的句子。
- en: 'Package comments should begin with “Package” followed by the package name:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包注释应以“Package”开头，后跟包名称：
- en: '[PRE6]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Function comments should begin with the name of the function they describe:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数注释应以它们描述的函数名称开头：
- en: '[PRE7]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can include code examples in your comments by indenting them.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过将其缩进来包含代码示例在你的评论中。
- en: Other than indentation for code samples, don’t add extra punctuation characters
    for emphasis or formatting. Doc comments will be displayed as plain text, and
    should be formatted that way.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了代码示例的缩进外，不要添加额外的标点符号用于强调或格式化。文档注释将显示为普通文本，并且应以此方式格式化。
- en: Viewing documentation in a web browser
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网页浏览器中查看文档
- en: If you’re more comfortable in a web browser than a terminal, there are other
    ways to view package documentation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在网页浏览器而不是终端中查看文档，还有其他查看包文档的方法。
- en: 'The simplest is to type the word “golang” followed by the name of the package
    you want into your favorite search engine. (“Golang” is commonly used for web
    searches regarding the Go language because “go” is too common a word to be useful
    for filtering out irrelevant results.) If we wanted documentation for the `fmt`
    package, we could search for “golang fmt”:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在你喜欢的搜索引擎中键入“golang”后跟你想要的包名称。（“Golang”通常用于搜索有关 Go 语言的内容，因为“go”是一个太普通的词，无法过滤掉无关的结果。）如果我们想要`fmt`包的文档，我们可以搜索“golang
    fmt”：
- en: '![image](assets/f0143-01.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0143-01.png)'
- en: The results should include sites that offer Go documentation in HTML format.
    If you’re searching for a package in the Go standard library (like `fmt`), one
    of the top results will probably be from *[golang.org](http://golang.org)*, a
    site run by the Go development team. The documentation will have much the same
    contents as the output of the `go doc` tool, with package names, import paths,
    and descriptions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该包含以 HTML 格式提供 Go 文档的站点。如果你搜索 Go 标准库中的一个包（比如`fmt`），顶部结果之一可能来自* golang.org*，这是由
    Go 开发团队运行的站点。文档的内容将与`go doc`工具的输出基本相同，包括包名称、导入路径和描述。
- en: '![image](assets/f0143-02.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0143-02.png)'
- en: One major advantage of the HTML documentation is that each function name in
    the list of the package’s functions will be a handy clickable link leading to
    the function documentation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 文档的一个主要优势是包的函数列表中的每个函数名都是一个方便的可点击链接，可以直接跳转到函数文档。
- en: '![image](assets/f0143-03.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0143-03.png)'
- en: But the content is just the same as what you’d see when running `go doc` in
    your terminal. It’s all based on the same simple doc comments in the code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但内容与在终端中运行`go doc`看到的内容完全相同。一切都基于代码中相同简单的文档注释。
- en: Serving HTML documentation to yourself with “godoc”
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“godoc”将 HTML 文档提供给自己
- en: The same software that powers the *[golang.org](http://golang.org)* site’s documentation
    section is actually available on *your* computer, too. It’s a tool called `godoc`
    (not to be confused with the `go doc` command), and it’s automatically installed
    along with Go. The `godoc` tool generates HTML documentation based on the code
    in your main Go installation and your workspace. It includes a web server that
    can share the resulting pages with browsers. (Don’t worry, with its default settings
    `godoc` won’t accept connections from any computer other than your own.)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*golang.org* 网站文档部分使用的是相同的软件，实际上也可以在*你的*计算机上使用。这个工具叫做`godoc`（不要与`go doc`命令混淆），它会随着
    Go 的安装自动安装。`godoc` 工具基于你的主 Go 安装和工作区中的代码生成 HTML 文档，包含一个可以与浏览器共享生成页面的 Web 服务器。（别担心，默认设置下，`godoc`
    不会接受来自除你自己之外的任何计算机的连接。）'
- en: '![image](assets/f0144-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0144-01.png)'
- en: 'To run `godoc` in web server mode, we’ll type the `godoc` command (again, don’t
    confuse that with `go doc`) in a terminal, followed by a special option: `-http=:6060`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Web 服务器模式下运行`godoc`，我们将在终端中输入`godoc`命令（再次强调，不要与`go doc`混淆），然后加上一个特殊选项：`-http=:6060`。
- en: 'Then with `godoc` running, you can type the URL:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`godoc`运行时，你可以在浏览器中输入 URL：
- en: '[PRE8]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '...into your web browser’s address bar and press Enter. Your browser will connect
    to your own computer, and the `godoc` server will respond with an HTML page. You’ll
    be presented with a list of all the packages installed on your machine.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '...输入到你的网页浏览器地址栏中并按 Enter 键。你的浏览器将连接到你自己的计算机，`godoc`服务器将以 HTML 页面响应。你将看到安装在你计算机上的所有包的列表。'
- en: '![image](assets/f0144-02.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0144-02.png)'
- en: Each package name in the list is a link to that package’s documentation. Click
    it, and you’ll see the same package docs that you’d see on *[golang.org](http://golang.org)*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个包名称都是指向该包文档的链接。点击它，你会看到与在* golang.org* 上看到的相同的包文档。
- en: '![image](assets/f0144-03.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/f0144-03.png)'
- en: The “godoc” server includes YOUR packages!
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “godoc”服务器包含*你的*包！
- en: 'If we scroll further through our local `godoc` server’s list of packages, we’ll
    see something interesting: our `keyboard` package!'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续浏览本地`godoc`服务器的包列表，我们会看到一些有趣的内容：我们的`keyboard`包！
- en: '![image](assets/f0145-01.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0145-01.png)'
- en: In addition to packages from Go’s standard library, the `godoc` tool also builds
    HTML documentation for any packages in your Go workspace. These could be third-party
    packages you’ve installed, or packages you’ve written yourself.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除了来自Go标准库的包之外，`godoc`工具还为你的Go工作区中的任何包构建HTML文档。这些可以是你安装的第三方包，也可以是你自己编写的包。
- en: Click the *keyboard* link, and you’ll be taken to the package’s documentation.
    The docs will include any doc comments from our code!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*keyboard*链接，你将进入包的文档页面。文档中将包含我们代码中的任何文档注释！
- en: '![image](assets/f0145-02.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0145-02.png)'
- en: When you’re ready to stop the `godoc` server, return to your terminal window,
    then hold the Ctrl key and press C. You’ll be returned to your system prompt.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备停止`godoc`服务器时，回到你的终端窗口，然后按住Ctrl键并按C键。你会回到系统提示符。
- en: '![image](assets/f0145-03.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0145-03.png)'
- en: Go makes it easy to document your packages, which makes packages easier to share,
    which in turn makes them easier for other developers to use. It’s just one more
    feature that makes packages a great way to share code!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Go使得文档化你的包变得简单，这使得包更容易分享，进而使其他开发者更容易使用。这只是使包成为代码共享的一个更好方式的又一特性！
- en: Your Go Toolbox
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的Go工具箱
- en: '![image](assets/f0074-01.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0074-01.png)'
- en: '**That’s it for [Chapter 4](#bundles_of_codecolon_packages)! You’ve added packages
    to your toolbox.**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是[第四章](#bundles_of_codecolon_packages)的内容！你已经向你的工具箱添加了包。**'
- en: '![image](assets/f0146-02.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0146-02.png)'
- en: Pool Puzzle Solution
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解答
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines. **Don’t** use the same snippet more than once, and you won’t need
    to use all the snippets. Your **goal** is to set up a `calc` package within a
    Go workspace so `calc’`s functions can be used within *main.go*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从池中获取代码片段，并将它们放入空白行中。**不要**重复使用同一个片段，并且你不需要使用所有的片段。你的**目标**是在Go工作区内设置一个`calc`包，以便在*main.go*中使用`calc`的函数。
- en: '![image](assets/f0147-01.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/f0147-01.png)'
