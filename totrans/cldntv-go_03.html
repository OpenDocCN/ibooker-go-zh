<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Why Go Rules the Cloud Native World"><div class="chapter" id="chapter_2">&#13;
<h1><span class="label">Chapter 2. </span>Why Go Rules the Cloud Native World</h1>&#13;
&#13;
<blockquote>&#13;
<p>Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius—and a lot of courage—to move in the opposite direction.<sup><a data-type="noteref" id="idm45983645071000-marker" href="ch02.xhtml#idm45983645071000">1</a></sup></p>&#13;
<p data-type="attribution">E.F. Schumacher, <cite>Small Is Beautiful (August 1973)</cite></p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="The Motivation Behind Go"><div class="sect1" id="idm45983645068712">&#13;
<h1>The Motivation Behind Go</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="design of" id="ch02_term1"/><a data-type="indexterm" data-primary="Google" id="idm45983651868536"/>The idea of Go emerged in September of 2007 at Google, the inevitable outcome of putting a bunch of smart people in a room and frustrating the heck out of them.</p>&#13;
&#13;
<p>The people in question were Robert Griesemer, Rob Pike, and Ken Thompson; all already highly regarded for their individual work in designing other languages. The source of their collective ire was nothing less than the entire set of programming languages that were available at the time, which they were finding just weren’t well-suited to the task of describing the kinds of distributed, scalable, resilient services that Google was building.<sup><a data-type="noteref" id="idm45983651866712-marker" href="ch02.xhtml#idm45983651866712">2</a></sup></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="programming languages" id="idm45983651865896"/>Essentially, the common languages of the day had been developed in a different era, one before multiple processors were commonplace, and networks were quite so &#13;
<span class="keep-together">ubiquitous</span>. Their support for multicore processing and networking—essential building blocks of modern “cloud native” services<sup><a data-type="noteref" id="idm45983651864088-marker" href="ch02.xhtml#idm45983651864088">3</a></sup>—was often limited or required extraordinary efforts to utilize. Simply put, programming languages weren’t keeping up with the needs of modern software development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Features for a Cloud Native World"><div class="sect1" id="idm45983651862824">&#13;
<h1>Features for a Cloud Native World</h1>&#13;
&#13;
<p>Their frustrations were many, but all of them amounted to one thing: the undue complexity of the languages they were working with was making it harder to build server software. These included, but weren’t limited to:<sup><a data-type="noteref" id="idm45983651860872-marker" href="ch02.xhtml#idm45983651860872">4</a></sup></p>&#13;
<dl>&#13;
<dt>Low program comprehensibility</dt>&#13;
<dd>&#13;
<p>Code had become too hard to read. Unnecessary bookkeeping and repetition was compounded by functionally overlapping features that often encouraged cleverness over clarity.</p>&#13;
</dd>&#13;
<dt>Slow builds</dt>&#13;
<dd>&#13;
<p>Language construction and years of feature creep resulted in build times that ran for minutes or hours, even on large build clusters.</p>&#13;
</dd>&#13;
<dt>Inefficiency</dt>&#13;
<dd>&#13;
<p>Many programmers responded to the aforementioned problems by adopting more fluid, dynamic languages, effectively trading efficiency and type safety for expressiveness.</p>&#13;
</dd>&#13;
<dt>High cost of updates</dt>&#13;
<dd>&#13;
<p>Incompatibilities between even minor versions of a language, as well as any dependencies it may have (and its transitive dependencies!) often made updating an exercise in frustration.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Over the years, multiple—often quite clever—solutions have been presented to address some of these issues in various ways, usually introducing additional complexity in the process. Clearly, they couldn’t be fixed with a new API or language feature. So, Go’s designers envisioned a modern language, the first language built for the cloud native era, supporting modern networked and multicore computing, expressive yet comprehensible, and allowing its users to focus on solving their problems instead of struggling with their language.<a data-type="indexterm" data-primary="programming languages" id="idm45983651851656"/></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go language" data-see="Go" id="idm45983651850696"/>The result, the Go language, is notable as much for the features it explicitly <em>doesn’t have</em> as it is for the ones it does. Some of those features (and nonfeatures) and the motivation behind them are discussed in the following sections.<a data-type="indexterm" data-primary="Go" data-secondary="design of" data-startref="ch02_term1" id="idm45983651849048"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Composition and Structural Typing"><div class="sect2" id="idm45983651847672">&#13;
<h2>Composition and Structural Typing</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Java" id="ch02_term5"/><a data-type="indexterm" data-primary="object-oriented programming" id="ch02_term3"/>Object-oriented programming, which is based on the concept of “objects” of various “types” possessing various attributes, has existed since the 1960s, but it truly came into vogue in the early to mid-1990s with the release of Java and the addition of object-oriented features to C++. Since then, it has emerged as the dominant programming paradigm, and remains so even today.</p>&#13;
&#13;
<p>The promise of object-oriented programming is seductive, and the theory behind it even makes a certain kind of intuitive sense. Data and behaviors can be associated with <em>types</em> of things, which can be inherited by <em>subtypes</em> of those things. <em>Instances</em> of those types can be conceptualized as tangible objects with properties and behaviors—components of a larger system modeling concrete, real-world concepts.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="inheritance" id="ch02_term8"/>In practice however, objected-oriented programming using inheritance often requires that relationships between types be carefully considered and painstakingly designed, and that particular design patterns and practices be faithfully observed. As such, as illustrated in <a data-type="xref" href="#img_ch02_inheritance">Figure 2-1</a>, the tendency in object-oriented programming is for the focus to shift away from developing algorithms, and towards developing and maintaining taxonomies and ontologies.<a data-type="indexterm" data-primary="object-oriented programming" data-startref="ch02_term3" id="idm45983651838920"/></p>&#13;
&#13;
<figure><div id="img_ch02_inheritance" class="figure">&#13;
<img src="Images/cngo_0201.png" alt="cngo 0201" width="1443" height="1060"/>&#13;
<h6><span class="label">Figure 2-1. </span>Over time, objected-oriented programming trends towards taxonomy</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="indexterm" data-primary="types" data-secondary="structs" id="idm45983651835688"/><a data-type="indexterm" data-primary="structs" id="idm45983651834552"/><a data-type="indexterm" data-primary="Go" data-secondary="features of" id="ch02_term4"/>That’s not to say that Go doesn’t have object-oriented features that allow polymorphic behavior and code reuse. It, too, has a type-like concept in the form of <em>structs</em>, which can have properties and behaviors. What it rejects is inheritance and the elaborate relationships that come with it, opting instead to assemble more complex types by <em>embedding</em> simpler ones within them: an approach known as <em>composition</em>.<a data-type="indexterm" data-primary="composition" id="idm45983651612264"/></p>&#13;
&#13;
<p>Specifically, where inheritance revolves around extending “is a” relationships between classes (i.e., a car “is a” motored vehicle), composition allows types to be constructed using “has a” relationships to define what they can do (i.e., a car “has a” motor). In practice, this permits greater design flexibility while allowing the creation of business domains that are less susceptible to disruption by the quirks of “family members.”<a data-type="indexterm" data-primary="inheritance" data-startref="ch02_term8" id="idm45983651610808"/></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="features of" data-startref="ch02_term4" id="idm45983651609576"/>By extension, while Go uses interfaces to describe behavioral contracts, it has no &#13;
<span class="keep-together">“is a”</span> concept, so equivalency is determined by inspecting a type’s definition, not its lineage. For example, given a <code>Shape</code> interface that defines an <code>Area</code> method, any type with an <code>Area</code> method will implicitly satisfy the <code>Shape</code> interface, without having to explicitly declare itself as a <code>Shape</code>:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="go"><code class="kd">type</code> <code class="nx">Shape</code> <code class="kd">interface</code> <code class="p">{</code>                  <code class="c1">// Any Shape must have an Area</code>&#13;
    <code class="nx">Area</code><code class="p">()</code> <code class="kt">float64</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">Rectangle</code> <code class="kd">struct</code> <code class="p">{</code>                 <code class="c1">// Rectangle doesn't explicitly</code>&#13;
    <code class="nx">width</code><code class="p">,</code> <code class="nx">height</code> <code class="kt">float64</code>               <code class="c1">// declare itself to be a Shape</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">Rectangle</code> <code class="nx">r</code><code class="p">)</code> <code class="nx">Area</code><code class="p">()</code> <code class="kt">float64</code> <code class="p">{</code>     <code class="c1">// Rectangle has an Area method; it</code>&#13;
    <code class="k">return</code> <code class="nx">r</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">r</code><code class="p">.</code><code class="nx">height</code>           <code class="c1">// satisfies the Shape interface</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="indexterm" data-primary="structural typing mechanism" id="idm45983650499944"/>This <em>structural typing</em> mechanism, which has been described as <em>duck typing</em><sup><a data-type="noteref" id="idm45983645616360-marker" href="ch02.xhtml#idm45983645616360">5</a></sup> at compile time, largely sheds the burdensome maintenance of tedious taxonomies that &#13;
<span class="keep-together">saddle</span> more traditional object-oriented languages like Java and C++, freeing programmers to focus on data structures and algorithms.<a data-type="indexterm" data-primary="Java" data-startref="ch02_term5" id="idm45983651790600"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Comprehensibility"><div class="sect2" id="idm45983651847208">&#13;
<h2>Comprehensibility</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="comprehensibility" id="ch02_term9"/>Service languages like C++ and Java are often criticized for being clumsy, awkward to use, and unnecessarily verbose. They require lots of repetition and careful bookkeeping, saddling projects with superfluous boilerplate that gets in the way of programmers who have to divert their attention to things other than the problem they’re trying to solve, and limiting projects’ scalability under the weight of all the resulting complexity.</p>&#13;
&#13;
<p class="pagebreak-before"><a data-type="indexterm" data-primary="Go" data-secondary="design of" id="idm45983647762632"/>Go was designed with large projects with lots of contributors in mind. Its minimalist design (just 25 keywords and 1 loop type), and the strong opinions of its compiler, strongly favor clarity over cleverness.<sup><a data-type="noteref" id="idm45983651382280-marker" href="ch02.xhtml#idm45983651382280">6</a></sup> This in turn encourages simplicity and &#13;
<span class="keep-together">productivity</span> over clutter and complexity. The resulting code is relatively easy to ingest, review, and maintain, and harbors far fewer “gotchas.”<a data-type="indexterm" data-primary="comprehensibility" data-startref="ch02_term9" id="idm45983647899384"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="CSP-Style Concurrency"><div class="sect2" id="idm45983651422584">&#13;
<h2>CSP-Style Concurrency</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="CSP-style" id="idm45983651384664"/>Most mainstream languages provide some means of running multiple processes concurrently, allowing a program to be composed of independently executed processes. Used correctly, concurrency can be incredibly useful, but it also introduces a number of challenges, particularly around ordering events, communication between processes, and coordination of access to shared resources.</p>&#13;
&#13;
<p>Traditionally, a programmer will confront these challenges by allowing processes to share some piece of memory, which is then wrapped in locks or mutexes to restrict access to one process at a time. But even when well-implemented, this strategy can generate a fair amount of bookkeeping overhead. It’s also easy to forget to lock or unlock shared memory, potentially introducing race conditions, deadlocks, or concurrent modifications. This class of errors can be fiendishly difficult to debug.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="features of" id="idm45983647641480"/><a data-type="indexterm" data-primary="Communicating Sequential Processes" data-see="CSP" id="idm45983647635272"/><a data-type="indexterm" data-primary="CSP" id="idm45983647634360"/><a data-type="indexterm" data-primary="Hoare, Tony" id="idm45983647633688"/>Go, on the other hand, favors another strategy, based on a formal language called Communicating Sequential Processes (CSP), first described in Tony Hoare’s influential paper of the same name<sup><a data-type="noteref" id="idm45983647612392-marker" href="ch02.xhtml#idm45983647612392">7</a></sup> that describes patterns of interaction in concurrent systems in terms of message passing via channels.</p>&#13;
&#13;
<p>The resulting concurrency model, implemented in Go with language primitives like <code>goroutines</code> and <code>channels</code>, makes Go uniquely<sup><a data-type="noteref" id="idm45983651600136-marker" href="ch02.xhtml#idm45983651600136">8</a></sup> capable of elegantly structuring concurrent software without depending entirely on locking. It encourages developers to limit sharing memory, and to instead allow processes to interact with one another <em>entirely</em> by passing messages. This idea is often summarized by the Go proverb:</p>&#13;
<blockquote>&#13;
<p>Do not communicate by sharing memory. Instead, share memory by communicating.<a data-type="indexterm" data-primary="Go" data-secondary="proverbs" id="idm45983649855912"/></p>&#13;
<p data-type="attribution">Go Proverb</p>&#13;
</blockquote>&#13;
<aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before"><div class="sidebar" id="idm45983649854024">&#13;
<h5>Concurrency Is Not Parallelism</h5>&#13;
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="computational" id="idm45983651596232"/><a data-type="indexterm" data-primary="parallelism" id="idm45983651595256"/>Computational concurrency and parallelism are often confused, which is understandable given that both concepts describe the state of having multiple processes executing during the same period of time. However, they are most definitely not the same thing:<sup><a data-type="noteref" id="idm45983651594184-marker" href="ch02.xhtml#idm45983651594184">9</a></sup></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Parallelism</em> describes the simultaneous execution of multiple independent processes.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Concurrency</em> describes the composition of independently executing processes; it says nothing about when processes will execute.</p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Fast Builds"><div class="sect2" id="idm45983647608360">&#13;
<h2>Fast Builds</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go" data-secondary="design of" id="ch02_term11"/><a data-type="indexterm" data-primary="Google" id="idm45983647605832"/>One of the primary motivations for the Go language was the maddeningly long build times for certain languages of the time,<sup><a data-type="noteref" id="idm45983647604888-marker" href="ch02.xhtml#idm45983647604888">10</a></sup> which even on Google’s large compilation clusters often require minutes, or even hours, to complete. This eats away at development time and grinds down developer productivity. Given Go’s primary purpose of enhancing rather than hindering developer productivity, long build times had to go.</p>&#13;
&#13;
<p>The specifics of the Go compiler are beyond the scope of this book (and beyond my own expertise). Briefly, however, the Go language was designed to provide a model of software construction free of complex relationships, greatly simplifying dependency analysis and eliminating the need for C-style include files and libraries and the overhead that comes with them. As a result, most Go builds complete in seconds, or occasionally minutes, even on relatively humble hardware. For example, building all 1.8 million lines<sup><a data-type="noteref" id="idm45983647603016-marker" href="ch02.xhtml#idm45983647603016">11</a></sup> of Go in Kubernetes v1.20.2 on a MacBook Pro with a 2.4 GHz 8-Core Intel i9 processor and 32 GB of RAM required about 45 seconds of real time:</p>&#13;
&#13;
<pre data-type="programlisting">mtitmus:~/workspace/kubernetes[MASTER]$ time make&#13;
&#13;
real    0m45.309s&#13;
user    1m39.609s&#13;
sys     0m43.559s</pre>&#13;
&#13;
<p>Not that this doesn’t come without compromises. Any proposed change to the Go language is weighed in part against its likely effect on build times; some otherwise promising proposals have been rejected on the grounds that they would increase it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Linguistic Stability"><div class="sect2" id="idm45983647599048">&#13;
<h2>Linguistic Stability</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="linguistic stability" id="idm45983647597608"/><a data-type="indexterm" data-primary="Go 1" id="idm45983647596904"/>Go 1 was released in March of 2012, defining both the specification of the language and the specification of a set of core APIs. The natural consequence of this is an explicit promise, from the Go design team to the Go users, that programs written &#13;
<span class="keep-together">in Go 1</span> will continue to compile and run correctly, unchanged, for the lifetime of the &#13;
<span class="keep-together">Go 1</span> specification. That is, Go programs that work today can be expected to continue to work even under future “point” releases of Go 1 (Go 1.1, Go 1.2, etc.).<sup><a data-type="noteref" id="idm45983647594312-marker" href="ch02.xhtml#idm45983647594312">12</a></sup></p>&#13;
&#13;
<p>This stands in stark contrast to many other languages, which sometimes add new features enthusiastically, gradually increasing the complexity of the language—and anything written in it—in time, leading to a once elegant language becoming a sprawling featurescape that’s often exceedingly difficult to master.<sup><a data-type="noteref" id="idm45983647591464-marker" href="ch02.xhtml#idm45983647591464">13</a></sup></p>&#13;
&#13;
<p>The Go Team considers this exceptional level of linguistic stability to be a vital feature of Go; it allows users to trust Go and to build on it. It allows libraries to be consumed and built upon with minimal hassle, and dramatically lowers the cost of updates, particularly for large projects and organizations. Importantly, it also allows the Go community to use Go and to learn from it; to spend time writing with the language rather than writing the language.</p>&#13;
&#13;
<p>This is not to say that Go won’t grow: both the APIs and the core language certainly <em>can</em> acquire new packages and features,<sup><a data-type="noteref" id="idm45983647588664-marker" href="ch02.xhtml#idm45983647588664">14</a></sup> and there are many proposals for exactly that,<sup><a data-type="noteref" id="idm45983647587976-marker" href="ch02.xhtml#idm45983647587976">15</a></sup> but not in a way that breaks existing Go 1 code.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Go 2" id="idm45983647585496"/>That being said, it’s quite possible<sup><a data-type="noteref" id="idm45983647584664-marker" href="ch02.xhtml#idm45983647584664">16</a></sup> that there will actually <em>never</em> be a Go 2. More likely, Go 1 will continue to be compatible indefinitely; and in the unlikely event that a breaking change is introduced, Go will provide a conversion utility, like the <code>go fix</code> command that was used during the move to Go 1.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Memory Safety"><div class="sect2" id="idm45983647581304">&#13;
<h2>Memory Safety</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="pointers" id="idm45983647580024"/>The designers of Go have taken great pains to ensure that the language is free of the various bugs and security vulnerabilities—not to mention tedious bookkeeping—associated with direct memory access. Pointers are strictly typed and are always &#13;
<span class="keep-together">initialized</span> to some value (even if that value is <code>nil</code>), and pointer arithmetic is explicitly disallowed. Built-in reference types like maps and channels, which are represented internally as pointers to mutable structures, are initialized by the <code>make</code> function. Simply put, Go neither needs nor allows the kind of manual memory management and manipulation that lower-level languages like C and C++ allow and require, and the subsequent gains with respect to complexity and memory safety can’t be overstated.<a data-type="indexterm" data-primary="pointer arithmetic" id="idm45983647576728"/><a data-type="indexterm" data-primary="C++" id="ch02_term14"/><a data-type="indexterm" data-primary="C (language)" id="idm45983647575080"/></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="garbage-collected language" id="ch02_term13"/>For the programmer, the fact that Go is a garbage-collected language obviates the need to carefully track and free up memory for every allocated byte, eliminating a considerable bookkeeping burden from the programmer’s shoulders. Life without <code>malloc</code> is liberating.</p>&#13;
&#13;
<p>What’s more, by eliminating manual memory management and manipulation—even pointer arithmetic—Go’s designers have made it effectively immune to an entire class of memory errors and the security holes they can introduce. No memory leaks, no buffer overruns, no address space layout randomization. Nothing.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Rust" id="ch02_term15"/>Of course, this simplicity and ease of development comes with some tradeoffs, and while Go’s garbage collector is incredibly sophisticated, it does introduce some overhead. As such, Go can’t compete with languages like C++ and Rust in pure raw execution speed. That said, as we see in the next section, Go still does pretty well for itself in that arena.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Performance"><div class="sect2" id="idm45983647569848">&#13;
<h2>Performance</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Java" id="ch02_term16"/><a data-type="indexterm" data-primary="Python" id="ch02_term17"/>Confronted with the slow builds and tedious bookkeeping of the statically typed, compiled languages like C++ and Java, many programmers moved towards more dynamic, fluid languages like Python. While these languages are excellent for many things, they’re also very inefficient relative to compiled languages like Go, C++, &#13;
<span class="keep-together">and Java.</span></p>&#13;
&#13;
<p>Some of this is made quite clear in the benchmarks of <a data-type="xref" href="#table_ch02_benchmarks">Table 2-1</a>. Of course, benchmarks in general should be taken with a grain of salt, but some results are particularly striking.</p>&#13;
<table id="table_ch02_benchmarks" class="pagebreak-before less_space">&#13;
<caption><span class="label">Table 2-1. </span>Relative benchmarks for common service languages (seconds)<sup><a data-type="noteref" id="idm45983647562936-marker" href="ch02.xhtml#idm45983647562936">a</a></sup></caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>C++</th>&#13;
<th>Go</th>&#13;
<th>Java</th>&#13;
<th>NodeJS</th>&#13;
<th>Python3</th>&#13;
<th>Ruby</th>&#13;
<th>Rust</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Fannkuch-Redux</strong></p></td>&#13;
<td><p><code>8.08</code></p></td>&#13;
<td><p><code>8.28</code></p></td>&#13;
<td><p><code>11.00</code></p></td>&#13;
<td><p><code>11.89</code></p></td>&#13;
<td><p><code>367.49</code></p></td>&#13;
<td><p><code>1255.50</code></p></td>&#13;
<td><p><code>7.28</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>FASTA</strong></p></td>&#13;
<td><p><code>0.78</code></p></td>&#13;
<td><p><code>1.20</code></p></td>&#13;
<td><p><code>1.20</code></p></td>&#13;
<td><p><code>2.02</code></p></td>&#13;
<td><p><code>39.10</code></p></td>&#13;
<td><p><code>31.29</code></p></td>&#13;
<td><p><code>0.74</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>K-Nucleotide</strong></p></td>&#13;
<td><p><code>1.95</code></p></td>&#13;
<td><p><code>8.29</code></p></td>&#13;
<td><p><code>5.00</code></p></td>&#13;
<td><p><code>15.48</code></p></td>&#13;
<td><p><code>46.37</code></p></td>&#13;
<td><p><code>72.19</code></p></td>&#13;
<td><p><code>2.76</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Mandlebrot</strong></p></td>&#13;
<td><p><code>0.84</code></p></td>&#13;
<td><p><code>3.75</code></p></td>&#13;
<td><p><code>4.11</code></p></td>&#13;
<td><p><code>4.03</code></p></td>&#13;
<td><p><code>172.58</code></p></td>&#13;
<td><p><code>259.25</code></p></td>&#13;
<td><p><code>0.93</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>N-Body</strong></p></td>&#13;
<td><p><code>4.09</code></p></td>&#13;
<td><p><code>6.38</code></p></td>&#13;
<td><p><code>6.75</code></p></td>&#13;
<td><p><code>8.36</code></p></td>&#13;
<td><p><code>586.17</code></p></td>&#13;
<td><p><code>253.50</code></p></td>&#13;
<td><p><code>3.31</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Spectral norm</strong></p></td>&#13;
<td><p><code>0.72</code></p></td>&#13;
<td><p><code>1.43</code></p></td>&#13;
<td><p><code>4.09</code></p></td>&#13;
<td><p><code>1.84</code></p></td>&#13;
<td><p><code>118.40</code></p></td>&#13;
<td><p><code>113.92</code></p></td>&#13;
<td><p><code>0.71</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
<tbody><tr class="footnotes"><td colspan="8"><p data-type="footnote" id="idm45983647562936"><sup><a href="ch02.xhtml#idm45983647562936-marker">a</a></sup> Gouy, Isaac. The Computer Language Benchmarks Game. 18 Jan. 2021. <a href="https://oreil.ly/bQFjc"><em class="hyperlink">https://oreil.ly/bQFjc</em></a>.</p></td></tr></tbody></table>&#13;
&#13;
<p>On inspection, it seems that the results can be clustered into three categories corresponding with the types of languages used to generate them:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Compiled, strictly typed languages with manual memory management (C++, Rust)<a data-type="indexterm" data-primary="Rust" data-startref="ch02_term15" id="idm45983647504872"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Compiled, strictly typed languages with garbage collection (Go, Java)<a data-type="indexterm" data-primary="Java" data-startref="ch02_term16" id="idm45983647503064"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Interpreted, dynamically typed languages (Python, Ruby)<a data-type="indexterm" data-primary="C++" data-startref="ch02_term14" id="idm45983647501256"/><a data-type="indexterm" data-primary="Ruby" id="idm45983647500280"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These results suggest that, while the garbage-collected languages are generally slightly less performant than the ones with manual memory management, the differences don’t appear to be great enough to matter except under the most demanding requirements.<a data-type="indexterm" data-primary="garbage-collected language" data-startref="cg02_term13" id="idm45983647498696"/></p>&#13;
&#13;
<p>The differences between the interpreted and compiled languages, however, is striking. At least in these examples, Python, the archetypical dynamic language, benchmarks about <em>ten to one hundred times slower</em> than most compiled languages. Of course, it can be argued that this is still perfectly adequate for many—if not most—purposes, but this is less true for cloud native applications, which often have to endure significant spikes in demand, ideally without having to rely on potentially costly upscaling.<a data-type="indexterm" data-primary="Python" data-startref="ch02_term17" id="idm45983647496392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Static Linking"><div class="sect2" id="idm45983647495320">&#13;
<h2>Static Linking</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="static linking" id="idm45983647494264"/>By default, Go programs are compiled directly into native, statically linked executable binaries into which all necessary Go libraries and the Go runtime are copied. This produces slightly larger files (on the order of about 2MB for a “hello world”), but the resulting binary has no external language runtime to install,<sup><a data-type="noteref" id="idm45983647493096-marker" href="ch02.xhtml#idm45983647493096">17</a></sup> or external library dependencies to upgrade or conflict,<sup><a data-type="noteref" id="idm45983647492440-marker" href="ch02.xhtml#idm45983647492440">18</a></sup> and can be easily distributed to users or deployed to a host without fear of suffering dependency or environmental conflicts.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="container orchestration system" id="idm45983647491320"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="features of" id="idm45983647490552"/>This ability is particularly useful when you’re working with containers. Because Go binaries don’t require an external language runtime or even a distribution, they can be built into “scratch” images that don’t have parent images. The result is a very small (single digit MB) image with minimal deployment latency and data transfer overhead. These are very useful traits in an orchestration system like Kubernetes that may need to pull the image with some regularity.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Static Typing"><div class="sect2" id="idm45983647488728">&#13;
<h2>Static Typing</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="static typing" id="ch02_term18"/><a data-type="indexterm" data-primary="C++" id="idm45983647486184"/><a data-type="indexterm" data-primary="Java" id="idm45983647485512"/><a data-type="indexterm" data-primary="Python" id="idm45983647484840"/>Back in the early days of Go’s design, its authors had to make a choice: would it be <em>statically typed</em>, like C++ or Java, requiring variables to be explicitly defined before use, or <em>dynamically typed</em>, like Python, allowing programmers to assign values to variables without defining them and therefore generally faster to code? It wasn’t a particularly hard decision; it didn’t take very long. Static typing was the obvious choice, but it wasn’t arbitrary, or based on personal preference.<sup><a data-type="noteref" id="idm45983647482936-marker" href="ch02.xhtml#idm45983647482936">19</a></sup></p>&#13;
&#13;
<p>First, type correctness for statically typed languages can be evaluated at compile time, making them far more performant (see <a data-type="xref" href="#table_ch02_benchmarks">Table 2-1</a>).</p>&#13;
&#13;
<p>The designers of Go understood that the time spent in development is only a fraction of a project’s total lifecycle, and that any gains in coding velocity with dynamically typed languages is more than made up for by the increased difficulty in debugging and maintaining such code. After all, what Python programmer hasn’t had their code crash because they tried to use a string as an integer?</p>&#13;
&#13;
<p>Take the following Python code snippet, for example:</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="python"><code class="n">my_variable</code> <code class="o">=</code> <code class="mi">0</code>&#13;
&#13;
<code class="k">while</code> <code class="n">my_variable</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">:</code>&#13;
    <code class="n">my_varaible</code> <code class="o">=</code> <code class="n">my_variable</code> <code class="o">+</code> <code class="mi">1</code>   <code class="c1"># Typo! Infinite loop!</code></pre>&#13;
&#13;
<p>See it yet? Keep trying if you don’t. It can take a second.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="bugs" id="idm45983647619480"/>Any programmer can make this kind of subtle misspelling error, which just so happens to also produce perfectly valid, executable Python. These are just two trivial examples of an entire class of errors that Go will catch at compile time rather than (heaven forbid) in production, and generally closer in the code to the location where they are introduced. After all, it’s well-understood that the earlier in the development cycle you catch a bug, the easier (read cheaper) it is to fix it.</p>&#13;
&#13;
<p>Finally, I’ll even assert something somewhat controversial: typed languages are more readable. Python is often lauded as especially readable with its forgiving nature and somewhat English-like syntax,<sup><a data-type="noteref" id="idm45983647617624-marker" href="ch02.xhtml#idm45983647617624">20</a></sup> but what would you do if presented with the following Python function signature?</p>&#13;
&#13;
<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">send</code><code class="p">(</code><code class="n">message</code><code class="p">,</code> <code class="n">recipient</code><code class="p">):</code></pre>&#13;
&#13;
<p>Is <code>message</code> a string? Is <code>recipient</code> an instance of some class described elsewhere? Yes, this could be improved with some documentation and a couple of reasonable defaults, but many of us have had to maintain enough code to know that that’s a pretty distant star to wish on. Explicitly defined types can guide development and ease the mental burden of writing code by automatically tracking information the programmer would otherwise have to track mentally by serving as documentation for both the programmer and everybody who has to maintain their code.<a data-type="indexterm" data-primary="Go" data-secondary="design of" data-startref="ch02_term11" id="idm45983647395304"/><a data-type="indexterm" data-primary="static typing" data-startref="ch02_term18" id="idm45983647473016"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983651862360">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>If <a data-type="xref" href="ch01.xhtml#chapter_1">Chapter 1</a> focused on what makes a <em>system</em> cloud native, then this chapter can be said to have focused on what makes a <em>language</em>, specifically Go, a good fit for building cloud native services.</p>&#13;
&#13;
<p>However, while a cloud native system needs to be scalable, loosely coupled, resilient, manageable, and observable, a language for the cloud native era has to be able to do more than just build systems with those attributes. After all, with a bit of effort, pretty much any language can, technically, be used to build such systems. So what makes Go so special?</p>&#13;
&#13;
<p>It can be argued that all of the features presented in this chapter directly or indirectly contribute to the cloud native attributes from the previous chapter. Concurrency and memory safety can be said to contribute to service scalability, and structural typing to allow loose coupling, for example. But while Go is the only mainstream language I know that puts all of these features in one place, are they <em>really</em> so novel?</p>&#13;
&#13;
<p>Perhaps most conspicuous of Go’s features are its baked-in—not bolted-on—concurrency features, which allow a programmer to fully and more safely utilize modern networking and multicore hardware. Goroutines and channels are wondrous, of course, and make it far easier to build resilient, highly concurrent networked services, but they’re technically not unique if you consider some less common languages like Clojure or Crystal.</p>&#13;
&#13;
<p>I would assert that where Go really shines is in its faithful adherence to the principle of clarity over cleverness, which extends from an understanding that source code is written by humans for other humans.<sup><a data-type="noteref" id="idm45983647387240-marker" href="ch02.xhtml#idm45983647387240">21</a></sup> That it compiles into machine code is almost immaterial.</p>&#13;
&#13;
<p>Go is designed to support the way people actually work together: in teams, which sometimes change membership, whose members also work on other things. In this environment, code clarity, the minimization of “tribal knowledge,” and the ability to rapidly iterate are critical. Go’s simplicity is often misunderstood and unappreciated, but it lets programmers focus on solving problems instead of struggling with the &#13;
<span class="keep-together">language</span>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.xhtml#chapter_3">Chapter 3</a>, we’ll review many of the specific features of the Go language, where we’ll get to see that simplicity up close.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983645071000"><sup><a href="ch02.xhtml#idm45983645071000-marker">1</a></sup> Schumacher, E.F. “Small Is Beautiful.” <em>The Radical Humanist</em>, August 1973, p. 22.</p><p data-type="footnote" id="idm45983651866712"><sup><a href="ch02.xhtml#idm45983651866712-marker">2</a></sup> These were “cloud native” services before the term “cloud native” was coined.</p><p data-type="footnote" id="idm45983651864088"><sup><a href="ch02.xhtml#idm45983651864088-marker">3</a></sup> Of course, they weren’t called “cloud native” at the time; to Google they were just “services.”</p><p data-type="footnote" id="idm45983651860872"><sup><a href="ch02.xhtml#idm45983651860872-marker">4</a></sup> Pike, Rob. “Go at Google: Language Design in the Service of Software Engineering.” Google, Inc., 2012. <a href="https://oreil.ly/6V9T1"><em class="hyperlink">https://oreil.ly/6V9T1</em></a>.</p><p data-type="footnote" id="idm45983645616360"><sup><a href="ch02.xhtml#idm45983645616360-marker">5</a></sup> In languages that use duck typing, the type of an object is less important than the methods it defines. In other words, “if it walks like a duck and it quacks like a duck, then it must be a duck.”</p><p data-type="footnote" id="idm45983651382280"><sup><a href="ch02.xhtml#idm45983651382280-marker">6</a></sup> Cheney, Dave. “Clear Is Better than Clever.” <em>The Acme of Foolishness</em>, 19 July 2019. <a href="https://oreil.ly/vJs0X"><em class="hyperlink">https://oreil.ly/vJs0X</em></a>.</p><p data-type="footnote" id="idm45983647612392"><sup><a href="ch02.xhtml#idm45983647612392-marker">7</a></sup> Hoare, C.A.R. “Communicating Sequential Processes.” <em>Communications of the ACM</em>, vol. 21, no. 8, Aug. 1978, pp. 666–77. <a href="https://oreil.ly/CHiLt"><em class="hyperlink">https://oreil.ly/CHiLt</em></a>.</p><p data-type="footnote" id="idm45983651600136"><sup><a href="ch02.xhtml#idm45983651600136-marker">8</a></sup> At least among the “mainstream” languages, whatever that means.</p><p data-type="footnote" id="idm45983651594184"><sup><a href="ch02.xhtml#idm45983651594184-marker">9</a></sup> Gerrand, Andrew. “Concurrency Is Not Parallelism.” <em>The Go Blog</em>, 16 Jan. 2016. <a href="https://oreil.ly/WXf4g"><em class="hyperlink">https://oreil.ly/WXf4g</em></a>.</p><p data-type="footnote" id="idm45983647604888"><sup><a href="ch02.xhtml#idm45983647604888-marker">10</a></sup> C++. We’re talking about C++.</p><p data-type="footnote" id="idm45983647603016"><sup><a href="ch02.xhtml#idm45983647603016-marker">11</a></sup> Not counting comments; Openhub.net. “Kubernetes.” <em>Open Hub</em>, Black Duck Software, Inc., 18 Jan. 2021. <a href="https://oreil.ly/y5Rty"><em class="hyperlink">https://oreil.ly/y5Rty</em></a>.</p><p data-type="footnote" id="idm45983647594312"><sup><a href="ch02.xhtml#idm45983647594312-marker">12</a></sup> The Go Team. “Go 1 and the Future of Go Programs.” <em>The Go Documentation</em>. <a href="https://oreil.ly/Mqn0I"><em class="hyperlink">https://oreil.ly/Mqn0I</em></a>.</p><p data-type="footnote" id="idm45983647591464"><sup><a href="ch02.xhtml#idm45983647591464-marker">13</a></sup> Anybody remember Java 1.1? I remember Java 1.1. Sure, we didn’t have generics or autoboxing or enhanced <code>for</code> loops back then, but we were happy. Happy, I tell you.</p><p data-type="footnote" id="idm45983647588664"><sup><a href="ch02.xhtml#idm45983647588664-marker">14</a></sup> I’m on team generics. Go, fightin’ Parametric Polymorphics!</p><p data-type="footnote" id="idm45983647587976"><sup><a href="ch02.xhtml#idm45983647587976-marker">15</a></sup> The Go Team. “Proposing Changes to Go.” <em>GitHub</em>, 7 Aug. 2019. <a href="https://oreil.ly/folYF"><em class="hyperlink">https://oreil.ly/folYF</em></a>.</p><p data-type="footnote" id="idm45983647584664"><sup><a href="ch02.xhtml#idm45983647584664-marker">16</a></sup> Pike, Rob. “Sydney Golang Meetup—Rob Pike—Go 2 Draft Specifications” (video). <em>YouTube</em>, 13 Nov. 2018. <a href="https://oreil.ly/YmMAd"><em class="hyperlink">https://oreil.ly/YmMAd</em></a>.</p><p data-type="footnote" id="idm45983647493096"><sup><a href="ch02.xhtml#idm45983647493096-marker">17</a></sup> Take that, Java.</p><p data-type="footnote" id="idm45983647492440"><sup><a href="ch02.xhtml#idm45983647492440-marker">18</a></sup> Take that, Python.</p><p data-type="footnote" id="idm45983647482936"><sup><a href="ch02.xhtml#idm45983647482936-marker">19</a></sup> Few arguments in programming generate as many snarky comments as Static versus Dynamic typing, except perhaps the Great Tabs versus Spaces Debate, on which Go’s unofficial position is “shut up, who cares?”</p><p data-type="footnote" id="idm45983647617624"><sup><a href="ch02.xhtml#idm45983647617624-marker">20</a></sup> I, too, have been lauded for my forgiving nature and somewhat English-like syntax.</p><p data-type="footnote" id="idm45983647387240"><sup><a href="ch02.xhtml#idm45983647387240-marker">21</a></sup> Or for the same human after a few months of thinking about other things.</p></div></div></section></div></body></html>