- en: 'Chapter 15\. responding to requests: Web Apps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0425-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**This is the 21st century. Users want web apps.** Go’s got you covered there,
    too! The Go standard library includes packages to help you host your own web applications
    and make them accessible from any web browser. So we’re going to spend the final
    two chapters of the book showing you how to build web apps.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing your web app needs is the ability to respond when a browser
    sends it a request. In this chapter, we’ll learn to use the `net/http` package
    to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing web apps in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An app that runs in your terminal is great—for your own use. But ordinary users
    have been spoiled by the internet and the World Wide Web. They don’t want to learn
    to use a terminal so they can use your app. They don’t even want to install your
    app. They want it to be ready to use the moment they click a link in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry! Go can help you write apps for the web, too.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0426-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We won’t lead you on—writing a web app is not a small task. This is going to
    require all of the skills you’ve learned so far, plus a few new ones. But Go has
    some excellent packages available that will make the process easier!
  prefs: []
  type: TYPE_NORMAL
- en: This includes the `net/http` package. HTTP stands for “**H**yper**T**ext **T**ransfer
    **P**rotocol,” and it’s used for communication by web browsers and web servers.
    With `net/http`, you’ll be able to create your very own web apps using Go!
  prefs: []
  type: TYPE_NORMAL
- en: Browsers, requests, servers, and responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you type a URL into your browser, you’re actually sending a *request* for
    a web page. That request goes to a *server*. A server’s job is to get the appropriate
    page and send it back to the browser in a *response*.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of the web, the server usually read the contents of an HTML
    file on the server’s hard drive and sent that HTML back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0427-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But today, it’s much more common for the server to communicate with a *program*
    to fulfill the request, instead of reading from a file. This program can be written
    in pretty much any language you want, including Go!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0427-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A simple web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling a request from a browser is a lot of work. Fortunately, we don’t have
    to do it all ourselves. Back in [Chapter 13](ch13.html#sharing_workcolon_goroutines_and_channel),
    we used the `net/http` package to make requests to servers. The `net/http` package
    also includes a small web server, so it’s also able to *respond* to requests.
    All *we* have to do is write the code that fills those responses with data.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a program that uses `net/http` to serve simple responses to the browser.
    Although the program is short, there’s a lot going on here, some of it new. We’ll
    run the program first, then go back and explain it piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0428-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the above code to a file of your choosing, and run it from your terminal
    using **`go run`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0428-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re running our own web app! Now we just need to connect a web browser to
    it and test it out. Open your browser and type this URL into the address bar.
    (If the URL looks a little strange to you, don’t worry; we’ll explain what it
    means in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The browser will send a request to the app, which will respond with “`Hello,
    web!`”. We’ve just sent our first response to the browser!
  prefs: []
  type: TYPE_NORMAL
- en: The app will keep listening for requests until we stop it. When you’re done
    with the page, press Ctrl-C in your terminal to signal the program to exit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0428-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Your computer is talking to itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we launched our little web app, it started its very own web server, right
    there on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0429-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Because the app is running *on* your computer (and not somewhere out on the
    internet), we use the special hostname `localhost` in the URL. This tells your
    browser that it needs to establish a connection *from* your computer *to* that
    same computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0429-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We also need to specify a port as part of the URL. (A *port* is a numbered network
    communication channel that an application can listen for messages on.) In our
    code, we specified that the server should listen on port 8080, so we include that
    in the URL, following the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0429-03.png)'
  prefs: []
  type: TYPE_IMG
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: I got an error saying the browser was unable to connect!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Your server might not actually be running. Look for error messages in
    your terminal. Also check the hostname and port number in your browser, in case
    you mistyped them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q: Why do I have to specify a port number in the URL? I don’t have to do
    that with other websites!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Most web servers listen for HTTP requests on port 80, because that’s
    the port that web browsers make HTTP requests to by default. But on many operating
    systems, you need special permissions to run a service that listens on port 80,
    for security reasons. That’s why we set up our server to listen on port 8080 instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q: My browser just displays the message, “404 page not found.”**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** That’s a response from the server, which is good, but it also means
    the resource you requested wasn’t found. Check that your URL ends in */hello*,
    and ensure you haven’t made a typo in the server program code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q: When I tried to run my app, I got an error saying “listen tcp 127.0.0.1:8080:
    bind: address already in use”!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Your program is trying to listen on the same port as another program
    (which your OS won’t allow). Have you run the server program more than once? If
    so, did you press Ctrl-C in the terminal to stop it when you were done? Be sure
    to stop the old server before running a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: Our simple web app, explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s take a closer look at the parts of our little web app.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call `http.HandleFunc` with the string `"/hello"`,
    and the `viewHandler` function. (Go supports *first-class functions*, which allow
    you to pass functions to other functions. We’ll talk more about those shortly.)
    This tells the app to call `viewHandler` whenever a request for a URL ending in
    */hello* is received.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0430-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we call `http.ListenAndServe`, which starts up the web server. We pass
    it the string `"localhost:8080"`, which will cause it to accept requests only
    from your own machine on port 8080\. (When you’re ready to open apps up to requests
    from other computers, you can use a string of `"0.0.0.0:8080"` instead. You can
    also change the port number to something other than 8080, if you want.) The `nil`
    value in the second argument just means that requests will be handled using functions
    set up via `HandleFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (Later, if you want to learn about alternate ways to handle requests, look up
    the documentation for the “ListenAndServe” function, the “Handler” interface,
    and the “ServeMux” type from the “http” package.)
  prefs: []
  type: TYPE_NORMAL
- en: We call `ListenAndServe` *after* `HandleFunc` because `ListenAndServe` will
    run forever, unless it encounters an error. If it does, it will return that error,
    which we log before the program exits. If there are no errors, though, this program
    will just continue running until we interrupt it by pressing Ctrl-C in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0430-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Compared to `main`, there’s nothing very surprising in the `viewHandler` function.
    The server passes `viewHandler` an `http.ResponseWriter`, which is used for writing
    data to the browser response, and a pointer to an `http.Request` value, which
    represents the browser’s request. (We don’t use the `Request` value in this program,
    but handler functions still have to accept one.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0430-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Within `viewHandler`, we add data to the response by calling the `Write` method
    on the `ResponseWriter`. `Write` doesn’t accept strings, but it does accept a
    slice of `byte` values, so we convert our `"Hello, web!"` string to a `[]byte`,
    then pass it to `Write`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0431-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You might remember `byte` values from [Chapter 13](ch13.html#sharing_workcolon_goroutines_and_channel).
    The `ioutil.Readall` function returned a slice of `byte` values when called on
    a response retrieved via the `http.Get` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0431-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we saw in [Chapter 13](ch13.html#sharing_workcolon_goroutines_and_channel),
    a `[]byte` can be converted to a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0431-03.png)'
  prefs: []
  type: TYPE_IMG
- en: And as you’ve just seen in this simple web app, a `string` can be converted
    to a `[]byte`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0431-04.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ResponseWriter`’s `Write` method returns the number of bytes successfully
    written, and any error encountered. We can’t do anything useful with the number
    of bytes written, so we ignore that. But if there’s an error, we log it and exit
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Resource paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we entered a URL in our browser to access our web app, we made sure it
    ended in */hello*. But why did we need to?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A server usually has lots of different resources that it can send to a browser,
    including HTML pages, images, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0432-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The part of a URL following the host address and port is the resource *path*.
    It tells the server which of its many resources you want to act on. The `net/http`
    server pulls the path off the end of the URL, and uses it in handling the request.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0432-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When we called `http.HandleFunc` in our web app, we passed it the string `"/hello"`,
    and the `viewHandler` function. The string is used as a request resource path
    to look for. From then on, any time a request with a path of `/hello` is received,
    the app will call the `viewHandler` function. The `viewHandler` function is then
    responsible for generating a response that’s appropriate for the request it received.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0432-03.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, that means responding with the text “Hello, web!”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0432-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Your app can’t just respond “Hello, web!” to every request it receives, though.
    Most apps will need to respond to different request paths in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: One way to accomplish this is by calling `HandleFunc` once for each path you
    want to handle, and provide a different function to handle each path. Your app
    will then be able to respond to requests for any of those paths.
  prefs: []
  type: TYPE_NORMAL
- en: Responding differently for different resource paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s an update to our app that provides greetings in three different languages.
    We call `HandleFunc` three different times. Requests with a `"/hello"` path cause
    the `englishHandler` function to be called, requests for `"/salut"` are handled
    by the `frenchHandler` function, and requests for `"/namaste"` are handled by
    `hindiHandler`. Each of these handler functions passes its `ResponseWriter` and
    a string to a new `write` function, which writes the string to the response.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0433-01.png)![image](assets/f0433-02.png)'
  prefs: []
  type: TYPE_IMG
- en: First-class functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we call `http.HandleFunc` with handler functions, we’re not calling the
    handler function and passing its result to `HandleFunc`. We are passing the *function
    itself* to `HandleFunc`. That function is stored to be called later when a matching
    request path is received.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0435-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The Go language supports **first-class functions**; that is, functions in Go
    are treated as “first-class citizens.”
  prefs: []
  type: TYPE_NORMAL
- en: In a programming language with first-class functions, functions can be assigned
    to variables, and then called from those variables.
  prefs: []
  type: TYPE_NORMAL
- en: The code below first defines a `sayHi` function. In our `main` function, we
    declare a `myFunction` variable with a type of `func()`, meaning the variable
    can hold a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we assign the `sayHi` function itself to `myFunction`. Notice that we
    don’t put any parentheses—we don’t write `sayHi()`—because doing so would *call*
    `sayHi`. We type only the function name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This causes the `sayHi` function itself to be assigned to the `myFunction` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'But on the next line, we *do* include parentheses following the `myFunction`
    variable name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This causes the function stored inside the `myFunction` variable to be called.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0435-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Passing functions to other functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages with first-class functions also allow you to pass functions
    as arguments to other functions. This code defines simple `sayHi` and `sayBye`
    functions. It also defines a `twice` function that takes another function as a
    parameter named `theFunction`. The `twice` function then calls whatever function
    is stored in `theFunction` twice.
  prefs: []
  type: TYPE_NORMAL
- en: In `main`, we call `twice` and pass the `sayHi` function as an argument, which
    causes `sayHi` to be run twice. Then we call `twice` with the `sayBye` function,
    which causes `sayBye` to be run twice.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0436-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions as types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can’t just use any function as an argument when calling any other function,
    though. If we tried to pass the `sayHi` function as an argument to `http.HandleFunc`,
    we’d get a compile error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0436-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A function’s parameters and return value are part of its type. A variable that
    holds a function needs to specify what parameters and return values that function
    should have. That variable can only hold functions whose number and types of parameters
    and return values match the specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code defines a `greeterFunction` variable with a type of `func()`: it
    holds a function that accepts no parameters and returns no values. Then we define
    a `mathFunction` variable with a type of `func(int, int) float64`: it holds a
    function that accepts two integer parameters and returns a `float64` value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code also defines `sayHi` and `divide` functions. If we assign `sayHi`
    to the `greeterFunction` variable and `divide` to the `mathFunction` variable,
    everything compiles and runs fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0437-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But if we try to reverse the two, we’ll get compile errors again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0437-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The `divide` function accepts two `int` parameters and returns a `float64` value,
    so it can’t be stored in the `greeterFunction` variable (which expects a function
    with no parameters and no return value). And the `sayHi` function accepts no parameters
    and returns no value, so it can’t be stored in the `mathFunction` variable (which
    expects a function with two `int` parameters and a `float64` return value).
  prefs: []
  type: TYPE_NORMAL
- en: Functions that accept a function as a parameter also need to specify the parameters
    and return types the passed-in function should have.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a `doMath` function with a `passedFunction` parameter. The passed-in
    function needs to accept two `int` parameters, and return one `float64` value.
  prefs: []
  type: TYPE_NORMAL
- en: We also define `divide` and `multiply` functions, both of which accept two `int`
    parameters and return one `float64`. Either `divide` or `multiply` can be passed
    to `doMath` successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0438-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A function that doesn’t match the specified type can’t be passed to `doMath`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0438-02.png)'
  prefs: []
  type: TYPE_IMG
- en: And that’s why we get compile errors if we pass the wrong function to `http.HandleFunc`.
    `HandleFunc` expects to be passed a function that takes a `ResponseWriter` and
    a pointer to a `Request` as parameters. Pass anything else, and you’ll get a compile
    error.
  prefs: []
  type: TYPE_NORMAL
- en: And really, that’s a good thing. A function that can’t analyze a request and
    write a response probably isn’t going to be able to handle browser requests. If
    you try to pass a function with the wrong type, Go will alert you to the problem
    before your program even compiles.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0438-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0439-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in this code. **Don’t** use the same snippet more than once, and you
    won’t need to use all the snippets. Your **goal** is to make a program that will
    run and produce the output shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0439-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Note: each snippet from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0439-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](assets/arrow.png) Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution_8).'
  prefs: []
  type: TYPE_NORMAL
- en: What’s next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to receive a request from a browser and send a response. The
    trickiest part is done!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0440-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In the final chapter, we’ll use this knowledge to build a more complex app.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all our responses have used plain text. We’re going to learn to use
    HTML to give the page more structure. And we’ll learn to use the `html/template`
    package to insert data into our HTML before sending it back to the browser. See
    you there!
  prefs: []
  type: TYPE_NORMAL
- en: Your Go Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0441-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**That’s it for [Chapter 15](#responding_to_requestscolon_web_apps)! You’ve
    added HTTP handler functions and first-class functions to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0441-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0443-01.png)'
  prefs: []
  type: TYPE_IMG
