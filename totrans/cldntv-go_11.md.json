["```go\n// Get issues a GET to the specified URL\nfunc Get(url string) (*http.Response, error)\n\n// Head issues a HEAD to the specified URL\nfunc Head(url string) (*http.Response, error)\n```", "```go\ntype Response struct {\n    Status     string       // e.g. \"200 OK\"\n    StatusCode int          // e.g. 200\n\n    // Header maps header keys to values.\n    Header Header\n\n    // Body represents the response body.\n    Body io.ReadCloser\n\n    // ContentLength records the length of the associated content. The\n    // value -1 indicates that the length is unknown.\n    ContentLength int64\n\n    // Request is the request that was sent to obtain this Response.\n    Request *Request\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"http://example.com\")     // Send an HTTP GET\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()                         // Close your response!\n\n    body, err := io.ReadAll(resp.Body)          // Read body as []byte\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(body))\n}\n```", "```go\n// Post issues a POST to the specified URL\nfunc Post(url, contentType string, body io.Reader) (*Response, error)\n\n// PostForm issues a POST to the specified URL, with data's keys\n// and values URL-encoded as the request body\nfunc PostForm(url string, data url.Values) (*Response, error)\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"strings\"\n)\n\nconst json = `{ \"name\":\"Matt\", \"age\":44 }`      // This is our JSON\n\nfunc main() {\n    in := strings.NewReader(json)               // Wrap JSON with an io.Reader\n\n    // Issue HTTP POST, declaring our content-type as \"text/json\"\n    resp, err := http.Post(\"http://example.com/upload\", \"text/json\", in)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()                     // Close your response!\n\n    message, err := io.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(string(message))\n}\n```", "```go\n    $ apt install -y protobuf-compiler\n    $ protoc --version\n    ```", "```go\n    $ brew install protobuf\n    $ protoc --version\n    ```", "```go\n    $ go install google.golang.org/protobuf/cmd/protoc-gen-go\n    ```", "```go\nsyntax = \"proto3\";\n\noption go_package = \"github.com/cloud-native-go/ch08/point\";\n\n// Point represents a labeled position on a 2-dimensional surface\nmessage Point {\n  int32 x = 1;\n  int32 y = 2;\n  string label = 3;\n}\n\n// Line contains start and end Points\nmessage Line {\n  Point start = 1;\n  Point end = 2;\n  string label = 3;\n}\n\n// Polyline contains any number (including zero) of Points\nmessage Polyline {\n  repeated Point point = 1;\n  string label = 2;\n}\n```", "```go\nsyntax = \"proto3\";\n\noption go_package = \"github.com/cloud-native-go/ch08/keyvalue\";\n\n// GetRequest represents a request to the key-value store for the\n// value associated with a particular key\nmessage GetRequest {\n  string key = 1;\n}\n\n// GetResponse represents a response from the key-value store for a\n// particular value\nmessage GetResponse {\n  string value = 1;\n}\n\n// PutRequest represents a request to the key-value store for the\n// value associated with a particular key\nmessage PutRequest {\n  string key = 1;\n  string value = 2;\n}\n\n// PutResponse represents a response from the key-value store for a\n// Put action.\nmessage PutResponse {}\n\n// DeleteRequest represents a request to the key-value store to delete\n// the record associated with a key\nmessage DeleteRequest {\n  string key = 1;\n}\n\n// DeleteResponse represents a response from the key-value store for a\n// Delete action.\nmessage DeleteResponse {}\n```", "```go\nservice KeyValue {\n  rpc Get(GetRequest) returns (GetResponse);\n\n  rpc Put(PutRequest) returns (PutResponse);\n\n  rpc Delete(DeleteRequest) returns (DeleteResponse);\n}\n```", "```go\n$ protoc --proto_path=$SOURCE_DIR \\\n    --go_out=$DEST_DIR --go_opt=paths=source_relative \\\n    --go-grpc_out=$DEST_DIR --go-grpc_opt=paths=source_relative \\\n    $SOURCE_DIR/keyvalue.proto\n```", "```go\ntype KeyValueServer interface {\n    Get(context.Context, *GetRequest) (*GetResponse, error)\n    Put(context.Context, *PutRequest) (*PutResponse, error)\n    Delete(context.Context, *DeleteRequest) (*PutResponse, error)\n}\n```", "```go\ntype UnimplementedKeyValueServer struct {}\n\nfunc (*UnimplementedKeyValueServer) Get(context.Context, *GetRequest)\n        (*GetResponse, error) {\n\n    return nil, status.Errorf(codes.Unimplemented, \"method not implemented\")\n}\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"net\"\n\n    pb \"github.com/cloud-native-go/ch08/keyvalue\"\n    \"google.golang.org/grpc\"\n)\n\n// server is used to implement KeyValueServer. It MUST embed the generated\n// struct pb.UnimplementedKeyValueServer\ntype server struct {\n    pb.UnimplementedKeyValueServer\n}\n\nfunc (s *server) Get(ctx context.Context, r *pb.GetRequest)\n        (*pb.GetResponse, error) {\n\n    log.Printf(\"Received GET key=%v\", r.Key)\n\n    // The local Get function is implemented back in Chapter 5\n    value, err := Get(r.Key)\n\n    // Return expects a GetResponse pointer and an err\n    return &pb.GetResponse{Value: value}, err\n}\n\nfunc main() {\n    // Create a gRPC server and register our KeyValueServer with it\n    s := grpc.NewServer()\n    pb.RegisterKeyValueServer(s, &server{})\n\n    // Open a listening port on 50051\n    lis, err := net.Listen(\"tcp\", \":50051\")\n    if err != nil {\n        log.Fatalf(\"failed to listen: %v\", err)\n    }\n\n    // Start accepting connections on the listening port\n    if err := s.Serve(lis); err != nil {\n        log.Fatalf(\"failed to serve: %v\", err)\n    }\n}\n```", "```go\ntype KeyValueClient interface {\n    Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption)\n        (*GetResponse, error)\n\n    Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption)\n        (*PutResponse, error)\n\n    Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption)\n        (*PutResponse, error)\n}\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"log\"\n    \"os\"\n    \"strings\"\n    \"time\"\n\n    pb \"github.com/cloud-native-go/ch08/keyvalue\"\n    \"google.golang.org/grpc\"\n)\n\nfunc main() {\n    // Set up a connection to the gRPC server\n    conn, err := grpc.Dial(\"localhost:50051\",\n        grpc.WithInsecure(), grpc.WithBlock(), grpc.WithTimeout(time.Second))\n    if err != nil {\n        log.Fatalf(\"did not connect: %v\", err)\n    }\n    defer conn.Close()\n\n    // Get a new instance of our client\n    client := pb.NewKeyValueClient(conn)\n\n    var action, key, value string\n\n    // Expect something like \"set foo bar\"\n    if len(os.Args) > 2 {\n        action, key = os.Args[1], os.Args[2]\n        value = strings.Join(os.Args[3:], \" \")\n    }\n\n    // Use context to establish a 1-second timeout.\n    ctx, cancel := context.WithTimeout(context.Background(), time.Second)\n    defer cancel()\n\n    // Call client.Get() or client.Put() as appropriate.\n    switch action {\n    case \"get\":\n        r, err := client.Get(ctx, &pb.GetRequest{Key: key})\n        if err != nil {\n            log.Fatalf(\"could not get value for key %s: %v\\n\", key, err)\n        }\n        log.Printf(\"Get %s returns: %s\", key, r.Value)\n\n    case \"put\":\n        _, err := client.Put(ctx, &pb.PutRequest{Key: key, Value: value})\n        if err != nil {\n            log.Fatalf(\"could not put key %s: %v\\n\", key, err)\n        }\n        log.Printf(\"Put %s\", key)\n\n    default:\n        log.Fatalf(\"Syntax: go run [get|put] KEY VALUE...\")\n    }\n}\n```", "```go\nfunc Open(path string) (*Plugin, error)\n```", "```go\ntype Symbol interface{}\n```", "```go\nfunc (p *Plugin) Lookup(symName string) (Symbol, error)\n```", "```go\n~/cloud-native-go/ch08/go-plugin\n├── duck\n│   └── duck.go\n├── frog\n│   └── frog.go\n└── main\n    └── main.go\n```", "```go\ntype Sayer interface {\n    Says() string\n}\n```", "```go\npackage main\n\ntype duck struct{}\n\nfunc (d duck) Says() string {\n    return \"quack!\"\n}\n\n// Animal is exported as a symbol.\nvar Animal duck\n```", "```go\n$ go build -buildmode=plugin -o duck/duck.so duck/duck.go\n```", "```go\n$ file duck/duck.so\nduck/duck.so: Mach-O 64-bit dynamically linked shared library x86_64\n```", "```go\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"plugin\"\n)\n```", "```go\nif len(os.Args) != 2 {\n    log.Fatal(\"usage: run main/main.go animal\")\n}\n\n// Get the animal name, and build the path where we expect to\n// find the corresponding shared object (.so) file.\nname := os.Args[1]\nmodule := fmt.Sprintf(\"./%s/%s.so\", name, name)\n```", "```go\n// Open our plugin and get a *plugin.Plugin.\np, err := plugin.Open(module)\nif err != nil {\n    log.Fatal(err)\n}\n```", "```go\n// Lookup searches for a symbol named \"Animal\" in plug-in p.\nsymbol, err := p.Lookup(\"Animal\")\nif err != nil {\n    log.Fatal(err)\n}\n```", "```go\ntype Symbol interface{}\n```", "```go\n// Asserts that the symbol interface holds a Sayer.\nanimal, ok := symbol.(Sayer)\nif !ok {\n    log.Fatal(\"that's not a Sayer\")\n}\n\n// Now we can use our loaded plug-in!\nfmt.Printf(\"A %s says: %q\\n\", name, animal.Says())\n```", "```go\n$ go run main/main.go duck\nA duck says: \"quack!\"\n\n$ go run main/main.go frog\nA frog says: \"ribbit!\"\n```", "```go\n$ go run main/main.go fox\nA fox says: \"ring-ding-ding-ding-dingeringeding!\"\n```", "```go\n~/cloud-native-go/ch08/hashicorp-plugin\n├── commons\n│   └── commons.go\n├── duck\n│   └── duck.go\n└── main\n    └── main.go\n```", "```go\ntype Sayer interface {\n    Says() string\n}\n```", "```go\ntype SayerPlugin struct {\n    Impl Sayer\n}\n\nfunc (SayerPlugin) Client(b *plugin.MuxBroker, c *rpc.Client)\n        (interface{}, error) {\n\n    return &SayerRPC{client: c}, nil\n}\n\nfunc (p *SayerPlugin) Server(*plugin.MuxBroker) (interface{}, error) {\n    return &SayerRPCServer{Impl: p.Impl}, nil\n}\n```", "```go\ntype SayerRPC struct{ client *rpc.Client }\n\nfunc (g *SayerRPC) Says() string {\n    var resp string\n\n    err := g.client.Call(\"Plugin.Says\", new(interface{}), &resp)\n    if err != nil {\n        panic(err)\n    }\n\n    return resp\n}\n```", "```go\nvar HandshakeConfig = plugin.HandshakeConfig{\n    ProtocolVersion:  1,\n    MagicCookieKey:   \"BASIC_PLUGIN\",\n    MagicCookieValue: \"hello\",\n}\n```", "```go\ntype SayerRPCServer struct {\n    Impl Sayer    // Impl contains our actual implementation\n}\n\nfunc (s *SayerRPCServer) Says(args interface{}, resp *string) error {\n    *resp = s.Impl.Says()\n    return nil\n}\n```", "```go\npackage main\n```", "```go\nimport (\n    \"github.com/cloud-native-go/ch08/hashicorp-plugin/commons\"\n    \"github.com/hashicorp/go-plugin\"\n)\n```", "```go\ntype Duck struct{}\n\nfunc (g *Duck) Says() string {\n    return \"Quack!\"\n}\n```", "```go\nfunc main() {\n    // Create and initialize our service implementation.\n    sayer := &Duck{}\n\n    // pluginMap is the map of plug-ins we can dispense.\n    var pluginMap = map[string]plugin.Plugin{\n        \"sayer\": &commons.SayerPlugin{Impl: sayer},\n    }\n\n    plugin.Serve(&plugin.ServeConfig{\n        HandshakeConfig: handshakeConfig,\n        Plugins:         pluginMap,\n    })\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n\n    \"github.com/cloud-native-go/ch08/hashicorp-plugin/commons\"\n    \"github.com/hashicorp/go-plugin\"\n)\n```", "```go\nfunc main() {\n    if len(os.Args) != 2 {\n        log.Fatal(\"usage: run main/main.go animal\")\n    }\n\n    // Get the animal name, and build the path where we expect to\n    // find the corresponding executable file.\n    name := os.Args[1]\n    module := fmt.Sprintf(\"./%s/%s\", name, name)\n\n    // Does the file exist?\n    _, err := os.Stat(module)\n    if os.IsNotExist(err) {\n        log.Fatal(\"can't find an animal named\", name)\n    }\n}\n```", "```go\n// pluginMap is the map of plug-ins we can dispense.\nvar pluginMap = map[string]plugin.Plugin{\n    \"sayer\": &commons.SayerPlugin{},\n}\n\n// Launch the plugin process!\nclient := plugin.NewClient(&plugin.ClientConfig{\n    HandshakeConfig: commons.HandshakeConfig,\n    Plugins:         pluginMap,\n    Cmd:             exec.Command(module),\n})\ndefer client.Kill()\n\n// Connect to the plugin via RPC\nrpcClient, err := client.Client()\nif err != nil {\n    log.Fatal(err)\n}\n```", "```go\n    // Request the plug-in from the client\n    raw, err := rpcClient.Dispense(\"sayer\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // We should have a Sayer now! This feels like a normal interface\n    // implementation, but is actually over an RPC connection.\n    sayer := raw.(commons.Sayer)\n\n    // Now we can use our loaded plug-in!\n    fmt.Printf(\"A %s says: %q\\n\", name, sayer.Says())\n}\n```", "```go\n~/cloud-native-go/ch08/hexarch/\n├── core\n│   └── core.go\n├── frontend\n│   ├── grpc.go\n│   └── rest.go\n├── main.go\n└── transact\n    ├── filelogger.go\n    └── pglogger.go\n```", "```go\ntype TransactionLogger interface {\n    WriteDelete(key string)\n    WritePut(key, value string)\n}\n```", "```go\npackage core\n\nimport (\n    \"errors\"\n    \"log\"\n    \"sync\"\n)\n\ntype KeyValueStore struct {\n    m        map[string]string\n    transact TransactionLogger\n}\n\nfunc NewKeyValueStore(tl TransactionLogger) *KeyValueStore {\n    return &KeyValueStore{\n        m:        make(map[string]string),\n        transact: tl,\n    }\n}\n\nfunc (store *KeyValueStore) Delete(key string) error {\n    delete(store.m, key)\n    store.transact.WriteDelete(key)\n    return nil\n}\n\nfunc (store *KeyValueStore) Put(key string, value string) error {\n    store.m[key] = value\n    store.transact.WritePut(key, value)\n    return nil\n}\n```", "```go\nfunc NewTransactionLogger(logger string) (core.TransactionLogger, error) {\n    switch logger {\n    case \"file\":\n        return NewFileTransactionLogger(os.Getenv(\"TLOG_FILENAME\"))\n\n    case \"postgres\":\n        return NewPostgresTransactionLogger(\n            PostgresDbParams{\n                dbName: os.Getenv(\"TLOG_DB_HOST\"),\n                host: os.Getenv(\"TLOG_DB_DATABASE\"),\n                user: os.Getenv(\"TLOG_DB_USERNAME\"),\n                password: os.Getenv(\"TLOG_DB_PASSWORD\"),\n            }\n        )\n\n    case \"\":\n        return nil, fmt.Errorf(\"transaction logger type not defined\")\n\n    default:\n        return nil, fmt.Errorf(\"no such transaction logger %s\", s)\n    }\n}\n```", "```go\npackage frontend\n\ntype FrontEnd interface {\n    Start(kv *core.KeyValueStore) error\n}\n```", "```go\npackage frontend\n\nimport (\n    \"net/http\"\n\n    \"github.com/cloud-native-go/examples/ch08/hexarch/core\"\n    \"github.com/gorilla/mux\"\n)\n\n// restFrontEnd contains a reference to the core application logic,\n// and complies with the contract defined by the FrontEnd interface.\ntype restFrontEnd struct {\n    store *core.KeyValueStore\n}\n\n// keyValueDeleteHandler handles the logic for the DELETE HTTP method.\nfunc (f *restFrontEnd) keyValueDeleteHandler(w http.ResponseWriter,\n        r *http.Request) {\n\n    vars := mux.Vars(r)\n    key := vars[\"key\"]\n\n    err := f.store.Delete(key)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n}\n\n// ...other handler functions omitted for brevity.\n\n// Start includes the setup and start logic that previously\n// lived in a main function.\nfunc (f *restFrontEnd) Start(store *core.KeyValueStore) error {\n    // Remember our core application reference.\n    f.store = store\n\n    r := mux.NewRouter()\n\n    r.HandleFunc(\"/v1/{key}\", f.keyValueGetHandler).Methods(\"GET\")\n    r.HandleFunc(\"/v1/{key}\", f.keyValuePutHandler).Methods(\"PUT\")\n    r.HandleFunc(\"/v1/{key}\", f.keyValueDeleteHandler).Methods(\"DELETE\")\n\n    return http.ListenAndServe(\":8080\", r)\n}\n```", "```go\npackage main\n\nimport (\n    \"log\"\n\n    \"github.com/cloud-native-go/examples/ch08/hexarch/core\"\n    \"github.com/cloud-native-go/examples/ch08/hexarch/frontend\"\n    \"github.com/cloud-native-go/examples/ch08/hexarch/transact\"\n)\n\nfunc main() {\n    // Create our TransactionLogger. This is an adapter that will plug\n    // into the core application's TransactionLogger port.\n    tl, err := transact.NewTransactionLogger(os.Getenv(\"TLOG_TYPE\"))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create Core and tell it which TransactionLogger to use.\n    // This is an example of a \"driven agent\"\n    store := core.NewKeyValueStore(tl)\n    store.Restore()\n\n    // Create the frontend.\n    // This is an example of a \"driving agent.\"\n    fe, err := frontend.NewFrontEnd(os.Getenv(\"FRONTEND_TYPE\"))\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Fatal(fe.Start(store))\n}\n```"]