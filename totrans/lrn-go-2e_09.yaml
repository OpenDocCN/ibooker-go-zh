- en: Chapter 9\. Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 错误
- en: Error handling is one of the biggest challenges for developers moving to Go
    from other languages. For those used to exceptions, Go’s approach feels anachronistic.
    But solid software engineering principles underlie Go’s approach. In this chapter,
    you’ll learn how to work with errors in Go. You’ll also take a look at `panic`
    and `recover`, Go’s system for handling errors that should stop execution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是开发者从其他语言转向Go时面临的最大挑战之一。对于习惯于异常的人来说，Go的方法感觉过时。但Go方法的背后是坚实的软件工程原则。在本章中，您将学习如何在Go中处理错误。您还将了解`panic`和`recover`，Go用于处理应该停止执行的错误的系统。
- en: 'How to Handle Errors: The Basics'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理错误：基础知识
- en: 'As was covered briefly in [Chapter 5](ch05.html#unique_chapter_id_05), Go handles
    errors by returning a value of type `error` as the last return value for a function.
    This is entirely by convention, but it is such a strong convention that it should
    never be breached. When a function executes as expected, `nil` is returned for
    the error parameter. If something goes wrong, an error value is returned instead.
    The calling function then checks the error return value by comparing it to `nil`,
    handling the error, or returning an error of its own. A simple function with error
    handling looks like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第5章](ch05.html#unique_chapter_id_05)中简要介绍的那样，Go通过在函数的最后一个返回值返回`error`类型的值来处理错误。虽然这完全是按约定来的，但这一约定如此之强，以至于不应该违反。当函数正常执行时，错误参数返回`nil`。如果出现问题，则返回一个错误值。调用函数通过将其与`nil`比较来检查错误返回值，处理错误，或返回自己的错误。一个带有错误处理的简单函数看起来像这样：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A new error is created from a string by calling the `New` function in the `errors`
    package. Error messages should not be capitalized nor should they end with punctuation
    or a newline. In most cases, you should set the other return values to their zero
    values when a non-nil error is returned. You’ll see an exception to this rule
    when I cover sentinel errors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`errors`包中的`New`函数通过字符串创建新的错误。错误消息不应大写，也不应以标点符号或换行符结尾。在大多数情况下，当返回非`nil`错误时，应将其他返回值设置为它们的零值。在我讨论哨兵错误时，您将看到此规则的一个例外。
- en: 'Unlike languages with exceptions, Go doesn’t have special constructs to detect
    if an error was returned. When a function returns an error, use an `if` statement
    to check the error variable to see if it is non-nil:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有异常的语言不同，Go没有特殊的结构来检测是否返回了错误。当函数返回错误时，使用`if`语句来检查错误变量是否为非`nil`：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can try out this code in the *sample_code/error_basics* directory in the
    [Chapter 9 repository](https://oreil.ly/KCSeb).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第9章库](https://oreil.ly/KCSeb)的*sample_code/error_basics*目录中尝试此代码。
- en: '`error` is a built-in interface that defines a single method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`是一个内置接口，定义了一个方法：'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Anything that implements this interface is considered an error. The reason you
    return `nil` from a function to indicate that no error occurred is that `nil`
    is the zero value for any interface type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现此接口的内容都被视为错误。您从函数返回`nil`以指示未发生错误的原因是`nil`是任何接口类型的零值。
- en: There are two very good reasons that Go uses a returned error instead of thrown
    exceptions. First, exceptions add at least one new code path through the code.
    These paths are sometimes unclear, especially in languages whose functions don’t
    include a declaration that an exception is possible. This produces code that crashes
    in surprising ways when exceptions aren’t properly handled, or, even worse, code
    that doesn’t crash but whose data is not properly initialized, modified, or stored.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用返回的错误而不是抛出异常有两个非常好的原因。首先，异常会通过代码添加至少一条新的代码路径。这些路径有时不太清晰，特别是在函数不包括异常可能性声明的语言中。这会导致代码以令人惊讶的方式崩溃，当异常没有被正确处理时，甚至更糟糕的是，代码并不会崩溃，但其数据没有正确初始化、修改或存储。
- en: The second reason is more subtle but demonstrates how Go’s features work together.
    The Go compiler requires all variables to be read. Making errors returned values
    forces developers to either check and handle error conditions or make it explicit
    that they are ignoring errors by using an underscore (`_`) for the returned error
    value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因更微妙，但展示了Go的特性如何协同工作。Go编译器要求读取所有变量。使错误返回值迫使开发者要么检查和处理错误条件，要么通过使用下划线(`_`)明确表明他们正在忽略错误。
- en: Exception handling may produce shorter code, but having fewer lines doesn’t
    necessarily make code easier to understand or maintain. As you’ve seen, idiomatic
    Go favors clear code, even if it takes more lines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能会生成更短的代码，但更少的行数并不一定使代码更易于理解或维护。正如您所见，Go 的惯用法更青睐清晰的代码，即使代码行数更多。
- en: Another thing to note is how code flows in Go. The error handling is indented
    inside an `if` statement. The business logic is not. This gives a quick visual
    clue to which code is along the “golden path” and which code is the exceptional
    condition.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是 Go 中代码的流程。错误处理位于`if`语句的缩进内，而业务逻辑则不是。这为哪些代码处于“黄金路径”以及哪些代码是异常条件提供了快速的视觉线索。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The second situation is a reused `err` variable. The Go compiler requires every
    variable to be read at least once. It doesn’t require that *every* write to a
    variable is read. If you use an `err` variable multiple times, you have to read
    it only once to make the compiler happy. In [“staticcheck”](ch11.html#staticcheck),
    you’ll see a way to detect this.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是重用的`err`变量。Go 编译器要求每个变量至少被读取一次。它不要求对变量的每次写入都进行读取。如果多次使用`err`变量，则只需读取一次即可使编译器满意。在[“staticcheck”](ch11.html#staticcheck)中，您将看到一种检测此问题的方法。
- en: Use Strings for Simple Errors
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串表示简单错误
- en: 'Go’s standard library provides two ways to create an error from a string. The
    first is the `errors.New` function. It takes in a `string` and returns an `error`.
    This string is returned when you call the `Error` method on the returned error
    instance. If you pass an error to `fmt.Println`, it calls the `Error` method automatically:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了两种从字符串创建错误的方式。第一种是`errors.New`函数。它接受一个`string`并返回一个`error`。当您调用返回的错误实例的`Error`方法时，此字符串将被返回。如果将错误传递给`fmt.Println`，它会自动调用`Error`方法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second way is to use the `fmt.Errorf` function. This function allows you
    to include runtime information in the error message by using the `fmt.Printf`
    verbs to format an error string. Like `errors.New`, this string is returned when
    you call the `Error` method on the returned error instance:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用`fmt.Errorf`函数。此函数允许您通过使用`fmt.Printf`占位符在错误消息中包含运行时信息。与`errors.New`类似，调用返回的错误实例的`Error`方法时返回此字符串：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can find this code in the *sample_code/string_error* directory in the [Chapter
    9 repository](https://oreil.ly/KCSeb).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第9章代码库](https://oreil.ly/KCSeb)的*sample_code/string_error*目录中找到此代码。
- en: Sentinel Errors
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哨兵错误
- en: 'Some errors are meant to signal that processing cannot continue because of
    a problem with the current state. In his blog post [“Don’t Just Check Errors,
    Handle Them Gracefully”](https://oreil.ly/TiJnS), Dave Cheney, a developer who
    has been active in the Go community for many years, coined the term *sentinel
    errors* to describe these:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误意味着由于当前状态存在问题而无法继续处理。在他的博客文章[“不仅仅检查错误，优雅地处理它们”](https://oreil.ly/TiJnS)中，Dave
    Cheney，一个多年活跃于 Go 社区的开发者，创造了术语*哨兵错误*来描述这些错误：
- en: The name descends from the practice in computer programming of using a specific
    value to signify that no further processing is possible. So too with Go, we use
    specific values to signify an error.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名称源自计算机编程实践中使用特定值表示无法进一步处理。在 Go 中也是如此，我们使用特定值来表示错误。
- en: Sentinel errors are one of the few variables that are declared at the package
    level. By convention, their names start with `Err` (with the notable exception
    of `io.EOF`). They should be treated as read-only; there’s no way for the Go compiler
    to enforce this, but it is a programming error to change their value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵错误是少数在包级别声明的变量之一。按照惯例，它们的名称以`Err`开头（`io.EOF`是显著的例外）。它们应被视为只读；虽然 Go 编译器无法强制执行这一点，但修改它们的值是编程错误。
- en: 'Sentinel errors are usually used to indicate that you cannot start or continue
    processing. For example, the standard library includes a package for processing
    ZIP files, `archive/zip`. This package defines several sentinel errors, including
    `ErrFormat`, which is returned when data that doesn’t represent a ZIP file is
    passed in. Try out this code on [The Go Playground](https://oreil.ly/DaW-s) or
    in the *sample_code/sentinel_error* directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵错误通常用于指示无法启动或继续处理。例如，标准库包括一个用于处理 ZIP 文件的包，`archive/zip`。此包定义了几个哨兵错误，包括`ErrFormat`，当传入的数据不表示
    ZIP 文件时返回。您可以在[The Go Playground](https://oreil.ly/DaW-s)或第9章代码库的*sample_code/sentinel_error*目录中尝试此代码：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another example of a sentinel error in the standard library is `rsa.ErrMessa⁠ge​TooLong`
    in the `crypto/rsa` package. It indicates that a message cannot be encrypted because
    it is too long for the provided public key. The sentinel error `context.Canceled`
    is covered in [Chapter 14](ch14.html#unique_chapter_id_14).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中另一个哨兵错误的例子是`rsa.ErrMessageTooLong`，位于`crypto/rsa`包中。它指示由于消息过长而无法使用提供的公钥进行加密。哨兵错误`context.Canceled`在[第14章](ch14.html#unique_chapter_id_14)中有详细介绍。
- en: Be sure you need a sentinel error before you define one. Once you define one,
    it is part of your public API, and you have committed to it being available in
    all future backward-compatible releases. It’s far better to reuse one of the existing
    ones in the standard library or to define an error type that includes information
    about the condition that caused the error to be returned (you’ll see how to do
    that in the next section). But if you have an error condition that indicates a
    specific state has been reached in your application where no further processing
    is possible and no additional information needs to be used to explain the error
    state, a sentinel error is the correct choice.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义哨兵错误之前，请确保您确实需要一个。一旦定义了哨兵错误，它就成为您公共API的一部分，并且您已经承诺它在所有未来向后兼容的发布中都可用。更好的做法是重用标准库中的现有错误之一，或者定义一个错误类型，其中包含有关导致返回错误的条件的信息（您将在下一节中看到如何实现）。但是，如果您有一个错误条件，指示应用程序中已达到特定状态，进一步处理不可能，并且不需要使用其他信息来解释错误状态，则哨兵错误是正确的选择。
- en: How do you test for a sentinel error? As you can see in the preceding code sample,
    use `==` to test whether the error was returned when calling a function whose
    documentation explicitly says it returns a sentinel error. In [“Is and As”](#is_as),
    I discuss how to check for sentinel errors in other situations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如何测试哨兵错误？如前面的代码示例所示，使用`==`来测试调用函数时是否返回了文档明确说明返回哨兵错误的情况。在[“Is and As”](#is_as)中，我将讨论如何在其他情况下检查哨兵错误。
- en: So far, all the errors that you’ve seen are strings. But Go errors can contain
    more information. Let’s see how.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您看到的所有错误都是字符串。但是Go错误可以包含更多信息。让我们看看如何做到这一点。
- en: Errors Are Values
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误是值
- en: 'Since `error` is an interface, you can define your own errors that include
    additional information for logging or error handling. For example, you might want
    to include a status code as part of the error to indicate the kind of error that
    should be reported back to the user. This lets you avoid string comparisons (whose
    text might change) to determine error causes. Let’s see how this works. First,
    define your own enumeration to represent the status codes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`error`是一个接口，您可以定义自己的错误类型，其中包含用于日志记录或错误处理的附加信息。例如，您可能希望在错误中包含状态码以指示应向用户报告的错误类型。这样可以避免字符串比较（其文本可能会更改）来确定错误原因。让我们看看这是如何工作的。首先，定义自己的枚举以表示状态码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, define a `StatusErr` to hold this value:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个`StatusErr`来保存这个值：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can use `StatusErr` to provide more details about what went wrong:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`StatusErr`来提供有关出现问题的更多详细信息：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can find this code in the *sample_code/custom_error* directory in the [Chapter
    9 repository](https://oreil.ly/KCSeb).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第9章存储库](https://oreil.ly/KCSeb)的*sample_code/custom_error*目录中找到此代码。
- en: Even when you define your own custom error types, always use `error` as the
    return type for the error result. This allows you to return different types of
    errors from your function and allows callers of your function to choose not to
    depend on the specific error type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使定义了自己的自定义错误类型，也要始终将`error`作为错误结果的返回类型。这允许您从函数中返回不同类型的错误，并允许调用者选择不依赖于特定的错误类型。
- en: 'If you are using your own error type, be sure you don’t return an uninitialized
    instance. Let’s see what happens if you do. Try out the following code on [The
    Go Playground](https://oreil.ly/MPaHx) or in the *sample_code/return_custom_error*
    directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用自己的错误类型，请确保不要返回未初始化的实例。看看如果这样做会发生什么。在[The Go Playground](https://oreil.ly/MPaHx)或[第9章存储库](https://oreil.ly/KCSeb)的*sample_code/return_custom_error*目录中尝试以下代码：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this program produces the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将产生以下输出：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This isn’t a pointer type versus value type issue; if you declared `genErr`
    to be of type `*StatusErr`, you’d see the same output. The reason `err` is non-nil
    is that `error` is an interface. As I discussed in [“Interfaces and nil”](ch07.html#interface_nil),
    for an interface to be considered `nil`, both the underlying type and the underlying
    value must be `nil`. Whether or not `genErr` is a pointer, the underlying type
    part of the interface is not `nil`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是指针类型与值类型的问题；如果你声明`genErr`的类型是`*StatusErr`，你会看到相同的输出。`err`非空的原因是`error`是一个接口。正如我在[“接口和nil”](ch07.html#interface_nil)中讨论的那样，要使接口被认为是`nil`，必须同时满足底层类型和底层值都是`nil`。不管`genErr`是不是指针，接口的底层类型部分都不是`nil`。
- en: 'You can fix this in two ways. The most common approach is to explicitly return
    `nil` for the error value when a function completes successfully:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用两种方法修复这个问题。最常见的方法是在函数成功完成时显式地返回`nil`作为错误值：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This has the advantage of not requiring you to read through code to make sure
    that the error variable on the `return` statement is correctly defined.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是不需要你阅读代码来确保`return`语句上的错误变量被正确定义。
- en: 'Another approach is to make sure that any local variable that holds an `error`
    is of type `error`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是确保任何持有`error`的局部变量都是`error`类型：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Warning
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When using custom errors, never define a variable to be of the type of your
    custom error. Either explicitly return `nil` when no error occurs or define the
    variable to be of type `error`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义错误时，永远不要定义一个变量为你自定义错误的类型。要么在没有错误发生时显式地返回`nil`，要么定义变量为`error`类型。
- en: As was covered in [“Use Type Assertions and Type Switches Sparingly”](ch07.html#rare_type_assertions),
    don’t use a type assertion or a type switch to access the fields and methods of
    a custom error. Instead, use `errors.As`, which is discussed in [“Is and As”](#is_as).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[“谨慎使用类型断言和类型切换”](ch07.html#rare_type_assertions)中所述，不要使用类型断言或类型切换来访问自定义错误的字段和方法。相反，请使用`errors.As`，这在[“Is和As”](#is_as)中有讨论。
- en: Wrapping Errors
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装错误
- en: When an error is passed back through your code, you often want to add information
    to it. This can be the name of the function that received the error or the operation
    it was trying to perform. When you preserve an error while adding information,
    it is called *wrapping* the error. When you have a series of wrapped errors, it
    is called an *error tree*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当错误通过你的代码传递回来时，你通常希望为其添加信息。这可以是接收到错误的函数的名称或它试图执行的操作。当你在保留错误的同时添加信息时，称为*包装*错误。当你有一系列被包装的错误时，称为*错误树*。
- en: 'A function in the Go standard library wraps errors, and you’ve already seen
    it. The `fmt.Errorf` function has a special verb, `%w`. Use this to create an
    error whose formatted string includes the formatted string of another error and
    which contains the original error as well. The convention is to write `: %w` at
    the end of the error format string and to make the error to be wrapped the last
    parameter passed to `fmt.Errorf`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'Go标准库中的一个函数用于包装错误，你已经见过它了。`fmt.Errorf`函数有一个特殊的占位符`%w`。使用它可以创建一个错误，其格式化字符串包含另一个错误的格式化字符串，并且包含原始错误。惯例是在错误格式字符串的末尾写上`:
    %w`，并且将要被包装的错误作为`fmt.Errorf`的最后一个参数传递。'
- en: 'The standard library also provides a function for unwrapping errors, the `Unwrap`
    function in the `errors` package. You pass it an error, and it returns the wrapped
    error if there is one. If there isn’t, it returns `nil`. Here’s a quick program
    that demonstrates wrapping with `fmt.Errorf` and unwrapping with `errors.Unwrap`.
    You can run it on [The Go Playground](https://oreil.ly/HxdHz) or in the *sample_code/wrap_error*
    directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还提供了一个解包错误的函数，即`errors`包中的`Unwrap`函数。你将一个错误传递给它，如果存在包装错误，它将返回被包装的错误。如果没有，它将返回`nil`。这里有一个快速示例程序，演示了使用`fmt.Errorf`包装和使用`errors.Unwrap`解包的过程。你可以在[The
    Go Playground](https://oreil.ly/HxdHz)上运行它，或者在[第9章代码库](https://oreil.ly/KCSeb)的*sample_code/wrap_error*目录中运行它：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run this program, you see the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到以下输出：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You don’t usually call `errors.Unwrap` directly. Instead, you use `errors.Is`
    and `errors.As` to find a specific wrapped error. I’ll talk about these two functions
    in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不直接调用`errors.Unwrap`。相反，你可以使用`errors.Is`和`errors.As`来查找特定的包装错误。我将在下一节讨论这两个函数。
- en: 'If you want to wrap an error with your custom error type, your error type needs
    to implement the method `Unwrap`. This method takes in no parameters and returns
    an `error`. Here’s an update to the error that you defined earlier to demonstrate
    how this works. You can find it in the *sample_code/custom_wrapped_error* directory
    in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用你自定义的错误类型包装一个错误，你的错误类型需要实现 `Unwrap` 方法。该方法不带参数并返回一个 `error`。下面是对你之前定义的错误的更新，演示了如何实现这一点。你可以在
    *sample_code/custom_wrapped_error* 目录中的 [第9章存储库](https://oreil.ly/KCSeb) 找到它：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now you can use `StatusErr` to wrap underlying errors:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `StatusErr` 包装底层错误：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Not all errors need to be wrapped. A library can return an error that means
    processing cannot continue, but the error message contains implementation details
    that aren’t needed in other parts of your program. In this situation, it is perfectly
    acceptable to create a brand-new error and return that instead. Understand the
    situation and determine what needs to be returned.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的错误都需要包装。一个库可能会返回一个错误，意味着处理无法继续，但错误消息包含了在程序其他部分不需要的实现细节。在这种情况下，创建一个全新的错误并返回是完全可以接受的。理解情况并确定需要返回什么。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to create a new error that contains the message from another error,
    but don’t want to wrap it, use `fmt.Errorf` to create an error but use the `%v`
    verb instead of `%w`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个包含另一个错误消息的新错误，但又不想包装它，请使用 `fmt.Errorf` 创建一个错误，但是使用 `%v` 动词而不是 `%w`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Wrapping Multiple Errors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装多个错误
- en: 'Sometimes a function generates multiple errors that should be returned. For
    example, if you wrote a function to validate the fields in a struct, it would
    be better to return an error for each invalid field. Since the standard function
    signature returns `error` and not `[]error`, you need to merge multiple errors
    into a single error. That’s what the `errors.Join` function is for:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个函数会生成多个应返回的错误。例如，如果你编写一个函数来验证结构体中的字段，最好为每个无效字段返回一个错误。由于标准函数签名返回 `error`
    而不是 `[]error`，你需要将多个错误合并为单个错误。这就是 `errors.Join` 函数的用途：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can find this code in the *sample_code/join_error* directory in the [Chapter
    9 repository](https://oreil.ly/KCSeb).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *sample_code/join_error* 目录中的 [第9章存储库](https://oreil.ly/KCSeb) 找到这段代码。
- en: 'Another way to merge multiple errors is to pass multiple `%w` verbs to `fmt.Errorf`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 合并多个错误的另一种方法是将多个 `%w` 动词传递给 `fmt.Errorf`：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can implement your own `error` type that supports multiple wrapped errors.
    To do so, implement the `Unwrap` method but have it return `[]error` instead of
    `error`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现自己的支持多个包装错误的 `error` 类型。为此，实现 `Unwrap` 方法但让它返回 `[]error` 而不是 `error`：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Go doesn’t support method overloading, so you can’t create a single type that
    provides both implementations of `Unwrap`. Also note that the `errors.Unwrap`
    function will return `nil` if you pass it an error that implements the `[]error`
    variant of `Unwrap`. This is another reason you shouldn’t call the `errors.Unwrap`
    function directly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不支持方法重载，因此你不能创建一个提供 `Unwrap` 的单一类型。还要注意，如果将 `errors.Unwrap` 函数传递给实现 `[]error`
    变体的错误，它将返回 `nil`。这也是你不应直接调用 `errors.Unwrap` 函数的另一个原因。
- en: 'If you need to handle errors that may wrap zero, one, or multiple errors, use
    this code as a basis. You can find it in the *sample_code/custom_wrapped_multi_error*
    directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理可能包装零个、一个或多个错误的错误，请使用此代码作为基础。你可以在 *sample_code/custom_wrapped_multi_error*
    目录中的 [第9章存储库](https://oreil.ly/KCSeb) 找到它：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the standard library doesn’t define interfaces to represent errors with
    either `Unwrap` variant, this code uses anonymous interfaces in a type switch
    to match the methods and access the wrapped errors. Before writing your own code,
    see if you can use `errors.Is` and `errors.As` to examine your error trees. Let’s
    see how they work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准库没有定义接口来表示具有 `Unwrap` 变体的错误，此代码使用匿名接口在类型切换中匹配方法并访问包装的错误。在编写自己的代码之前，请查看是否可以使用
    `errors.Is` 和 `errors.As` 检查错误树。让我们看看它们是如何工作的。
- en: Is and As
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Is 和 As
- en: Wrapping errors is a useful way to get additional information about an error,
    but it introduces problems. If a sentinel error is wrapped, you cannot use `==`
    to check for it, nor can you use a type assertion or type switch to match a wrapped
    custom error. Go solves this problem with two functions in the `errors` package,
    `Is` and `As`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 包装错误是获取有关错误的附加信息的有用方式，但它也引入了问题。如果包装了一个 sentinel 错误，则无法使用 `==` 进行检查，也无法使用类型断言或类型切换来匹配包装的自定义错误。Go
    通过 `errors` 包中的两个函数 `Is` 和 `As` 解决了这个问题。
- en: 'To check whether the returned error or any errors that it wraps match a specific
    sentinel error instance, use `errors.Is`. It takes in two parameters: the error
    being checked and the instance you are comparing it against. The `errors.Is` function
    returns `true` if any error in the error tree matches the provided sentinel error.
    You’ll write a short program to see `errors.Is` in action. You can run it yourself
    on [The Go Playground](https://oreil.ly/5_6rI) or in the *sample_code/is_error*
    directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查返回的错误或其包装的任何错误是否与特定的 sentinel 错误实例匹配，请使用 `errors.Is`。它接受两个参数：要检查的错误和要比较的实例。如果错误树中的任何错误与提供的
    sentinel 错误匹配，则 `errors.Is` 函数返回 `true`。您将编写一个简短的程序来演示 `errors.Is` 的工作原理。您可以在[Go
    Playground](https://oreil.ly/5_6rI)或[第 9 章存储库](https://oreil.ly/KCSeb)的 *sample_code/is_error*
    目录中运行它：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running this program produces the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序会产生以下输出：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, `errors.Is` uses `==` to compare each wrapped error with the specified
    error. If this does not work for an error type that you define (for example, if
    your error is a noncomparable type), implement the `Is` method on your error:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`errors.Is` 使用 `==` 比较每个包装错误与指定错误。如果对您定义的错误类型（例如，如果您的错误是非可比较类型），这种比较方式不起作用，请在您的错误上实现
    `Is` 方法：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (The `slices.Equal` function was mentioned back in [“Slices”](ch03.html#slice_info).)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （`slices.Equal` 函数在[“Slices”](ch03.html#slice_info)中已经提到。）
- en: 'Another use for defining your own `Is` method is to allow comparisons against
    errors that aren’t identical instances. You might want to pattern match your errors,
    specifying a filter instance that matches errors that have some of the same fields.
    Define a new error type, `ResourceErr`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自己的 `Is` 方法的另一个用途是允许与不完全相同实例的错误进行比较。您可能希望对错误进行模式匹配，指定一个过滤器实例来匹配具有部分相同字段的错误。定义一个新的错误类型，`ResourceErr`：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want two `ResourceErr` instances to match when either field is set,
    you can do so by writing a custom `Is` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望两个 `ResourceErr` 实例在任何字段设置时匹配，可以通过编写自定义的 `Is` 方法来实现：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now you can find, for example, all errors that refer to the database, no matter
    the code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以找到例如所有与数据库相关的错误，无论代码如何：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see this code on [The Go Playground](https://oreil.ly/Mz_Op) or in the
    *sample_code/cus⁠tom_is​_error_pattern_match* directory in the [Chapter 9 repository](https://oreil.ly/KCSeb).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Go Playground](https://oreil.ly/Mz_Op)或[第 9 章存储库](https://oreil.ly/KCSeb)的
    *sample_code/custom_is_error_pattern_match* 目录中查看此代码。
- en: 'The `errors.As` function allows you to check whether a returned error (or any
    error it wraps) matches a specific type. It takes in two parameters. The first
    is the error being examined, and the second is a pointer to a variable of the
    type that you are looking for. If the function returns `true`, an error in the
    error tree was found that matched, and that matching error is assigned to the
    second parameter. If the function returns `false`, no match was found in the error
    tree. Try it out with `MyErr`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`errors.As` 函数允许您检查返回的错误（或其包装的任何错误）是否与特定类型匹配。它接受两个参数。第一个参数是正在检查的错误，第二个参数是您要查找的类型的变量的指针。如果函数返回
    `true`，则在错误树中找到了匹配的错误，并且该匹配的错误被赋给第二个参数。如果函数返回 `false`，则在错误树中找不到匹配项。尝试使用 `MyErr`：'
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that you use `var` to declare a variable of a specific type set to the
    zero value. You then pass a pointer to this variable into `errors.As`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您使用 `var` 声明特定类型的变量，并将此变量的指针传递给 `errors.As`。
- en: 'You don’t have to pass a pointer to a variable of an error type as the second
    parameter to `errors.As`. You can pass a pointer to an interface to find an error
    that meets the interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必将错误类型的变量指针作为 `errors.As` 的第二个参数传递。您可以传递一个指向接口的指针，以找到符合接口的错误：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The example uses an anonymous interface, but any interface type is acceptable.
    You can find both `errors.As` examples in the *sample_code/custom_as_error* directory
    in the [Chapter 9 repository](https://oreil.ly/KCSeb).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例使用了匿名接口，但任何接口类型都可以。你可以在[第9章存储库](https://oreil.ly/KCSeb)的*sample_code/custom_as_error*目录中找到`errors.As`的两个示例。
- en: Warning
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If the second parameter to `errors.As` is anything other than a pointer to an
    error or a pointer to an interface, the method panics.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`errors.As`的第二个参数不是指向错误或接口的指针，则该方法会panic。
- en: Just as you can override the default `errors.Is` comparison with an `Is` method,
    you can override the default `errors.As` comparison with an `As` method on your
    error. Implementing an `As` method is nontrivial and requires reflection (I will
    talk about reflection in Go in [Chapter 16](ch16.html#unique_chapter_id_16)).
    You should do it only in unusual circumstances, such as when you want to match
    an error of one type and return another.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以通过`Is`方法覆盖默认的`errors.Is`比较一样，你也可以通过在你的错误上实现一个`As`方法来覆盖默认的`errors.As`比较。实现`As`方法是复杂的，并且需要反射（我将在第16章中讨论Go中的反射）。只有在不寻常的情况下才应该这样做，例如当你想匹配一种类型的错误并返回另一种类型时。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use `errors.Is` when you are looking for a specific *instance* or specific *values*.
    Use `errors.As` when you are looking for a specific *type*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你寻找特定*实例*或特定*值*时，请使用`errors.Is`。当你寻找特定*类型*时，请使用`errors.As`。
- en: Wrapping Errors with defer
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用defer包装错误
- en: 'Sometimes you find yourself wrapping multiple errors with the same message:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会发现自己用相同的消息包装多个错误：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can simplify this code by using `defer`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`defer`来简化这段代码：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You have to name the return values so that you can refer to `err` in the deferred
    function. If you name a single return value, you must name all of them, so you
    use an underscore here for the string return value that isn’t explicitly assigned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须给返回值命名，这样你才能在延迟函数中引用`err`。如果你给一个返回值命名，那么所有的返回值都必须命名，所以在这里你对未显式赋值的字符串返回值使用了下划线。
- en: In the `defer` closure, the code checks whether an error was returned. If so,
    it reassigns the error to a new error that wraps the original error with a message
    indicating which function detected the error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`defer`闭包中，代码会检查是否返回了错误。如果是这样，它会将错误重新赋值为一个新的错误，此错误会用一个消息包装原始错误，指示哪个函数检测到了错误。
- en: This pattern works well when you are wrapping every error with the same message.
    If you want to customize the wrapping error with more detail, put both the specific
    and the general message in every `fmt.Errorf`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个错误都用相同的消息包装时，这种模式效果很好。如果你想要用更多的细节定制包装错误，可以在每个`fmt.Errorf`中同时放置具体和一般的消息。
- en: panic and recover
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: panic和recover
- en: Previous chapters have mentioned panics in passing without going into any details
    on what they are. A *panic* is similar to an `Error` in Java or Python. It is
    a state generated by the Go runtime whenever it is unable to figure out what should
    happen next. This is almost always due to a programming error, like an attempt
    to read past the end of a slice or passing a negative size to `make`. The Go runtime
    also panics if it detects bugs in itself, such as the garbage collector misbehaving.
    However, I’ve never seen this happen. If there’s a panic, blame the runtime last.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节中提到过`panic`，但没有详细介绍它们是什么。*Panic* 类似于Java或Python中的`Error`。这是Go运行时在无法确定接下来应该发生什么时生成的一种状态。这几乎总是由于编程错误引起的，例如尝试读取超出切片末尾或将负大小传递给`make`。如果Go运行时检测到自身的错误，例如垃圾收集器的不当行为，它也会`panic`。但我从未见过这种情况发生。如果发生`panic`，最后责备运行时。
- en: As soon as a panic happens, the current function exits immediately, and any
    `defer`s attached to the current function start running. When those `defer`s complete,
    the `defer`s attached to the calling function run, and so on, until `main` is
    reached. The program then exits with a message and a stack trace.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生panic，当前函数立即退出，并且任何附加到当前函数的defer开始运行。当这些defer完成时，调用函数的defer运行，依此类推，直到达到`main`。然后程序以消息和堆栈跟踪退出。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If there is a panic in a goroutine other than the main goroutine (goroutines
    are covered in [“Goroutines”](ch12.html#goroutines)), the chain of defers ends
    at the function used to launch the goroutine. A program exits if *any* goroutine
    panics without being recovered.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了主goroutine之外的goroutine中发生了panic（goroutine在[“Goroutines”](ch12.html#goroutines)中介绍），则defer链以启动该goroutine的函数结束。如果*任何*goroutine发生了panic但未被recover，程序将退出。
- en: 'If any situations in your programs are unrecoverable, you can create your own
    panics. The built-in function `panic` takes one parameter, which can be of any
    type. Usually, it is a string. Following is a trivial program that panics; you
    can run it on [The Go Playground](https://oreil.ly/yCBib) or in the *sample_code/panic*
    directory in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序中有任何不可恢复的情况，您可以自行创建`panic`。内置函数`panic`接受一个参数，可以是任何类型。通常是一个字符串。以下是一个简单的会触发panic的程序；您可以在[Go
    Playground](https://oreil.ly/yCBib)上运行它，或者在[第9章存储库](https://oreil.ly/KCSeb)的*sample_code/panic*目录中运行它：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running this code produces the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, a `panic` prints out its message followed by a stack trace.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`panic`会打印出其消息，然后是堆栈跟踪。
- en: 'Go provides a way to capture a `panic` to provide a more graceful shutdown
    or to prevent shutdown at all. The built-in `recover` function is called from
    within a `defer` to check whether a `panic` happened. If there was a `panic`,
    the value assigned to the `panic` is returned. Once a `recover` happens, execution
    continues normally. Let’s take a look with another sample program. Run it on [The
    Go Playground](https://oreil.ly/f5Ybe) or in the *sample_code/panic_recover* directory
    in the [Chapter 9 repository](https://oreil.ly/KCSeb):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一种捕获`panic`的方法，以提供更优雅的关闭或防止关闭。内置的`recover`函数是从`defer`中调用的，用于检查是否发生了`panic`。如果有`panic`，则返回给`panic`赋的值。一旦发生`recover`，执行会正常继续。让我们看看另一个示例程序。在[Go
    Playground](https://oreil.ly/f5Ybe)上运行它，或者在[第9章存储库](https://oreil.ly/KCSeb)的*sample_code/panic_recover*目录中运行它：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There’s a specific pattern for using `recover`. You register a function with
    `defer` to handle a potential `panic`. You call `recover` within an `if` statement
    and check whether a non-nil value was found. You must call `recover` from within
    a `defer` because once a `panic` happens, only deferred functions are run.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`recover`有一个特定的模式。您可以使用`defer`注册一个函数来处理可能的`panic`。在`if`语句中调用`recover`，并检查是否找到了非nil值。您必须在`defer`中调用`recover`，因为一旦发生`panic`，只有延迟函数会运行。
- en: 'Running this code produces the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Since `recover` uses a non-nil value to detect whether a `panic` happened,
    a clever reader might raise the question: *What happens if you call `panic(nil)`
    and there’s a `recover`?* In code compiled with Go versions before 1.21, the answer
    was “nothing great.” In those versions, `recover` stops a `panic` from propagating,
    but no message or data indicates what happened. Starting with Go 1.21, a `panic(nil)`
    call is identical to `panic(new(runtime.PanicNilError))`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`recover`使用非nil值来检测是否发生了`panic`，聪明的读者可能会提出一个问题：*如果您调用`panic(nil)`并且有一个`recover`会发生什么？*在Go版本1.21之前编译的代码中，答案是“没有什么了不起的事情。”在这些版本中，`recover`会停止`panic`的传播，但没有消息或数据表明发生了什么。从Go
    1.21开始，`panic(nil)`的调用与`panic(new(runtime.PanicNilError))`相同。
- en: While `panic` and `recover` look a lot like exception handling in other languages,
    they are not intended to be used that way. Reserve panics for fatal situations
    and use `recover` as a way to gracefully handle these situations. If your program
    panics, be careful about trying to continue executing after the panic. You’ll
    rarely want to keep your program running after a `panic` occurs. If the `panic`
    was triggered because the computer is out of a resource like memory or disk space,
    the safest thing to do is use `recover` to log the situation to monitoring software
    and shut down with `os.Exit(1)`. If a programming error caused the panic, you
    can try to continue, but you’ll likely hit the same problem again. In the preceding
    sample program, it would be idiomatic to check for division by zero and return
    an error if one was passed in.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`panic`和`recover`看起来很像其他语言中的异常处理，但它们不打算这样使用。保留`panic`用于致命情况，并使用`recover`作为优雅处理这些情况的一种方式。如果您的程序发生了panic，请小心尝试在panic发生后继续执行。在计算机由于内存或磁盘空间等资源不足而触发`panic`时，最安全的做法是使用`recover`将情况记录到监控软件并使用`os.Exit(1)`关闭。如果程序错误导致了panic，您可以尝试继续执行，但很可能会再次遇到相同的问题。在上述示例程序中，如果出现除以零，则检查并返回错误是惯用的做法。
- en: The reason you don’t rely on `panic` and `recover` is that `recover` doesn’t
    make clear *what* could fail. It just ensures that *if* something fails, you can
    print out a message and continue. Idiomatic Go favors code that explicitly outlines
    the possible failure conditions over shorter code that handles anything while
    saying nothing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你不依赖于`panic`和`recover`的原因是`recover`不清楚*什么*可能失败。它只是确保*如果*某事失败，你可以打印出一条消息并继续。惯用的Go代码偏爱明确列出可能的失败条件的代码，而不是处理任何事情但什么都不说的短代码。
- en: Using `recover` is recommended in one situation. If you are creating a library
    for third parties, do not let panics escape the boundaries of your public API.
    If a `panic` is possible, a public function should use `recover` to convert the
    `panic` into an error, return it, and let the calling code decide what to do with
    them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个情况下推荐使用`recover`。如果你正在为第三方创建库，请不要让`panic`逃离公共API的边界。如果可能发生`panic`，公共函数应该使用`recover`将`panic`转换为错误，返回它，并让调用代码决定如何处理它们。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While the HTTP server built into Go recovers from panics in handlers, David
    Symonds said in a [GitHub comment](https://oreil.ly/BGOmg) that as of 2015, this
    is now considered a mistake by the Go team.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然内置在Go中的HTTP服务器在处理程序中恢复了panic，但戴维·西蒙兹在[GitHub评论](https://oreil.ly/BGOmg)中说，截至2015年，Go团队认为这是一个错误。
- en: Getting a Stack Trace from an Error
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从错误获取堆栈跟踪
- en: One of the reasons that new Go developers are tempted to use `panic` and `recover`
    is they want to get a stack trace when something goes wrong. By default, Go doesn’t
    provide that. As I’ve shown, you can use error wrapping to build a call stack
    by hand, but some third-party libraries with error types generate those stacks
    automatically (see [Chapter 10](ch10.html#unique_chapter_id_10) to learn how to
    incorporate third-party code in your program). Cockroachdb provides a [third-party
    library](https://oreil.ly/-n1EX) with functions for wrapping errors with stack
    traces.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新Go开发人员倾向于使用`panic`和`recover`的原因之一是他们希望在出现问题时获得堆栈跟踪。默认情况下，Go不提供这个功能。如我所示，你可以使用错误包装手动构建调用堆栈，但一些第三方带有错误类型的库会自动生成这些堆栈（参见[第10章](ch10.html#unique_chapter_id_10)了解如何将第三方代码整合到你的程序中）。Cockroachdb提供了一个[第三方库](https://oreil.ly/-n1EX)，其中包含用于带堆栈跟踪的错误包装的函数。
- en: By default, the stack trace is not printed out. If you want to see the stack
    trace, use `fmt.Printf` and the verbose output verb (`%+v`). Check the [documentation](https://oreil.ly/3-5Ql)
    to learn more.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，不会打印出堆栈跟踪。如果想看到堆栈跟踪，请使用`fmt.Printf`和详细输出动词（`%+v`）。查阅[文档](https://oreil.ly/3-5Ql)了解更多信息。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you have a stack trace in your error, the output includes the full path
    to the file on the computer where the program was compiled. If you don’t want
    to expose the path, use the `-trimpath` flag when building your code. This replaces
    the full path with the package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的错误中有一个堆栈跟踪时，输出会包含程序编译时计算机上文件的完整路径。如果不想暴露路径，构建代码时请使用`-trimpath`标志。这会用包名替换完整路径。
- en: Exercises
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Look at the code in the *sample_code/exercise* directory in the [Chapter 9 repository](https://oreil.ly/KCSeb).
    You are going to modify this code in each of these exercises. It works correctly,
    but improvements should be made to its error handling.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看*sample_code/exercise*目录中[第9章存储库](https://oreil.ly/KCSeb)中的代码。你将在每个练习中修改这些代码。它的功能是正确的，但应改进其错误处理。
- en: Create a sentinel error to represent an invalid ID. In `main`, use `errors.Is`
    to check for the sentinel error, and print a message when it is found.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个哨兵错误来表示无效的ID。在`main`中，使用`errors.Is`检查哨兵错误，并在发现时打印消息。
- en: Define a custom error type to represent an empty field error. This error should
    include the name of the empty `Employee` field. In `main`, use `errors.As` to
    check for this error. Print out a message that includes the field name.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个自定义错误类型来表示空字段错误。此错误应包括空`Employee`字段的名称。在`main`中，使用`errors.As`检查此错误。打印一个包含字段名的消息。
- en: Rather than returning the first error found, return back a single error that
    contains all errors discovered during validation. Update the code in `main` to
    properly report multiple errors.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是返回发现的第一个错误，返回一个包含所有验证期间发现的错误的单个错误。更新`main`中的代码，正确报告多个错误。
- en: Wrapping Up
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束
- en: This chapter covered errors in Go, what they are, how to define your own, and
    how to examine them. You also took a look at `panic` and `recover`. The next chapter
    discusses packages and modules, how to use third-party code in your programs,
    and how to publish your own code for others to use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Go 语言中的错误，它们是什么，如何定义自己的错误，以及如何检查它们。您还学习了`panic`和`recover`。下一章将讨论包和模块，如何在程序中使用第三方代码，以及如何发布您自己的代码供他人使用。
