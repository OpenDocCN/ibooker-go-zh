- en: 'Appendix B. six things we didn’t cover: Leftovers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](assets/f0495-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**We’ve covered a lot of ground, and you’re almost finished with this book.**
    We’ll miss you, but before we let you go, we wouldn’t feel right about sending
    you out into the world without a *little* more preparation. We’ve saved six important
    topics for this appendix.'
  prefs: []
  type: TYPE_NORMAL
- en: '#1 Initialization statements for “if”'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we have a `saveString` function that returns a single `error` value (or
    `nil` if there was no error). In our `main` function, we might store that return
    value in an `err` variable before handling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0496-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Now suppose we added another call to `saveString` in `main` that also uses an
    `err` variable. We have to remember to make the first use of `err` a short variable
    declaration, and change later uses to assignments. Otherwise, we’ll get a compile
    error for attempting to redeclare a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0496-02.png)'
  prefs: []
  type: TYPE_IMG
- en: But really, we’re only using the `err` variable within the `if` statement and
    its block. What if there was a way to limit the scope of the variable, so that
    we could treat each occurrence as a separate variable?
  prefs: []
  type: TYPE_NORMAL
- en: Remember when we first covered `for` loops, back in [Chapter 2](ch02.html#which_code_runs_nextquestcolon_condition)?
    We said they could include an initialization statement, where you initialize variables.
    Those variables were only in scope within the `for` loop’s block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0496-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar to `for` loops, Go allows you to add an initialization statement before
    the condition in `if` statements. Initialization statements are usually used to
    initialize one or more variables for use within the `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0497-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The scope of variables declared within an initialization statement is limited
    to that `if` statement’s conditional expression and its block. If we rewrite our
    previous sample to use `if` initialization statements, the scope of each `err`
    variable will be limited to the `if` statement conditional and block, meaning
    we’ll have two completely separate `err` variables. We won’t have to worry about
    which one is defined first.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0497-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This limitation on scope cuts both ways. If a function has multiple return values,
    and you need one of them *inside* the `if` statement and one *outside*, you probably
    won’t be able to call it in an `if` initialization statement. If you try, you’ll
    find the value you need outside the `if` block is out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0497-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead, you’ll need to call the function prior to the `if` statement, as normal,
    so that its return values are in scope both inside *and* outside the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0497-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '#2 The switch statement'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to take one of several actions based on the value of an expression,
    it can lead to a mess of `if` statements and `else` clauses. The `switch` statement
    is a more efficient way to express these choices.
  prefs: []
  type: TYPE_NORMAL
- en: You write the `switch` keyword, followed by a condition expression. Then you
    add several `case` expressions, each with a possible value the condition expression
    could have. The first `case` whose value matches the condition expression is selected,
    and the code it contains is run. The other `case` expressions are ignored. You
    can also provide a `default` statement which will be run if no `case` matches.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a reimplementation of a code sample that we wrote with `if` and `else`
    statements in [Chapter 12](ch12.html#back_on_your_feetcolon_recovering_from_f).
    This version requires significantly less code. For our `switch` condition, we
    select a random number from `1` to `3`. We provide `case` expressions for each
    of those values, each of which prints a different message. To alert us to the
    theoretically impossible situation where no `case` matches, we also provide a
    `default` statement that panics.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0498-01.png)'
  prefs: []
  type: TYPE_IMG
- en: there are no Dumb Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Q: I’ve seen other languages where you have to provide a “break” statement
    at the end of each `case`, or it will run the next `case`’s code as well. Does
    Go not require this?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** Developers have a history of forgetting the “break” statement in other
    languages, resulting in bugs. To help avoid this, Go automatically exits the `switch`
    at the end of a `case`’s code.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a `fallthrough` keyword you can use in a case, if you *do* want the
    next case’s code to run as well.
  prefs: []
  type: TYPE_NORMAL
- en: '#3 More basic types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has additional basic types that we haven’t had space to talk about. You probably
    won’t have reason to use these in your own projects, but you’ll encounter them
    in some libraries, so it’s best to be aware they exist.
  prefs: []
  type: TYPE_NORMAL
- en: '| Types | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int8 int16 int32 int64` | These hold integers, just like `int`, but they’re
    a specific size in memory (the number in the type name specifies the size in bits).
    Fewer bits consume less RAM or other storage; more bits mean larger numbers can
    be stored. You should use `int` unless you have a specific reason to use one of
    these; it’s more efficient. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | This is just like `int`, but it holds only *unsigned* integers;
    it can’t hold negative numbers. This means you can fit larger numbers into the
    same amount of memory, as long as you’re certain the values will never be negative.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8 uint16 uint32 uint64` | These also hold unsigned integers, but like
    the `int` variants, they consume a specific number of bits in memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | The `float64` type holds floating-point numbers and consumes
    64 bits of memory. This is its smaller 32-bit cousin. (There are no 8-bit or 16-bit
    variants for floating-point numbers.) |'
  prefs: []
  type: TYPE_TB
- en: '#4 More about runes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced runes very briefly back in [Chapter 1](ch01.html#letapsos_get_going_syntax_basics),
    and we haven’t talked about them since. But we don’t want to end the book without
    going into a little more detail about them...
  prefs: []
  type: TYPE_NORMAL
- en: Back in the days before modern operating systems, most computing was done using
    the unaccented English alphabet, with its 26 letters (in upper- and lowercase).
    There were so few of them, a character could be represented by a single byte (with
    1 bit to spare). A standard called ASCII was used to ensure the same byte value
    was converted to the same letter on different systems.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, the English alphabet isn’t the only writing system in the world;
    there are many others, some with thousands of different characters. The Unicode
    standard is an attempt to create one set of *4-byte* values that can represent
    every character in every one of these different writing systems (and many other
    characters besides).
  prefs: []
  type: TYPE_NORMAL
- en: Go uses values of the `rune` type to represent Unicode values. Usually, one
    rune represents one character. (There are exceptions, but those are beyond the
    scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: Go uses UTF-8, a standard that represents Unicode characters using 1 to 4 bytes
    each. Characters from the old ASCII set can still be represented using a single
    byte; other characters may require anywhere from 2 to 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Here are two strings, one with letters from the English alphabet, and one with
    letters from the Russian alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0500-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Generally, you don’t need to worry about the details of how characters are
    stored. That is, *until* you try to convert strings to their component bytes and
    back. If we try to call the `len` function with our two strings, for example,
    we get very different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0500-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a string to the `len` function, it returns the length in *bytes*,
    not *runes*. The English alphabet string fits into 5 bytes—each rune requires
    just 1 byte because it’s from the old ASCII character set. But the Russian alphabet
    string takes 10 bytes—each rune requires 2 bytes to store.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the length of a string in *characters*, you should instead use the
    `unicode/utf8` package’s `RuneCountInString` function. This function will return
    the correct number of characters, regardless of the number of bytes used to store
    each one.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0500-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Working with partial strings safely means converting the string to runes,
    not bytes.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Previously in the book, we’ve had to convert strings to slices of bytes so we
    could write them to an HTTP response or to the terminal. This works fine, as long
    as you make sure to write *all* the bytes in the resulting slice. But if you try
    to work with just *part* of the bytes, you’re asking for trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s some code that attempts to strip the first three characters from the
    previous strings. We convert each string to a slice of bytes, then use the slice
    operator to gather everything from the fourth element to the end of the slice.
    Then we convert the partial byte slices back to strings and print them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0501-01.png)'
  prefs: []
  type: TYPE_IMG
- en: This works fine with the English alphabet characters, which each take up 1 byte.
    But the Russian characters each take *2 bytes*. Cutting off the first 3 bytes
    of that string omits only the first character, and “half” of the second, resulting
    in an unprintable character.
  prefs: []
  type: TYPE_NORMAL
- en: Go supports converting from strings to slices of `rune` values, and from slices
    of runes back to strings. To work with partial strings, you should convert them
    to a slice of `rune` values rather than a slice of `byte` values. That way, you
    won’t accidentally grab just part of the bytes for a rune.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an update to the previous code that converts the strings to slices of
    runes instead of slices of bytes. Our slice operators now omit the first three
    *runes* from each slice, rather than the first *3 bytes*. When we convert the
    partial slices to strings and print them, we get only the last two (complete)
    characters from each.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0501-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll encounter similar problems if you try to use a slice of bytes to process
    each character of a string. Processing 1 byte at a time will work as long as your
    strings are all characters from the ASCII set. But as soon as a character comes
    along that requires 2 or more bytes, you’ll find yourself working with just part
    of the bytes for a rune again.
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a `for ... range` loop to print the English alphabet characters,
    1 byte per character. Then it tries to do the same with the Russian alphabet characters,
    1 byte per character—which fails because each of these characters requires 2 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0502-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Go allows you to use a `for...range` loop on a string, which will process a
    *rune* at a time, not a *byte* at a time. This is a much safer approach. The first
    variable you provide will be assigned the current byte index (not the rune index)
    within the string. The second variable will be assigned the current rune.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an update to the above code that uses a `for...range` loop to process
    the strings themselves, not their byte representations. You can see from the indexes
    in the output that 1 byte at a time is being processed for the English characters,
    but *2 bytes* at a time are being processed for the Russian characters.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0502-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Go’s runes make it easy to work with partial strings and not have to worry about
    whether they contain Unicode characters or not. Just remember, anytime you want
    to work with just part of a string, convert it to runes, not bytes!
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Buffered channels'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of Go channels: *unbuffered* and *buffered*.'
  prefs: []
  type: TYPE_NORMAL
- en: All the channels we’ve shown you so far have been unbuffered. When a goroutine
    sends a value on an unbuffered channel, it immediately blocks until another goroutine
    receives the value. Buffered channels, on the other hand, can hold a certain number
    of values before causing the sending goroutine to block. Under the right circumstances,
    this can improve a program’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a channel, you can make a buffered channel by passing a second
    argument to `make` with the number of values the channel should be able to hold
    in its buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0503-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When a goroutine sends a value via the channel, that value is added to the buffer.
    Instead of blocking, the sending goroutine continues running.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0503-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The sending goroutine can continue sending values on the channel until the buffer
    is full; only then will an additional send operation cause the goroutine to block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0503-03.png)'
  prefs: []
  type: TYPE_IMG
- en: When another goroutine receives a value from the channel, it pulls the earliest-added
    value from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0503-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Additional receive operations will continue to empty the buffer, while additional
    sends will fill the buffer back up.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0503-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s try running a program with an unbuffered channel, and then change it to
    a buffered channel so you can see the difference. Below, we define a `sendLetters`
    function to run as a goroutine. It sends four values to a channel, sleeping 1
    second before each value. In `main`, we create an unbuffered channel and pass
    it to `sendLetters`. Then we put the `main` goroutine to sleep for 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0504-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When the `main` goroutine wakes up, it receives four values from the channel.
    But the `sendLetters` goroutine was blocked, waiting for `main` to receive the
    first value. So the `main` goroutine has to wait 1 second between each remaining
    value while the `sendLetters` goroutine catches back up.
  prefs: []
  type: TYPE_NORMAL
- en: We can speed our program up a bit simply by adding a single-value buffer to
    the channel.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do is add a second argument when calling `make`. Interactions
    with the channel are otherwise identical, so we don’t have to make any other changes
    to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when `sendLetters` sends its first value to the channel, it doesn’t block
    until the `main` goroutine receives it. The sent value goes in the channel’s buffer
    instead. It’s only when the second value is sent (and none have yet been received)
    that the channel’s buffer is filled and the `sendLetters` goroutine blocks. Adding
    a one-value buffer to the channel shaves 1 second off the program’s run time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0505-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Increasing the buffer size to `3` allows the `sendLetters` goroutine to send
    three values without blocking. It blocks on the final send, but this is after
    all of its 1-second `Sleep` calls have completed. So when the `main` goroutine
    wakes up after 5 seconds, it immediately receives the three values waiting in
    the buffered channel, as well as the value that caused `sendLetters` to block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/f0505-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This allows the program to complete in only 5 seconds!
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Further reading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the end of the book. But it’s just the beginning of your journey as
    a Go programmer. We want to recommend a few resources that will help you along
    the road.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Head First Go Website***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://headfirstgo.com/](https://headfirstgo.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: The official website for this book. Here you can download all our code samples,
    practice with additional exercises, and learn about new topics, all written in
    the same easy-to-read, incredibly witty prose!
  prefs: []
  type: TYPE_NORMAL
- en: '***A Tour of Go***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://tour.golang.org](https://tour.golang.org)*'
  prefs: []
  type: TYPE_NORMAL
- en: This is an interactive tutorial on Go’s basic features. It covers much the same
    material as this book, but includes some additional details. Examples in the Tour
    can be edited and run right from your browser (just like in the Go Playground).
  prefs: []
  type: TYPE_NORMAL
- en: '***Effective Go***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: A guide maintained by the Go team on how to write idiomatic Go code (that is,
    code that follows community conventions).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Go Blog***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://blog.golang.org](https://blog.golang.org)*'
  prefs: []
  type: TYPE_NORMAL
- en: The official Go blog. Offers helpful articles on using Go and announcements
    of new Go versions and features.
  prefs: []
  type: TYPE_NORMAL
- en: '***Package Documentation***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://golang.org/pkg/](https://golang.org/pkg/)*'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on all the standard packages. These are the same docs available
    through the `go doc` command, but all the libraries are in one convenient list
    for browsing. The `encoding/json`, `image`, and `io/ioutil` packages might be
    interesting places to start.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Go Programming Language***'
  prefs: []
  type: TYPE_NORMAL
- en: '*[https://www.gopl.io/](https://www.gopl.io/)*'
  prefs: []
  type: TYPE_NORMAL
- en: This book is the only resource on this page that isn’t free, but it’s worth
    it. It’s well known and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of technical books out there: tutorial books (like the
    one you’re holding) and reference books (like *The Go Programming Language*).
    And it’s a great reference: it covers all the topics we didn’t have room for in
    this book. If you’re going to continue using Go, this is a must-read.'
  prefs: []
  type: TYPE_NORMAL
