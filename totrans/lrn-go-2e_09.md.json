["```go\nfunc calcRemainderAndMod(numerator, denominator int) (int, int, error) {\n    if denominator == 0 {\n        return 0, 0, errors.New(\"denominator is 0\")\n    }\n    return numerator / denominator, numerator % denominator, nil\n}\n```", "```go\nfunc main() {\n    numerator := 20\n    denominator := 3\n    remainder, mod, err := calcRemainderAndMod(numerator, denominator)\n    if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n    fmt.Println(remainder, mod)\n}\n```", "```go\ntype error interface {\n    Error() string\n}\n```", "```go\nfunc doubleEven(i int) (int, error) {\n    if i % 2 != 0 {\n        return 0, errors.New(\"only even numbers are processed\")\n    }\n    return i * 2, nil\n}\n\nfunc main() {\n    result, err := doubleEven(1)\n    if err != nil {\n        fmt.Println(err) // prints \"only even numbers are processed\"\n    }\n    fmt.Println(result)\n}\n```", "```go\nfunc doubleEven(i int) (int, error) {\n    if i % 2 != 0 {\n        return 0, fmt.Errorf(\"%d isn't an even number\", i)\n    }\n    return i * 2, nil\n}\n```", "```go\nfunc main() {\n    data := []byte(\"This is not a zip file\")\n    notAZipFile := bytes.NewReader(data)\n    _, err := zip.NewReader(notAZipFile, int64(len(data)))\n    if err == zip.ErrFormat {\n        fmt.Println(\"Told you so\")\n    }\n}\n```", "```go\ntype Status int\n\nconst (\n    InvalidLogin Status = iota + 1\n    NotFound\n)\n```", "```go\ntype StatusErr struct {\n    Status    Status\n    Message   string\n}\n\nfunc (se StatusErr) Error() string {\n    return se.Message\n}\n```", "```go\nfunc LoginAndGetData(uid, pwd, file string) ([]byte, error) {\n    token, err := login(uid, pwd)\n    if err != nil {\n        return nil, StatusErr{\n            Status:    InvalidLogin,\n            Message: fmt.Sprintf(\"invalid credentials for user %s\", uid),\n        }\n    }\n    data, err := getData(token, file)\n    if err != nil {\n        return nil, StatusErr{\n            Status:    NotFound,\n            Message: fmt.Sprintf(\"file %s not found\", file),\n        }\n    }\n    return data, nil\n}\n```", "```go\nfunc GenerateErrorBroken(flag bool) error {\n    var genErr StatusErr\n    if flag {\n        genErr = StatusErr{\n            Status: NotFound,\n        }\n    }\n    return genErr\n}\n\nfunc main() {\n    err := GenerateErrorBroken(true)\n    fmt.Println(\"GenerateErrorBroken(true) returns non-nil error:\", err != nil)\n    err = GenerateErrorBroken(false)\n    fmt.Println(\"GenerateErrorBroken(false) returns non-nil error:\", err != nil)\n}\n```", "```go\ntrue\ntrue\n```", "```go\nfunc GenerateErrorOKReturnNil(flag bool) error {\n    if flag {\n        return StatusErr{\n            Status: NotFound,\n        }\n    }\n    return nil\n}\n```", "```go\nfunc GenerateErrorUseErrorVar(flag bool) error {\n    var genErr error\n    if flag {\n        genErr = StatusErr{\n            Status: NotFound,\n        }\n    }\n    return genErr\n}\n```", "```go\nfunc fileChecker(name string) error {\n    f, err := os.Open(name)\n    if err != nil {\n        return fmt.Errorf(\"in fileChecker: %w\", err)\n    }\n    f.Close()\n    return nil\n}\n\nfunc main() {\n    err := fileChecker(\"not_here.txt\")\n    if err != nil {\n        fmt.Println(err)\n        if wrappedErr := errors.Unwrap(err); wrappedErr != nil {\n            fmt.Println(wrappedErr)\n        }\n    }\n}\n```", "```go\nin fileChecker: open not_here.txt: no such file or directory\nopen not_here.txt: no such file or directory\n```", "```go\ntype StatusErr struct {\n    Status  Status\n    Message string\n    Err     error\n}\n\nfunc (se StatusErr) Error() string {\n    return se.Message\n}\n\nfunc (se StatusErr) Unwrap() error {\n    return se.Err\n}\n```", "```go\nfunc LoginAndGetData(uid, pwd, file string) ([]byte, error) {\n    token, err := login(uid,pwd)\n    if err != nil {\n        return nil, StatusErr {\n            Status: InvalidLogin,\n            Message: fmt.Sprintf(\"invalid credentials for user %s\",uid),\n            Err: err,\n        }\n    }\n    data, err := getData(token, file)\n    if err != nil {\n        return nil, StatusErr {\n            Status: NotFound,\n            Message: fmt.Sprintf(\"file %s not found\",file),\n            Err: err,\n        }\n    }\n    return data, nil\n}\n```", "```go\nerr := internalFunction()\nif err != nil {\n    return fmt.Errorf(\"internal failure: %v\", err)\n}\n```", "```go\ntype Person struct {\n    FirstName string\n    LastName  string\n    Age       int\n}\n\nfunc ValidatePerson(p Person) error {\n    var errs []error\n    if len(p.FirstName) == 0 {\n        errs = append(errs, errors.New(\"field FirstName cannot be empty\"))\n    }\n    if len(p.LastName) == 0 {\n        errs = append(errs, errors.New(\"field LastName cannot be empty\"))\n    }\n    if p.Age < 0 {\n        errs = append(errs, errors.New(\"field Age cannot be negative\"))\n    }\n    if len(errs) > 0 {\n        return errors.Join(errs...)\n    }\n    return nil\n}\n```", "```go\nerr1 := errors.New(\"first error\")\nerr2 := errors.New(\"second error\")\nerr3 := errors.New(\"third error\")\nerr := fmt.Errorf(\"first: %w, second: %w, third: %w\", err1, err2, err3)\n```", "```go\ntype MyError struct {\n    Code   int\n    Errors []error\n}\n\ntype (m MyError) Error() string {\n    return errors.Join(m.Errors...).Error()\n}\n\nfunc (m MyError) Unwrap() []error {\n    return m.Errors\n}\n```", "```go\nvar err error\nerr = funcThatReturnsAnError()\nswitch err := err.(type) {\ncase interface {Unwrap() error}:\n    // handle single error\n    innerErr := err.Unwrap()\n    // process innerErr\ncase interface {Unwrap() []error}:\n    //handle multiple wrapped errors\n    innerErrs := err.Unwrap()\n    for _, innerErr := range innerErrs {\n        // process each innerErr\n    }\ndefault:\n    // handle no wrapped error\n}\n```", "```go\nfunc fileChecker(name string) error {\n    f, err := os.Open(name)\n    if err != nil {\n        return fmt.Errorf(\"in fileChecker: %w\", err)\n    }\n    f.Close()\n    return nil\n}\n\nfunc main() {\n    err := fileChecker(\"not_here.txt\")\n    if err != nil {\n        if errors.Is(err, os.ErrNotExist) {\n            fmt.Println(\"That file doesn't exist\")\n        }\n    }\n}\n```", "```go\nThat file doesn't exist\n```", "```go\ntype MyErr struct {\n    Codes []int\n}\n\nfunc (me MyErr) Error() string {\n    return fmt.Sprintf(\"codes: %v\", me.Codes)\n}\n\nfunc (me MyErr) Is(target error) bool {\n    if me2, ok := target.(MyErr); ok {\n        return slices.Equal(me.Codes, me2.Codes)\n    }\n    return false\n}\n```", "```go\ntype ResourceErr struct {\n    Resource     string\n    Code         int\n}\n\nfunc (re ResourceErr) Error() string {\n    return fmt.Sprintf(\"%s: %d\", re.Resource, re.Code)\n}\n```", "```go\nfunc (re ResourceErr) Is(target error) bool {\n    if other, ok := target.(ResourceErr); ok {\n        ignoreResource := other.Resource == \"\"\n        ignoreCode := other.Code == 0\n        matchResource := other.Resource == re.Resource\n        matchCode := other.Code == re.Code\n        return matchResource && matchCode ||\n            matchResource && ignoreCode ||\n            ignoreResource && matchCode\n    }\n    return false\n}\n```", "```go\nif errors.Is(err, ResourceErr{Resource: \"Database\"}) {\n    fmt.Println(\"The database is broken:\", err)\n    // process the codes\n}\n```", "```go\nerr := AFunctionThatReturnsAnError()\nvar myErr MyErr\nif errors.As(err, &myErr) {\n    fmt.Println(myErr.Codes)\n}\n```", "```go\nerr := AFunctionThatReturnsAnError()\nvar coder interface {\n    CodeVals() []int\n}\nif errors.As(err, &coder) {\n    fmt.Println(coder.CodeVals())\n}\n```", "```go\nfunc DoSomeThings(val1 int, val2 string) (string, error) {\n    val3, err := doThing1(val1)\n    if err != nil {\n        return \"\", fmt.Errorf(\"in DoSomeThings: %w\", err)\n    }\n    val4, err := doThing2(val2)\n    if err != nil {\n        return \"\", fmt.Errorf(\"in DoSomeThings: %w\", err)\n    }\n    result, err := doThing3(val3, val4)\n    if err != nil {\n        return \"\", fmt.Errorf(\"in DoSomeThings: %w\", err)\n    }\n    return result, nil\n}\n```", "```go\nfunc DoSomeThings(val1 int, val2 string) (_ string, err error) {\n    defer func() {\n        if err != nil {\n            err = fmt.Errorf(\"in DoSomeThings: %w\", err)\n        }\n    }()\n    val3, err := doThing1(val1)\n    if err != nil {\n        return \"\", err\n    }\n    val4, err := doThing2(val2)\n    if err != nil {\n        return \"\", err\n    }\n    return doThing3(val3, val4)\n}\n```", "```go\nfunc doPanic(msg string) {\n    panic(msg)\n}\n\nfunc main() {\n    doPanic(os.Args[0])\n}\n```", "```go\npanic: /tmpfs/play\n\ngoroutine 1 [running]:\nmain.doPanic(...)\n    /tmp/sandbox567884271/prog.go:6\nmain.main()\n    /tmp/sandbox567884271/prog.go:10 +0x5f\n```", "```go\nfunc div60(i int) {\n    defer func() {\n        if v := recover(); v != nil {\n            fmt.Println(v)\n        }\n    }()\n    fmt.Println(60 / i)\n}\n\nfunc main() {\n    for _, val := range []int{1, 2, 0, 6} {\n        div60(val)\n    }\n}\n```", "```go\n60\n30\nruntime error: integer divide by zero\n10\n```"]