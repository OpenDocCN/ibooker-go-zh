["```go\nfunc HasDuplicates[T comparable](slice ...T) bool {\n    dup := make(map[T]any, len(slice))\n    for _, s := range slice {\n        if _, ok := dup[s]; ok {\n            return true\n        }\n        dup[s] = \"whatever, I don't use this value\"\n    }\n    return false\n}\n\nfunc HasDuplicates2[T comparable](slice ...T) bool {\n    dup := make(map[T]struct{}, len(slice))\n    for _, s := range slice {\n        if _, ok := dup[s]; ok {\n            return true\n        }\n        dup[s] = struct{}{} ![1](assets/1.png)\n    }\n    return false\n}\n```", "```go\nfunc ComplexComputation() int { ![1](assets/1.png)\n    // Some computation...\n\n    // Some cleanup...\n    return 4\n}\n\nfunc Handle_VeryWrong(w http.ResponseWriter, r *http.Request) {\n    respCh := make(chan int)\n\n    go func() { ![2](assets/2.png)\n        defer close(respCh) ![3](assets/3.png)\n        respCh <- ComplexComputation()\n    }()\n\n    select { ![4](assets/4.png)\n    case <-r.Context().Done():\n        return ![5](assets/5.png)\n    case resp := <-respCh:\n        _, _ = w.Write([]byte(strconv.Itoa(resp)))\n        return\n    }\n}\n```", "```go\nfunc TestHandleCancel(t *testing.T) { ![1](assets/1.png)\n    defer goleak.VerifyNone(t) ![2](assets/2.png)\n\n    w := httptest.NewRecorder()\n    r := httptest.NewRequest(\"\", \"https://efficientgo.com\", nil)\n\n    wg := sync.WaitGroup{}\n    wg.Add(1)\n\n    ctx, cancel := context.WithCancel(context.Background())\n    go func() {\n        Handle_VeryWrong(w, r.WithContext(ctx))\n        wg.Done()\n    }()\n    cancel()\n\n    wg.Wait()\n}\n```", "```go\n=== RUN   TestHandleCancel\n    leaks.go:78: found unexpected goroutines:\n        [Goroutine 8 in state sleep, with time.Sleep on top of the stack:\n        goroutine 8 [sleep]: ![1](assets/1.png)\n        time.Sleep(0x3b9aca00)\n           /go1.18.3/src/runtime/time.go:194 +0x12e\n        github.com/efficientgo/examples/pkg/leak.ComplexComputation()\n           /examples/pkg/leak/leak_test.go:107 +0x1e\n        github.com/efficientgo/examples/pkg/leak.Handle_VeryWrong.func1()\n           /examples/pkg/leak/leak_test.go:117 +0x5d\n        created by github.com/efficientgo/examples/pkg/leak.Handle_VeryWrong\n           /examples/pkg/leak/leak_test.go:115 +0x7d\n        ]\n--- FAIL: TestHandleCancel (0.44s)\n=== RUN   TestHandleCancel\n    leaks.go:78: found unexpected goroutines:\n        [Goroutine 21 in state chan send, with Handle_VeryWrong.func1 (...):\n        goroutine 21 [chan send]: ![2](assets/2.png)\n        github.com/efficientgo/examples/pkg/leak.Handle_VeryWrong.func1()\n           /examples/pkg/leak/leak_test.go:117 +0x71\n        created by github.com/efficientgo/examples/pkg/leak.Handle_VeryWrong\n           /examples/pkg/leak/leak_test.go:115 +0x7d\n        ]\n--- FAIL: TestHandleCancel (3.44s)\n```", "```go\nfunc Handle_Wrong(w http.ResponseWriter, r *http.Request) {\n    respCh := make(chan int, 1) ![1](assets/1.png)\n\n    go func() {\n        defer close(respCh)\n        respCh <- ComplexComputation()\n    }()\n\n    select {\n    case <-r.Context().Done():\n        return\n    case resp := <-respCh:\n        _, _ = w.Write([]byte(strconv.Itoa(resp)))\n        return\n    }\n}\n\nfunc Handle_AlsoWrong(w http.ResponseWriter, r *http.Request) {\n    respCh := make(chan int, 1)\n\n    go func() {\n        defer close(respCh)\n        respCh <- ComplexComputationWithCtx(r.Context()) ![2](assets/2.png)\n    }()\n\n    select {\n    case <-r.Context().Done():\n        return\n    case resp := <-respCh:\n        _, _ = w.Write([]byte(strconv.Itoa(resp)))\n        return\n    }\n}\n\nfunc ComplexComputationWithCtx(ctx context.Context) (ret int) {\n    var done bool\n    for !done && ctx.Err == nil {\n        // Some partial computation...\n    }\n\n    // Some cleanup... ![3](assets/3.png)\n    return ret\n}\n```", "```go\nfunc Handle_Better(w http.ResponseWriter, r *http.Request) {\n    respCh := make(chan int)\n\n    go func() {\n        defer close(respCh)\n        respCh <- ComplexComputationWithCtx(r.Context())\n    }()\n\n    resp := <-respCh ![1](assets/1.png)\n    if r.Context().Err() != nil {\n        return\n    }\n\n    _, _ = w.Write([]byte(strconv.Itoa(resp)))\n}\n```", "```go\nfunc BenchmarkComplexComputation_Wrong(b *testing.B) { ![1](assets/1.png)\n    for i := 0; i < b.N; i++ {\n        go func() { ComplexComputation() }()\n        go func() { ComplexComputation() }()\n    }\n}\n\nfunc BenchmarkComplexComputation_Better(b *testing.B) { ![2](assets/2.png)\n    defer goleak.VerifyNone(\n        b,\n        goleak.IgnoreTopFunction(\"testing.(*B).run1\"),\n        goleak.IgnoreTopFunction(\"testing.(*B).doBench\"),\n    ) ![3](assets/3.png)\n\n    for i := 0; i < b.N; i++ {\n        wg := sync.WaitGroup{}\n        wg.Add(2)\n\n        go func() {\n            defer wg.Done()\n            ComplexComputation()\n        }()\n        go func() {\n            defer wg.Done()\n            ComplexComputation()\n        }()\n        wg.Wait()\n   }\n}\n```", "```go\n// import \"github.com/efficientgo/core/logerrcapture\"\n// import \"github.com/efficientgo/core/errcapture\"\n\nfunc doWithFile_Wrong(fileName string) error {\n    f, err := os.Open(fileName)\n    if err != nil {\n        return err\n    }\n    defer f.Close() // Wrong! ![1](assets/1.png)\n\n    // Use file...\n\n    return nil\n}\n\nfunc doWithFile_CaptureCloseErr(fileName string) (err error) { ![2](assets/2.png)\n    f, err := os.Open(fileName)\n    if err != nil {\n        return err\n    }\n    defer errcapture.Do(&err, f.Close, \"close file\") ![2](assets/2.png)\n\n    // Use file...\n\n    return nil\n}\n\nfunc doWithFile_LogCloseErr(logger log.Logger, fileName string) {\n    f, err := os.Open(fileName)\n    if err != nil {\n        level.Error(logger).Log(\"err\", err)\n        return\n    }\n    defer logerrcapture.Do(logger, f.Close, \"close file\") ![3](assets/3.png)\n\n    // Use file...\n}\n```", "```go\n// import \"github.com/efficientgo/core/merrors\"\n\nfunc openMultiple_Wrong(fileNames ...string) ([]io.ReadCloser, error) {\n    files := make([]io.ReadCloser, 0, len(fileNames))\n    for _, fn := range fileNames {\n        f, err := os.Open(fn)\n        if err != nil {\n            return nil, err // Leaked files! ![1](assets/1.png)\n        }\n        files = append(files, f)\n    }\n    return files, nil\n}\n\nfunc openMultiple_Correct(fileNames ...string) ([]io.ReadCloser, error) {\n    files := make([]io.ReadCloser, 0, len(fileNames))\n    for _, fn := range fileNames {\n        f, err := os.Open(fn)\n        if err != nil {\n            return nil, merrors.New(err, closeAll(files)).Err() ![2](assets/2.png)\n        }\n        files = append(files, f)\n    }\n    return files, nil\n}\n\nfunc closeAll(closers []io.ReadCloser) error {\n    errs := merrors.New()\n    for _, c := range closers {\n        errs.Add(c.Close())\n    }\n    return errs.Err()\n}\n```", "```go\nfunc handleResp_Wrong(resp *http.Response) error { ![1](assets/1.png)\n    if resp.StatusCode != http.StatusOK {\n        return errors.Newf(\"got non-200 response; code: %v\", resp.StatusCode)\n    }\n    return nil\n}\n\nfunc handleResp_StillWrong(resp *http.Response) error {\n    defer func() {\n        _ = resp.Body.Close() ![2](assets/2.png)\n    }()\n\n    if resp.StatusCode != http.StatusOK {\n        return errors.Newf(\"got non-200 response; code: %v\", resp.StatusCode)\n    }\n    return nil\n}\n\nfunc handleResp_Better(resp *http.Response) (err error) {\n    defer errcapture.ExhaustClose(&err, resp.Body, \"close\") ![3](assets/3.png)\n\n    if resp.StatusCode != http.StatusOK {\n        return errors.Newf(\"got non-200 response; code: %v\", resp.StatusCode)\n    }\n    return nil\n}\n\nfunc BenchmarkClient(b *testing.B) {\n    defer goleak.VerifyNone(\n        b,\n        goleak.IgnoreTopFunction(\"testing.(*B).run1\"),\n        goleak.IgnoreTopFunction(\"testing.(*B).doBench\"),\n    )\n\n    c := &http.Client{}\n    defer c.CloseIdleConnections() ![4](assets/4.png)\n\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        resp, err := c.Get(\"http://google.com\")\n        testutil.Ok(b, err)\n        testutil.Ok(b, handleResp_Wrong(resp))\n    }\n}\n```", "```go\nconst size = 1e6 ![1](assets/1.png)\n\nslice := make([]string, 0, size) ![2](assets/2.png)\nfor i := 0; i < size; i++ {\n    slice = append(slice, \"something\")\n}\n\nslice2 := make([]string, size) ![3](assets/3.png)\nfor i := 0; i < size; i++ {\n    slice2[i] = \"something\"\n}\n\nm := make(map[int]string, size) ![4](assets/4.png)\nfor i := 0; i < size; i++ {\n    m[i] = \"something\"\n}\n\nbuf := bytes.Buffer{} ![5](assets/5.png)\nbuf.Grow(size)\nfor i := 0; i < size; i++ {\n    _ = buf.WriteByte('a')\n}\n\nbuilder := strings.Builder{}\nbuilder.Grow(size)\nfor i := 0; i < size; i++ {\n    builder.WriteByte('a')\n}\n```", "```go\nfunc ReadAll1(r io.Reader, size int) ([]byte, error) {\n   buf := bytes.Buffer{}\n   buf.Grow(size)\n   n, err := io.Copy(&buf, r) ![1](assets/1.png)\n   return buf.Bytes()[:n], err\n}\n\nfunc ReadAll2(r io.Reader, size int) ([]byte, error) {\n   buf := make([]byte, size)\n   n, err := io.ReadFull(r, buf) ![2](assets/2.png)\n   if err == io.EOF {\n      err = nil\n   }\n   return buf[:n], err\n}\n\nfunc BenchmarkReadAlls(b *testing.B) {\n   const size = int(1e6)\n   inner := make([]byte, size)\n\n   b.Run(\"io.ReadAll\", func(b *testing.B) {\n      b.ReportAllocs()\n      for i := 0; i < b.N; i++ {\n         buf, err := io.ReadAll(bytes.NewReader(inner))\n         testutil.Ok(b, err)\n         testutil.Equals(b, size, len(buf))\n      }\n   })\n\n   b.Run(\"ReadAll1\", func(b *testing.B) {\n      b.ReportAllocs()\n      for i := 0; i < b.N; i++ {\n         buf, err := ReadAll1(bytes.NewReader(inner), size)\n         testutil.Ok(b, err)\n         testutil.Equals(b, size, len(buf))\n      }\n   })\n\n   b.Run(\"ReadAll2\", func(b *testing.B) {\n      b.ReportAllocs()\n      for i := 0; i < b.N; i++ {\n         buf, err := ReadAll2(bytes.NewReader(inner), size)\n         testutil.Ok(b, err)\n         testutil.Equals(b, size, len(buf))\n      }\n   })\n}\n```", "```go\nBenchmarkReadAlls\nBenchmarkReadAlls/io.ReadAll\nBenchmarkReadAlls/io.ReadAll-12  1210   872388 ns/op  5241169 B/op  29 allocs/op\nBenchmarkReadAlls/ReadAll1\nBenchmarkReadAlls/ReadAll1-12    8486   165519 ns/op  1007723 B/op  4 allocs/op\nBenchmarkReadAlls/ReadAll2\nBenchmarkReadAlls/ReadAll2-12    10000  102414 ns/op  1007676 B/op  3 allocs/op\nPASS\n```", "```go\ntype Node struct {\n    next *Node\n    value int\n}\n\ntype SinglyLinkedList struct {\n    head *Node\n\n    pool      []Node ![1](assets/1.png)\n    poolIndex int\n}\n\nfunc (l *SinglyLinkedList) Grow(len int) { ![2](assets/2.png)\n    l.pool = make([]Node, len)\n    l.poolIndex = 0\n}\n\nfunc (l *SinglyLinkedList) Insert(value int) {\n    var newNode *Node\n    if len(l.pool) > l.poolIndex { ![3](assets/3.png)\n        newNode = &l.pool[l.poolIndex]\n        l.poolIndex++\n    } else {\n        newNode = &Node{}\n    }\n\n    newNode.next = l.head\n    newNode.value = value\n    l.head = newNode\n}\n```", "```go\nfunc (l *SinglyLinkedList) Delete(n *Node) { /* ... */ } ![1](assets/1.png)\n\nfunc TestSinglyLinkedList_Delete(t *testing.T) { ![2](assets/2.png)\n    l := &SinglyLinkedList{}\n    l.Grow(size)\n    for k := 0; k < size; k++ {\n        l.Insert(k)\n    }\n    l.pool = nil // Dispose pool. ![3](assets/3.png)\n    _printHeapUsage() ![4](assets/4.png)\n\n    // Remove all but last.\n    for curr := l.head; curr.next != nil; curr = curr.next { ![5](assets/5.png)\n        l.Delete(curr)\n    }\n    _printHeapUsage() ![6](assets/6.png)\n\n    l.Delete(l.head)\n    _printHeapUsage() ![7](assets/7.png)\n}\n\nfunc _printHeapUsage() {\n    m := runtime.MemStats{}\n\n    runtime.GC()\n    runtime.ReadMemStats(&m)\n    fmt.Println(float64(m.HeapAlloc)/1024.0, \"KB\")\n}\n```", "```go\nfunc (l *SinglyLinkedList) ClipMemory() {\n    var objs int\n    for curr := l.head; curr != nil; curr = curr.next {\n        objs++\n    }\n\n    l.pool = make([]Node, objs) ![1](assets/1.png)\n    l.poolIndex = 0\n    for curr := l.head; curr != nil; curr = curr.next {\n        oldCurr := curr\n        curr = &l.pool[l.poolIndex]\n        l.poolIndex++\n\n        curr.next = oldCurr.next ![2](assets/2.png)\n        curr.value = oldCurr.value\n\n        if oldCurr == l.head {\n            l.head = curr ![3](assets/3.png)\n        }\n    }\n}\n```", "```go\nfunc processUsingBuffer(buf []byte) {\n    buf = buf[:0] ![1](assets/1.png)\n\n    for i := 0; i < 1e6; i++ {\n        buf = append(buf, 'a')\n    }\n\n    // Use buffer...\n}\n\nfunc BenchmarkProcess(b *testing.B) {\n    b.Run(\"alloc\", func(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            processUsingBuffer(nil) ![2](assets/2.png)\n        }\n    })\n\n    b.Run(\"buffer\", func(b *testing.B) {\n        buf := make([]byte, 1e6)\n        b.ResetTimer()\n        for i := 0; i < b.N; i++ {\n            processUsingBuffer(buf) ![3](assets/3.png)\n        }\n    })\n}\n```", "```go\nfunc processUsingPool(p *sync.Pool) {\n    buf := p.Get().([]byte) ![1](assets/1.png)\n    buf = buf[:0]\n\n    for i := 0; i < 1e6; i++ {\n        buf = append(buf, 'a')\n    }\n    defer p.Put(buf) ![2](assets/2.png)\n\n    // Use buffer...\n}\n\nfunc BenchmarkProcess(b *testing.B) {\n    b.ReportAllocs()\n\n    p := sync.Pool{\n        New: func() any { return []byte{} }, ![3](assets/3.png)\n    }\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        processUsingPool(&p) ![4](assets/4.png)\n    }\n}\n```", "```go\nfunc processUsingPool_Wrong(p *sync.Pool) {\n    buf := p.Get().([]byte)\n    buf = buf[:0]\n\n    defer p.Put(buf) ![1](assets/1.png)\n\n    for i := 0; i < 1e6; i++ {\n        buf = append(buf, 'a')\n    }\n\n    // Use buffer...\n}\n\nfunc BenchmarkProcess(b *testing.B) {\n    p := sync.Pool{\n        New: func() any { return []byte{} },\n    }\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        processUsingPool_Wrong(&p) ![2](assets/2.png)\n    }\n}\n```", "```go\nfunc BenchmarkProcess(b *testing.B) {\n    b.Run(\"buffer-GC\", func(b *testing.B) {\n        buf := make([]byte, 1e6)\n        b.ResetTimer()\n      for i := 0; i < b.N; i++ {\n            processUsingBuffer(buf) ![1](assets/1.png)\n            runtime.GC()\n            runtime.GC()\n        }\n    })\n\n    b.Run(\"pool-GC\", func(b *testing.B) {\n        p := sync.Pool{\n            New: func() any { return []byte{} },\n        }\n        b.ResetTimer()\n        for i := 0; i < b.N; i++ {\n            processUsingPool(&p) ![2](assets/2.png)\n            runtime.GC()\n            runtime.GC()\n        }\n    })\n}\n```", "```go\nname                  time/op\nLabeler/no-buffering   430ms ± 0%\nLabeler/sync-pool      435ms ± 0%\nLabeler/gobwas-pool    438ms ± 0%\nLabeler/static-buffers 434ms ± 0%\n\nname                  alloc/op\nLabeler/no-buffering   3.10MB ± 0%\nLabeler/sync-pool      62.0kB ± 0%\nLabeler/gobwas-pool    94.5kB ± 0% ![1](assets/1.png)\nLabeler/static-buffers 62.0kB ± 0%\n\nname                  allocs/op\nLabeler/no-buffering    3.00 ± 0%\nLabeler/sync-pool       3.00 ± 0%\nLabeler/gobwas-pool     3.00 ± 0%\nLabeler/static-buffers  2.00 ± 0%\n```"]