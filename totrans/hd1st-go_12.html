<html><head></head><body><section data-pdf-bookmark="Chapter 11. what can you do?: Interfaces" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="what_can_you_doquestcolon_interfaces">
<h1 class="calibre17"><span class="calibre">Chapter 11. </span>what can you do?: Interfaces</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0321-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="interfaces" data-secondary="about" data-type="indexterm" id="idm46062710420824" class="calibre10"/><strong class="calibre8">Sometimes you don’t care about the particular type of a value.</strong> You don’t care about what it <em class="calibre9">is</em>. You just need to know that it will be able to <em class="calibre9">do</em> certain things. That you’ll be able to call <em class="calibre9">certain methods</em> on it. You don’t care whether you have a <code class="calibre20">Pen</code> or a <code class="calibre20">Pencil</code>, you just need something with a <code class="calibre20">Draw</code> method. You don’t care whether you have a <code class="calibre20">Car</code> or a <code class="calibre20">Boat</code>, you just need something with a <code class="calibre20">Steer</code> method.</p>
<p class="calibre7">That’s what Go <strong class="calibre8">interfaces</strong> accomplish. They let you define variables and function parameters that will hold <em class="calibre9">any</em> type, as long as that type defines certain methods.</p>
<section data-pdf-bookmark="Two different types that have the same methods" data-type="sect1" class="preface"><div class="preface" id="two_different_types_that_have_the_same_m">
<h1 class="calibre25">Two different types that have the same methods</h1>
<p class="calibre7"><a data-primary="methods" data-secondary="types and" data-type="indexterm" id="idm46062710412504" class="calibre10"/><a data-primary="types" data-secondary="methods and" data-type="indexterm" id="idm46062710410776" class="calibre10"/>Remember audio tape recorders? (We suppose some of you will be too young.) They were great, though. They let you easily record all your favorite songs together on a single tape, even if they were by different artists. Of course, the recorders were usually too bulky to carry around with you. If you wanted to take your tapes on the go, you needed a separate, battery-powered tape player. Those usually didn’t have recording capabilities. Ah, but it was so great making custom mixtapes and sharing them with your friends!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0322-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We’re so overwhelmed with nostalgia that we’ve created a <code class="calibre20">gadget</code> package to help us reminisce. It includes a type that simulates a tape recorder, and another type that simulates a tape player.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0322-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The <code class="calibre20">TapePlayer</code> type has a <code class="calibre20">Play</code> method to simulate playing a song, and a <code class="calibre20">Stop</code> method to stop the virtual playback.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0322-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The <code class="calibre20">TapeRecorder</code> type also has <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> methods, and a <code class="calibre20">Record</code> method as well.</p>
</div></section>
<section data-pdf-bookmark="A method parameter that can only accept one type" data-type="sect1" class="preface"><div class="preface" id="a_method_parameter_that_can_only_accept">
<h1 class="calibre25">A method parameter that can only accept one type</h1>
<p class="calibre7"><a data-primary="parameters" data-secondary="methods and" data-type="indexterm" id="idm46062710396536" class="calibre10"/>Here’s a sample program that uses the <code class="calibre20">gadget</code> package. We define a <code class="calibre20">playList</code> function that takes a <code class="calibre20">TapePlayer</code> value, and a slice of song titles to play on it. The function loops over each title in the slice, and passes it to the <code class="calibre20">TapePlayer</code>’s <code class="calibre20">Play</code> method. When it’s done playing the list, it calls <code class="calibre20">Stop</code> on the <code class="calibre20">TapePlayer</code>.</p>
<p class="calibre7">Then, in the <code class="calibre20">main</code> method, all we have to do is create the <code class="calibre20">TapePlayer</code> and the slice of song titles, and pass them to <code class="calibre20">playList</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0323-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The <code class="calibre20">playList</code> function works great with a <code class="calibre20">TapePlayer</code> value. You might hope that it would work with a <code class="calibre20">TapeRecorder</code> as well. (After all, a tape recorder is basically just a tape player with an extra record function.) But <code class="calibre20">playList</code>’s first parameter has a type of <code class="calibre20">TapePlayer</code>. Try to pass it an argument of any other type, and you’ll get a compile error:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0323-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0324-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In this case, it does seem like the Go language’s type safety is getting in our way, rather than helping us. The <code class="calibre20">TapeRecorder</code> type defines all the methods that the <code class="calibre20">playList</code> function needs, but we’re being blocked from using it because <code class="calibre20">playList</code> only accepts <code class="calibre20">TapePlayer</code> values.</p>
<p class="calibre7">So what can we do? Write a second, nearly identical <code class="calibre20">playListWithRecorder</code> function that takes a <code class="calibre20">TapeRecorder</code> instead?</p>
<p class="calibre7">Actually, Go offers another way...</p>
</div></section>
<section data-pdf-bookmark="Interfaces" data-type="sect1" class="preface"><div class="preface" id="interfaces">
<h1 class="calibre25">Interfaces</h1>
<p class="calibre7"><a data-primary="curly braces {}" data-secondary="interfaces and" data-type="indexterm" id="idm46062710375192" class="calibre10"/><a data-primary="interface keyword" data-type="indexterm" id="idm46062710373912" class="calibre10"/><a data-primary="interfaces" data-secondary="about" data-type="indexterm" id="idm46062710373032" class="calibre10"/><a data-primary="interfaces" data-secondary="methods and" data-type="indexterm" id="idm46062710371880" class="calibre10"/><a data-primary="interfaces" data-secondary="return values and" data-type="indexterm" id="idm46062710370744" class="calibre10"/><a data-primary="interfaces" data-secondary="types satisfying" data-type="indexterm" id="idm46062710369672" class="calibre10"/><a data-primary="interface types" data-secondary="defining" data-type="indexterm" id="idm46062710368536" class="calibre10"/><a data-primary="methods" data-secondary="interfaces and" data-type="indexterm" id="idm46062710367464" class="calibre10"/><a data-primary="return values" data-secondary="interfaces and" data-type="indexterm" id="idm46062710366328" class="calibre10"/><a data-primary="types" data-secondary="satisfying interfaces" data-type="indexterm" id="idm46062710365256" class="calibre10"/>When you install a program on your computer, you usually expect the program to provide you with a way to interact with it. You expect a word processor to give you a place to type text. You expect a backup program to give you a way to select which files to save. You expect a spreadsheet to give you a way to insert columns and rows for data. The set of controls a program provides you so you can interact with it is often called its <em class="calibre9">interface</em>.</p>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">An interface is a set of methods that certain values are expected to have.</strong></p>
</blockquote>
<p class="calibre7">Whether you’ve actually thought about it or not, you probably expect Go values to provide you with a way to interact with them, too. What’s the most common way to interact with a Go value? Through its methods.</p>
<p class="calibre7">In Go, an <strong class="calibre8">interface</strong> is defined as a set of methods that certain values are expected to have. You can think of an interface as a set of actions you need a type to be able to perform.</p>
<p class="calibre7">You define an interface type using the <code class="calibre20">interface</code> keyword, followed by curly braces containing a list of method names, along with any parameters or return values the methods are expected to have.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0325-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Any type that has all the methods listed in an interface definition is said to <strong class="calibre8">satisfy</strong> that interface. A type that satisfies an interface can be used anywhere that interface is called for.</p>
<p class="calibre7">The method names, parameter types (or lack thereof), and return value types (or lack thereof) all need to match those defined in the interface. A type can have methods <em class="calibre9">in addition</em> to those listed in the interface, but it mustn’t be <em class="calibre9">missing</em> any, or it doesn’t satisfy that interface.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0325-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">A type can satisfy multiple interfaces, and an interface can (and usually should) have multiple types that satisfy it.</p>
</div></section>
<section data-pdf-bookmark="Defining a type that satisfies an interface" data-type="sect1" class="preface"><div class="preface" id="defining_a_type_that_satisfies_an_interf">
<h1 class="calibre25">Defining a type that satisfies an interface</h1>
<p class="calibre7">The code below sets up a quick experimental package, named <code class="calibre20">mypkg</code>. It defines an interface type named <code class="calibre20">MyInterface</code> with three methods. Then it defines a type named <code class="calibre20">MyType</code> that satisfies <code class="calibre20">MyInterface</code>.</p>
<p class="calibre7">There are three methods required to satisfy <code class="calibre20">MyInterface</code>: a <code class="calibre20">MethodWithoutParameters</code> method, a <code class="calibre20">MethodWithParameter</code> method that takes a <code class="calibre20">float64</code> parameter, and a <code class="calibre20">MethodWithReturnValue</code> method that returns a <code class="calibre20">string</code>.</p>
<p class="calibre7">Then we declare another type, <code class="calibre20">MyType</code>. The underlying type of <code class="calibre20">MyType</code> doesn’t matter in this example; we just used <code class="calibre20">int</code>. We define all the methods on <code class="calibre20">MyType</code> that it needs to satisfy <code class="calibre20">MyInterface</code>, plus one extra method that isn’t part of the interface.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0326-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Many other languages would require us to explicitly say that <code class="calibre20">MyType</code> satisfies <code class="calibre20">MyInterface</code>. But in Go, this happens <em class="calibre9">automatically</em>. If a type has all the methods declared in an interface, then it can be used anywhere that interface is required, with no further declarations needed.</p>
<p class="calibre7"><a data-primary="concrete types" data-type="indexterm" id="idm46062710339032" class="calibre10"/><a data-primary="interface types" data-secondary="about" data-type="indexterm" id="idm46062710337880" class="calibre10"/>Here’s a quick program that will let us try <code class="calibre20">mypkg</code> out.</p>
<p class="calibre7">A variable declared with an interface type can hold any value whose type satisfies that interface. This code declares a <code class="calibre20">value</code> variable with <code class="calibre20">MyInterface</code> as its type, then creates a <code class="calibre20">MyType</code> value and assigns it to <code class="calibre20">value</code>. (Which is allowed, because <code class="calibre20">MyType</code> satisfies <code class="calibre20">MyInterface</code>.) Then we call all the methods on that value that are part of the interface.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0327-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Concrete types, interface types" data-type="sect1" class="preface"><div class="preface" id="concrete_typescomma_interface_types">
<h1 class="calibre25">Concrete types, interface types</h1>
<p class="calibre7">All the types we’ve defined in previous chapters have been concrete types. A <strong class="calibre8">concrete type</strong> specifies not only what its values can <em class="calibre9">do</em> (what methods you can call on them), but also what they <em class="calibre9">are</em>: they specify the underlying type that holds the value’s data.</p>
<p class="calibre7">Interface types don’t describe what a value <em class="calibre9">is</em>: they don’t say what its underlying type is, or how its data is stored. They only describe what a value can <em class="calibre9">do</em>: what methods it has.</p>
<p class="calibre7">Suppose you need to write down a quick note. In your desk drawer, you have values of several concrete types: <code class="calibre20">Pen</code>, <code class="calibre20">Pencil</code>, and <code class="calibre20">Marker</code>. Each of these concrete types defines a <code class="calibre20">Write</code> method, so you don’t really care which type you grab. You just want a <code class="calibre20">WritingInstrument</code>: an interface type that is satisfied by any concrete type with a <code class="calibre20">Write</code> method.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0327-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Assign any type that satisfies the interface" data-type="sect1" class="preface"><div class="preface" id="assign_any_type_that_satisfies_the_inter">
<h1 class="calibre25">Assign any type that satisfies the interface</h1>
<p class="calibre7"><a data-primary="functions" data-secondary="parameters in" data-type="indexterm" id="idm46062710319128" class="calibre10"/><a data-primary="interface types" data-secondary="assigning values with" data-type="indexterm" id="idm46062710317400" class="calibre10"/><a data-primary="parameters" data-secondary="functions and" data-type="indexterm" id="idm46062710316312" class="calibre10"/>When you have a variable with an interface type, it can hold values of any type that satisfies the interface.</p>
<p class="calibre7">Suppose we have <code class="calibre20">Whistle</code> and <code class="calibre20">Horn</code> types, each of which has a <code class="calibre20">MakeSound</code> method. We can create a <code class="calibre20">NoiseMaker</code> interface that represents any type with a <code class="calibre20">MakeSound</code> method. If we declare a <code class="calibre20">toy</code> variable with a type of <code class="calibre20">NoiseMaker</code>, we’ll be able to assign either <code class="calibre20">Whistle</code> or <code class="calibre20">Horn</code> values to it. (<em class="calibre9">Or</em> any other type that we later declare, as long as it has a <code class="calibre20">MakeSound</code> method.)</p>
<p class="calibre7">We can then call the <code class="calibre20">MakeSound</code> method on any value assigned to the <code class="calibre20">toy</code> variable. Although we don’t know exactly what concrete type the value in <code class="calibre20">toy</code> <em class="calibre9">is</em>, we know what it can <em class="calibre9">do</em>: make sounds. If its type didn’t have a <code class="calibre20">MakeSound</code> method, then it wouldn’t satisfy the <code class="calibre20">NoiseMaker</code> interface, and we wouldn’t have been able to assign it to the variable.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0328-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You can declare function parameters with interface types as well. (After all, function parameters are really just variables too.) If we declare a <code class="calibre20">play</code> function that takes a <code class="calibre20">NoiseMaker</code>, for example, then we can pass any value from a type with a <code class="calibre20">MakeSound</code> method to <code class="calibre20">play</code>:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0328-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="You can only call methods defined as part of the interface" data-type="sect1" class="preface"><div class="preface" id="you_can_only_call_methods_defined_as_par">
<div class="calibre24" id="calibre_pb_0"/>
</div></section>
</div></section>

<section data-pdf-bookmark="Chapter 11. what can you do?: Interfaces" data-type="chapter" epub:type="chapter" class="preface">
<div class="preface" id="what_can_you_doquestcolon_interfaces">
<section data-pdf-bookmark="You can only call methods defined as part of the interface" data-type="sect1" class="preface">
<div class="preface" id="you_can_only_call_methods_defined_as_par">
<h1 class="calibre25">You can only call methods defined as part of the interface</h1>
<p class="calibre7"><a data-primary="calling methods" data-type="indexterm" id="idm46062710297928" class="calibre10"/><a data-primary="concrete types" data-type="indexterm" id="idm46062710296600" class="calibre10"/><a data-primary="interfaces" data-secondary="methods and" data-type="indexterm" id="idm46062710295736" class="calibre10"/><a data-primary="methods" data-secondary="calling" data-type="indexterm" id="idm46062710294664" class="calibre10"/><a data-primary="methods" data-secondary="interfaces and" data-type="indexterm" id="idm46062710293480" class="calibre10"/>Once you assign a value to a variable (or method parameter) with an interface type, you can <em class="calibre9">only</em> call methods that are specified by the interface on it.</p>
<p class="calibre7">Suppose we created a <code class="calibre20">Robot</code> type, which in addition to a <code class="calibre20">MakeSound</code> method, also has a <code class="calibre20">Walk</code> method. We add a call to <code class="calibre20">Walk</code> in the <code class="calibre20">play</code> function, and pass a new <code class="calibre20">Robot</code> value to <code class="calibre20">play</code>.</p>
<p class="calibre7">But the code doesn’t compile, saying that <code class="calibre20">NoiseMaker</code> values don’t have a <code class="calibre20">Walk</code> method.</p>
<p class="calibre7">Why is that? <code class="calibre20">Robot</code> values <em class="calibre9">do</em> have a <code class="calibre20">Walk</code> method; the definition is right there!</p>
<p class="calibre7">But it’s <em class="calibre9">not</em> a <code class="calibre20">Robot</code> value that we’re passing to the <code class="calibre20">play</code> function; it’s a <code class="calibre20">NoiseMaker</code>. What if we had passed a <code class="calibre20">Whistle</code> or <code class="calibre20">Horn</code> to <code class="calibre20">play</code> instead? Those don’t have <code class="calibre20">Walk</code> methods!</p>
<p class="calibre7">When we have a variable of an interface type, the only methods we can be sure it has are the methods that are defined in the interface. And so those are the only methods Go allows you to call. (There <em class="calibre9">is</em> a way to get at the value’s concrete type, so that you can call more specialized methods. We’ll look at that shortly.)</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0329-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Note that it <em class="calibre9">is</em> just fine to assign a type that <em class="calibre9">has</em> other methods to a variable with an interface type. As long as you don’t actually call those other methods, everything will work.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0329-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Breaking Stuff is Educational!" data-type="sect1" class="preface"><div class="preface" id="breaking_stuff_is_educational_8">
<h1 class="calibre25">Breaking Stuff is Educational!</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0330-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="interfaces" data-secondary="errors in satisfying" data-type="indexterm" id="idm46062710270872" class="calibre10"/>Here are a couple concrete types, <code class="calibre20">Fan</code> and <code class="calibre20">CoffeePot</code>. We also have an <code class="calibre20">Appliance</code> interface with a <code class="calibre20">TurnOn</code> method. <code class="calibre20">Fan</code> and <code class="calibre20">CoffeePot</code> both have <code class="calibre20">TurnOn</code> methods, so they both satisfy the <code class="calibre20">Appliance</code> interface.</p>
<p class="calibre7">That’s why, in the <code class="calibre20">main</code> function, we’re able to define an <code class="calibre20">Appliance</code> variable, and assign both <code class="calibre20">Fan</code> and <code class="calibre20">CoffeePot</code> variables to it.</p>
<p class="calibre7">Make one of the changes below and try to compile the code. Then undo your change and try the next one. See what happens!</p>
<pre data-type="programlisting" class="calibre32">type Appliance interface {
       TurnOn()
}

type Fan string
func (f Fan) TurnOn() {
      fmt.Println("Spinning")
}

type CoffeePot string
func (c CoffeePot) TurnOn() {
      fmt.Println("Powering up")
}
func (c CoffeePot) Brew() {
      fmt.Println("Heating Up")
}

func main() {
      var device Appliance
      device = Fan("Windco Breeze")
      device.TurnOn()
      device = CoffeePot("LuxBrew")
      device.TurnOn()
}</pre>
<table class="calibre11">
<thead class="calibre33">
<tr class="calibre13">
<th class="calibre34">If you do this...</th>
<th class="calibre34">...the code will break because...</th>
</tr>
</thead>
<tbody class="calibre12">
<tr class="calibre13">
<td class="calibre14">Call a method from the concrete type that isn’t defined in the interface:<br class="calibre16"/>
<code class="calibre36">device.Brew()</code></td>
<td class="calibre14">When you have a value in a variable with an interface type, you can only call methods defined as part of that interface, regardless of what methods the concrete type had.</td>
</tr>
<tr class="calibre15">
<td class="calibre14">Remove the method that satisfies the interface from a type:
<code class="calibre36">
<s class="calibre35">func (c CoffeePot) TurnOn() {</s>
<s class="calibre35">      fmt.Println("Powering up")</s>
<s class="calibre35">}</s>
</code>
</td>
<td class="calibre14">If a type doesn’t satisfy an interface, you can’t assign values of that type to variables that use that interface as their type.</td>
</tr>
<tr class="calibre13">
<td class="calibre14">Add a new return value or parameter on the method that satisfies the interface:
<code class="calibre36">
func (f Fan) TurnOn() error {
       fmt.Println("Spinning")
       return nil
}
</code>
</td>
<td class="calibre14">If the number and types of all parameters and return values don’t match between a concrete type’s method definition and the method definition in the interface, then the concrete type does not satisfy the interface.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Fixing our playList function using an interface" data-type="sect1" class="preface"><div class="preface" id="fixing_our_playlist_function_using_an_in">
<h1 class="calibre25">Fixing our playList function using an interface</h1>
<p class="calibre7"><a data-primary="functions" data-secondary="interfaces and" data-type="indexterm" id="idm46062710250072" class="calibre10"/><a data-primary="functions" data-secondary="methods and" data-type="indexterm" id="idm46062710248616" class="calibre10"/><a data-primary="interfaces" data-secondary="functions and" data-type="indexterm" id="idm46062710247352" class="calibre10"/><a data-primary="interface types" data-secondary="defining" data-type="indexterm" id="idm46062710246168" class="calibre10"/><a data-primary="methods" data-secondary="functions and" data-type="indexterm" id="idm46062710245048" class="calibre10"/>Let’s see if we can use an interface to allow our <code class="calibre20">playList</code> function to work with the <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> methods on both of our concrete types: <code class="calibre20">TapePlayer</code> and <code class="calibre20">TapeRecorder</code>.</p>
<pre data-type="programlisting" class="calibre32">// TapePlayer type definition here
func (t TapePlayer) Play(song string) {
       fmt.Println("Playing", song)
}
func (t TapePlayer) Stop() {
       fmt.Println("Stopped!")
}
// TapeRecorder type definition here
func (t TapeRecorder) Play(song string) {
       fmt.Println("Playing", song)
}
func (t TapeRecorder) Record() {
       fmt.Println("Recording")
}
func (t TapeRecorder) Stop() {
       fmt.Println("Stopped!")
}</pre>
<p class="calibre7">In our <code class="calibre20">main</code> package, we declare a <code class="calibre20">Player</code> interface. (We could define it in the <code class="calibre20">gadget</code> package instead, but defining the interface in the same package where we use it gives us more flexibility.) We specify that the interface requires both a <code class="calibre20">Play</code> method with a <code class="calibre20">string</code> parameter, and a <code class="calibre20">Stop</code> method with no parameters. This means that both the <code class="calibre20">TapePlayer</code> and <code class="calibre20">TapeRecorder</code> types will satisfy the <code class="calibre20">Player</code> interface.</p>
<p class="calibre7">We update the <code class="calibre20">playList</code> function to take any value that satisfies <code class="calibre20">Player</code> instead of <code class="calibre20">TapePlayer</code> specifically. We also change the type of the <code class="calibre20">player</code> variable from <code class="calibre20">TapePlayer</code> to <code class="calibre20">Player</code>. This allows us to assign either a <code class="calibre20">TapePlayer</code> or a <code class="calibre20">TapeRecorder</code> to <code class="calibre20">player</code>. We then pass values of both types to <code class="calibre20">playList</code>!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0331-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="watch_it_6">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/watch-it.png" class="calibre4"/></span> Watch it!</h5>
<p class="calibre7"><a data-primary="interface types" data-secondary="naming rules for" data-type="indexterm" id="idm46062710225752" class="calibre10"/><a data-primary="naming rules" data-secondary="interface types" data-type="indexterm" id="idm46062710224392" class="calibre10"/><a data-primary="naming rules" data-secondary="types" data-type="indexterm" id="idm46062710223240" class="calibre10"/><a data-primary="pointers and pointer types" data-secondary="receiver parameters" data-type="indexterm" id="idm46062710222120" class="calibre10"/><a data-primary="receiver parameters (methods)" data-secondary="pointers and" data-type="indexterm" id="idm46062710220968" class="calibre10"/><a data-primary="types" data-secondary="naming rules for" data-type="indexterm" id="idm46062710219896" class="calibre10"/><strong class="calibre8">If a type declares methods with pointer receivers, then you’ll only be able to use pointers to that type when assigning to interface variables.</strong></p>
<p class="calibre7"><em class="calibre9">The</em> <code class="calibre20">toggle</code> <em class="calibre9">method on the</em> <code class="calibre20">Switch</code> <em class="calibre9">type below has to use a pointer receiver so it can modify the receiver.</em></p>
<pre data-type="programlisting" class="calibre32">package main

import "fmt"

type Switch string
func (s *Switch) toggle() {
       if *s == "on" {
              *s = "off"
       } else {
              *s = "on"
       }
       fmt.Println(*s)
}

type Toggleable interface {
       toggle()
}

func main() {
       s := Switch("off")
       var t Toggleable = s
       t.toggle()
       t.toggle()
}</pre>
<p class="calibre7"><em class="calibre9">But that results in an error when we assign a</em> <code class="calibre20">Switch</code> <em class="calibre9">value to a variable with the interface type</em> <code class="calibre20">Toggleable</code><em class="calibre9">:</em></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0332-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><em class="calibre9">When Go decides whether a value satisfies an interface, pointer methods aren’t included for direct values. But they are included for pointers. So the solution is to assign a pointer to a</em> <code class="calibre20">Switch</code> <em class="calibre9">to the</em> <code class="calibre20">Toggleable</code> <em class="calibre9">variable, instead of a direct</em> <code class="calibre20">Switch</code> <em class="calibre9">value:</em></p>
<p class="calibre7"><code class="calibre20">var t Toggleable = &amp; s</code></p>
<div data-type="note" epub:type="note" class="calibre42"><h6 class="calibre23">Note</h6>
<p class="calibre7">Assign a pointer instead.</p>
</div>
<p class="calibre7"><em class="calibre9">Make that change, and the code should work correctly.</em></p>
</div></aside>
</div></section>
<section data-pdf-bookmark="there are no Dumb Questions" data-type="sect1" class="preface"><div class="preface" id="there_are_no_dumb_questions_8">
<h1 class="calibre25">there are no Dumb Questions</h1>
<p class="calibre7"><strong class="calibre8">Q: Should interface type names begin with a capital letter or a lowercase letter?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> The rules for interface type names are the same as the rules for any other type. If the name begins with a lowercase letter, then the interface type will be <em class="calibre9">unexported</em> and will not be accessible outside the current package. Sometimes you won’t need to use the interface you’re declaring from other packages, so making it unexported is fine. But if you <em class="calibre9">do</em> want to use it in other packages, you’ll need to start the interface type’s name with a capital letter, so that it’s exported.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_21">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7">The code at the right defines <code class="calibre20">Car</code> and <code class="calibre20">Truck</code> types, each of which have <code class="calibre20">Accelerate</code>, <code class="calibre20">Brake</code>, and <code class="calibre20">Steer</code> methods. Fill in the blanks to add a <code class="calibre20">Vehicle</code> interface that includes those three methods, so that the code in the <code class="calibre20">main</code> function will compile and produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0333-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="ch11_split_001.html#exercise_solution_21" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></aside>
</div></section>
<section data-pdf-bookmark="Type assertions" data-type="sect1" class="preface"><div class="preface" id="type_assertions">
<h1 class="calibre25">Type assertions</h1>
<p class="calibre7"><a data-primary="concrete types" data-type="indexterm" id="idm46062710188664" class="calibre10"/><a data-primary="interface types" data-secondary="assigning values with" data-type="indexterm" id="idm46062710187720" class="calibre10"/><a data-primary="interface types" data-secondary="type assertions and" data-type="indexterm" id="idm46062710186536" class="calibre10"/><a data-primary="type assertions" data-secondary="about" data-type="indexterm" id="idm46062710185496" class="calibre10"/>We’ve defined a new <code class="calibre20">TryOut</code> function that will let us test the various methods of our <code class="calibre20">TapePlayer</code> and <code class="calibre20">TapeRecorder</code> types. <code class="calibre20">TryOut</code> has a single parameter with the <code class="calibre20">Player</code> interface as its type, so that we can pass in either a <code class="calibre20">TapePlayer</code> or <code class="calibre20">TapeRecorder</code>.</p>
<p class="calibre7">Within <code class="calibre20">TryOut</code>, we call the <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> methods, which are both part of the <code class="calibre20">Player</code> interface. We also call the <code class="calibre20">Record</code> method, which is <em class="calibre9">not</em> part of the <code class="calibre20">Player</code> interface, but <em class="calibre9">is</em> defined on the <code class="calibre20">TapeRecorder</code> type. We’re only passing a <code class="calibre20">TapeRecorder</code> value to <code class="calibre20">TryOut</code> for now, so we should be fine, right?</p>
<p class="calibre7">Unfortunately, no. We saw earlier that if a value of a concrete type is assigned to a variable with an interface type (including function parameters), then you can only call methods on it that are part of that interface, regardless of what other methods the concrete type has. Within the <code class="calibre20">TryOut</code> function, we don’t have a <code class="calibre20">TapeRecorder</code> value (the concrete type), we have a <code class="calibre20">Player</code> value (the interface type). And the <code class="calibre20">Player</code> interface doesn’t have a <code class="calibre20">Record</code> method!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0334-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We need a way to get the concrete type value (which <em class="calibre9">does</em> have a <code class="calibre20">Record</code> method) back.</p>
<p class="calibre7">Your first instinct might be to try a type conversion to convert the <code class="calibre20">Player</code> value to a <code class="calibre20">TapeRecorder</code> value. But type conversions aren’t meant for use with interface types, so that generates an error. The error message suggests trying something else:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0334-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">A “type assertion”? What’s that?</p>
<p class="calibre7"><a data-primary="interfaces" data-secondary="methods and" data-type="indexterm" id="idm46062710165496" class="calibre10"/><a data-primary="parentheses ()" data-secondary="concrete types and" data-type="indexterm" id="idm46062710164104" class="calibre10"/>When you have a value of a concrete type assigned to a variable with an interface type, a <strong class="calibre8">type assertion</strong> lets you get the concrete type back. It’s <em class="calibre9">kind of</em> like a type conversion. Its syntax even looks like a cross between a method call and a type conversion. After an interface value, you type a dot, followed by a pair of parentheses with the concrete type. (Or rather, what you’re <em class="calibre9">asserting</em> the value’s concrete type is.)</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0335-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In plain language, the type assertion above says something like “I know this variable uses the interface type <code class="calibre20">NoiseMaker</code>, but I’m pretty sure <em class="calibre9">this</em> <code class="calibre20">NoiseMaker</code> is actually a <code class="calibre20">Robot</code>.”</p>
<p class="calibre7">Once you’ve used a type assertion to get a value of a concrete type back, you can call methods on it that are defined on that type, but aren’t part of the interface.</p>
<p class="calibre7">This code assigns a <code class="calibre20">Robot</code> to a <code class="calibre20">NoiseMaker</code> interface value. We’re able to call <code class="calibre20">MakeSound</code> on the <code class="calibre20">NoiseMaker</code>, because it’s part of the interface. But to call the <code class="calibre20">Walk</code> method, we need to use a type assertion to get a <code class="calibre20">Robot</code> value. Once we have a <code class="calibre20">Robot</code> (rather than a <code class="calibre20">NoiseMaker</code>), we can call <code class="calibre20">Walk</code> on it.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0335-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Type assertion failures" data-type="sect1" class="preface"><div class="preface" id="type_assertion_failures">
<h1 class="calibre25">Type assertion failures</h1>
<p class="calibre7"><a data-primary="error handling" data-secondary="type assertions" data-type="indexterm" id="idm46062710148104" class="calibre10"/><a data-primary="type assertions" data-secondary="error handling and" data-type="indexterm" id="idm46062710146808" class="calibre10"/>Previously, our <code class="calibre20">TryOut</code> function wasn’t able to call the <code class="calibre20">Record</code> method on a <code class="calibre20">Player</code> value, because it’s not part of the <code class="calibre20">Player</code> interface. Let’s see if we can get this working using a type assertion.</p>
<p class="calibre7">Just like before, we pass a <code class="calibre20">TapeRecorder</code> to <code class="calibre20">TryOut</code>, where it gets assigned to a parameter that uses the <code class="calibre20">Player</code> interface as its type. We’re able to call the <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> methods on the <code class="calibre20">Player</code> value, because those are both part of the <code class="calibre20">Player</code> interface.</p>
<p class="calibre7">Then, we use a type assertion to convert the <code class="calibre20">Player</code> back to a <code class="calibre20">TapeRecorder</code>. And we call <code class="calibre20">Record</code> on the <code class="calibre20">TapeRecorder</code> value instead.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0336-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Everything seems to be working great...with a <code class="calibre20">TapeRecorder</code>. But what happens if we try to pass a <code class="calibre20">TapePlayer</code> to <code class="calibre20">TryOut</code>? How well will that work, considering we have a type assertion that says the parameter to <code class="calibre20">TryOut</code> is actually a <code class="calibre20">TapeRecorder</code>?</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0336-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Everything compiles successfully, but when we try to run it, we get a runtime panic! As you might expect, trying to assert that a <code class="calibre20">TapePlayer</code> is actually a <code class="calibre20">TapeRecorder</code> did not go well. (It’s simply not true, after all.)</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0336-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Avoiding panics when type assertions fail" data-type="sect1" class="preface"><div class="preface" id="avoiding_panics_when_type_assertions_fai">
<h1 class="calibre25">Avoiding panics when type assertions fail</h1>
<p class="calibre7">If a type assertion is used in a context that expects only one return value, and the original type doesn’t match the type in the assertion, the program will panic at runtime (<em class="calibre9">not</em> when compiling):</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0337-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If type assertions are used in a context where multiple return values are expected, they have a second, optional return value that indicates whether the assertion was successful or not. (And the assertion won’t panic if it’s unsuccessful.) The second value is a <code class="calibre20">bool</code>, and it will be <code class="calibre20">true</code> if the value’s original type was the asserted type, or <code class="calibre20">false</code> if not. You can do whatever you want with this second return value, but by convention it’s usually assigned to a variable named <code class="calibre20">ok</code>.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="calibre7">This is another place Go follows the “comma ok idiom” that we first saw when accessing maps in <a data-type="xref" href="ch07_split_000.html#labeling_datacolon_maps" class="calibre10">Chapter 7</a>.</p>
</div>
<p class="calibre7">Here’s an update to the above code that assigns the results of the type assertion to a variable for the concrete type’s value, and a second <code class="calibre20">ok</code> variable. It uses the <code class="calibre20">ok</code> value in an <code class="calibre20">if</code> statement to determine whether it can safely call <code class="calibre20">Record</code> on the concrete value (because the <code class="calibre20">Player</code> value had an original type of <code class="calibre20">TapeRecorder</code>), or if it should skip doing so (because the <code class="calibre20">Player</code> had some other concrete value).</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0337-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In this case, the concrete type was <code class="calibre20">TapePlayer</code>, not <code class="calibre20">TapeRecorder</code>, so the assertion is unsuccessful, and <code class="calibre20">ok</code> is <code class="calibre20">false</code>. The <code class="calibre20">if</code> statement’s <code class="calibre20">else</code> clause runs, printing <code class="calibre20">Player was not a TapeRecorder</code>. A runtime panic is averted.</p>
<p class="calibre7">When using type assertions, if you’re not absolutely sure which original type is behind the interface value, then you should use the optional <code class="calibre20">ok</code> value to handle cases where it’s a different type than you expected, and avoid a runtime panic.</p>
</div></section>
<section data-pdf-bookmark="Testing TapePlayers and TapeRecorders using type assertions" data-type="sect1" class="preface"><div class="preface" id="testing_tapeplayers_and_taperecorders_us">
<h1 class="calibre25">Testing TapePlayers and TapeRecorders using type assertions</h1>
<p class="calibre7"><a data-primary="testing" data-secondary="using type assertions" data-type="indexterm" id="idm46062710108072" class="calibre10"/><a data-primary="type assertions" data-secondary="using" data-type="indexterm" id="idm46062710104424" class="calibre10"/>Let’s see if we can use what we’ve learned to fix our <code class="calibre20">TryOut</code> function for <code class="calibre20">TapePlayer</code> and <code class="calibre20">TapeRecorder</code> values. Instead of ignoring the second return value from our type assertion, we’ll assign it to an <code class="calibre20">ok</code> variable. The <code class="calibre20">ok</code> variable will be <code class="calibre20">true</code> if the type assertion is successful (indicating the <code class="calibre20">recorder</code> variable holds a <code class="calibre20">TapeRecorder</code> value, ready for us to call <code class="calibre20">Record</code> on it), or <code class="calibre20">false</code> otherwise (indicating it’s <em class="calibre9">not</em> safe to call <code class="calibre20">Record</code>). We wrap the call to the <code class="calibre20">Record</code> method in an <code class="calibre20">if</code> statement to ensure it’s only called when the type assertion is successful.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0338-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">As before, in our <code class="calibre20">main</code> function, we first call <code class="calibre20">TryOut</code> with a <code class="calibre20">TapeRecorder</code> value. <code class="calibre20">TryOut</code> takes the <code class="calibre20">Player</code> interface value it receives, and calls the <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> methods on it. The assertion that the <code class="calibre20">Player</code> value’s concrete type is <code class="calibre20">TapeRecorder</code> succeeds, and the <code class="calibre20">Record</code> method is called on the resulting <code class="calibre20">TapeRecorder</code> value.</p>
<p class="calibre7">Then, we call <code class="calibre20">TryOut</code> again with a <code class="calibre20">TapePlayer</code>. (This is the call that halted the program previously because the type assertion panicked.) <code class="calibre20">Play</code> and <code class="calibre20">Stop</code> are called, as before. The type assertion fails, because the <code class="calibre20">Player</code> value holds a <code class="calibre20">TapePlayer</code> and not a <code class="calibre20">TapeRecorder</code>. But because we’re capturing the second return value in the <code class="calibre20">ok</code> value, the type assertion doesn’t panic this time. It just sets <code class="calibre20">ok</code> to <code class="calibre20">false</code>, which causes the code in our <code class="calibre20">if</code> statement not to run, which causes <code class="calibre20">Record</code> not to be called. (Which is good, because <code class="calibre20">TapePlayer</code> values don’t have a <code class="calibre20">Record</code> method.)</p>
<p class="calibre7">Thanks to type assertions, we’ve got our <code class="calibre20">TryOut</code> function working with both <code class="calibre20">TapeRecorder</code> and <code class="calibre20">TapePlayer</code> values!</p>
</div></section>
<section data-pdf-bookmark="Pool Puzzle" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_9">
<h1 class="calibre25">Pool Puzzle</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/chair.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Updated code from our previous exercise is at the right. We’re creating a <code class="calibre20">TryVehicle</code> method that calls all the methods from the <code class="calibre20">Vehicle</code> interface. Then, it should attempt a type assertion to get a concrete <code class="calibre20">Truck</code> value. If successful, it should call <code class="calibre20">LoadCargo</code> on the <code class="calibre20">Truck</code> value.</p>
<p class="calibre7">Your <strong class="calibre8">job</strong> is to take code snippets from the pool and place them into the blank lines in this code. <strong class="calibre8">Don’t</strong> use the same snippet more than once, and you won’t need to use all the snippets. Your <strong class="calibre8">goal</strong> is to make a program that will run and produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0339-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Note: each snippet from the pool can only be used once!</strong></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0339-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><img alt="image" src="assets/arrow.png" class="calibre4"/> Answers in <a data-type="xref" href="ch11_split_001.html#pool_puzzle_solution_7" class="calibre10">“Pool Puzzle Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="The “error” interface" data-type="sect1" class="preface"><div class="preface" id="the_ldquoerrorrdquo_interface">
<h1 class="calibre25">The “error” interface</h1>
<p class="calibre7"><a data-primary="error built-in type" data-type="indexterm" id="idm46062710064376" class="calibre10"/><a data-primary="Error method" data-type="indexterm" id="idm46062710063176" class="calibre10"/><a data-primary="interfaces" data-secondary="error type as" data-type="indexterm" id="idm46062710062296" class="calibre10"/>We’d like to wrap up the chapter by looking at a few interfaces that are built into Go. We haven’t covered these interfaces explicitly, but you’ve actually been using them all along.</p>
<p class="calibre7">In <a data-type="xref" href="ch03.html#call_mecolon_functions" class="calibre10">Chapter 3</a>, we learned how to create our own <code class="calibre20">error</code> values. We said, “An error value is any value with a method named <code class="calibre20">Error</code> that returns a string.”</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0340-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">That’s right. The <code class="calibre20">error</code> type is just an interface! It looks something like this:</p>
<pre data-type="programlisting" class="calibre32">type error interface {
       Error() string
}</pre>
<p class="calibre7">Declaring the <code class="calibre20">error</code> type as an interface means that if it has an <code class="calibre20">Error</code> method that returns a <code class="calibre20">string</code>, it satisfies the <code class="calibre20">error</code> interface, and it’s an <code class="calibre20">error</code> value. That means you can define your own types and use them anywhere an <code class="calibre20">error</code> value is required!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0340-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">For example, here’s a simple defined type, <code class="calibre20">ComedyError</code>. Because it has an <code class="calibre20">Error</code> method that returns a <code class="calibre20">string</code>, it satisfies the <code class="calibre20">error</code> interface, and we can assign it to a variable with the type <code class="calibre20">error</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0340-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="blocks of code" data-secondary="universe block" data-type="indexterm" id="idm46062710045144" class="calibre10"/><a data-primary="universe block" data-type="indexterm" id="idm46062710043608" class="calibre10"/>If you need an <code class="calibre20">error</code> value, but also need to track more information about the error than just an error message string, you can create your own type that satisfies the <code class="calibre20">error</code> interface <em class="calibre9">and</em> stores the information you want.</p>
<p class="calibre7">Suppose you’re writing a program that monitors some equipment to ensure it doesn’t overheat. Here’s an <code class="calibre20">OverheatError</code> type that might be useful. It has an <code class="calibre20">Error</code> method, so it satisfies <code class="calibre20">error</code>. But more interestingly, it uses <code class="calibre20">float64</code> as its underlying type, allowing us to track the degrees over capacity.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0341-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Here’s a <code class="calibre20">checkTemperature</code> function that uses <code class="calibre20">OverheatError</code>. It takes the system’s actual temperature and the temperature that’s considered safe as parameters. It specifies that it returns a value of type <code class="calibre20">error</code>, not an <code class="calibre20">OverheatError</code> specifically, but that’s okay because <code class="calibre20">OverheatError</code> satisfies the <code class="calibre20">error</code> interface. If the <code class="calibre20">actual</code> temperature is over the <code class="calibre20">safe</code> temperature, <code class="calibre20">checkTemperature</code> returns a new <code class="calibre20">OverheatError</code> that records the excess.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0341-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="there are no Dumb Questions" data-type="sect1" class="preface"><div class="preface" id="there_are_no_dumb_questions_9">
<h1 class="calibre25">there are no Dumb Questions</h1>
<p class="calibre7"><strong class="calibre8">Q: How is it we’ve been using the <code class="calibre40">error</code> interface type in all these different packages, without importing it? Its name begins with a lowercase letter. Doesn’t that mean it’s unexported, from whatever package it’s declared in? What package is <code class="calibre40">error</code> declared in, anyway?</strong></p>
<p class="calibre7"><strong class="calibre8">A:</strong> The <code class="calibre20">error</code> type is a “predeclared identifier,” like <code class="calibre20">int</code> or <code class="calibre20">string</code>. And so, like other predeclared identifiers, it’s not part of <em class="calibre9">any</em> package. It’s part of the “universe block,” meaning it’s available everywhere, regardless of what package you’re in.</p>
<p class="calibre7">Remember how there are <code class="calibre20">if</code> and <code class="calibre20">for</code> blocks, which are encompassed by function blocks, which are encompassed by package blocks? Well, the universe block encompasses all package blocks. That means you can use anything defined in the universe block from any package, without importing it. And that includes <code class="calibre20">error</code> and all other predeclared identifiers.</p>
</div></section>
<section data-pdf-bookmark="The Stringer interface" data-type="sect1" class="preface"><div class="preface" id="the_stringer_interface">
<h1 class="calibre25">The Stringer interface</h1>
<p class="calibre7"><a data-primary="fmt package" data-secondary="Stringer interface" data-type="indexterm" id="idm46062710020360" class="calibre10"/><a data-primary="Printf function (fmt)" data-secondary="Stringer interface and" data-type="indexterm" id="idm46062710019112" class="calibre10"/><a data-primary="Stringer interface (fmt)" data-type="indexterm" id="idm46062710017592" class="calibre10"/>Remember our <code class="calibre20">Gallons</code>, <code class="calibre20">Liters</code>, and <code class="calibre20">Milliliters</code> types, which we created back in <a data-type="xref" href="ch09.html#yoursquore_my_typecolon_defined_types" class="calibre10">Chapter 9</a> to distinguish between various units for measuring volume? We’re discovering that it’s not so easy to distinguish between them after all. Twelve gallons is a very different amount than 12 liters or 12 milliliters, but they all look the same when printed. If there are too many decimal places of precision on a value, that looks awkward when printed, too.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0342-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You can use <code class="calibre20">Printf</code> to round the number off and add an abbreviation indicating the unit of measure, but doing that every place you need to use these types would quickly get tedious.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0342-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">That’s why the <code class="calibre20">fmt</code> package defines the <code class="calibre20">fmt.Stringer</code> interface: to allow any type to decide how it will be displayed when printed. It’s easy to set up any type to satisfy <code class="calibre20">Stringer</code>; just define a <code class="calibre20">String()</code> method that returns a <code class="calibre20">string</code>. The interface definition looks like this:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0342-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">For example, here we’ve set up this <code class="calibre20">CoffeePot</code> type to satisfy <code class="calibre20">Stringer</code>:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0342-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="fmt package" data-secondary="Print function" data-type="indexterm" id="idm46062710000616" class="calibre10"/><a data-primary="fmt package" data-secondary="Println function" data-type="indexterm" id="idm46062709999192" class="calibre10"/><a data-primary="Print function (fmt)" data-type="indexterm" id="idm46062709998072" class="calibre10"/><a data-primary="Println function (fmt)" data-type="indexterm" id="idm46062709997240" class="calibre10"/>Many functions in the <code class="calibre20">fmt</code> package check whether the values passed to them satisfy the <code class="calibre20">Stringer</code> interface, and call their <code class="calibre20">String</code> methods if so. This includes the <code class="calibre20">Print</code>, <code class="calibre20">Println</code>, and <code class="calibre20">Printf</code> functions and more. Now that <code class="calibre20">CoffeePot</code> satisfies <code class="calibre20">Stringer</code>, we can pass <code class="calibre20">CoffeePot</code> values directly to these functions, and the return value of the <code class="calibre20">CoffeePot</code>’s <code class="calibre20">String</code> method will be used in the output:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0343-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Now for a more serious use of this interface type. Let’s make our <code class="calibre20">Gallons</code>, <code class="calibre20">Liters</code>, and <code class="calibre20">Milliliters</code> types satisfy <code class="calibre20">Stringer</code>. We’ll move our code to format their values to <code class="calibre20">String</code> methods associated with each type. We’ll call the <code class="calibre20">Sprintf</code> function instead of <code class="calibre20">Printf</code>, and return the resulting value.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0343-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Now, any time we pass <code class="calibre20">Gallons</code>, <code class="calibre20">Liters</code>, and <code class="calibre20">Milliliters</code> values to <code class="calibre20">Println</code> (or most other <code class="calibre20">fmt</code> functions), their <code class="calibre20">String</code> methods will be called, and the return values used in the output. We’ve set up a useful default format for printing each of these types!</p>
</div></section>
<section data-pdf-bookmark="The empty interface" data-type="sect1" class="preface"><div class="preface" id="the_empty_interface">
<h1 class="calibre25">The empty interface</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0344-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="empty interface" data-type="indexterm" id="idm46062709977224" class="calibre10"/><a data-primary="functions" data-secondary="variadic" data-type="indexterm" id="idm46062709975880" class="calibre10"/><a data-primary="interfaces" data-secondary="empty" data-type="indexterm" id="idm46062709974696" class="calibre10"/><a data-primary="interface types" data-secondary="empty interface" data-type="indexterm" id="idm46062709973624" class="calibre10"/><a data-primary="variadic functions" data-secondary="about" data-type="indexterm" id="idm46062709972488" class="calibre10"/>Good question! Let’s run <code class="calibre20"><strong class="calibre39">go doc</strong></code> to bring up the documentation for <code class="calibre20">fmt.Println</code> and see what type its parameters are declared as...</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0344-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">As we saw in <a data-type="xref" href="ch06.html#appending_issuecolon_slices" class="calibre10">Chapter 6</a>, the <code class="calibre20">...</code> means that it’s a variadic function, meaning it can take any number of parameters. But what’s this <code class="calibre20">interface{}</code> type?</p>
<p class="calibre7">Remember, an interface declaration specifies the methods that a type is required to have in order to satisfy that interface. For example, our <code class="calibre20">NoiseMaker</code> interface is satisfied by any type that has a <code class="calibre20">MakeSound</code> method.</p>
<pre data-type="programlisting" class="calibre32">type NoiseMaker interface {
       MakeSound()
}</pre>
<p class="calibre7">But what would happen if we declared an interface type that didn’t require any methods at all? It would be satisfied by <em class="calibre9">any</em> type! It would be satisfied by <em class="calibre9">all</em> types!</p>
<pre data-type="programlisting" class="calibre32">type Anything interface {
}</pre>
<p class="calibre7"><a data-primary="methods" data-secondary="interfaces and" data-type="indexterm" id="idm46062709961816" class="calibre10"/>The type <code class="calibre20">interface{}</code> is known as <strong class="calibre8">the empty interface</strong>, and it’s used to accept values of <em class="calibre9">any</em> type. The empty interface doesn’t have any methods that are required to satisfy it, and so <em class="calibre9">every</em> type satisfies it.</p>
<p class="calibre7">If you declare a function that accepts a parameter with the empty interface as its type, then you can pass it values of any type as an argument:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0345-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">The empty interface doesn’t require any methods to satisfy it, and so it’s satisfied by <span class="calibre21">all</span> types.</strong></p>
</blockquote>
<p class="calibre7">But don’t rush out and start using the empty interface for all your function parameters! If you have a value with the empty interface as its type, there’s not much you can <em class="calibre9">do</em> with it.</p>
<p class="calibre7">Most of the functions in <code class="calibre20">fmt</code> accept empty-interface values, so you can pass it on to those:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0345-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">But don’t try calling any methods on an empty-interface value! Remember, if you have a value with an interface type, you can only call methods on it that are part of the interface. And the empty interface doesn’t <em class="calibre9">have</em> any methods. That means there are <em class="calibre9">no</em> methods you can call on a value with the empty interface type!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0345-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">To call methods on a value with the empty interface type, you’d need to use a type assertion to get a value of the concrete type back.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0346-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">And by that point, you’re probably better off writing a function that accepts only that specific concrete type.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0346-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">So there are limits to the usefulness of the empty interface when defining your own functions. But you’ll use the empty interface all the time with the functions in the <code class="calibre20">fmt</code> package, and in other places too. The next time you see an <code class="calibre20">interface{}</code> parameter in a function’s documentation, you’ll know exactly what it means!</p>
<p class="calibre7">When you’re defining variables or function parameters, often you’ll know exactly what the value you’ll be working with <em class="calibre9">is</em>. You’ll be able to use a concrete type like <code class="calibre20">Pen</code>, <code class="calibre20">Car</code>, or <code class="calibre20">Whistle</code>. Other times, though, you only care about what the value can <em class="calibre9">do</em>. In that case, you’re going to want to define an interface type, like <code class="calibre20">WritingInstrument</code>, <code class="calibre20">Vehicle</code>, or <code class="calibre20">NoiseMaker</code>.</p>
<p class="calibre7">You’ll define the methods you need to be able to call as part of the interface type. And you’ll be able to assign to your variables or call your functions without worrying about the concrete type of your values. If it has the right methods, you’ll be able to use it!</p>
</div></section>
<section data-pdf-bookmark="Your Go Toolbox" data-type="sect1" class="preface"><div class="preface" id="your_go_toolbox_11">
<h1 class="calibre25">Your Go Toolbox</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0347-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">That’s it for <a data-type="xref" href="ch11_split_000.html#what_can_you_doquestcolon_interfaces" class="calibre10">Chapter 11</a>! You’ve added interfaces to your toolbox.</strong></p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="calibre7"><strong class="calibre8">Interfaces</strong></p>
<p class="calibre7">An interface is a set of methods certain values are expected to have.</p>
<p class="calibre7">Any type that has all the methods listed in an interface definition is said to satisfy that interface.</p>
<p class="calibre7">A type that satisfies an interface can be assigned to any variable or function parameter that uses that interface as its type.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="bullet_point_11">
<h5 class="calibre31">Bullet Points</h5>
<ul class="list_style_type_none">
<li class="calibre18"><p class="calibre7">A concrete type specifies not only what its values can <em class="calibre9">do</em> (what methods you can call on them), but also what they <em class="calibre9">are</em>: they specify the underlying type that holds the value’s data.</p></li>
<li class="calibre18"><p class="calibre7">An interface type is an abstract type. Interfaces don’t describe what a value <em class="calibre9">is</em>: they don’t say what its underlying type is or how its data is stored. They only describe what a value can <em class="calibre9">do</em>: what methods it has.</p></li>
<li class="calibre18"><p class="calibre7">An interface definition needs to contain a list of method names, along with any parameters or return values those methods are expected to have.</p></li>
<li class="calibre18"><p class="calibre7">To satisfy an interface, a type must have all the methods the interface specifies. Method names, parameter types (or lack thereof), and return value types (or lack thereof) all need to match those defined in the interface.</p></li>
<li class="calibre18"><p class="calibre7">A type can have methods in addition to those listed in the interface, but it mustn’t be missing any, or it doesn’t satisfy that interface.</p></li>
<li class="calibre18"><p class="calibre7">A type can satisfy multiple interfaces, and an interface can have multiple types that satisfy it.</p></li>
<li class="calibre18"><p class="calibre7">Interface satisfaction is automatic. There is no need to explicitly declare that a concrete type satisfies an interface in Go.</p></li>
<li class="calibre18"><p class="calibre7">When you have a variable of an interface type, the only methods you can call on it are those defined in the interface.</p></li>
<li class="calibre18"><p class="calibre7">If you’ve assigned a value of a concrete type to a variable with an interface type, you can use a <strong class="calibre8">type assertion</strong> to get the concrete type value back. Only then can you call methods that are defined on the concrete type (but not the interface).</p></li>
<li class="calibre18"><p class="calibre7">Type assertions return a second <code class="calibre20">bool</code> value that indicates whether the assertion was successful.</p>
<pre data-type="programlisting" class="calibre32">car, ok := vehicle.(Car)</pre></li>
</ul>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solution_21">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0348-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Pool Puzzle Solution" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_solution_7">
<h1 class="calibre25">Pool Puzzle Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0348-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
</div></section></body></html>