- en: Chapter 3\. Go Language Foundations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Go语言基础
- en: A language that doesn’t affect the way you think about programming is not worth
    knowing.^([1](ch03.xhtml#idm45983647379672))
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种不影响编程思维方式的语言是不值得学习的。^([1](ch03.xhtml#idm45983647379672))
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alan Perlis, ACM SIGPLAN Notices (September 1982)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alan Perlis，ACM SIGPLAN Notices（1982年9月）
- en: No programming book would be complete without at least a brief refresher of
    its language of choice, so here we are!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本编程书籍会完整，而不至少简短地回顾其所选择的语言，所以我们在这里！
- en: This chapter will differ slightly from the ones in more introductory level books,
    however, in that we’re assuming that you’re at least familiar with common coding
    paradigms but may or may not be a little rusty with the finer points of Go syntax.
    As such, this chapter will focus as much on Go’s nuances and subtleties as its
    fundamentals. For a deeper dive into the latter, I recommend either [*Introducing
    Go*](https://oreil.ly/9Ht4R) by Caleb Doxsey (O’Reilly) or *The Go Programming
    Language* by Alan A. A. Donovan and Brian W. Kernighan (Addison-Wesley Professional)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与更初级的书籍略有不同，我们假设您至少熟悉常见的编码范例，但可能对Go语法的一些细节有些生疏。因此，本章将侧重于Go语言的微妙之处，以及其基础知识。如需更深入地了解后者，我建议阅读
    [*Go 语言编程*](https://oreil.ly/9Ht4R)（Caleb Doxsey著，O'Reilly出版社）或 *Go 程序设计语言*（Alan
    A. A. Donovan 和 Brian W. Kernighan著，Addison-Wesley Professional出版社）。
- en: 'If you’re relatively new to the language, you’ll definitely want to read on.
    Even if you’re somewhat comfortable with Go, you might want to skim this chapter:
    there will be a gem or two in here for you. If you’re a seasoned veteran of the
    language, you can go ahead and move on to the next chapter (or read it ironically
    and judge me).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对该语言相对陌生，您肯定会希望继续阅读。即使您对Go语言有些了解，您可能也想浏览本章内容：这里会有一两个宝藏。如果您是该语言的老手，可以直接进入下一章（或以讽刺的方式阅读并评判我）。
- en: Basic Data Types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据类型
- en: 'Go’s basic data types, the fundamental building blocks from which more complex
    types are constructed, can be divided into three subcategories:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go的基本数据类型是更复杂类型的基础构件，可以分为三个子类别：
- en: Booleans that contain only one bit of information—`true` or `false`—representing
    some logical conclusion or state.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔类型仅包含一位信息 — `true` 或 `false` — 表示某种逻辑结论或状态。
- en: Numeric types that represent simple—variously sized floating point and signed
    and unsigned integers—or complex numbers.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示简单浮点和有符号/无符号整数或复数的数值类型。
- en: Strings that represent an immutable sequence of Unicode code points.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表不可变的Unicode代码点序列的字符串。
- en: Booleans
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'The Boolean data type, representing the two logical truth values, exists in
    some form^([2](ch03.xhtml#idm45983647325000)) in every programming language ever
    devised. It’s represented by the `bool` type, a special 1-bit integer type that
    has two possible values:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数据类型代表两个逻辑真值，以某种形式存在^([2](ch03.xhtml#idm45983647325000))于每一种编程语言中。它由 `bool`
    类型表示，是一种特殊的1位整数类型，具有两个可能的值：
- en: '`true`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`'
- en: '`false`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: 'Go supports all of the typical logical operations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持所有典型的逻辑操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Curiously, Go doesn’t include a logical XOR operator. There *is* a `^` operator,
    but it’s reserved for bitwise XOR operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Go语言不包含逻辑异或运算符。但是，存在 `^` 运算符，但它仅用于按位异或操作。
- en: Simple Numbers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单数值
- en: 'Go has a small menagerie of systematically named, floating point, and signed
    and unsigned integer numbers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go具有一小部分系统命名的、浮点、有符号和无符号整数：
- en: Signed integer
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号整数
- en: '`int8`, `int16`, `int32`, `int64`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`int8`，`int16`，`int32`，`int64`'
- en: Unsigned integer
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数
- en: '`uint8`, `uint16`, `uint32`, `uint64`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint8`，`uint16`，`uint32`，`uint64`'
- en: Floating point
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数
- en: '`float32`, `float64`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`float32`，`float64`'
- en: Systematic naming is nice, but code is written by humans with squishy human
    brains, so the Go designers provided two lovely conveniences.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 系统化命名很好，但代码是由人类用软软的人类大脑编写的，因此Go设计者提供了两个可爱的便利。
- en: First, there are two “machine dependent” types, simply called `int` and `uint`,
    whose size is determined based on available hardware. These are convenient if
    the specific size of your numbers isn’t critical. Sadly, there’s no machine-dependent
    floating-point number type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有两种“机器相关”类型，简称为 `int` 和 `uint`，其大小根据可用硬件确定。如果您的数字的特定大小并不重要，这些类型非常方便。遗憾的是，并没有机器相关的浮点数类型。
- en: 'Second, two integer types have mnemonic aliases: `byte`, which is an alias
    for `uint8`; and `rune`, which is an alias for `uint32`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，有两种整数类型具有助记别名：`byte`，是 `uint8` 的别名；`rune`，是 `uint32` 的别名。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For most uses, it generally makes sense to just use `int` and `float64`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用途，通常只需使用`int`和`float64`就足够了。
- en: Complex Numbers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: 'Go offers two sizes of *complex numbers*, if you’re feeling a little imaginative:^([3](ch03.xhtml#idm45983647252184))
    `complex64` and `complex128`. These can be expressed as an *imaginary literal*
    by a floating point immediately followed by an `i`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供两种大小的*复数*，如果你感觉有点富有想象力：^([3](ch03.xhtml#idm45983647252184)) `complex64`
    和 `complex128`。这些可以通过浮点数后紧接着的`i`来表示为*虚数字面量*：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Complex numbers are very neat but don’t come into play all that often, so I
    won’t drill down into them here. If you’re as fascinated by them as I hope you
    are, *The Go Programming Language* by Donovan and Kernighan gives them the full
    treatment they deserve.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 复数非常有趣，但实际上并不经常使用，所以我在这里不会深入讨论它们。如果你像我希望的那样着迷于它们，《Go编程语言》（Donovan 和 Kernighan）为它们提供了应有的全面解释。
- en: Strings
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A *string* represents a sequence of Unicode code points. Strings in Go are
    immutable: once created, it’s not possible to change a string’s contents.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*代表Unicode代码点序列。Go 中的字符串是不可变的：一旦创建，就无法更改字符串的内容。'
- en: 'Go supports two styles of string literals, the double-quote style (or interpreted
    literals) and the back-quote style (or raw string literals). For example, the
    following two string literals are equivalent:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持两种风格的字符串字面量，双引号风格（或解释字面量）和反引号风格（或原始字符串字面量）。例如，以下两个字符串字面量是等效的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this interpreted string literal, each `\n` character pair will be escaped
    as one newline character, and each `\"` character pair will be escaped as one
    double-quote character.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个解释字符串字面量中，每个`\n`字符对将被转义为一个换行符字符，每个`\"`字符对将被转义为一个双引号字符。
- en: Behind the scenes, a string is actually just a wrapper around a slice of UTF-8
    encoded `byte` values, so any operation that can be applied to slices and arrays
    can also be applied to strings. If you aren’t clear on slices yet, you can take
    this moment to read ahead to [“Slices”](#section_ch03_slices).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，字符串实际上只是围绕UTF-8编码的`byte`值切片的包装器，因此可以对切片和数组应用的任何操作也可以应用于字符串。如果你对切片还不清楚，现在可以阅读到[“切片”](#section_ch03_slices)部分。
- en: Variables
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables can be declared by using the `var` keyword to pair an identifier
    with some typed value, and may be updated at any time, with the general form:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过使用`var`关键字将标识符与某些类型值配对，并且可以随时更新，其一般形式为：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, there is considerable flexibility in variable declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，变量声明有相当大的灵活性：
- en: 'With initialization: `var foo int = 42`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带初始化：`var foo int = 42`
- en: 'Of multiple variables: `var foo, bar int = 42, 1302`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个变量的情况：`var foo, bar int = 42, 1302`
- en: 'With type inference: `var foo = 42`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带类型推断：`var foo = 42`
- en: 'Of mixed multiple types: `var b, f, s = true, 2.3, "four"`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合多种类型的变量：`var b, f, s = true, 2.3, "four"`
- en: 'Without initialization (see [“Zero Values”](#section_ch03_zero_values)): `var
    s string`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未初始化（参见[“零值”](#section_ch03_zero_values)）：`var s string`
- en: Note
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Go is very opinionated about clutter: it *hates* it. If you declare a variable
    in a function but don’t use it, your program will refuse to compile.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对于杂乱的事物非常有主张：它*讨厌*它们。如果在函数中声明了一个变量但没有使用它，你的程序将拒绝编译。
- en: Short Variable Declarations
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短变量声明
- en: Go provides a bit of syntactic sugar that allows variables within functions
    to be simultaneously declared and assigned by using the `:=` operator in place
    of a `var` declaration with an implicit type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一些语法糖，允许在函数内部使用`:=`操作符同时声明和赋值变量，而不是使用具有隐式类型的`var`声明。
- en: 'Short variable declarations have the general form:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 短变量声明的一般形式为：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These can be used to declare both single and multiple assignments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以用来声明单个和多个赋值：
- en: 'With initialization: `percent := rand.Float64() * 100.0`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带初始化：`percent := rand.Float64() * 100.0`
- en: 'Multiple variables at once: `x, y := 0, 2`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性多个变量：`x, y := 0, 2`
- en: In practice, short variable declarations are the most common way that variables
    are declared and initialized in Go; `var` is usually only used either for local
    variables that need an explicit type, or to declare a variable that will be assigned
    a value later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，短变量声明是Go中声明和初始化变量的最常见方式；`var`通常仅用于需要显式类型的局部变量，或者声明稍后将赋值的变量。
- en: Warning
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Remember that `:=` is a declaration, and `=` is an assignment. A `:=` operator
    that only attempts to redeclare existing variables will fail at compile time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`:=`是一个声明，而`=`是一个赋值操作符。如果`:=`操作符仅尝试重新声明已存在的变量，将在编译时失败。
- en: Interestingly (and sometimes confusingly), if a short variable declaration has
    a mix of new and existing variables on its left-hand side, the short variable
    declaration acts like an assignment to the existing variables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是（有时会令人困惑），如果短变量声明在其左侧同时包含新变量和现有变量，那么该短变量声明将像对现有变量进行赋值一样。
- en: Zero Values
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零值
- en: 'When a variable is declared without an explicit value, it’s assigned to the
    *zero value* for its type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量声明时没有明确的值时，它将被分配给其类型的*零值*：
- en: 'Integers: `0`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：`0`
- en: 'Floats: `0.0`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数：`0.0`
- en: 'Booleans: `false`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`false`
- en: 'Strings: `""` (the empty string)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`""`（空字符串）
- en: 'To illustrate, let’s define four variables of various types, without explicit
    initialization:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们定义四个不同类型的变量，而不进行显式初始化：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if we were to use these variables we’d find that they were, in fact, already
    initialized to their zero values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要使用这些变量，我们会发现它们实际上已经初始化为它们的零值：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You’ll notice the use of the `fmt.Printf` function, which allows greater control
    over output format. If you’re not familiar with this function, or with Go’s format
    strings, see the following sidebar.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到使用`fmt.Printf`函数，它允许更好地控制输出格式。如果您对这个函数或Go语言的格式化字符串不熟悉，请参阅下面的侧边栏。
- en: The Blank Identifier
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白标识符
- en: The *blank identifier*, represented by the `_` (underscore) operator, acts as
    an anonymous placeholder. It may be used like any other identifier in a declaration,
    except it doesn’t introduce a binding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*空白标识符*由`_`（下划线）运算符表示，充当匿名占位符。它可以像声明中的任何其他标识符一样使用，只是它不引入绑定。'
- en: 'It’s most commonly used as a way to selectively ignore unneeded values in an
    assignment, which can be useful in a language that both supports multiple returns
    and demands there be no unused variables. For example, if you wanted to handle
    any potential errors returned by `fmt.Printf`, but don’t care about the number
    of bytes it writes,^([4](ch03.xhtml#idm45983646893816)) you could do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常被用作在赋值中选择性地忽略不需要的值的一种方式，在支持多返回值且要求没有未使用变量的语言中，这非常有用。例如，如果您想处理`fmt.Printf`返回的任何潜在错误，但不关心它写入的字节数，^([4](ch03.xhtml#idm45983646893816))，您可以执行以下操作：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The blank identifier can also be used to import a package solely for its side
    effects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 空白标识符也可以用于仅因其副作用而导入包：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Packages imported in this way are loaded and initialized as normal, including
    triggering any of its `init` functions, but are otherwise ignored and need not
    be referenced or otherwise directly used.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式导入的包将像正常加载和初始化一样运行，包括触发其`init`函数，但除此之外将被忽略且无需引用或直接使用。
- en: Constants
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'Constants are very similar to variables, using the `const` keyword to associate
    an identifier with some typed value. However, constants differ from variables
    in some important ways. First, and most obviously, attempting to modify a constant
    will generate an error at compile time. Second, constants *must* be assigned a
    value at declaration: they have no zero value.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 常量与变量非常相似，使用`const`关键字将标识符与某个类型化值关联。然而，常量在某些重要方面与变量不同。首先，最明显的是，试图修改一个常量将在编译时生成错误。其次，常量*必须*在声明时赋值：它们没有零值。
- en: 'Both `var` and `const` may be used at both the package and function level,
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`和`const`均可在包级和函数级别使用，如下所示：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To demonstrate their behavioral similarity, the previous snippet arbitrarily
    mixes explicit type definitions with type inference for both the constants and
    variables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它们行为的相似性，前面的代码片段任意混合了常量和变量的显式类型定义以及类型推断。
- en: Finally, the choice of `fmt.Sprintf` is inconsequential to this example, but
    if you’re unclear about Go’s format strings you can look back to [“Formatting
    I/O in Go”](#sidebar_ch03_printf).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选择`fmt.Sprintf`对于本例并不重要，但如果您对Go语言的格式化字符串不清楚，可以参考[“在Go中格式化I/O”](#sidebar_ch03_printf)。
- en: 'Container Types: Arrays, Slices, and Maps'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器类型：数组、切片和映射
- en: 'Go has three first-class container types that can be used to store collections
    of element values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有三种一流的容器类型，用于存储元素值的集合：
- en: ArrayArray
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数组数组
- en: A fixed-length sequence of zero or more elements of a particular type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个固定长度的特定类型的零个或多个元素的序列。
- en: Slice
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 切片
- en: An abstraction around an array that can be resized at runtime.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个围绕可以在运行时调整大小的数组的抽象。
- en: Map
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 映射
- en: An associative data structure that allows distinct keys to be arbitrarily paired
    with, or “mapped to,” values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将不同键与值“映射”或配对的关联数据结构。
- en: As container types, all of these have a `length` property that reflects how
    many elements are stored in that container. The `len` built-in function can be
    used to find the length of any array, slice (including strings), or map.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为容器类型，所有这些都有一个`length`属性，反映存储在该容器中的元素数量。可以使用内置函数`len`来查找任何数组、切片（包括字符串）或映射的长度。
- en: Arrays
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: In Go, as in most other mainstream languages, an *array* is a fixed-length sequence
    of zero or more elements of a particular type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，与大多数其他主流语言一样，*数组* 是特定类型的零个或多个元素的固定长度序列。
- en: 'Arrays can be declared by including a length declaration. The zero value of
    an array is an array of the specified length containing zero-valued elements.
    Individual array elements are indexed from `0` to `N-1`, and can be accessed using
    the familiar bracket notation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过包含长度声明来声明数组。数组的零值是一个包含指定长度的元素全为零值的数组。单个数组元素从`0`到`N-1`进行索引，并且可以使用熟悉的括号表示法访问：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Arrays can be initialized using array literals, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用数组文字初始化数组，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also have the compiler count the array elements for you:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以让编译器为您计算数组元素的数量：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In both cases, the type of `b` is `[3]int`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`b`的类型都是`[3]int`。
- en: 'As with all container types, the `len` built-in function can be used to discover
    the length of an array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有容器类型一样，可以使用`len`内置函数来发现数组的长度：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In practice, arrays aren’t actually used directly very often. Instead, it’s
    much more common to use *slices*, an array abstraction type that behaves (for
    all practical purposes) like a resizable array.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，数组并不经常直接使用。相反，更常见的是使用 *切片*，一种行为（在所有实际目的上）类似于可调整大小数组的数组抽象类型。
- en: Slices
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: Slices are a data type in Go that provide a powerful abstraction around a traditional
    array, such that working with slices looks and feels to the programmer very much
    like working with arrays. Like arrays, slices provide access to a sequence of
    elements of a particular type via the familiar bracket notation, indexed from
    `0` to `N-1`. However, where arrays are fixed-length, slices can be resized at
    runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是 Go 语言中的一种数据类型，它们在传统数组周围提供了一个强大的抽象，使得与切片的操作看起来和感觉起来非常类似于操作数组。与数组一样，切片通过熟悉的括号表示法提供对特定类型元素序列的访问，索引从`0`到`N-1`。然而，数组是固定长度的，而切片可以在运行时调整大小。
- en: 'As shown in [Figure 3-1](#img_ch03_slice), a slice is actually a lightweight
    data structure with three components:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 3-1](#img_ch03_slice)所示，切片实际上是一个轻量级数据结构，具有三个组件：
- en: A pointer to some element of a backing array that represents the first element
    of the slice (not necessarily the first element of the array)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向表示切片第一个元素的支持数组中某个元素的指针（不一定是数组的第一个元素）
- en: A length, representing the number of elements in the slice
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个长度，表示切片中的元素数量
- en: A capacity, which represents the upper value of the length
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容量，表示长度的上限值
- en: If not otherwise specified, the capacity value equals the number of elements
    between the start of the slice and the end of the backing array. The built-in
    `len` and `cap` functions will provide the length and capacity of a slice, respectively.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未另行指定，则容量值等于切片起始位置到支持数组末尾的元素数。内置函数`len`和`cap`分别提供切片的长度和容量。
- en: '![cngo 0301](Images/cngo_0301.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0301](Images/cngo_0301.png)'
- en: Figure 3-1\. Two slices backed by the same array
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. 由同一数组支持的两个切片
- en: Working with slices
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用切片
- en: 'Creating a slice is somewhat different from creating an array: slices are typed
    only according to the type of their elements, not their number. The `make` built-in
    function can be used to create a slice with a nonzero length as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 创建切片与创建数组有所不同：切片仅根据其元素类型而不是其数量进行类型化。可以使用`make`内置函数创建具有非零长度的切片，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, working with slices feels a lot like working with arrays. Like
    arrays, the zero value of a slice is a slice of the specified length containing
    zero-valued elements, and elements in a slice are indexed and accessed exactly
    like they are in an array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，使用切片的感觉与使用数组的感觉非常相似。与数组一样，切片的零值是一个包含指定长度的零值元素的切片，切片中的元素像在数组中一样进行索引和访问。
- en: 'A slice literal is declared just like an array literal, except that you omit
    the element count:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 切片文字与数组文字声明方式相同，只是省略了元素计数：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Slices can be extended using the `append` built-in, which returns an extended
    slice containing one or more new values appended to the original one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`append`内置函数扩展切片，它返回一个包含一个或多个附加到原始切片中的新值的扩展切片：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `append` built-in function also happens to be *variadic*, which means it
    can accept a variable number of arguments in addition to the slice to be appended.
    Variadic functions will be covered in more detail in [“Variadic Functions”](#section_ch03_variadic_functions):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`内置函数也是*可变参数*的，这意味着它除了要附加的切片之外还可以接受可变数量的参数。可变参数函数将在[“可变参数函数”](https://example.org/section_ch03_variadic_functions)中更详细地介绍：'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `append` built-in function returns the appended slice rather than
    modifying the slice in place. The reason for this is that behind the scenes, if
    the destination has sufficient capacity to accommodate the new elements, then
    a new slice is constructed from the original underlying array. If not, a new underlying
    array is automatically allocated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`append`内置函数返回附加的切片，而不是在原地修改切片。其背后的原因是，如果目标具有足够的容量来容纳新元素，则从原始的底层数组构造一个新切片。如果没有，将自动分配一个新的底层数组。
- en: Warning
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Note that `append` *returns* the appended slice. Failing to store it is a common
    error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`append` *返回* 附加的切片。未存储它是一个常见的错误。
- en: The slice operator
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片操作符
- en: Arrays and slices (including strings) support the *slice operator*, which has
    the syntax `s[i:j]`, where `i` and `j` are in the range `0 ≤ i ≤ j ≤ cap(s)`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片（包括字符串）支持*切片操作符*，其语法为`s[i:j]`，其中`i`和`j`在范围`0 ≤ i ≤ j ≤ cap(s)`内。
- en: 'For example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous snippet, we define a slice literal. Recall that it closely resembles
    an array literal, except that it doesn’t indicate a size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们定义了一个切片字面量。请记住，它与数组字面量非常相似，只是它不指示大小。
- en: 'If the values of `i` or `j` are omitted from a slice operator, they’ll default
    to `0` and `len(s)`, respectively:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切片操作符的值`i`或`j`被省略，它们将默认为`0`和`len(s)`，分别：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A slice operator will produce a new slice backed by the same array with a length
    of `j - i`. Changes made to this slice will be reflected in the underlying array,
    and subsequently in all slices derived from that same array:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符将生成一个新的切片，其长度为`j - i`，由相同的数组支持。对此切片的更改将反映在底层数组中，随后反映在所有从同一数组派生的切片中：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This effect is illustrated in more detail in [Figure 3-1](#img_ch03_slice).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此效果在[图3-1](https://example.org/img_ch03_slice)中有更详细的说明。
- en: Strings as slices
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串作为切片
- en: The subject of how Go implements strings under the hood is actually quite a
    bit more complex than you might expect, involving lots of details like the differences
    between bytes, characters, and runes; Unicode versus UTF-8 encoding; and the differences
    between a string and a string literal.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Go 如何在幕后实现字符串的主题实际上比你可能期望的要复杂得多，涉及到诸如字节、字符和符文之间的差异；Unicode 与 UTF-8 编码之间的区别；以及字符串与字符串字面量之间的差异。
- en: 'For now it’s sufficient to know that Go strings are essentially just read-only
    slices of bytes that typically (but aren’t *required* to) contain a series of
    UTF-8 sequences representing Unicode code points, called `runes`. Go even allows
    you to cast your strings into `byte` or `rune` arrays:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，了解 Go 字符串本质上只是字节的只读切片就足够了，通常（但不是*必须*）包含一系列表示 Unicode 代码点的 UTF-8 序列，称为`符文`。Go
    甚至允许您将字符串转换为`byte`或`rune`数组：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By casting the string `s` in this way, we’re able to uncover its identity as
    either a slice of bytes or a slice of runes. We can illustrate this by using `fmt.Printf`
    with the `%T` (type) and `%v` (value) flags (which we presented in [“Formatting
    I/O in Go”](#sidebar_ch03_printf)) to output the results:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式将字符串`s`强制转换，我们能够揭示它作为字节切片或符文切片的身份。我们可以通过使用`fmt.Printf`与`%T`（类型）和`%v`（值）标志（我们在[“在
    Go 中格式化 I/O”](https://example.org/sidebar_ch03_printf)中介绍过）来输出结果来说明这一点：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the value of the string literal, `foö`, contains a mix of characters
    whose encoding can be contained in a single byte (`f` and `o`, encoded as `102`
    and `111`, respectively) and one character that cannot (`ö`, encoded as `195 182`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串字面量`foö`的值包含一些字符的混合，其编码可以包含在一个字节中（`f`和`o`，编码分别为`102`和`111`），以及一个无法包含在一个字节中的字符（`ö`，编码为`195
    182`）。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the `byte` and `rune` types are mnemonic aliases for `uint8` and
    `int32`, respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`byte`和`rune`类型是`uint8`和`int32`的助记别名。
- en: Each of these lines print the type and value of the variables passed to it.
    As expected, the string value, `foö`, is printed literally. The next two lines
    are interesting, however. The `uint8` (byte) slice contains four bytes, which
    represent the string’s UTF-8 encoding (two 1-byte code points, and one 2-byte
    code point). The `int32` (rune) slice contains three values that represent the
    code points of the individual characters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每条语句打印传递给它的变量的类型和值。如预期的那样，字符串值`foö`被字面打印。然而，接下来的两行很有趣。`uint8`（字节）切片包含四个字节，这些字节表示字符串的UTF-8编码（两个1字节码点和一个2字节码点）。`int32`（rune）切片包含三个值，表示各个字符的码点。
- en: There’s far, far more to string encoding in Go, but we only have so much space.
    If you’re interested in learning more, take a look at Rob Pike’s “Strings, Bytes,
    Runes and Characters in Go” on [*The Go Blog*](https://oreil.ly/mgku7) for a deep
    dive into the subject.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go中的字符串编码还有很多内容，但我们的空间有限。如果你有兴趣了解更多，请看Rob Pike的《Go博客》中的“Go中的字符串、字节、符文和字符”深入研究这个主题。
- en: Maps
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图
- en: 'Go’s *map* data type references a *hash table*: an incredibly useful associative
    data structure that allows distinct keys to be arbitrarily “mapped” to values
    as key-value pairs. This data structure is common among today’s mainstream languages:
    if you’re coming to Go from one of these then you probably already use them, perhaps
    in the form of Python’s `dict`, Ruby’s `Hash`, or Java’s `HashMap`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Go的*map*数据类型引用了*哈希表*：这是一种非常有用的关联数据结构，允许将不同的键任意地“映射”到值作为键值对。这种数据结构在当今主流的语言中很常见：如果你从这些语言中的一个转到Go，则可能已经使用过它们，也许是Python的`dict`，Ruby的`Hash`，或Java的`HashMap`的形式。
- en: Map types in Go are written `map[K]V`, where `K` and `V` are the types of its
    keys and values, respectively. Any type that is comparable using the `==` operator
    may be used as a key, and `K` and `V` need not be of the same type. For example,
    `string` keys may be mapped to `float32` values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的地图类型写作`map[K]V`，其中`K`和`V`分别是其键和值的类型。任何可以使用`==`运算符进行比较的类型都可以用作键，并且`K`和`V`不需要是相同的类型。例如，可以将`string`键映射到`float32`值。
- en: 'A map can be initialized using the built-in `make` function, and its values
    can be referenced using the usual `name[key]` syntax. Our old friend `len` will
    return the number of key/value pairs in a map; the `delete` built-in can remove
    key/value pairs:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置的`make`函数初始化地图，并且可以使用通常的`name[key]`语法引用其值。我们的老朋友`len`将返回地图中键/值对的数量；`delete`内置函数可以删除键/值对：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Maps may also be initialized and populated as *map literals*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 地图也可以用*映射文字*来初始化和填充：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note the trailing comma on the last line. This is not optional: the code will
    refuse to compile if it’s missing.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一行的尾随逗号。这不是可选的：如果缺少它，代码将拒绝编译。
- en: Map membership testing
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图成员测试
- en: 'Requesting the value of a key that’s not present in a map won’t cause an exception
    to be thrown (those don’t exist in Go anyway) or return some kind of `null` value.
    Rather, it returns the zero value for the map’s value type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请求地图中不存在的键的值不会导致抛出异常（在Go中不存在异常），也不会返回某种`null`值。相反，它返回地图值类型的零值：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This can be a very useful feature because it reduces a lot of boilerplate membership
    testing when working with maps, but it can be a little tricky when your map happens
    to actually contain zero-valued values. Fortunately, accessing a map can also
    return a second optional `bool` that indicates whether the key is present in the
    map:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个非常有用的功能，因为在处理地图时可以减少很多样板成员测试，但当你的地图实际上包含零值时，可能会有些棘手。幸运的是，访问地图也可以返回第二个可选的`bool`，指示键是否存在于地图中：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, the value of `newton` is `0.0`. But is that really the correct
    value,^([5](ch03.xhtml#idm45983644570440)) or was there just no matching key?
    Fortunately, since `ok` is also `false`, we know the latter to be the case.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`newton`的值是`0.0`。但那真的是正确的值吗，^([5](ch03.xhtml#idm45983644570440))，还是只是没有匹配的键？幸运的是，由于`ok`也是`false`，我们知道是后者。
- en: Pointers
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: Okay. Pointers. The bane and undoing of undergraduates the world over. If you’re
    coming from a dynamically typed language, the idea of the pointer may seem alien
    to you. While we’re not going to drill down *too* deeply into the subject, we’ll
    do our best to cover it well enough to provide some clarity on the subject.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。指针。全世界的本科生的梦魇和毁灭。如果你来自一个动态类型语言，指针的概念可能对你来说很陌生。虽然我们不会对这个主题深入探讨*过度*，但我们会尽力详细介绍，以便在这个主题上提供一些清晰度。
- en: Going back to first principles, a “variable” is a piece of storage in memory
    that contains some value. Typically, when you refer to a variable by its name
    (`foo = 10`) or by an expression (`s[i] = "foo"`), you’re directly reading or
    updating the value of the variable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一原则，"变量" 是内存中包含某个值的存储空间。通常，当你通过其名称引用变量（`foo = 10`）或通过表达式引用变量时（`s[i] = "foo"`），你直接读取或更新变量的值。
- en: 'A *pointer* stores the *address* of a variable: the location in memory where
    the value is stored. Every variable has an address, and using pointers allows
    us to indirectly read or update the value of their variables (illustrated in [Figure 3-2](#img_ch03_pointers)):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针* 存储变量的*地址*：存储值的内存位置。每个变量都有一个地址，使用指针允许我们间接读取或更新它们的变量的值（如 [图 3-2](#img_ch03_pointers)
    所示）：'
- en: Retrieving the address of a variable
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检索变量的地址
- en: The address of a named variable can be retrieved by using the `&` operator.
    For example, the expression `p := &a` will obtain the address of `a` and assign
    it to `p`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `&` 操作符来检索命名变量的地址。例如，表达式 `p := &a` 将获取 `a` 的地址并将其赋给 `p`。
- en: Pointer types
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型
- en: The variable `p`, which you can say “points to” `a`, has a type of `*int`, where
    the `*` indicates that it’s a pointer type that points to an `int`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `p`，你可以说它“指向” `a`，其类型为 `*int`，其中 `*` 表示它是一个指向 `int` 的指针类型。
- en: Dereferencing a pointer
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用指针
- en: To retrieve the value of the value `a` from `p`, you can *dereference* it using
    a `*` before the pointer variable name, allowing us to indirectly read or update
    `a`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `p` 检索变量 `a` 的值，您可以使用在指针变量名称前加 `*` 的方法进行解引用，从而间接读取或更新 `a`。
- en: '![cngo 0302](Images/cngo_0302.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![cngo 0302](Images/cngo_0302.png)'
- en: Figure 3-2\. The expression `p := &a` gets the address of `a` and assigns it
    to `p`
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 表达式 `p := &a` 获取 `a` 的地址并将其赋给 `p`
- en: 'Now, to put everything in one place, take a look at the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有内容放在一起，看看以下内容：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Pointers can be declared like any other variable, with a zero value of `nil`
    if not explicitly initialized. They’re also comparable, being equal only if they
    contain the same address (that is, they point to the same variable) or if they
    are both `nil`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以像任何其他变量一样声明，如果没有明确初始化，则零值为 `nil`。它们也是可比较的，只有当它们包含相同地址（即它们指向相同变量）或者它们都是 `nil`
    时才相等：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because `n` is never initialized, its value is `nil`, and comparing it to `nil`
    returns `true`. The integers `x` and `y` both have a value of `0`, so comparing
    their values yields `true`, but they are still distinct variables, and comparing
    pointers to them still evaluates to `false`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `n` 从未初始化，其值为 `nil`，与 `nil` 比较返回 `true`。整数 `x` 和 `y` 均具有值 `0`，因此比较它们的值返回
    `true`，但它们仍然是不同的变量，比较它们的指针仍然评估为 `false`。
- en: Control Structures
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Any programmer coming to Go from another language will find its suite of control
    structures to be generally familiar, even comfortable (at first) for those coming
    from a language heavily influenced by C. However, there are some pretty important
    deviations in their implementation and usages that might seem odd at first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一种语言转到 Go 的任何程序员通常会发现其控制结构套件基本上是熟悉的，甚至对于那些受 C 语言强烈影响的人来说，在其实现和用法上有一些相当重要的偏差，这可能一开始看起来有些奇怪。
- en: For example, control structure statements don’t require lots of parentheses.
    Okay. Less clutter. That’s fine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，控制结构语句不需要很多括号。好的。少一点混乱。没问题。
- en: There’s also only one loop type. There is no `while`; only `for`. Seriously!
    It’s actually pretty cool, though. Read on, and you’ll see what I mean.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也只有一种循环类型。没有 `while`；只有 `for`。真的！尽管如此，它实际上非常酷。继续阅读，你就会明白我是什么意思。
- en: Fun with for
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有趣的 for
- en: The `for` statement is Go’s one and only loop construct, and while there’s no
    explicit `while` loop, Go’s `for` can provide all of its functionality, effectively
    unifying all of the entry control loop types to which you’ve become accustomed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语句是 Go 的唯一循环构造，虽然没有显式的 `while` 循环，但 Go 的 `for` 可以提供所有其功能，有效地统一了您已习惯的所有入口控制循环类型。'
- en: Go has no `do-while` equivalent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Go 没有 `do-while` 的等价物。
- en: The general for statement
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用的 for 语句
- en: 'The general form of `for` loops in Go is nearly identical to that of other
    C-family languages, in which three statements—the init statement, the continuation
    condition, and the post statement—are separated by semicolons in the traditional
    style. Any variables declared in the init statement will be scoped only to the
    `for` statement:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中`for`循环的一般形式与其他C语言家族几乎完全相同，其中的三个语句——初始化语句、继续条件和后置语句——在传统风格下由分号分隔。在初始化语句中声明的任何变量将仅在`for`语句中作用域内有效：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, `i` is initialized to 0\. At the end of each iteration `i`
    is incremented by 1, and if it’s still less than 10, the process repeats.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`i`被初始化为0。在每次迭代结束时，`i`增加1，如果仍然小于10，则重复此过程。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike most C-family languages, `for` statements don’t require parentheses around
    their clauses, and braces are required.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数C语言家族不同，`for`语句在其条件子句周围不需要括号，但必须使用大括号。
- en: 'In a break from traditional C-style languages, Go’s `for` statement’s init
    and post statements are entirely optional. As shown in the code that follows,
    this makes it considerably more flexible:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中，与传统的C风格语言不同，`for`语句的初始化语句和后置语句都是完全可选的。正如下面的代码所示，这使得它更加灵活：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `for` statement in the previous example has no init or post statements,
    only a bare condition. This is actually a big deal, because it means that `for`
    is able to fill the role traditionally occupied by the `while` loop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子中的`for`语句没有初始化或后置语句，只有一个裸条件。这实际上是一个大问题，因为这意味着`for`可以填补传统上由`while`循环占据的角色。
- en: 'Finally, omitting all three clauses from a `for` statement creates a block
    that loops infinitely, just like a traditional `while (true)`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`for`语句中省略所有三个子句将创建一个无限循环的块，就像传统的`while (true)`一样：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Because it lacks any terminating condition, the loop in the previous snippet
    will iterate forever. On purpose.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它缺少任何终止条件，所以前面片段中的循环将永远迭代下去。这是故意的。
- en: Looping over arrays and slices
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历数组和切片
- en: Go provides a useful keyword, `range`, that simplifies looping over a variety
    of data types.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个有用的关键字`range`，简化了对各种数据类型的循环遍历。
- en: 'In the case of arrays and slices, `range` can be used with a `for` statement
    to retrieve the index and the value of each element as it iterates:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组和切片，可以使用`range`结合`for`语句来获取每个元素的索引和值：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the previous example, the values of `i` and `v` will update each iteration
    to contain the index and value, respectively, of each element in the slice `s`.
    So the output will look something like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，变量`i`和`v`将在每次迭代中更新，分别包含切片`s`中每个元素的索引和值。因此，输出将类似于以下内容：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But what if you don’t need both of these values? After all, the Go compiler
    will demand that you use them if you declare them. Fortunately, as elsewhere in
    Go, the unneeded values can be discarded by using the “blank identifier,” signified
    by the underscore operator:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你不需要这两个值呢？毕竟，如果你声明它们，Go编译器会要求你使用它们。幸运的是，在Go的其他地方一样，可以通过使用“下划线运算符”来丢弃不需要的值：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As in the last example, the value `v` will update each iteration to contain
    the value of each element in the slice `a`. This time, however, the index value
    is conveniently ignored and discarded, and the Go compiler stays content.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个例子类似，变量`v`将在每次迭代中更新，分别包含切片`a`中每个元素的值。但是，这次方便地忽略和丢弃了索引值，而Go编译器则满足了。
- en: Looping over maps
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历映射
- en: 'The `range` keyword may be also be used with a `for` statement to loop over
    maps, with each iteration returning the current key and value:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`关键字也可以与`for`语句一起用于遍历映射，每次迭代返回当前的键和值：'
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that Go maps aren’t ordered, so the output won’t be either:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Go的映射不是有序的，因此输出也不会有序：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The if Statement
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: 'The typical application of the `if` statement in Go is consistent with other
    C-style languages, except for the lack of parentheses around the clause and the
    fact that braces are required:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，`if`语句的典型应用与其他C风格语言一致，唯一的区别是条件子句周围不需要括号，但必须使用大括号：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike most C-family languages, `if` statements don’t require parentheses around
    their clauses, and braces are required.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数C语言家族不同，`if`语句在其条件子句周围不需要括号，但必须使用大括号。
- en: 'Interestingly, Go allows an initialization statement to precede the condition
    clause in an `if` statement, allowing for a particularly useful idiom. For example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Go语言允许在`if`语句中的条件子句之前放置一个初始化语句，这是一种特别有用的习惯用法。例如：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note how the `err` variable is being initialized prior to a check for its definition,
    making it somewhat similar to the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`err`变量在检查其定义之前是如何被初始化的，这使得它与以下内容有些相似：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The two constructs aren’t exactly equivalent however: in the first example
    `err` is scoped only to the `if` statement; in the second example `err` is visible
    to the entire containing function.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这两个结构并不完全等价：在第一个示例中，`err`的作用域仅限于`if`语句；而在第二个示例中，`err`对整个包含函数可见。
- en: The switch Statement
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: As in other languages, Go provides a `switch` statement that provides a way
    to more concisely express a series of `if-then-else` conditionals. However, it
    differs from the traditional implementation in a number of ways that make it considerably
    more flexible.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言类似，Go语言提供了一个`switch`语句，用于更简洁地表达一系列`if-then-else`条件语句。但是，它与传统实现有许多不同之处，使其更加灵活。
- en: 'Perhaps the most obvious difference to folks coming from C-family languages
    is that there’s no fallthrough between the cases by default; this behavior can
    be explicitly added by using the `fallthrough` keyword:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从C家族语言来的人来说，最明显的区别可能是默认情况下在情况之间没有`fallthrough`；可以通过使用`fallthrough`关键字显式添加此行为：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In this example, the value of `i % 3` is `0`, which matches the first case,
    causing it to output to word `Zero`. In Go, `switch` cases don’t fall through
    by default, but the existence of an explicit `fallthrough` statement means that
    the subsequent case is also executed and `One` is printed. Finally, the absence
    of a `fallthrough` on that case causes the resolution of the `switch` to complete.
    All told, the following is printed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`i % 3`的值为`0`，与第一个情况匹配，导致输出单词`Zero`。在Go语言中，默认情况下`switch`语句的情况不会贯穿，但存在显式的`fallthrough`语句意味着随后的情况也会执行，并打印`One`。最后，该情况没有`fallthrough`，导致`switch`的解析完成。总之，打印如下内容：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Switches in Go have two interesting properties. First, `case` expressions don’t
    need to be integers, or even constants: the cases will be evaluated from top to
    bottom, running the first case whose value is equal to the condition expression.
    Second, if the switch expression is left empty it’ll be interpreted as `true`,
    and will match the first case whose guarding condition evaluates to `true`. Both
    of these properties are demonstrated in the following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`switch`具有两个有趣的属性。首先，`case`表达式不需要是整数，甚至不必是常量：这些情况将从上到下进行评估，运行第一个其值等于条件表达式的情况。其次，如果`switch`表达式为空，它将被解释为`true`，并将匹配第一个其保护条件评估为`true`的情况。以下示例演示了这两个属性：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `switch` has no condition, so it’s exactly equivalent to using `switch true`.
    As such, it matches the first statement whose condition also evaluates to `true`.
    In my case, `hour` is 23, so the output is “I’m sleeping.”^([6](ch03.xhtml#idm45983643598696))
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`没有条件，因此它与使用`switch true`完全等效。因此，它将匹配第一个条件也评估为`true`的语句。在我的情况下，`hour`为23，因此输出为“I’m
    sleeping.”^([6](ch03.xhtml#idm45983643598696))'
- en: 'Finally, just as with `if`, a statement can precede the condition expression
    of a `switch`, in which case any defined values are scoped to the `switch`. For
    example, the previous example can be rewritten as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像`if`语句一样，语句可以在`switch`的条件表达式之前出现，这种情况下任何定义的值都将作用于`switch`。例如，可以将前面的示例重写如下：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note the trailing semicolon: this empty expression implies `true`, so that
    this expression is equivalent to `switch hour := time.Now().Hour(); true` and
    matches the first true case condition.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意末尾的分号：这个空表达式意味着`true`，因此该表达式等效于`switch hour := time.Now().Hour(); true`，并匹配第一个`true`条件。
- en: Error Handling
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Errors in Go are treated as just another value, represented by the built-in
    `error` type. This makes error handling straightforward: idiomatic Go functions
    may include an `error`-typed value in its list of returns, which if not `nil`
    indicates an error state that may be handled via the primary execution path. For
    example, the `os.Open` function returns a non-`nil` error value when it fails
    to open a file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，错误被视为另一个值，由内置的`error`类型表示。这使得错误处理变得简单：符合Go语言习惯的函数可能在返回列表中包含一个`error`类型的值，如果不为`nil`，则表示存在错误状态，可以通过主要的执行路径来处理。例如，当`os.Open`函数无法打开文件时会返回一个非`nil`的错误值：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The actual implementation of the `error` type is actually incredibly simple:
    it’s just a universally visible interface that declares a single method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`类型的实际实现非常简单：它只是一个普遍可见的接口，声明了一个单一方法：'
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is very different from the exceptions that are used in many languages,
    which necessitate a dedicated system for exception catching and handling that
    can lead to confusing and unintuitive flow control.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这与许多语言中使用的异常非常不同，后者需要专门的异常捕获和处理系统，可能导致混乱和不直观的流程控制。
- en: Creating an Error
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误
- en: 'There are two simple ways to create error values, and a more complicated way.
    The simple ways are to use either the `errors.New` or `fmt.Errorf` functions;
    the latter is handy because it provides string formatting too:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法来创建错误值，还有一种更复杂的方法。简单的方法是使用`errors.New`或`fmt.Errorf`函数；后者很方便，因为它还提供了字符串格式化功能：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, the fact that `error` is an interface allows you to implement your
    own error types, if you need to. For example, a common pattern is to allow errors
    to be nested within other errors:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`error`是一个接口的事实允许你实现自己的错误类型，如果需要的话。例如，一个常见的模式是允许错误嵌套在其他错误中：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For more information about errors, and some good advice on error handling in
    Go, take a look at Andrew Gerrand’s “Error Handling and Go” on [*The Go Blog*](https://oreil.ly/YQ6if).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于错误的更多信息，以及在Go中进行错误处理的一些良好建议，请查看Andrew Gerrand在[*The Go Blog*](https://oreil.ly/YQ6if)上的“错误处理与Go”。
- en: 'Putting the Fun in Functions: Variadics and Closures'
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中玩乐趣：可变参数和闭包
- en: 'Functions in Go work a lot like they do in other languages: they receive parameters,
    do some work, and (optionally) return something.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的函数工作方式与其他语言非常相似：它们接收参数，执行一些工作，并（可选地）返回一些内容。
- en: But Go functions are built for a level of flexibility not found in many mainstream
    languages, and can also do a lot of things that many other languages can’t, such
    as returning or accepting multiple values, or being used as first-class types
    or anonymous functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Go函数的灵活性远超过许多主流语言，并且还可以做许多其他语言无法做到的事情，比如返回或接受多个值，或者用作一级类型或匿名函数。
- en: Functions
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Declaring a function in Go is similar to most other languages: they have a
    name, a list of typed parameters, an optional list of return types, and a body.
    However, Go function declaration differs somewhat from other C-family languages,
    in that it uses a dedicated `func` keyword; the type for each parameter follows
    its name; and return types are placed at the end of the function definition header
    and may be omitted entirely (there’s no `void` type).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中声明函数与大多数其他语言类似：它们有一个名称，一个类型化参数列表，一个可选的返回类型列表和一个函数体。然而，Go函数声明与其他C系列语言有所不同，它使用了专用的`func`关键字；每个参数的类型跟在其名称后面；并且返回类型放在函数定义头的末尾，可以完全省略（没有`void`类型）。
- en: 'A function with a return type list must end with a `return` statement, except
    when execution can’t reach the end of the function due to the presence of an infinite
    loop or a terminal `panic` before the function exits:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 带有返回类型列表的函数必须以`return`语句结尾，除非由于存在无限循环或终端`panic`而导致函数无法到达结尾：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Additionally, a bit of syntactic sugar allows the type for a sequence of parameters
    or returns of the same type to be written only once. For example, the following
    definitions of `func foo` are equivalent:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一点语法糖允许一系列参数或相同类型的返回值的类型只需写一次。例如，下面这些定义的`func foo`是等效的：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Multiple return values
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多返回值
- en: 'Functions can return any number of values. For example, the following `swap`
    function accepts two strings, and returns two strings. The list of return types
    for multiple returns must be enclosed in parentheses:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回任意数量的值。例如，以下`swap`函数接受两个字符串，并返回两个字符串。多返回值的返回类型列表必须用括号括起来：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To accept multiple values from a function with multiple returns, you can use
    multiple assignment:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要从具有多个返回值的函数中接受多个值，可以使用多重赋值：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When run, the value of `a` will be “bar,” and `b` will be “foo.”
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，变量`a`的值将是“bar”，而`b`将是“foo”。
- en: Recursion
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: 'Go allows *recursive* function calls, in which functions call themselves. Used
    properly, recursion can be a very powerful tool that can be applied to many types
    of problems. The canonical example is the calculation of the factorial of a positive
    integer, the product of all positive integers less than or equal to `n`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许*递归*函数调用，即函数调用自身。如果使用正确，递归可以是一个非常强大的工具，可以应用于许多类型的问题。经典例子是计算正整数`n`的阶乘，即所有小于或等于`n`的正整数的乘积：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: For any integer `n` greater than one, `factorial` will call itself with a parameter
    of `n - 1`. This can add up very quickly!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何大于一的整数`n`，`factorial`将以`n - 1`作为参数调用自身。这可能会非常快速增加！
- en: Defer
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推迟执行
- en: Go’s `defer` keyword can be used to schedule the execution of a function call
    for immediately before the surrounding function returns, and is commonly used
    to guarantee that resources are released or otherwise cleaned up.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的`defer`关键字可用于安排在包围函数返回之前执行函数调用，并且通常用于确保释放或清理资源。
- en: 'For example, to defer printing the text “cruel world” to the end of a function
    call, we insert the `defer` keyword immediately before it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要推迟打印文本“cruel world”到函数调用的末尾，我们在其前面立即插入`defer`关键字：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When the previous snippet is run, it produces the following output, with the
    deferred output printed last:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码片段时，它会产生以下输出，推迟输出最后打印：
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For a less trivial example, we’ll create an empty file and attempt to write
    to it. A `closeFile` function is provided to close the file when we’re done with
    it. However, if we simply call it at the end of `main`, an error could result
    in `closeFile` never being called and the file being left in an open state. Therefore,
    we use a `defer` to ensure that the `closeFile` function is called before the
    function returns, however it returns:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个不那么琐碎的例子，我们将创建一个空文件并尝试向其写入。提供了一个`closeFile`函数，在完成后关闭文件。但是，如果我们简单地在`main`的末尾调用它，可能会出现错误，导致`closeFile`永远不会被调用，文件仍处于打开状态。因此，我们使用`defer`确保在函数返回之前调用`closeFile`函数，无论它如何返回：
- en: '[PRE55]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When you run this code, you should get the following output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，您应该获得以下输出：
- en: '[PRE56]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If multiple defer calls are used in a function, each is pushed onto a stack.
    When the surrounding function returns, the deferred calls are executed in last-in-first-out
    order. For example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数中使用多个`defer`调用，每个都会被推送到堆栈上。当包围函数返回时，推迟的调用按照后进先出的顺序执行。例如：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This function, when run, will output the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此函数时，将输出以下内容：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Defers are a very useful feature for ensuring that resources are cleaned up.
    If you’re working with external resources, you’ll want to make liberal use of
    them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 推迟执行是确保资源清理的非常有用的功能。如果您正在处理外部资源，您会希望大量使用它们。
- en: Pointers as parameters
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针作为参数
- en: 'Much of the power of pointers becomes evident when they’re combined with functions.
    Typically, function parameters are *passed* *by value*: when a function is called
    it receives a copy of each parameter, and changes made to the copy by the function
    don’t affect the caller. However, pointers contain a *reference* to a value, rather
    than the value itself, and can be used by a receiving function to indirectly modify
    the value passed to the function in a way that can affect the function caller.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的许多功能在与函数结合时变得显而易见。通常，函数参数是*按值传递*的：当调用函数时，它接收每个参数的副本，函数对副本的更改不会影响调用者。但是，指针包含对值的*引用*，而不是值本身，接收函数可以间接地修改传递给函数的值，从而可能影响函数调用者。
- en: 'The follow function demonstrates both scenarios:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的函数演示了这两种情况：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This behavior isn’t unique to pointers. In fact, under the hood, several data
    types are actually references to memory locations, including slices, maps, functions,
    and channels. Changes made to such *reference types* in a function can affect
    the caller, without needing to explicitly dereference them:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为并不局限于指针。实际上，在底层，几种数据类型实际上是对内存位置的引用，包括切片、映射、函数和通道。在函数中对这些*引用类型*进行的更改可能会影响调用者，而无需显式解引用它们：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this example, the map `m` has a length of two when it’s passed to the `update`
    function, which adds the pair `{ "c" : 2 }`. Because `m` is a reference type,
    it’s passed to `update` as a reference to an underlying data structure instead
    of a copy of one, so the insertion is reflected in `m` in `main` after the `update`
    function returns.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '在此示例中，当将映射`m`传递给`update`函数时，其长度为两个，它添加了一对`{ "c" : 2 }`。因为`m`是一个引用类型，它作为对底层数据结构的引用传递给`update`，因此在`update`函数返回后，`main`中的`m`中会反映出这个插入操作。'
- en: Variadic Functions
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: A *variadic function* is one that may be called with zero or more trailing arguments.
    The most familiar example is the members of the `fmt.Printf` family of functions,
    which accept a single format specifier string and an arbitrary number of additional
    arguments.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*可变参数函数*是可以使用零个或多个尾随参数调用的函数。最熟悉的例子是`fmt.Printf`系列函数的成员，它们接受一个格式说明符字符串和任意数量的附加参数。'
- en: 'This is the signature for the standard `fmt.Printf` function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that it accepts a string, and zero or more `interface{}` values. If you’re
    rusty on the `interface{}` syntax, we’ll review it in [“Interfaces”](#section_ch03_interfaces),
    but you can interpret `interface{}` to mean “some arbitrarily typed thing.” What’s
    most interesting here, however, is that the final argument contains an ellipsis
    (`...`). This is the *variadic operator*, which indicates that the function may
    be called with any number of arguments of this type. For example, you can call
    `fmt.Printf` with a format and two differently typed parameters:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Within the variadic function, the variadic argument is a slice of the argument
    type. In the following example, the variadic `factors` parameter of the `product`
    method is of type `[]int` and may be ranged over accordingly:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this example, the call to `product` from `main` uses three parameters (though
    it could use any number of parameters it likes). In the `product` function, these
    are translated into an `[]int` slice with the value `{2, 2, 2}` that are iteratively
    multiplied to construct the final return value of `8`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Passing slices as variadic values
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if your value is already in slice form, and you still want to pass it to
    a variadic function? Do you need to split it into multiple individual parameters?
    Goodness no.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you can apply the variadic operator after the variable name when
    calling the variadic function:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, you have a variable `m` with the type `[]int`, which you want to pass
    to the variadic function `product`. Using the variadic operator when calling `product(m...)`
    makes this possible.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions and Closures
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Go, functions are *first-class values* that can be operated upon in the
    same way as any other entity in the language: they have types, may be assigned
    to variables, and may even be passed to and returned by other functions.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The zero value of a function type is `nil`; calling a `nil` function value
    will cause a panic:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Functions may be created within other functions as *anonymous functions*, which
    may be called, passed, or otherwise treated like any other functions. A particularly
    powerful feature of Go is that anonymous functions have access to the state of
    their parent, and retain that access *even after* the parent function has executed.
    This is, in fact, the definition of a *closure*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *closure* is a nested function that has access to the variables of its parent
    function, even after the parent has executed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the following `incrementor` function. This function has
    state, in the form of the variable `i`, and returns an anonymous function that
    increments that value before returning it. The returned function can be said to
    *close over* the variable `i`, making it a true (if trivial) closure:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we call `incrementor`, it creates its own new, local value of `i`, and
    returns a new anonymous function of type that will increment that value. Subsequent
    calls to `incrementor` will each receive their own copy of `i`. We can demonstrate
    that in the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `incrementor` 时，它会创建其自己的新的本地值 `i`，并返回一个新的匿名函数，该函数将递增该值。对 `incrementor`
    的后续调用将分别接收它们自己的 `i` 的副本。我们可以在以下示例中演示这一点：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the `incrementer` provides a new function `increment`; each
    call to `increment` increments its internal counter by one. When `incrementer`
    is called again, though, it creates and returns an entirely new function, with
    its own brand new counter. Neither of these functions can influence the other.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`incrementer` 提供了一个新的函数 `increment`；每次调用 `increment` 时，它的内部计数器都会增加一次。但是当再次调用
    `incrementer` 时，它将创建并返回一个全新的函数，带有自己全新的计数器。这两个函数互不影响。
- en: Structs, Methods, and Interfaces
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体、方法和接口
- en: One of the biggest mental switches that people sometimes have to make when first
    coming to the Go language is that Go isn’t a traditional object-oriented language.
    Not really. Sure, Go has types with methods, which kind of look like objects,
    but they don’t have a prescribed inheritance hierarchy. Instead Go allows components
    to be assembled into a whole using *composition*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们初次接触Go语言时，他们可能需要做的最大心理转变之一是，Go并不是传统的面向对象语言。不完全是。当然，Go有带方法的类型，看起来有点像对象，但它们没有规定的继承层次结构。相反，Go允许通过*组合*将组件组装成整体。
- en: For example, where a more strictly object-oriented language might have a `Car`
    class that extends an abstract `Vehicle` class; perhaps it would implement `Wheels`
    and `Engine`. This sounds fine in theory, but these relationships can grow to
    become convoluted and hard to manage.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，更严格的面向对象语言可能会有一个 `Car` 类来扩展一个抽象的 `Vehicle` 类；也许它会实现 `Wheels` 和 `Engine`。理论上这听起来很好，但是这些关系可能会变得复杂而难以管理。
- en: Go’s composition approach, on the other hand, allows components to be “put together”
    without having to define their ontological relationships. Extending the previous
    example, Go could have a `Car` struct, which could be have its various parts,
    such as `Wheels` and `Engine`, embedded within it. Furthermore, methods in Go
    can be defined for any sort of data; they’re not just for structs anymore.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Go 的组合方法允许组件被“组合在一起”，而无需定义它们的本体关系。延续前面的例子，Go 可能有一个 `Car` 结构体，其中可以嵌入其各种部件，如
    `Wheels` 和 `Engine`。此外，Go 中的方法可以为任何类型的数据定义；它们不再仅限于结构体。
- en: Structs
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: 'In Go, a *struct* is nothing more than an aggregation of zero or more fields
    as a single entity, where each field is a named value of an arbitrary type. A
    struct can be defined using the following `type Name struct` syntax. A struct
    is never `nil`: rather, the zero value of a struct is the zero value of all of
    its fields:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，*struct* 实际上只是作为单个实体聚合的零个或多个字段，其中每个字段都是任意类型的命名值。可以使用以下 `type Name struct`
    语法定义结构体。结构体从不是 `nil`：而是结构体的零值是其所有字段的零值：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Struct fields can be accessed using the standard dot notation:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体字段可以使用标准点符号来访问：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Structs are commonly created and manipulated by reference, so Go provides a
    little bit of syntactic sugar: members of structs can be accessed from a pointer
    to the struct using dot notation; the pointers are automatically dereferenced:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体通常通过引用创建和操作，因此Go提供了一些语法糖：可以使用点符号从结构体的指针访问结构体的成员；指针会自动解引用：
- en: '[PRE70]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this example, `v` is a pointer to a `Vertex` whose `X` and `Y` member values
    you want to swap. If you had to dereference the pointer to do this, you’d have
    to do something like `(*v).X, (*v).Y = (*v).Y, (*v).X`, which is clearly terrible.
    Instead, automatic pointer dereferencing lets you do `v.X, v.Y = v.Y, v.X`, which
    is far less terrible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`v` 是指向 `Vertex` 的指针，其 `X` 和 `Y` 成员值需要进行交换。如果你必须对指针进行解引用来执行此操作，你将不得不像这样做
    `(*v).X, (*v).Y = (*v).Y, (*v).X`，显然这样做很糟糕。而自动指针解引用使你可以这样做 `v.X, v.Y = v.Y, v.X`，这要好得多。
- en: Methods
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: In Go, *methods* are functions that are attached to types, including but not
    limited to structs. The declaration syntax for a method is very similar to that
    of a function, except that it includes an extra *receiver argument* before the
    function name that specifies the type that the method is attached to. When the
    method is called, the instance is accessible by the name specified in the receiver.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，*方法* 是附加到类型的函数，包括但不限于结构体。方法的声明语法与函数非常相似，只是在函数名之前加了一个额外的 *接收器参数*，指定方法附加到的类型。当调用方法时，实例可以通过接收器指定的名称访问。
- en: 'For example, our earlier `Vertex` type can be extended by attaching a `Square`
    method with a receiver named `v` of type `*Vertex`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们先前的 `Vertex` 类型可以通过附加一个 `Square` 方法来扩展，接收器名为 `v`，类型为 `*Vertex`：
- en: '[PRE71]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Warning
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Receivers are type specific: methods attached to a pointer type can only be
    called on a pointer to that type.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器是类型特定的：附加到指针类型的方法只能在该类型的指针上调用。
- en: 'In addition to structs, you can also claim standard composite types—structs,
    slices, or maps—as your own, and attach methods to them. For example, we declare
    a new type, `MyMap`, which is just a standard `map[string]int`, and attach a `Length`
    method to it:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构体之外，还可以声明标准的复合类型，如结构体、切片或映射，并将方法附加到它们上。例如，我们声明了一个新类型，`MyMap`，它只是一个标准的 `map[string]int`，并附加了一个
    `Length` 方法：
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The result is a new type, `MyMap`, which is (and can be used as) a map of strings
    to integers, `map[string]int`, but which also has a `Length` method that returns
    the map’s length.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新类型 `MyMap`，它是（并且可以被用作）字符串到整数的映射 `map[string]int`，但同时具有返回映射长度的 `Length`
    方法。
- en: Interfaces
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: In Go, an *interface* is just a set of method signatures. As in other languages
    with a concept of an interface, they are used to describe the general behaviors
    of other types without being coupled to implementation details. An interface can
    thus be viewed as a *contract* that a type may satisfy, opening the door to powerful
    abstraction techniques.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，*接口* 只是一组方法签名。与其他具有接口概念的语言一样，它们用于描述其他类型的一般行为，而不与实现细节耦合。因此，接口可以被视为类型可能满足的
    *合约*，为强大的抽象技术打开了大门。
- en: 'For example, a `Shape` interface can be defined that includes an `Area` method
    signature. Any type that wants to be a `Shape` must have an `Area` method that
    returns a `float64`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以定义一个 `Shape` 接口，其中包含一个 `Area` 方法签名。任何想要成为 `Shape` 的类型必须有一个返回 `float64`
    的 `Area` 方法：
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we’ll define two shapes, `Circle` and `Rectangle`, that satisfy the `Shape`
    interface by attaching an `Area` method to each one. Note that we don’t have to
    explicitly declare that they satisfy the interface: if a type possesses all of
    its methods, it can *implicitly satisfy* an interface. This is particularly useful
    when you want to design interfaces that are satisfied by types that you don’t
    own or control:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义了两种形状，`Circle` 和 `Rectangle`，它们通过为每个附加一个 `Area` 方法来满足 `Shape` 接口。注意，我们无需显式声明它们满足接口：如果一个类型具有接口的所有方法，它可以
    *隐式满足* 接口。当你想设计被你不拥有或不控制的类型满足的接口时，这特别有用。
- en: '[PRE74]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Because both `Circle` and `Rectangle` implicitly satisfy the `Shape` interface,
    we can pass them to any function that expects a `Shape`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Circle` 和 `Rectangle` 都隐式满足 `Shape` 接口，我们可以将它们传递给任何期望 `Shape` 的函数：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Type assertions
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型断言
- en: A *type assertion* can be applied to an interface value to “assert” its identity
    as a concrete type. The syntax takes the general form of `x.(T)`, where `x` is
    an expression of an interface, and `T` is the asserted type.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言可以应用于接口值，以“断言”其作为具体类型的身份。语法的一般形式为 `x.(T)`，其中 `x` 是接口的表达式，`T` 是所断言的类型。
- en: 'Referring to the `Shape` interface and `Circle` struct we used previously:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们之前使用的 `Shape` 接口和 `Circle` 结构体：
- en: '[PRE76]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The empty interface
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空接口
- en: 'One curious construct is the *empty interface*: `interface{}`. The empty interface
    specifies no methods. It carries no information; it says nothing.^([7](ch03.xhtml#idm45983641253048))'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一个奇特的构造是 *空接口*：`interface{}`。空接口不指定任何方法。它不携带任何信息；它什么也不说。^([7](ch03.xhtml#idm45983641253048))
- en: A variable of type `interface{}` can hold values of any type, which can be very
    useful when your code needs to handle values of any type. The `fmt.Println` method
    is a good example of a function using this strategy.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `interface{}` 的变量可以保存任何类型的值，在处理需要处理任何类型值的代码时非常有用。`fmt.Println` 方法是一个使用这种策略的很好的例子。
- en: There are downsides, however. Working with the empty interface requires certain
    assumptions to be made, which have to be checked at runtime and result in code
    that’s more fragile and less efficient.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有其不利之处。与空接口一起工作需要做出某些假设，这些假设必须在运行时进行检查，并导致代码更加脆弱和效率更低。
- en: Composition with Type Embedding
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型嵌入进行组合
- en: Go doesn’t allow subclassing or inheritance in the traditional object-oriented
    sense. Instead it allows types to be *embedded* within one another, extending
    the functionalities of the embedded types into the embedding type.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Go不允许以传统面向对象的方式进行子类化或继承。相反，它允许类型在彼此之间*嵌入*，将嵌入类型的功能扩展到嵌入类型中。
- en: This is a particularly useful feature of Go that allows functionalities to be
    reused via *composition*—combining the features of existing types to create new
    types—instead of inheritance, removing the need for the kinds of elaborate type
    hierarchies that can saddle traditional object-oriented programming projects.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go的一个特别有用的功能，允许通过*组合*来重用功能——即通过结合现有类型的特性来创建新类型——而不是继承，从而消除了传统面向对象编程项目可能负担的复杂类型层次结构的需求。
- en: Interface embedding
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口嵌入
- en: 'A popular example of embedding interfaces comes to us by way of the `io` package.
    Specifically, the widely used `io.Reader` and `io.Writer` interfaces, which are
    defined as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的接口嵌入示例来自于`io`包。具体来说，广泛使用的`io.Reader`和`io.Writer`接口，其定义如下：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'But what if you want an interface with the methods of both an `io.Reader` and
    `io.Writer`? Well, you *could* implement a third interface that copies the methods
    of both, but then you have to keep all of them in agreement. That doesn’t just
    add unnecessary maintenance overhead: it’s also a good way to accidentally introduce
    errors.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您希望有一个同时具有`io.Reader`和`io.Writer`方法的接口怎么办？嗯，您*可以*实现一个第三个接口，复制两者的方法，但随后必须保持所有接口的一致性。这不仅增加了不必要的维护开销：还会意外引入错误的好方法。
- en: 'Rather than go the copy–paste route, Go allows you to embed the two existing
    interfaces into a third one that takes on the features of both. Syntactically,
    this is done by adding the embedded interfaces as anonymous fields, as demonstrated
    by the standard `io.ReadWriter` interface, shown here:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是走复制粘贴的路线，Go允许您将两个现有接口嵌入到第三个接口中，以获取两者的特性。语法上，通过将嵌入接口作为匿名字段添加来实现，就像标准的`io.ReadWriter`接口所示：
- en: '[PRE78]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The result of this composition is a new interface that has all of the methods
    of the interfaces embedded within it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合的结果是一个新的接口，该接口具有所有嵌入其内的接口的方法。
- en: Note
  id: totrans-365
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Only interfaces can be embedded within interfaces.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 只有接口可以嵌入到其他接口中。
- en: Struct embedding
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体嵌入
- en: 'Embedding isn’t limited to interfaces: structs can also be embedded into other
    structs.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不仅限于接口：结构体也可以嵌入到其他结构体中。
- en: 'The struct equivalent to the `io.Reader` and `io.Writer` example in the previous
    section comes from the `bufio` package. Specifically, `bufio.Reader` (which implements
    `io.Reader`) and `bufio.Writer` (which implements `io.Writer`). Similarly, `bufio`
    also provides an implementation of `io.ReadWriter`, which is just a composition
    of the existing `bufio.Reader` and `bufio.Writer` types:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中`io.Reader`和`io.Writer`示例的结构体等价物来自于`bufio`包。具体来说，`bufio.Reader`（实现了`io.Reader`）和`bufio.Writer`（实现了`io.Writer`）。类似地，`bufio`还提供了`io.ReadWriter`的实现，它只是现有`bufio.Reader`和`bufio.Writer`类型的组合：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see, the syntax for embedding structs is identical to that of interfaces:
    adding the embedded types as unnamed fields. In the preceding case, the `bufio.ReadWriter`
    embeds `bufio.Reader` and `bufio.Writer` as pointer types.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，嵌入结构体的语法与嵌入接口的语法相同：将嵌入类型作为未命名字段添加。在上述情况中，`bufio.ReadWriter`嵌入了指针类型的`bufio.Reader`和`bufio.Writer`。
- en: Warning
  id: totrans-372
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Just like any pointers, embedded pointers to structs have a zero value of `nil`,
    and must be initialized to point to valid structs before they can be used.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何指针一样，对结构体的嵌入指针具有`nil`的零值，在使用之前必须初始化为指向有效的结构体。
- en: Promotion
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级
- en: 'So, why would you use composition instead of just adding a struct field? The
    answer is that when a type is embedded, its exported properties and methods are
    *promoted* to the embedding type, allowing them to be directly invoked. For example,
    the `Read` method of a `bufio.Reader` is accessible directly from an instance
    of `bufio.ReadWriter`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You don’t have to know or care that the `Read` method is actually attached to
    the embedded `*bufio.Reader`. It’s important to know, though, that when a promoted
    method is invoked the method’s receiver is still the embedded type, so the receiver
    of `rw.Read` is the `ReadWriter`’s `Reader` field, not the `ReadWriter`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Directly accessing embedded fields
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Occasionally, you’ll need to refer to an embedded field directly. To do this,
    you use the type name of the field as a field name. In the following (somewhat
    contrived) example, the `UseReader` function requires a `*bufio.Reader`, but what
    you have is a `*bufio.ReadWriter` instance:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As you can see, this snippet uses the type name of the field you want to access
    (`Reader`) as the field name (`rw.Reader`) to retrieve the `*bufio.Reader` from
    `rw`. This can be handy for initialization as well:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If we’d just created `rw` as `&bufio.ReadWriter{}`, its embedded fields would
    be `nil`, but the snippet produces a `*bufio.ReadWriter` with fully defined `*bufio.Reader`
    and `*bufio.Writer` fields. While you wouldn’t typically do this with a `&bufio.ReadWriter`,
    this approach could be used to provide a useful mock in a pinch.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The Good Stuff: Concurrency'
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intricacies of concurrent programming are many, and are well beyond the
    scope of this work. However, you can say that reasoning about concurrency is hard,
    and that the way concurrency is generally done makes it harder. In most languages,
    the usual approach to processes orchestration is to create some shared bit of
    memory, which is then wrapped in locks to restrict access to one process at a
    time, often introducing maddeningly difficult-to-debug errors such as race conditions
    or deadlocks.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Go, on the other hand, favors another strategy: it provides two concurrency
    primitives—goroutines and channels—that can be used together to elegantly structure
    concurrent software, that don’t depend quite so much on locking. It encourages
    developers to limit sharing memory, and to instead allow processes to interact
    with one other entirely by passing messages.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of Go’s most powerful features is the `go` keyword. Any function call prepended
    with the `go` keyword will run as usual, but the caller can proceed uninterrupted
    rather than wait for the function to return. Under the hood, the function is executed
    as a lightweight, concurrently executing process called a *goroutine*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is strikingly simple: a function `foo`, which may be executed sequentially
    as `foo()`, may be executed as a concurrent goroutine simply by adding the `go`
    keyword: `go foo()`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Goroutines can also be used to invoke a function literal:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Channels
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, *channels* are typed primitives that allow communication between two
    goroutines. They act as pipes into which a value can be sent and then received
    by a goroutine on the other end.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，*通道* 是一种类型化的原语，允许两个goroutine之间进行通信。它们充当管道，可以将值发送到另一端的goroutine，然后接收。
- en: 'Channels may be created using the `make` function. Each channel can transmit
    values of a specific type, called its *element type*. Channel types are written
    using the `chan` keyword followed by their element type. The following example
    declares and allocates an `int` channel:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `make` 函数创建通道。每个通道可以传输特定类型的值，称为其*元素类型*。通道类型使用 `chan` 关键字后跟其元素类型编写。以下示例声明并分配了一个
    `int` 通道：
- en: '[PRE85]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The two primary operations supported by channels are *send* and *receive*,
    both of which use the `<-` operator, where the arrow indicates the direction of
    the data flow as demonstrated in the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通道支持的两个主要操作是*发送*和*接收*，它们都使用 `<-` 运算符，箭头指示数据流的方向，如以下示例所示：
- en: '[PRE86]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Channel blocking
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道阻塞
- en: 'By default, a channel is *unbuffered*. Unbuffered channels have a very useful
    property: sends on them block until another goroutine receives on the channel,
    and receives block until another goroutine sends on the channel. This behavior
    can be exploited to synchronize two goroutines, as demonstrated in the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通道是*无缓冲*的。无缓冲通道具有非常有用的属性：对它们的发送会阻塞，直到另一个goroutine接收该通道，而接收则会阻塞，直到另一个goroutine发送到该通道。可以利用这种行为来同步两个goroutine，如以下示例所示：
- en: '[PRE87]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Although `main` and the anonymous `goroutine` run concurrently and could in
    theory run in any order, the blocking behavior of unbuffered channels guarantees
    that the output will always be “ping” followed by “pong.”
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `main` 函数和匿名 `goroutine` 可以并行运行，并且理论上可以以任何顺序运行，但无缓冲通道的阻塞行为保证输出始终是“ping”后跟“pong”。
- en: Channel buffering
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道缓冲
- en: Go channels may be *buffered*, in which case they contain an internal value
    queue with a fixed *capacity* that’s specified when the buffer is initialized.
    Sends to a buffered channel only block when the buffer is full; receives from
    a channel only block when the buffer is empty. Any other time, send and receive
    operations write to or read from the buffer, respectively, and exit immediately.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的通道可以是*缓冲的*，在这种情况下，它们包含一个内部值队列，具有在初始化缓冲时指定的固定*容量*。对缓冲通道的发送仅在缓冲区满时阻塞；从通道接收仅在缓冲区为空时阻塞。在其他任何时间，发送和接收操作将写入或从缓冲区读取，并立即退出。
- en: 'A buffered channel can be created by providing a second argument to the `make`
    function to indicate its capacity:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过向 `make` 函数提供第二个参数来指定其容量来创建缓冲通道：
- en: '[PRE88]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Closing channels
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'The third available channel operation is *close*, which sets a flag to indicate
    that no more values will be sent on it. The built-in `close` function can be used
    to close a channel: `close(ch)`.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种可用的通道操作是*关闭*，它设置一个标志以指示不会再在其上发送更多值。内置的 `close` 函数可用于关闭通道：`close(ch)`。
- en: Tip
  id: totrans-409
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The channel close operation is just a flag to tell the receiver not to expect
    any more values. You don’t *have to* explicitly close channels.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通道关闭操作仅是一个标志，告诉接收方不再期望收到更多的值。您不需要*强制*显式关闭通道。
- en: 'Trying to send on a closed channel will cause a `panic`. Receiving from a closed
    channel will retrieve any values sent on the channel prior to its closure; any
    subsequent receive operations will immediately yield the zero value of the channel’s
    element type. Receivers may also test whether a channel has been closed (and its
    buffer is empty) by assigning a second `bool` parameter to the receive expression:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在已关闭的通道上发送将引发 `panic`。从已关闭的通道接收将检索发送到通道的任何值（在其关闭之前），任何后续的接收操作将立即返回通道元素类型的零值。接收方还可以通过为接收表达式分配第二个
    `bool` 参数来测试通道是否已关闭（及其缓冲区是否为空）：
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Warning
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While either party may close a channel, in practice only the sender should do
    so. Inadvertently sending on a closed channel will cause a panic.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何一方都可以关闭通道，但实际上只有发送方应该这样做。在已关闭的通道上无意地发送将会导致恐慌。
- en: Looping over channels
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历通道
- en: 'The `range` keyword may be used to loop over channels that are open or contain
    buffered values. The loop will block until a value is available to be read or
    until the channel is closed. You can see how this works in the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `range` 关键字遍历打开或包含缓冲值的通道。该循环将阻塞，直到有值可供读取或通道被关闭。您可以在以下示例中看到其工作方式：
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this example, the buffered channel `ch` is created, and three values are
    sent before being closed. Because the three values were sent to the channel before
    it was closed, looping over this channel will output all three lines before terminating.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，创建了缓冲通道`ch`，并在关闭之前发送了三个值。由于三个值在通道关闭之前被发送，因此在循环遍历该通道时，将输出所有三行内容后终止。
- en: Had the channel not been closed, the loop would stop and wait for the next value
    to be sent along the channel, potentially indefinitely.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通道没有关闭，循环将停止并等待下一个值被发送到通道，可能会无限期地等待。
- en: Select
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: 'Go’s `select` statements are a little like `switch` statements that provide
    a convenient mechanism for multiplexing communications with multiple channels.
    The syntax for `select` is very similar to `switch`, with some number of `case`
    statements that specify code to be executed upon a successful send or receive
    operation:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的`select`语句类似于`switch`语句，提供了一个便捷的机制来多路复用与多个通道的通信。`select`的语法与`switch`非常相似，具有一些`case`语句，指定在成功发送或接收操作时执行的代码：
- en: '[PRE91]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the preceding snippet, there are three primary cases specified with three
    different conditions. If the channel `ch1` is ready to be read, then its value
    will be read (and discarded) and the text “Got something” will be printed. If
    `ch2` is ready to be read, then its value will be read and assigned to the variable
    `x` before printing the value of `x`. Finally, if `ch3` is ready to be sent to,
    then the value `y` is sent to it before printing the value of `y`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，指定了三个主要情况，并具有三个不同的条件。如果通道`ch1`准备好读取，那么将读取（并丢弃）其值，并打印文本“得到了东西”。如果`ch2`准备好读取，则将读取其值并分配给变量`x`，然后打印`x`的值。最后，如果`ch3`准备好接收数据，则将值`y`发送到它之前打印`y`的值。
- en: Finally, if no cases are ready, the `default` statements will be executed. If
    there’s no `default`, then the `select` will block until one of its cases is ready,
    at which point it performs the associated communication and executes the associated
    statements. If multiple cases are ready, `select` will execute one at random.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有`case`准备好，则将执行`default`语句。如果没有`default`，则`select`将阻塞，直到其一个`case`准备就绪，然后执行相关的通信并执行相关的语句。如果多个`case`都准备就绪，`select`将随机执行一个。
- en: Gotcha!
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意！
- en: When using `select`, keep in mind that a closed channel never blocks and is
    always readable.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`select`时，请记住，关闭的通道永远不会阻塞并且始终可读取。
- en: Implementing channel timeouts
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现通道超时
- en: 'The ability to use `select` to multiplex on channels can be very powerful,
    and can make otherwise very difficult or tedious tasks trivial. Take, for example,
    the implementation of a timeout on an arbitrary channel. In some languages this
    might require some awkward thread work, but a `select` with a call to `time.After`,
    which returns a channel that sends a message after a specified duration, makes
    short work of it:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`select`在通道上进行多路复用的能力非常强大，可以使本来非常困难或乏味的任务变得简单。例如，在任意通道上实现超时，在某些语言中可能需要一些尴尬的线程工作，但使用`select`与调用`time.After`一起，后者返回一个在指定持续时间后发送消息的通道，可以轻松搞定：
- en: '[PRE92]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Since there’s no `default` statement, this `select` will block until one if
    its case conditions becomes true. If `ch` doesn’t become available to read before
    the channel returned by `time.After` emits a message, then the second case will
    activate and the statement will time out.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有`default`语句，这个`select`将阻塞，直到其一个`case`条件变为真。如果在`time.After`返回的通道发出消息之前，`ch`不可用于读取，则第二个`case`将激活并且语句将超时。
- en: Summary
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: What I covered in this chapter could easily have consumed an entire book, if
    I’d been able to drill down into the level of detail the subject really deserves.
    But space and time are limited (and that book’s already been written^([8](ch03.xhtml#idm45983640288648)))
    so I have to remain content to have only this one chapter as a broad and shallow
    survey of the Go language (at least until the second edition comes out).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的内容如果能深入探讨到主题真正值得的细节水平，可能轻易就能写成一本书。但空间和时间有限（并且那本书已经写好^([8](ch03.xhtml#idm45983640288648))），所以我只能满足于此章作为对Go语言广泛且浅显的概述（至少在第二版出版之前）。
- en: But learning Go’s syntax and grammar will only get you so far. In [Chapter 4](ch04.xhtml#chapter_4)
    I’ll be presenting a variety of Go programming patterns that I see come up pretty
    regularly in the “cloud native” context. So, if you thought this chapter was interesting,
    you’re going to love the next one.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45983647379672-marker)) Perlis, Alan. *ACM SIGPLAN Notices*
    17(9), September 1982, pp. 7–13.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45983647325000-marker)) Earlier versions of C, C++, and
    Python lacked a native Boolean type, instead representing them using the integers
    `0` (for `false`) or `1` (for `true`). Some languages like Perl, Lua, and Tcl
    still use a similar strategy.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45983647252184-marker)) See what I did there?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.xhtml#idm45983646893816-marker)) Why would you?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#idm45983644570440-marker)) In fact, the freezing point of water
    on the Newton scale actually is 0.0, but that’s not important.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch03.xhtml#idm45983643598696-marker)) Clearly this code needs to be recalibrated.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch03.xhtml#idm45983641253048-marker)) Pike, Rob. “Go Proverbs.” YouTube.
    1 Dec. 2015\. [*https://oreil.ly/g8Rid*](https://oreil.ly/g8Rid).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch03.xhtml#idm45983640288648-marker)) One last time, if you haven’t read
    it yet, go read *The Go Programming Language* by Donovan and Kernighan (Addison-Wesley
    Professional).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
