- en: Chapter 3\. Go Language Foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A language that doesn’t affect the way you think about programming is not worth
    knowing.^([1](ch03.xhtml#idm45983647379672))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alan Perlis, ACM SIGPLAN Notices (September 1982)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No programming book would be complete without at least a brief refresher of
    its language of choice, so here we are!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will differ slightly from the ones in more introductory level books,
    however, in that we’re assuming that you’re at least familiar with common coding
    paradigms but may or may not be a little rusty with the finer points of Go syntax.
    As such, this chapter will focus as much on Go’s nuances and subtleties as its
    fundamentals. For a deeper dive into the latter, I recommend either [*Introducing
    Go*](https://oreil.ly/9Ht4R) by Caleb Doxsey (O’Reilly) or *The Go Programming
    Language* by Alan A. A. Donovan and Brian W. Kernighan (Addison-Wesley Professional)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re relatively new to the language, you’ll definitely want to read on.
    Even if you’re somewhat comfortable with Go, you might want to skim this chapter:
    there will be a gem or two in here for you. If you’re a seasoned veteran of the
    language, you can go ahead and move on to the next chapter (or read it ironically
    and judge me).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go’s basic data types, the fundamental building blocks from which more complex
    types are constructed, can be divided into three subcategories:'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans that contain only one bit of information—`true` or `false`—representing
    some logical conclusion or state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric types that represent simple—variously sized floating point and signed
    and unsigned integers—or complex numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings that represent an immutable sequence of Unicode code points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Boolean data type, representing the two logical truth values, exists in
    some form^([2](ch03.xhtml#idm45983647325000)) in every programming language ever
    devised. It’s represented by the `bool` type, a special 1-bit integer type that
    has two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go supports all of the typical logical operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Curiously, Go doesn’t include a logical XOR operator. There *is* a `^` operator,
    but it’s reserved for bitwise XOR operations.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go has a small menagerie of systematically named, floating point, and signed
    and unsigned integer numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: Signed integer
  prefs: []
  type: TYPE_NORMAL
- en: '`int8`, `int16`, `int32`, `int64`'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer
  prefs: []
  type: TYPE_NORMAL
- en: '`uint8`, `uint16`, `uint32`, `uint64`'
  prefs: []
  type: TYPE_NORMAL
- en: Floating point
  prefs: []
  type: TYPE_NORMAL
- en: '`float32`, `float64`'
  prefs: []
  type: TYPE_NORMAL
- en: Systematic naming is nice, but code is written by humans with squishy human
    brains, so the Go designers provided two lovely conveniences.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are two “machine dependent” types, simply called `int` and `uint`,
    whose size is determined based on available hardware. These are convenient if
    the specific size of your numbers isn’t critical. Sadly, there’s no machine-dependent
    floating-point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, two integer types have mnemonic aliases: `byte`, which is an alias
    for `uint8`; and `rune`, which is an alias for `uint32`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For most uses, it generally makes sense to just use `int` and `float64`.
  prefs: []
  type: TYPE_NORMAL
- en: Complex Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go offers two sizes of *complex numbers*, if you’re feeling a little imaginative:^([3](ch03.xhtml#idm45983647252184))
    `complex64` and `complex128`. These can be expressed as an *imaginary literal*
    by a floating point immediately followed by an `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Complex numbers are very neat but don’t come into play all that often, so I
    won’t drill down into them here. If you’re as fascinated by them as I hope you
    are, *The Go Programming Language* by Donovan and Kernighan gives them the full
    treatment they deserve.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *string* represents a sequence of Unicode code points. Strings in Go are
    immutable: once created, it’s not possible to change a string’s contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go supports two styles of string literals, the double-quote style (or interpreted
    literals) and the back-quote style (or raw string literals). For example, the
    following two string literals are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this interpreted string literal, each `\n` character pair will be escaped
    as one newline character, and each `\"` character pair will be escaped as one
    double-quote character.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, a string is actually just a wrapper around a slice of UTF-8
    encoded `byte` values, so any operation that can be applied to slices and arrays
    can also be applied to strings. If you aren’t clear on slices yet, you can take
    this moment to read ahead to [“Slices”](#section_ch03_slices).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables can be declared by using the `var` keyword to pair an identifier
    with some typed value, and may be updated at any time, with the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is considerable flexibility in variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With initialization: `var foo int = 42`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of multiple variables: `var foo, bar int = 42, 1302`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With type inference: `var foo = 42`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of mixed multiple types: `var b, f, s = true, 2.3, "four"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without initialization (see [“Zero Values”](#section_ch03_zero_values)): `var
    s string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Go is very opinionated about clutter: it *hates* it. If you declare a variable
    in a function but don’t use it, your program will refuse to compile.'
  prefs: []
  type: TYPE_NORMAL
- en: Short Variable Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go provides a bit of syntactic sugar that allows variables within functions
    to be simultaneously declared and assigned by using the `:=` operator in place
    of a `var` declaration with an implicit type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Short variable declarations have the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be used to declare both single and multiple assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With initialization: `percent := rand.Float64() * 100.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple variables at once: `x, y := 0, 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, short variable declarations are the most common way that variables
    are declared and initialized in Go; `var` is usually only used either for local
    variables that need an explicit type, or to declare a variable that will be assigned
    a value later.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that `:=` is a declaration, and `=` is an assignment. A `:=` operator
    that only attempts to redeclare existing variables will fail at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly (and sometimes confusingly), if a short variable declaration has
    a mix of new and existing variables on its left-hand side, the short variable
    declaration acts like an assignment to the existing variables.
  prefs: []
  type: TYPE_NORMAL
- en: Zero Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a variable is declared without an explicit value, it’s assigned to the
    *zero value* for its type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integers: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floats: `0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Booleans: `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Strings: `""` (the empty string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate, let’s define four variables of various types, without explicit
    initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to use these variables we’d find that they were, in fact, already
    initialized to their zero values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice the use of the `fmt.Printf` function, which allows greater control
    over output format. If you’re not familiar with this function, or with Go’s format
    strings, see the following sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: The Blank Identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *blank identifier*, represented by the `_` (underscore) operator, acts as
    an anonymous placeholder. It may be used like any other identifier in a declaration,
    except it doesn’t introduce a binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s most commonly used as a way to selectively ignore unneeded values in an
    assignment, which can be useful in a language that both supports multiple returns
    and demands there be no unused variables. For example, if you wanted to handle
    any potential errors returned by `fmt.Printf`, but don’t care about the number
    of bytes it writes,^([4](ch03.xhtml#idm45983646893816)) you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The blank identifier can also be used to import a package solely for its side
    effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Packages imported in this way are loaded and initialized as normal, including
    triggering any of its `init` functions, but are otherwise ignored and need not
    be referenced or otherwise directly used.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants are very similar to variables, using the `const` keyword to associate
    an identifier with some typed value. However, constants differ from variables
    in some important ways. First, and most obviously, attempting to modify a constant
    will generate an error at compile time. Second, constants *must* be assigned a
    value at declaration: they have no zero value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `var` and `const` may be used at both the package and function level,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate their behavioral similarity, the previous snippet arbitrarily
    mixes explicit type definitions with type inference for both the constants and
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the choice of `fmt.Sprintf` is inconsequential to this example, but
    if you’re unclear about Go’s format strings you can look back to [“Formatting
    I/O in Go”](#sidebar_ch03_printf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Container Types: Arrays, Slices, and Maps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go has three first-class container types that can be used to store collections
    of element values:'
  prefs: []
  type: TYPE_NORMAL
- en: ArrayArray
  prefs: []
  type: TYPE_NORMAL
- en: A fixed-length sequence of zero or more elements of a particular type.
  prefs: []
  type: TYPE_NORMAL
- en: Slice
  prefs: []
  type: TYPE_NORMAL
- en: An abstraction around an array that can be resized at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs: []
  type: TYPE_NORMAL
- en: An associative data structure that allows distinct keys to be arbitrarily paired
    with, or “mapped to,” values.
  prefs: []
  type: TYPE_NORMAL
- en: As container types, all of these have a `length` property that reflects how
    many elements are stored in that container. The `len` built-in function can be
    used to find the length of any array, slice (including strings), or map.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, as in most other mainstream languages, an *array* is a fixed-length sequence
    of zero or more elements of a particular type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays can be declared by including a length declaration. The zero value of
    an array is an array of the specified length containing zero-valued elements.
    Individual array elements are indexed from `0` to `N-1`, and can be accessed using
    the familiar bracket notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can be initialized using array literals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have the compiler count the array elements for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the type of `b` is `[3]int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all container types, the `len` built-in function can be used to discover
    the length of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In practice, arrays aren’t actually used directly very often. Instead, it’s
    much more common to use *slices*, an array abstraction type that behaves (for
    all practical purposes) like a resizable array.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices are a data type in Go that provide a powerful abstraction around a traditional
    array, such that working with slices looks and feels to the programmer very much
    like working with arrays. Like arrays, slices provide access to a sequence of
    elements of a particular type via the familiar bracket notation, indexed from
    `0` to `N-1`. However, where arrays are fixed-length, slices can be resized at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 3-1](#img_ch03_slice), a slice is actually a lightweight
    data structure with three components:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to some element of a backing array that represents the first element
    of the slice (not necessarily the first element of the array)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A length, representing the number of elements in the slice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A capacity, which represents the upper value of the length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not otherwise specified, the capacity value equals the number of elements
    between the start of the slice and the end of the backing array. The built-in
    `len` and `cap` functions will provide the length and capacity of a slice, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![cngo 0301](Images/cngo_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Two slices backed by the same array
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Working with slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a slice is somewhat different from creating an array: slices are typed
    only according to the type of their elements, not their number. The `make` built-in
    function can be used to create a slice with a nonzero length as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with slices feels a lot like working with arrays. Like
    arrays, the zero value of a slice is a slice of the specified length containing
    zero-valued elements, and elements in a slice are indexed and accessed exactly
    like they are in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slice literal is declared just like an array literal, except that you omit
    the element count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Slices can be extended using the `append` built-in, which returns an extended
    slice containing one or more new values appended to the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `append` built-in function also happens to be *variadic*, which means it
    can accept a variable number of arguments in addition to the slice to be appended.
    Variadic functions will be covered in more detail in [“Variadic Functions”](#section_ch03_variadic_functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `append` built-in function returns the appended slice rather than
    modifying the slice in place. The reason for this is that behind the scenes, if
    the destination has sufficient capacity to accommodate the new elements, then
    a new slice is constructed from the original underlying array. If not, a new underlying
    array is automatically allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that `append` *returns* the appended slice. Failing to store it is a common
    error.
  prefs: []
  type: TYPE_NORMAL
- en: The slice operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arrays and slices (including strings) support the *slice operator*, which has
    the syntax `s[i:j]`, where `i` and `j` are in the range `0 ≤ i ≤ j ≤ cap(s)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we define a slice literal. Recall that it closely resembles
    an array literal, except that it doesn’t indicate a size.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the values of `i` or `j` are omitted from a slice operator, they’ll default
    to `0` and `len(s)`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A slice operator will produce a new slice backed by the same array with a length
    of `j - i`. Changes made to this slice will be reflected in the underlying array,
    and subsequently in all slices derived from that same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This effect is illustrated in more detail in [Figure 3-1](#img_ch03_slice).
  prefs: []
  type: TYPE_NORMAL
- en: Strings as slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The subject of how Go implements strings under the hood is actually quite a
    bit more complex than you might expect, involving lots of details like the differences
    between bytes, characters, and runes; Unicode versus UTF-8 encoding; and the differences
    between a string and a string literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now it’s sufficient to know that Go strings are essentially just read-only
    slices of bytes that typically (but aren’t *required* to) contain a series of
    UTF-8 sequences representing Unicode code points, called `runes`. Go even allows
    you to cast your strings into `byte` or `rune` arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By casting the string `s` in this way, we’re able to uncover its identity as
    either a slice of bytes or a slice of runes. We can illustrate this by using `fmt.Printf`
    with the `%T` (type) and `%v` (value) flags (which we presented in [“Formatting
    I/O in Go”](#sidebar_ch03_printf)) to output the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the value of the string literal, `foö`, contains a mix of characters
    whose encoding can be contained in a single byte (`f` and `o`, encoded as `102`
    and `111`, respectively) and one character that cannot (`ö`, encoded as `195 182`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that the `byte` and `rune` types are mnemonic aliases for `uint8` and
    `int32`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these lines print the type and value of the variables passed to it.
    As expected, the string value, `foö`, is printed literally. The next two lines
    are interesting, however. The `uint8` (byte) slice contains four bytes, which
    represent the string’s UTF-8 encoding (two 1-byte code points, and one 2-byte
    code point). The `int32` (rune) slice contains three values that represent the
    code points of the individual characters.
  prefs: []
  type: TYPE_NORMAL
- en: There’s far, far more to string encoding in Go, but we only have so much space.
    If you’re interested in learning more, take a look at Rob Pike’s “Strings, Bytes,
    Runes and Characters in Go” on [*The Go Blog*](https://oreil.ly/mgku7) for a deep
    dive into the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go’s *map* data type references a *hash table*: an incredibly useful associative
    data structure that allows distinct keys to be arbitrarily “mapped” to values
    as key-value pairs. This data structure is common among today’s mainstream languages:
    if you’re coming to Go from one of these then you probably already use them, perhaps
    in the form of Python’s `dict`, Ruby’s `Hash`, or Java’s `HashMap`.'
  prefs: []
  type: TYPE_NORMAL
- en: Map types in Go are written `map[K]V`, where `K` and `V` are the types of its
    keys and values, respectively. Any type that is comparable using the `==` operator
    may be used as a key, and `K` and `V` need not be of the same type. For example,
    `string` keys may be mapped to `float32` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A map can be initialized using the built-in `make` function, and its values
    can be referenced using the usual `name[key]` syntax. Our old friend `len` will
    return the number of key/value pairs in a map; the `delete` built-in can remove
    key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Maps may also be initialized and populated as *map literals*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the trailing comma on the last line. This is not optional: the code will
    refuse to compile if it’s missing.'
  prefs: []
  type: TYPE_NORMAL
- en: Map membership testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Requesting the value of a key that’s not present in a map won’t cause an exception
    to be thrown (those don’t exist in Go anyway) or return some kind of `null` value.
    Rather, it returns the zero value for the map’s value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be a very useful feature because it reduces a lot of boilerplate membership
    testing when working with maps, but it can be a little tricky when your map happens
    to actually contain zero-valued values. Fortunately, accessing a map can also
    return a second optional `bool` that indicates whether the key is present in the
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, the value of `newton` is `0.0`. But is that really the correct
    value,^([5](ch03.xhtml#idm45983644570440)) or was there just no matching key?
    Fortunately, since `ok` is also `false`, we know the latter to be the case.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay. Pointers. The bane and undoing of undergraduates the world over. If you’re
    coming from a dynamically typed language, the idea of the pointer may seem alien
    to you. While we’re not going to drill down *too* deeply into the subject, we’ll
    do our best to cover it well enough to provide some clarity on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to first principles, a “variable” is a piece of storage in memory
    that contains some value. Typically, when you refer to a variable by its name
    (`foo = 10`) or by an expression (`s[i] = "foo"`), you’re directly reading or
    updating the value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *pointer* stores the *address* of a variable: the location in memory where
    the value is stored. Every variable has an address, and using pointers allows
    us to indirectly read or update the value of their variables (illustrated in [Figure 3-2](#img_ch03_pointers)):'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the address of a variable
  prefs: []
  type: TYPE_NORMAL
- en: The address of a named variable can be retrieved by using the `&` operator.
    For example, the expression `p := &a` will obtain the address of `a` and assign
    it to `p`.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer types
  prefs: []
  type: TYPE_NORMAL
- en: The variable `p`, which you can say “points to” `a`, has a type of `*int`, where
    the `*` indicates that it’s a pointer type that points to an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a pointer
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the value of the value `a` from `p`, you can *dereference* it using
    a `*` before the pointer variable name, allowing us to indirectly read or update
    `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '![cngo 0302](Images/cngo_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. The expression `p := &a` gets the address of `a` and assigns it
    to `p`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, to put everything in one place, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointers can be declared like any other variable, with a zero value of `nil`
    if not explicitly initialized. They’re also comparable, being equal only if they
    contain the same address (that is, they point to the same variable) or if they
    are both `nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because `n` is never initialized, its value is `nil`, and comparing it to `nil`
    returns `true`. The integers `x` and `y` both have a value of `0`, so comparing
    their values yields `true`, but they are still distinct variables, and comparing
    pointers to them still evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Control Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any programmer coming to Go from another language will find its suite of control
    structures to be generally familiar, even comfortable (at first) for those coming
    from a language heavily influenced by C. However, there are some pretty important
    deviations in their implementation and usages that might seem odd at first.
  prefs: []
  type: TYPE_NORMAL
- en: For example, control structure statements don’t require lots of parentheses.
    Okay. Less clutter. That’s fine.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also only one loop type. There is no `while`; only `for`. Seriously!
    It’s actually pretty cool, though. Read on, and you’ll see what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: Fun with for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` statement is Go’s one and only loop construct, and while there’s no
    explicit `while` loop, Go’s `for` can provide all of its functionality, effectively
    unifying all of the entry control loop types to which you’ve become accustomed.
  prefs: []
  type: TYPE_NORMAL
- en: Go has no `do-while` equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: The general for statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The general form of `for` loops in Go is nearly identical to that of other
    C-family languages, in which three statements—the init statement, the continuation
    condition, and the post statement—are separated by semicolons in the traditional
    style. Any variables declared in the init statement will be scoped only to the
    `for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `i` is initialized to 0\. At the end of each iteration `i`
    is incremented by 1, and if it’s still less than 10, the process repeats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike most C-family languages, `for` statements don’t require parentheses around
    their clauses, and braces are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a break from traditional C-style languages, Go’s `for` statement’s init
    and post statements are entirely optional. As shown in the code that follows,
    this makes it considerably more flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `for` statement in the previous example has no init or post statements,
    only a bare condition. This is actually a big deal, because it means that `for`
    is able to fill the role traditionally occupied by the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, omitting all three clauses from a `for` statement creates a block
    that loops infinitely, just like a traditional `while (true)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Because it lacks any terminating condition, the loop in the previous snippet
    will iterate forever. On purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over arrays and slices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go provides a useful keyword, `range`, that simplifies looping over a variety
    of data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of arrays and slices, `range` can be used with a `for` statement
    to retrieve the index and the value of each element as it iterates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, the values of `i` and `v` will update each iteration
    to contain the index and value, respectively, of each element in the slice `s`.
    So the output will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you don’t need both of these values? After all, the Go compiler
    will demand that you use them if you declare them. Fortunately, as elsewhere in
    Go, the unneeded values can be discarded by using the “blank identifier,” signified
    by the underscore operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As in the last example, the value `v` will update each iteration to contain
    the value of each element in the slice `a`. This time, however, the index value
    is conveniently ignored and discarded, and the Go compiler stays content.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range` keyword may be also be used with a `for` statement to loop over
    maps, with each iteration returning the current key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that Go maps aren’t ordered, so the output won’t be either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The typical application of the `if` statement in Go is consistent with other
    C-style languages, except for the lack of parentheses around the clause and the
    fact that braces are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike most C-family languages, `if` statements don’t require parentheses around
    their clauses, and braces are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, Go allows an initialization statement to precede the condition
    clause in an `if` statement, allowing for a particularly useful idiom. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `err` variable is being initialized prior to a check for its definition,
    making it somewhat similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The two constructs aren’t exactly equivalent however: in the first example
    `err` is scoped only to the `if` statement; in the second example `err` is visible
    to the entire containing function.'
  prefs: []
  type: TYPE_NORMAL
- en: The switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in other languages, Go provides a `switch` statement that provides a way
    to more concisely express a series of `if-then-else` conditionals. However, it
    differs from the traditional implementation in a number of ways that make it considerably
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most obvious difference to folks coming from C-family languages
    is that there’s no fallthrough between the cases by default; this behavior can
    be explicitly added by using the `fallthrough` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the value of `i % 3` is `0`, which matches the first case,
    causing it to output to word `Zero`. In Go, `switch` cases don’t fall through
    by default, but the existence of an explicit `fallthrough` statement means that
    the subsequent case is also executed and `One` is printed. Finally, the absence
    of a `fallthrough` on that case causes the resolution of the `switch` to complete.
    All told, the following is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Switches in Go have two interesting properties. First, `case` expressions don’t
    need to be integers, or even constants: the cases will be evaluated from top to
    bottom, running the first case whose value is equal to the condition expression.
    Second, if the switch expression is left empty it’ll be interpreted as `true`,
    and will match the first case whose guarding condition evaluates to `true`. Both
    of these properties are demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `switch` has no condition, so it’s exactly equivalent to using `switch true`.
    As such, it matches the first statement whose condition also evaluates to `true`.
    In my case, `hour` is 23, so the output is “I’m sleeping.”^([6](ch03.xhtml#idm45983643598696))
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, just as with `if`, a statement can precede the condition expression
    of a `switch`, in which case any defined values are scoped to the `switch`. For
    example, the previous example can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the trailing semicolon: this empty expression implies `true`, so that
    this expression is equivalent to `switch hour := time.Now().Hour(); true` and
    matches the first true case condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Errors in Go are treated as just another value, represented by the built-in
    `error` type. This makes error handling straightforward: idiomatic Go functions
    may include an `error`-typed value in its list of returns, which if not `nil`
    indicates an error state that may be handled via the primary execution path. For
    example, the `os.Open` function returns a non-`nil` error value when it fails
    to open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual implementation of the `error` type is actually incredibly simple:
    it’s just a universally visible interface that declares a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is very different from the exceptions that are used in many languages,
    which necessitate a dedicated system for exception catching and handling that
    can lead to confusing and unintuitive flow control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two simple ways to create error values, and a more complicated way.
    The simple ways are to use either the `errors.New` or `fmt.Errorf` functions;
    the latter is handy because it provides string formatting too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the fact that `error` is an interface allows you to implement your
    own error types, if you need to. For example, a common pattern is to allow errors
    to be nested within other errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For more information about errors, and some good advice on error handling in
    Go, take a look at Andrew Gerrand’s “Error Handling and Go” on [*The Go Blog*](https://oreil.ly/YQ6if).
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting the Fun in Functions: Variadics and Closures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions in Go work a lot like they do in other languages: they receive parameters,
    do some work, and (optionally) return something.'
  prefs: []
  type: TYPE_NORMAL
- en: But Go functions are built for a level of flexibility not found in many mainstream
    languages, and can also do a lot of things that many other languages can’t, such
    as returning or accepting multiple values, or being used as first-class types
    or anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declaring a function in Go is similar to most other languages: they have a
    name, a list of typed parameters, an optional list of return types, and a body.
    However, Go function declaration differs somewhat from other C-family languages,
    in that it uses a dedicated `func` keyword; the type for each parameter follows
    its name; and return types are placed at the end of the function definition header
    and may be omitted entirely (there’s no `void` type).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function with a return type list must end with a `return` statement, except
    when execution can’t reach the end of the function due to the presence of an infinite
    loop or a terminal `panic` before the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, a bit of syntactic sugar allows the type for a sequence of parameters
    or returns of the same type to be written only once. For example, the following
    definitions of `func foo` are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Multiple return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions can return any number of values. For example, the following `swap`
    function accepts two strings, and returns two strings. The list of return types
    for multiple returns must be enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To accept multiple values from a function with multiple returns, you can use
    multiple assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When run, the value of `a` will be “bar,” and `b` will be “foo.”
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go allows *recursive* function calls, in which functions call themselves. Used
    properly, recursion can be a very powerful tool that can be applied to many types
    of problems. The canonical example is the calculation of the factorial of a positive
    integer, the product of all positive integers less than or equal to `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For any integer `n` greater than one, `factorial` will call itself with a parameter
    of `n - 1`. This can add up very quickly!
  prefs: []
  type: TYPE_NORMAL
- en: Defer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go’s `defer` keyword can be used to schedule the execution of a function call
    for immediately before the surrounding function returns, and is commonly used
    to guarantee that resources are released or otherwise cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to defer printing the text “cruel world” to the end of a function
    call, we insert the `defer` keyword immediately before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When the previous snippet is run, it produces the following output, with the
    deferred output printed last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For a less trivial example, we’ll create an empty file and attempt to write
    to it. A `closeFile` function is provided to close the file when we’re done with
    it. However, if we simply call it at the end of `main`, an error could result
    in `closeFile` never being called and the file being left in an open state. Therefore,
    we use a `defer` to ensure that the `closeFile` function is called before the
    function returns, however it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If multiple defer calls are used in a function, each is pushed onto a stack.
    When the surrounding function returns, the deferred calls are executed in last-in-first-out
    order. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This function, when run, will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Defers are a very useful feature for ensuring that resources are cleaned up.
    If you’re working with external resources, you’ll want to make liberal use of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers as parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much of the power of pointers becomes evident when they’re combined with functions.
    Typically, function parameters are *passed* *by value*: when a function is called
    it receives a copy of each parameter, and changes made to the copy by the function
    don’t affect the caller. However, pointers contain a *reference* to a value, rather
    than the value itself, and can be used by a receiving function to indirectly modify
    the value passed to the function in a way that can affect the function caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The follow function demonstrates both scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior isn’t unique to pointers. In fact, under the hood, several data
    types are actually references to memory locations, including slices, maps, functions,
    and channels. Changes made to such *reference types* in a function can affect
    the caller, without needing to explicitly dereference them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the map `m` has a length of two when it’s passed to the `update`
    function, which adds the pair `{ "c" : 2 }`. Because `m` is a reference type,
    it’s passed to `update` as a reference to an underlying data structure instead
    of a copy of one, so the insertion is reflected in `m` in `main` after the `update`
    function returns.'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *variadic function* is one that may be called with zero or more trailing arguments.
    The most familiar example is the members of the `fmt.Printf` family of functions,
    which accept a single format specifier string and an arbitrary number of additional
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the signature for the standard `fmt.Printf` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it accepts a string, and zero or more `interface{}` values. If you’re
    rusty on the `interface{}` syntax, we’ll review it in [“Interfaces”](#section_ch03_interfaces),
    but you can interpret `interface{}` to mean “some arbitrarily typed thing.” What’s
    most interesting here, however, is that the final argument contains an ellipsis
    (`...`). This is the *variadic operator*, which indicates that the function may
    be called with any number of arguments of this type. For example, you can call
    `fmt.Printf` with a format and two differently typed parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the variadic function, the variadic argument is a slice of the argument
    type. In the following example, the variadic `factors` parameter of the `product`
    method is of type `[]int` and may be ranged over accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the call to `product` from `main` uses three parameters (though
    it could use any number of parameters it likes). In the `product` function, these
    are translated into an `[]int` slice with the value `{2, 2, 2}` that are iteratively
    multiplied to construct the final return value of `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing slices as variadic values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if your value is already in slice form, and you still want to pass it to
    a variadic function? Do you need to split it into multiple individual parameters?
    Goodness no.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you can apply the variadic operator after the variable name when
    calling the variadic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have a variable `m` with the type `[]int`, which you want to pass
    to the variadic function `product`. Using the variadic operator when calling `product(m...)`
    makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions and Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Go, functions are *first-class values* that can be operated upon in the
    same way as any other entity in the language: they have types, may be assigned
    to variables, and may even be passed to and returned by other functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The zero value of a function type is `nil`; calling a `nil` function value
    will cause a panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Functions may be created within other functions as *anonymous functions*, which
    may be called, passed, or otherwise treated like any other functions. A particularly
    powerful feature of Go is that anonymous functions have access to the state of
    their parent, and retain that access *even after* the parent function has executed.
    This is, in fact, the definition of a *closure*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A *closure* is a nested function that has access to the variables of its parent
    function, even after the parent has executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, the following `incrementor` function. This function has
    state, in the form of the variable `i`, and returns an anonymous function that
    increments that value before returning it. The returned function can be said to
    *close over* the variable `i`, making it a true (if trivial) closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `incrementor`, it creates its own new, local value of `i`, and
    returns a new anonymous function of type that will increment that value. Subsequent
    calls to `incrementor` will each receive their own copy of `i`. We can demonstrate
    that in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `incrementer` provides a new function `increment`; each
    call to `increment` increments its internal counter by one. When `incrementer`
    is called again, though, it creates and returns an entirely new function, with
    its own brand new counter. Neither of these functions can influence the other.
  prefs: []
  type: TYPE_NORMAL
- en: Structs, Methods, and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest mental switches that people sometimes have to make when first
    coming to the Go language is that Go isn’t a traditional object-oriented language.
    Not really. Sure, Go has types with methods, which kind of look like objects,
    but they don’t have a prescribed inheritance hierarchy. Instead Go allows components
    to be assembled into a whole using *composition*.
  prefs: []
  type: TYPE_NORMAL
- en: For example, where a more strictly object-oriented language might have a `Car`
    class that extends an abstract `Vehicle` class; perhaps it would implement `Wheels`
    and `Engine`. This sounds fine in theory, but these relationships can grow to
    become convoluted and hard to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s composition approach, on the other hand, allows components to be “put together”
    without having to define their ontological relationships. Extending the previous
    example, Go could have a `Car` struct, which could be have its various parts,
    such as `Wheels` and `Engine`, embedded within it. Furthermore, methods in Go
    can be defined for any sort of data; they’re not just for structs anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Go, a *struct* is nothing more than an aggregation of zero or more fields
    as a single entity, where each field is a named value of an arbitrary type. A
    struct can be defined using the following `type Name struct` syntax. A struct
    is never `nil`: rather, the zero value of a struct is the zero value of all of
    its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Struct fields can be accessed using the standard dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Structs are commonly created and manipulated by reference, so Go provides a
    little bit of syntactic sugar: members of structs can be accessed from a pointer
    to the struct using dot notation; the pointers are automatically dereferenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `v` is a pointer to a `Vertex` whose `X` and `Y` member values
    you want to swap. If you had to dereference the pointer to do this, you’d have
    to do something like `(*v).X, (*v).Y = (*v).Y, (*v).X`, which is clearly terrible.
    Instead, automatic pointer dereferencing lets you do `v.X, v.Y = v.Y, v.X`, which
    is far less terrible.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, *methods* are functions that are attached to types, including but not
    limited to structs. The declaration syntax for a method is very similar to that
    of a function, except that it includes an extra *receiver argument* before the
    function name that specifies the type that the method is attached to. When the
    method is called, the instance is accessible by the name specified in the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our earlier `Vertex` type can be extended by attaching a `Square`
    method with a receiver named `v` of type `*Vertex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Receivers are type specific: methods attached to a pointer type can only be
    called on a pointer to that type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to structs, you can also claim standard composite types—structs,
    slices, or maps—as your own, and attach methods to them. For example, we declare
    a new type, `MyMap`, which is just a standard `map[string]int`, and attach a `Length`
    method to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The result is a new type, `MyMap`, which is (and can be used as) a map of strings
    to integers, `map[string]int`, but which also has a `Length` method that returns
    the map’s length.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, an *interface* is just a set of method signatures. As in other languages
    with a concept of an interface, they are used to describe the general behaviors
    of other types without being coupled to implementation details. An interface can
    thus be viewed as a *contract* that a type may satisfy, opening the door to powerful
    abstraction techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `Shape` interface can be defined that includes an `Area` method
    signature. Any type that wants to be a `Shape` must have an `Area` method that
    returns a `float64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll define two shapes, `Circle` and `Rectangle`, that satisfy the `Shape`
    interface by attaching an `Area` method to each one. Note that we don’t have to
    explicitly declare that they satisfy the interface: if a type possesses all of
    its methods, it can *implicitly satisfy* an interface. This is particularly useful
    when you want to design interfaces that are satisfied by types that you don’t
    own or control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both `Circle` and `Rectangle` implicitly satisfy the `Shape` interface,
    we can pass them to any function that expects a `Shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Type assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *type assertion* can be applied to an interface value to “assert” its identity
    as a concrete type. The syntax takes the general form of `x.(T)`, where `x` is
    an expression of an interface, and `T` is the asserted type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the `Shape` interface and `Circle` struct we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The empty interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One curious construct is the *empty interface*: `interface{}`. The empty interface
    specifies no methods. It carries no information; it says nothing.^([7](ch03.xhtml#idm45983641253048))'
  prefs: []
  type: TYPE_NORMAL
- en: A variable of type `interface{}` can hold values of any type, which can be very
    useful when your code needs to handle values of any type. The `fmt.Println` method
    is a good example of a function using this strategy.
  prefs: []
  type: TYPE_NORMAL
- en: There are downsides, however. Working with the empty interface requires certain
    assumptions to be made, which have to be checked at runtime and result in code
    that’s more fragile and less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Composition with Type Embedding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go doesn’t allow subclassing or inheritance in the traditional object-oriented
    sense. Instead it allows types to be *embedded* within one another, extending
    the functionalities of the embedded types into the embedding type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a particularly useful feature of Go that allows functionalities to be
    reused via *composition*—combining the features of existing types to create new
    types—instead of inheritance, removing the need for the kinds of elaborate type
    hierarchies that can saddle traditional object-oriented programming projects.
  prefs: []
  type: TYPE_NORMAL
- en: Interface embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A popular example of embedding interfaces comes to us by way of the `io` package.
    Specifically, the widely used `io.Reader` and `io.Writer` interfaces, which are
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you want an interface with the methods of both an `io.Reader` and
    `io.Writer`? Well, you *could* implement a third interface that copies the methods
    of both, but then you have to keep all of them in agreement. That doesn’t just
    add unnecessary maintenance overhead: it’s also a good way to accidentally introduce
    errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than go the copy–paste route, Go allows you to embed the two existing
    interfaces into a third one that takes on the features of both. Syntactically,
    this is done by adding the embedded interfaces as anonymous fields, as demonstrated
    by the standard `io.ReadWriter` interface, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The result of this composition is a new interface that has all of the methods
    of the interfaces embedded within it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Only interfaces can be embedded within interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Struct embedding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding isn’t limited to interfaces: structs can also be embedded into other
    structs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The struct equivalent to the `io.Reader` and `io.Writer` example in the previous
    section comes from the `bufio` package. Specifically, `bufio.Reader` (which implements
    `io.Reader`) and `bufio.Writer` (which implements `io.Writer`). Similarly, `bufio`
    also provides an implementation of `io.ReadWriter`, which is just a composition
    of the existing `bufio.Reader` and `bufio.Writer` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax for embedding structs is identical to that of interfaces:
    adding the embedded types as unnamed fields. In the preceding case, the `bufio.ReadWriter`
    embeds `bufio.Reader` and `bufio.Writer` as pointer types.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just like any pointers, embedded pointers to structs have a zero value of `nil`,
    and must be initialized to point to valid structs before they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Promotion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, why would you use composition instead of just adding a struct field? The
    answer is that when a type is embedded, its exported properties and methods are
    *promoted* to the embedding type, allowing them to be directly invoked. For example,
    the `Read` method of a `bufio.Reader` is accessible directly from an instance
    of `bufio.ReadWriter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to know or care that the `Read` method is actually attached to
    the embedded `*bufio.Reader`. It’s important to know, though, that when a promoted
    method is invoked the method’s receiver is still the embedded type, so the receiver
    of `rw.Read` is the `ReadWriter`’s `Reader` field, not the `ReadWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: Directly accessing embedded fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Occasionally, you’ll need to refer to an embedded field directly. To do this,
    you use the type name of the field as a field name. In the following (somewhat
    contrived) example, the `UseReader` function requires a `*bufio.Reader`, but what
    you have is a `*bufio.ReadWriter` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this snippet uses the type name of the field you want to access
    (`Reader`) as the field name (`rw.Reader`) to retrieve the `*bufio.Reader` from
    `rw`. This can be handy for initialization as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If we’d just created `rw` as `&bufio.ReadWriter{}`, its embedded fields would
    be `nil`, but the snippet produces a `*bufio.ReadWriter` with fully defined `*bufio.Reader`
    and `*bufio.Writer` fields. While you wouldn’t typically do this with a `&bufio.ReadWriter`,
    this approach could be used to provide a useful mock in a pinch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Good Stuff: Concurrency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intricacies of concurrent programming are many, and are well beyond the
    scope of this work. However, you can say that reasoning about concurrency is hard,
    and that the way concurrency is generally done makes it harder. In most languages,
    the usual approach to processes orchestration is to create some shared bit of
    memory, which is then wrapped in locks to restrict access to one process at a
    time, often introducing maddeningly difficult-to-debug errors such as race conditions
    or deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go, on the other hand, favors another strategy: it provides two concurrency
    primitives—goroutines and channels—that can be used together to elegantly structure
    concurrent software, that don’t depend quite so much on locking. It encourages
    developers to limit sharing memory, and to instead allow processes to interact
    with one other entirely by passing messages.'
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of Go’s most powerful features is the `go` keyword. Any function call prepended
    with the `go` keyword will run as usual, but the caller can proceed uninterrupted
    rather than wait for the function to return. Under the hood, the function is executed
    as a lightweight, concurrently executing process called a *goroutine*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is strikingly simple: a function `foo`, which may be executed sequentially
    as `foo()`, may be executed as a concurrent goroutine simply by adding the `go`
    keyword: `go foo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Goroutines can also be used to invoke a function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go, *channels* are typed primitives that allow communication between two
    goroutines. They act as pipes into which a value can be sent and then received
    by a goroutine on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels may be created using the `make` function. Each channel can transmit
    values of a specific type, called its *element type*. Channel types are written
    using the `chan` keyword followed by their element type. The following example
    declares and allocates an `int` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The two primary operations supported by channels are *send* and *receive*,
    both of which use the `<-` operator, where the arrow indicates the direction of
    the data flow as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Channel blocking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, a channel is *unbuffered*. Unbuffered channels have a very useful
    property: sends on them block until another goroutine receives on the channel,
    and receives block until another goroutine sends on the channel. This behavior
    can be exploited to synchronize two goroutines, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Although `main` and the anonymous `goroutine` run concurrently and could in
    theory run in any order, the blocking behavior of unbuffered channels guarantees
    that the output will always be “ping” followed by “pong.”
  prefs: []
  type: TYPE_NORMAL
- en: Channel buffering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go channels may be *buffered*, in which case they contain an internal value
    queue with a fixed *capacity* that’s specified when the buffer is initialized.
    Sends to a buffered channel only block when the buffer is full; receives from
    a channel only block when the buffer is empty. Any other time, send and receive
    operations write to or read from the buffer, respectively, and exit immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'A buffered channel can be created by providing a second argument to the `make`
    function to indicate its capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Closing channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third available channel operation is *close*, which sets a flag to indicate
    that no more values will be sent on it. The built-in `close` function can be used
    to close a channel: `close(ch)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The channel close operation is just a flag to tell the receiver not to expect
    any more values. You don’t *have to* explicitly close channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to send on a closed channel will cause a `panic`. Receiving from a closed
    channel will retrieve any values sent on the channel prior to its closure; any
    subsequent receive operations will immediately yield the zero value of the channel’s
    element type. Receivers may also test whether a channel has been closed (and its
    buffer is empty) by assigning a second `bool` parameter to the receive expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While either party may close a channel, in practice only the sender should do
    so. Inadvertently sending on a closed channel will cause a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range` keyword may be used to loop over channels that are open or contain
    buffered values. The loop will block until a value is available to be read or
    until the channel is closed. You can see how this works in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the buffered channel `ch` is created, and three values are
    sent before being closed. Because the three values were sent to the channel before
    it was closed, looping over this channel will output all three lines before terminating.
  prefs: []
  type: TYPE_NORMAL
- en: Had the channel not been closed, the loop would stop and wait for the next value
    to be sent along the channel, potentially indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go’s `select` statements are a little like `switch` statements that provide
    a convenient mechanism for multiplexing communications with multiple channels.
    The syntax for `select` is very similar to `switch`, with some number of `case`
    statements that specify code to be executed upon a successful send or receive
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, there are three primary cases specified with three
    different conditions. If the channel `ch1` is ready to be read, then its value
    will be read (and discarded) and the text “Got something” will be printed. If
    `ch2` is ready to be read, then its value will be read and assigned to the variable
    `x` before printing the value of `x`. Finally, if `ch3` is ready to be sent to,
    then the value `y` is sent to it before printing the value of `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if no cases are ready, the `default` statements will be executed. If
    there’s no `default`, then the `select` will block until one of its cases is ready,
    at which point it performs the associated communication and executes the associated
    statements. If multiple cases are ready, `select` will execute one at random.
  prefs: []
  type: TYPE_NORMAL
- en: Gotcha!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `select`, keep in mind that a closed channel never blocks and is
    always readable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing channel timeouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability to use `select` to multiplex on channels can be very powerful,
    and can make otherwise very difficult or tedious tasks trivial. Take, for example,
    the implementation of a timeout on an arbitrary channel. In some languages this
    might require some awkward thread work, but a `select` with a call to `time.After`,
    which returns a channel that sends a message after a specified duration, makes
    short work of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Since there’s no `default` statement, this `select` will block until one if
    its case conditions becomes true. If `ch` doesn’t become available to read before
    the channel returned by `time.After` emits a message, then the second case will
    activate and the statement will time out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What I covered in this chapter could easily have consumed an entire book, if
    I’d been able to drill down into the level of detail the subject really deserves.
    But space and time are limited (and that book’s already been written^([8](ch03.xhtml#idm45983640288648)))
    so I have to remain content to have only this one chapter as a broad and shallow
    survey of the Go language (at least until the second edition comes out).
  prefs: []
  type: TYPE_NORMAL
- en: But learning Go’s syntax and grammar will only get you so far. In [Chapter 4](ch04.xhtml#chapter_4)
    I’ll be presenting a variety of Go programming patterns that I see come up pretty
    regularly in the “cloud native” context. So, if you thought this chapter was interesting,
    you’re going to love the next one.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45983647379672-marker)) Perlis, Alan. *ACM SIGPLAN Notices*
    17(9), September 1982, pp. 7–13.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45983647325000-marker)) Earlier versions of C, C++, and
    Python lacked a native Boolean type, instead representing them using the integers
    `0` (for `false`) or `1` (for `true`). Some languages like Perl, Lua, and Tcl
    still use a similar strategy.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45983647252184-marker)) See what I did there?
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch03.xhtml#idm45983646893816-marker)) Why would you?
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch03.xhtml#idm45983644570440-marker)) In fact, the freezing point of water
    on the Newton scale actually is 0.0, but that’s not important.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch03.xhtml#idm45983643598696-marker)) Clearly this code needs to be recalibrated.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch03.xhtml#idm45983641253048-marker)) Pike, Rob. “Go Proverbs.” YouTube.
    1 Dec. 2015\. [*https://oreil.ly/g8Rid*](https://oreil.ly/g8Rid).
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch03.xhtml#idm45983640288648-marker)) One last time, if you haven’t read
    it yet, go read *The Go Programming Language* by Donovan and Kernighan (Addison-Wesley
    Professional).
  prefs: []
  type: TYPE_NORMAL
