<html><head></head><body><section data-pdf-bookmark="Chapter 6. appending issue: Slices" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="appending_issuecolon_slices">
<h1 class="calibre17"><span class="calibre">Chapter 6. </span>appending issue: Slices</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0175-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="slices" data-secondary="about" data-type="indexterm" id="idm46062712701752" class="calibre10"/><strong class="calibre8">We’ve learned we can’t add more elements to an array.</strong> That’s a real problem for our program, because we don’t know in advance how many pieces of data our file contains. But that’s where Go <strong class="calibre8">slices</strong> come in. Slices are a collection type that can grow to hold additional items—just the thing to fix our current program! We’ll also see how slices give users an easier way to provide data to <em class="calibre9">all</em> your programs, and how they can help you write functions that are more convenient to call.</p>
<section data-pdf-bookmark="Slices" data-type="sect1" class="preface"><div class="preface" id="slices">
<h1 class="calibre25">Slices</h1>
<p class="calibre7"><a data-primary="arrays" data-secondary="slices and" data-type="indexterm" id="idm46062712696440" class="calibre10"/><a data-primary="functions" data-secondary="slices and" data-type="indexterm" id="idm46062712695192" class="calibre10"/><a data-primary="make built-in function" data-secondary="slices and" data-type="indexterm" id="idm46062712694056" class="calibre10"/><a data-primary="short variable declaration (:=)" data-secondary="for slices" data-type="indexterm" id="idm46062712692952" class="calibre10"/><a data-primary="slices" data-secondary="arrays and" data-type="indexterm" id="idm46062712691880" class="calibre10"/><a data-primary="slices" data-secondary="functions and" data-type="indexterm" id="idm46062712690744" class="calibre10"/><a data-primary="square brackets []" data-secondary="slices and" data-type="indexterm" id="idm46062712689672" class="calibre10"/>There actually <em class="calibre9">is</em> a Go data structure that we can add more values to—it’s called a <strong class="calibre8">slice</strong>. Like arrays, slices are made up of multiple elements, all of the same type. <em class="calibre9">Unlike</em> arrays, functions are available that allow us to add extra elements onto the end of a slice.</p>
<p class="calibre7">To declare the type for a variable that holds a slice, you use an empty pair of square brackets, followed by the type of elements the slice will hold.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0176-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">This is just like the syntax for declaring an array variable, except that you don’t specify the size.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0176-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Unlike with array variables, declaring a slice variable doesn’t automatically create a slice. For that, you can call the built-in <code class="calibre20">make</code> function. You pass <code class="calibre20">make</code> the type of the slice you want to create (which should be the same as the type of the variable you’re going to assign it to), and the length of slice it should create.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0176-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Once the slice is created, you assign and retrieve its elements using the same syntax you would for an array.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0176-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You don’t have to declare the variable and create the slice in separate steps; using <code class="calibre20">make</code> with a short variable declaration will infer the variable’s type for you.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0176-05.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="curly braces {}" data-secondary="slices and" data-type="indexterm" id="idm46062712673224" class="calibre10"/><a data-primary="len built-in function" data-secondary="slices and" data-type="indexterm" id="idm46062712671736" class="calibre10"/><a data-primary="literals" data-secondary="slice" data-type="indexterm" id="idm46062712670648" class="calibre10"/><a data-primary="slice literals" data-type="indexterm" id="idm46062712669512" class="calibre10"/><a data-primary="slices" data-secondary="len function and" data-type="indexterm" id="idm46062712668680" class="calibre10"/>The built-in <code class="calibre20">len</code> function works the same way with slices as it does with arrays. Just pass <code class="calibre20">len</code> a slice, and its length will be returned as an integer.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0177-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Both <code class="calibre20">for</code> and <code class="calibre20">for</code>...<code class="calibre20">range</code> loops work just the same with slices as they do with arrays, too:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0177-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Slice literals" data-type="sect1" class="preface"><div class="preface" id="slice_literals">
<h1 class="calibre25">Slice literals</h1>
<p class="calibre7">Just like with arrays, if you know in advance what values a slice will start with, you can initialize the slice with those values using a <strong class="calibre8">slice literal</strong>. A slice literal looks a lot like an array literal, but where an array literal has the length of the array in square brackets, a slice literal’s square brackets are empty. The empty brackets are then followed by the type of elements the slice will hold, and a list in curly braces of the initial values each element will have.</p>
<p class="calibre7">There’s no need to call the <code class="calibre20">make</code> function; using a slice literal in your code will create the slice <em class="calibre9">and</em> prepopulate it.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0177-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">These examples are like the previous ones we showed, except that instead of assigning values to the slice elements one by one, the entire slice is initialized using slice literals.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0177-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Pool Puzzle" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_6">
<h1 class="calibre25">Pool Puzzle</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0178-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Your <strong class="calibre8">job</strong> is to take code snippets from the pool and place them into the blank lines in this code. <strong class="calibre8">Don’t</strong> use the same snippet more than once, and you won’t need to use all the snippets. Your <strong class="calibre8">goal</strong> is to make a program that will run and produce the output shown.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0178-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0178-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">Note: each snippet from the pool can only be used once!</strong></p>
<p class="calibre7"><span class="calibre"><img alt="image" src="assets/arrow.png" class="calibre4"/></span> Answers in <a data-type="xref" href="#pool_puzzle_Solution_4" class="calibre10">“Pool Puzzle Solution”</a>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0179-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">Because slices are built on <span class="calibre21">top</span> of arrays. You can’t understand how slices work without understanding arrays. Here, we’ll show you why...</strong></p>
</blockquote>
</div></section>
<section data-pdf-bookmark="The slice operator" data-type="sect1" class="preface"><div class="preface" id="the_slice_operator">
<h1 class="calibre25">The slice operator</h1>
<p class="calibre7"><a data-primary="arrays" data-secondary="slices and" data-type="indexterm" id="idm46062712634728" class="calibre10"/><a data-primary="indexes" data-secondary="for slices" data-type="indexterm" id="idm46062712633128" class="calibre10"/><a data-primary="make built-in function" data-secondary="slices and" data-type="indexterm" id="idm46062712632040" class="calibre10"/><a data-primary="slice operator" data-type="indexterm" id="idm46062712630904" class="calibre10"/><a data-primary="slices" data-secondary="arrays and" data-type="indexterm" id="idm46062712630072" class="calibre10"/><a data-primary="slices" data-secondary="indexes for" data-type="indexterm" id="idm46062712628968" class="calibre10"/><a data-primary="start indexes (slices)" data-type="indexterm" id="idm46062712627864" class="calibre10"/><a data-primary="stop indexes (slices)" data-type="indexterm" id="idm46062712627032" class="calibre10"/>Every slice is built on top of an <strong class="calibre8">underlying array</strong>. It’s the underlying array that actually holds the slice’s data; the slice is merely a view into some (or all) of the array’s elements.</p>
<p class="calibre7">When you use the <code class="calibre20">make</code> function or a slice literal to create a slice, the underlying array is created for you automatically (and you can’t access it, except through the slice). But you can also create the array yourself, and then create a slice based on it with the <strong class="calibre8">slice operator</strong>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0180-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The slice operator looks similar to the syntax for accessing an individual element or slice of an array, except that it has two indexes: the index of the array where the slice should start, and the index of the array that the slice should stop <span class="calibre21">before</span>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0180-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Notice that we emphasize that the second index is the index the slice will stop <span class="calibre21">before</span>. That is, the slice should include the elements up to, but <em class="calibre9">not</em> including, the second index. If you use <code class="calibre20">underlyingArray[i:j]</code> as a slice operator, the resulting slice will actually contain the elements <code class="calibre20">underlyingArray[i]</code> through <code class="calibre20">underlyingArray[j-1]</code>.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="calibre7">(We know, it’s counterintuitive. But a similar notation has been used in the Python programming language for over 20 years, and it seems to work OK.)</p>
</div>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0180-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If you want a slice to include the last element of an underlying array, you actually specify a second index that’s one <em class="calibre9">beyond</em> the end of the array in your slice operator.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0181-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Make sure you don’t go any further than that, though, or you’ll get an error:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0181-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The slice operator has defaults for both the start and stop indexes. If you omit the start index, a value of <code class="calibre20">0</code> (the first element of the array) will be used.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0181-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">And if you omit the stop index, everything from the start index to the end of the underlying array will be included in the resulting slice.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0181-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Underlying arrays" data-type="sect1" class="preface"><div class="preface" id="underlying_arrays">
<h1 class="calibre25">Underlying arrays</h1>
<p class="calibre7"><a data-primary="slices" data-secondary="about" data-type="indexterm" id="idm46062712600920" class="calibre10"/>As we mentioned, a slice doesn’t hold any data itself; it’s merely a view into the elements of an underlying array. You can think of a slice as a microscope, focusing on a particular portion of the contents of a slide (the underlying array).</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0182-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">When you take a slice of an underlying array, you can only “see” the portion of the array’s elements that are visible through the slice.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0182-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">It’s even possible to have multiple slices point to the same underlying array. Each slice will then be a view into its own subset of the array’s elements. The slices can even overlap!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0182-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Change the underlying array, change the slice" data-type="sect1" class="preface"><div class="preface" id="change_the_underlying_arraycomma_change">
<h1 class="calibre25">Change the underlying array, change the slice</h1>
<p class="calibre7"><a data-primary="literals" data-secondary="slice" data-type="indexterm" id="idm46062712590872" class="calibre10"/><a data-primary="make built-in function" data-secondary="slices and" data-type="indexterm" id="idm46062712589208" class="calibre10"/><a data-primary="slice literals" data-type="indexterm" id="idm46062712588120" class="calibre10"/><a data-primary="slice operator" data-type="indexterm" id="idm46062712587256" class="calibre10"/>Now, here’s something to be careful about: because a slice is just a view into the contents of an array, if you change the underlying array, those changes will <em class="calibre9">also</em> be visible within the slice!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0183-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Assigning a new value to a slice element will change the corresponding element in the underlying array.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0183-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If multiple slices point to the same underlying array, a change to the array’s elements will be visible in <em class="calibre9">all</em> the slices.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0183-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Because of these potential issues, you may find it’s generally better to create slices using <code class="calibre20">make</code> or a slice literal, rather than creating an array and using a slice operator on it. With <code class="calibre20">make</code> and with slice literals, you never have to work with the underlying array.</p>
</div></section>
<section data-pdf-bookmark="Add onto a slice with the “append” function" data-type="sect1" class="preface"><div class="preface" id="add_onto_a_slice_with_the_ldquoappendrdq">
<h1 class="calibre25">Add onto a slice with the “append” function</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0184-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="append built-in function" data-type="indexterm" id="idm46062712573320" class="calibre10"/><a data-primary="slices" data-secondary="append function and" data-type="indexterm" id="idm46062712572104" class="calibre10"/>Go offers a built-in <code class="calibre20">append</code> function that takes a slice, and one or more values you want to append to the end of that slice. It returns a new, larger slice with all the same elements as the original slice, plus the new elements added onto the end.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0184-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">You don’t have to keep track of what index you want to assign new values to, or anything! Just call <code class="calibre20">append</code> with your slice and the value(s) you want added to the end, and you’ll get a new, longer slice back. It’s really that easy!</p>
<p class="calibre7">Well, with one caution...</p>
<p class="calibre7">Notice that we’re making sure to assign the return value of <code class="calibre20">append</code> back to the <em class="calibre9">same</em> slice variable we passed to <code class="calibre20">append</code>. This is to avoid some potentially inconsistent behavior in the slices returned from <code class="calibre20">append</code>.</p>
<p class="calibre7">A slice’s underlying array can’t grow in size. If there isn’t room in the array to add elements, all its elements will be copied to a new, larger array, and the slice will be updated to refer to this new array. But since all this happens behind the scenes in the <code class="calibre20">append</code> function, there’s no easy way to tell whether the slice returned from <code class="calibre20">append</code> has the <em class="calibre9">same</em> underlying array as the slice you passed in, or a <em class="calibre9">different</em> underlying array. If you keep both slices, this can lead to some unpredictable behavior.</p>
<p class="calibre7">Below, for example, we have four slices, the last three created by calls to <code class="calibre20">append</code>. Here we are <em class="calibre9">not</em> following the convention of assigning <code class="calibre20">append</code>’s return value back to the same variable. When we assign a value to an element of the <code class="calibre20">s4</code> slice, we can see the change reflected in <code class="calibre20">s3</code>, because <code class="calibre20">s4</code> and <code class="calibre20">s3</code> happen to share the same underlying array. But the change is <em class="calibre9">not</em> reflected in <code class="calibre20">s2</code> or <code class="calibre20">s1</code>, because they have a <em class="calibre9">different</em> underlying array.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0185-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">So when calling <code class="calibre20">append</code>, it’s conventional to just assign the return value back to the same slice variable you passed to <code class="calibre20">append</code>. You don’t need to worry about whether two slices have the same underlying array if you’re only storing one slice!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0185-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Slices and zero values" data-type="sect1" class="preface"><div class="preface" id="slices_and_zero_values">
<h1 class="calibre25">Slices and zero values</h1>
<p class="calibre7"><a data-primary="nil value" data-secondary="for slices" data-type="indexterm" id="idm46062712549272" class="calibre10"/><a data-primary="slices" data-secondary="nil value for" data-type="indexterm" id="idm46062712547784" class="calibre10"/><a data-primary="slices" data-secondary="zero values for" data-type="indexterm" id="idm46062712546712" class="calibre10"/><a data-primary="%#v formatting verb" data-type="indexterm" id="idm46062712545576" class="calibre10"/><a data-primary="zero values" data-secondary="for slices" data-type="indexterm" id="idm46062712544744" class="calibre10"/>As with arrays, if you access a slice element that no value has been assigned to, you’ll get the zero value for that type back:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0186-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Unlike arrays, the slice variable itself <em class="calibre9">also</em> has a zero value: it’s <code class="calibre20">nil</code>. That is, a slice variable that no slice has been assigned to will have a value of <code class="calibre20">nil</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0186-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">In other languages, that might require testing whether a variable actually contains a slice before attempting to use it. But in Go, functions are intentionally written to treat a <code class="calibre20">nil</code> slice value as if it were an empty slice. For example, the <code class="calibre20">len</code> function will return <code class="calibre20">0</code> if it’s passed a <code class="calibre20">nil</code> slice:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0186-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The <code class="calibre20">append</code> function also treats <code class="calibre20">nil</code> slices like empty slices. If you pass an empty slice to <code class="calibre20">append</code>, it will add the item you specify to the slice, and return a slice with one item. If you pass a <code class="calibre20">nil</code> slice to <code class="calibre20">append</code>, you’ll <em class="calibre9">also</em> get a slice with one item back, even though there technically was no slice to “append” the item to. The <code class="calibre20">append</code> function will create the slice behind the scenes.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0186-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">This means you generally don’t have to worry about whether you have an empty slice or a <code class="calibre20">nil</code> slice. You can treat them both the same, and your code will “just work”!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0186-05.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Reading additional file lines using slices and “append”" data-type="sect1" class="preface"><div class="preface" id="reading_additional_file_lines_using_slic">
<h1 class="calibre25">Reading additional file lines using slices and “append”</h1>
<p class="calibre7"><a data-primary="append built-in function" data-type="indexterm" id="idm46062712522952" class="calibre10"/><a data-primary="file management" data-secondary="reading text files using slices and append function" data-type="indexterm" id="idm46062712521704" class="calibre10"/><a data-primary="reading text files" data-secondary="using slices and append function" data-type="indexterm" id="idm46062712520488" class="calibre10"/><a data-primary="slices" data-secondary="append function and" data-type="indexterm" id="idm46062712519448" class="calibre10"/><a data-primary="text files" data-secondary="reading using slices and append function" data-type="indexterm" id="idm46062712518344" class="calibre10"/>Now that we know about slices and the <code class="calibre20">append</code> function, we can finally fix our <code class="calibre20">average</code> program! Remember, <code class="calibre20">average</code> was failing as soon as we added a fourth line to the <em class="calibre9">data.txt</em> file it reads from:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0187-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">We traced the problem back to our <code class="calibre20">datafile</code> package, which stores the file lines in an array that can’t grow beyond three elements:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0187-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Most of our work with slices has just centered on understanding them. Now that we do, updating the <code class="calibre20">GetFloats</code> function to use a slice instead of an array doesn’t involve much effort.</p>
<p class="calibre7">First, we update the function declaration to return a slice of <code class="calibre20">float64</code> values instead of an array. Previously, we stored the array in a variable called <code class="calibre20">numbers</code>; we’ll just use that same variable name to hold the slice. We won’t assign a value to <code class="calibre20">numbers</code>, so at first it will be <code class="calibre20">nil</code>.</p>
<p class="calibre7">Instead of assigning values read from the file to a specific array index, we can just call <code class="calibre20">append</code> to extend the slice (or create a slice, if it’s <code class="calibre20">nil</code>) and add new values. That means we can get rid of the code to create and update the <code class="calibre20">i</code> variable that tracks the index. We assign the <code class="calibre20">float64</code> value returned from <code class="calibre20">ParseFloat</code> to a new temporary variable, just to hold it while we check for any errors in parsing. Then we pass the <code class="calibre20">numbers</code> slice and the new value from the file to <code class="calibre20">append</code>, making sure to assign the return value back to the <code class="calibre20">numbers</code> variable.</p>
<p class="calibre7">Aside from that, the code in <code class="calibre20">GetFloats</code> can remain the same—the slice is basically a drop-in replacement for the array.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0188-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Trying our improved program" data-type="sect1" class="preface"><div class="preface" id="trying_our_improved_program">
<h1 class="calibre25">Trying our improved program</h1>
<p class="calibre7">The slice returned from the <code class="calibre20">GetFloats</code> function works like a drop-in replacement for an array in our main <code class="calibre20">average</code> program, too. In fact, we don’t have to make <em class="calibre9">any</em> changes to the main program!</p>
<p class="calibre7">Because we used a <code class="calibre20">:=</code> short variable declaration to assign the <code class="calibre20">GetFloats</code> return value to a variable, the <code class="calibre20">numbers</code> variable automatically switches from an inferred type of <code class="calibre20">[3]float64</code> (an array) to a type of <code class="calibre20">[]float64</code> (a slice). And because the <code class="calibre20">for</code>...<code class="calibre20">range</code> loop and the <code class="calibre20">len</code> functions work the same way with a slice as they do with an array, no changes are needed to that code, either!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0189-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">That means we’re ready to try the changes out! Ensure the <em class="calibre9">data.txt</em> file is still saved in your Go workspace’s <em class="calibre9">bin</em> subdirectory, and then compile and run the code using the same commands as before. It will read all the lines of <em class="calibre9">data.txt</em> and display their average. Then try updating <em class="calibre9">data.txt</em> to have more lines, or fewer; it will still work regardless!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0189-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0189-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Returning a nil slice in the event of an error" data-type="sect1" class="preface"><div class="preface" id="returning_a_nil_slice_in_the_event_of_an">
<h1 class="calibre25">Returning a nil slice in the event of an error</h1>
<p class="calibre7"><a data-primary="error handling" data-secondary="slices" data-type="indexterm" id="idm46062712482792" class="calibre10"/><a data-primary="nil value" data-secondary="for slices" data-type="indexterm" id="idm46062712481016" class="calibre10"/><a data-primary="slices" data-secondary="error handling" data-type="indexterm" id="idm46062712479976" class="calibre10"/><a data-primary="slices" data-secondary="nil value for" data-type="indexterm" id="idm46062712478824" class="calibre10"/>Let’s make one more small improvement to the <code class="calibre20">GetFloats</code> function. Currently, we’re returning the <code class="calibre20">numbers</code> slice even in the event of an error. That means that we could be returning a slice with invalid data:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0190-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The code that calls <code class="calibre20">GetFloats</code> <em class="calibre9">should</em> check the returned error value, see that it’s not <code class="calibre20">nil</code>, and ignore the contents of the returned slice. But really, why bother to return the slice at all, if the data it contains is invalid? Let’s update <code class="calibre20">GetFloats</code> to return <code class="calibre20">nil</code> instead of a slice in the event of an error.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0190-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Let’s recompile the program (which will include the updated <code class="calibre20">datafile</code> package) and run it. It should work the same as before. But now our error-handling code is a little bit cleaner.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0190-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_10">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common.png" class="calibre4"/></span> Exercise</h5>
<p class="calibre7"><a data-primary="arguments, command-line" data-type="indexterm" id="idm46062712463928" class="calibre10"/><a data-primary="cd command" data-type="indexterm" id="idm46062712462776" class="calibre10"/><a data-primary="command-line arguments" data-secondary="about" data-type="indexterm" id="idm46062712462040" class="calibre10"/>Below is a program that takes a slice of an array and then appends elements to the slice. Write down what the program output would be.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0191-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
<p class="calibre7"><span class="calibre"><img alt="image" src="assets/arrow.png" class="calibre4"/></span> Answers in <a data-type="xref" href="#exercise_solutions_10" class="calibre10">“<span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="Command-line arguments" data-type="sect1" class="preface"><div class="preface" id="command-line_arguments">
<h1 class="calibre25">Command-line arguments</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0191-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<blockquote class="calibre37 pcalibre1 pcalibre2">
<p class="calibre38"><strong class="calibre8">There is an alternative—users could pass the values to the program as <span class="calibre21">command-line arguments</span>.</strong></p>
</blockquote>
<p class="calibre7">Just as you can control the behavior of many Go functions by passing them arguments, you can pass arguments to many programs you run from the terminal or command prompt. This is known as a program’s <em class="calibre9">command-line interface</em>.</p>
<p class="calibre7">You’ve already seen command-line arguments used in this very book. When we run the <code class="calibre20">cd</code> (“change directory”) command, we pass it the name of the directory we want to change to as an argument. When we run the <code class="calibre20">go</code> command, we often pass it multiple arguments: the subcommand (<code class="calibre20">run</code>, <code class="calibre20">install</code>, etc.) we want to use, and the name of the file or package we want the subcommand to work on.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0191-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Getting command-line arguments from the os.Args slice" data-type="sect1" class="preface"><div class="preface" id="getting_command-line_arguments_from_the">
<h1 class="calibre25">Getting command-line arguments from the os.Args slice</h1>
<p class="calibre7"><a data-primary="Args variable (os)" data-type="indexterm" id="idm46062712444456" class="calibre10"/><a data-primary="command-line arguments" data-secondary="os.Args and" data-type="indexterm" id="idm46062712443176" class="calibre10"/><a data-primary="os package" data-secondary="Args variable" data-type="indexterm" id="idm46062712442072" class="calibre10"/>Let’s set up a new version of the <code class="calibre20">average</code> program, called <code class="calibre20">average2</code>, that takes the values to average as command-line arguments.</p>
<p class="calibre7">The <code class="calibre20">os</code> package has a package variable, <code class="calibre20">os.Args</code>, that gets set to a slice of strings representing the command-line arguments the currently running program was executed with. We’ll start by simply printing the <code class="calibre20">os.Args</code> slice to see what it contains.</p>
<p class="calibre7">Create a new <em class="calibre9">average2</em> directory alongside the <em class="calibre9">average</em> directory in your workspace, and save a <em class="calibre9">main.go</em> file within it.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0192-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Then, save the following code in <em class="calibre9">main.go</em>. It simply imports the <code class="calibre20">fmt</code> and <code class="calibre20">os</code> packages, and passes the <code class="calibre20">os.Args</code> slice to <code class="calibre20">fmt.Println</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0192-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Let’s try it out. From your terminal or command prompt, run this command to compile and install the program:</p>
<p class="calibre7"><code class="calibre20">go install github.com/headfirstgo/average2</code></p>
<p class="calibre7">That will install an executable file named <em class="calibre9">average2</em> (or <em class="calibre9">average2.exe</em> on Windows) to your Go workspace’s <em class="calibre9">bin</em> subdirectory. Use the <code class="calibre20">cd</code> command to change to <em class="calibre9">bin</em>, and type <strong class="calibre8">average2</strong>, but don’t hit the Enter key just yet. Following the program name, type a space, and then type one or more arguments, separated by spaces. <em class="calibre9">Then</em> hit Enter. The program will run and print the value of <code class="calibre20">os.Args</code>.</p>
<p class="calibre7">Rerun <code class="calibre20">average2</code> with different arguments, and you should see different output.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0192-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="The slice operator can be used on other slices" data-type="sect1" class="preface"><div class="preface" id="the_slice_operator_can_be_used_on_other">
<h1 class="calibre25">The slice operator can be used on other slices</h1>
<p class="calibre7"><a data-primary="arrays" data-secondary="slices and" data-type="indexterm" id="idm46062712420088" class="calibre10"/><a data-primary="slice operator" data-type="indexterm" id="idm46062712418472" class="calibre10"/><a data-primary="slices" data-secondary="arrays and" data-type="indexterm" id="idm46062712417672" class="calibre10"/>This is working pretty well, but there’s one problem: the name of the executable is being included as the first element of <code class="calibre20">os.Args</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0193-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">That should be easy to remove, though. Remember how we used the slice operator to get a slice that included everything but the first element of an array?</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0193-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The slice operator can be used on slices just like it can on arrays. If we use a slice operator of <code class="calibre20">[1:]</code> on <code class="calibre20">os.Args</code>, it will give us a new slice that omits the first element (whose index is <code class="calibre20">0</code>), and includes the second element (index <code class="calibre20">1</code>) through the end of the slice.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0193-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">If we recompile and rerun <code class="calibre20">average2</code>, this time we’ll see that the output includes only the actual command-line arguments.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0193-04.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Updating our program to use command-line arguments" data-type="sect1" class="preface"><div class="preface" id="updating_our_program_to_use_command-line">
<h1 class="calibre25">Updating our program to use command-line arguments</h1>
<p class="calibre7"><a data-primary="arguments, command-line" data-type="indexterm" id="idm46062712402696" class="calibre10"/><a data-primary="command-line arguments" data-secondary="updating programs to use" data-type="indexterm" id="idm46062712401528" class="calibre10"/><a data-primary="len built-in function" data-secondary="slices and" data-type="indexterm" id="idm46062712400408" class="calibre10"/><a data-primary="slices" data-secondary="len function and" data-type="indexterm" id="idm46062712399256" class="calibre10"/>Now that we’re able to get the command-line arguments as a slice of strings, let’s update the <code class="calibre20">average2</code> program to convert the arguments to actual numbers, and calculate their average. We’ll mostly be able to reuse the concepts we learned about in our original <code class="calibre20">average</code> program and the <code class="calibre20">datafile</code> package.</p>
<p class="calibre7">We use the slice operator on <code class="calibre20">os.Args</code> to omit the program name, and assign the resulting slice to an <code class="calibre20">arguments</code> variable. We set up a <code class="calibre20">sum</code> variable that will hold the total of all the numbers we’re given. Then we use a <code class="calibre20">for</code>...<code class="calibre20">range</code> loop to process the elements of the <code class="calibre20">arguments</code> slice (using the <code class="calibre20">_</code> blank identifier to ignore the element index). We use <code class="calibre20">strconv.ParseFloat</code> to convert the argument string to a <code class="calibre20">float64</code>. If we get an error, we log it and exit, but otherwise we add the current number to <code class="calibre20">sum</code>.</p>
<p class="calibre7">When we’ve looped through all the arguments, we use <code class="calibre20">len(arguments)</code> to determine how many data samples we’re averaging. We then divide <code class="calibre20">sum</code> by this sample count to get the average.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0194-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">With these changes saved, we can recompile and rerun the program. It will take the numbers you provide as arguments and average them. Give as few or as many arguments as you like; it will still work!</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0194-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Variadic functions" data-type="sect1" class="preface"><div class="preface" id="variadic_functions">
<h1 class="calibre25">Variadic functions</h1>
<p class="calibre7"><a data-primary="... (ellipsis)" data-type="indexterm" id="idm46062712383864" class="calibre10"/><a data-primary="arguments to functions" data-secondary="variadic functions and" data-type="indexterm" id="idm46062712382712" class="calibre10"/><a data-primary="ellipsis (...)" data-type="indexterm" id="idm46062712381592" class="calibre10"/><a data-primary="functions" data-secondary="variadic" data-type="indexterm" id="idm46062712380728" class="calibre10"/><a data-primary="variadic functions" data-secondary="about" data-type="indexterm" id="idm46062712379592" class="calibre10"/>Now that we know about slices, we can cover a feature of Go that we haven’t talked about so far. Have you noticed that some function calls can take as few, or as many, arguments as needed? Look at <code class="calibre20">fmt.Println</code> or <code class="calibre20">append</code>, for example:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0195-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Don’t try doing this with just any function, though! With all the functions we’ve defined so far, there had to be an <em class="calibre9">exact</em> match between the number of parameters in the function definition and the number of arguments in the function call. Any difference would result in a compile error.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0195-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">So how do <code class="calibre20">Println</code> and <code class="calibre20">append</code> do it? They’re declared as variadic functions. A <strong class="calibre8">variadic function</strong> is one that can be called with a <em class="calibre9">varying</em> number of arguments. To make a function variadic, use an ellipsis (<code class="calibre20">...</code>) before the type of the last (or only) function parameter in the function declaration.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0195-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="variadic functions" data-secondary="examples of" data-type="indexterm" id="idm46062712367592" class="calibre10"/>The last parameter of a variadic function receives the variadic arguments as a slice, which the function can then process like any other slice.</p>
<p class="calibre7">Here’s a variadic version of the <code class="calibre20">twoInts</code> function, and it works just fine with any number of arguments:</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0196-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Here’s a similar function that works with strings. Notice that if we provide no variadic arguments, it’s not an error; the function just receives an empty slice.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0196-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">A function can take one or more nonvariadic arguments as well. Although a function caller can omit variadic arguments (resulting in an empty slice), nonvariadic arguments are always required; it’s a compile error to omit those. Only the <em class="calibre9">last</em> parameter in a function definition can be variadic; you can’t place it in front of required parameters.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0196-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Using variadic functions" data-type="sect1" class="preface"><div class="preface" id="using_variadic_functions">
<h1 class="calibre25">Using variadic functions</h1>
<p class="calibre7">Here’s a <code class="calibre20">maximum</code> function that takes any number of <code class="calibre20">float64</code> arguments and returns the greatest value out of all of them. The arguments to <code class="calibre20">maximum</code> are stored in a slice in the <code class="calibre20">numbers</code> parameter. To start, we set the current maximum value to <code class="calibre20">-Inf</code>, a special value representing negative infinity, obtained by calling <code class="calibre20">math.Inf</code>. (We could start with a current maximum of <code class="calibre20">0</code>, but this way <code class="calibre20">maximum</code> will work with negative numbers.) Then we use <code class="calibre20">for</code>...<code class="calibre20">range</code> to process each argument in the <code class="calibre20">numbers</code> slice, comparing it to the current maximum, and setting it as the new maximum if it’s greater. Whatever maximum remains after processing all the arguments is the one we return.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0197-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Here’s an <code class="calibre20">inRange</code> function that takes a minimum value, a maximum value, and any number of additional <code class="calibre20">float64</code> arguments. It will discard any argument that is below the given minimum or above the given maximum, returning a slice containing only the arguments that were in the specified range.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0197-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Code Magnets" data-type="sect1" class="preface"><div class="preface" id="code_magnets_4">
<h1 class="calibre25">Code Magnets</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0198-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><a data-primary="averages, calculating using variadic functions" data-type="indexterm" id="idm46062712341576" class="calibre10"/><a data-primary="variadic functions" data-secondary="using to calculate averages" data-type="indexterm" id="idm46062712340200" class="calibre10"/>A Go program that defines and uses a variadic function is scrambled up on the fridge. Can you reconstruct the code snippets to make a working program that will produce the given output?</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0198-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><span class="calibre"><img alt="image" src="assets/arrow.png" class="calibre4"/></span> Answers in <a data-type="xref" href="#code_magnets_solution_4" class="calibre10">“Code Magnets Solution”</a>.</p>
</div></section>
<section data-pdf-bookmark="Using a variadic function to calculate averages" data-type="sect1" class="preface"><div class="preface" id="using_a_variadic_function_to_calculate_a">
<h1 class="calibre25">Using a variadic function to calculate averages</h1>
<p class="calibre7">Let’s create a variadic <code class="calibre20">average</code> function that can take any number of <code class="calibre20">float64</code> arguments and return their average. It will look much like the logic from our <code class="calibre20">average2</code> program. We’ll set up a <code class="calibre20">sum</code> variable to hold the total of the argument values. Then we’ll loop through the range of arguments, adding each one to the value in <code class="calibre20">sum</code>. Finally, we’ll divide <code class="calibre20">sum</code> by the number of arguments (converted to a <code class="calibre20">float64</code>) to get the average. The result is a function that can average as many (or as few) numbers as we want.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0198-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Passing slices to variadic functions" data-type="sect1" class="preface"><div class="preface" id="passing_slices_to_variadic_functions">
<h1 class="calibre25">Passing slices to variadic functions</h1>
<p class="calibre7"><a data-primary="slices" data-secondary="passing to variadic functions" data-type="indexterm" id="idm46062712325112" class="calibre10"/><a data-primary="variadic functions" data-secondary="passing slices to" data-type="indexterm" id="idm46062712323864" class="calibre10"/>Our new <code class="calibre20">average</code> variadic function works so well, we should try updating our <code class="calibre20">average2</code> program to make use of it. We can paste the <code class="calibre20">average</code> function into our <code class="calibre20">average2</code> code as is.</p>
<p class="calibre7">In the <code class="calibre20">main</code> function, we’re still going to need to convert each of the command-line arguments from a <code class="calibre20">string</code> to a <code class="calibre20">float64</code> value. We’ll create a slice to hold the resulting values, and store it in a variable named <code class="calibre20">numbers</code>. After each command-line argument is converted, instead of using it to calculate the average directly, we’ll just append it to the <code class="calibre20">numbers</code> slice.</p>
<p class="calibre7">We then <em class="calibre9">attempt</em> to pass the <code class="calibre20">numbers</code> slice to the <code class="calibre20">average</code> function. But when we go to compile the program, that results in an error...</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0199-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">The <code class="calibre20">average</code> function is expecting one or more <code class="calibre20">float64</code> arguments, not a <em class="calibre9">slice</em> of <code class="calibre20">float64</code> values...</p>
<p class="calibre7">So what now? Are we forced to choose between making our functions variadic and being able to pass slices to them?</p>
<p class="calibre7">Fortunately, Go provides special syntax for this situation. When calling a variadic function, simply add an ellipsis (<code class="calibre20">...</code>) following the slice you want to use in place of variadic arguments.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0200-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">So all we need to do is add an ellipsis following the <code class="calibre20">numbers</code> slice in our call to <code class="calibre20">average</code>.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0200-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">With that change made, we should be able to compile and run our program again. It will convert our command-line arguments to a slice of <code class="calibre20">float64</code> values, then pass that slice to the variadic <code class="calibre20">average</code> function.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0200-03.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></section>
<section data-pdf-bookmark="Slices have saved the day!" data-type="sect1" class="preface"><div class="preface" id="slices_have_saved_the_dayexcl">
<h1 class="calibre25">Slices have saved the day!</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0201-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7">Working with lists of values is essential for any programming language. With arrays and slices, you can keep your data in collections of whatever size you need. And with features like <code class="calibre20">for</code>...<code class="calibre20">range</code> loops, Go makes it easy to process the data in those collections, too!</p>
</div></section>
<section data-pdf-bookmark="Your Go Toolbox" data-type="sect1" class="preface"><div class="preface" id="your_go_toolbox_6">
<h1 class="calibre25">Your Go Toolbox</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0202-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"><strong class="calibre8">That’s it for <a data-type="xref" href="#appending_issuecolon_slices" class="calibre10">Chapter 6</a>! You’ve added slices to your toolbox.</strong></p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0202-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="Bullet_Points_6">
<h5 class="calibre31">Bullet Points</h5>
<ul class="list_style_type_none">
<li class="calibre18"><p class="calibre7">The type for a slice variable is declared just like the type for an array variable, except the length is omitted:</p>
<p class="calibre7"><code class="calibre20">var mySlice []int</code></p></li>
<li class="calibre18"><p class="calibre7">For the most part, code for working with slices is identical to code that works with arrays. This includes: accessing elements, using zero values, passing slices to the <code class="calibre20">len</code> function, and <code class="calibre20">for</code>...<code class="calibre20">range</code> loops.</p></li>
<li class="calibre18"><p class="calibre7">A <strong class="calibre8">slice literal</strong> looks just like an array literal, except the length is omitted:<br class="calibre16"/><code class="calibre20">[]int{1, 7, 10}</code></p></li>
<li class="calibre18"><p class="calibre7">You can get a slice that contains elements <code class="calibre20">i</code> through <code class="calibre20">j - 1</code> of an array or slice using the <strong class="calibre8">slice operator</strong>: <code class="calibre20">s[i:j]</code></p></li>
<li class="calibre18"><p class="calibre7">The <code class="calibre20">os.Args</code> package variable contains a slice of strings with the command-line arguments the current program was run with.</p></li>
<li class="calibre18"><p class="calibre7">A <strong class="calibre8">variadic function</strong> is one that can be called with a varying number of arguments.</p></li>
<li class="calibre18"><p class="calibre7">To declare a variadic function, place an ellipsis (<code class="calibre20">...</code>) before the type of the last parameter in the function declaration. That parameter will then receive all the variadic arguments as a slice.</p></li>
<li class="calibre18"><p class="calibre7">When calling a variadic function, you can use a slice in place of the variadic arguments by typing an ellipsis after the slice:</p>
<p class="calibre7"><code class="calibre20">inRange(1, 10, mySlice...)</code></p></li>
</ul>
</div></aside>
</div></section>
<section data-pdf-bookmark="Pool Puzzle Solution" data-type="sect1" class="preface"><div class="preface" id="pool_puzzle_Solution_4">
<h1 class="calibre25">Pool Puzzle Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0203-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar" class="calibre30"><div class="sidebar" id="exercise_solutions_10">
<h5 class="calibre31"><span class="calibre"><img alt="image" src="assets/common1.png" class="calibre4"/></span> Exercise Solution</h5>
<p class="calibre7">Below is a program that takes a slice of an array and then appends elements to the slice. Write down what the program output would be.</p>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0203-02.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
</div></aside>
</div></section>
<section data-pdf-bookmark="Code Magnets Solution" data-type="sect1" class="preface"><div class="preface" id="code_magnets_solution_4">
<h1 class="calibre25">Code Magnets Solution</h1>
<figure class="informal"><div class="figure">
<img alt="image" src="assets/f0204-01.png" class="calibre4"/>
<h6 class="calibre5"/>
</div></figure>
<p class="calibre7"/>
</div></section>
</div></section></body></html>