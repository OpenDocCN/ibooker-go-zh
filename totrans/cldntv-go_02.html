<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. What Is a “Cloud Native” Application?"><div class="chapter" id="chapter_1">&#13;
<h1><span class="label">Chapter 1. </span>What Is a “Cloud Native” Application?</h1>&#13;
&#13;
<blockquote>&#13;
<p>The most dangerous phrase in the language is, “We’ve always done it this way.”<sup><a data-type="noteref" id="idm45983644896536-marker" href="ch01.xhtml#idm45983644896536">1</a></sup></p>&#13;
<p data-type="attribution">Grace Hopper, <cite>Computerworld (January 1976)</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>If you’re reading this book, then you’ve no doubt at least heard the term<a data-type="indexterm" data-primary="cloud native" data-secondary="definition of" id="ch01_term1"/> <em>cloud native</em> before. More likely, you’ve probably seen some of the many, many articles written by vendors bubbling over with breathless adoration and dollar signs in their eyes. If this is the bulk of your experience with the term so far, then you can be forgiven for thinking the term to be ambiguous and buzzwordy, just another of a series of markety expressions that might have started as something useful but have since been taken over by people trying to sell you something. See also: Agile, DevOps.</p>&#13;
&#13;
<p>For similar reasons, a web search for “cloud native definition” might lead you to think that all an application needs to be cloud native is to be written in the “right” language<sup><a data-type="noteref" id="idm45983644890840-marker" href="ch01.xhtml#idm45983644890840">2</a></sup> or framework, or to use the “right” technology. Certainly, your choice of language can make your life significantly easier or harder, but it’s neither necessary nor sufficient for making an application cloud native.</p>&#13;
&#13;
<p>Is cloud native, then, just a matter of <em>where</em> an application runs? The term <em>cloud native</em> certainly suggests that. All you’d need to do is pour your kludgy<sup><a data-type="noteref" id="idm45983645042344-marker" href="ch01.xhtml#idm45983645042344">3</a></sup> old application into a container and run it in Kubernetes, and you’re cloud native now, right? Nope. All you’ve done is make your application harder to deploy and harder to manage.<sup><a data-type="noteref" id="idm45983645041352-marker" href="ch01.xhtml#idm45983645041352">4</a></sup> A kludgy application in Kubernetes is still kludgy.</p>&#13;
&#13;
<p>So, what <em>is</em> a cloud native application? In this chapter, we’ll answer exactly that. First, we’ll examine the history of computing service paradigms up to (and especially) the present, and discuss how the relentless pressure to scale drove (and continues to drive) the development and adoption of technologies that provide high levels of dependability at often vast scales. Finally, we’ll identify the specific attributes associated with such an application<a data-type="indexterm" data-primary="cloud native" data-secondary="definition of" data-startref="ch01_term1" id="idm45983645039256"/>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="The Story So Far"><div class="sect1" id="idm45983645037752">&#13;
<h1>The Story So Far</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="networked applications, history of" id="ch01_term2"/>The story of networked applications is the story of the pressure to scale.</p>&#13;
&#13;
<p>The late 1950s saw the introduction of the mainframe computer. At the time, every program and piece of data was stored in a single giant machine that users could access by means of dumb terminals with no computational ability of their own. All the logic and all the data all lived together as one big happy monolith. It was a &#13;
<span class="keep-together">simpler</span> time.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="multitiered architecture" id="idm45983645033416"/>Everything changed in the 1980s with the arrival of inexpensive network-connected PCs. Unlike dumb terminals, PCs were able to do some computation of their own, making it possible to offload some of an application’s logic onto them. This new &#13;
<span class="keep-together">multitiered</span> architecture—which separated presentation logic, business logic, and data (<a data-type="xref" href="#img_ch01_3_tiered_architecture">Figure 1-1</a>)—made it possible, for the first time, for the components of a networked application to be modified or replaced independent of the others.</p>&#13;
&#13;
<figure><div id="img_ch01_3_tiered_architecture" class="figure">&#13;
<img src="Images/cngo_0101.png" alt="cngo 0101" width="1196" height="455"/>&#13;
<h6><span class="label">Figure 1-1. </span>A traditional three-tiered architecture, with clearly defined presentation, business logic, and data components</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="indexterm" data-primary="dot com gold rush" id="idm45983645028184"/><a data-type="indexterm" data-primary="software as a service (SAAS)" id="idm45983645027480"/><a data-type="indexterm" data-primary="SAAS (software as a service)" id="idm45983645026792"/>In the 1990s, the popularization of the World Wide Web and the subsequent “dot-com” gold rush introduced the world to software as a service (SaaS). Entire industries were built on the SaaS model, driving the development of more complex and resource-hungry applications, which were in turn harder to develop, maintain, and deploy. Suddenly the classic multitiered architecture wasn’t enough anymore. &#13;
<span class="keep-together">In response,</span> business logic started to get decomposed into subcomponents that &#13;
<span class="keep-together">could be developed,</span> maintained, and deployed independently, ushering in the age of &#13;
<span class="keep-together">microservices</span>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Amazon" id="idm45983645063480"/><a data-type="indexterm" data-primary="Amazon EC2 (Elastic Computer Cloud)" id="idm45983645062776"/><a data-type="indexterm" data-primary="Amazon Elastic Computer Cloud (EC2)" id="idm45983645062088"/><a data-type="indexterm" data-primary="Infrastructure as a service" data-see="IaaS" id="idm45983645061400"/><a data-type="indexterm" data-primary="IaaS" id="idm45983645060440"/><a data-type="indexterm" data-primary="Cloud Computing" id="idm45983645059768"/>In 2006, Amazon launched Amazon Web Services (AWS), which included the Elastic Compute Cloud (EC2) service. Although AWS wasn’t the <em>first</em> infrastructure as a service (IaaS) offering, it revolutionized the on-demand availability of data storage and computing resources, bringing Cloud Computing—and the ability to quickly scale—to the masses, catalyzing a massive migration of resources into “the cloud.”</p>&#13;
&#13;
<p>Unfortunately, organizations soon learned that life at scale isn’t easy. Bad things happen, and when you’re working with hundreds or thousands of resources (or more!), bad things happen <em>a lot</em>. Traffic will wildly spike up or down, essential hardware will fail, upstream dependencies will become suddenly and inexplicably inaccessible. Even if nothing goes wrong for a while, you still have to deploy and manage all of these resources. At this scale, it’s impossible (or at least wildly impractical) for humans to keep up with all of these issues manually.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_ch01_dependencies">&#13;
<h5>Upstream and Downstream Dependencies</h5>&#13;
<p><a data-type="indexterm" data-primary="upstream dependencies" data-seealso="transitive upstream dependencies" id="idm45983645054904"/><a data-type="indexterm" data-primary="downstream dependencies" data-seealso="transitive downstream dependencies" id="idm45983645053864"/><a data-type="indexterm" data-primary="dependency relationship" id="idm45983645052904"/>In this book we’ll sometimes use the terms <em>upstream dependency</em> and <em>downstream dependency</em> to describe the relative positions of two resources in a dependency relationship. There’s no real consensus in the industry around the directionality of these terms, so this book will use them as follows:</p>&#13;
&#13;
<p>Imagine that we have three services: A, B, and C, as shown in the following figure:</p>&#13;
&#13;
<figure><div class="figure">&#13;
<img src="Images/cngo_01in01.png" alt="cngo 01in01" width="619" height="279"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>In this scenario, Service A makes requests to (and therefore depends on) Service B, which in turn depends on Service C.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="transitive downstream dependencies" id="idm45983645048232"/>Because Service B depends on Service C, we can say that Service C is a <em>downstream dependency</em> of Service B. By extension, because Service A depends on Service B which depends on Service C, Service C is also a <em>transitive downstream dependency</em> of &#13;
<span class="keep-together">Service A.</span></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="transitive upstream dependencies" id="idm45983645045432"/>Inversely, because Service C is depended upon by Service B, we can say that Service B is an <em>upstream dependency</em> of Service C, and that Service A is a <em>transitive upstream dependency</em> of Service A.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="What Is Cloud Native?"><div class="sect1" id="idm45983644922696">&#13;
<h1>What Is Cloud Native?</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="cloud native" data-secondary="definition of" id="idm45983644921224"/>Fundamentally, a truly cloud native application incorporates everything we’ve learned about running networked applications at scale over the past 60 years. They are scalable in the face of wildly changing load, resilient in the face of environmental uncertainty, and manageable in the face of ever-changing requirements. In other words, a cloud native application is built for life in a cruel, uncertain universe<a data-type="indexterm" data-primary="networked applications, history of" data-startref="ch01_term2" id="idm45983644919688"/>.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="Cloud Native Computing Foundation" id="idm45983644918360"/><a data-type="indexterm" data-primary="Linux Foundation" id="idm45983644917528"/>But how do we <em>define</em> the term <em>cloud native</em>? Fortunately for all of us,<sup><a data-type="noteref" id="idm45983644915864-marker" href="ch01.xhtml#idm45983644915864">5</a></sup> we don’t have to. The <a href="https://oreil.ly/621yd">Cloud Native Computing Foundation</a>—a subfoundation of the renowned Linux Foundation, and something of an acknowledged authority on the subject—has already done it for us:</p>&#13;
<blockquote>&#13;
<p>Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds….</p>&#13;
&#13;
<p>These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.<sup><a data-type="noteref" id="idm45983644912856-marker" href="ch01.xhtml#idm45983644912856">6</a></sup></p>&#13;
<p data-type="attribution">Cloud Native Computing Foundation, <cite>CNCF Cloud Native Definition v1.0</cite></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-type="indexterm" data-primary="cloud native" data-secondary="attributes" id="idm45983644909400"/>By this definition, cloud native applications are more than just applications that happen to live in a cloud. They’re also <em>scalable</em>, <em>loosely coupled</em>, <em>resilient</em>, <em>manageable</em>, and <em>observable</em>. Taken together, these “cloud native attributes” can be said to constitute the foundation of what it means for a system to be cloud native.</p>&#13;
&#13;
<p>As it turns out, each of those words has a pretty specific meaning of its own, so let’s take a look.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Scalability"><div class="sect2" id="section_ch01_scalability">&#13;
<h2>Scalability</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="scalability" data-secondary="definition of" data-seealso="horizontal scaling, vertical scaling" id="ch01_term3"/>In the context of cloud computing, <em>scalability</em> can be defined as the ability of a system to continue to behave as expected in the face of significant upward or downward changes in demand. A system can be considered to be scalable if it doesn’t need to be refactored to perform its intended function during or after a steep increase in demand.</p>&#13;
&#13;
<p>Because unscalable services can seem to function perfectly well under initial conditions, scalability isn’t always a primary consideration during service design. While this might be fine in the short term, services that aren’t capable of growing much beyond their original expectations also have a limited lifetime value. What’s more, it’s often fiendishly difficult to refactor a service for scalability, so building with it in mind can save both time and money in the long run.</p>&#13;
&#13;
<p>There are two different ways that a service can be scaled, each with its own associated pros and cons:</p>&#13;
<dl>&#13;
<dt><a data-type="indexterm" data-primary="vertical scaling" id="idm45983644874712"/>Vertical scaling</dt>&#13;
<dd>&#13;
<p>A system can be <em>vertically scaled</em> (or <em>scaled up</em>) by upsizing (or downsizing) the hardware resources that are already allocated to it. For example, by adding memory or CPU to a database that’s running on a dedicated computing instance. Vertical scaling has the benefit of being technically relatively straightforward, but any given instance can only be upsized so much.</p>&#13;
</dd>&#13;
<dt><a data-type="indexterm" data-primary="horizontally scaling" id="idm45983644871496"/><a data-type="indexterm" data-primary="container orchestration system" data-seealso="Kubernetes" id="idm45983644870792"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="applications for" id="idm45983644869784"/>Horizontal scaling</dt>&#13;
<dd>&#13;
<p>A system can be <em>horizontally scaled</em> (or <em>scaled out</em>) by adding (or removing) service instances. For example, this can be done by increasing the number of service nodes behind a load balancer or containers in Kubernetes, or another container orchestration system. This strategy has a number of advantages, including redundancy and freedom from the limits of available instance sizes. However, more replicas mean greater design and management complexity, and not all services can be horizontally scaled.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Given that there are two ways of scaling a service—up or out—does that mean that any service whose hardware can be upscaled (and is capable of taking advantage of increased hardware resources) is “scalable”? If you want to split hairs, then sure, to a point. But how scalable is it? Vertical scaling is inherently limited by the size of available computing resources, so a service that can only be scaled up isn’t very scalable at all. If you want to be able to scale by ten times, or a hundred, or a thousand, your service really has to be horizontally scalable.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="application state" id="idm45983644865064"/>So what’s the difference between a service that’s horizontally scalable and one that’s not? It all boils down to one thing: state. A service that doesn’t maintain any application state—or which has been very carefully designed to distribute its state between service replicas—will be relatively straightforward to scale out. For any other application, it will be hard. It’s that simple.<a data-type="indexterm" data-primary="scalability" data-startref="ch01_term3" id="idm45983644863816"/></p>&#13;
&#13;
<p>The concepts of scalability, state, and redundancy will be discussed in much more depth in <a data-type="xref" href="ch07.xhtml#chapter_7">Chapter 7</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Loose Coupling"><div class="sect2" id="section_ch01_loose_coupling">&#13;
<h2>Loose Coupling</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="loose coupling" data-secondary="definition of" id="ch01_term4"/><em>Loose coupling</em> is a system property and design strategy in which a system’s components have minimal knowledge of any other components. Two systems can be said to be <em>loosely coupled</em> when changes to one component generally don’t require changes to the other.</p>&#13;
&#13;
<p>For example, web servers and web browsers can be considered to be loosely coupled: servers can be updated or even completely replaced without affecting our browsers at all. In their case, this is possible because standard web servers have agreed that they would communicate using a set of standard protocols.<sup><a data-type="noteref" id="idm45983644856888-marker" href="ch01.xhtml#idm45983644856888">7</a></sup> In other words, they provide a <em>service contract</em>. Imagine the chaos if all the world’s web browsers had to be updated each time NGINX or httpd had a new version!<a data-type="indexterm" data-primary="service contract" id="idm45983644855560"/><sup><a data-type="noteref" id="idm45983645023000-marker" href="ch01.xhtml#idm45983645023000">8</a></sup></p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="microservices architecture" id="idm45983645021848"/>It could be said that “loose coupling” is just a restatement of the whole point of microservice architectures: to partition components so that changes in one don’t necessarily affect another. This might even be true. However, this principle is often neglected, and bears repeating. The benefits of loose coupling—and the consequences if it’s neglected—cannot be understated. It’s very easy to create a “worst of all worlds” system that pairs the management and complexity overhead of having multiple services with the dependencies and entanglements of a monolithic system: the dreaded <em>distributed monolith</em>.<a data-type="indexterm" data-primary="distributed monolith" id="idm45983645019944"/></p>&#13;
&#13;
<p>Unfortunately, there’s no magic technology or protocol that can keep your services from being tightly coupled. Any data exchange format can be misused. There are, however, several that help, and—when applied with practices like declarative APIs and good versioning practices—can be used to create services that are both loosely-coupled <em>and</em> modifiable.<a data-type="indexterm" data-primary="loose coupling" data-secondary="definition of" data-startref="ch01_term4" id="idm45983645018056"/></p>&#13;
&#13;
<p>These technologies and practices will be discussed and demonstrated in detail in <a data-type="xref" href="ch08.xhtml#chapter_8">Chapter 8</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Resilience"><div class="sect2" id="section_ch01_resilience">&#13;
<h2>Resilience</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="fault tolerance" id="idm45983645013720"/><a data-type="indexterm" data-primary="resilience" data-secondary="definition of" id="ch01_term5"/><em>Resilience</em> (roughly synonymous with <em>fault tolerance</em>) is a measure of how well a system withstands and recovers from errors and faults. A system can be considered &#13;
<span class="keep-together"><em>resilient</em></span> if it can continue operating correctly—possibly at a reduced level—rather than failing completely when some part of the system fails.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="system, definition of" id="idm45983645009608"/>When we discuss resilience (and the other the other “cloud native attributes” as well, but especially when we discuss resilience) we use the word “system” quite a lot. A <em>system</em>, depending on how it’s used, can refer to anything from a complex web of interconnected services (such as an entire distributed application), to a collection of closely related components (such as the replicas of a single function or service instance), or a single process running on a single machine. Every system is composed of several subsystems, which in turn are composed of sub-subsystems, which are themselves composed of sub-sub-subsystems. It’s turtles all the way down.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="faults" id="idm45983645007416"/><a data-type="indexterm" data-primary="bugs" data-seealso="faults, memory leaks" id="idm45983645006488"/><a data-type="indexterm" data-primary="error, definition of" id="idm45983645005544"/><a data-type="indexterm" data-primary="failures" data-secondary="definition of" id="idm45983645004872"/>In the language of systems engineering, any system can contain defects, or <em>faults</em>, which we lovingly refer to as <em>bugs</em> in the software world. As we all know too well, under certain conditions, any fault can give rise to an <em>error</em>, which is the name we give to any discrepancy between a system’s intended behavior and its actual behavior. Errors have the potential to cause a system to fail to perform its required function: a <em>failure</em>. It doesn’t stop there though: a failure in a subsystem or component becomes a fault in the larger system; any fault that isn’t properly contained has the potential to cascade upwards until it causes a total system failure.</p>&#13;
&#13;
<p>In an ideal world, every system would be carefully designed to prevent faults from ever occurring, but this is an unrealistic goal. You can’t prevent every possible fault, and it’s wasteful and unproductive to try. However, by assuming that all of a system’s components are certain to fail—which they are—and designing them to respond to potential faults and limit the effects of failures, you can produce a system that’s functionally healthy even when some of its components are not.</p>&#13;
&#13;
<p>There are many ways of designing a system for resiliency. Deploying redundant components is perhaps the most common approach, but that also assumes that a fault won’t affect all components of the same type. Circuit breakers and retry logic can be included to prevent failures from propagating between components. Faulty components can even be reaped—or can intentionally fail—to benefit the larger system.</p>&#13;
&#13;
<p>We’ll discuss all of these approaches (and more) in much more depth in <a data-type="xref" href="ch09.xhtml#chapter_9">Chapter 9</a>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983645187384">&#13;
<h5>Resilience Is Not Reliability</h5>&#13;
<p><a data-type="indexterm" data-primary="resilience" data-secondary="reliability and" id="idm45983645186120"/>The terms <em>resilience</em> and <em>reliability</em> describe closely related concepts, and are often confused. But, as we’ll discuss in <a data-type="xref" href="ch09.xhtml#chapter_9">Chapter 9</a>, they aren’t quite the same thing:<sup><a data-type="noteref" id="idm45983645183224-marker" href="ch01.xhtml#idm45983645183224">9</a></sup></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The resilience of a system is the degree to which it can continue to operate correctly in the face of errors and faults. Resilience, along with the other four cloud native properties, is just one factor that contributes to reliability.</p>&#13;
</li>&#13;
<li>&#13;
<p>The reliability of a system is its ability to behave as expected for a given time interval. Reliability, in conjunction with attributes like availability and maintainability, contributes to a system’s overall dependability.<a data-type="indexterm" data-primary="resilience" data-secondary="definition of" data-startref="ch01_term5" id="idm45983645178904"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Manageability"><div class="sect2" id="section_ch01_manageability">&#13;
<h2>Manageability</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="manageability" data-secondary="definition of" id="idm45983645175048"/>A system’s <em>manageability</em> is the ease (or lack thereof) with which its behavior can be modified to keep it secure, running smoothly, and compliant with changing requirements. A system can be considered <em>manageable</em> if it’s possible to sufficiently alter its behavior without having to alter its code.</p>&#13;
&#13;
<p>As a system property, manageability gets a lot less attention than some of the more attention-grabbing attributes like scalability or observability. It’s every bit as critical, though, particularly in complex, distributed systems.</p>&#13;
&#13;
<p>For example, imagine a hypothetical system that includes a service and a database, and that the service refers to the database by a URL. What if you needed to update that service to refer to another database? If the URL was hardcoded you might have to update the code and redeploy, which, depending on the system, might be awkward for its own reasons. Of course, you could update the DNS record to point to the new location, but what if you needed to redeploy a development version of the service, with its own development database?</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="environment variable" data-secondary="example of" id="idm45983645170888"/>A manageable system might, for example, represent this value as an easily modified environment variable; if the service that uses it is deployed in Kubernetes, adjustments to its behavior might be a matter of updating a value in a ConfigMap. A more complex system might even provide a declarative API that a developer can use to tell the system what behavior she expects. There’s no single right answer.<sup><a data-type="noteref" id="idm45983645169368-marker" href="ch01.xhtml#idm45983645169368">10</a></sup></p>&#13;
&#13;
<p>Manageability isn’t limited to configuration changes. It encompasses all possible dimensions of a system’s behavior, be it the ability to activate feature flags, or rotate credentials or TLS certificates, or even (and perhaps especially) deploy or upgrade (or downgrade) system components.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="adaptability" id="idm45983645167864"/>Manageable systems are designed for adaptability, and can be readily adjusted to accommodate changing functional, environmental, or security requirements. Unmanageable systems, on the other hand, tend to be far more brittle, frequently requiring ad hoc—often manual—changes. The overhead involved in managing such systems places fundamental limits on their scalability, availability, and reliability.</p>&#13;
&#13;
<p>The concept of manageability—and some preferred practices for implementing them in Go—will be discussed in much more depth in <a data-type="xref" href="ch10.xhtml#chapter_10">Chapter 10</a>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45983645165128">&#13;
<h5>Manageability Is Not Maintainability</h5>&#13;
<p><a data-type="indexterm" data-primary="manageability" data-secondary="maintainability and" id="idm45983645163912"/>It can be said that manageability and maintainability have some “mission overlap” in that they’re both concerned with the ease with which a system can be modified,<sup><a data-type="noteref" id="idm45983645162616-marker" href="ch01.xhtml#idm45983645162616">11</a></sup> but they’re actually quite different:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Manageability describes the ease with which changes can be made to the behavior of a running system, up to and including deploying (and redeploying) components of that system. It’s how easy it is to make changes <em>from the outside</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p><a data-type="indexterm" data-primary="maintainability" id="idm45983645103208"/>Maintainability describes the ease with which changes can be made to a system’s underlying functionality, most often its code. It’s how easy it is to make changes <em>from the inside</em>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect2" data-pdf-bookmark="Observability"><div class="sect2" id="idm45983645176712">&#13;
<h2>Observability</h2>&#13;
&#13;
<p><a data-type="indexterm" data-primary="observability" data-secondary="definition of" id="ch01_term7"/>The <em>observability</em> of a system is a measure of how well its internal states can be inferred from knowledge of its external outputs. A system can be considered <em>observable</em> when it’s possible to quickly and consistently ask novel questions about it with minimal prior knowledge, and without having to reinstrument or build new code.</p>&#13;
&#13;
<p>On its face, this might sound simple enough: just sprinkle in some logging and slap up a couple of dashboards, and your system is observable, right? Almost certainly not. Not with modern, complex systems in which almost any problem is the manifestation of a web of multiple things going wrong simultaneously. The Age of the LAMP Stack is over; things are harder now.</p>&#13;
&#13;
<p>This isn’t to say that metrics, logging, and tracing aren’t important. On the contrary: they represent the building blocks of observability. But their mere existence is not enough: data is not information. They need to be used the right way. They need to be rich. Together, they need to be able to answer questions that you’ve never even thought to ask before.</p>&#13;
&#13;
<p>The ability to detect and debug problems is a fundamental requirement for the maintenance and evolution of a robust system. But in a distributed system it’s often hard enough just figuring out <em>where</em> a problem is. Complex systems are just too…<em>complex</em>. The number of possible failure states for any given system is proportional to the product of the number of possible partial and complete failure states of each of its components, and it’s impossible to predict all of them. The traditional approach of focusing attention on the things we expect to fail simply isn’t enough.</p>&#13;
&#13;
<p>Emerging practices in observability can be seen as the evolution of monitoring. Years of experience with designing, building, and maintaining complex systems have taught us that traditional methods of instrumentation—including but not limited to dashboards, unstructured logs, or alerting on various “known unknowns”—just aren’t up to the challenges presented by modern distributed systems.</p>&#13;
&#13;
<p>Observability is a complex and subtle subject, but, fundamentally, it comes down to this: instrument your systems richly enough and under real enough scenarios so that, in the future, you can answer questions that you haven’t thought to ask yet.<a data-type="indexterm" data-primary="observability" data-secondary="definition of" data-startref="ch01_term7" id="idm45983645092536"/></p>&#13;
&#13;
<p>The concept of observability—and some suggestions for implementing it—will be discussed in much more depth in <a data-type="xref" href="ch11.xhtml#chapter_11">Chapter 11</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Why Is Cloud Native a Thing?"><div class="sect1" id="idm45983644922072">&#13;
<h1>Why Is Cloud Native a Thing?</h1>&#13;
&#13;
<p><a data-type="indexterm" data-primary="cloud native" data-secondary="evolution of" id="ch01_term8"/>The move towards “cloud native” is an example of architectural and technical adaptation, driven by environmental pressure and selection. It’s evolution—survival of the fittest. Bear with me here; I’m a biologist by training.</p>&#13;
&#13;
<p>Eons ago, in the Dawn of Time,<sup><a data-type="noteref" id="idm45983645086552-marker" href="ch01.xhtml#idm45983645086552">12</a></sup> applications would be built and deployed (generally by hand) to one or a small number of servers, where they were carefully maintained and nurtured. If they got sick, they were lovingly nursed back to health. If a service went down, you could often fix it with a restart. Observability was shelling into a server to run <code>top</code> and review logs. It was a simpler time.</p>&#13;
&#13;
<p>In 1997, only 11% of people in industrialized countries, and 2% worldwide, were regular internet users. The subsequent years saw exponential growth in internet access and adoption, however, and by 2017 that number had exploded to 81% in industrialized countries and 48% worldwide<sup><a data-type="noteref" id="idm45983645084440-marker" href="ch01.xhtml#idm45983645084440">13</a></sup>—and continues to grow.</p>&#13;
&#13;
<p>All of those users—and their money—applied stress to services, generating significant incentive to scale. What’s more, as user sophistication and dependency on web services grew, so did expectations that their favorite web applications would be both feature-rich and always available.</p>&#13;
&#13;
<p>The result was, and is, a significant evolutionary pressure towards scale, complexity, and dependability. These three attributes don’t play well together, though, and the traditional approaches simply couldn’t, and can’t, keep up. New techniques and practices had to be invented.</p>&#13;
&#13;
<p><a data-type="indexterm" data-primary="IaaS" id="idm45983645081368"/><a data-type="indexterm" data-primary="public clouds" id="idm45983645080664"/>Fortunately, the introduction of public clouds and IaaS made it relatively straightforward to scale infrastructure out. Shortcomings with dependability could often be compensated for with sheer numbers. But that introduced new problems. How do you maintain a hundred servers? A thousand? Ten thousand? How do you install your application onto them, or upgrade it? How do you debug it when it misbehaves? How do you even know it’s healthy? Problems that are merely annoying at small scale tend to become very hard at large scale.</p>&#13;
&#13;
<p>Cloud native is a thing because scale is the cause of (and solution to) all our problems. It’s not magic. It’s not special. All fancy language aside, cloud native techniques and technologies exist for no other reasons than to make it possible to leverage the benefits of a “cloud” (quantity) while compensating for its downsides (lack of dependability).<a data-type="indexterm" data-primary="cloud native" data-secondary="evolution of" data-startref="ch01_term8" id="idm45983645078552"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45983645077176">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we talked a fair amount about the history of computing, and how what we now call “cloud native” isn’t a new phenomenon so much as the inevitable outcome of a virtuous cycle of technological demand driving innovation driving more demand.</p>&#13;
&#13;
<p>Ultimately, though, all of those fancy words distill down to a single point: today’s applications have to dependably serve a lot of people. The techniques and technologies that we call “cloud native” represent the best current practices for building a service that’s scalable, adaptable, and resilient enough to do that.</p>&#13;
&#13;
<p>But what does all of this to do with Go? As it turns out, cloud native infrastructure requires cloud native tools. In <a data-type="xref" href="ch02.xhtml#chapter_2">Chapter 2</a>, we’ll start to talk about what that means, exactly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45983644896536"><sup><a href="ch01.xhtml#idm45983644896536-marker">1</a></sup> Surden, Esther. “Privacy Laws May Usher in Defensive DP: Hopper.” <em>Computerworld</em>, 26 Jan. 1976, p. 9.</p><p data-type="footnote" id="idm45983644890840"><sup><a href="ch01.xhtml#idm45983644890840-marker">2</a></sup> Which is Go. Don’t get me wrong—this is still a Go book after all.</p><p data-type="footnote" id="idm45983645042344"><sup><a href="ch01.xhtml#idm45983645042344-marker">3</a></sup> A “kludge” is “an awkward or inelegant solution.” It’s a fascinating word with a fascinating history.</p><p data-type="footnote" id="idm45983645041352"><sup><a href="ch01.xhtml#idm45983645041352-marker">4</a></sup> Have you ever wondered why so many Kubernetes migrations fail?</p><p data-type="footnote" id="idm45983644915864"><sup><a href="ch01.xhtml#idm45983644915864-marker">5</a></sup> Especially for me. I get to write this cool book.</p><p data-type="footnote" id="idm45983644912856"><sup><a href="ch01.xhtml#idm45983644912856-marker">6</a></sup> Cloud Native Computing Foundation. “CNCF Cloud Native Definition v1.0,” GitHub, 7 Dec. 2020. <a href="https://oreil.ly/KJuTr"><em class="hyperlink">https://oreil.ly/KJuTr</em></a>.</p><p data-type="footnote" id="idm45983644856888"><sup><a href="ch01.xhtml#idm45983644856888-marker">7</a></sup> Those of us who remember the Browser Wars of the 1990s will recall that this wasn’t always strictly true.</p><p data-type="footnote" id="idm45983645023000"><sup><a href="ch01.xhtml#idm45983645023000-marker">8</a></sup> Or if every website required a different browser. That would stink, <em>wouldn’t it?</em></p><p data-type="footnote" id="idm45983645183224"><sup><a href="ch01.xhtml#idm45983645183224-marker">9</a></sup> If you’re interested in a complete academic treatment, I highly recommend <a href="https://oreil.ly/80wGT"><em>Reliability and Availability Engineering</em></a> by Kishor S. Trivedi and Andrea Bobbio.</p><p data-type="footnote" id="idm45983645169368"><sup><a href="ch01.xhtml#idm45983645169368-marker">10</a></sup> There are some wrong ones though.</p><p data-type="footnote" id="idm45983645162616"><sup><a href="ch01.xhtml#idm45983645162616-marker">11</a></sup> Plus, they both start with <em>M</em>. Super confusing.</p><p data-type="footnote" id="idm45983645086552"><sup><a href="ch01.xhtml#idm45983645086552-marker">12</a></sup> That time was the 1990s.</p><p data-type="footnote" id="idm45983645084440"><sup><a href="ch01.xhtml#idm45983645084440-marker">13</a></sup> International Telecommunication Union (ITU). “Internet users per 100 inhabitants 1997 to 2007” and “Internet users per 100 inhabitants 2005 to 2017.” <em>ICT Data and Statistics (IDS)</em>.</p></div></div></section></div></body></html>