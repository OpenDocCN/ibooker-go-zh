# 第三章：复合类型

在上一章中，你已经了解了字面量和预声明变量类型：数字、布尔值和字符串。在本章中，你将了解 Go 中的复合类型、支持它们的内置函数以及与它们一起工作的最佳实践。

# 数组——过于严格，无法直接使用

和大多数编程语言一样，Go 也有数组。然而，在 Go 中很少直接使用数组。稍后你将了解原因，但首先让我们快速了解数组声明语法和使用。

数组中的所有元素必须是指定的类型。有几种声明样式。在第一种样式中，你指定数组的大小和数组元素的类型：

```go
var x [3]int
```

这将创建一个包含三个 `int` 类型元素的数组。因为没有指定初始值，所有元素（`x[0]`、`x[1]` 和 `x[2]`）都会初始化为 `int` 类型的零值，当然是 0。如果数组有初始值，可以使用*数组字面量*指定它们：

```go
var x = [3]int{10, 20, 30}
```

如果你有一个*稀疏数组*（大部分元素设置为零值的数组），你可以在数组字面量中仅指定非零值的索引：

```go
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```

这将创建一个包含以下值的 12 个 `int` 类型数组：[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。

当使用数组字面量初始化数组时，可以用 `...` 替换指定数组中元素数量的数字：

```go
var x = [...]int{10, 20, 30}
```

你可以使用 `==` 和 `!=` 来比较两个数组。如果它们长度相同并且包含相等的值，则它们相等：

```go
var x = [...]int{1, 2, 3}
var y = [3]int{1, 2, 3}
fmt.Println(x == y) // prints true
```

Go 只有一维数组，但你可以模拟多维数组：

```go
var x [2][3]int
```

这声明了 `x` 为长度为 2 的数组，其类型是长度为 3 的 `int` 数组。这听起来有些迂腐，但有些语言有真正的矩阵支持，比如 Fortran 或 Julia；而 Go 不是其中之一。

和大多数语言一样，Go 中的数组是通过方括号语法进行读写的：

```go
x[0] = 10
fmt.Println(x[2])
```

你不能读取或写入数组的末尾或使用负索引。如果你使用常量或字面量索引这样做，会导致编译时错误。使用变量索引进行越界读取或写入会在运行时编译，但会失败并产生*panic*（你将在“panic and recover”中了解更多关于 panic 的信息）。

最后，内置函数 `len` 接受一个数组并返回其长度：

```go
fmt.Println(len(x))
```

之前我说过，在 Go 中很少显式使用数组。这是因为它们有一个不寻常的限制：Go 认为数组的*大小*是数组的*类型*的一部分。这意味着声明为 `[3]int` 的数组与声明为 `[4]int` 的数组是不同的类型。这也意味着你不能使用变量指定数组的大小，因为类型必须在编译时而不是运行时解析。

此外，*不能使用类型转换直接将不同大小的数组转换为相同类型*。因为不能将不同大小的数组相互转换，所以无法编写处理任何大小数组的函数，也无法将不同大小的数组分配给同一个变量。

###### 注意

当我讨论内存布局时，您将了解数组在背后的工作原理，详见第六章。

因此，请不要在不提前知道所需长度的情况下使用数组。例如，标准库中的一些加密函数返回数组，因为校验和的大小是算法的一部分。这是例外而不是规则。

这引出了一个问题：为什么语言中会有这样一种有限的功能？Go 中存在数组的主要原因是为*切片*提供后备存储，这是 Go 中最有用的功能之一。

# 切片

大多数情况下，当您需要一个保存数值序列的数据结构时，应该使用切片。切片如此有用的原因在于您可以根据需要扩展切片的长度。这是因为切片的长度*不是*其类型的一部分。这消除了数组的最大限制，并允许您编写处理任何大小切片的单个函数（我将在第五章中讨论函数编写）。在介绍了在 Go 中使用切片的基础知识后，我将讨论最佳使用方法。

使用切片看起来很像使用数组，但存在细微差别。首先要注意的是，在声明时不需要指定切片的大小：

```go
var x = []int{10, 20, 30}
```

###### 提示

使用`[...]`创建数组。使用`[]`创建切片。

这使用*切片字面量*创建了三个`int`的切片。与数组一样，您还可以仅指定切片字面量中非零值的索引：

```go
var x = []int{1, 5: 4, 6, 10: 100, 15}
```

这将创建一个包含以下值的 12 个`int`的切片：[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。

您可以模拟多维切片并创建切片的切片：

```go
var x [][]int
```

您可以使用括号语法读取和写入切片，与数组一样，您不能读取或写入超出末尾或使用负索引：

```go
x[0] = 10
fmt.Println(x[2])
```

到目前为止，切片看起来与数组相同。当您尝试声明不使用字面量的切片时，您开始看到数组和切片之间的区别：

```go
var x []int
```

这将创建一个`int`切片。由于未分配任何值，`x`被分配了切片的零值，这是您之前未见过的：`nil`。我将在第六章中更多地讨论`nil`，但它与其他语言中的`null`略有不同。在 Go 中，`nil`是一个表示某些类型缺少值的标识符。与前一章中看到的无类型数值常量一样，`nil`没有类型，因此可以将其赋值或与不同类型的值进行比较。`nil`切片不包含任何内容。

切片是你见过的第一个不可*比较*的类型。使用`==`来比较两个切片是否相同或者使用`!=`来比较它们是否不同是编译时错误。你只能将一个切片与`nil`使用`==`比较：

```go
fmt.Println(x == nil) // prints true
```

自 Go 1.21 以来，标准库中的`slices`包包含了两个比较切片的函数。`slices.Equal`函数接受两个切片，并在这两个切片长度相同且所有元素相等时返回`true`。它要求切片的元素是可比较的。另一个函数`slice.EqualFunc`允许你传递一个函数来确定相等性，并且不要求切片元素是可比较的。你将会在“传递函数作为参数”章节学习如何将函数传递给函数。`slices`包中的其他函数在“向标准库添加泛型”章节中有详细介绍。

```go
x := []int{1, 2, 3, 4, 5}
y := []int{1, 2, 3, 4, 5}
z := []int{1, 2, 3, 4, 5, 6}
s := []string{"a", "b", "c"}
fmt.Println(slices.Equal(x, y)) // prints true
fmt.Println(slices.Equal(x, z)) // prints false
fmt.Println(slices.Equal(x, s)) // does not compile
```

###### 警告

`reflect`包中包含一个名为`DeepEqual`的函数，可以比较几乎任何东西，包括切片。这是一个遗留函数，主要用于测试。在包含`slices.Equal`和`slices.EqualFunc`之前，通常使用`reflect.DeepEqual`来比较切片。不要在新代码中使用它，因为它比`slices`包中的函数更慢，也不够安全。

## len

Go 语言提供了几个内置函数来处理切片。当你查看数组时，已经看到了内置的`len`函数。它对切片也适用。将一个`nil`切片传递给`len`将返回 0。

###### 注意

内置函数`len`是 Go 语言的一部分，因为它可以做一些你自己编写的函数无法做到的事情。你已经看到`len`的参数可以是任何类型的数组或切片。很快你会看到它也适用于字符串和映射。在“Channels”章节中，你将看到它与通道一起使用。试图将任何其他类型的变量传递给`len`会导致编译时错误。正如你将在第五章中看到的，Go 语言不允许开发者编写一个接受任何字符串、数组、切片、通道或映射的函数，但却拒绝其他类型。

## append

内置的`append`函数用于增长切片：

```go
var x []int
x = append(x, 10) // assign result to the variable that's passed in
```

`append`函数至少接受两个参数，一个任意类型的切片和一个该类型的值。它返回一个相同类型的切片，并将其赋给传递给`append`的变量。在这个示例中，你正在向一个`nil`切片追加，但你也可以向已有元素的切片追加：

```go
var x = []int{1, 2, 3}
x = append(x, 4)
```

你可以一次追加多个值：

```go
x = append(x, 5, 6, 7)
```

通过使用`...`操作符将源切片扩展为单独的值，可以将一个切片追加到另一个切片（你将在“可变输入参数和切片”中学到更多关于`...`操作符的知识）：

```go
y := []int{20, 30, 40}
x = append(x, y...)
```

如果忘记为`append`返回的值分配值，这将是编译时错误。你可能会想知道为什么这似乎有些重复。我将在第五章中详细讨论这个问题，但是 Go 是一种*按值传递*的语言。每次将参数传递给函数时，Go 都会复制传入的值。将切片传递给`append`函数实际上是将切片的副本传递给函数。函数向切片的副本添加值并返回副本。然后，将返回的切片重新分配给调用函数中的变量。

## 容量

正如你所见，切片是值的序列。切片中的每个元素都分配给连续的内存位置，这使得读写这些值非常快速。切片的长度是已分配值的连续内存位置的数量。每个切片还有一个*容量*，即预留的连续内存位置数量。这可以大于长度。每次向切片追加值时，都会向切片末尾添加一个或多个值。每添加一个值，长度增加一次。当长度达到容量时，没有更多空间可放置值。如果在长度等于容量时尝试添加额外的值，则`append`函数使用 Go 运行时为切片分配一个新的背景数组，其容量更大。原始背景数组中的值被复制到新数组中，新值被添加到新背景数组的末尾，然后更新切片以引用新背景数组。最后，更新后的切片被返回。

当切片通过`append`增长时，Go 运行时需要时间来分配新内存，并将现有数据从旧内存复制到新内存。旧内存也需要进行垃圾回收。因此，当当前容量小于 256 时，Go 运行时通常会将切片的容量加倍。截至 Go 1.18，切片的规则是：当当前容量小于 256 时，切片的容量增加`(current_capacity + 768)/4`。这慢慢地以 25%的增长收敛（容量为 512 的切片将增长 63%，但容量为 4096 的切片只增长 30%）。

就像内置的`len`函数返回切片的当前长度一样，内置的`cap`函数返回切片的当前容量。与`len`相比，`cap`的使用频率要低得多。大多数情况下，`cap`用于检查切片是否足够大以容纳新数据，或者是否需要调用`make`来创建一个新的切片。

你也可以将数组传递给`cap`函数，但对于数组，`cap`总是返回与`len`相同的值。不要将其放入你的代码中，而是将此技巧留到 Go 知识竞赛之夜。

让我们看看向切片添加元素如何改变长度和容量。在示例 3-1 中运行代码在[Go Playground](https://oreil.ly/yiHu-)或在[第三章存储库](https://oreil.ly/dZMDe)的*sample_code/len_cap*目录中。

##### 示例 3-1。理解容量

```go
var x []int
fmt.Println(x, len(x), cap(x))
x = append(x, 10)
fmt.Println(x, len(x), cap(x))
x = append(x, 20)
fmt.Println(x, len(x), cap(x))
x = append(x, 30)
fmt.Println(x, len(x), cap(x))
x = append(x, 40)
fmt.Println(x, len(x), cap(x))
x = append(x, 50)
fmt.Println(x, len(x), cap(x))
```

当您构建并运行代码时，您将看到以下输出。注意容量如何何时增加：

```go
[] 0 0
[10] 1 1
[10 20] 2 2
[10 20 30] 3 4
[10 20 30 40] 4 4
[10 20 30 40 50] 5 8
```

虽然切片自动增长很方便，但是一次性为其指定大小要高效得多。如果您知道要放入切片中的事物数量，使用正确的初始容量来创建它。您可以使用`make`函数来实现这一点。

## make

您已经看到两种声明切片的方式，使用切片字面量或`nil`零值。虽然有用，但是这两种方式都不允许您创建已指定长度或容量的空切片。这是内置的`make`函数的任务。它允许您指定类型、长度，并且可选地指定容量。让我们来看一下：

```go
x := make([]int, 5)
```

这将创建一个长度为 5 且容量为 5 的`int`切片。由于长度为 5，`x[0]`到`x[4]`都是有效元素，并且它们都初始化为 0。

一个常见的初学者错误是尝试使用`append`来填充这些初始元素：

```go
x := make([]int, 5)
x = append(x, 10)
```

将 10 放在切片末尾，在 0–4 元素的零值之后，因为`append`总是增加切片的长度。现在`x`的值是[0 0 0 0 0 10]，长度为 6，容量为 10（一旦附加的第六个元素，容量就会加倍）。

您还可以使用`make`指定初始容量：

```go
x := make([]int, 5, 10)
```

这将创建一个长度为 5 且容量为 10 的`int`切片。

您还可以创建长度为零但容量大于零的切片：

```go
x := make([]int, 0, 10)
```

在这种情况下，您有一个非`nil`的长度为 0 但容量为 10 的切片。由于长度为 0，您无法直接对其进行索引，但可以向其附加值：

```go
x := make([]int, 0, 10)
x = append(x, 5,6,7,8)
```

现在`x`的值是[5 6 7 8]，长度为 4，容量为 10。

###### 警告

绝不要指定容量小于长度！这是一个编译时错误，如果使用常量或数字字面量这样做。如果您使用变量指定比长度更小的容量，您的程序将在运行时发生恐慌。

## 清空切片

Go 1.21 添加了一个`clear`函数，接受一个切片并将所有切片的元素设置为它们的零值。切片的长度保持不变。以下代码：

```go
s := []string{"first", "second", "third"}
fmt.Println(s, len(s))
clear(s)
fmt.Println(s, len(s))
```

输出如下：

```go
[first second third] 3
[  ] 3
```

（记住，字符串的零值是空字符串`""`！）

## 声明您的切片

现在您已经看到所有这些创建切片的方法，您应该如何选择使用哪种切片声明风格？主要目标是尽量减少切片需要增长的次数。如果可能切片根本不需要增长，请使用没有分配值的`var`声明来创建`nil`切片，如示例 3-2 所示。

##### 示例 3-2。声明一个可能保持`nil`的切片

```go
var data []int
```

###### 注意

你可以使用空切片字面量创建一个切片：

```go
var x = []int{}
```

这将创建一个零长度和零容量的切片。这与`nil`切片的不同是令人困惑的。由于实现原因，将零长度的切片与`nil`比较返回`false`，而将`nil`切片与`nil`比较返回`true`。为简单起见，推荐使用`nil`切片。零长度的切片仅在将切片转换为 JSON 时有用。你将在“encoding/json”中进一步了解。

如果有一些起始值，或者切片的值不会改变，那么切片字面量是一个不错的选择（见示例 3-3）。

##### 示例 3-3\. 使用默认值声明切片

```go
data := []int{2, 4, 6, 8} // numbers we appreciate
```

如果你对切片需要多大有一个很好的想法，但在编写程序时不知道这些值是多少，请使用`make`。那么问题就变成了在调用`make`时是否应指定一个非零长度，或者指定零长度和非零容量。有三种可能性：

+   如果你使用切片作为缓冲区（你会在“io and Friends”中看到这一点），那么请指定一个非零长度。

+   如果你*确信*知道你想要的确切大小，你可以指定长度并索引到切片中设置值。当在一个切片中转换值并将它们存储在第二个切片中时，通常会这样做。这种方法的缺点是，如果大小错误，你将在切片末尾得到零值，或者因尝试访问不存在的元素而引发恐慌。

+   在其他情况下，使用零长度和指定容量的`make`。这允许你使用`append`向切片添加项目。如果项目数量较少，你不会在末尾得到多余的零值。如果项目数量较多，你的代码不会出现恐慌。

Go 社区在第二种和第三种方法之间存在分歧。我个人更喜欢使用一个初始化为零长度的切片来使用`append`。在某些情况下可能会慢一些，但较不容易引入 bug。

###### 警告

`append`总是增加切片的长度！如果你使用`make`指定了切片的长度，请确保在这样做之前是有意为之，否则可能会在切片的开头得到一堆意外的零值。

## 切片切片

*切片表达式*从一个切片中创建一个切片。它写在方括号内，由起始偏移和结束偏移组成，用冒号（:）分隔。起始偏移是包含在新切片中的第一个位置，结束偏移是要包含的最后一个位置的下一个位置。如果省略起始偏移，假定为 0。同样，如果省略结束偏移，则用切片的结尾替代。通过在示例 3-4 中的代码上运行它，你可以看到它是如何工作的，可以在[The Go Playground](https://oreil.ly/PFtfZ)或[第三章代码库](https://oreil.ly/Ka-rJ)的*sample_code/slicing_slices*目录中查看。

##### 示例 3-4\. 切片切片

```go
x := []string{"a", "b", "c", "d"}
y := x[:2]
z := x[1:]
d := x[1:3]
e := x[:]
fmt.Println("x:", x)
fmt.Println("y:", y)
fmt.Println("z:", z)
fmt.Println("d:", d)
fmt.Println("e:", e)
```

它会得到以下输出：

```go
x: [a b c d]
y: [a b]
z: [b c d]
d: [b c]
e: [a b c d]
```

当你从一个切片中取出另一个切片时，你并没有复制数据。相反，现在你有两个共享内存的变量。这意味着对切片中元素的更改会影响所有共享该元素的切片。让我们看看当你改变值时会发生什么。你可以在示例 3-5 中的代码上运行这段代码，在[Go Playground](https://oreil.ly/xEw9J)或[第三章代码库](https://oreil.ly/nYkrx)的*sample_code/slice_share_storage*目录中运行。

##### 示例 3-5\. 具有重叠存储的切片

```go
x := []string{"a", "b", "c", "d"}
y := x[:2]
z := x[1:]
x[1] = "y"
y[0] = "x"
z[1] = "z"
fmt.Println("x:", x)
fmt.Println("y:", y)
fmt.Println("z:", z)
```

你将得到以下输出：

```go
x: [x y z d]
y: [x y]
z: [y z d]
```

修改`x`同时也修改了`y`和`z`，而对`y`和`z`的修改也会影响`x`。

当与`append`结合使用时，切片切片变得更加令人困惑。在示例 3-6 中尝试这段代码，在[Go Playground](https://oreil.ly/4f4pd)或[第三章代码库](https://oreil.ly/H1YKD)的*sample_code/slice_append_storage*目录中尝试。

##### 示例 3-6\. `append`使得重叠切片变得更加混乱

```go
x := []string{"a", "b", "c", "d"}
y := x[:2]
fmt.Println(cap(x), cap(y))
y = append(y, "z")
fmt.Println("x:", x)
fmt.Println("y:", y)
```

运行此代码会得到以下输出：

```go
4 4
x: [a b z d]
y: [a b z]
```

当你从另一个切片中取出一个切片时，子切片的容量被设置为原始切片的容量减去子切片在原始切片中的起始偏移量。这意味着原始切片中子切片之后的元素，包括未使用的容量，会被两个切片共享。

当你从`x`中创建`y`切片时，长度设置为 2，但容量设置为 4，与`x`相同。由于容量为 4，向`y`末尾添加元素会将值放在`x`的第三个位置。

这种行为会产生一些奇怪的场景，多个切片相互添加并覆盖彼此的数据。看看你能否猜到示例 3-7 中的代码会打印出什么，然后在[Go Playground](https://oreil.ly/KCveh)或[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/confusing_slices*目录中运行以查看是否猜对了。

##### 示例 3-7\. 更加令人困惑的切片

```go
x := make([]string, 0, 5)
x = append(x, "a", "b", "c", "d")
y := x[:2]
z := x[2:]
fmt.Println(cap(x), cap(y), cap(z))
y = append(y, "i", "j", "k")
x = append(x, "x")
z = append(z, "y")
fmt.Println("x:", x)
fmt.Println("y:", y)
fmt.Println("z:", z)
```

为了避免复杂的切片情况，你应该要么永远不要在子切片上使用`append`，要么确保`append`不会通过使用*完整切片表达式*而导致覆盖。这有点奇怪，但它清楚地表明了父切片和子切片之间共享的内存量。完整切片表达式包括第三部分，指示了父切片容量中可用于子切片的最后位置。从这个数字中减去起始偏移量即可得到子切片的容量。示例 3-8 展示了前一示例中修改为使用完整切片表达式的前四行代码。

##### 示例 3-8\. 完整切片表达式可以防止`append`的问题

```go
x := make([]string, 0, 5)
x = append(x, "a", "b", "c", "d")
y := x[:2:2]
z := x[2:4:4]
```

在[The Go Playground](https://oreil.ly/G7YBT)或者[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/full_slice_expression*目录中尝试这段代码。`y`和`z`的容量都为`2`。因为你限制了子切片的容量为它们的长度，向`y`和`z`附加额外元素会创建新的切片，这些切片不会与其他切片交互。运行此代码后，`x`设置为`[a b c d x]`，`y`设置为`[a b i j k]`，`z`设置为`[c d y]`。

###### 警告

当对切片进行切片时要小心！两个切片共享同一内存，对其中一个的更改会反映在另一个上。避免在切片后修改切片或者在通过切片生成后修改切片。使用三部分切片表达式防止`append`在切片之间共享容量。

## 复制

如果需要创建与原始切片独立的切片，请使用内置的`copy`函数。我们来看一个简单的例子，可以在[The Go Playground](https://oreil.ly/ilMNY)上运行，或者在[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/copy_slice*目录中运行：

```go
x := []int{1, 2, 3, 4}
y := make([]int, 4)
num := copy(y, x)
fmt.Println(y, num)
```

你会得到以下输出：

```go
[1 2 3 4] 4
```

`copy`函数接受两个参数。第一个是目标切片，第二个是源切片。该函数尽可能从源切片向目标切片复制尽可能多的值，受限于较小的切片，并返回复制的元素数。`x`和`y`的*容量*不重要；长度才重要。

你也可以复制切片的子集。以下代码将四元素切片的前两个元素复制到两元素切片中：

```go
x := []int{1, 2, 3, 4}
y := make([]int, 2)
num := copy(y, x)
```

变量`y`设置为[1 2]，`num`设置为 2。

你也可以从源切片的中间复制：

```go
x := []int{1, 2, 3, 4}
y := make([]int, 2)
copy(y, x[2:])
```

通过对切片进行切片来复制`x`的第三和第四个元素。还请注意*不要将`copy`的输出分配给变量*。如果你不需要复制的元素数，那么你不需要分配它。

`copy`函数允许在覆盖底层切片的重叠部分之间进行复制：

```go
x := []int{1, 2, 3, 4}
num := copy(x[:3], x[1:])
fmt.Println(x, num)
```

在这种情况下，你在`x`的最后三个值之上复制了`x`的前三个值。这将打印出[2 3 4 4] 3。

你可以通过对数组进行切片来使用`copy`。你可以将数组作为复制的源或目标。你可以在[The Go Playground](https://oreil.ly/-mhRW)上试试以下代码，或者在[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/copy_array*目录中试试：

```go
x := []int{1, 2, 3, 4}
d := [4]int{5, 6, 7, 8}
y := make([]int, 2)
copy(y, d[:])
fmt.Println(y)
copy(d[:], x)
fmt.Println(d)
```

第一次调用`copy`将数组`d`的前两个值复制到切片`y`中。第二次将切片`x`的所有值复制到数组`d`中。这将产生以下输出：

```go
[5 6]
[1 2 3 4]
```

## 将数组转换为切片

切片不是你唯一可以切片的东西。如果你有一个数组，你可以使用切片表达式从中获取切片。这是将数组连接到仅接受切片的函数的有用方式。要将整个数组转换为切片，请使用`[:]`语法：

```go
xArray := [4]int{5, 6, 7, 8}
xSlice := xArray[:]
```

你也可以将数组的子集转换为切片：

```go
x := [4]int{5, 6, 7, 8}
y := x[:2]
z := x[2:]
```

注意从数组中获取切片具有与从切片中获取切片相同的内存共享属性。如果在[The Go Playground](https://oreil.ly/kliaJ)或[第三章仓库](https://oreil.ly/Ur5f2)中的*sample_code/slice_array_memory*目录中运行以下代码：

```go
x := [4]int{5, 6, 7, 8}
y := x[:2]
z := x[2:]
x[0] = 10
fmt.Println("x:", x)
fmt.Println("y:", y)
fmt.Println("z:", z)
```

你会得到如下输出：

```go
x: [10 6 7 8]
y: [10 6]
z: [7 8]
```

## 将切片转换为数组

使用类型转换可以从切片创建一个数组变量。你可以将整个切片转换为相同类型的数组，或者从切片的子集创建数组。

当你将切片转换为数组时，切片中的数据将被复制到新的内存中。这意味着对切片的更改不会影响数组，反之亦然。

下面的代码：

```go
xSlice := []int{1, 2, 3, 4}
xArray := [4]int(xSlice)
smallArray := [2]int(xSlice)
xSlice[0] = 10
fmt.Println(xSlice)
fmt.Println(xArray)
fmt.Println(smallArray)
```

输出结果如下：

```go
[10 2 3 4]
[1 2 3 4]
[1 2]
```

数组的大小必须在编译时指定。在切片到数组类型转换中使用`[...]`会导致编译时错误。

虽然数组的大小可以比切片的大小小，但不能比其大。不幸的是，编译器无法检测到这一点，如果你指定的数组大小比切片的长度（而非容量）大，你的代码将在运行时崩溃。以下代码：

```go
panicArray := [5]int(xSlice)
fmt.Println(panicArray)
```

在运行时，以下消息导致程序崩溃：

```go
panic: runtime error: cannot convert slice with length 4 to array
     or pointer to array with length 5
```

###### 注意

尽管我还没有讨论过指针，但你也可以使用类型转换将切片转换为数组的指针：

```go
xSlice := []int{1,2,3,4}
xArrayPointer := (*[4]int)(xSlice)
```

将切片转换为数组指针后，两者之间共享存储。对其中一个的更改会影响另一个：

```go
xSlice[0] = 10
xArrayPointer[1] = 20
fmt.Println(xSlice) // prints [10 20 3 4]
fmt.Println(xArrayPointer) // prints &[10 20 3 4]
```

指针在第六章中有详细介绍。

你可以在[The Go Playground](https://oreil.ly/Ss4Ea)或[第三章仓库](https://oreil.ly/Ur5f2)的*sample_code/array_conversion*目录中尝试所有数组类型转换。

在“数组——直接使用过于严格”中，我提到当传入的数组大小可能变化时，无法将数组用作函数参数。技术上，你可以通过将数组转换为切片，再将切片转换为不同大小的数组，并将第二个数组传递给函数来绕过此限制。第二个数组必须比第一个数组短，否则程序将会崩溃。虽然这在紧急情况下可能有所帮助，但如果你经常这样做，强烈考虑修改函数的 API 以接受切片而不是数组。

# 字符串、符文和字节

现在我已经讨论了切片，我们可以再次看字符串。你可能会认为 Go 语言中的字符串是由符文组成的，但事实并非如此。在底层，Go 语言使用一系列字节来表示字符串。这些字节可以不必遵循任何特定的字符编码，但是几个 Go 库函数（以及我在下一章中讨论的`for-range`循环）假设一个字符串由一系列 UTF-8 编码的代码点组成。

###### 注意

根据语言规范，Go 源代码总是用 UTF-8 编写。除非在字符串文字中使用十六进制转义，否则你的字符串文字是用 UTF-8 编写的。

就像你可以从数组或切片中提取单个值一样，你也可以通过使用*索引表达式*从字符串中提取单个值：

```go
var s string = "Hello there"
var b byte = s[6]
```

像数组和切片一样，字符串的索引是从零开始的；在这个示例中，`b`被赋予了在`s`中第七个位置的数值`116`（小写字母 t 的 UTF-8 值）。

你用于数组和切片的切片表达式符号也适用于字符串：

```go
var s string = "Hello there"
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]
```

这将“o t”赋给`s2`，“Hello”赋给`s3`，“there”赋给`s4`。你可以在[The Go Playground](https://oreil.ly/pF8T6)或[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/string_slicing*目录中尝试这段代码。

尽管 Go 语言允许你使用切片符号来创建子串，并使用索引符号从字符串中提取单个条目，这确实很方便，但在这样做时要小心。由于字符串是不可变的，它们不会像切片的切片那样有修改问题。不过，也存在不同的问题。一个字符串由一系列字节组成，而 UTF-8 中的一个代码点可以是一到四个字节长。前面的示例完全由 UTF-8 中长度为一个字节的代码点组成，所以一切都按预期进行。但是在处理非英语或表情符号的语言时，你会遇到长度为多个字节的 UTF-8 代码点：

```go
var s string = "Hello "
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]

```

在这个示例中，`s3`仍然等于“Hello。”变量`s4`设置为太阳表情符号。但是`s2`并没有被设置为“o ![](img/sun.png)。”而是得到了“o ![](img/replacement.png)。”这是因为你只复制了太阳表情符号代码点的第一个字节，这个字节单独来看不是有效的代码点。

Go 语言允许你将字符串传递给内置的`len`函数以找到字符串的长度。由于字符串索引和切片表达式计算的是字节位置，因此返回的长度是以字节为单位的长度，而不是代码点的长度：

```go
var s string = "Hello "
fmt.Println(len(s))

```

这段代码打印出 10，而不是 7，因为用 UTF-8 编码的太阳笑脸表情符号需要四个字节来表示。你可以在[The Go Playground](https://oreil.ly/6ngTb)或[第三章代码库](https://oreil.ly/Ur5f2)的*sample_code/sun_slicing*目录中运行这些太阳表情符号的示例。

###### 警告

尽管 Go 允许您在字符串中使用切片和索引语法，但只有在您知道您的字符串仅包含占用一个字节的字符时才应使用它。

由于 rune、字符串和字节之间的复杂关系，Go 提供了一些有趣的类型转换。单个 rune 或字节可以转换为字符串：

```go
var a rune    = 'x'
var s string  = string(a)
var b byte    = 'y'
var s2 string = string(b)
```

###### 警告

新手 Go 开发者常见的一个错误是尝试通过类型转换将`int`转换为`string`：

```go
var x int = 65
var y = string(x)
fmt.Println(y)
```

这导致`y`具有值“A”，而不是“65”。从 Go 1.15 开始，`go vet`阻止从除`rune`或`byte`以外的任何整数类型进行字符串类型转换。

字符串可以在字节片段或 rune 切片之间来回转换。在示例 3-9 和[第三章存储库](https://oreil.ly/Ur5f2)中的*sample_code/string_to_slice*目录中尝试此代码：

##### 示例 3-9\. 将字符串转换为切片

```go
var s string = "Hello, "
var bs []byte = []byte(s)
var rs []rune = []rune(s)
fmt.Println(bs)
fmt.Println(rs)

```

当您运行此代码时，您会看到以下输出：

```go
[72 101 108 108 111 44 32 240 159 140 158]
[72 101 108 108 111 44 32 127774]
```

第一行输出将字符串转换为 UTF-8 字节。第二行将字符串转换为 runes。

Go 中大多数数据都是按字节序列读取和写入的，因此最常见的字符串类型转换是通过字节切片来回转换。很少使用 rune 切片。

不要使用切片和索引表达式处理字符串，应该使用标准库中`strings`和`unicode/utf8`包中的函数从字符串中提取子字符串和代码点。在下一章中，您将看到如何使用`for-range`循环迭代字符串中的代码点。

# 映射

当您有顺序数据时，切片非常有用。与大多数语言一样，Go 提供了一种内置数据类型，用于在您想要将一个值关联到另一个值的情况下使用。映射类型的书写方式为`map[keyType]valueType`。让我们看看声明映射的几种方法。首先，您可以使用`var`声明创建一个映射变量，该变量被设置为其零值：

```go
var nilMap map[string]int
```

在这种情况下，`nilMap`被声明为具有`string`键和`int`值的映射。映射的零值是`nil`。`nil`映射的长度为 0。尝试读取`nil`映射始终返回映射值类型的零值。但是，*尝试向`nil`映射变量写入数据将导致恐慌*。

您可以使用`:=`声明通过*map 字面量*创建一个映射变量：

```go
totalWins := map[string]int{}
```

在这种情况下，您正在使用空的映射字面量。这不同于`nil`映射。它的长度为 0，但您可以读取和写入分配了空映射字面量的映射。以下是一个非空映射字面量的示例：

```go
teams := map[string][]string {
    "Orcas": []string{"Fred", "Ralph", "Bijou"},
    "Lions": []string{"Sarah", "Peter", "Billie"},
    "Kittens": []string{"Waldo", "Raul", "Ze"},
}
```

映射字面量的主体是键，后跟冒号（:），然后是值。每个键值对在映射中用逗号分隔，即使是最后一行也是如此。在这个例子中，值是一个字符串切片。映射中值的类型可以是任何类型。关于键类型的一些限制稍后会讨论。

如果你知道打算放入地图中的键值对数量，但不知道确切的值，可以使用`make`创建具有默认大小的地图：

```go
ages := make(map[int][]string, 10)
```

使用`make`创建的地图仍然具有长度为 0，并且它们可以超过最初指定的大小。

地图在几个方面类似于切片：

+   随着向地图添加键值对，地图会自动增长。

+   如果你知道打算插入地图中的键值对数量，可以使用`make`创建具有特定初始大小的地图。

+   将地图传递给`len`函数可以告诉你地图中键值对的数量。

+   地图的零值为`nil`。

+   地图不可比较。你可以检查它们是否等于`nil`，但不能使用`==`检查两个地图是否具有相同的键和值，也不能使用`!=`检查它们是否不同。

地图的键可以是任何可比较的类型。这意味着*你不能使用切片或地图作为地图的键*。

###### 提示

何时应该使用地图，何时应该使用切片？当数据应按顺序处理或元素的顺序重要时，应使用切片来表示数据列表。

当你需要使用除递增整数值以外的其他方式来组织值时，地图非常有用，例如名称。

## 读取和写入地图

让我们看一个声明、写入和读取地图的简短程序。你可以在示例 3-10 上的[The Go Playground](https://oreil.ly/gBMvf)或[第三章存储库](https://oreil.ly/Ur5f2)的*sample_code/map_read_write*目录中运行此程序。

##### 示例 3-10\. 使用地图

```go
totalWins := map[string]int{}
totalWins["Orcas"] = 1
totalWins["Lions"] = 2
fmt.Println(totalWins["Orcas"])
fmt.Println(totalWins["Kittens"])
totalWins["Kittens"]++
fmt.Println(totalWins["Kittens"])
totalWins["Lions"] = 3
fmt.Println(totalWins["Lions"])
```

运行此程序时，你将看到以下输出：

```go
1
0
1
3
```

通过将键放在方括号内并使用`=`指定值来为地图键分配值，通过将键放在方括号内读取分配给地图键的值。请注意，你不能使用`:=`来为地图键分配值。

当你尝试读取从未设置过的地图键的值时，地图将返回地图值类型的零值。在本例中，值类型为`int`，因此会返回 0\. 你可以使用`++`运算符来递增地图键的数值。因为地图默认返回其零值，所以即使与键关联的现有值不存在，这也适用。

## 逗号 ok 习语

正如你所见，如果要查找与地图中不存在的键关联的值，地图将返回零值。这在实现像前面看到的`totalWins`计数器时非常方便。然而，有时确实需要查找键是否存在于地图中。Go 提供了*逗号 ok 习语*来区分关联零值的键和不在地图中的键：

```go
m := map[string]int{
    "hello": 5,
    "world": 0,
}
v, ok := m["hello"]
fmt.Println(v, ok)

v, ok = m["world"]
fmt.Println(v, ok)

v, ok = m["goodbye"]
fmt.Println(v, ok)
```

与将映射读取的结果分配给单个变量不同，使用逗号 ok 惯用法将映射读取的结果分配给两个变量。第一个变量获取与键关联的值。第二个返回的值是一个布尔值，通常命名为`ok`。如果`ok`为`true`，则键存在于映射中。如果`ok`为`false`，则键不存在。在这个示例中，代码打印出`5 true`，`0 true`和`0 false`。

###### 注意

在 Go 语言中，当你想要区分读取一个值和返回零值时，可以使用逗号 ok 惯用法。你将在第十二章再次看到它，并且在使用类型断言时也会看到它在第七章。

## 从映射中删除

键-值对可以通过内置的`delete`函数从映射中移除：

```go
m := map[string]int{
    "hello": 5,
    "world": 10,
}
delete(m, "hello")
```

`delete`函数接收一个映射和一个键，然后移除具有指定键的键-值对。如果键不在映射中或映射为`nil`，则什么也不发生。`delete`函数不返回值。

## 清空映射

你在“清空切片”中看到的`clear`函数也适用于映射。清空后的映射长度被设为零，不同于清空切片。以下代码：

```go
m := map[string]int{
    "hello": 5,
    "world": 10,
}
fmt.Println(m, len(m))
clear(m)
fmt.Println(m, len(m))
```

输出如下：

```go
map[hello:5 world:10] 2
map[] 0
```

## 比较映射

Go 1.21 添加了一个名为`maps`的包到标准库中，其中包含用于处理映射的辅助函数。你将在“向标准库添加泛型”中了解更多关于该包的信息。包中的两个函数对比两个映射是否相等非常有用，`maps.Equal`和`maps.EqualFunc`。它们类似于`slices.Equal`和`slices.EqualFunc`函数：

```go
m := map[string]int{
    "hello": 5,
    "world": 10,
}
n := map[string]int{
    "world": 10,
    "hello": 5,
}
fmt.Println(maps.Equal(m, n)) // prints true
```

## 使用映射作为集合

许多语言在它们的标准库中包含了集合。*集合*是一种数据类型，确保值最多只有一个，但不保证值的顺序。检查元素是否在集合中是快速的，无论集合中有多少元素。（检查元素是否在切片中则会花费更多时间，因为切片中的元素越多，时间越长。）

Go 语言不包含集合，但可以使用映射来模拟其部分功能。将映射的键用于要放入集合的类型，并将值用`bool`类型。示例 3-11 中的代码演示了这一概念。你可以在[The Go Playground](https://oreil.ly/wC6XK)或[第三章示例代码库](https://oreil.ly/Ur5f2)的*sample_code/map_set*目录中运行它。

##### 示例 3-11. 使用映射作为集合

```go
intSet := map[int]bool{}
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}
for _, v := range vals {
    intSet[v] = true
}
fmt.Println(len(vals), len(intSet))
fmt.Println(intSet[5])
fmt.Println(intSet[500])
if intSet[100] {
    fmt.Println("100 is in the set")
}
```

你需要一个`int`类型的集合，因此创建一个映射，其中键是`int`类型，值是`bool`类型。你使用`for-range`循环（我在“for-range 语句”中讨论）迭代`vals`中的值，将它们放入`intSet`中，并将每个`int`与布尔值`true`关联。

我们向`intSet`写入了 11 个值，但`intSet`的长度为 8，因为在映射中不能有重复的键。如果你在`intSet`中查找 5，它会返回`true`，因为存在一个值为 5 的键。然而，如果你在`intSet`中查找 500 或 100，它会返回`false`。这是因为你没有将这两个值放入`intSet`中，这导致映射返回映射值的零值，而`bool`类型的零值为`false`。

如果你需要提供像并集、交集和差集等操作的集合，你可以自己编写一个，或者使用其中一个提供这些功能的许多第三方库。（关于使用第三方库，您将在第十章中学到更多。）

###### 注意

有些人喜欢在用映射实现集合时使用`struct{}`作为值。（我将在下一节讨论结构体。）优点是空结构体使用零字节，而布尔值使用一个字节。

缺点是使用`struct{}`会使您的代码变得笨拙。赋值不够明显，并且您需要使用逗号-ok 惯用法来检查值是否在集合中：

```go
intSet := map[int]struct{}{}
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}
for _, v := range vals {
    intSet[v] = struct{}{}
}
if _, ok := intSet[5]; ok {
    fmt.Println("5 is in the set")
}
```

除非您有非常大的集合，否则内存使用的差异可能不足以抵消其缺点。

# 结构体

映射是存储某些类型数据的方便方式，但它们有一些限制。它们不定义 API，因为没有办法限制映射只允许特定的键。此外，映射中所有值必须是相同类型的。因此，映射不是将数据从一个函数传递到另一个函数的理想方式。当你有想要一起组合的相关数据时，你应该定义一个*结构体*。

###### 注意

如果你已经了解一种面向对象的语言，你可能想知道类和结构体之间的区别。区别很简单：Go 语言没有类，因为它没有继承。这并不意味着 Go 语言没有一些面向对象语言的特性，只是它的实现方式有些不同。您将在第七章中学到更多关于 Go 语言面向对象特性的内容。

大多数语言都有类似结构体的概念，Go 语言用于读取和写入结构体的语法看起来应该很熟悉：

```go
type person struct {
    name string
    age  int
    pet  string
}
```

结构体类型使用关键字`type`、结构体类型的名称、关键字`struct`和一对大括号`{}`定义。在大括号内，列出结构体的字段。就像在`var`声明中先放变量名后放变量类型一样，在结构体声明中先放结构体字段名后放结构体字段类型。还要注意，与映射字面量不同，结构体声明中没有逗号分隔字段。您可以在函数内或函数外定义结构体类型。在函数内定义的结构体类型只能在该函数内使用。（关于函数，您将在第五章中学到更多。）

###### 注意

从技术上讲，你可以将结构体定义作用域限定在任何块级别。在第四章中你会学到更多关于块的知识。

一旦声明了结构体类型，就可以定义该类型的变量：

```go
var fred person
```

在这里我们使用了`var`声明。由于`fred`没有被赋值，它得到了`person`结构体类型的零值。零值结构体将所有字段设置为字段的零值。

*结构体字面量*也可以分配给变量：

```go
bob := person{}
```

与映射不同，分配空的结构体字面量和不分配任何值之间没有区别。两者都会将结构体中的所有字段初始化为它们的零值。非空结构体字面量有两种风格。首先，结构体字面量可以被指定为字段值的逗号分隔列表，放在大括号内：

```go
julia := person{
    "Julia",
    40,
    "cat",
}
```

当使用这种结构体字面量格式时，必须为结构体中的每个字段指定一个值，并且这些值按照结构体定义中声明的顺序赋给字段。

第二种结构体字面量风格看起来像映射字面量的风格：

```go
beth := person{
    age:  30,
    name: "Beth",
}
```

你可以使用结构体中字段的名称来指定值。这种风格有一些优势。它允许你以任意顺序指定字段，并且不需要为所有字段提供值。未指定的字段将被设置为其零值。

你不能混合这两种结构体字面量风格：要么所有字段都用名称指定，要么一个也不用。对于所有字段始终被指定的小结构体，简单的结构体字面量风格是可以接受的。在其他情况下，使用名称。这样更冗长，但清楚地表明了赋值给哪个字段的值，无需引用结构体定义。这也更易维护。如果你初始化结构体时不使用字段名称，并且结构体的未来版本添加了额外的字段，你的代码将不再编译。

结构体中的字段可以通过点表示法进行访问：

```go
bob.name = "Bob"
fmt.Println(bob.name)
```

就像你用括号同时读取和写入映射一样，你可以使用点表示法读取和写入结构体字段。

## 匿名结构体

你也可以声明一个变量实现一个结构体类型，而不先给结构体类型命名。这称为*匿名结构体*：

```go
var person struct {
    name string
    age  int
    pet  string
}

person.name = "bob"
person.age = 50
person.pet = "dog"

pet := struct {
    name string
    kind string
}{
    name: "Fido",
    kind: "dog",
}
```

在这个例子中，变量`person`和`pet`的类型是匿名结构体。你可以像对命名结构体类型一样，分配（和读取）匿名结构体中的字段。正如你可以用结构体字面量初始化命名结构体的实例一样，你也可以对匿名结构体做同样的事情。

也许你会想知道，拥有仅关联于单个实例的数据类型何时有用。匿名结构体在两种常见情况下非常方便。第一种情况是当你将外部数据转换为结构体，或者将结构体转换为外部数据（如 JSON 或 Protocol Buffers）时。分别称为*反序列化*和*序列化*数据。你将在“encoding/json”中学习如何做到这一点。

编写测试是匿名结构体出现的另一个地方。在第十五章中编写表驱动测试时，您将使用匿名结构体的切片。

## 比较和转换结构体

结构体是否可比取决于结构体的字段。完全由可比较类型组成的结构体是可比较的；具有切片或映射字段的结构体不可比较（正如您将在后面的章节中看到的，函数和通道字段也会阻止结构体可比较）。

与 Python 或 Ruby 不同，在 Go 中没有魔术方法可以被重写来重新定义相等性并使 `==` 和 `!=` 适用于不可比较的结构体。当然，您可以编写自己的函数来比较结构体。

就像 Go 不允许不同原始类型的变量之间的比较一样，Go 也不允许表示不同类型的结构体之间的比较。如果两个结构体的字段具有相同的名称、顺序和类型，Go 允许你从一个结构体类型转换为另一个结构体类型。让我们看看这意味着什么。给定这个结构体：

```go
type firstPerson struct {
    name string
    age  int
}
```

您可以使用类型转换将 `firstPerson` 的实例转换为 `secondPerson`，但是您不能使用 `==` 来比较 `firstPerson` 的实例和 `secondPerson` 的实例，因为它们是不同的类型：

```go
type secondPerson struct {
    name string
    age  int
}
```

你不能将 `firstPerson` 的实例转换为 `thirdPerson`，因为字段的顺序不同：

```go
type thirdPerson struct {
    age  int
    name string
}
```

你不能将 `firstPerson` 的实例转换为 `fourthPerson`，因为字段名称不匹配：

```go
type fourthPerson struct {
    firstName string
    age       int
}
```

最后，你不能将 `firstPerson` 的实例转换为 `fifthPerson`，因为有一个额外的字段：

```go
type fifthPerson struct {
    name          string
    age           int
    favoriteColor string
}
```

匿名结构体增加了一个小变化：如果正在比较两个结构体变量，并且至少有一个类型是匿名结构体，那么如果两个结构体的字段具有相同的名称、顺序和类型，您可以在不进行类型转换的情况下比较它们。如果两个结构体的字段具有相同的名称、顺序和类型，您还可以在命名和匿名结构体类型之间进行赋值：

```go
type firstPerson struct {
    name string
    age  int
}
f := firstPerson{
    name: "Bob",
    age:  50,
}
var g struct {
    name string
    age  int
}

// compiles -- can use = and == between identical named and anonymous structs
g = f
fmt.Println(f == g)
```

# 练习

以下练习将测试您对 Go 复合类型的了解。您可以在[第三章存储库](https://oreil.ly/d2nrA)的 *exercise_solutions* 目录中找到解决方案。

1.  编写一个程序，定义一个名为 `greetings` 的字符串切片类型的变量，其值为 `"Hello"`、`"Hola"`、`"नमस्कार"`、`"こんにちは"` 和 `"Привіт"`。创建一个包含前两个值的子切片；第二个子切片包含第二、第三和第四个值；第三个子切片包含第四和第五个值。打印出所有四个切片。

1.  编写一个程序，定义一个名为 `message` 的字符串变量，其值为 `"Hi ![](img/woman.png) and ![](img/man.png)"`，并打印出其中的第四个符文作为字符，而不是数字。

1.  编写一个程序，定义一个名为`Employee`的结构体，它包含三个字段：`firstName`、`lastName`和`id`。前两个字段的类型是`string`，最后一个字段（`id`）的类型是`int`。使用任意值创建三个此结构体的实例。第一个实例使用结构体字面量样式且没有字段名初始化，第二个实例使用结构体字面量样式并指定字段名，第三个实例使用`var`声明。使用点符号赋值填充第三个结构体的字段。打印出这三个结构体的所有信息。

# 结语

你已经学到了很多关于 Go 语言中复合类型的知识。除了学习更多关于字符串的知识外，现在你还知道如何使用内置的通用容器类型：切片（slices）和映射（maps）。你还可以通过结构体构建自己的复合类型。在下一章中，你将看到 Go 语言的控制结构：`for`、`if/else`和`switch`。你还将了解 Go 语言如何将代码组织成块，并且不同的块级别可能会导致意想不到的行为。
