# 第二章。预声明类型和声明

现在，您已经设置好开发环境，是时候开始了解 Go 语言的语言特性以及如何最佳地使用它们了。当试图弄清楚“最佳”意味着什么时，有一个主要的原则：以一种使您的意图清晰的方式编写您的程序。在我介绍功能并讨论选项时，我将解释为什么我认为特定的方法会产生更清晰的代码。

我将首先查看内置于 Go 中的类型以及如何声明这些类型的变量。尽管每位程序员对这些概念都有经验，但 Go 在某些方面有所不同，并且与其他语言之间存在微妙的差异。

# 预声明类型

Go 语言内置了许多类型。这些被称为*预声明*类型。它们类似于其他语言中的类型：布尔型、整数型、浮点型和字符串型。对于那些从其他语言过渡的开发人员来说，习惯地使用这些类型有时是一个挑战。你将看到这些类型如何在 Go 中发挥最佳作用。在我回顾这些类型之前，让我们先了解一些适用于所有类型的概念。

## 零值

像大多数现代语言一样，Go 会为声明但未赋值的变量分配一个默认的*零值*。显式的零值使得代码更清晰，并消除了在 C 和 C++程序中发现的错误源。当我讨论每种类型时，我还将涵盖该类型的零值。您可以在[《Go 编程语言规范》](https://oreil.ly/3d3e6)中找到有关零值的详细信息。

## 字面量

Go 语言中的*字面量*是明确指定的数字、字符或字符串。Go 程序有四种常见的字面量类型。（在讨论复数时，我将涵盖一种罕见的第五种字面量类型。）

*整数字面量*是一系列数字。整数字面量默认为十进制，但使用不同的前缀表示其他进制：0b 表示二进制（基数为 2），0o 表示八进制（基数为 8），0x 表示十六进制（基数为 16）。前缀的字母可以是大写或小写。在一个前导的 0 后没有字母的情况下，是另一种表示八进制字面量的方式。不要使用这种表示法，因为它会非常令人困惑。

为了更容易阅读更长的整数字面量，Go 允许您在字面量的中间放置下划线。这使您可以例如在十进制数中按千位组织（1_234）。这些下划线对数字的值没有影响。下划线的唯一限制是它们不能出现在数字的开头或结尾，并且不能相互挨着。您可以在字面量中的每个数字之间放置下划线（1_2_3_4），但是不要这样做。通过在千位处分隔十进制数或在 1 字节、2 字节或 4 字节边界处分隔二进制、八进制或十六进制数来提高可读性。

*浮点文字* 有一个小数点来表示值的小数部分。它们也可以使用字母 `e` 和正负数来指定指数（例如 6.03e23）。您还可以选择使用 0x 前缀以及字母 `p` 来以十六进制编写它们，指示任何指数（0x12.34p5，相当于十进制中的 582.5）。与整数文字一样，您可以使用下划线来格式化您的浮点文字。

*rune 文字* 表示一个字符，用单引号括起来。与许多其他语言不同，在 Go 中，单引号和双引号*不能*互换使用。rune 文字可以写成单个 Unicode 字符（`'a'`）、8 位八进制数字（`'\141'`）、8 位十六进制数字（`'\x61'`）、16 位十六进制数字（`'\u0061'`）或 32 位 Unicode 数字（`'\U00000061'`）。还有几个反斜杠转义的 rune 文字，其中最有用的是换行符（`'\n'`）、制表符（`'\t'`）、单引号（`'\''`）和反斜杠（`'\\'`）。

实际上，使用十进制来表示整数和浮点数文字。八进制表示很少见，主要用于表示 POSIX 权限标志值（例如 0o777 表示 rwxrwxrwx）。十六进制和二进制有时用于位过滤器或网络和基础设施应用程序。除非上下文使代码更清晰，否则避免使用任何 rune 文字的数值转义。

有两种方式表示*字符串文字*。大多数情况下，您应该使用双引号创建*解释字符串文字*（例如，类型 **`"问候和`** **`致意"`**）。这些包含零个或多个 rune 文字。它们被称为“解释性”的原因是它们将 rune 文字（数值和反斜杠转义的）解释为单个字符。

###### 注意

一个 rune 文字的反斜杠转义在字符串文字中不合法：单引号转义。它被双引号的反斜杠转义替换。

不能出现在解释字符串文字中的唯一字符是未转义的反斜杠、未转义的换行符和未转义的双引号。如果您使用解释字符串文字，并希望问候语在不同行与致意语，并且希望“致意”出现在引号中，则需要输入 **`"问候和\n\"致意\""`**。

如果需要在字符串中包含反斜杠、双引号或换行符，使用*原始字符串文字*更容易。这些用反引号（`` ` ``）界定，并且可以包含除反引号以外的任何字符。原始字符串文字中没有转义字符；所有字符均按原样包含。使用原始字符串文字时，您可以这样写一个多行问候语：

```go
`Greetings and
"Salutations"`
```

字面量被视为 *无类型的*。我将在 “字面量是无类型的” 中更详细地探讨这一概念。正如你在 “var Versus :=” 中所看到的，Go 中有些情况下类型并没有显式声明。在这些情况下，Go 使用字面量的 *默认类型*；如果表达式中没有明确表明字面量的类型，字面量将默认为某一类型。在讨论不同的预声明类型时，我将提到字面量的默认类型。

## 布尔类型

`bool` 类型表示布尔变量。`bool` 类型的变量可以有两个值：`true` 或 `false`。`bool` 的零值是 `false`：

```go
var flag bool // no value assigned, set to false
var isAwesome = true
```

谈论变量类型而不展示变量声明，或者反之，都是很难的。我将先使用变量声明并在 “var Versus :=” 中对其进行描述。

## 数值类型

Go 语言拥有大量的数值类型：12 种类型（以及一些特殊名称），分为三类。如果你来自像 JavaScript 这样只使用单一数值类型的语言，可能会觉得这很多。实际上，一些类型经常被使用，而其他一些则更为奇特。我将从整数类型开始讨论，然后再转向浮点类型和非常不寻常的复数类型。

### 整数类型

Go 语言提供了带有各种大小的有符号和无符号整数，从一到八字节不等。它们在 表 2-1 中展示。

表 2-1\. Go 语言中的整数类型

| 类型名称 | 取值范围 |
| --- | --- |
| `int8` | -128 到 127 |
| `int16` | -32768 到 32767 |
| `int32` | -2147483648 到 2147483647 |
| `int64` | -9223372036854775808 到 9223372036854775807 |
| `uint8` | 0 到 255 |
| `uint16` | 0 到 65535 |
| `uint32` | 0 到 4294967295 |
| `uint64` | 0 到 18446744073709551615 |

从名称就能看出，所有整数类型的零值都是 `0`。

### 特殊的整数类型

Go 语言确实有一些特殊的整数类型名称。`byte` 是 `uint8` 的别名；在 Go 代码中可以合法地在 `byte` 和 `uint8` 之间进行赋值、比较或执行数学运算。然而，在 Go 代码中很少看到 `uint8`，通常直接称之为 `byte`。

第二个特殊名称是 `int`。在 32 位 CPU 上，`int` 是一个 32 位有符号整数，类似于 `int32`。在大多数 64 位 CPU 上，`int` 是一个 64 位有符号整数，就像 `int64` 一样。因为 `int` 在平台间不一致，如果在没有类型转换的情况下在 `int` 和 `int32` 或 `int64` 之间赋值、比较或执行数学运算，会导致编译时错误（详见 “显式类型转换”）。整数字面量默认为 `int` 类型。

###### 注意

一些不常见的 64 位 CPU 架构使用 32 位有符号整数作为 `int` 类型。Go 支持其中的三种：`amd64p32`、`mips64p32` 和 `mips64p32le`。

第三个特殊名称是 `uint`。它遵循与 `int` 相同的规则，只是无符号的（值始终为 0 或正数）。

还有两个特殊的整数类型名称，`rune`和`uintptr`。你之前已经看过 rune 字面量，我将在“字符串和 rune 的味道”中讨论`rune`类型，以及在第十六章中讨论`uintptr`。

### 如何选择使用哪种整数类型

Go 提供的整数类型比一些其他语言更多。考虑到这些选择，你可能会想知道何时应该使用每种类型。你应该遵循三个简单的规则：

+   如果你正在处理具有特定大小或符号的整数的二进制文件格式或网络协议，请使用相应的整数类型。

+   如果你正在编写一个应该适用于任何整数类型的库函数，可以利用 Go 的泛型支持，并使用泛型类型参数来表示任何整数类型（我在第五章中更详细地讨论函数及其参数，以及在第八章中更详细地讨论泛型）。

+   在所有其他情况下，只需使用`int`。

###### 注意

你可能会遇到遗留代码，其中有一对函数完成相同的任务，但一个使用`int64`作为参数和变量的类型，另一个使用`uint64`。原因是 API 在 Go 添加泛型之前创建的。没有泛型，你需要编写带有稍微不同名称的函数来使用不同类型实现相同的算法。使用`int64`和`uint64`意味着你可以编写一次代码，让调用者使用类型转换来传递值并转换返回的数据。

你可以在`strconv`包中的函数`FormatInt`和`FormatUint`中看到这种模式，它们在 Go 标准库中。

### 整数运算符

Go 整数支持通常的算术运算符：+、`-`、`*`、`/`，使用`%`进行模运算。整数除法的结果是整数；如果要获得浮点结果，需要使用类型转换将整数转换为浮点数。另外，要小心不要将整数除以 0；这会导致恐慌（我在“panic 和 recover”中更详细地讨论恐慌）。

###### 注意

Go 中的整数除法向零截断；详细信息请参见 Go 规范中关于[算术运算符](https://oreil.ly/zp3OJ)的部分。

你可以将任何算术运算符与`=`结合使用来修改变量：`+=`、`-=`、`*=`、`/=`和`%=`。例如，以下代码的结果是变量`x`的值为 20：

```go
var x int = 10
x *= 2
```

可以使用`==`、`!=`、`>`、`>=`、`<`和`<=`比较整数。

Go 还为整数提供了位操作运算符。你可以使用`<<`和`>>`进行位左移和右移，或者使用`&`（按位与）、`|`（按位或）、`^`（按位异或）和`&^`（按位与非）进行位掩码操作。与算术运算符一样，你也可以将所有位操作符与`=`结合使用来修改变量：`&=`、`|=`、`^=`、`&^=`、`<<=`和`>>=`。

### 浮点类型

Go 有两种浮点类型，如表 2-2 所示。

表 2-2\. Go 中的浮点类型

| 类型名称 | 最大绝对值 | 最小（非零）绝对值 |
| --- | --- | --- |
| `float32` | 3.40282346638528859811704183484516925440e+38 | 1.401298464324817070923729583289916131280e-45 |
| `float64` | 1.797693134862315708145274237317043567981e+308 | 4.940656458412465441765687928682213723651e-324 |

就像整数类型一样，浮点类型的零值是 0。

Go 语言中的浮点数与其他语言的浮点数类似。Go 语言使用 IEEE 754 规范，提供了大范围和有限精度。选择使用哪种浮点类型很简单：除非必须与现有格式兼容，否则使用`float64`。浮点数字面量的默认类型是`float64`，因此始终使用`float64`是最简单的选项。它还有助于减少浮点数精度问题，因为`float32`只有六到七位小数的精度。除非已使用分析器确定它是问题的重要来源，否则不必担心内存大小的差异（测试和分析详见第十五章）。

更重要的问题是是否应该完全使用浮点数。在许多情况下，答案是否定的。就像其他语言一样，Go 语言的浮点数有很大的范围，但不能存储该范围内的每个值；它们存储最接近的近似值。由于浮点数不是精确的，它们只能在可以接受不精确值或者浮点数规则已充分理解的情况下使用。这限制了它们的使用范围，例如图形、统计和科学操作。

###### 警告

浮点数不能精确表示小数值。不要用它们来表示货币或任何其他必须有精确小数表示的值！在“导入第三方代码”中，您将查看一个处理精确小数值的第三方模块。

您可以使用所有标准的数学和比较运算符处理浮点数，除了 `%`。浮点数除法有一些有趣的特性。将非零浮点变量除以 0 会返回`+Inf`或`-Inf`（正无穷或负无穷），取决于数字的符号。将设置为 0 的浮点变量除以 0 会返回`NaN`（非数值）。

虽然 Go 允许你使用`==`和`!=`来比较浮点数，但最好不要这样做。由于浮点数的不精确性，两个浮点数可能在你认为它们应该相等时不相等。相反，定义一个允许的最大差异，并查看两个浮点数之间的差异是否小于该值。这个值（有时称为*epsilon*）取决于你的精度需求；我无法给你一个简单的规则。如果不确定，建议咨询你附近友好的数学家。如果找不到，请参考[The Floating Point Guide 的“Comparison”页面](https://oreil.ly/n9ws3)，它可以帮助你（或可能说服你除非绝对必要，否则避免使用浮点数）。

### 复杂类型（你可能不会使用这些）

还有一种数值类型，非常不寻常。Go 对复数有一流支持。如果你不知道复数是什么，那你不是这个特性的目标用户；可以跳过这部分。

在 Go 中，复数支持并不复杂。Go 定义了两种复数类型。`complex64`使用`float32`值表示实部和虚部，而`complex128`使用`float64`值。两者都可以使用内置函数`complex`进行声明：

```go
var complexNum = complex(20.3, 10.2)
```

Go 使用几条规则来确定`complex`函数返回值的类型：

+   如果你对函数参数同时使用未类型化的常量或字面量，将创建一个未类型化的复数字面量，默认类型为`complex128`。

+   如果`complex`函数的两个值都是`float32`类型，将创建一个`complex64`。

+   如果一个值是`float32`，另一个值是可以适应`float32`的未类型化常量或字面量，则将创建一个`complex64`。

+   否则，将创建一个`complex128`。

所有标准的浮点运算符都可以用于复数。与浮点数一样，你可以使用`==`或`!=`进行比较，但它们有相同的精度限制，因此最好使用 epsilon 技术。你可以使用内置函数`real`和`imag`分别提取复数的实部和虚部。`math/cmplx`包提供了额外的函数来操作`complex128`值。

两种复数类型的零值都将实部和虚部分别赋值为 0。

示例 2-1 展示了一个简单的程序，演示了复数的工作原理。你可以在[The Go Playground](https://oreil.ly/fuyIu)上自行运行它，或者在[第二章存储库](https://oreil.ly/zXZqI)的*sample_code/complex_numbers*目录中查看它。

##### Example 2-1\. 复数

```go
func main() {
    x := complex(2.5, 3.1)
    y := complex(10.2, 2)
    fmt.Println(x + y)
    fmt.Println(x - y)
    fmt.Println(x * y)
    fmt.Println(x / y)
    fmt.Println(real(x))
    fmt.Println(imag(x))
    fmt.Println(cmplx.Abs(x))
}
```

运行此代码会得到以下结果：

```go
(12.7+5.1i)
(-7.699999999999999+1.1i)
(19.3+36.62i)
(0.2934098482043688+0.24639022584228065i)
2.5
3.1
3.982461550347975
```

你也可以看到浮点数不精确性在这里展示出来。

如果你想知道第五种原始字面量是什么，Go 支持虚数字面量来表示复数的虚部。它们看起来像浮点字面量，但后缀为`i`。

尽管 Go 语言作为预声明类型拥有复数，但并不是流行的数值计算语言。采用受限，因为其他特性（如矩阵支持）不是语言的一部分，而库必须使用效率低下的替代品，比如切片的切片。 （您将在第三章中查看切片及其在第六章中的实现。）但是，如果您需要在较大程序的一部分中计算 Mandelbrot 集，或者实现二次方程求解器，复数支持在这里为您提供帮助。

也许你会想知道为什么 Go 语言包括复数。答案很简单：Ken Thompson，Go 语言（和 Unix）的创造者之一，认为它们会很[有趣](https://oreil.ly/eBmkq)。有关从 Go 的未来版本中[移除复数](https://oreil.ly/Q76EV)的讨论，但忽略这一功能会更容易。

###### 注意

如果您确实希望在 Go 中编写数值计算应用程序，可以使用第三方[Gonum](https://www.gonum.org)包。它利用复数，并为线性代数、矩阵、积分和统计等提供有用的库。但您应该首先考虑其他语言。

## 字符串和符文的味道

这让我们来谈谈字符串。像大多数现代语言一样，Go 语言将字符串作为内置类型。字符串的零值是空字符串。Go 支持 Unicode；正如我展示的“文字”，你可以在字符串中放入任何 Unicode 字符。像整数和浮点数一样，字符串使用`==`比较是否相等，使用`!=`比较是否不等，使用`>`、`>=`、`<`或`<=`进行排序。它们通过`+`运算符进行连接。

Go 中的字符串是不可变的；您可以重新分配字符串变量的值，但不能更改分配给它的字符串的值。

Go 还有一种表示单个代码点的类型。*符文*类型是`int32`类型的别名，就像`byte`是`uint8`的别名一样。正如您可能猜到的那样，符文文字的默认类型是符文，字符串文字的默认类型是字符串。

如果您引用字符，请使用 rune 类型，而不是`int32`类型。它们可能对编译器来说是相同的，但您应该使用能够澄清代码意图的类型：

```go
var myFirstInitial rune = 'J' // good - the type name matches the usage
var myLastInitial int32 = 'B' // bad - legal but confusing
```

我将在下一章节中详细讨论字符串，涵盖一些实现细节、与字节和符文的关系，以及高级功能和陷阱。

## 显式类型转换

大多数具有多个数字类型的语言在需要时会自动从一个类型转换为另一个类型。这称为*自动类型提升*，虽然它看起来非常方便，但事实证明，正确转换一个类型到另一个类型的规则可能会变得复杂并产生意外结果。作为一种重视意图清晰性和可读性的语言，Go 不允许在变量之间进行自动类型提升。当变量类型不匹配时，必须使用*类型转换*。即使是不同大小的整数和浮点数也必须转换为相同类型以进行交互。这清楚地表明您需要的确切类型，而无需记住任何类型转换规则（见 示例 2-2）。

##### 示例 2-2\. 类型转换

```go
var x int = 10
var y float64 = 30.2
var sum1 float64 = float64(x) + y
var sum2 int = x + int(y)
fmt.Println(sum1, sum2)
```

在这个示例代码中，您定义了四个变量。`x` 是一个值为 10 的 `int`，`y` 是一个值为 30.2 的 `float64`。由于它们不是相同的类型，您需要将它们转换为同一类型以进行相加。对于 `sum1`，您使用 `float64` 类型转换将 `x` 转换为 `float64`，对于 `sum2`，您使用 `int` 类型转换将 `y` 转换为 `int`。当您运行此代码时，它会打印出 40.2 40。

同一行为适用于不同大小的整数类型（见 示例 2-3）。

##### 示例 2-3\. 整数类型转换

```go
var x int = 10
var b byte = 100
var sum3 int = x + int(b)
var sum4 byte = byte(x) + b
fmt.Println(sum3, sum4)
```

您可以在 [Go Playground](https://oreil.ly/VoE7H) 上运行这些示例，或者在 [第二章存储库](https://oreil.ly/dGtos) 中的 *sample_code/type_conversion* 目录中运行。

围绕类型的严格性还有其他影响。由于 Go 中的所有类型转换都是显式的，您不能将另一种 Go 类型视为布尔值。在许多语言中，非零数字或非空字符串可以解释为布尔值 `true`。就像自动类型提升一样，“真值”值得从语言到语言的规则有所不同，这可能会令人困惑。不足为奇，Go 不允许真值。事实上，*没有其他类型可以被隐式或显式地转换为布尔型*。如果要将另一种数据类型转换为布尔型，必须使用其中一个比较运算符（`==`、`!=`、`>`、`<`、`<=` 或 `>=`）。例如，要检查变量 `x` 是否等于 0，代码将是 `x == 0`。如果要检查字符串 `s` 是否为空，请使用 `s == ""`。

###### 注意

类型转换是 Go 中选择在一定程度上增加冗余性以换取简洁性和清晰度的地方之一。您会多次看到这种权衡。惯用的 Go 更看重可理解性而不是简洁性。

## 文字量没有类型

虽然您不能将两个声明为不同类型整数的整数变量相加，但是 Go 允许您在浮点表达式中使用整数字面量，甚至将整数字面量赋值给浮点变量：

```go
var x float64 = 10
var y float64 = 200.3 * 5
```

这是因为，正如我之前提到的，Go 中的文字都是无类型的。Go 是一门实用的语言，推迟类型指定是有意义的。这意味着它们可以与任何类型兼容的变量一起使用。当你在第七章看到用户定义的类型时，你会发现甚至可以在预定义类型的基础上使用文字。无类型的能力有限；你不能将文字串赋给数字类型的变量，或将文字数字赋给字符串变量，也不能将浮点文字赋给`int`。这些都会被编译器标记为错误。还存在大小限制；虽然你可以写比任何整数都大的数字文字，但如果试图将其分配给超出指定变量的值的文字，例如将文字 1000 分配给`byte`类型的变量，编译时会出错。

# `var`与`:=`的比较：

对于一门小语言来说，Go 有很多声明变量的方法。这背后有一个原因：每种声明风格都传达了关于变量如何使用的信息。让我们逐一介绍在 Go 中声明变量的方法，并看看每种方法何时适用。

在 Go 中声明变量的最冗长方式使用`var`关键字，显式类型和赋值。它看起来像这样：

```go
var x int = 10
```

如果`=`右侧的类型是你变量的预期类型，你可以在`=`左侧省略类型。由于整数文字的默认类型是`int`，以下声明`x`为类型为`int`的变量：

```go
var x = 10
```

相反，如果你想声明一个变量并将其赋值为零值，可以保留类型并在右侧省略`=`：

```go
var x int
```

你可以使用`var`一次声明多个变量，它们可以是相同类型的：

```go
var x, y int = 10, 20
```

你可以声明同一类型的所有零值：

```go
var x, y int
```

或者不同类型的：

```go
var x, y = 10, "hello"
```

还有一种使用`var`的方法。如果你一次声明多个变量，可以将它们包装在*声明列表*中：

```go
var (
    x    int
    y        = 20
    z    int = 30
    d, e     = 40, "hello"
    f, g string
)
```

Go 还支持一种短声明和赋值格式。当你在函数内部时，可以使用`:=`运算符来替代使用类型推断的`var`声明。以下两个语句完全相同——它们声明`x`为`int`，其值为 10：

```go
var x = 10
x := 10
```

像`var`一样，你可以使用`:=`一次声明多个变量。以下两行都将 10 赋给`x`，将“hello”赋给`y`：

```go
var x, y = 10, "hello"
x, y := 10, "hello"
```

`:=`运算符可以做一件`var`做不到的事情：它允许你对已存在的变量赋值。只要`:=`的左侧至少有一个新变量，其他任何变量都可以已经存在：

```go
x := 10
x, y := 30, "hello"
```

使用`:=`有一个限制。如果你在包级别声明一个变量，你必须使用`var`，因为在函数外部使用`:=`是不合法的。

如何知道使用哪种风格？一如既往，选择能最清晰表达你意图的方式。在函数内部最常见的声明风格是 `:=`。在函数外部，仅在罕见情况下声明多个包级变量时才使用声明列表。

在某些函数内部的情况下，应避免使用 `:=`：

+   当将变量初始化为其零值时，请使用 `var x int`。这样可以明确表明零值是有意为之的。

+   当将无类型常量或文本分配给变量时，如果默认类型不是你想要的变量类型，请使用带有指定类型的长形式 `var`。虽然使用类型转换来指定值的类型并使用 `:=` 来写 `x := byte(20)` 是合法的，但习惯上写成 `var x byte = 20`。

+   因为 `:=` 允许你对新变量和现有变量进行赋值，有时当你认为在重用现有变量时它会创建新变量（详见“变量屏蔽”）。在这些情况下，使用 `var` 显式声明所有新变量，以明确表明哪些变量是新的，然后使用赋值运算符 (`=`) 为新变量和旧变量赋值。

虽然 `var` 和 `:=` 允许在同一行上声明多个变量，但仅在从函数返回多个值或使用逗号 ok 惯用法时使用这种风格（参见第 5 章 和 “逗号 ok 惯用法”）。

很少在函数外部声明变量，即所谓的*包块*（参见“块”）。值会改变的包级变量是一个坏主意。当你在函数外部有一个变量时，很难追踪其所做的更改，这使得理解数据如何在程序中流动变得困难。这可能导致隐含的错误。一般规则是，只在包块中声明那些实际上是不可变的变量。

###### 提示

避免在函数外部声明变量，因为它们会使数据流分析变得复杂。

你可能会想知道：Go 是否提供了确保值不可变的方法？答案是肯定的，但它与你在其他编程语言中见过的方式有些不同。现在是学习 `const` 的时候了。

# 使用 `const`

许多语言都有一种声明值为不可变的方法。在 Go 中，可以使用 `const` 关键字实现。乍一看，它似乎与其他语言中的方式完全相同。尝试在示例 2-4 中的代码中使用 [Go Playground](https://oreil.ly/FdG-W) 或 [第二章存储库](https://oreil.ly/QxTTT) 中的 *sample_code/const_declaration* 目录。

##### 示例 2-4\. `const` 声明

```go
package main

import "fmt"

const x int64 = 10

const (
    idKey   = "id"
    nameKey = "name"
)

const z = 20 * 10

func main() {
    const y = "hello"

    fmt.Println(x)
    fmt.Println(y)

    x = x + 1 // this will not compile!
    y = "bye" // this will not compile!
    fmt.Println(x)
    fmt.Println(y)
}
```

当你运行这段代码时，编译会失败，并显示以下错误消息：

```go
./prog.go:20:2: cannot assign to x (constant 10 of type int64)
./prog.go:21:2: cannot assign to y (untyped string constant "hello")
```

正如你所看到的，你可以在包级别或函数内部声明一个常量。与 `var` 类似，你可以（也应该）在一组括号中声明一组相关的常量。

请注意，在 Go 中，`const` 的功能非常有限。Go 中的常量是将文字值命名的一种方式。它们只能保存编译器在编译时能够确定的值。这意味着它们可以被分配：

+   数字文字值

+   `true` 和 `false`

+   字符串

+   Runes

+   内建函数 `complex`、`real`、`imag`、`len` 和 `cap` 返回的值

+   由操作符和前置值组成的表达式

###### 注意

我将在下一章中介绍 `len` 和 `cap` 函数。可以与 `const` 一起使用的另一个值称为 `iota`。在讨论在 Chapter 7 中创建自己的类型时，我会谈到 `iota`。

Go 不提供在运行时指定计算出的值为不可变的方法。例如，以下代码将无法编译，错误信息为 `x + y (value of type int) is not constant`：

```go
x := 5
y := 10
const z = x + y // this won't compile!
```

正如你将在下一章中看到的那样，Go 中没有不可变的数组、切片、映射或结构体，也无法声明结构体中的字段为不可变。这比听起来的限制要少。在函数内部，如果变量被修改，这是明确的，因此不可变性不那么重要。在 “Go Is Call by Value” 中，你将看到 Go 如何防止对作为参数传递给函数的变量进行修改。

###### 提示

在 Go 中，常量是将文字值命名的一种方式。在 Go 中，没有方法可以声明一个变量是不可变的。

# 类型化和非类型化常量

常量可以是类型化的或非类型化的。非类型化的常量与文字值完全相同；它没有自己的类型，但在无法推断出其他类型时使用默认类型。类型化常量只能直接分配给该类型的变量。

是否使常量类型化取决于常量声明的原因。如果你为一个可能与多种数值类型一起使用的数学常量命名，保持常量为非类型化是合适的。通常情况下，保持常量为非类型化可以提供更大的灵活性。在某些情况下，你会希望常量强制类型化。当我在 “iota Is for Enumerations—Sometimes” 中讨论使用 `iota` 进行枚举时，你将看到一种对类型化常量的用法。

下面是非类型化常量声明的样子：

```go
const x = 10
```

以下所有的赋值都是合法的：

```go
var y int = x
var z float64 = x
var d byte = x
```

下面是类型化常量声明的样子：

```go
const typedX int = 10
```

这个常量只能直接分配给一个 `int`。将其分配给任何其他类型会产生编译时错误，如下所示：

```go
cannot use typedX (type int) as type float64 in assignment
```

# 未使用的变量

Go 的一个目标是使大型团队更容易协作开发程序。为此，Go 有一些编程语言中独特的规则。在第一章中，你看到 Go 程序需要使用`go fmt`按照特定方式格式化，以便更轻松地编写代码操作工具并提供编码标准。另一个 Go 的要求是*每个声明的局部变量都必须被读取*。声明局部变量但不读取其值是*编译时错误*。

编译器对未使用的变量检查并不彻底。只要变量被读取一次，编译器就不会抱怨，即使有写入变量而从未被读取的情况。你可以在[Go Playground](https://oreil.ly/8JLA6)上或[第二章存储库](https://oreil.ly/FqALl)的*sample_code/assignments_not_read*目录中运行以下有效的 Go 程序：

```go
func main() {
    x := 10 // this assignment isn't read!
    x = 20
    fmt.Println(x)
    x = 30 // this assignment isn't read!
}
```

虽然编译器和`go vet`不能捕获对`x`分配值为 10 和 30 的未使用情况，但第三方工具可以检测到它们。我会在“使用代码质量扫描工具”中讨论这些工具。

###### 注意

Go 编译器不会阻止你创建未读的包级别变量。这是你应该避免创建包级别变量的另一个理由。

# 命名变量和常量

Go 对命名变量的规则与 Go 开发者在命名变量和常量时遵循的模式之间存在差异。与大多数语言一样，Go 要求标识符名称以字母或下划线开头，名称可以包含数字、下划线和字母。Go 对“字母”和“数字”的定义比许多语言宽泛一些。任何被认为是字母或数字的 Unicode 字符都是允许的。这使得示例 2-5 中所有变量定义都是完全有效的 Go 代码。

##### 示例 2-5\. 绝对不应该使用的变量名

```go
_0 := 0_0
_𝟙 := 20
π := 3
ａ := "hello" // Unicode U+FF41
__ := "double underscore" // two underscores
fmt.Println(_0)
fmt.Println(_𝟙)
fmt.Println(π)
fmt.Println(ａ)
fmt.Println(__)

```

你可以在[Go Playground](https://oreil.ly/VIYOk)上测试这段糟糕的代码。虽然它可以工作，但*不要*使用这样的变量名。这些名称被认为不符合习惯，因为它们违反了确保代码传达其功能的基本规则。这些名称令人困惑，或在许多键盘上难以输入。类似的 Unicode 代码点是最阴险的，因为即使它们看起来是相同的字符，它们代表的是完全不同的变量。你可以在[Go Playground](https://oreil.ly/hrvb6)上或[第二章存储库](https://oreil.ly/7nLfx)的*sample_code/look_alike_code_points*目录中运行所示代码。

##### 示例 2-6\. 使用类似代码点作为变量名

```go
func main() {
    ａ := "hello"   // Unicode U+FF41
    a := "goodbye" // standard lowercase a (Unicode U+0061)
    fmt.Println(ａ)
    fmt.Println(a)
}

```

当你运行这个程序时，你会得到：

```go
hello
goodbye
```

即使下划线在变量名中是有效的字符，但它很少被使用，因为 Go 语言习惯不使用蛇形命名法（例如 `index_counter` 或 `number_tries`）。相反，Go 语言习惯使用驼峰命名法（例如 `indexCounter` 或 `numberTries`），当标识符名称由多个单词组成时。

###### 注意

在 Go 中，下划线本身 (`_`) 是一个特殊的标识符名称；在讲解第五章（Chapter 5）中函数时，我会更详细地讨论它。

在许多语言中，常量总是使用全部大写字母编写，用下划线分隔单词（例如 `INDEX_COUNTER` 或 `NUMBER_TRIES`）。但 Go 语言不遵循此模式。这是因为 Go 使用包级声明名称的首字母大小写来确定该项是否可以在包外部访问。在讲解第十章（Chapter 10）时，我会重新讨论这一点。

在函数内部，更倾向于使用短变量名。*变量的作用域越小，其名称就越短*。在 Go 语言中，常见于 `for` 循环中使用单个字母作为变量名。例如，在 `for-range` 循环中，变量名 `k` 和 `v`（分别代表*键*和*值*）被用作变量名。如果使用标准的 `for` 循环，`i` 和 `j` 是常见的索引变量名。对于常见类型的变量，还有其他习惯用法来命名；随着我讲解标准库的更多部分，我会提到它们。

一些类型系统较弱的语言鼓励开发者在变量名中包含变量的预期类型。由于 Go 语言是强类型的，你不需要这样做来跟踪底层类型。然而，你可能会看到 Go 代码中使用类型的首字母作为变量名（例如 `i` 表示整数或 `f` 表示浮点数）。当你定义自己的类型时，类似的模式同样适用，特别是在命名接收器变量时（这在“方法”中讨论）。

这些短名称有两个目的。首先，它们消除了重复输入，使你的代码更简洁。其次，它们作为检查代码复杂性的一种方式。如果你发现很难跟踪你的短命名变量，那么你的代码块可能做得太多了。

在包块中命名变量和常量时，使用更具描述性的名称。名称仍然应该不包含类型，但由于作用域更广，你需要一个更完整的名称来澄清值代表的含义。

想要了解更多关于 Go 命名建议的讨论，请阅读[Google Go 风格决策的命名部分](https://oreil.ly/6AUc_)。

# 练习

这些练习演示了本章讨论的概念。这些练习的解答以及本章的程序位于[第二章的存储库](https://oreil.ly/nGUVd)中。

1.  编写一个程序，声明一个名为`i`且值为 20 的整数变量。将`i`赋给名为`f`的浮点变量。打印出`i`和`f`。

1.  编写一个程序，声明一个名为`value`的常量，它可以分配给整数和浮点变量。将其分配给一个名为`i`的整数和一个名为`f`的浮点变量。打印出`i`和`f`。

1.  编写一个具有三个变量的程序，一个名为`b`且类型为`byte`，一个名为`smallI`且类型为`int32`，一个名为`bigI`且类型为`uint64`。为每种类型的变量分配其类型的最大合法值；然后将每个变量加`1`。打印出它们的值。

# 总结

在这里，你已经涵盖了很多内容，理解了如何使用预声明类型，声明变量以及如何使用赋值和运算符。在下一章中，我们将看看 Go 语言中的复合类型：数组、切片、映射和结构体。我们还将再次查看字符串和符文以及它们与字符编码的交互。
