# 目录（真实版本）

+   如何使用这本书：介绍

    **Go 语言的奥秘**。

    在这里*你*试图*学习*一些东西，而你的*大脑*却在这里帮你，确保学习不*粘*。你的大脑在思考，“最好为更重要的事情留出空间，比如避免哪些野生动物以及裸体滑雪是否是个坏主意。”那么*你*如何骗过你的大脑，让它觉得你的生活取决于学会如何用 Go 语言编程？

    +   “这本书是为谁准备的？”

    +   “我们知道你在想什么”

    +   “我们知道你的大脑在想什么”

    +   “元认知：思考思考”

    +   “这是我们做的”

    +   “阅读我”

    +   “致谢”

+   第一章

    **你准备好了要为你的软件加速了吗？**

    你想要一个**简单**的编程语言，**编译快**吗？**运行快**吗？让你**轻松分发**你的工作给用户吗？那么**你已经准备好使用 Go 语言了！**

    Go 是一种专注于**简单性**和**速度**的编程语言。它比其他语言更简单，因此学习速度更快。它还能让你利用今天的多核处理器的强大性能，因此你的程序运行得更快。本章将向你展示所有能让**开发者生活更轻松**，使**用户更满意**的 Go 特性。

    +   “准备，开始，Go！”

    +   “Go Playground”

    +   “这一切意味着什么？”

    +   “如果出了问题怎么办？”

    +   “调用函数”

    +   “Println 函数”

    +   “使用其他包中的函数”

    +   “函数返回值”

    +   “一个 Go 程序模板”

    +   “字符串”

    +   “符文”

    +   “布尔值”

    +   “数字”

    +   “数学运算和比较”

    +   “类型”

    +   “声明变量”

    +   “零值”

    +   “短变量声明”

    +   “命名规则”

    +   “类型转换”

    +   “在你的计算机上安装 Go”

    +   “Go 代码的编译”

    +   “Go 工具”

    +   “使用“go run”快速测试代码”

    +   “你的 Go 工具箱”

+   第二章

    **每个程序都有只在特定情况下适用的部分。**

    “当出现错误时，应运行此代码。否则，应运行其他代码。” 几乎每个程序都包含只有在特定条件为真时才应运行的代码。因此，几乎每种编程语言都提供了让你确定是否运行代码片段的**条件语句**。Go 也不例外。

    你可能还需要使部分代码*重复运行*。与大多数语言一样，Go 提供了能够多次运行代码段的**循环**。我们将在本章学习如何同时使用条件语句和循环！

    +   “调用方法”

    +   “成绩的制作”

    +   “函数或方法的多返回值”

    +   “选项 1：使用空白标识符忽略错误返回值”

    +   “选项 2：处理错误”

    +   “条件语句”

    +   “有条件地记录致命错误”

    +   “避免名称重叠”

    +   “将字符串转换为数字”

    +   “区块”

    +   “区块和变量作用域”

    +   “我们已完成评分程序！”

    +   “短变量声明中只需一个变量是新的”

    +   “让我们来制作一个游戏”

    +   “包名称与导入路径”

    +   “生成随机数”

    +   “从键盘获取整数”

    +   “将猜测与目标进行比较”

    +   “循环”

    +   “初始化和后置语句是可选的”

    +   “在猜数字游戏中使用循环”

    +   “退出我们的猜测循环”

    +   “揭示目标”

    +   “恭喜，你的游戏完成了！”

    +   “你的 Go 工具箱”

+   第三章

    **你一直错过了**。

    你已经像专业人士一样调用函数了。但是你只能调用 Go 为你定义的函数。现在轮到你了。我们将向你展示如何创建自己的函数。我们将学习如何声明带有和不带有参数的函数。我们将声明返回单个值的函数，并学习如何返回多个值以便在出现错误时进行指示。我们还将学习关于**指针**，它们允许我们进行更高效的内存管理函数调用。

    +   “一些重复的代码”

    +   “使用 Printf 和 Sprintf 格式化输出”

    +   “格式化动词”

    +   “格式化值宽度”

    +   “格式化小数数宽度”

    +   “在我们的油漆计算器中使用 Printf”

    +   “声明函数”

    +   “声明函数参数”

    +   “在我们的油漆计算器中使用函数”

    +   “函数和变量作用域”

    +   “函数返回值”

    +   “在我们的油漆计算器中使用返回值”

    +   “paintNeeded 函数需要错误处理”

    +   “错误值”

    +   “声明多返回值”

    +   “在我们的 paintNeeded 函数中使用多返回值”

    +   “始终处理错误！”

    +   “函数参数接收参数的副本”

    +   “指针”

    +   “指针类型”

    +   “获取或更改指针处的值”

    +   “在函数中使用指针”

    +   “使用指针修复我们的“double”函数”

    +   “你的 Go 工具箱”

+   第四章

    **现在是组织的时候**。

    到目前为止，我们把所有的代码都混在一个文件里。随着程序变得越来越大和复杂，这很快会变得一团糟。

    在本章中，我们将向您展示如何创建自己的**包**，以帮助将相关代码集中在一个地方。但包不仅仅是组织代码的好方法。包还是在您的程序之间*共享代码*的简便方式。它们还是*与其他开发者共享代码*的简便方式。

    +   “不同的程序，相同的函数”

    +   “Sharing code between programs using packages”

    +   “The Go workspace directory holds package code”

    +   “Creating a new package”

    +   “Importing our package into a program”

    +   “Packages use the same file layout”

    +   “Package naming conventions”

    +   “Package qualifiers”

    +   “Moving our shared code to a package”

    +   “Constants”

    +   “Nested package directories and import paths”

    +   “Installing program executables with “go install””

    +   “Changing workspaces with the GOPATH environment variable”

    +   “Setting GOPATH”

    +   “Publishing packages”

    +   “Downloading and installing packages with “go get””

    +   “Reading package documentation with “go doc””

    +   “Documenting your packages with doc comments”

    +   “Viewing documentation in a web browser”

    +   “Serving HTML documentation to yourself with “godoc””

    +   “The “godoc” server includes YOUR packages!”

    +   “Your Go Toolbox”

+   Chapter 5

    **有许多程序处理各种列表**。

    -   列表的地址。电话号码的列表。产品的列表。Go 有*两种*内置的列表存储方式。本章将介绍第一种：**数组**。您将学习如何创建数组，如何向数组填充数据以及如何再次获取这些数据。然后您将学习如何处理数组中的所有元素，首先是用`for`循环的*繁琐*方法，然后是用`for`…`range`循环的*简单*方法。

    +   “Arrays hold collections of values”

    +   “Zero values in arrays”

    +   “Array literals”

    +   “Functions in the “fmt” package know how to handle arrays”

    +   “Accessing array elements within a loop”

    +   “Checking array length with the “len” function”

    +   “Looping over arrays safely with “for...range””

    +   “Using the blank identifier with “for...range” loops”

    +   “计算数组中数字的总和”

    +   “计算数组中数字的平均值”

    +   “读取文本文件”

    +   “将文本文件读入数组”

    +   “更新我们的“average”程序以读取文本文件”

    +   “我们的程序只能处理三个值！”

    +   “你的 Go 工具箱”

+   第六章

    **我们学到了，无法向数组添加更多元素**。

    我们程序的一个真正问题是，因为我们事先不知道文件包含多少数据片段，这对我们的程序来说是个问题。但这就是 Go **切片**派上用场的地方。切片是一种集合类型，可以扩展以容纳额外的项——这正是修复当前程序的方法！我们还会看到切片如何为用户提供更轻松的方式来提供数据给*所有*你的程序，并且如何帮助你编写更方便调用的函数。

    +   “切片”

    +   “切片字面量”

    +   “切片操作符”

    +   “底层数组”

    +   “更改基础数组，更改切片”

    +   “使用“append”函数添加到切片”

    +   “切片和零值”

    +   “使用切片和“append”读取额外文件行”

    +   “尝试我们改进的程序”

    +   “在发生错误时返回一个空切片”

    +   “命令行参数”

    +   “从 os.Args 切片获取命令行参数”

    +   “切片操作符可以用在其他切片上”

    +   “更新我们的程序以使用命令行参数”

    +   “可变参数函数”

    +   “使用可变参数函数”

    +   “使用可变参数函数计算平均值”

    +   “向可变参数函数传递切片”

    +   “切片拯救了全局！”

    +   “你的 Go 工具箱”

+   第七章

    **把东西扔到一堆里没问题，直到你需要再找出来**。

    你已经学会如何使用*数组*和*切片*创建值列表。你也学会了如何对数组或切片中的*每个值*应用相同的操作。但是如果你需要处理一个*特定的*值呢？你需要从数组或切片的开头开始，逐个查找每个值。

    如果有一种集合，每个值上都有一个标签，你可以快速找到你需要的值！本章我们将介绍**映射**，它正是做这件事情的。

    +   “计数投票”

    +   “从文件中读取名字”

    +   “以切片方式艰难计数名字”

    +   “映射”

    +   “映射字面量”

    +   “映射内的零值”

    +   “映射变量的零值是 nil”

    +   “如何区分零值和已赋值的值”

    +   “使用‘delete’函数删除键/值对”

    +   “更新我们的投票计数程序以使用映射”

    +   “使用 for...range 循环处理映射”

    +   “for...range 循环处理映射时会随机顺序处理！”

    +   “使用 for...range 循环更新我们的投票计数程序”

    +   “投票计数程序已完成！”

    +   “你的 Go 工具箱”

+   第八章

    **有时你需要存储不止一种类型的数据**。

    我们学习了切片，它们存储一系列的值。然后我们学习了映射，它们将一系列的键映射到一系列的值。但是这两种数据结构只能存储*一种*类型的值。有时候，你需要将*多种*类型的值组合在一起。比如邮寄地址，你需要将街道名称（字符串）和邮政编码（整数）混合在一起。或者学生档案，你需要将学生姓名（字符串）和平均学分绩点（浮点数）混合在一起。在切片或映射中无法混合值类型。但是如果使用另一种叫做**结构体**的类型，是可以的。本章我们将详细学习结构体！

    +   “切片和映射只能持有一种类型的值”

    +   “结构体由许多类型的值构建而成”

    +   “使用点运算符访问结构字段”

    +   “在结构体中存储订阅者数据”

    +   “定义类型和结构体”

    +   “使用定义类型来管理杂志订阅者”

    +   “使用定义类型与函数”

    +   “使用函数修改结构体”

    +   “通过指针访问结构体字段”

    +   “使用指针传递大型结构体”

    +   “将我们的结构体类型移动到另一个包中”

    +   “定义类型的名称必须大写才能导出”

    +   “结构体字段名称必须大写才能导出”

    +   “结构体字面量”

    +   “创建雇员结构体类型”

    +   “创建地址结构体类型”

    +   “将结构体作为另一种类型的字段添加”

    +   “在另一个结构体中设置结构体”

    +   “匿名结构字段”

    +   “嵌入结构体”

    +   “我们的定义类型已经完成！”

    +   “你的 Go 工具箱”

+   第九章

    **关于定义类型，还有更多知识等待学习**。

    在上一章中，我们向你展示了如何定义一个带有结构体底层类型的类型。但是我们*没有*向你展示的是，你可以使用*任何*类型作为底层类型。

    并且你还记得方法吗——那种特殊类型的函数，与特定类型的值相关联？我们在整本书中一直在各种值上调用方法，但我们还没有向你展示如何定义*自己的*方法。在本章中，我们将解决这一切。让我们开始吧！

    +   “真实生活中的类型错误”

    +   “带有基础类型的定义类型”

    +   “定义类型和运算符”

    +   “使用函数进行类型转换”

    +   “使用方法修复函数名称冲突”

    +   “定义方法”

    +   “接收器参数基本上就是另一个参数”

    +   “方法与函数基本相同”

    +   “指针接收器参数”

    +   “使用方法将升和毫升转换为加仑”

    +   “使用方法将加仑转换为升和毫升”

    +   “你的 Go 工具箱”

+   第十章

    **错误是难免的**。

    有时，您的程序会从用户输入、读取的文件或其他地方接收到无效数据。在本章中，您将了解**封装**：一种保护结构类型字段免受无效数据影响的方式。这样，您就可以确保字段数据是安全的，可以正常使用！

    我们还会向您展示如何**嵌入**其他类型到您的结构类型中。如果您的结构类型需要其他类型已有的方法，您不需要复制和粘贴方法代码。您可以将其他类型嵌入到您的结构类型中，然后像使用自己类型上定义的方法一样使用嵌入类型的方法！

    +   “创建一个日期结构类型”

    +   “人们正在将日期结构字段设置为无效值！”

    +   “Setter 方法”

    +   “Setter 方法需要指针接收器”

    +   “添加其余的 setter 方法”

    +   “为 setter 方法添加验证”

    +   “字段仍然可以设置为无效值！”

    +   “将日期类型移动到另一个包”

    +   “使日期字段非公开”

    +   “通过公开方法访问非公开字段”

    +   “Getter 方法”

    +   “封装”

    +   “在事件类型中嵌入日期类型”

    +   “非公开字段不会被提升”

    +   “公开方法会像字段一样被提升”

    +   “封装事件标题字段”

    +   “提升的方法与外部类型的方法并存”

    +   “我们的日历包已经完成！”

    +   “你的 Go 工具箱”

+   第十一章

    **有时您不关心值的具体类型**。

    您不关心它是*什么*。您只需要知道它将能够*做*某些事情。您只需要知道您可以在其上调用*某些方法*。您不关心是否有一支`Pen`还是一支`Pencil`，您只需要拥有一个具有`Draw`方法的东西。您不关心是否有一辆`Car`还是一艘`Boat`，您只需要拥有一个具有`Steer`方法的东西。

    Go **接口**实现了这一点。它允许您定义变量和函数参数，这些变量和参数可以持有*任何*类型，只要该类型定义了特定的方法。

    +   “具有相同方法的两种不同类型”

    +   “仅接受一种类型的方法参数”

    +   “接口”

    +   “定义满足接口的类型”

    +   “具体类型，接口类型”

    +   “分配任何满足接口的类型”

    +   “只能调用作为接口一部分定义的方法”

    +   “使用接口修复我们的 playList 函数”

    +   “类型断言”

    +   “类型断言失败”

    +   “在类型断言失败时避免 panic”

    +   “使用类型断言测试 TapePlayers 和 TapeRecorders”

    +   ““error” 接口”

    +   “Stringer 接口”

    +   “空接口”

    +   “您的 Go 工具箱”

+   第十二章

    **每个程序都会遇到错误。您应该为它们做好准备**。

    有时候处理错误可能就像报告并退出程序那样简单。但是其他错误可能需要额外的操作。您可能需要关闭已打开的文件或网络连接，或者进行其他清理工作，以确保您的程序不会留下混乱。在本章中，我们将向您展示如何**延迟**清理操作，以便即使出现错误，也能执行这些操作。我们还将向您展示如何在适当的情况下使您的程序**panic**，以及如何在之后**recover**。

    +   “重新访问从文件读取数字”

    +   “任何错误都将阻止文件关闭！”

    +   “延迟函数调用”

    +   “使用延迟函数调用从错误中恢复”

    +   “使用延迟函数调用确保文件被关闭”

    +   “列出目录中的文件”

    +   “列出子目录中的文件（将更加棘手）”

    +   “递归函数调用”

    +   “递归列出目录内容”

    +   “递归函数中的错误处理”

    +   “引发 panic”

    +   “堆栈跟踪”

    +   “在崩溃前完成延迟调用”

    +   “在 scanDirectory 中使用“panic””

    +   “何时使用 panic”

    +   ““recover”函数”

    +   “从 recover 中返回 panic 值”

    +   “在 scanDirectory 中从 panic 中恢复”

    +   “重新引发 panic”

    +   “你的 Go 工具箱”

+   第十三章

    **一次只处理一件事情并不总是完成任务的最快方式**。

    一些大问题可以分解成更小的任务。**Goroutines** 让你的程序可以同时处理几个不同的任务。你的 goroutines 可以使用**channels**来协调它们的工作，这使它们可以向彼此发送数据 *并且* 同步，以确保一个 goroutine 不会领先于另一个。Goroutines 让你充分利用具有多个处理器的计算机，从而使你的程序运行速度尽可能快！

    +   “检索网页”

    +   “多任务”

    +   “使用 goroutines 进行并发”

    +   “使用 goroutine”

    +   “在我们的 responseSize 函数中使用 goroutines”

    +   “我们不能直接控制 goroutines 何时运行”

    +   “无法在 return 语句中使用 Go 语句返回值”

    +   “使用 channels 发送和接收值”

    +   “使用 channels 同步 goroutines”

    +   “观察 goroutine 同步”

    +   “使用 channels 修复我们的网页大小程序”

    +   “更新我们的 channel 以传递一个结构体”

    +   “你的 Go 工具箱”

+   第十四章

    -   您确定您的软件现在正常工作吗？真的确定吗？

    在将新版本发送给用户之前，您可能已经尝试过新功能，以确保它们都正常工作。但是您有没有尝试过*旧*功能，以确保没有破坏其中任何一个？*所有*的旧功能？如果这个问题让您担心，那么您的程序需要**自动化测试**。自动化测试确保您程序的组件在您修改代码后仍然正常工作。Go 语言的`testing`包和`go test`工具使编写自动化测试变得轻松，利用您已经学到的技能！

    +   “自动化测试在其他人发现之前找到您的 bug”

    +   “我们本应该为之编写自动化测试的函数”

    +   “我们引入了一个 bug！”

    +   “编写测试”

    +   “使用“go test”命令运行测试”

    +   “测试我们实际返回的值”

    +   “使用“Errorf”方法获取更详细的测试失败消息”

    +   “测试“助手”函数”

    +   “通过“go test”命令使测试通过”

    +   “测试驱动开发”

    +   “另一个要修复的 bug”

    +   “运行特定测试集”

    +   “基于表格的测试”

    +   “使用测试修复恐慌性代码”

    +   “您的 Go 工具箱”

+   第十五章

    -   这是 21 世纪。用户需要 Web 应用程序。

    Go 还包括帮助您托管自己的 Web 应用程序并使其可从任何 Web 浏览器访问的包。因此，我们将在本书的最后两章中向您展示如何构建 Web 应用程序。

    您的 Web 应用程序首先需要能够在浏览器发送请求时做出响应的能力。在本章中，我们将学习使用`net/http`包来实现这一点。

    +   “使用 Go 编写 Web 应用程序”

    +   “浏览器、请求、服务器和响应”

    +   “一个简单的 Web 应用程序”

    +   “您的计算机正在与自己交流”

    +   “我们的简单 Web 应用程序，解释”

    +   “资源路径”

    +   “针对不同资源路径作出不同响应”

    +   “一流函数”

    +   “将函数作为类型传递给其他函数”

    +   “将函数作为类型”

    +   “接下来的步骤”

    +   “您的 Go 工具箱”

+   “更新我们的模板以包含我们的签名”

    “从文件中读取签名片段的切片”

    电子邮件和社交媒体帖子可以使用纯文本。但是您的页面需要格式化。它们需要标题和段落。它们需要表单，让用户向您的应用程序提交数据。要做到这些，您需要 HTML 代码。

    最终，您需要在 HTML 代码中插入数据。这就是为什么 Go 提供了`html/template`包的原因，这是在您的应用程序 HTML 响应中包含数据的强大方法。模板是构建更大更好的 Web 应用程序的关键，在这一最后一章中，我们将向您展示如何使用它们！

    +   “留言板应用程序”

    +   “处理请求并检查错误的函数”

    +   “建立项目目录并尝试应用程序”

    +   “在 HTML 中制作签名列表”

    +   “使我们的应用程序响应 HTML”

    +   ““text/template”包”

    +   “使用模板的 Execute 方法和 io.Writer 接口”

    +   “ResponseWriters 和 os.Stdout 都满足 io.Writer 接口”

    +   “使用操作将结构体字段插入模板”

    +   “通过“if”操作使模板的部分内容可选”

    +   “通过“range”操作重复模板的部分内容”

    +   “从请求中获取表单字段的值”

    +   **您的 Web 应用程序需要以 HTML 方式响应，而不是纯文本。**

    +   “用于保存签名和签名计数的结构体”

    +   第十六章

    +   “让用户使用 HTML 表单添加数据”

    +   “表单提交请求”

    +   “表单提交的路径和 HTTP 方法”

    +   “使用操作将数据插入模板”

    +   “保存表单数据”

    +   “HTTP 重定向”

    +   “我们完整的应用程序代码”

    +   “你的 Go 工具箱”

+   附录 A](app01.html#understanding_osdotopenfile_opening_file)

    **有些程序需要将数据写入文件，而不仅仅是读取数据。**

    在整本书中，当我们想要处理文件时，你必须在文本编辑器中创建它们，以便你的程序读取。但是一些程序会*生成*数据，当它们这样做时，它们需要能够*写入*数据到文件中。

    我们之前在书中使用了`os.OpenFile`函数来打开一个文件进行写入。但当时我们没有足够的空间来全面探讨它的工作原理。在这个附录中，我们将向你展示一切你需要了解的内容，以便有效地使用`os.OpenFile`！

    +   “理解 os.OpenFile”

    +   “向 os.OpenFile 传递标志常量”

    +   “二进制表示法”

    +   “按位运算符”

    +   “按位与运算符”

    +   “按位或运算符”

    +   “在“os”包常量上使用按位或”

    +   “使用按位或来修复我们的 os.OpenFile 选项”

    +   “类 Unix 文件权限”

    +   “用 os.FileMode 类型表示权限”

    +   “八进制表示法”

    +   “将八进制值转换为 FileMode 值”

    +   “对 os.OpenFile 的调用，解释”

+   附录 B](app02.html#six_things_we_didnapost_covercolon_Lefto)

    **我们已经覆盖了很多内容，你也快完成这本书了**。

    我们会想念你，但在让你离开之前，我们觉得还是有必要给你一点*额外的*准备。我们在这个附录中保存了六个重要的主题。

    +   “#1 “if”语句的初始化语句”

    +   “#2 switch 语句”

    +   “#3 更多基本类型”

    +   “#4 关于符文的更多信息”

    +   “#5 缓冲通道”

    +   “#6 进一步阅读”
